
STM32F072RB-Nucleo_MB1303_Provider_PD30.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000c56c  080000c0  080000c0  000100c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000001cc  0800c62c  0800c62c  0001c62c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  0800c7f8  0800c7f8  0001c7f8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  0800c7fc  0800c7fc  0001c7fc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         000002cc  20000000  0800c800  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00001a60  200002cc  0800cacc  000202cc  2**2
                  ALLOC
  7 ._user_heap_stack 00000804  20001d2c  0800cacc  00021d2c  2**0
                  ALLOC
  8 .ARM.attributes 0000002e  00000000  00000000  000202cc  2**0
                  CONTENTS, READONLY
  9 .debug_line   00020714  00000000  00000000  000202fa  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   000418a4  00000000  00000000  00040a0e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000777e  00000000  00000000  000822b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00001c20  00000000  00000000  00089a30  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000a073a  00000000  00000000  0008b650  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00002788  00000000  00000000  0012bd90  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00015bb3  00000000  00000000  0012e518  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  000204b7  00000000  00000000  001440cb  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      00000f98  00000000  00000000  00164582  2**0
                  CONTENTS, READONLY
 18 .iar.rtmodel  000000c9  00000000  00000000  0016551a  2**0
                  CONTENTS, READONLY
 19 .iar_vfe_header 0000000c  00000000  00000000  001655e4  2**2
                  CONTENTS, READONLY
 20 .debug_frame  00006e40  00000000  00000000  001655f0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	200002cc 	.word	0x200002cc
 80000e0:	00000000 	.word	0x00000000
 80000e4:	0800c614 	.word	0x0800c614

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	200002d0 	.word	0x200002d0
 8000104:	0800c614 	.word	0x0800c614

08000108 <USBPD_CAD_Init>:
 8000108:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800010a:	0007      	movs	r7, r0
 800010c:	000c      	movs	r4, r1
 800010e:	0015      	movs	r5, r2
 8000110:	001e      	movs	r6, r3
 8000112:	2801      	cmp	r0, #1
 8000114:	d830      	bhi.n	8000178 <USBPD_CAD_Init+0x70>
 8000116:	200c      	movs	r0, #12
 8000118:	f00c f9de 	bl	800c4d8 <malloc>
 800011c:	0002      	movs	r2, r0
 800011e:	4841      	ldr	r0, [pc, #260]	; (8000224 <.text_6>)
 8000120:	00b9      	lsls	r1, r7, #2
 8000122:	1841      	adds	r1, r0, r1
 8000124:	604a      	str	r2, [r1, #4]
 8000126:	2a00      	cmp	r2, #0
 8000128:	d101      	bne.n	800012e <USBPD_CAD_Init+0x26>
 800012a:	2003      	movs	r0, #3
 800012c:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 800012e:	9600      	str	r6, [sp, #0]
 8000130:	2300      	movs	r3, #0
 8000132:	2600      	movs	r6, #0
 8000134:	c248      	stmia	r2!, {r3, r6}
 8000136:	6013      	str	r3, [r2, #0]
 8000138:	7802      	ldrb	r2, [r0, #0]
 800013a:	1c52      	adds	r2, r2, #1
 800013c:	7002      	strb	r2, [r0, #0]
 800013e:	6848      	ldr	r0, [r1, #4]
 8000140:	9900      	ldr	r1, [sp, #0]
 8000142:	6001      	str	r1, [r0, #0]
 8000144:	7103      	strb	r3, [r0, #4]
 8000146:	6084      	str	r4, [r0, #8]
 8000148:	4837      	ldr	r0, [pc, #220]	; (8000228 <.text_7>)
 800014a:	6882      	ldr	r2, [r0, #8]
 800014c:	2301      	movs	r3, #1
 800014e:	6083      	str	r3, [r0, #8]
 8000150:	6881      	ldr	r1, [r0, #8]
 8000152:	2900      	cmp	r1, #0
 8000154:	d1fc      	bne.n	8000150 <USBPD_CAD_Init+0x48>
 8000156:	0029      	movs	r1, r5
 8000158:	4d34      	ldr	r5, [pc, #208]	; (800022c <.text_8>)
 800015a:	6005      	str	r5, [r0, #0]
 800015c:	6805      	ldr	r5, [r0, #0]
 800015e:	4e34      	ldr	r6, [pc, #208]	; (8000230 <.text_9>)
 8000160:	6035      	str	r5, [r6, #0]
 8000162:	6082      	str	r2, [r0, #8]
 8000164:	6882      	ldr	r2, [r0, #8]
 8000166:	4313      	orrs	r3, r2
 8000168:	6083      	str	r3, [r0, #8]
 800016a:	6863      	ldr	r3, [r4, #4]
 800016c:	9a00      	ldr	r2, [sp, #0]
 800016e:	0038      	movs	r0, r7
 8000170:	f009 f848 	bl	8009204 <CAD_Init>
 8000174:	2000      	movs	r0, #0
 8000176:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 8000178:	2001      	movs	r0, #1
 800017a:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

0800017c <USBPD_CAD_PortEnable>:
 800017c:	2802      	cmp	r0, #2
 800017e:	d204      	bcs.n	800018a <USBPD_CAD_PortEnable+0xe>
 8000180:	4a28      	ldr	r2, [pc, #160]	; (8000224 <.text_6>)
 8000182:	0080      	lsls	r0, r0, #2
 8000184:	1810      	adds	r0, r2, r0
 8000186:	6840      	ldr	r0, [r0, #4]
 8000188:	7101      	strb	r1, [r0, #4]
 800018a:	4770      	bx	lr

0800018c <USBPD_CAD_Process>:
 800018c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800018e:	b084      	sub	sp, #16
 8000190:	a802      	add	r0, sp, #8
 8000192:	bf00      	nop
 8000194:	a132      	add	r1, pc, #200	; (adr r1, 8000260 <.text_14>)
 8000196:	c90c      	ldmia	r1!, {r2, r3}
 8000198:	c00c      	stmia	r0!, {r2, r3}
 800019a:	2400      	movs	r4, #0
 800019c:	4d22      	ldr	r5, [pc, #136]	; (8000228 <.text_7>)
 800019e:	4e21      	ldr	r6, [pc, #132]	; (8000224 <.text_6>)
 80001a0:	e031      	b.n	8000206 <USBPD_CAD_Process+0x7a>
 80001a2:	68a8      	ldr	r0, [r5, #8]
 80001a4:	2101      	movs	r1, #1
 80001a6:	60a9      	str	r1, [r5, #8]
 80001a8:	68aa      	ldr	r2, [r5, #8]
 80001aa:	2a00      	cmp	r2, #0
 80001ac:	d1fc      	bne.n	80001a8 <USBPD_CAD_Process+0x1c>
 80001ae:	4a1f      	ldr	r2, [pc, #124]	; (800022c <.text_8>)
 80001b0:	602a      	str	r2, [r5, #0]
 80001b2:	4a1f      	ldr	r2, [pc, #124]	; (8000230 <.text_9>)
 80001b4:	682b      	ldr	r3, [r5, #0]
 80001b6:	6013      	str	r3, [r2, #0]
 80001b8:	60a8      	str	r0, [r5, #8]
 80001ba:	68a8      	ldr	r0, [r5, #8]
 80001bc:	4301      	orrs	r1, r0
 80001be:	60a9      	str	r1, [r5, #8]
 80001c0:	e018      	b.n	80001f4 <USBPD_CAD_Process+0x68>
 80001c2:	0620      	lsls	r0, r4, #24
 80001c4:	0d80      	lsrs	r0, r0, #22
 80001c6:	9001      	str	r0, [sp, #4]
 80001c8:	1d30      	adds	r0, r6, #4
 80001ca:	9901      	ldr	r1, [sp, #4]
 80001cc:	1847      	adds	r7, r0, r1
 80001ce:	6838      	ldr	r0, [r7, #0]
 80001d0:	7900      	ldrb	r0, [r0, #4]
 80001d2:	2801      	cmp	r0, #1
 80001d4:	d116      	bne.n	8000204 <USBPD_CAD_Process+0x78>
 80001d6:	aa00      	add	r2, sp, #0
 80001d8:	1c52      	adds	r2, r2, #1
 80001da:	4669      	mov	r1, sp
 80001dc:	b2e0      	uxtb	r0, r4
 80001de:	f00a fee3 	bl	800afa8 <CAD_StateMachine>
 80001e2:	a902      	add	r1, sp, #8
 80001e4:	9a01      	ldr	r2, [sp, #4]
 80001e6:	5088      	str	r0, [r1, r2]
 80001e8:	4668      	mov	r0, sp
 80001ea:	7800      	ldrb	r0, [r0, #0]
 80001ec:	2800      	cmp	r0, #0
 80001ee:	d009      	beq.n	8000204 <USBPD_CAD_Process+0x78>
 80001f0:	2801      	cmp	r0, #1
 80001f2:	d0d6      	beq.n	80001a2 <USBPD_CAD_Process+0x16>
 80001f4:	4668      	mov	r0, sp
 80001f6:	7842      	ldrb	r2, [r0, #1]
 80001f8:	7801      	ldrb	r1, [r0, #0]
 80001fa:	b2e0      	uxtb	r0, r4
 80001fc:	683b      	ldr	r3, [r7, #0]
 80001fe:	689b      	ldr	r3, [r3, #8]
 8000200:	681b      	ldr	r3, [r3, #0]
 8000202:	4798      	blx	r3
 8000204:	1c64      	adds	r4, r4, #1
 8000206:	7830      	ldrb	r0, [r6, #0]
 8000208:	b2e1      	uxtb	r1, r4
 800020a:	4281      	cmp	r1, r0
 800020c:	d3d9      	bcc.n	80001c2 <USBPD_CAD_Process+0x36>
 800020e:	2801      	cmp	r0, #1
 8000210:	d101      	bne.n	8000216 <USBPD_CAD_Process+0x8a>
 8000212:	9802      	ldr	r0, [sp, #8]
 8000214:	e004      	b.n	8000220 <USBPD_CAD_Process+0x94>
 8000216:	9803      	ldr	r0, [sp, #12]
 8000218:	9902      	ldr	r1, [sp, #8]
 800021a:	4288      	cmp	r0, r1
 800021c:	d300      	bcc.n	8000220 <USBPD_CAD_Process+0x94>
 800021e:	4608      	mov	r0, r1
 8000220:	b005      	add	sp, #20
 8000222:	bdf0      	pop	{r4, r5, r6, r7, pc}

08000224 <.text_6>:
 8000224:	200019dc 	.word	0x200019dc

08000228 <.text_7>:
 8000228:	40023000 	.word	0x40023000

0800022c <.text_8>:
 800022c:	f407a5c2 	.word	0xf407a5c2

08000230 <.text_9>:
 8000230:	200019f8 	.word	0x200019f8

08000234 <USBPD_CAD_AssertRd>:
 8000234:	b510      	push	{r4, lr}
 8000236:	0004      	movs	r4, r0
 8000238:	f00a f843 	bl	800a2c2 <USBPDM1_DeAssertRp>
 800023c:	0020      	movs	r0, r4
 800023e:	f00a f841 	bl	800a2c4 <USBPDM1_AssertRd>
 8000242:	bd10      	pop	{r4, pc}

08000244 <USBPD_CAD_AssertRp>:
 8000244:	b510      	push	{r4, lr}
 8000246:	0004      	movs	r4, r0
 8000248:	f00a f83d 	bl	800a2c6 <USBPDM1_DeAssertRd>
 800024c:	0020      	movs	r0, r4
 800024e:	f00a f837 	bl	800a2c0 <USBPDM1_AssertRp>
 8000252:	bd10      	pop	{r4, pc}

08000254 <USBPD_CAD_EnterErrorRecovery>:
 8000254:	b580      	push	{r7, lr}
 8000256:	f008 fff9 	bl	800924c <CAD_Enter_ErrorRecovery>
 800025a:	bd01      	pop	{r0, pc}

0800025c <USBPD_CAD_GetMemoryConsumption>:
 800025c:	2018      	movs	r0, #24
 800025e:	4770      	bx	lr

08000260 <.text_14>:
 8000260:	00000002 	.word	0x00000002
 8000264:	00000002 	.word	0x00000002

08000268 <USBPD_PE_Init>:
 8000268:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
 800026a:	b083      	sub	sp, #12
 800026c:	0017      	movs	r7, r2
 800026e:	001d      	movs	r5, r3
 8000270:	4668      	mov	r0, sp
 8000272:	7b06      	ldrb	r6, [r0, #12]
 8000274:	2e01      	cmp	r6, #1
 8000276:	d838      	bhi.n	80002ea <USBPD_PE_Init+0x82>
 8000278:	20e6      	movs	r0, #230	; 0xe6
 800027a:	0080      	lsls	r0, r0, #2
 800027c:	f00c f92c 	bl	800c4d8 <malloc>
 8000280:	499b      	ldr	r1, [pc, #620]	; (80004f0 <.text_10>)
 8000282:	466a      	mov	r2, sp
 8000284:	7b12      	ldrb	r2, [r2, #12]
 8000286:	0092      	lsls	r2, r2, #2
 8000288:	5088      	str	r0, [r1, r2]
 800028a:	0004      	movs	r4, r0
 800028c:	d101      	bne.n	8000292 <USBPD_PE_Init+0x2a>
 800028e:	2016      	movs	r0, #22
 8000290:	e073      	b.n	800037a <USBPD_PE_Init+0x112>
 8000292:	9500      	str	r5, [sp, #0]
 8000294:	9d04      	ldr	r5, [sp, #16]
 8000296:	21e6      	movs	r1, #230	; 0xe6
 8000298:	0089      	lsls	r1, r1, #2
 800029a:	f00c f8ed 	bl	800c478 <__aeabi_memclr>
 800029e:	6025      	str	r5, [r4, #0]
 80002a0:	6067      	str	r7, [r4, #4]
 80002a2:	2701      	movs	r7, #1
 80002a4:	68e0      	ldr	r0, [r4, #12]
 80002a6:	43b8      	bics	r0, r7
 80002a8:	403e      	ands	r6, r7
 80002aa:	4306      	orrs	r6, r0
 80002ac:	60e6      	str	r6, [r4, #12]
 80002ae:	9800      	ldr	r0, [sp, #0]
 80002b0:	60a0      	str	r0, [r4, #8]
 80002b2:	2600      	movs	r6, #0
 80002b4:	498f      	ldr	r1, [pc, #572]	; (80004f4 <.text_11>)
 80002b6:	1861      	adds	r1, r4, r1
 80002b8:	704e      	strb	r6, [r1, #1]
 80002ba:	6820      	ldr	r0, [r4, #0]
 80002bc:	6801      	ldr	r1, [r0, #0]
 80002be:	9102      	str	r1, [sp, #8]
 80002c0:	498d      	ldr	r1, [pc, #564]	; (80004f8 <.text_12>)
 80002c2:	1861      	adds	r1, r4, r1
 80002c4:	9101      	str	r1, [sp, #4]
 80002c6:	0021      	movs	r1, r4
 80002c8:	3136      	adds	r1, #54	; 0x36
 80002ca:	9100      	str	r1, [sp, #0]
 80002cc:	7900      	ldrb	r0, [r0, #4]
 80002ce:	0880      	lsrs	r0, r0, #2
 80002d0:	2301      	movs	r3, #1
 80002d2:	4003      	ands	r3, r0
 80002d4:	209d      	movs	r0, #157	; 0x9d
 80002d6:	0040      	lsls	r0, r0, #1
 80002d8:	1822      	adds	r2, r4, r0
 80002da:	bf00      	nop
 80002dc:	a128      	add	r1, pc, #160	; (adr r1, 8000380 <PE_PrlCallbacks>)
 80002de:	4668      	mov	r0, sp
 80002e0:	7b00      	ldrb	r0, [r0, #12]
 80002e2:	f004 fdad 	bl	8004e40 <USBPD_PRL_Init>
 80002e6:	2800      	cmp	r0, #0
 80002e8:	d001      	beq.n	80002ee <USBPD_PE_Init+0x86>
 80002ea:	2002      	movs	r0, #2
 80002ec:	e045      	b.n	800037a <USBPD_PE_Init+0x112>
 80002ee:	68e0      	ldr	r0, [r4, #12]
 80002f0:	4982      	ldr	r1, [pc, #520]	; (80004fc <.text_13>)
 80002f2:	4001      	ands	r1, r0
 80002f4:	60e1      	str	r1, [r4, #12]
 80002f6:	6860      	ldr	r0, [r4, #4]
 80002f8:	9000      	str	r0, [sp, #0]
 80002fa:	7800      	ldrb	r0, [r0, #0]
 80002fc:	2303      	movs	r3, #3
 80002fe:	6821      	ldr	r1, [r4, #0]
 8000300:	7909      	ldrb	r1, [r1, #4]
 8000302:	088a      	lsrs	r2, r1, #2
 8000304:	423a      	tst	r2, r7
 8000306:	d00c      	beq.n	8000322 <USBPD_PE_Init+0xba>
 8000308:	2108      	movs	r1, #8
 800030a:	4301      	orrs	r1, r0
 800030c:	9800      	ldr	r0, [sp, #0]
 800030e:	7001      	strb	r1, [r0, #0]
 8000310:	7928      	ldrb	r0, [r5, #4]
 8000312:	4003      	ands	r3, r0
 8000314:	2201      	movs	r2, #1
 8000316:	2101      	movs	r1, #1
 8000318:	4668      	mov	r0, sp
 800031a:	7b00      	ldrb	r0, [r0, #12]
 800031c:	f004 fde4 	bl	8004ee8 <USBPD_PRL_SetHeader>
 8000320:	e017      	b.n	8000352 <USBPD_PE_Init+0xea>
 8000322:	21f7      	movs	r1, #247	; 0xf7
 8000324:	4001      	ands	r1, r0
 8000326:	9800      	ldr	r0, [sp, #0]
 8000328:	7001      	strb	r1, [r0, #0]
 800032a:	4872      	ldr	r0, [pc, #456]	; (80004f4 <.text_11>)
 800032c:	5426      	strb	r6, [r4, r0]
 800032e:	7928      	ldrb	r0, [r5, #4]
 8000330:	4003      	ands	r3, r0
 8000332:	2200      	movs	r2, #0
 8000334:	2100      	movs	r1, #0
 8000336:	4668      	mov	r0, sp
 8000338:	7b00      	ldrb	r0, [r0, #12]
 800033a:	f004 fdd5 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800033e:	0638      	lsls	r0, r7, #24
 8000340:	9001      	str	r0, [sp, #4]
 8000342:	2304      	movs	r3, #4
 8000344:	aa01      	add	r2, sp, #4
 8000346:	2106      	movs	r1, #6
 8000348:	4668      	mov	r0, sp
 800034a:	7b00      	ldrb	r0, [r0, #12]
 800034c:	68a5      	ldr	r5, [r4, #8]
 800034e:	69ed      	ldr	r5, [r5, #28]
 8000350:	47a8      	blx	r5
 8000352:	6820      	ldr	r0, [r4, #0]
 8000354:	7900      	ldrb	r0, [r0, #4]
 8000356:	0880      	lsrs	r0, r0, #2
 8000358:	4007      	ands	r7, r0
 800035a:	0039      	movs	r1, r7
 800035c:	4668      	mov	r0, sp
 800035e:	7b00      	ldrb	r0, [r0, #12]
 8000360:	f004 fddf 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8000364:	6860      	ldr	r0, [r4, #4]
 8000366:	7841      	ldrb	r1, [r0, #1]
 8000368:	228f      	movs	r2, #143	; 0x8f
 800036a:	400a      	ands	r2, r1
 800036c:	7042      	strb	r2, [r0, #1]
 800036e:	6860      	ldr	r0, [r4, #4]
 8000370:	6801      	ldr	r1, [r0, #0]
 8000372:	2210      	movs	r2, #16
 8000374:	4391      	bics	r1, r2
 8000376:	6001      	str	r1, [r0, #0]
 8000378:	2000      	movs	r0, #0
 800037a:	b005      	add	sp, #20
 800037c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08000380 <PE_PrlCallbacks>:
 8000380:	4463 0800 4481 0800 4139 0800 418d 0800     cD...D..9A...A..

08000390 <USBPD_PE_SetTrace>:
 8000390:	4a5b      	ldr	r2, [pc, #364]	; (8000500 <.text_14>)
 8000392:	60d0      	str	r0, [r2, #12]
 8000394:	7011      	strb	r1, [r2, #0]
 8000396:	4770      	bx	lr

08000398 <USBPD_PE_CheckLIB>:
 8000398:	495a      	ldr	r1, [pc, #360]	; (8000504 <.text_15>)
 800039a:	4288      	cmp	r0, r1
 800039c:	d101      	bne.n	80003a2 <USBPD_PE_CheckLIB+0xa>
 800039e:	2001      	movs	r0, #1
 80003a0:	4770      	bx	lr
 80003a2:	2000      	movs	r0, #0
 80003a4:	4770      	bx	lr

080003a6 <USBPD_PE_GetMemoryConsumption>:
 80003a6:	b510      	push	{r4, lr}
 80003a8:	f004 fd9c 	bl	8004ee4 <USBPD_PRL_GetMemoryConsumption>
 80003ac:	0004      	movs	r4, r0
 80003ae:	f7ff ff55 	bl	800025c <USBPD_CAD_GetMemoryConsumption>
 80003b2:	1820      	adds	r0, r4, r0
 80003b4:	21e6      	movs	r1, #230	; 0xe6
 80003b6:	00c9      	lsls	r1, r1, #3
 80003b8:	1840      	adds	r0, r0, r1
 80003ba:	bd10      	pop	{r4, pc}

080003bc <USBPD_PE_TimerCounter>:
 80003bc:	b081      	sub	sp, #4
 80003be:	4950      	ldr	r1, [pc, #320]	; (8000500 <.text_14>)
 80003c0:	0080      	lsls	r0, r0, #2
 80003c2:	1808      	adds	r0, r1, r0
 80003c4:	6840      	ldr	r0, [r0, #4]
 80003c6:	21d9      	movs	r1, #217	; 0xd9
 80003c8:	0089      	lsls	r1, r1, #2
 80003ca:	1840      	adds	r0, r0, r1
 80003cc:	494e      	ldr	r1, [pc, #312]	; (8000508 <.text_16>)
 80003ce:	084a      	lsrs	r2, r1, #1
 80003d0:	8b43      	ldrh	r3, [r0, #26]
 80003d2:	4013      	ands	r3, r2
 80003d4:	2b01      	cmp	r3, #1
 80003d6:	db02      	blt.n	80003de <USBPD_PE_TimerCounter+0x22>
 80003d8:	8b43      	ldrh	r3, [r0, #26]
 80003da:	185b      	adds	r3, r3, r1
 80003dc:	8343      	strh	r3, [r0, #26]
 80003de:	8803      	ldrh	r3, [r0, #0]
 80003e0:	4013      	ands	r3, r2
 80003e2:	2b01      	cmp	r3, #1
 80003e4:	db02      	blt.n	80003ec <USBPD_PE_TimerCounter+0x30>
 80003e6:	8803      	ldrh	r3, [r0, #0]
 80003e8:	185b      	adds	r3, r3, r1
 80003ea:	8003      	strh	r3, [r0, #0]
 80003ec:	8843      	ldrh	r3, [r0, #2]
 80003ee:	4013      	ands	r3, r2
 80003f0:	2b01      	cmp	r3, #1
 80003f2:	db02      	blt.n	80003fa <USBPD_PE_TimerCounter+0x3e>
 80003f4:	8843      	ldrh	r3, [r0, #2]
 80003f6:	185b      	adds	r3, r3, r1
 80003f8:	8043      	strh	r3, [r0, #2]
 80003fa:	8883      	ldrh	r3, [r0, #4]
 80003fc:	4013      	ands	r3, r2
 80003fe:	2b01      	cmp	r3, #1
 8000400:	db02      	blt.n	8000408 <USBPD_PE_TimerCounter+0x4c>
 8000402:	8883      	ldrh	r3, [r0, #4]
 8000404:	185b      	adds	r3, r3, r1
 8000406:	8083      	strh	r3, [r0, #4]
 8000408:	88c3      	ldrh	r3, [r0, #6]
 800040a:	4013      	ands	r3, r2
 800040c:	2b01      	cmp	r3, #1
 800040e:	db02      	blt.n	8000416 <USBPD_PE_TimerCounter+0x5a>
 8000410:	88c3      	ldrh	r3, [r0, #6]
 8000412:	185b      	adds	r3, r3, r1
 8000414:	80c3      	strh	r3, [r0, #6]
 8000416:	8903      	ldrh	r3, [r0, #8]
 8000418:	4013      	ands	r3, r2
 800041a:	2b01      	cmp	r3, #1
 800041c:	db02      	blt.n	8000424 <USBPD_PE_TimerCounter+0x68>
 800041e:	8903      	ldrh	r3, [r0, #8]
 8000420:	185b      	adds	r3, r3, r1
 8000422:	8103      	strh	r3, [r0, #8]
 8000424:	8943      	ldrh	r3, [r0, #10]
 8000426:	4013      	ands	r3, r2
 8000428:	2b01      	cmp	r3, #1
 800042a:	db02      	blt.n	8000432 <USBPD_PE_TimerCounter+0x76>
 800042c:	8943      	ldrh	r3, [r0, #10]
 800042e:	185b      	adds	r3, r3, r1
 8000430:	8143      	strh	r3, [r0, #10]
 8000432:	8983      	ldrh	r3, [r0, #12]
 8000434:	4013      	ands	r3, r2
 8000436:	2b01      	cmp	r3, #1
 8000438:	db02      	blt.n	8000440 <USBPD_PE_TimerCounter+0x84>
 800043a:	8983      	ldrh	r3, [r0, #12]
 800043c:	185b      	adds	r3, r3, r1
 800043e:	8183      	strh	r3, [r0, #12]
 8000440:	89c3      	ldrh	r3, [r0, #14]
 8000442:	4013      	ands	r3, r2
 8000444:	2b01      	cmp	r3, #1
 8000446:	db02      	blt.n	800044e <USBPD_PE_TimerCounter+0x92>
 8000448:	89c3      	ldrh	r3, [r0, #14]
 800044a:	185b      	adds	r3, r3, r1
 800044c:	81c3      	strh	r3, [r0, #14]
 800044e:	8a43      	ldrh	r3, [r0, #18]
 8000450:	4013      	ands	r3, r2
 8000452:	2b01      	cmp	r3, #1
 8000454:	db02      	blt.n	800045c <USBPD_PE_TimerCounter+0xa0>
 8000456:	8a43      	ldrh	r3, [r0, #18]
 8000458:	185b      	adds	r3, r3, r1
 800045a:	8243      	strh	r3, [r0, #18]
 800045c:	8a83      	ldrh	r3, [r0, #20]
 800045e:	4013      	ands	r3, r2
 8000460:	2b01      	cmp	r3, #1
 8000462:	db02      	blt.n	800046a <USBPD_PE_TimerCounter+0xae>
 8000464:	8a83      	ldrh	r3, [r0, #20]
 8000466:	185b      	adds	r3, r3, r1
 8000468:	8283      	strh	r3, [r0, #20]
 800046a:	8ac3      	ldrh	r3, [r0, #22]
 800046c:	4013      	ands	r3, r2
 800046e:	2b01      	cmp	r3, #1
 8000470:	db02      	blt.n	8000478 <USBPD_PE_TimerCounter+0xbc>
 8000472:	8ac3      	ldrh	r3, [r0, #22]
 8000474:	185b      	adds	r3, r3, r1
 8000476:	82c3      	strh	r3, [r0, #22]
 8000478:	8a03      	ldrh	r3, [r0, #16]
 800047a:	4013      	ands	r3, r2
 800047c:	2b01      	cmp	r3, #1
 800047e:	db02      	blt.n	8000486 <USBPD_PE_TimerCounter+0xca>
 8000480:	8a03      	ldrh	r3, [r0, #16]
 8000482:	185b      	adds	r3, r3, r1
 8000484:	8203      	strh	r3, [r0, #16]
 8000486:	8b03      	ldrh	r3, [r0, #24]
 8000488:	4013      	ands	r3, r2
 800048a:	2b01      	cmp	r3, #1
 800048c:	db02      	blt.n	8000494 <USBPD_PE_TimerCounter+0xd8>
 800048e:	8b03      	ldrh	r3, [r0, #24]
 8000490:	185b      	adds	r3, r3, r1
 8000492:	8303      	strh	r3, [r0, #24]
 8000494:	8b83      	ldrh	r3, [r0, #28]
 8000496:	4013      	ands	r3, r2
 8000498:	2b01      	cmp	r3, #1
 800049a:	db02      	blt.n	80004a2 <USBPD_PE_TimerCounter+0xe6>
 800049c:	8b83      	ldrh	r3, [r0, #28]
 800049e:	185b      	adds	r3, r3, r1
 80004a0:	8383      	strh	r3, [r0, #28]
 80004a2:	8bc3      	ldrh	r3, [r0, #30]
 80004a4:	401a      	ands	r2, r3
 80004a6:	2a01      	cmp	r2, #1
 80004a8:	db02      	blt.n	80004b0 <USBPD_PE_TimerCounter+0xf4>
 80004aa:	8bc2      	ldrh	r2, [r0, #30]
 80004ac:	1851      	adds	r1, r2, r1
 80004ae:	83c1      	strh	r1, [r0, #30]
 80004b0:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80004b2:	1c49      	adds	r1, r1, #1
 80004b4:	6241      	str	r1, [r0, #36]	; 0x24
 80004b6:	b001      	add	sp, #4
 80004b8:	4770      	bx	lr

080004ba <USBPD_PE_IsCableConnected>:
 80004ba:	b538      	push	{r3, r4, r5, lr}
 80004bc:	000c      	movs	r4, r1
 80004be:	490c      	ldr	r1, [pc, #48]	; (80004f0 <.text_10>)
 80004c0:	0082      	lsls	r2, r0, #2
 80004c2:	588d      	ldr	r5, [r1, r2]
 80004c4:	2100      	movs	r1, #0
 80004c6:	f003 fe62 	bl	800418e <PE_Reset>
 80004ca:	6868      	ldr	r0, [r5, #4]
 80004cc:	6801      	ldr	r1, [r0, #0]
 80004ce:	2c01      	cmp	r4, #1
 80004d0:	d104      	bne.n	80004dc <USBPD_PE_IsCableConnected+0x22>
 80004d2:	2280      	movs	r2, #128	; 0x80
 80004d4:	0112      	lsls	r2, r2, #4
 80004d6:	430a      	orrs	r2, r1
 80004d8:	6002      	str	r2, [r0, #0]
 80004da:	e006      	b.n	80004ea <USBPD_PE_IsCableConnected+0x30>
 80004dc:	4a07      	ldr	r2, [pc, #28]	; (80004fc <.text_13>)
 80004de:	400a      	ands	r2, r1
 80004e0:	6002      	str	r2, [r0, #0]
 80004e2:	2000      	movs	r0, #0
 80004e4:	21d6      	movs	r1, #214	; 0xd6
 80004e6:	0089      	lsls	r1, r1, #2
 80004e8:	5468      	strb	r0, [r5, r1]
 80004ea:	2000      	movs	r0, #0
 80004ec:	bd32      	pop	{r1, r4, r5, pc}
	...

080004f0 <.text_10>:
 80004f0:	200019ec 	.word	0x200019ec

080004f4 <.text_11>:
 80004f4:	00000357 	.word	0x00000357

080004f8 <.text_12>:
 80004f8:	0000034a 	.word	0x0000034a

080004fc <.text_13>:
 80004fc:	fffff7ff 	.word	0xfffff7ff

08000500 <.text_14>:
 8000500:	200019e8 	.word	0x200019e8

08000504 <.text_15>:
 8000504:	30210001 	.word	0x30210001

08000508 <.text_16>:
 8000508:	0000ffff 	.word	0x0000ffff

0800050c <USBPD_PE_StateMachine_SRC>:
 800050c:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 800050e:	b08a      	sub	sp, #40	; 0x28
 8000510:	48b5      	ldr	r0, [pc, #724]	; (80007e8 <__iar_annotation$$branch+0xc>)
 8000512:	a90a      	add	r1, sp, #40	; 0x28
 8000514:	7809      	ldrb	r1, [r1, #0]
 8000516:	0089      	lsls	r1, r1, #2
 8000518:	1840      	adds	r0, r0, r1
 800051a:	6844      	ldr	r4, [r0, #4]
 800051c:	2000      	movs	r0, #0
 800051e:	9008      	str	r0, [sp, #32]
 8000520:	20d9      	movs	r0, #217	; 0xd9
 8000522:	0080      	lsls	r0, r0, #2
 8000524:	1820      	adds	r0, r4, r0
 8000526:	9004      	str	r0, [sp, #16]
 8000528:	6a46      	ldr	r6, [r0, #36]	; 0x24
 800052a:	8807      	ldrh	r7, [r0, #0]
 800052c:	4668      	mov	r0, sp
 800052e:	9904      	ldr	r1, [sp, #16]
 8000530:	8849      	ldrh	r1, [r1, #2]
 8000532:	8281      	strh	r1, [r0, #20]
 8000534:	9904      	ldr	r1, [sp, #16]
 8000536:	8889      	ldrh	r1, [r1, #4]
 8000538:	81c1      	strh	r1, [r0, #14]
 800053a:	9904      	ldr	r1, [sp, #16]
 800053c:	88c9      	ldrh	r1, [r1, #6]
 800053e:	8141      	strh	r1, [r0, #10]
 8000540:	9904      	ldr	r1, [sp, #16]
 8000542:	8909      	ldrh	r1, [r1, #8]
 8000544:	8101      	strh	r1, [r0, #8]
 8000546:	9904      	ldr	r1, [sp, #16]
 8000548:	8949      	ldrh	r1, [r1, #10]
 800054a:	80c1      	strh	r1, [r0, #6]
 800054c:	9904      	ldr	r1, [sp, #16]
 800054e:	8989      	ldrh	r1, [r1, #12]
 8000550:	8081      	strh	r1, [r0, #4]
 8000552:	9904      	ldr	r1, [sp, #16]
 8000554:	89c9      	ldrh	r1, [r1, #14]
 8000556:	8041      	strh	r1, [r0, #2]
 8000558:	9904      	ldr	r1, [sp, #16]
 800055a:	89c9      	ldrh	r1, [r1, #14]
 800055c:	8001      	strh	r1, [r0, #0]
 800055e:	9804      	ldr	r0, [sp, #16]
 8000560:	8a00      	ldrh	r0, [r0, #16]
 8000562:	9904      	ldr	r1, [sp, #16]
 8000564:	8a49      	ldrh	r1, [r1, #18]
 8000566:	9a04      	ldr	r2, [sp, #16]
 8000568:	8a92      	ldrh	r2, [r2, #20]
 800056a:	9b04      	ldr	r3, [sp, #16]
 800056c:	8adb      	ldrh	r3, [r3, #22]
 800056e:	9d04      	ldr	r5, [sp, #16]
 8000570:	8c2d      	ldrh	r5, [r5, #32]
 8000572:	0536      	lsls	r6, r6, #20
 8000574:	0d36      	lsrs	r6, r6, #20
 8000576:	19f6      	adds	r6, r6, r7
 8000578:	466f      	mov	r7, sp
 800057a:	8abf      	ldrh	r7, [r7, #20]
 800057c:	19f6      	adds	r6, r6, r7
 800057e:	466f      	mov	r7, sp
 8000580:	89ff      	ldrh	r7, [r7, #14]
 8000582:	19f6      	adds	r6, r6, r7
 8000584:	466f      	mov	r7, sp
 8000586:	897f      	ldrh	r7, [r7, #10]
 8000588:	19f6      	adds	r6, r6, r7
 800058a:	466f      	mov	r7, sp
 800058c:	893f      	ldrh	r7, [r7, #8]
 800058e:	19f6      	adds	r6, r6, r7
 8000590:	466f      	mov	r7, sp
 8000592:	88ff      	ldrh	r7, [r7, #6]
 8000594:	19f6      	adds	r6, r6, r7
 8000596:	466f      	mov	r7, sp
 8000598:	88bf      	ldrh	r7, [r7, #4]
 800059a:	19f6      	adds	r6, r6, r7
 800059c:	466f      	mov	r7, sp
 800059e:	887f      	ldrh	r7, [r7, #2]
 80005a0:	19f6      	adds	r6, r6, r7
 80005a2:	466f      	mov	r7, sp
 80005a4:	883f      	ldrh	r7, [r7, #0]
 80005a6:	19f6      	adds	r6, r6, r7
 80005a8:	1830      	adds	r0, r6, r0
 80005aa:	1840      	adds	r0, r0, r1
 80005ac:	1880      	adds	r0, r0, r2
 80005ae:	18c0      	adds	r0, r0, r3
 80005b0:	0529      	lsls	r1, r5, #20
 80005b2:	0f49      	lsrs	r1, r1, #29
 80005b4:	1840      	adds	r0, r0, r1
 80005b6:	9904      	ldr	r1, [sp, #16]
 80005b8:	8c09      	ldrh	r1, [r1, #32]
 80005ba:	06c9      	lsls	r1, r1, #27
 80005bc:	0ec9      	lsrs	r1, r1, #27
 80005be:	1840      	adds	r0, r0, r1
 80005c0:	b280      	uxth	r0, r0
 80005c2:	9007      	str	r0, [sp, #28]
 80005c4:	0020      	movs	r0, r4
 80005c6:	f003 f9f9 	bl	80039bc <PE_Check_RxEvent>
 80005ca:	4669      	mov	r1, sp
 80005cc:	7308      	strb	r0, [r1, #12]
 80005ce:	2803      	cmp	r0, #3
 80005d0:	d101      	bne.n	80005d6 <USBPD_PE_StateMachine_SRC+0xca>
 80005d2:	2001      	movs	r0, #1
 80005d4:	e254      	b.n	8000a80 <__iar_annotation$$branch+0x88>
 80005d6:	2502      	movs	r5, #2
 80005d8:	20d4      	movs	r0, #212	; 0xd4
 80005da:	0080      	lsls	r0, r0, #2
 80005dc:	1826      	adds	r6, r4, r0
 80005de:	7930      	ldrb	r0, [r6, #4]
 80005e0:	280f      	cmp	r0, #15
 80005e2:	d117      	bne.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 80005e4:	7230      	strb	r0, [r6, #8]
 80005e6:	2000      	movs	r0, #0
 80005e8:	7130      	strb	r0, [r6, #4]
 80005ea:	487f      	ldr	r0, [pc, #508]	; (80007e8 <__iar_annotation$$branch+0xc>)
 80005ec:	68c7      	ldr	r7, [r0, #12]
 80005ee:	2f00      	cmp	r7, #0
 80005f0:	d010      	beq.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 80005f2:	7800      	ldrb	r0, [r0, #0]
 80005f4:	07c0      	lsls	r0, r0, #31
 80005f6:	d50d      	bpl.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 80005f8:	7a30      	ldrb	r0, [r6, #8]
 80005fa:	7a71      	ldrb	r1, [r6, #9]
 80005fc:	4281      	cmp	r1, r0
 80005fe:	d009      	beq.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 8000600:	7270      	strb	r0, [r6, #9]
 8000602:	2000      	movs	r0, #0
 8000604:	9000      	str	r0, [sp, #0]
 8000606:	2300      	movs	r3, #0
 8000608:	7a32      	ldrb	r2, [r6, #8]
 800060a:	7b20      	ldrb	r0, [r4, #12]
 800060c:	07c1      	lsls	r1, r0, #31
 800060e:	0fc9      	lsrs	r1, r1, #31
 8000610:	2004      	movs	r0, #4
 8000612:	47b8      	blx	r7
 8000614:	9807      	ldr	r0, [sp, #28]
 8000616:	2800      	cmp	r0, #0
 8000618:	d006      	beq.n	8000628 <USBPD_PE_StateMachine_SRC+0x11c>
 800061a:	2107      	movs	r1, #7
 800061c:	f005 fb3a 	bl	8005c94 <__aeabi_idivmod>
 8000620:	2900      	cmp	r1, #0
 8000622:	d101      	bne.n	8000628 <USBPD_PE_StateMachine_SRC+0x11c>
 8000624:	2001      	movs	r0, #1
 8000626:	9008      	str	r0, [sp, #32]
 8000628:	496f      	ldr	r1, [pc, #444]	; (80007e8 <__iar_annotation$$branch+0xc>)
 800062a:	7808      	ldrb	r0, [r1, #0]
 800062c:	4028      	ands	r0, r5
 800062e:	68c9      	ldr	r1, [r1, #12]
 8000630:	9101      	str	r1, [sp, #4]
 8000632:	4669      	mov	r1, sp
 8000634:	7b09      	ldrb	r1, [r1, #12]
 8000636:	7a32      	ldrb	r2, [r6, #8]
 8000638:	2a00      	cmp	r2, #0
 800063a:	d100      	bne.n	800063e <USBPD_PE_StateMachine_SRC+0x132>
 800063c:	e0eb      	b.n	8000816 <__iar_annotation$$branch+0x3a>
 800063e:	1e52      	subs	r2, r2, #1
 8000640:	d100      	bne.n	8000644 <USBPD_PE_StateMachine_SRC+0x138>
 8000642:	e0a8      	b.n	8000796 <__iar_annotation$$branch+0xe>
 8000644:	1e52      	subs	r2, r2, #1
 8000646:	d100      	bne.n	800064a <USBPD_PE_StateMachine_SRC+0x13e>
 8000648:	e0ed      	b.n	8000826 <__iar_annotation$$branch+0x4a>
 800064a:	1e52      	subs	r2, r2, #1
 800064c:	d101      	bne.n	8000652 <__iar_annotation$$branch+0x4>

0800064e <__iar_annotation$$branch>:
 800064e:	f001 f8e6 	bl	800181e <__iar_annotation$$branch+0x250>
 8000652:	1e52      	subs	r2, r2, #1
 8000654:	d101      	bne.n	800065a <__iar_annotation$$branch+0x4>

08000656 <__iar_annotation$$branch>:
 8000656:	f001 f8fc 	bl	8001852 <__iar_annotation$$branch+0x284>
 800065a:	1e52      	subs	r2, r2, #1
 800065c:	d100      	bne.n	8000660 <__iar_annotation$$branch+0xa>
 800065e:	e133      	b.n	80008c8 <__iar_annotation$$branch+0xec>
 8000660:	1e52      	subs	r2, r2, #1
 8000662:	d100      	bne.n	8000666 <__iar_annotation$$branch+0x10>
 8000664:	e214      	b.n	8000a90 <__iar_annotation$$branch+0x98>
 8000666:	1e52      	subs	r2, r2, #1
 8000668:	d100      	bne.n	800066c <__iar_annotation$$branch+0x16>
 800066a:	e219      	b.n	8000aa0 <__iar_annotation$$branch+0xa8>
 800066c:	1e52      	subs	r2, r2, #1
 800066e:	d100      	bne.n	8000672 <__iar_annotation$$branch+0x1c>
 8000670:	e282      	b.n	8000b78 <__iar_annotation$$branch+0x180>
 8000672:	1e52      	subs	r2, r2, #1
 8000674:	d100      	bne.n	8000678 <__iar_annotation$$branch+0x22>
 8000676:	e2ca      	b.n	8000c0e <__iar_annotation$$branch+0x216>
 8000678:	1e52      	subs	r2, r2, #1
 800067a:	2a01      	cmp	r2, #1
 800067c:	d800      	bhi.n	8000680 <__iar_annotation$$branch+0x2a>
 800067e:	e3c3      	b.n	8000e08 <__iar_annotation$$branch+0x410>
 8000680:	1e92      	subs	r2, r2, #2
 8000682:	d100      	bne.n	8000686 <__iar_annotation$$branch+0x30>
 8000684:	e357      	b.n	8000d36 <__iar_annotation$$branch+0x33e>
 8000686:	1e52      	subs	r2, r2, #1
 8000688:	d100      	bne.n	800068c <__iar_annotation$$branch+0x36>
 800068a:	e383      	b.n	8000d94 <__iar_annotation$$branch+0x39c>
 800068c:	1e52      	subs	r2, r2, #1
 800068e:	d100      	bne.n	8000692 <__iar_annotation$$branch+0x3c>
 8000690:	e3b7      	b.n	8000e02 <__iar_annotation$$branch+0x40a>
 8000692:	1e52      	subs	r2, r2, #1
 8000694:	d101      	bne.n	800069a <__iar_annotation$$branch+0x4>

08000696 <__iar_annotation$$branch>:
 8000696:	f000 fc91 	bl	8000fbc <__iar_annotation$$branch+0x5c4>
 800069a:	1e52      	subs	r2, r2, #1
 800069c:	d101      	bne.n	80006a2 <__iar_annotation$$branch+0x4>

0800069e <__iar_annotation$$branch>:
 800069e:	f000 fc21 	bl	8000ee4 <__iar_annotation$$branch+0x4ec>
 80006a2:	1e52      	subs	r2, r2, #1
 80006a4:	d101      	bne.n	80006aa <__iar_annotation$$branch+0x4>

080006a6 <__iar_annotation$$branch>:
 80006a6:	f000 fc3d 	bl	8000f24 <__iar_annotation$$branch+0x52c>
 80006aa:	1e52      	subs	r2, r2, #1
 80006ac:	d101      	bne.n	80006b2 <__iar_annotation$$branch+0x4>

080006ae <__iar_annotation$$branch>:
 80006ae:	f000 fc56 	bl	8000f5e <__iar_annotation$$branch+0x566>
 80006b2:	1e52      	subs	r2, r2, #1
 80006b4:	d101      	bne.n	80006ba <__iar_annotation$$branch+0x4>

080006b6 <__iar_annotation$$branch>:
 80006b6:	f000 fce5 	bl	8001084 <__iar_annotation$$branch+0x68c>
 80006ba:	1e52      	subs	r2, r2, #1
 80006bc:	d101      	bne.n	80006c2 <__iar_annotation$$branch+0x4>

080006be <__iar_annotation$$branch>:
 80006be:	f000 fc9d 	bl	8000ffc <__iar_annotation$$branch+0x604>
 80006c2:	1e52      	subs	r2, r2, #1
 80006c4:	d101      	bne.n	80006ca <__iar_annotation$$branch+0x4>

080006c6 <__iar_annotation$$branch>:
 80006c6:	f000 fcac 	bl	8001022 <__iar_annotation$$branch+0x62a>
 80006ca:	1e52      	subs	r2, r2, #1
 80006cc:	d100      	bne.n	80006d0 <__iar_annotation$$branch+0xa>
 80006ce:	e263      	b.n	8000b98 <__iar_annotation$$branch+0x1a0>
 80006d0:	1e92      	subs	r2, r2, #2
 80006d2:	d101      	bne.n	80006d8 <__iar_annotation$$branch+0x4>

080006d4 <__iar_annotation$$branch>:
 80006d4:	f000 fd2a 	bl	800112c <__iar_annotation$$branch+0x734>
 80006d8:	1e52      	subs	r2, r2, #1
 80006da:	d101      	bne.n	80006e0 <__iar_annotation$$branch+0x4>

080006dc <__iar_annotation$$branch>:
 80006dc:	f000 fd56 	bl	800118c <__iar_annotation$$branch+0x794>
 80006e0:	1e52      	subs	r2, r2, #1
 80006e2:	d101      	bne.n	80006e8 <__iar_annotation$$branch+0x4>

080006e4 <__iar_annotation$$branch>:
 80006e4:	f000 fdcd 	bl	8001282 <__iar_annotation$$branch+0x88a>
 80006e8:	1e52      	subs	r2, r2, #1
 80006ea:	d101      	bne.n	80006f0 <__iar_annotation$$branch+0x4>

080006ec <__iar_annotation$$branch>:
 80006ec:	f000 fde9 	bl	80012c2 <__iar_annotation$$branch+0x8ca>
 80006f0:	1e92      	subs	r2, r2, #2
 80006f2:	d101      	bne.n	80006f8 <__iar_annotation$$branch+0x4>

080006f4 <__iar_annotation$$branch>:
 80006f4:	f001 f869 	bl	80017ca <__iar_annotation$$branch+0x1fc>
 80006f8:	1e52      	subs	r2, r2, #1
 80006fa:	d101      	bne.n	8000700 <__iar_annotation$$branch+0x4>

080006fc <__iar_annotation$$branch>:
 80006fc:	f000 ff69 	bl	80015d2 <__iar_annotation$$branch+0x4>
 8000700:	1e52      	subs	r2, r2, #1
 8000702:	d101      	bne.n	8000708 <__iar_annotation$$branch+0x4>

08000704 <__iar_annotation$$branch>:
 8000704:	f000 ff8e 	bl	8001624 <__iar_annotation$$branch+0x56>
 8000708:	1e52      	subs	r2, r2, #1
 800070a:	d101      	bne.n	8000710 <__iar_annotation$$branch+0x4>

0800070c <__iar_annotation$$branch>:
 800070c:	f001 f814 	bl	8001738 <__iar_annotation$$branch+0x16a>
 8000710:	1e52      	subs	r2, r2, #1
 8000712:	d101      	bne.n	8000718 <__iar_annotation$$branch+0x4>

08000714 <__iar_annotation$$branch>:
 8000714:	f001 f849 	bl	80017aa <__iar_annotation$$branch+0x1dc>
 8000718:	1e52      	subs	r2, r2, #1
 800071a:	d101      	bne.n	8000720 <__iar_annotation$$branch+0x4>

0800071c <__iar_annotation$$branch>:
 800071c:	f000 fe39 	bl	8001392 <__iar_annotation$$branch+0x99a>
 8000720:	1e92      	subs	r2, r2, #2
 8000722:	d101      	bne.n	8000728 <__iar_annotation$$branch+0x4>

08000724 <__iar_annotation$$branch>:
 8000724:	f000 fea0 	bl	8001468 <__iar_annotation$$branch+0xa70>
 8000728:	1e52      	subs	r2, r2, #1
 800072a:	d101      	bne.n	8000730 <__iar_annotation$$branch+0x4>

0800072c <__iar_annotation$$branch>:
 800072c:	f000 fefa 	bl	8001524 <__iar_annotation$$branch+0xb2c>
 8000730:	1e52      	subs	r2, r2, #1
 8000732:	d101      	bne.n	8000738 <__iar_annotation$$branch+0x4>

08000734 <__iar_annotation$$branch>:
 8000734:	f000 ff1a 	bl	800156c <__iar_annotation$$branch+0xb74>
 8000738:	1e52      	subs	r2, r2, #1
 800073a:	d101      	bne.n	8000740 <__iar_annotation$$branch+0x4>

0800073c <__iar_annotation$$branch>:
 800073c:	f000 fcc7 	bl	80010ce <__iar_annotation$$branch+0x6d6>
 8000740:	1e52      	subs	r2, r2, #1
 8000742:	d101      	bne.n	8000748 <__iar_annotation$$branch+0x4>

08000744 <__iar_annotation$$branch>:
 8000744:	f000 fcd1 	bl	80010ea <__iar_annotation$$branch+0x6f2>
 8000748:	1e52      	subs	r2, r2, #1
 800074a:	d101      	bne.n	8000750 <__iar_annotation$$branch+0x4>

0800074c <__iar_annotation$$branch>:
 800074c:	f000 fcda 	bl	8001104 <__iar_annotation$$branch+0x70c>
 8000750:	1e52      	subs	r2, r2, #1
 8000752:	d101      	bne.n	8000758 <__iar_annotation$$branch+0x4>

08000754 <__iar_annotation$$branch>:
 8000754:	f000 fe21 	bl	800139a <__iar_annotation$$branch+0x9a2>
 8000758:	1e52      	subs	r2, r2, #1
 800075a:	d101      	bne.n	8000760 <__iar_annotation$$branch+0x4>

0800075c <__iar_annotation$$branch>:
 800075c:	f001 f9a5 	bl	8001aaa <__iar_annotation$$branch+0xca>
 8000760:	1e52      	subs	r2, r2, #1
 8000762:	d018      	beq.n	8000796 <__iar_annotation$$branch+0xe>
 8000764:	1e52      	subs	r2, r2, #1
 8000766:	d101      	bne.n	800076c <__iar_annotation$$branch+0x4>

08000768 <__iar_annotation$$branch>:
 8000768:	f001 f9ae 	bl	8001ac8 <__iar_annotation$$branch+0xe8>
 800076c:	1e52      	subs	r2, r2, #1
 800076e:	d101      	bne.n	8000774 <__iar_annotation$$branch+0x4>

08000770 <__iar_annotation$$branch>:
 8000770:	f001 f9e6 	bl	8001b40 <__iar_annotation$$branch+0x160>
 8000774:	1e52      	subs	r2, r2, #1
 8000776:	2a01      	cmp	r2, #1
 8000778:	d90d      	bls.n	8000796 <__iar_annotation$$branch+0xe>
 800077a:	1e92      	subs	r2, r2, #2
 800077c:	2a07      	cmp	r2, #7
 800077e:	d801      	bhi.n	8000784 <__iar_annotation$$branch+0x4>

08000780 <__iar_annotation$$branch>:
 8000780:	f001 fa10 	bl	8001ba4 <__iar_annotation$$branch+0x22>
 8000784:	3a08      	subs	r2, #8
 8000786:	d101      	bne.n	800078c <__iar_annotation$$branch+0x4>

08000788 <__iar_annotation$$branch>:
 8000788:	f001 f9fd 	bl	8001b86 <__iar_annotation$$branch+0x4>
 800078c:	1e52      	subs	r2, r2, #1
 800078e:	2a03      	cmp	r2, #3
 8000790:	d901      	bls.n	8000796 <__iar_annotation$$branch+0xe>
 8000792:	3a28      	subs	r2, #40	; 0x28
 8000794:	2a01      	cmp	r2, #1
 8000796:	d801      	bhi.n	800079c <__iar_annotation$$branch+0x4>

08000798 <__iar_annotation$$branch>:
 8000798:	f001 fa09 	bl	8001bae <__iar_annotation$$branch+0x2c>
 800079c:	3a12      	subs	r2, #18
 800079e:	d0fa      	beq.n	8000796 <__iar_annotation$$branch+0xe>
 80007a0:	3a1e      	subs	r2, #30
 80007a2:	d023      	beq.n	80007ec <__iar_annotation$$branch+0x10>
 80007a4:	1e52      	subs	r2, r2, #1
 80007a6:	d101      	bne.n	80007ac <__iar_annotation$$branch+0x4>

080007a8 <__iar_annotation$$branch>:
 80007a8:	f001 f898 	bl	80018dc <__iar_annotation$$branch+0x1e>
 80007ac:	1e52      	subs	r2, r2, #1
 80007ae:	d101      	bne.n	80007b4 <__iar_annotation$$branch+0x4>

080007b0 <__iar_annotation$$branch>:
 80007b0:	f001 f8e0 	bl	8001974 <__iar_annotation$$branch+0xb6>
 80007b4:	1e52      	subs	r2, r2, #1
 80007b6:	d101      	bne.n	80007bc <__iar_annotation$$branch+0x4>

080007b8 <__iar_annotation$$branch>:
 80007b8:	f001 f8fb 	bl	80019b2 <__iar_annotation$$branch+0xf4>
 80007bc:	1e52      	subs	r2, r2, #1
 80007be:	d100      	bne.n	80007c2 <__iar_annotation$$branch+0xa>
 80007c0:	e339      	b.n	8000e36 <__iar_annotation$$branch+0x43e>
 80007c2:	1e52      	subs	r2, r2, #1
 80007c4:	d100      	bne.n	80007c8 <__iar_annotation$$branch+0x10>
 80007c6:	e35c      	b.n	8000e82 <__iar_annotation$$branch+0x48a>
 80007c8:	1e92      	subs	r2, r2, #2
 80007ca:	d101      	bne.n	80007d0 <__iar_annotation$$branch+0x4>

080007cc <__iar_annotation$$branch>:
 80007cc:	f001 fa02 	bl	8001bd4 <__iar_annotation$$branch+0x52>
 80007d0:	1e52      	subs	r2, r2, #1
 80007d2:	d100      	bne.n	80007d6 <__iar_annotation$$branch+0xa>
 80007d4:	e0b9      	b.n	800094a <__iar_annotation$$branch+0x16e>
 80007d6:	1e92      	subs	r2, r2, #2
 80007d8:	2a08      	cmp	r2, #8
 80007da:	d801      	bhi.n	80007e0 <__iar_annotation$$branch+0x4>

080007dc <__iar_annotation$$branch>:
 80007dc:	f001 f9ec 	bl	8001bb8 <__iar_annotation$$branch+0x36>
 80007e0:	3a09      	subs	r2, #9
 80007e2:	d0cc      	beq.n	800077e <__iar_annotation$$branch+0xe>
 80007e4:	e0ee      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80007e6:	bf00      	nop
 80007e8:	200019e8 	.word	0x200019e8
 80007ec:	68a0      	ldr	r0, [r4, #8]
 80007ee:	6b81      	ldr	r1, [r0, #56]	; 0x38
 80007f0:	2900      	cmp	r1, #0
 80007f2:	d003      	beq.n	80007fc <__iar_annotation$$branch+0x20>
 80007f4:	7b22      	ldrb	r2, [r4, #12]
 80007f6:	07d0      	lsls	r0, r2, #31
 80007f8:	0fc0      	lsrs	r0, r0, #31
 80007fa:	4788      	blx	r1
 80007fc:	2014      	movs	r0, #20
 80007fe:	4669      	mov	r1, sp
 8000800:	7308      	strb	r0, [r1, #12]
 8000802:	2101      	movs	r1, #1
 8000804:	a80a      	add	r0, sp, #40	; 0x28
 8000806:	7800      	ldrb	r0, [r0, #0]
 8000808:	f003 fcc1 	bl	800418e <PE_Reset>
 800080c:	a80a      	add	r0, sp, #40	; 0x28
 800080e:	7800      	ldrb	r0, [r0, #0]
 8000810:	f004 fe20 	bl	8005454 <USBPD_PRL_Reset>
 8000814:	e0d6      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000816:	2500      	movs	r5, #0
 8000818:	43ed      	mvns	r5, r5
 800081a:	6860      	ldr	r0, [r4, #4]
 800081c:	6801      	ldr	r1, [r0, #0]
 800081e:	2210      	movs	r2, #16
 8000820:	4391      	bics	r1, r2
 8000822:	6001      	str	r1, [r0, #0]
 8000824:	e0ce      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000826:	6860      	ldr	r0, [r4, #4]
 8000828:	6800      	ldr	r0, [r0, #0]
 800082a:	0340      	lsls	r0, r0, #13
 800082c:	0fc1      	lsrs	r1, r0, #31
 800082e:	a80a      	add	r0, sp, #40	; 0x28
 8000830:	7800      	ldrb	r0, [r0, #0]
 8000832:	f004 fbb2 	bl	8004f9a <USBPD_PRL_CableCapable>
 8000836:	6860      	ldr	r0, [r4, #4]
 8000838:	2701      	movs	r7, #1
 800083a:	6801      	ldr	r1, [r0, #0]
 800083c:	0ac9      	lsrs	r1, r1, #11
 800083e:	4039      	ands	r1, r7
 8000840:	d100      	bne.n	8000844 <__iar_annotation$$branch+0x68>
 8000842:	e170      	b.n	8000b26 <__iar_annotation$$branch+0x12e>
 8000844:	2103      	movs	r1, #3
 8000846:	6822      	ldr	r2, [r4, #0]
 8000848:	7913      	ldrb	r3, [r2, #4]
 800084a:	2203      	movs	r2, #3
 800084c:	401a      	ands	r2, r3
 800084e:	7803      	ldrb	r3, [r0, #0]
 8000850:	25fc      	movs	r5, #252	; 0xfc
 8000852:	401d      	ands	r5, r3
 8000854:	432a      	orrs	r2, r5
 8000856:	7002      	strb	r2, [r0, #0]
 8000858:	6860      	ldr	r0, [r4, #4]
 800085a:	7802      	ldrb	r2, [r0, #0]
 800085c:	4011      	ands	r1, r2
 800085e:	2901      	cmp	r1, #1
 8000860:	d101      	bne.n	8000866 <__iar_annotation$$branch+0x8a>
 8000862:	2100      	movs	r1, #0
 8000864:	e000      	b.n	8000868 <__iar_annotation$$branch+0x8c>
 8000866:	2101      	movs	r1, #1
 8000868:	239f      	movs	r3, #159	; 0x9f
 800086a:	4013      	ands	r3, r2
 800086c:	0149      	lsls	r1, r1, #5
 800086e:	4319      	orrs	r1, r3
 8000870:	7001      	strb	r1, [r0, #0]
 8000872:	2000      	movs	r0, #0
 8000874:	7560      	strb	r0, [r4, #21]
 8000876:	6860      	ldr	r0, [r4, #4]
 8000878:	7841      	ldrb	r1, [r0, #1]
 800087a:	228f      	movs	r2, #143	; 0x8f
 800087c:	400a      	ands	r2, r1
 800087e:	2110      	movs	r1, #16
 8000880:	4311      	orrs	r1, r2
 8000882:	7041      	strb	r1, [r0, #1]
 8000884:	4db3      	ldr	r5, [pc, #716]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000886:	7828      	ldrb	r0, [r5, #0]
 8000888:	0780      	lsls	r0, r0, #30
 800088a:	d509      	bpl.n	80008a0 <__iar_annotation$$branch+0xc4>
 800088c:	2000      	movs	r0, #0
 800088e:	9000      	str	r0, [sp, #0]
 8000890:	2300      	movs	r3, #0
 8000892:	2256      	movs	r2, #86	; 0x56
 8000894:	68e0      	ldr	r0, [r4, #12]
 8000896:	2101      	movs	r1, #1
 8000898:	4001      	ands	r1, r0
 800089a:	2009      	movs	r0, #9
 800089c:	68ed      	ldr	r5, [r5, #12]
 800089e:	47a8      	blx	r5
 80008a0:	2156      	movs	r1, #86	; 0x56
 80008a2:	68e2      	ldr	r2, [r4, #12]
 80008a4:	2001      	movs	r0, #1
 80008a6:	4010      	ands	r0, r2
 80008a8:	68a2      	ldr	r2, [r4, #8]
 80008aa:	68d2      	ldr	r2, [r2, #12]
 80008ac:	4790      	blx	r2
 80008ae:	6860      	ldr	r0, [r4, #4]
 80008b0:	6800      	ldr	r0, [r0, #0]
 80008b2:	0900      	lsrs	r0, r0, #4
 80008b4:	4007      	ands	r7, r0
 80008b6:	d005      	beq.n	80008c4 <__iar_annotation$$branch+0xe8>
 80008b8:	48a7      	ldr	r0, [pc, #668]	; (8000b58 <__iar_annotation$$branch+0x160>)
 80008ba:	84b0      	strh	r0, [r6, #36]	; 0x24
 80008bc:	2514      	movs	r5, #20
 80008be:	2006      	movs	r0, #6
 80008c0:	7230      	strb	r0, [r6, #8]
 80008c2:	e07f      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80008c4:	2005      	movs	r0, #5
 80008c6:	e0e8      	b.n	8000a9a <__iar_annotation$$branch+0xa2>
 80008c8:	2001      	movs	r0, #1
 80008ca:	6861      	ldr	r1, [r4, #4]
 80008cc:	6809      	ldr	r1, [r1, #0]
 80008ce:	0c89      	lsrs	r1, r1, #18
 80008d0:	4001      	ands	r1, r0
 80008d2:	d100      	bne.n	80008d6 <__iar_annotation$$branch+0xfa>
 80008d4:	e0e0      	b.n	8000a98 <__iar_annotation$$branch+0xa0>
 80008d6:	6821      	ldr	r1, [r4, #0]
 80008d8:	7809      	ldrb	r1, [r1, #0]
 80008da:	0789      	lsls	r1, r1, #30
 80008dc:	d400      	bmi.n	80008e0 <__iar_annotation$$branch+0x104>
 80008de:	e0db      	b.n	8000a98 <__iar_annotation$$branch+0xa0>
 80008e0:	21ff      	movs	r1, #255	; 0xff
 80008e2:	1c89      	adds	r1, r1, #2
 80008e4:	82e1      	strh	r1, [r4, #22]
 80008e6:	7831      	ldrb	r1, [r6, #0]
 80008e8:	22e0      	movs	r2, #224	; 0xe0
 80008ea:	400a      	ands	r2, r1
 80008ec:	4310      	orrs	r0, r2
 80008ee:	7030      	strb	r0, [r6, #0]
 80008f0:	7870      	ldrb	r0, [r6, #1]
 80008f2:	2180      	movs	r1, #128	; 0x80
 80008f4:	4301      	orrs	r1, r0
 80008f6:	7071      	strb	r1, [r6, #1]
 80008f8:	6860      	ldr	r0, [r4, #4]
 80008fa:	7800      	ldrb	r0, [r0, #0]
 80008fc:	0640      	lsls	r0, r0, #25
 80008fe:	0f80      	lsrs	r0, r0, #30
 8000900:	6831      	ldr	r1, [r6, #0]
 8000902:	4a96      	ldr	r2, [pc, #600]	; (8000b5c <__iar_annotation$$branch+0x164>)
 8000904:	400a      	ands	r2, r1
 8000906:	0340      	lsls	r0, r0, #13
 8000908:	4310      	orrs	r0, r2
 800090a:	6030      	str	r0, [r6, #0]
 800090c:	4994      	ldr	r1, [pc, #592]	; (8000b60 <__iar_annotation$$branch+0x168>)
 800090e:	4001      	ands	r1, r0
 8000910:	6031      	str	r1, [r6, #0]
 8000912:	7830      	ldrb	r0, [r6, #0]
 8000914:	0680      	lsls	r0, r0, #26
 8000916:	0e80      	lsrs	r0, r0, #26
 8000918:	7030      	strb	r0, [r6, #0]
 800091a:	6830      	ldr	r0, [r6, #0]
 800091c:	b280      	uxth	r0, r0
 800091e:	21ff      	movs	r1, #255	; 0xff
 8000920:	0609      	lsls	r1, r1, #24
 8000922:	4301      	orrs	r1, r0
 8000924:	6031      	str	r1, [r6, #0]
 8000926:	2001      	movs	r0, #1
 8000928:	9002      	str	r0, [sp, #8]
 800092a:	209a      	movs	r0, #154	; 0x9a
 800092c:	9001      	str	r0, [sp, #4]
 800092e:	2001      	movs	r0, #1
 8000930:	9000      	str	r0, [sp, #0]
 8000932:	0033      	movs	r3, r6
 8000934:	220f      	movs	r2, #15
 8000936:	2101      	movs	r1, #1
 8000938:	0020      	movs	r0, r4
 800093a:	f002 ff61 	bl	8003800 <PE_Send_DataMessage>
 800093e:	2800      	cmp	r0, #0
 8000940:	d140      	bne.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000942:	4888      	ldr	r0, [pc, #544]	; (8000b64 <__iar_annotation$$branch+0x16c>)
 8000944:	83b0      	strh	r0, [r6, #28]
 8000946:	251e      	movs	r5, #30
 8000948:	e03c      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 800094a:	2912      	cmp	r1, #18
 800094c:	d136      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 800094e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000950:	0bc0      	lsrs	r0, r0, #15
 8000952:	d133      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 8000954:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000956:	0b00      	lsrs	r0, r0, #12
 8000958:	0740      	lsls	r0, r0, #29
 800095a:	d02f      	beq.n	80009bc <__iar_annotation$$branch+0x1e0>
 800095c:	201f      	movs	r0, #31
 800095e:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000960:	4001      	ands	r1, r0
 8000962:	290f      	cmp	r1, #15
 8000964:	d12a      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 8000966:	219e      	movs	r1, #158	; 0x9e
 8000968:	0049      	lsls	r1, r1, #1
 800096a:	1861      	adds	r1, r4, r1
 800096c:	780a      	ldrb	r2, [r1, #0]
 800096e:	784b      	ldrb	r3, [r1, #1]
 8000970:	021b      	lsls	r3, r3, #8
 8000972:	18d2      	adds	r2, r2, r3
 8000974:	788b      	ldrb	r3, [r1, #2]
 8000976:	041b      	lsls	r3, r3, #16
 8000978:	18d2      	adds	r2, r2, r3
 800097a:	78c9      	ldrb	r1, [r1, #3]
 800097c:	0609      	lsls	r1, r1, #24
 800097e:	1851      	adds	r1, r2, r1
 8000980:	9100      	str	r1, [sp, #0]
 8000982:	4669      	mov	r1, sp
 8000984:	7809      	ldrb	r1, [r1, #0]
 8000986:	4008      	ands	r0, r1
 8000988:	2801      	cmp	r0, #1
 800098a:	d117      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 800098c:	0988      	lsrs	r0, r1, #6
 800098e:	2801      	cmp	r0, #1
 8000990:	d114      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 8000992:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000994:	0440      	lsls	r0, r0, #17
 8000996:	0f40      	lsrs	r0, r0, #29
 8000998:	1e43      	subs	r3, r0, #1
 800099a:	20a0      	movs	r0, #160	; 0xa0
 800099c:	0040      	lsls	r0, r0, #1
 800099e:	1822      	adds	r2, r4, r0
 80009a0:	2113      	movs	r1, #19
 80009a2:	7b27      	ldrb	r7, [r4, #12]
 80009a4:	07f8      	lsls	r0, r7, #31
 80009a6:	0fc0      	lsrs	r0, r0, #31
 80009a8:	68a7      	ldr	r7, [r4, #8]
 80009aa:	69ff      	ldr	r7, [r7, #28]
 80009ac:	47b8      	blx	r7
 80009ae:	2007      	movs	r0, #7
 80009b0:	7230      	strb	r0, [r6, #8]
 80009b2:	2000      	movs	r0, #0
 80009b4:	83b0      	strh	r0, [r6, #28]
 80009b6:	2014      	movs	r0, #20
 80009b8:	4669      	mov	r1, sp
 80009ba:	7308      	strb	r0, [r1, #12]
 80009bc:	8bb0      	ldrh	r0, [r6, #28]
 80009be:	03a9      	lsls	r1, r5, #14
 80009c0:	4288      	cmp	r0, r1
 80009c2:	d05f      	beq.n	8000a84 <__iar_annotation$$branch+0x8c>
 80009c4:	4863      	ldr	r0, [pc, #396]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 80009c6:	68c7      	ldr	r7, [r0, #12]
 80009c8:	2f00      	cmp	r7, #0
 80009ca:	d010      	beq.n	80009ee <__iar_annotation$$branch+0x212>
 80009cc:	7800      	ldrb	r0, [r0, #0]
 80009ce:	07c0      	lsls	r0, r0, #31
 80009d0:	d50d      	bpl.n	80009ee <__iar_annotation$$branch+0x212>
 80009d2:	7a30      	ldrb	r0, [r6, #8]
 80009d4:	7a71      	ldrb	r1, [r6, #9]
 80009d6:	4281      	cmp	r1, r0
 80009d8:	d009      	beq.n	80009ee <__iar_annotation$$branch+0x212>
 80009da:	7270      	strb	r0, [r6, #9]
 80009dc:	2000      	movs	r0, #0
 80009de:	9000      	str	r0, [sp, #0]
 80009e0:	2300      	movs	r3, #0
 80009e2:	7a32      	ldrb	r2, [r6, #8]
 80009e4:	7b20      	ldrb	r0, [r4, #12]
 80009e6:	07c1      	lsls	r1, r0, #31
 80009e8:	0fc9      	lsrs	r1, r1, #31
 80009ea:	2004      	movs	r0, #4
 80009ec:	47b8      	blx	r7
 80009ee:	2701      	movs	r7, #1
 80009f0:	4668      	mov	r0, sp
 80009f2:	7b00      	ldrb	r0, [r0, #12]
 80009f4:	2814      	cmp	r0, #20
 80009f6:	d101      	bne.n	80009fc <__iar_annotation$$branch+0x4>

080009f8 <__iar_annotation$$branch>:
 80009f8:	f001 f8fd 	bl	8001bf6 <__iar_annotation$$branch+0x4>
 80009fc:	0020      	movs	r0, r4
 80009fe:	f003 f809 	bl	8003a14 <PE_Check_AMSConflict>
 8000a02:	2815      	cmp	r0, #21
 8000a04:	d102      	bne.n	8000a0c <__iar_annotation$$branch+0x14>
 8000a06:	2014      	movs	r0, #20
 8000a08:	4669      	mov	r1, sp
 8000a0a:	7308      	strb	r0, [r1, #12]
 8000a0c:	4851      	ldr	r0, [pc, #324]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000a0e:	68c5      	ldr	r5, [r0, #12]
 8000a10:	2d00      	cmp	r5, #0
 8000a12:	d010      	beq.n	8000a36 <__iar_annotation$$branch+0x3e>
 8000a14:	7800      	ldrb	r0, [r0, #0]
 8000a16:	07c0      	lsls	r0, r0, #31
 8000a18:	d50d      	bpl.n	8000a36 <__iar_annotation$$branch+0x3e>
 8000a1a:	7a30      	ldrb	r0, [r6, #8]
 8000a1c:	7a71      	ldrb	r1, [r6, #9]
 8000a1e:	4281      	cmp	r1, r0
 8000a20:	d009      	beq.n	8000a36 <__iar_annotation$$branch+0x3e>
 8000a22:	7270      	strb	r0, [r6, #9]
 8000a24:	2000      	movs	r0, #0
 8000a26:	9000      	str	r0, [sp, #0]
 8000a28:	2300      	movs	r3, #0
 8000a2a:	7a32      	ldrb	r2, [r6, #8]
 8000a2c:	68e0      	ldr	r0, [r4, #12]
 8000a2e:	2101      	movs	r1, #1
 8000a30:	4001      	ands	r1, r0
 8000a32:	2004      	movs	r0, #4
 8000a34:	47a8      	blx	r5
 8000a36:	2500      	movs	r5, #0
 8000a38:	9808      	ldr	r0, [sp, #32]
 8000a3a:	2800      	cmp	r0, #0
 8000a3c:	d01c      	beq.n	8000a78 <__iar_annotation$$branch+0x80>
 8000a3e:	4845      	ldr	r0, [pc, #276]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000a40:	6901      	ldr	r1, [r0, #16]
 8000a42:	4a49      	ldr	r2, [pc, #292]	; (8000b68 <__iar_annotation$$branch+0x170>)
 8000a44:	4291      	cmp	r1, r2
 8000a46:	d017      	beq.n	8000a78 <__iar_annotation$$branch+0x80>
 8000a48:	1d01      	adds	r1, r0, #4
 8000a4a:	68e2      	ldr	r2, [r4, #12]
 8000a4c:	403a      	ands	r2, r7
 8000a4e:	0092      	lsls	r2, r2, #2
 8000a50:	5889      	ldr	r1, [r1, r2]
 8000a52:	68ce      	ldr	r6, [r1, #12]
 8000a54:	0b33      	lsrs	r3, r6, #12
 8000a56:	1c5b      	adds	r3, r3, #1
 8000a58:	4a44      	ldr	r2, [pc, #272]	; (8000b6c <__iar_annotation$$branch+0x174>)
 8000a5a:	4016      	ands	r6, r2
 8000a5c:	031b      	lsls	r3, r3, #12
 8000a5e:	4333      	orrs	r3, r6
 8000a60:	60cb      	str	r3, [r1, #12]
 8000a62:	1d00      	adds	r0, r0, #4
 8000a64:	68e1      	ldr	r1, [r4, #12]
 8000a66:	400f      	ands	r7, r1
 8000a68:	00b9      	lsls	r1, r7, #2
 8000a6a:	5840      	ldr	r0, [r0, r1]
 8000a6c:	68c1      	ldr	r1, [r0, #12]
 8000a6e:	0b0b      	lsrs	r3, r1, #12
 8000a70:	2b08      	cmp	r3, #8
 8000a72:	db01      	blt.n	8000a78 <__iar_annotation$$branch+0x80>
 8000a74:	400a      	ands	r2, r1
 8000a76:	60c2      	str	r2, [r0, #12]
 8000a78:	2d00      	cmp	r5, #0
 8000a7a:	d100      	bne.n	8000a7e <__iar_annotation$$branch+0x86>
 8000a7c:	e5ab      	b.n	80005d6 <USBPD_PE_StateMachine_SRC+0xca>
 8000a7e:	0028      	movs	r0, r5
 8000a80:	b00b      	add	sp, #44	; 0x2c
 8000a82:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000a84:	2000      	movs	r0, #0
 8000a86:	83b0      	strh	r0, [r6, #28]
 8000a88:	2007      	movs	r0, #7
 8000a8a:	7230      	strb	r0, [r6, #8]
 8000a8c:	2010      	movs	r0, #16
 8000a8e:	e7f7      	b.n	8000a80 <__iar_annotation$$branch+0x88>
 8000a90:	8cb0      	ldrh	r0, [r6, #36]	; 0x24
 8000a92:	03a9      	lsls	r1, r5, #14
 8000a94:	4288      	cmp	r0, r1
 8000a96:	d195      	bne.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000a98:	2007      	movs	r0, #7
 8000a9a:	7230      	strb	r0, [r6, #8]
 8000a9c:	2500      	movs	r5, #0
 8000a9e:	e791      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000aa0:	2101      	movs	r1, #1
 8000aa2:	0020      	movs	r0, r4
 8000aa4:	f002 fe0b 	bl	80036be <PE_Send_SRCCapabilities>
 8000aa8:	2805      	cmp	r0, #5
 8000aaa:	d002      	beq.n	8000ab2 <__iar_annotation$$branch+0xba>
 8000aac:	2809      	cmp	r0, #9
 8000aae:	d089      	beq.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000ab0:	e023      	b.n	8000afa <__iar_annotation$$branch+0x102>
 8000ab2:	2001      	movs	r0, #1
 8000ab4:	82e0      	strh	r0, [r4, #22]
 8000ab6:	2002      	movs	r0, #2
 8000ab8:	68e1      	ldr	r1, [r4, #12]
 8000aba:	4301      	orrs	r1, r0
 8000abc:	60e1      	str	r1, [r4, #12]
 8000abe:	2100      	movs	r1, #0
 8000ac0:	7561      	strb	r1, [r4, #21]
 8000ac2:	7521      	strb	r1, [r4, #20]
 8000ac4:	492a      	ldr	r1, [pc, #168]	; (8000b70 <__iar_annotation$$branch+0x178>)
 8000ac6:	83b1      	strh	r1, [r6, #28]
 8000ac8:	251a      	movs	r5, #26
 8000aca:	2116      	movs	r1, #22
 8000acc:	7231      	strb	r1, [r6, #8]
 8000ace:	4f21      	ldr	r7, [pc, #132]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000ad0:	7839      	ldrb	r1, [r7, #0]
 8000ad2:	4201      	tst	r1, r0
 8000ad4:	d009      	beq.n	8000aea <__iar_annotation$$branch+0xf2>
 8000ad6:	2000      	movs	r0, #0
 8000ad8:	9000      	str	r0, [sp, #0]
 8000ada:	2300      	movs	r3, #0
 8000adc:	220f      	movs	r2, #15
 8000ade:	7b20      	ldrb	r0, [r4, #12]
 8000ae0:	07c1      	lsls	r1, r0, #31
 8000ae2:	0fc9      	lsrs	r1, r1, #31
 8000ae4:	2009      	movs	r0, #9
 8000ae6:	68ff      	ldr	r7, [r7, #12]
 8000ae8:	47b8      	blx	r7
 8000aea:	210f      	movs	r1, #15
 8000aec:	7b22      	ldrb	r2, [r4, #12]
 8000aee:	07d0      	lsls	r0, r2, #31
 8000af0:	0fc0      	lsrs	r0, r0, #31
 8000af2:	68a2      	ldr	r2, [r4, #8]
 8000af4:	68d2      	ldr	r2, [r2, #12]
 8000af6:	4790      	blx	r2
 8000af8:	e764      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000afa:	2701      	movs	r7, #1
 8000afc:	68e1      	ldr	r1, [r4, #12]
 8000afe:	2001      	movs	r0, #1
 8000b00:	4008      	ands	r0, r1
 8000b02:	f004 fa37 	bl	8004f74 <USBPD_PRL_SRCReleaseSinkNG>
 8000b06:	68e0      	ldr	r0, [r4, #12]
 8000b08:	0840      	lsrs	r0, r0, #1
 8000b0a:	4007      	ands	r7, r0
 8000b0c:	d107      	bne.n	8000b1e <__iar_annotation$$branch+0x126>
 8000b0e:	7d60      	ldrb	r0, [r4, #21]
 8000b10:	2833      	cmp	r0, #51	; 0x33
 8000b12:	d204      	bcs.n	8000b1e <__iar_annotation$$branch+0x126>
 8000b14:	4817      	ldr	r0, [pc, #92]	; (8000b74 <__iar_annotation$$branch+0x17c>)
 8000b16:	8430      	strh	r0, [r6, #32]
 8000b18:	2596      	movs	r5, #150	; 0x96
 8000b1a:	2008      	movs	r0, #8
 8000b1c:	e6d0      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000b1e:	2f00      	cmp	r7, #0
 8000b20:	d001      	beq.n	8000b26 <__iar_annotation$$branch+0x12e>
 8000b22:	200f      	movs	r0, #15
 8000b24:	e7b9      	b.n	8000a9a <__iar_annotation$$branch+0xa2>
 8000b26:	4f0b      	ldr	r7, [pc, #44]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000b28:	7838      	ldrb	r0, [r7, #0]
 8000b2a:	0780      	lsls	r0, r0, #30
 8000b2c:	d509      	bpl.n	8000b42 <__iar_annotation$$branch+0x14a>
 8000b2e:	2000      	movs	r0, #0
 8000b30:	9000      	str	r0, [sp, #0]
 8000b32:	2300      	movs	r3, #0
 8000b34:	2220      	movs	r2, #32
 8000b36:	7b20      	ldrb	r0, [r4, #12]
 8000b38:	07c1      	lsls	r1, r0, #31
 8000b3a:	0fc9      	lsrs	r1, r1, #31
 8000b3c:	2009      	movs	r0, #9
 8000b3e:	68ff      	ldr	r7, [r7, #12]
 8000b40:	47b8      	blx	r7
 8000b42:	2120      	movs	r1, #32
 8000b44:	7b22      	ldrb	r2, [r4, #12]
 8000b46:	07d0      	lsls	r0, r2, #31
 8000b48:	0fc0      	lsrs	r0, r0, #31
 8000b4a:	68a2      	ldr	r2, [r4, #8]
 8000b4c:	68d2      	ldr	r2, [r2, #12]
 8000b4e:	4790      	blx	r2
 8000b50:	2000      	movs	r0, #0
 8000b52:	e6b5      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000b54:	200019e8 	.word	0x200019e8
 8000b58:	00008014 	.word	0x00008014
 8000b5c:	ffff9fff 	.word	0xffff9fff
 8000b60:	fffff8ff 	.word	0xfffff8ff
 8000b64:	0000801e 	.word	0x0000801e
 8000b68:	b5e8b5cd 	.word	0xb5e8b5cd
 8000b6c:	00000fff 	.word	0x00000fff
 8000b70:	0000801a 	.word	0x0000801a
 8000b74:	00008096 	.word	0x00008096
 8000b78:	8c30      	ldrh	r0, [r6, #32]
 8000b7a:	03a9      	lsls	r1, r5, #14
 8000b7c:	4288      	cmp	r0, r1
 8000b7e:	d1bb      	bne.n	8000af8 <__iar_annotation$$branch+0x100>
 8000b80:	2000      	movs	r0, #0
 8000b82:	8430      	strh	r0, [r6, #32]
 8000b84:	6820      	ldr	r0, [r4, #0]
 8000b86:	6840      	ldr	r0, [r0, #4]
 8000b88:	0601      	lsls	r1, r0, #24
 8000b8a:	0fc9      	lsrs	r1, r1, #31
 8000b8c:	d002      	beq.n	8000b94 <__iar_annotation$$branch+0x19c>
 8000b8e:	7d60      	ldrb	r0, [r4, #21]
 8000b90:	1c40      	adds	r0, r0, #1
 8000b92:	7560      	strb	r0, [r4, #21]
 8000b94:	2007      	movs	r0, #7
 8000b96:	e693      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000b98:	2911      	cmp	r1, #17
 8000b9a:	d132      	bne.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000b9c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000b9e:	0bc0      	lsrs	r0, r0, #15
 8000ba0:	d12f      	bne.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000ba2:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000ba4:	0b00      	lsrs	r0, r0, #12
 8000ba6:	0740      	lsls	r0, r0, #29
 8000ba8:	d02b      	beq.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000baa:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000bac:	06c0      	lsls	r0, r0, #27
 8000bae:	0ec0      	lsrs	r0, r0, #27
 8000bb0:	2802      	cmp	r0, #2
 8000bb2:	d126      	bne.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000bb4:	2501      	movs	r5, #1
 8000bb6:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000bb8:	0600      	lsls	r0, r0, #24
 8000bba:	0f81      	lsrs	r1, r0, #30
 8000bbc:	68e2      	ldr	r2, [r4, #12]
 8000bbe:	2001      	movs	r0, #1
 8000bc0:	4010      	ands	r0, r2
 8000bc2:	f003 fc05 	bl	80043d0 <PE_ExtRevisionInteroperability>
 8000bc6:	209e      	movs	r0, #158	; 0x9e
 8000bc8:	0040      	lsls	r0, r0, #1
 8000bca:	1820      	adds	r0, r4, r0
 8000bcc:	7801      	ldrb	r1, [r0, #0]
 8000bce:	7842      	ldrb	r2, [r0, #1]
 8000bd0:	0212      	lsls	r2, r2, #8
 8000bd2:	1889      	adds	r1, r1, r2
 8000bd4:	7882      	ldrb	r2, [r0, #2]
 8000bd6:	0412      	lsls	r2, r2, #16
 8000bd8:	1889      	adds	r1, r1, r2
 8000bda:	78c0      	ldrb	r0, [r0, #3]
 8000bdc:	0600      	lsls	r0, r0, #24
 8000bde:	1808      	adds	r0, r1, r0
 8000be0:	9000      	str	r0, [sp, #0]
 8000be2:	2304      	movs	r3, #4
 8000be4:	466a      	mov	r2, sp
 8000be6:	2106      	movs	r1, #6
 8000be8:	68e0      	ldr	r0, [r4, #12]
 8000bea:	4005      	ands	r5, r0
 8000bec:	0028      	movs	r0, r5
 8000bee:	68a5      	ldr	r5, [r4, #8]
 8000bf0:	69ed      	ldr	r5, [r5, #28]
 8000bf2:	47a8      	blx	r5
 8000bf4:	2500      	movs	r5, #0
 8000bf6:	83b5      	strh	r5, [r6, #28]
 8000bf8:	2009      	movs	r0, #9
 8000bfa:	7230      	strb	r0, [r6, #8]
 8000bfc:	2014      	movs	r0, #20
 8000bfe:	4669      	mov	r1, sp
 8000c00:	7308      	strb	r0, [r1, #12]
 8000c02:	8bb0      	ldrh	r0, [r6, #28]
 8000c04:	2180      	movs	r1, #128	; 0x80
 8000c06:	0209      	lsls	r1, r1, #8
 8000c08:	4288      	cmp	r0, r1
 8000c0a:	d163      	bne.n	8000cd4 <__iar_annotation$$branch+0x2dc>
 8000c0c:	e1d3      	b.n	8000fb6 <__iar_annotation$$branch+0x5be>
 8000c0e:	a901      	add	r1, sp, #4
 8000c10:	7b22      	ldrb	r2, [r4, #12]
 8000c12:	07d0      	lsls	r0, r2, #31
 8000c14:	0fc0      	lsrs	r0, r0, #31
 8000c16:	68a2      	ldr	r2, [r4, #8]
 8000c18:	6a12      	ldr	r2, [r2, #32]
 8000c1a:	4790      	blx	r2
 8000c1c:	280a      	cmp	r0, #10
 8000c1e:	d01c      	beq.n	8000c5a <__iar_annotation$$branch+0x262>
 8000c20:	280b      	cmp	r0, #11
 8000c22:	d002      	beq.n	8000c2a <__iar_annotation$$branch+0x232>
 8000c24:	280d      	cmp	r0, #13
 8000c26:	d056      	beq.n	8000cd6 <__iar_annotation$$branch+0x2de>
 8000c28:	e06d      	b.n	8000d06 <__iar_annotation$$branch+0x30e>
 8000c2a:	2000      	movs	r0, #0
 8000c2c:	9000      	str	r0, [sp, #0]
 8000c2e:	230c      	movs	r3, #12
 8000c30:	2202      	movs	r2, #2
 8000c32:	2100      	movs	r1, #0
 8000c34:	0020      	movs	r0, r4
 8000c36:	f002 fd9c 	bl	8003772 <PE_Send_CtrlMessage>
 8000c3a:	4fb8      	ldr	r7, [pc, #736]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000c3c:	7838      	ldrb	r0, [r7, #0]
 8000c3e:	0780      	lsls	r0, r0, #30
 8000c40:	d509      	bpl.n	8000c56 <__iar_annotation$$branch+0x25e>
 8000c42:	2000      	movs	r0, #0
 8000c44:	9000      	str	r0, [sp, #0]
 8000c46:	2300      	movs	r3, #0
 8000c48:	2204      	movs	r2, #4
 8000c4a:	7b20      	ldrb	r0, [r4, #12]
 8000c4c:	07c1      	lsls	r1, r0, #31
 8000c4e:	0fc9      	lsrs	r1, r1, #31
 8000c50:	2009      	movs	r0, #9
 8000c52:	68ff      	ldr	r7, [r7, #12]
 8000c54:	47b8      	blx	r7
 8000c56:	2104      	movs	r1, #4
 8000c58:	e748      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000c5a:	6860      	ldr	r0, [r4, #4]
 8000c5c:	7840      	ldrb	r0, [r0, #1]
 8000c5e:	0640      	lsls	r0, r0, #25
 8000c60:	0f40      	lsrs	r0, r0, #29
 8000c62:	2801      	cmp	r0, #1
 8000c64:	d00c      	beq.n	8000c80 <__iar_annotation$$branch+0x288>
 8000c66:	4668      	mov	r0, sp
 8000c68:	7900      	ldrb	r0, [r0, #4]
 8000c6a:	2803      	cmp	r0, #3
 8000c6c:	d108      	bne.n	8000c80 <__iar_annotation$$branch+0x288>
 8000c6e:	7b20      	ldrb	r0, [r4, #12]
 8000c70:	0700      	lsls	r0, r0, #28
 8000c72:	0f80      	lsrs	r0, r0, #30
 8000c74:	2803      	cmp	r0, #3
 8000c76:	d103      	bne.n	8000c80 <__iar_annotation$$branch+0x288>
 8000c78:	03a8      	lsls	r0, r5, #14
 8000c7a:	8470      	strh	r0, [r6, #34]	; 0x22
 8000c7c:	2500      	movs	r5, #0
 8000c7e:	e002      	b.n	8000c86 <__iar_annotation$$branch+0x28e>
 8000c80:	48a7      	ldr	r0, [pc, #668]	; (8000f20 <__iar_annotation$$branch+0x528>)
 8000c82:	8470      	strh	r0, [r6, #34]	; 0x22
 8000c84:	251e      	movs	r5, #30
 8000c86:	2000      	movs	r0, #0
 8000c88:	9000      	str	r0, [sp, #0]
 8000c8a:	230c      	movs	r3, #12
 8000c8c:	2203      	movs	r2, #3
 8000c8e:	2100      	movs	r1, #0
 8000c90:	0020      	movs	r0, r4
 8000c92:	f002 fd6e 	bl	8003772 <PE_Send_CtrlMessage>
 8000c96:	4fa1      	ldr	r7, [pc, #644]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000c98:	7838      	ldrb	r0, [r7, #0]
 8000c9a:	0780      	lsls	r0, r0, #30
 8000c9c:	d509      	bpl.n	8000cb2 <__iar_annotation$$branch+0x2ba>
 8000c9e:	2000      	movs	r0, #0
 8000ca0:	9000      	str	r0, [sp, #0]
 8000ca2:	2300      	movs	r3, #0
 8000ca4:	2201      	movs	r2, #1
 8000ca6:	7b20      	ldrb	r0, [r4, #12]
 8000ca8:	07c1      	lsls	r1, r0, #31
 8000caa:	0fc9      	lsrs	r1, r1, #31
 8000cac:	2009      	movs	r0, #9
 8000cae:	68ff      	ldr	r7, [r7, #12]
 8000cb0:	47b8      	blx	r7
 8000cb2:	2101      	movs	r1, #1
 8000cb4:	7b22      	ldrb	r2, [r4, #12]
 8000cb6:	07d0      	lsls	r0, r2, #31
 8000cb8:	0fc0      	lsrs	r0, r0, #31
 8000cba:	68a2      	ldr	r2, [r4, #8]
 8000cbc:	68d2      	ldr	r2, [r2, #12]
 8000cbe:	4790      	blx	r2
 8000cc0:	7b21      	ldrb	r1, [r4, #12]
 8000cc2:	20f3      	movs	r0, #243	; 0xf3
 8000cc4:	4008      	ands	r0, r1
 8000cc6:	4669      	mov	r1, sp
 8000cc8:	7909      	ldrb	r1, [r1, #4]
 8000cca:	0089      	lsls	r1, r1, #2
 8000ccc:	220c      	movs	r2, #12
 8000cce:	400a      	ands	r2, r1
 8000cd0:	4302      	orrs	r2, r0
 8000cd2:	7322      	strb	r2, [r4, #12]
 8000cd4:	e676      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000cd6:	2000      	movs	r0, #0
 8000cd8:	9000      	str	r0, [sp, #0]
 8000cda:	2303      	movs	r3, #3
 8000cdc:	220c      	movs	r2, #12
 8000cde:	2100      	movs	r1, #0
 8000ce0:	0020      	movs	r0, r4
 8000ce2:	f002 fd46 	bl	8003772 <PE_Send_CtrlMessage>
 8000ce6:	4f8d      	ldr	r7, [pc, #564]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000ce8:	7838      	ldrb	r0, [r7, #0]
 8000cea:	0780      	lsls	r0, r0, #30
 8000cec:	d509      	bpl.n	8000d02 <__iar_annotation$$branch+0x30a>
 8000cee:	2000      	movs	r0, #0
 8000cf0:	9000      	str	r0, [sp, #0]
 8000cf2:	2300      	movs	r3, #0
 8000cf4:	2203      	movs	r2, #3
 8000cf6:	7b20      	ldrb	r0, [r4, #12]
 8000cf8:	07c1      	lsls	r1, r0, #31
 8000cfa:	0fc9      	lsrs	r1, r1, #31
 8000cfc:	2009      	movs	r0, #9
 8000cfe:	68ff      	ldr	r7, [r7, #12]
 8000d00:	47b8      	blx	r7
 8000d02:	2103      	movs	r1, #3
 8000d04:	e6f2      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000d06:	2000      	movs	r0, #0
 8000d08:	9000      	str	r0, [sp, #0]
 8000d0a:	230e      	movs	r3, #14
 8000d0c:	2204      	movs	r2, #4
 8000d0e:	2100      	movs	r1, #0
 8000d10:	0020      	movs	r0, r4
 8000d12:	f002 fd2e 	bl	8003772 <PE_Send_CtrlMessage>
 8000d16:	4f81      	ldr	r7, [pc, #516]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000d18:	7838      	ldrb	r0, [r7, #0]
 8000d1a:	0780      	lsls	r0, r0, #30
 8000d1c:	d509      	bpl.n	8000d32 <__iar_annotation$$branch+0x33a>
 8000d1e:	2000      	movs	r0, #0
 8000d20:	9000      	str	r0, [sp, #0]
 8000d22:	2300      	movs	r3, #0
 8000d24:	2202      	movs	r2, #2
 8000d26:	7b20      	ldrb	r0, [r4, #12]
 8000d28:	07c1      	lsls	r1, r0, #31
 8000d2a:	0fc9      	lsrs	r1, r1, #31
 8000d2c:	2009      	movs	r0, #9
 8000d2e:	68ff      	ldr	r7, [r7, #12]
 8000d30:	47b8      	blx	r7
 8000d32:	2102      	movs	r1, #2
 8000d34:	e6da      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000d36:	8c71      	ldrh	r1, [r6, #34]	; 0x22
 8000d38:	03aa      	lsls	r2, r5, #14
 8000d3a:	4291      	cmp	r1, r2
 8000d3c:	d1ca      	bne.n	8000cd4 <__iar_annotation$$branch+0x2dc>
 8000d3e:	2100      	movs	r1, #0
 8000d40:	8471      	strh	r1, [r6, #34]	; 0x22
 8000d42:	6861      	ldr	r1, [r4, #4]
 8000d44:	784a      	ldrb	r2, [r1, #1]
 8000d46:	238f      	movs	r3, #143	; 0x8f
 8000d48:	4013      	ands	r3, r2
 8000d4a:	2240      	movs	r2, #64	; 0x40
 8000d4c:	431a      	orrs	r2, r3
 8000d4e:	704a      	strb	r2, [r1, #1]
 8000d50:	2800      	cmp	r0, #0
 8000d52:	d009      	beq.n	8000d68 <__iar_annotation$$branch+0x370>
 8000d54:	2000      	movs	r0, #0
 8000d56:	9000      	str	r0, [sp, #0]
 8000d58:	2300      	movs	r3, #0
 8000d5a:	2256      	movs	r2, #86	; 0x56
 8000d5c:	7b20      	ldrb	r0, [r4, #12]
 8000d5e:	07c1      	lsls	r1, r0, #31
 8000d60:	0fc9      	lsrs	r1, r1, #31
 8000d62:	2009      	movs	r0, #9
 8000d64:	9f01      	ldr	r7, [sp, #4]
 8000d66:	47b8      	blx	r7
 8000d68:	2701      	movs	r7, #1
 8000d6a:	2156      	movs	r1, #86	; 0x56
 8000d6c:	68e2      	ldr	r2, [r4, #12]
 8000d6e:	2001      	movs	r0, #1
 8000d70:	4010      	ands	r0, r2
 8000d72:	68a2      	ldr	r2, [r4, #8]
 8000d74:	68d2      	ldr	r2, [r2, #12]
 8000d76:	4790      	blx	r2
 8000d78:	68a0      	ldr	r0, [r4, #8]
 8000d7a:	6801      	ldr	r1, [r0, #0]
 8000d7c:	2900      	cmp	r1, #0
 8000d7e:	d007      	beq.n	8000d90 <__iar_annotation$$branch+0x398>
 8000d80:	68e0      	ldr	r0, [r4, #12]
 8000d82:	4007      	ands	r7, r0
 8000d84:	0038      	movs	r0, r7
 8000d86:	4788      	blx	r1
 8000d88:	2800      	cmp	r0, #0
 8000d8a:	d001      	beq.n	8000d90 <__iar_annotation$$branch+0x398>
 8000d8c:	200f      	movs	r0, #15
 8000d8e:	7230      	strb	r0, [r6, #8]
 8000d90:	200d      	movs	r0, #13
 8000d92:	e595      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000d94:	2000      	movs	r0, #0
 8000d96:	9000      	str	r0, [sp, #0]
 8000d98:	2303      	movs	r3, #3
 8000d9a:	2206      	movs	r2, #6
 8000d9c:	2100      	movs	r1, #0
 8000d9e:	0020      	movs	r0, r4
 8000da0:	f002 fce7 	bl	8003772 <PE_Send_CtrlMessage>
 8000da4:	2800      	cmp	r0, #0
 8000da6:	d12e      	bne.n	8000e06 <__iar_annotation$$branch+0x40e>
 8000da8:	6860      	ldr	r0, [r4, #4]
 8000daa:	7841      	ldrb	r1, [r0, #1]
 8000dac:	228f      	movs	r2, #143	; 0x8f
 8000dae:	400a      	ands	r2, r1
 8000db0:	2130      	movs	r1, #48	; 0x30
 8000db2:	4311      	orrs	r1, r2
 8000db4:	7041      	strb	r1, [r0, #1]
 8000db6:	4859      	ldr	r0, [pc, #356]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000db8:	7800      	ldrb	r0, [r0, #0]
 8000dba:	0780      	lsls	r0, r0, #30
 8000dbc:	d50a      	bpl.n	8000dd4 <__iar_annotation$$branch+0x3dc>
 8000dbe:	2000      	movs	r0, #0
 8000dc0:	9000      	str	r0, [sp, #0]
 8000dc2:	2300      	movs	r3, #0
 8000dc4:	2256      	movs	r2, #86	; 0x56
 8000dc6:	7b20      	ldrb	r0, [r4, #12]
 8000dc8:	07c1      	lsls	r1, r0, #31
 8000dca:	0fc9      	lsrs	r1, r1, #31
 8000dcc:	2009      	movs	r0, #9
 8000dce:	4f53      	ldr	r7, [pc, #332]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000dd0:	68ff      	ldr	r7, [r7, #12]
 8000dd2:	47b8      	blx	r7
 8000dd4:	2156      	movs	r1, #86	; 0x56
 8000dd6:	7b22      	ldrb	r2, [r4, #12]
 8000dd8:	07d0      	lsls	r0, r2, #31
 8000dda:	0fc0      	lsrs	r0, r0, #31
 8000ddc:	68a2      	ldr	r2, [r4, #8]
 8000dde:	68d2      	ldr	r2, [r2, #12]
 8000de0:	4790      	blx	r2
 8000de2:	4f4e      	ldr	r7, [pc, #312]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000de4:	7838      	ldrb	r0, [r7, #0]
 8000de6:	0780      	lsls	r0, r0, #30
 8000de8:	d509      	bpl.n	8000dfe <__iar_annotation$$branch+0x406>
 8000dea:	2000      	movs	r0, #0
 8000dec:	9000      	str	r0, [sp, #0]
 8000dee:	2300      	movs	r3, #0
 8000df0:	2210      	movs	r2, #16
 8000df2:	7b20      	ldrb	r0, [r4, #12]
 8000df4:	07c1      	lsls	r1, r0, #31
 8000df6:	0fc9      	lsrs	r1, r1, #31
 8000df8:	2009      	movs	r0, #9
 8000dfa:	68ff      	ldr	r7, [r7, #12]
 8000dfc:	47b8      	blx	r7
 8000dfe:	2110      	movs	r1, #16
 8000e00:	e674      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000e02:	2500      	movs	r5, #0
 8000e04:	43ed      	mvns	r5, r5
 8000e06:	e5dd      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000e08:	6860      	ldr	r0, [r4, #4]
 8000e0a:	7840      	ldrb	r0, [r0, #1]
 8000e0c:	0640      	lsls	r0, r0, #25
 8000e0e:	0f40      	lsrs	r0, r0, #29
 8000e10:	2803      	cmp	r0, #3
 8000e12:	d001      	beq.n	8000e18 <__iar_annotation$$branch+0x420>
 8000e14:	200e      	movs	r0, #14
 8000e16:	e553      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000e18:	7a30      	ldrb	r0, [r6, #8]
 8000e1a:	280a      	cmp	r0, #10
 8000e1c:	d007      	beq.n	8000e2e <__iar_annotation$$branch+0x436>
 8000e1e:	7b21      	ldrb	r1, [r4, #12]
 8000e20:	07c8      	lsls	r0, r1, #31
 8000e22:	0fc0      	lsrs	r0, r0, #31
 8000e24:	68a1      	ldr	r1, [r4, #8]
 8000e26:	6909      	ldr	r1, [r1, #16]
 8000e28:	4788      	blx	r1
 8000e2a:	2800      	cmp	r0, #0
 8000e2c:	d101      	bne.n	8000e32 <__iar_annotation$$branch+0x43a>
 8000e2e:	2003      	movs	r0, #3
 8000e30:	e546      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000e32:	200f      	movs	r0, #15
 8000e34:	e544      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000e36:	2001      	movs	r0, #1
 8000e38:	9000      	str	r0, [sp, #0]
 8000e3a:	2397      	movs	r3, #151	; 0x97
 8000e3c:	2202      	movs	r2, #2
 8000e3e:	2100      	movs	r1, #0
 8000e40:	0020      	movs	r0, r4
 8000e42:	f002 fc96 	bl	8003772 <PE_Send_CtrlMessage>
 8000e46:	2800      	cmp	r0, #0
 8000e48:	d11a      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000e4a:	2002      	movs	r0, #2
 8000e4c:	82e0      	strh	r0, [r4, #22]
 8000e4e:	2501      	movs	r5, #1
 8000e50:	4f32      	ldr	r7, [pc, #200]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000e52:	7839      	ldrb	r1, [r7, #0]
 8000e54:	4201      	tst	r1, r0
 8000e56:	d009      	beq.n	8000e6c <__iar_annotation$$branch+0x474>
 8000e58:	2000      	movs	r0, #0
 8000e5a:	9000      	str	r0, [sp, #0]
 8000e5c:	2300      	movs	r3, #0
 8000e5e:	2227      	movs	r2, #39	; 0x27
 8000e60:	68e0      	ldr	r0, [r4, #12]
 8000e62:	2101      	movs	r1, #1
 8000e64:	4001      	ands	r1, r0
 8000e66:	2009      	movs	r0, #9
 8000e68:	68ff      	ldr	r7, [r7, #12]
 8000e6a:	47b8      	blx	r7
 8000e6c:	2127      	movs	r1, #39	; 0x27
 8000e6e:	68e0      	ldr	r0, [r4, #12]
 8000e70:	4005      	ands	r5, r0
 8000e72:	0028      	movs	r0, r5
 8000e74:	68a2      	ldr	r2, [r4, #8]
 8000e76:	68d2      	ldr	r2, [r2, #12]
 8000e78:	4790      	blx	r2
 8000e7a:	48bc      	ldr	r0, [pc, #752]	; (800116c <__iar_annotation$$branch+0x774>)
 8000e7c:	8470      	strh	r0, [r6, #34]	; 0x22
 8000e7e:	4dbc      	ldr	r5, [pc, #752]	; (8001170 <__iar_annotation$$branch+0x778>)
 8000e80:	e5a0      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000e82:	8c71      	ldrh	r1, [r6, #34]	; 0x22
 8000e84:	03aa      	lsls	r2, r5, #14
 8000e86:	4291      	cmp	r1, r2
 8000e88:	d1fa      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000e8a:	2800      	cmp	r0, #0
 8000e8c:	d009      	beq.n	8000ea2 <__iar_annotation$$branch+0x4aa>
 8000e8e:	2000      	movs	r0, #0
 8000e90:	9000      	str	r0, [sp, #0]
 8000e92:	2300      	movs	r3, #0
 8000e94:	2228      	movs	r2, #40	; 0x28
 8000e96:	7b20      	ldrb	r0, [r4, #12]
 8000e98:	07c1      	lsls	r1, r0, #31
 8000e9a:	0fc9      	lsrs	r1, r1, #31
 8000e9c:	2009      	movs	r0, #9
 8000e9e:	9f01      	ldr	r7, [sp, #4]
 8000ea0:	47b8      	blx	r7
 8000ea2:	2128      	movs	r1, #40	; 0x28
 8000ea4:	7b22      	ldrb	r2, [r4, #12]
 8000ea6:	07d0      	lsls	r0, r2, #31
 8000ea8:	0fc0      	lsrs	r0, r0, #31
 8000eaa:	68a2      	ldr	r2, [r4, #8]
 8000eac:	68d2      	ldr	r2, [r2, #12]
 8000eae:	4790      	blx	r2
 8000eb0:	2000      	movs	r0, #0
 8000eb2:	9000      	str	r0, [sp, #0]
 8000eb4:	2303      	movs	r3, #3
 8000eb6:	2206      	movs	r2, #6
 8000eb8:	2100      	movs	r1, #0
 8000eba:	0020      	movs	r0, r4
 8000ebc:	f002 fc59 	bl	8003772 <PE_Send_CtrlMessage>
 8000ec0:	2800      	cmp	r0, #0
 8000ec2:	d1dd      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000ec4:	4f15      	ldr	r7, [pc, #84]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000ec6:	7838      	ldrb	r0, [r7, #0]
 8000ec8:	0780      	lsls	r0, r0, #30
 8000eca:	d509      	bpl.n	8000ee0 <__iar_annotation$$branch+0x4e8>
 8000ecc:	2000      	movs	r0, #0
 8000ece:	9000      	str	r0, [sp, #0]
 8000ed0:	2300      	movs	r3, #0
 8000ed2:	222c      	movs	r2, #44	; 0x2c
 8000ed4:	7b20      	ldrb	r0, [r4, #12]
 8000ed6:	07c1      	lsls	r1, r0, #31
 8000ed8:	0fc9      	lsrs	r1, r1, #31
 8000eda:	2009      	movs	r0, #9
 8000edc:	68ff      	ldr	r7, [r7, #12]
 8000ede:	47b8      	blx	r7
 8000ee0:	212c      	movs	r1, #44	; 0x2c
 8000ee2:	e603      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000ee4:	0020      	movs	r0, r4
 8000ee6:	f002 fd2a 	bl	800393e <PE_PerformSoftReset>
 8000eea:	2000      	movs	r0, #0
 8000eec:	9000      	str	r0, [sp, #0]
 8000eee:	2307      	movs	r3, #7
 8000ef0:	2203      	movs	r2, #3
 8000ef2:	2100      	movs	r1, #0
 8000ef4:	0020      	movs	r0, r4
 8000ef6:	f002 fc3c 	bl	8003772 <PE_Send_CtrlMessage>
 8000efa:	4f08      	ldr	r7, [pc, #32]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000efc:	7838      	ldrb	r0, [r7, #0]
 8000efe:	0780      	lsls	r0, r0, #30
 8000f00:	d509      	bpl.n	8000f16 <__iar_annotation$$branch+0x51e>
 8000f02:	2000      	movs	r0, #0
 8000f04:	9000      	str	r0, [sp, #0]
 8000f06:	2300      	movs	r3, #0
 8000f08:	222f      	movs	r2, #47	; 0x2f
 8000f0a:	7b20      	ldrb	r0, [r4, #12]
 8000f0c:	07c1      	lsls	r1, r0, #31
 8000f0e:	0fc9      	lsrs	r1, r1, #31
 8000f10:	2009      	movs	r0, #9
 8000f12:	68ff      	ldr	r7, [r7, #12]
 8000f14:	47b8      	blx	r7
 8000f16:	212f      	movs	r1, #47	; 0x2f
 8000f18:	e5e8      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000f1a:	bf00      	nop
 8000f1c:	200019e8 	.word	0x200019e8
 8000f20:	0000801e 	.word	0x0000801e
 8000f24:	2000      	movs	r0, #0
 8000f26:	9000      	str	r0, [sp, #0]
 8000f28:	2312      	movs	r3, #18
 8000f2a:	220d      	movs	r2, #13
 8000f2c:	2100      	movs	r1, #0
 8000f2e:	0020      	movs	r0, r4
 8000f30:	f002 fc1f 	bl	8003772 <PE_Send_CtrlMessage>
 8000f34:	2800      	cmp	r0, #0
 8000f36:	d1a3      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000f38:	488e      	ldr	r0, [pc, #568]	; (8001174 <__iar_annotation$$branch+0x77c>)
 8000f3a:	83b0      	strh	r0, [r6, #28]
 8000f3c:	251a      	movs	r5, #26
 8000f3e:	4f8e      	ldr	r7, [pc, #568]	; (8001178 <__iar_annotation$$branch+0x780>)
 8000f40:	7838      	ldrb	r0, [r7, #0]
 8000f42:	0780      	lsls	r0, r0, #30
 8000f44:	d509      	bpl.n	8000f5a <__iar_annotation$$branch+0x562>
 8000f46:	2000      	movs	r0, #0
 8000f48:	9000      	str	r0, [sp, #0]
 8000f4a:	2300      	movs	r3, #0
 8000f4c:	222e      	movs	r2, #46	; 0x2e
 8000f4e:	7b20      	ldrb	r0, [r4, #12]
 8000f50:	07c1      	lsls	r1, r0, #31
 8000f52:	0fc9      	lsrs	r1, r1, #31
 8000f54:	2009      	movs	r0, #9
 8000f56:	68ff      	ldr	r7, [r7, #12]
 8000f58:	47b8      	blx	r7
 8000f5a:	212e      	movs	r1, #46	; 0x2e
 8000f5c:	e5c6      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000f5e:	2911      	cmp	r1, #17
 8000f60:	d124      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f62:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000f64:	0bc9      	lsrs	r1, r1, #15
 8000f66:	d121      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f68:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000f6a:	0b09      	lsrs	r1, r1, #12
 8000f6c:	0749      	lsls	r1, r1, #29
 8000f6e:	d11d      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f70:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000f72:	06c9      	lsls	r1, r1, #27
 8000f74:	0ec9      	lsrs	r1, r1, #27
 8000f76:	2903      	cmp	r1, #3
 8000f78:	d118      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f7a:	2100      	movs	r1, #0
 8000f7c:	83b1      	strh	r1, [r6, #28]
 8000f7e:	2800      	cmp	r0, #0
 8000f80:	d008      	beq.n	8000f94 <__iar_annotation$$branch+0x59c>
 8000f82:	9100      	str	r1, [sp, #0]
 8000f84:	2300      	movs	r3, #0
 8000f86:	222f      	movs	r2, #47	; 0x2f
 8000f88:	7b20      	ldrb	r0, [r4, #12]
 8000f8a:	07c1      	lsls	r1, r0, #31
 8000f8c:	0fc9      	lsrs	r1, r1, #31
 8000f8e:	2009      	movs	r0, #9
 8000f90:	9f01      	ldr	r7, [sp, #4]
 8000f92:	47b8      	blx	r7
 8000f94:	212f      	movs	r1, #47	; 0x2f
 8000f96:	7b22      	ldrb	r2, [r4, #12]
 8000f98:	07d0      	lsls	r0, r2, #31
 8000f9a:	0fc0      	lsrs	r0, r0, #31
 8000f9c:	68a2      	ldr	r2, [r4, #8]
 8000f9e:	68d2      	ldr	r2, [r2, #12]
 8000fa0:	4790      	blx	r2
 8000fa2:	2007      	movs	r0, #7
 8000fa4:	7230      	strb	r0, [r6, #8]
 8000fa6:	2014      	movs	r0, #20
 8000fa8:	4669      	mov	r1, sp
 8000faa:	7308      	strb	r0, [r1, #12]
 8000fac:	8bb0      	ldrh	r0, [r6, #28]
 8000fae:	03a9      	lsls	r1, r5, #14
 8000fb0:	4288      	cmp	r0, r1
 8000fb2:	d000      	beq.n	8000fb6 <__iar_annotation$$branch+0x5be>
 8000fb4:	e506      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000fb6:	2000      	movs	r0, #0
 8000fb8:	83b0      	strh	r0, [r6, #28]
 8000fba:	e73a      	b.n	8000e32 <__iar_annotation$$branch+0x43a>
 8000fbc:	7b60      	ldrb	r0, [r4, #13]
 8000fbe:	21fc      	movs	r1, #252	; 0xfc
 8000fc0:	4001      	ands	r1, r0
 8000fc2:	7361      	strb	r1, [r4, #13]
 8000fc4:	0020      	movs	r0, r4
 8000fc6:	f002 fc81 	bl	80038cc <PE_Send_HARDRESET>
 8000fca:	68a0      	ldr	r0, [r4, #8]
 8000fcc:	6843      	ldr	r3, [r0, #4]
 8000fce:	2b00      	cmp	r3, #0
 8000fd0:	d005      	beq.n	8000fde <__iar_annotation$$branch+0x5e6>
 8000fd2:	2202      	movs	r2, #2
 8000fd4:	2101      	movs	r1, #1
 8000fd6:	7b25      	ldrb	r5, [r4, #12]
 8000fd8:	07e8      	lsls	r0, r5, #31
 8000fda:	0fc0      	lsrs	r0, r0, #31
 8000fdc:	4798      	blx	r3
 8000fde:	4867      	ldr	r0, [pc, #412]	; (800117c <__iar_annotation$$branch+0x784>)
 8000fe0:	82f0      	strh	r0, [r6, #22]
 8000fe2:	251b      	movs	r5, #27
 8000fe4:	7d20      	ldrb	r0, [r4, #20]
 8000fe6:	1c40      	adds	r0, r0, #1
 8000fe8:	7520      	strb	r0, [r4, #20]
 8000fea:	6860      	ldr	r0, [r4, #4]
 8000fec:	6801      	ldr	r1, [r0, #0]
 8000fee:	2210      	movs	r2, #16
 8000ff0:	4391      	bics	r1, r2
 8000ff2:	6001      	str	r1, [r0, #0]
 8000ff4:	2000      	movs	r0, #0
 8000ff6:	7130      	strb	r0, [r6, #4]
 8000ff8:	2015      	movs	r0, #21
 8000ffa:	e461      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000ffc:	495f      	ldr	r1, [pc, #380]	; (800117c <__iar_annotation$$branch+0x784>)
 8000ffe:	82f1      	strh	r1, [r6, #22]
 8001000:	251b      	movs	r5, #27
 8001002:	2115      	movs	r1, #21
 8001004:	7231      	strb	r1, [r6, #8]
 8001006:	2800      	cmp	r0, #0
 8001008:	d009      	beq.n	800101e <__iar_annotation$$branch+0x626>
 800100a:	2000      	movs	r0, #0
 800100c:	9000      	str	r0, [sp, #0]
 800100e:	2300      	movs	r3, #0
 8001010:	221d      	movs	r2, #29
 8001012:	7b20      	ldrb	r0, [r4, #12]
 8001014:	07c1      	lsls	r1, r0, #31
 8001016:	0fc9      	lsrs	r1, r1, #31
 8001018:	2009      	movs	r0, #9
 800101a:	9f01      	ldr	r7, [sp, #4]
 800101c:	47b8      	blx	r7
 800101e:	211d      	movs	r1, #29
 8001020:	e564      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8001022:	8af0      	ldrh	r0, [r6, #22]
 8001024:	03a9      	lsls	r1, r5, #14
 8001026:	4288      	cmp	r0, r1
 8001028:	d150      	bne.n	80010cc <__iar_annotation$$branch+0x6d4>
 800102a:	2000      	movs	r0, #0
 800102c:	82f0      	strh	r0, [r6, #22]
 800102e:	7d21      	ldrb	r1, [r4, #20]
 8001030:	2903      	cmp	r1, #3
 8001032:	d311      	bcc.n	8001058 <__iar_annotation$$branch+0x660>
 8001034:	7520      	strb	r0, [r4, #20]
 8001036:	7230      	strb	r0, [r6, #8]
 8001038:	4f4f      	ldr	r7, [pc, #316]	; (8001178 <__iar_annotation$$branch+0x780>)
 800103a:	7838      	ldrb	r0, [r7, #0]
 800103c:	0780      	lsls	r0, r0, #30
 800103e:	d509      	bpl.n	8001054 <__iar_annotation$$branch+0x65c>
 8001040:	2000      	movs	r0, #0
 8001042:	9000      	str	r0, [sp, #0]
 8001044:	2300      	movs	r3, #0
 8001046:	2220      	movs	r2, #32
 8001048:	7b20      	ldrb	r0, [r4, #12]
 800104a:	07c1      	lsls	r1, r0, #31
 800104c:	0fc9      	lsrs	r1, r1, #31
 800104e:	2009      	movs	r0, #9
 8001050:	68ff      	ldr	r7, [r7, #12]
 8001052:	47b8      	blx	r7
 8001054:	2120      	movs	r1, #32
 8001056:	e549      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8001058:	68a0      	ldr	r0, [r4, #8]
 800105a:	6843      	ldr	r3, [r0, #4]
 800105c:	2b00      	cmp	r3, #0
 800105e:	d00a      	beq.n	8001076 <__iar_annotation$$branch+0x67e>
 8001060:	7b60      	ldrb	r0, [r4, #13]
 8001062:	0780      	lsls	r0, r0, #30
 8001064:	0f80      	lsrs	r0, r0, #30
 8001066:	1e42      	subs	r2, r0, #1
 8001068:	4192      	sbcs	r2, r2
 800106a:	0fd2      	lsrs	r2, r2, #31
 800106c:	2101      	movs	r1, #1
 800106e:	7b25      	ldrb	r5, [r4, #12]
 8001070:	07e8      	lsls	r0, r5, #31
 8001072:	0fc0      	lsrs	r0, r0, #31
 8001074:	4798      	blx	r3
 8001076:	4842      	ldr	r0, [pc, #264]	; (8001180 <__iar_annotation$$branch+0x788>)
 8001078:	9904      	ldr	r1, [sp, #16]
 800107a:	8008      	strh	r0, [r1, #0]
 800107c:	25c8      	movs	r5, #200	; 0xc8
 800107e:	00ad      	lsls	r5, r5, #2
 8001080:	2013      	movs	r0, #19
 8001082:	e41d      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8001084:	68a0      	ldr	r0, [r4, #8]
 8001086:	6843      	ldr	r3, [r0, #4]
 8001088:	2701      	movs	r7, #1
 800108a:	2b00      	cmp	r3, #0
 800108c:	d005      	beq.n	800109a <__iar_annotation$$branch+0x6a2>
 800108e:	2204      	movs	r2, #4
 8001090:	68e1      	ldr	r1, [r4, #12]
 8001092:	2001      	movs	r0, #1
 8001094:	4008      	ands	r0, r1
 8001096:	2101      	movs	r1, #1
 8001098:	4798      	blx	r3
 800109a:	8ab0      	ldrh	r0, [r6, #20]
 800109c:	03a9      	lsls	r1, r5, #14
 800109e:	4288      	cmp	r0, r1
 80010a0:	d114      	bne.n	80010cc <__iar_annotation$$branch+0x6d4>
 80010a2:	2000      	movs	r0, #0
 80010a4:	9904      	ldr	r1, [sp, #16]
 80010a6:	8008      	strh	r0, [r1, #0]
 80010a8:	68a0      	ldr	r0, [r4, #8]
 80010aa:	6843      	ldr	r3, [r0, #4]
 80010ac:	2b00      	cmp	r3, #0
 80010ae:	d005      	beq.n	80010bc <__iar_annotation$$branch+0x6c4>
 80010b0:	2205      	movs	r2, #5
 80010b2:	2101      	movs	r1, #1
 80010b4:	68e0      	ldr	r0, [r4, #12]
 80010b6:	4007      	ands	r7, r0
 80010b8:	0038      	movs	r0, r7
 80010ba:	4798      	blx	r3
 80010bc:	4831      	ldr	r0, [pc, #196]	; (8001184 <__iar_annotation$$branch+0x78c>)
 80010be:	83f0      	strh	r0, [r6, #30]
 80010c0:	2101      	movs	r1, #1
 80010c2:	a80a      	add	r0, sp, #40	; 0x28
 80010c4:	7800      	ldrb	r0, [r0, #0]
 80010c6:	f003 f862 	bl	800418e <PE_Reset>
 80010ca:	7235      	strb	r5, [r6, #8]
 80010cc:	e47a      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80010ce:	2011      	movs	r0, #17
 80010d0:	82e0      	strh	r0, [r4, #22]
 80010d2:	2105      	movs	r1, #5
 80010d4:	7b22      	ldrb	r2, [r4, #12]
 80010d6:	07d0      	lsls	r0, r2, #31
 80010d8:	0fc0      	lsrs	r0, r0, #31
 80010da:	f004 f9aa 	bl	8005432 <USBDPD_PRL_BistCarrierEyeMode>
 80010de:	2028      	movs	r0, #40	; 0x28
 80010e0:	7230      	strb	r0, [r6, #8]
 80010e2:	4829      	ldr	r0, [pc, #164]	; (8001188 <__iar_annotation$$branch+0x790>)
 80010e4:	85b0      	strh	r0, [r6, #44]	; 0x2c
 80010e6:	253a      	movs	r5, #58	; 0x3a
 80010e8:	e46c      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80010ea:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 80010ec:	03a9      	lsls	r1, r5, #14
 80010ee:	4288      	cmp	r0, r1
 80010f0:	d1fa      	bne.n	80010e8 <__iar_annotation$$branch+0x6f0>
 80010f2:	2105      	movs	r1, #5
 80010f4:	7b22      	ldrb	r2, [r4, #12]
 80010f6:	07d0      	lsls	r0, r2, #31
 80010f8:	0fc0      	lsrs	r0, r0, #31
 80010fa:	f004 f9a2 	bl	8005442 <USBDPD_PRL_BistCarrierEyeModeExit>
 80010fe:	2000      	movs	r0, #0
 8001100:	85b0      	strh	r0, [r6, #44]	; 0x2c
 8001102:	e694      	b.n	8000e2e <__iar_annotation$$branch+0x436>
 8001104:	2911      	cmp	r1, #17
 8001106:	d10e      	bne.n	8001126 <__iar_annotation$$branch+0x72e>
 8001108:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800110a:	0bc0      	lsrs	r0, r0, #15
 800110c:	d10b      	bne.n	8001126 <__iar_annotation$$branch+0x72e>
 800110e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001110:	0b00      	lsrs	r0, r0, #12
 8001112:	0740      	lsls	r0, r0, #29
 8001114:	d007      	beq.n	8001126 <__iar_annotation$$branch+0x72e>
 8001116:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001118:	06c0      	lsls	r0, r0, #27
 800111a:	0ec0      	lsrs	r0, r0, #27
 800111c:	2803      	cmp	r0, #3
 800111e:	d102      	bne.n	8001126 <__iar_annotation$$branch+0x72e>
 8001120:	2014      	movs	r0, #20
 8001122:	4669      	mov	r1, sp
 8001124:	7308      	strb	r0, [r1, #12]
 8001126:	2011      	movs	r0, #17
 8001128:	82e0      	strh	r0, [r4, #22]
 800112a:	e44b      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 800112c:	2000      	movs	r0, #0
 800112e:	9000      	str	r0, [sp, #0]
 8001130:	2319      	movs	r3, #25
 8001132:	2208      	movs	r2, #8
 8001134:	2100      	movs	r1, #0
 8001136:	0020      	movs	r0, r4
 8001138:	f002 fb1b 	bl	8003772 <PE_Send_CtrlMessage>
 800113c:	2800      	cmp	r0, #0
 800113e:	d1f4      	bne.n	800112a <__iar_annotation$$branch+0x732>
 8001140:	2007      	movs	r0, #7
 8001142:	82e0      	strh	r0, [r4, #22]
 8001144:	480b      	ldr	r0, [pc, #44]	; (8001174 <__iar_annotation$$branch+0x77c>)
 8001146:	83b0      	strh	r0, [r6, #28]
 8001148:	251a      	movs	r5, #26
 800114a:	4f0b      	ldr	r7, [pc, #44]	; (8001178 <__iar_annotation$$branch+0x780>)
 800114c:	7838      	ldrb	r0, [r7, #0]
 800114e:	0780      	lsls	r0, r0, #30
 8001150:	d509      	bpl.n	8001166 <__iar_annotation$$branch+0x76e>
 8001152:	2000      	movs	r0, #0
 8001154:	9000      	str	r0, [sp, #0]
 8001156:	2300      	movs	r3, #0
 8001158:	2205      	movs	r2, #5
 800115a:	7b20      	ldrb	r0, [r4, #12]
 800115c:	07c1      	lsls	r1, r0, #31
 800115e:	0fc9      	lsrs	r1, r1, #31
 8001160:	2009      	movs	r0, #9
 8001162:	68ff      	ldr	r7, [r7, #12]
 8001164:	47b8      	blx	r7
 8001166:	2105      	movs	r1, #5
 8001168:	e4c0      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 800116a:	bf00      	nop
 800116c:	00008226 	.word	0x00008226
 8001170:	00000226 	.word	0x00000226
 8001174:	0000801a 	.word	0x0000801a
 8001178:	200019e8 	.word	0x200019e8
 800117c:	0000801b 	.word	0x0000801b
 8001180:	00008320 	.word	0x00008320
 8001184:	0000957c 	.word	0x0000957c
 8001188:	0000803a 	.word	0x0000803a
 800118c:	2911      	cmp	r1, #17
 800118e:	d15e      	bne.n	800124e <__iar_annotation$$branch+0x856>
 8001190:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001192:	0bc0      	lsrs	r0, r0, #15
 8001194:	d133      	bne.n	80011fe <__iar_annotation$$branch+0x806>
 8001196:	2007      	movs	r0, #7
 8001198:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800119a:	0b09      	lsrs	r1, r1, #12
 800119c:	4201      	tst	r1, r0
 800119e:	d02e      	beq.n	80011fe <__iar_annotation$$branch+0x806>
 80011a0:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80011a2:	06c9      	lsls	r1, r1, #27
 80011a4:	0ec9      	lsrs	r1, r1, #27
 80011a6:	2904      	cmp	r1, #4
 80011a8:	d129      	bne.n	80011fe <__iar_annotation$$branch+0x806>
 80011aa:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80011ac:	0b09      	lsrs	r1, r1, #12
 80011ae:	4008      	ands	r0, r1
 80011b0:	0083      	lsls	r3, r0, #2
 80011b2:	209e      	movs	r0, #158	; 0x9e
 80011b4:	0040      	lsls	r0, r0, #1
 80011b6:	1822      	adds	r2, r4, r0
 80011b8:	2105      	movs	r1, #5
 80011ba:	7b27      	ldrb	r7, [r4, #12]
 80011bc:	07f8      	lsls	r0, r7, #31
 80011be:	0fc0      	lsrs	r0, r0, #31
 80011c0:	68a7      	ldr	r7, [r4, #8]
 80011c2:	69ff      	ldr	r7, [r7, #28]
 80011c4:	47b8      	blx	r7
 80011c6:	2000      	movs	r0, #0
 80011c8:	83b0      	strh	r0, [r6, #28]
 80011ca:	2003      	movs	r0, #3
 80011cc:	7230      	strb	r0, [r6, #8]
 80011ce:	2014      	movs	r0, #20
 80011d0:	4669      	mov	r1, sp
 80011d2:	7308      	strb	r0, [r1, #12]
 80011d4:	4fd0      	ldr	r7, [pc, #832]	; (8001518 <__iar_annotation$$branch+0xb20>)
 80011d6:	7838      	ldrb	r0, [r7, #0]
 80011d8:	0780      	lsls	r0, r0, #30
 80011da:	d509      	bpl.n	80011f0 <__iar_annotation$$branch+0x7f8>
 80011dc:	2000      	movs	r0, #0
 80011de:	9000      	str	r0, [sp, #0]
 80011e0:	2300      	movs	r3, #0
 80011e2:	2207      	movs	r2, #7
 80011e4:	7b20      	ldrb	r0, [r4, #12]
 80011e6:	07c1      	lsls	r1, r0, #31
 80011e8:	0fc9      	lsrs	r1, r1, #31
 80011ea:	2009      	movs	r0, #9
 80011ec:	68ff      	ldr	r7, [r7, #12]
 80011ee:	47b8      	blx	r7
 80011f0:	2107      	movs	r1, #7
 80011f2:	7b22      	ldrb	r2, [r4, #12]
 80011f4:	07d0      	lsls	r0, r2, #31
 80011f6:	0fc0      	lsrs	r0, r0, #31
 80011f8:	68a2      	ldr	r2, [r4, #8]
 80011fa:	68d2      	ldr	r2, [r2, #12]
 80011fc:	4790      	blx	r2
 80011fe:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001200:	0bc0      	lsrs	r0, r0, #15
 8001202:	d124      	bne.n	800124e <__iar_annotation$$branch+0x856>
 8001204:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001206:	0b00      	lsrs	r0, r0, #12
 8001208:	0740      	lsls	r0, r0, #29
 800120a:	d120      	bne.n	800124e <__iar_annotation$$branch+0x856>
 800120c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800120e:	06c0      	lsls	r0, r0, #27
 8001210:	0ec0      	lsrs	r0, r0, #27
 8001212:	2804      	cmp	r0, #4
 8001214:	d11b      	bne.n	800124e <__iar_annotation$$branch+0x856>
 8001216:	2000      	movs	r0, #0
 8001218:	83b0      	strh	r0, [r6, #28]
 800121a:	2003      	movs	r0, #3
 800121c:	7230      	strb	r0, [r6, #8]
 800121e:	2014      	movs	r0, #20
 8001220:	4669      	mov	r1, sp
 8001222:	7308      	strb	r0, [r1, #12]
 8001224:	4fbc      	ldr	r7, [pc, #752]	; (8001518 <__iar_annotation$$branch+0xb20>)
 8001226:	7838      	ldrb	r0, [r7, #0]
 8001228:	0780      	lsls	r0, r0, #30
 800122a:	d509      	bpl.n	8001240 <__iar_annotation$$branch+0x848>
 800122c:	2000      	movs	r0, #0
 800122e:	9000      	str	r0, [sp, #0]
 8001230:	2300      	movs	r3, #0
 8001232:	2208      	movs	r2, #8
 8001234:	7b20      	ldrb	r0, [r4, #12]
 8001236:	07c1      	lsls	r1, r0, #31
 8001238:	0fc9      	lsrs	r1, r1, #31
 800123a:	2009      	movs	r0, #9
 800123c:	68ff      	ldr	r7, [r7, #12]
 800123e:	47b8      	blx	r7
 8001240:	2108      	movs	r1, #8
 8001242:	7b22      	ldrb	r2, [r4, #12]
 8001244:	07d0      	lsls	r0, r2, #31
 8001246:	0fc0      	lsrs	r0, r0, #31
 8001248:	68a2      	ldr	r2, [r4, #8]
 800124a:	68d2      	ldr	r2, [r2, #12]
 800124c:	4790      	blx	r2
 800124e:	8bb0      	ldrh	r0, [r6, #28]
 8001250:	03a9      	lsls	r1, r5, #14
 8001252:	4288      	cmp	r0, r1
 8001254:	d11e      	bne.n	8001294 <__iar_annotation$$branch+0x89c>
 8001256:	4fb0      	ldr	r7, [pc, #704]	; (8001518 <__iar_annotation$$branch+0xb20>)
 8001258:	7838      	ldrb	r0, [r7, #0]
 800125a:	0780      	lsls	r0, r0, #30
 800125c:	d509      	bpl.n	8001272 <__iar_annotation$$branch+0x87a>
 800125e:	2000      	movs	r0, #0
 8001260:	9000      	str	r0, [sp, #0]
 8001262:	2300      	movs	r3, #0
 8001264:	2209      	movs	r2, #9
 8001266:	7b20      	ldrb	r0, [r4, #12]
 8001268:	07c1      	lsls	r1, r0, #31
 800126a:	0fc9      	lsrs	r1, r1, #31
 800126c:	2009      	movs	r0, #9
 800126e:	68ff      	ldr	r7, [r7, #12]
 8001270:	47b8      	blx	r7
 8001272:	2109      	movs	r1, #9
 8001274:	7b22      	ldrb	r2, [r4, #12]
 8001276:	07d0      	lsls	r0, r2, #31
 8001278:	0fc0      	lsrs	r0, r0, #31
 800127a:	68a2      	ldr	r2, [r4, #8]
 800127c:	68d2      	ldr	r2, [r2, #12]
 800127e:	4790      	blx	r2
 8001280:	e5d5      	b.n	8000e2e <__iar_annotation$$branch+0x436>
 8001282:	2001      	movs	r0, #1
 8001284:	9000      	str	r0, [sp, #0]
 8001286:	231b      	movs	r3, #27
 8001288:	2207      	movs	r2, #7
 800128a:	2100      	movs	r1, #0
 800128c:	0020      	movs	r0, r4
 800128e:	f002 fa70 	bl	8003772 <PE_Send_CtrlMessage>
 8001292:	2800      	cmp	r0, #0
 8001294:	d000      	beq.n	8001298 <__iar_annotation$$branch+0x8a0>
 8001296:	e748      	b.n	800112a <__iar_annotation$$branch+0x732>
 8001298:	2006      	movs	r0, #6
 800129a:	82e0      	strh	r0, [r4, #22]
 800129c:	489f      	ldr	r0, [pc, #636]	; (800151c <__iar_annotation$$branch+0xb24>)
 800129e:	83b0      	strh	r0, [r6, #28]
 80012a0:	251a      	movs	r5, #26
 80012a2:	4f9d      	ldr	r7, [pc, #628]	; (8001518 <__iar_annotation$$branch+0xb20>)
 80012a4:	7838      	ldrb	r0, [r7, #0]
 80012a6:	0780      	lsls	r0, r0, #30
 80012a8:	d509      	bpl.n	80012be <__iar_annotation$$branch+0x8c6>
 80012aa:	2000      	movs	r0, #0
 80012ac:	9000      	str	r0, [sp, #0]
 80012ae:	2300      	movs	r3, #0
 80012b0:	220b      	movs	r2, #11
 80012b2:	7b20      	ldrb	r0, [r4, #12]
 80012b4:	07c1      	lsls	r1, r0, #31
 80012b6:	0fc9      	lsrs	r1, r1, #31
 80012b8:	2009      	movs	r0, #9
 80012ba:	68ff      	ldr	r7, [r7, #12]
 80012bc:	47b8      	blx	r7
 80012be:	210b      	movs	r1, #11
 80012c0:	e752      	b.n	8001168 <__iar_annotation$$branch+0x770>
 80012c2:	2911      	cmp	r1, #17
 80012c4:	d162      	bne.n	800138c <__iar_annotation$$branch+0x994>
 80012c6:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 80012c8:	0bc0      	lsrs	r0, r0, #15
 80012ca:	d133      	bne.n	8001334 <__iar_annotation$$branch+0x93c>
 80012cc:	2007      	movs	r0, #7
 80012ce:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80012d0:	0b09      	lsrs	r1, r1, #12
 80012d2:	4201      	tst	r1, r0
 80012d4:	d02e      	beq.n	8001334 <__iar_annotation$$branch+0x93c>
 80012d6:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80012d8:	06c9      	lsls	r1, r1, #27
 80012da:	0ec9      	lsrs	r1, r1, #27
 80012dc:	2901      	cmp	r1, #1
 80012de:	d129      	bne.n	8001334 <__iar_annotation$$branch+0x93c>
 80012e0:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80012e2:	0b09      	lsrs	r1, r1, #12
 80012e4:	4008      	ands	r0, r1
 80012e6:	0083      	lsls	r3, r0, #2
 80012e8:	209e      	movs	r0, #158	; 0x9e
 80012ea:	0040      	lsls	r0, r0, #1
 80012ec:	1822      	adds	r2, r4, r0
 80012ee:	2104      	movs	r1, #4
 80012f0:	7b27      	ldrb	r7, [r4, #12]
 80012f2:	07f8      	lsls	r0, r7, #31
 80012f4:	0fc0      	lsrs	r0, r0, #31
 80012f6:	68a7      	ldr	r7, [r4, #8]
 80012f8:	69ff      	ldr	r7, [r7, #28]
 80012fa:	47b8      	blx	r7
 80012fc:	2000      	movs	r0, #0
 80012fe:	83b0      	strh	r0, [r6, #28]
 8001300:	2003      	movs	r0, #3
 8001302:	7230      	strb	r0, [r6, #8]
 8001304:	2014      	movs	r0, #20
 8001306:	4669      	mov	r1, sp
 8001308:	7308      	strb	r0, [r1, #12]
 800130a:	4f83      	ldr	r7, [pc, #524]	; (8001518 <__iar_annotation$$branch+0xb20>)
 800130c:	7838      	ldrb	r0, [r7, #0]
 800130e:	0780      	lsls	r0, r0, #30
 8001310:	d509      	bpl.n	8001326 <__iar_annotation$$branch+0x92e>
 8001312:	2000      	movs	r0, #0
 8001314:	9000      	str	r0, [sp, #0]
 8001316:	2300      	movs	r3, #0
 8001318:	220d      	movs	r2, #13
 800131a:	7b20      	ldrb	r0, [r4, #12]
 800131c:	07c1      	lsls	r1, r0, #31
 800131e:	0fc9      	lsrs	r1, r1, #31
 8001320:	2009      	movs	r0, #9
 8001322:	68ff      	ldr	r7, [r7, #12]
 8001324:	47b8      	blx	r7
 8001326:	210d      	movs	r1, #13
 8001328:	7b22      	ldrb	r2, [r4, #12]
 800132a:	07d0      	lsls	r0, r2, #31
 800132c:	0fc0      	lsrs	r0, r0, #31
 800132e:	68a2      	ldr	r2, [r4, #8]
 8001330:	68d2      	ldr	r2, [r2, #12]
 8001332:	4790      	blx	r2
 8001334:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001336:	0bc0      	lsrs	r0, r0, #15
 8001338:	d128      	bne.n	800138c <__iar_annotation$$branch+0x994>
 800133a:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800133c:	0b00      	lsrs	r0, r0, #12
 800133e:	0740      	lsls	r0, r0, #29
 8001340:	d124      	bne.n	800138c <__iar_annotation$$branch+0x994>
 8001342:	201f      	movs	r0, #31
 8001344:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8001346:	4001      	ands	r1, r0
 8001348:	2904      	cmp	r1, #4
 800134a:	d003      	beq.n	8001354 <__iar_annotation$$branch+0x95c>
 800134c:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800134e:	4008      	ands	r0, r1
 8001350:	2810      	cmp	r0, #16
 8001352:	d11b      	bne.n	800138c <__iar_annotation$$branch+0x994>
 8001354:	2000      	movs	r0, #0
 8001356:	83b0      	strh	r0, [r6, #28]
 8001358:	2003      	movs	r0, #3
 800135a:	7230      	strb	r0, [r6, #8]
 800135c:	2014      	movs	r0, #20
 800135e:	4669      	mov	r1, sp
 8001360:	7308      	strb	r0, [r1, #12]
 8001362:	4f6d      	ldr	r7, [pc, #436]	; (8001518 <__iar_annotation$$branch+0xb20>)
 8001364:	7838      	ldrb	r0, [r7, #0]
 8001366:	0780      	lsls	r0, r0, #30
 8001368:	d509      	bpl.n	800137e <__iar_annotation$$branch+0x986>
 800136a:	2000      	movs	r0, #0
 800136c:	9000      	str	r0, [sp, #0]
 800136e:	2300      	movs	r3, #0
 8001370:	220e      	movs	r2, #14
 8001372:	7b20      	ldrb	r0, [r4, #12]
 8001374:	07c1      	lsls	r1, r0, #31
 8001376:	0fc9      	lsrs	r1, r1, #31
 8001378:	2009      	movs	r0, #9
 800137a:	68ff      	ldr	r7, [r7, #12]
 800137c:	47b8      	blx	r7
 800137e:	210e      	movs	r1, #14
 8001380:	7b22      	ldrb	r2, [r4, #12]
 8001382:	07d0      	lsls	r0, r2, #31
 8001384:	0fc0      	lsrs	r0, r0, #31
 8001386:	68a2      	ldr	r2, [r4, #8]
 8001388:	68d2      	ldr	r2, [r2, #12]
 800138a:	4790      	blx	r2
 800138c:	8bb0      	ldrh	r0, [r6, #28]
 800138e:	03a9      	lsls	r1, r5, #14
 8001390:	e1cf      	b.n	8001732 <__iar_annotation$$branch+0x164>
 8001392:	68a0      	ldr	r0, [r4, #8]
 8001394:	6881      	ldr	r1, [r0, #8]
 8001396:	2900      	cmp	r1, #0
 8001398:	d108      	bne.n	80013ac <__iar_annotation$$branch+0x9b4>
 800139a:	2000      	movs	r0, #0
 800139c:	9000      	str	r0, [sp, #0]
 800139e:	2303      	movs	r3, #3
 80013a0:	2204      	movs	r2, #4
 80013a2:	2100      	movs	r1, #0
 80013a4:	0020      	movs	r0, r4
 80013a6:	f002 f9e4 	bl	8003772 <PE_Send_CtrlMessage>
 80013aa:	e6be      	b.n	800112a <__iar_annotation$$branch+0x732>
 80013ac:	7b22      	ldrb	r2, [r4, #12]
 80013ae:	07d0      	lsls	r0, r2, #31
 80013b0:	0fc0      	lsrs	r0, r0, #31
 80013b2:	4788      	blx	r1
 80013b4:	280a      	cmp	r0, #10
 80013b6:	d002      	beq.n	80013be <__iar_annotation$$branch+0x9c6>
 80013b8:	280d      	cmp	r0, #13
 80013ba:	d025      	beq.n	8001408 <__iar_annotation$$branch+0xa10>
 80013bc:	e03c      	b.n	8001438 <__iar_annotation$$branch+0xa40>
 80013be:	4858      	ldr	r0, [pc, #352]	; (8001520 <__iar_annotation$$branch+0xb28>)
 80013c0:	8470      	strh	r0, [r6, #34]	; 0x22
 80013c2:	251e      	movs	r5, #30
 80013c4:	2000      	movs	r0, #0
 80013c6:	9000      	str	r0, [sp, #0]
 80013c8:	2324      	movs	r3, #36	; 0x24
 80013ca:	2203      	movs	r2, #3
 80013cc:	2100      	movs	r1, #0
 80013ce:	0020      	movs	r0, r4
 80013d0:	f002 f9cf 	bl	8003772 <PE_Send_CtrlMessage>
 80013d4:	68a0      	ldr	r0, [r4, #8]
 80013d6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80013d8:	2b00      	cmp	r3, #0
 80013da:	d005      	beq.n	80013e8 <__iar_annotation$$branch+0x9f0>
 80013dc:	2201      	movs	r2, #1
 80013de:	2101      	movs	r1, #1
 80013e0:	7b27      	ldrb	r7, [r4, #12]
 80013e2:	07f8      	lsls	r0, r7, #31
 80013e4:	0fc0      	lsrs	r0, r0, #31
 80013e6:	4798      	blx	r3
 80013e8:	4f4b      	ldr	r7, [pc, #300]	; (8001518 <__iar_annotation$$branch+0xb20>)
 80013ea:	7838      	ldrb	r0, [r7, #0]
 80013ec:	0780      	lsls	r0, r0, #30
 80013ee:	d509      	bpl.n	8001404 <__iar_annotation$$branch+0xa0c>
 80013f0:	2000      	movs	r0, #0
 80013f2:	9000      	str	r0, [sp, #0]
 80013f4:	2300      	movs	r3, #0
 80013f6:	2238      	movs	r2, #56	; 0x38
 80013f8:	7b20      	ldrb	r0, [r4, #12]
 80013fa:	07c1      	lsls	r1, r0, #31
 80013fc:	0fc9      	lsrs	r1, r1, #31
 80013fe:	2009      	movs	r0, #9
 8001400:	68ff      	ldr	r7, [r7, #12]
 8001402:	47b8      	blx	r7
 8001404:	2138      	movs	r1, #56	; 0x38
 8001406:	e6af      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001408:	2000      	movs	r0, #0
 800140a:	9000      	str	r0, [sp, #0]
 800140c:	2303      	movs	r3, #3
 800140e:	220c      	movs	r2, #12
 8001410:	2100      	movs	r1, #0
 8001412:	0020      	movs	r0, r4
 8001414:	f002 f9ad 	bl	8003772 <PE_Send_CtrlMessage>
 8001418:	4f3f      	ldr	r7, [pc, #252]	; (8001518 <__iar_annotation$$branch+0xb20>)
 800141a:	7838      	ldrb	r0, [r7, #0]
 800141c:	0780      	lsls	r0, r0, #30
 800141e:	d509      	bpl.n	8001434 <__iar_annotation$$branch+0xa3c>
 8001420:	2000      	movs	r0, #0
 8001422:	9000      	str	r0, [sp, #0]
 8001424:	2300      	movs	r3, #0
 8001426:	2239      	movs	r2, #57	; 0x39
 8001428:	7b20      	ldrb	r0, [r4, #12]
 800142a:	07c1      	lsls	r1, r0, #31
 800142c:	0fc9      	lsrs	r1, r1, #31
 800142e:	2009      	movs	r0, #9
 8001430:	68ff      	ldr	r7, [r7, #12]
 8001432:	47b8      	blx	r7
 8001434:	2139      	movs	r1, #57	; 0x39
 8001436:	e697      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001438:	2000      	movs	r0, #0
 800143a:	9000      	str	r0, [sp, #0]
 800143c:	2303      	movs	r3, #3
 800143e:	2204      	movs	r2, #4
 8001440:	2100      	movs	r1, #0
 8001442:	0020      	movs	r0, r4
 8001444:	f002 f995 	bl	8003772 <PE_Send_CtrlMessage>
 8001448:	4f33      	ldr	r7, [pc, #204]	; (8001518 <__iar_annotation$$branch+0xb20>)
 800144a:	7838      	ldrb	r0, [r7, #0]
 800144c:	0780      	lsls	r0, r0, #30
 800144e:	d509      	bpl.n	8001464 <__iar_annotation$$branch+0xa6c>
 8001450:	2000      	movs	r0, #0
 8001452:	9000      	str	r0, [sp, #0]
 8001454:	2300      	movs	r3, #0
 8001456:	2216      	movs	r2, #22
 8001458:	7b20      	ldrb	r0, [r4, #12]
 800145a:	07c1      	lsls	r1, r0, #31
 800145c:	0fc9      	lsrs	r1, r1, #31
 800145e:	2009      	movs	r0, #9
 8001460:	68ff      	ldr	r7, [r7, #12]
 8001462:	47b8      	blx	r7
 8001464:	2116      	movs	r1, #22
 8001466:	e67f      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001468:	8c71      	ldrh	r1, [r6, #34]	; 0x22
 800146a:	03aa      	lsls	r2, r5, #14
 800146c:	4291      	cmp	r1, r2
 800146e:	d151      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 8001470:	2100      	movs	r1, #0
 8001472:	8471      	strh	r1, [r6, #34]	; 0x22
 8001474:	6861      	ldr	r1, [r4, #4]
 8001476:	784a      	ldrb	r2, [r1, #1]
 8001478:	238f      	movs	r3, #143	; 0x8f
 800147a:	4013      	ands	r3, r2
 800147c:	2240      	movs	r2, #64	; 0x40
 800147e:	431a      	orrs	r2, r3
 8001480:	704a      	strb	r2, [r1, #1]
 8001482:	2800      	cmp	r0, #0
 8001484:	d009      	beq.n	800149a <__iar_annotation$$branch+0xaa2>
 8001486:	2000      	movs	r0, #0
 8001488:	9000      	str	r0, [sp, #0]
 800148a:	2300      	movs	r3, #0
 800148c:	2256      	movs	r2, #86	; 0x56
 800148e:	7b20      	ldrb	r0, [r4, #12]
 8001490:	07c1      	lsls	r1, r0, #31
 8001492:	0fc9      	lsrs	r1, r1, #31
 8001494:	2009      	movs	r0, #9
 8001496:	9f01      	ldr	r7, [sp, #4]
 8001498:	47b8      	blx	r7
 800149a:	2701      	movs	r7, #1
 800149c:	2156      	movs	r1, #86	; 0x56
 800149e:	68e2      	ldr	r2, [r4, #12]
 80014a0:	2001      	movs	r0, #1
 80014a2:	4010      	ands	r0, r2
 80014a4:	68a2      	ldr	r2, [r4, #8]
 80014a6:	68d2      	ldr	r2, [r2, #12]
 80014a8:	4790      	blx	r2
 80014aa:	6860      	ldr	r0, [r4, #4]
 80014ac:	6801      	ldr	r1, [r0, #0]
 80014ae:	2210      	movs	r2, #16
 80014b0:	430a      	orrs	r2, r1
 80014b2:	6002      	str	r2, [r0, #0]
 80014b4:	68a0      	ldr	r0, [r4, #8]
 80014b6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80014b8:	2b00      	cmp	r3, #0
 80014ba:	d00f      	beq.n	80014dc <__iar_annotation$$branch+0xae4>
 80014bc:	2206      	movs	r2, #6
 80014be:	68e1      	ldr	r1, [r4, #12]
 80014c0:	2001      	movs	r0, #1
 80014c2:	4008      	ands	r0, r1
 80014c4:	2101      	movs	r1, #1
 80014c6:	4798      	blx	r3
 80014c8:	68a0      	ldr	r0, [r4, #8]
 80014ca:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80014cc:	2b00      	cmp	r3, #0
 80014ce:	d005      	beq.n	80014dc <__iar_annotation$$branch+0xae4>
 80014d0:	2207      	movs	r2, #7
 80014d2:	68e1      	ldr	r1, [r4, #12]
 80014d4:	2001      	movs	r0, #1
 80014d6:	4008      	ands	r0, r1
 80014d8:	2101      	movs	r1, #1
 80014da:	4798      	blx	r3
 80014dc:	2100      	movs	r1, #0
 80014de:	68e2      	ldr	r2, [r4, #12]
 80014e0:	2001      	movs	r0, #1
 80014e2:	4010      	ands	r0, r2
 80014e4:	f003 fd1d 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 80014e8:	2000      	movs	r0, #0
 80014ea:	9000      	str	r0, [sp, #0]
 80014ec:	2325      	movs	r3, #37	; 0x25
 80014ee:	2206      	movs	r2, #6
 80014f0:	2100      	movs	r1, #0
 80014f2:	0020      	movs	r0, r4
 80014f4:	f002 f93d 	bl	8003772 <PE_Send_CtrlMessage>
 80014f8:	2800      	cmp	r0, #0
 80014fa:	d10b      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 80014fc:	68a0      	ldr	r0, [r4, #8]
 80014fe:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001500:	2b00      	cmp	r3, #0
 8001502:	d005      	beq.n	8001510 <__iar_annotation$$branch+0xb18>
 8001504:	2208      	movs	r2, #8
 8001506:	2101      	movs	r1, #1
 8001508:	68e0      	ldr	r0, [r4, #12]
 800150a:	4007      	ands	r7, r0
 800150c:	0038      	movs	r0, r7
 800150e:	4798      	blx	r3
 8001510:	48bd      	ldr	r0, [pc, #756]	; (8001808 <__iar_annotation$$branch+0x23a>)
 8001512:	8370      	strh	r0, [r6, #26]
 8001514:	e609      	b.n	800112a <__iar_annotation$$branch+0x732>
 8001516:	bf00      	nop
 8001518:	200019e8 	.word	0x200019e8
 800151c:	0000801a 	.word	0x0000801a
 8001520:	0000801e 	.word	0x0000801e
 8001524:	2911      	cmp	r1, #17
 8001526:	d112      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 8001528:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800152a:	0bc0      	lsrs	r0, r0, #15
 800152c:	d10f      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 800152e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001530:	0b00      	lsrs	r0, r0, #12
 8001532:	0740      	lsls	r0, r0, #29
 8001534:	d10b      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 8001536:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001538:	06c0      	lsls	r0, r0, #27
 800153a:	0ec0      	lsrs	r0, r0, #27
 800153c:	2806      	cmp	r0, #6
 800153e:	d106      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 8001540:	2000      	movs	r0, #0
 8001542:	8370      	strh	r0, [r6, #26]
 8001544:	2014      	movs	r0, #20
 8001546:	4669      	mov	r1, sp
 8001548:	7308      	strb	r0, [r1, #12]
 800154a:	2026      	movs	r0, #38	; 0x26
 800154c:	7230      	strb	r0, [r6, #8]
 800154e:	8b70      	ldrh	r0, [r6, #26]
 8001550:	03a9      	lsls	r1, r5, #14
 8001552:	4288      	cmp	r0, r1
 8001554:	d1de      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 8001556:	68a0      	ldr	r0, [r4, #8]
 8001558:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800155a:	2b00      	cmp	r3, #0
 800155c:	d005      	beq.n	800156a <__iar_annotation$$branch+0xb72>
 800155e:	220a      	movs	r2, #10
 8001560:	2101      	movs	r1, #1
 8001562:	7b27      	ldrb	r7, [r4, #12]
 8001564:	07f8      	lsls	r0, r7, #31
 8001566:	0fc0      	lsrs	r0, r0, #31
 8001568:	4798      	blx	r3
 800156a:	e12b      	b.n	80017c4 <__iar_annotation$$branch+0x1f6>
 800156c:	2100      	movs	r1, #0
 800156e:	0020      	movs	r0, r4
 8001570:	f002 fa14 	bl	800399c <PE_ChangePowerRole>
 8001574:	68a0      	ldr	r0, [r4, #8]
 8001576:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001578:	2501      	movs	r5, #1
 800157a:	2b00      	cmp	r3, #0
 800157c:	d005      	beq.n	800158a <__iar_annotation$$branch+0xb92>
 800157e:	220d      	movs	r2, #13
 8001580:	2100      	movs	r1, #0
 8001582:	68e7      	ldr	r7, [r4, #12]
 8001584:	2001      	movs	r0, #1
 8001586:	4038      	ands	r0, r7
 8001588:	4798      	blx	r3
 800158a:	0020      	movs	r0, r4
 800158c:	f002 feb0 	bl	80042f0 <PE_ResetDuringSwap>
 8001590:	4fae      	ldr	r7, [pc, #696]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001592:	7838      	ldrb	r0, [r7, #0]
 8001594:	0780      	lsls	r0, r0, #30
 8001596:	d509      	bpl.n	80015ac <__iar_annotation$$branch+0xbb4>
 8001598:	2000      	movs	r0, #0
 800159a:	9000      	str	r0, [sp, #0]
 800159c:	2300      	movs	r3, #0
 800159e:	2214      	movs	r2, #20
 80015a0:	68e0      	ldr	r0, [r4, #12]
 80015a2:	2101      	movs	r1, #1
 80015a4:	4001      	ands	r1, r0
 80015a6:	2009      	movs	r0, #9
 80015a8:	68ff      	ldr	r7, [r7, #12]
 80015aa:	47b8      	blx	r7
 80015ac:	2114      	movs	r1, #20
 80015ae:	68e2      	ldr	r2, [r4, #12]
 80015b0:	2001      	movs	r0, #1
 80015b2:	4010      	ands	r0, r2
 80015b4:	68a2      	ldr	r2, [r4, #8]
 80015b6:	68d2      	ldr	r2, [r2, #12]
 80015b8:	4790      	blx	r2
 80015ba:	68a0      	ldr	r0, [r4, #8]
 80015bc:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80015be:	2b00      	cmp	r3, #0
 80015c0:	d005      	beq.n	80015ce <__iar_annotation$$branch>
 80015c2:	220e      	movs	r2, #14
 80015c4:	2100      	movs	r1, #0
 80015c6:	68e0      	ldr	r0, [r4, #12]
 80015c8:	4005      	ands	r5, r0
 80015ca:	0028      	movs	r0, r5
 80015cc:	4798      	blx	r3

080015ce <__iar_annotation$$branch>:
 80015ce:	f7ff fa65 	bl	8000a9c <__iar_annotation$$branch+0xa4>
 80015d2:	2001      	movs	r0, #1
 80015d4:	9000      	str	r0, [sp, #0]
 80015d6:	231f      	movs	r3, #31
 80015d8:	220a      	movs	r2, #10
 80015da:	2100      	movs	r1, #0
 80015dc:	0020      	movs	r0, r4
 80015de:	f002 f8c8 	bl	8003772 <PE_Send_CtrlMessage>
 80015e2:	2800      	cmp	r0, #0
 80015e4:	d196      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 80015e6:	2008      	movs	r0, #8
 80015e8:	82e0      	strh	r0, [r4, #22]
 80015ea:	48b7      	ldr	r0, [pc, #732]	; (80018c8 <__iar_annotation$$branch+0xa>)
 80015ec:	83b0      	strh	r0, [r6, #28]
 80015ee:	251a      	movs	r5, #26
 80015f0:	68a0      	ldr	r0, [r4, #8]
 80015f2:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80015f4:	2b00      	cmp	r3, #0
 80015f6:	d005      	beq.n	8001604 <__iar_annotation$$branch+0x36>
 80015f8:	2202      	movs	r2, #2
 80015fa:	2101      	movs	r1, #1
 80015fc:	7b27      	ldrb	r7, [r4, #12]
 80015fe:	07f8      	lsls	r0, r7, #31
 8001600:	0fc0      	lsrs	r0, r0, #31
 8001602:	4798      	blx	r3
 8001604:	4f91      	ldr	r7, [pc, #580]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001606:	7838      	ldrb	r0, [r7, #0]
 8001608:	0780      	lsls	r0, r0, #30
 800160a:	d509      	bpl.n	8001620 <__iar_annotation$$branch+0x52>
 800160c:	2000      	movs	r0, #0
 800160e:	9000      	str	r0, [sp, #0]
 8001610:	2300      	movs	r3, #0
 8001612:	2237      	movs	r2, #55	; 0x37
 8001614:	7b20      	ldrb	r0, [r4, #12]
 8001616:	07c1      	lsls	r1, r0, #31
 8001618:	0fc9      	lsrs	r1, r1, #31
 800161a:	2009      	movs	r0, #9
 800161c:	68ff      	ldr	r7, [r7, #12]
 800161e:	47b8      	blx	r7
 8001620:	2137      	movs	r1, #55	; 0x37
 8001622:	e5a1      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001624:	2911      	cmp	r1, #17
 8001626:	d000      	beq.n	800162a <__iar_annotation$$branch+0x5c>
 8001628:	e57f      	b.n	800112a <__iar_annotation$$branch+0x732>
 800162a:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800162c:	0bc9      	lsrs	r1, r1, #15
 800162e:	d17d      	bne.n	800172c <__iar_annotation$$branch+0x15e>
 8001630:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8001632:	0b09      	lsrs	r1, r1, #12
 8001634:	0749      	lsls	r1, r1, #29
 8001636:	d179      	bne.n	800172c <__iar_annotation$$branch+0x15e>
 8001638:	2703      	movs	r7, #3
 800163a:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800163c:	06c9      	lsls	r1, r1, #27
 800163e:	0ec9      	lsrs	r1, r1, #27
 8001640:	2903      	cmp	r1, #3
 8001642:	d006      	beq.n	8001652 <__iar_annotation$$branch+0x84>
 8001644:	2904      	cmp	r1, #4
 8001646:	d031      	beq.n	80016ac <__iar_annotation$$branch+0xde>
 8001648:	290c      	cmp	r1, #12
 800164a:	d013      	beq.n	8001674 <__iar_annotation$$branch+0xa6>
 800164c:	2910      	cmp	r1, #16
 800164e:	d049      	beq.n	80016e4 <__iar_annotation$$branch+0x116>
 8001650:	e06c      	b.n	800172c <__iar_annotation$$branch+0x15e>
 8001652:	2500      	movs	r5, #0
 8001654:	83b5      	strh	r5, [r6, #28]
 8001656:	2120      	movs	r1, #32
 8001658:	7231      	strb	r1, [r6, #8]
 800165a:	2800      	cmp	r0, #0
 800165c:	d008      	beq.n	8001670 <__iar_annotation$$branch+0xa2>
 800165e:	9500      	str	r5, [sp, #0]
 8001660:	2300      	movs	r3, #0
 8001662:	2238      	movs	r2, #56	; 0x38
 8001664:	7b20      	ldrb	r0, [r4, #12]
 8001666:	07c1      	lsls	r1, r0, #31
 8001668:	0fc9      	lsrs	r1, r1, #31
 800166a:	2009      	movs	r0, #9
 800166c:	9f01      	ldr	r7, [sp, #4]
 800166e:	47b8      	blx	r7
 8001670:	2138      	movs	r1, #56	; 0x38
 8001672:	e052      	b.n	800171a <__iar_annotation$$branch+0x14c>
 8001674:	68a0      	ldr	r0, [r4, #8]
 8001676:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001678:	2b00      	cmp	r3, #0
 800167a:	d005      	beq.n	8001688 <__iar_annotation$$branch+0xba>
 800167c:	2205      	movs	r2, #5
 800167e:	2101      	movs	r1, #1
 8001680:	7b25      	ldrb	r5, [r4, #12]
 8001682:	07e8      	lsls	r0, r5, #31
 8001684:	0fc0      	lsrs	r0, r0, #31
 8001686:	4798      	blx	r3
 8001688:	2500      	movs	r5, #0
 800168a:	83b5      	strh	r5, [r6, #28]
 800168c:	7237      	strb	r7, [r6, #8]
 800168e:	4f6f      	ldr	r7, [pc, #444]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001690:	7838      	ldrb	r0, [r7, #0]
 8001692:	0780      	lsls	r0, r0, #30
 8001694:	d508      	bpl.n	80016a8 <__iar_annotation$$branch+0xda>
 8001696:	9500      	str	r5, [sp, #0]
 8001698:	2300      	movs	r3, #0
 800169a:	2239      	movs	r2, #57	; 0x39
 800169c:	7b20      	ldrb	r0, [r4, #12]
 800169e:	07c1      	lsls	r1, r0, #31
 80016a0:	0fc9      	lsrs	r1, r1, #31
 80016a2:	2009      	movs	r0, #9
 80016a4:	68ff      	ldr	r7, [r7, #12]
 80016a6:	47b8      	blx	r7
 80016a8:	2139      	movs	r1, #57	; 0x39
 80016aa:	e036      	b.n	800171a <__iar_annotation$$branch+0x14c>
 80016ac:	68a0      	ldr	r0, [r4, #8]
 80016ae:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80016b0:	2b00      	cmp	r3, #0
 80016b2:	d005      	beq.n	80016c0 <__iar_annotation$$branch+0xf2>
 80016b4:	2204      	movs	r2, #4
 80016b6:	2101      	movs	r1, #1
 80016b8:	7b25      	ldrb	r5, [r4, #12]
 80016ba:	07e8      	lsls	r0, r5, #31
 80016bc:	0fc0      	lsrs	r0, r0, #31
 80016be:	4798      	blx	r3
 80016c0:	2500      	movs	r5, #0
 80016c2:	83b5      	strh	r5, [r6, #28]
 80016c4:	7237      	strb	r7, [r6, #8]
 80016c6:	4f61      	ldr	r7, [pc, #388]	; (800184c <__iar_annotation$$branch+0x27e>)
 80016c8:	7838      	ldrb	r0, [r7, #0]
 80016ca:	0780      	lsls	r0, r0, #30
 80016cc:	d508      	bpl.n	80016e0 <__iar_annotation$$branch+0x112>
 80016ce:	9500      	str	r5, [sp, #0]
 80016d0:	2300      	movs	r3, #0
 80016d2:	2216      	movs	r2, #22
 80016d4:	7b20      	ldrb	r0, [r4, #12]
 80016d6:	07c1      	lsls	r1, r0, #31
 80016d8:	0fc9      	lsrs	r1, r1, #31
 80016da:	2009      	movs	r0, #9
 80016dc:	68ff      	ldr	r7, [r7, #12]
 80016de:	47b8      	blx	r7
 80016e0:	2116      	movs	r1, #22
 80016e2:	e01a      	b.n	800171a <__iar_annotation$$branch+0x14c>
 80016e4:	68a0      	ldr	r0, [r4, #8]
 80016e6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80016e8:	2b00      	cmp	r3, #0
 80016ea:	d005      	beq.n	80016f8 <__iar_annotation$$branch+0x12a>
 80016ec:	2204      	movs	r2, #4
 80016ee:	2101      	movs	r1, #1
 80016f0:	7b25      	ldrb	r5, [r4, #12]
 80016f2:	07e8      	lsls	r0, r5, #31
 80016f4:	0fc0      	lsrs	r0, r0, #31
 80016f6:	4798      	blx	r3
 80016f8:	2500      	movs	r5, #0
 80016fa:	83b5      	strh	r5, [r6, #28]
 80016fc:	7237      	strb	r7, [r6, #8]
 80016fe:	4f53      	ldr	r7, [pc, #332]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001700:	7838      	ldrb	r0, [r7, #0]
 8001702:	0780      	lsls	r0, r0, #30
 8001704:	d508      	bpl.n	8001718 <__iar_annotation$$branch+0x14a>
 8001706:	9500      	str	r5, [sp, #0]
 8001708:	2300      	movs	r3, #0
 800170a:	2255      	movs	r2, #85	; 0x55
 800170c:	7b20      	ldrb	r0, [r4, #12]
 800170e:	07c1      	lsls	r1, r0, #31
 8001710:	0fc9      	lsrs	r1, r1, #31
 8001712:	2009      	movs	r0, #9
 8001714:	68ff      	ldr	r7, [r7, #12]
 8001716:	47b8      	blx	r7
 8001718:	2155      	movs	r1, #85	; 0x55
 800171a:	7b22      	ldrb	r2, [r4, #12]
 800171c:	07d0      	lsls	r0, r2, #31
 800171e:	0fc0      	lsrs	r0, r0, #31
 8001720:	68a2      	ldr	r2, [r4, #8]
 8001722:	68d2      	ldr	r2, [r2, #12]
 8001724:	4790      	blx	r2
 8001726:	2014      	movs	r0, #20
 8001728:	4669      	mov	r1, sp
 800172a:	7308      	strb	r0, [r1, #12]
 800172c:	8bb0      	ldrh	r0, [r6, #28]
 800172e:	2180      	movs	r1, #128	; 0x80
 8001730:	0209      	lsls	r1, r1, #8
 8001732:	4288      	cmp	r0, r1
 8001734:	d138      	bne.n	80017a8 <__iar_annotation$$branch+0x1da>
 8001736:	e22a      	b.n	8001b8e <__iar_annotation$$branch+0xc>
 8001738:	6860      	ldr	r0, [r4, #4]
 800173a:	6801      	ldr	r1, [r0, #0]
 800173c:	2210      	movs	r2, #16
 800173e:	430a      	orrs	r2, r1
 8001740:	6002      	str	r2, [r0, #0]
 8001742:	68a0      	ldr	r0, [r4, #8]
 8001744:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001746:	2701      	movs	r7, #1
 8001748:	2b00      	cmp	r3, #0
 800174a:	d00f      	beq.n	800176c <__iar_annotation$$branch+0x19e>
 800174c:	2206      	movs	r2, #6
 800174e:	68e1      	ldr	r1, [r4, #12]
 8001750:	2001      	movs	r0, #1
 8001752:	4008      	ands	r0, r1
 8001754:	2101      	movs	r1, #1
 8001756:	4798      	blx	r3
 8001758:	68a0      	ldr	r0, [r4, #8]
 800175a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800175c:	2b00      	cmp	r3, #0
 800175e:	d005      	beq.n	800176c <__iar_annotation$$branch+0x19e>
 8001760:	2207      	movs	r2, #7
 8001762:	68e1      	ldr	r1, [r4, #12]
 8001764:	2001      	movs	r0, #1
 8001766:	4008      	ands	r0, r1
 8001768:	2101      	movs	r1, #1
 800176a:	4798      	blx	r3
 800176c:	2100      	movs	r1, #0
 800176e:	68e2      	ldr	r2, [r4, #12]
 8001770:	2001      	movs	r0, #1
 8001772:	4010      	ands	r0, r2
 8001774:	f003 fbd5 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8001778:	2000      	movs	r0, #0
 800177a:	9000      	str	r0, [sp, #0]
 800177c:	2321      	movs	r3, #33	; 0x21
 800177e:	2206      	movs	r2, #6
 8001780:	2100      	movs	r1, #0
 8001782:	0020      	movs	r0, r4
 8001784:	f001 fff5 	bl	8003772 <PE_Send_CtrlMessage>
 8001788:	2800      	cmp	r0, #0
 800178a:	d10d      	bne.n	80017a8 <__iar_annotation$$branch+0x1da>
 800178c:	68a0      	ldr	r0, [r4, #8]
 800178e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001790:	2b00      	cmp	r3, #0
 8001792:	d005      	beq.n	80017a0 <__iar_annotation$$branch+0x1d2>
 8001794:	2208      	movs	r2, #8
 8001796:	2101      	movs	r1, #1
 8001798:	68e0      	ldr	r0, [r4, #12]
 800179a:	4007      	ands	r7, r0
 800179c:	0038      	movs	r0, r7
 800179e:	4798      	blx	r3
 80017a0:	484a      	ldr	r0, [pc, #296]	; (80018cc <__iar_annotation$$branch+0xe>)
 80017a2:	8370      	strh	r0, [r6, #26]
 80017a4:	25f0      	movs	r5, #240	; 0xf0
 80017a6:	006d      	lsls	r5, r5, #1
 80017a8:	e4bf      	b.n	800112a <__iar_annotation$$branch+0x732>
 80017aa:	2911      	cmp	r1, #17
 80017ac:	d106      	bne.n	80017bc <__iar_annotation$$branch+0x1ee>
 80017ae:	2000      	movs	r0, #0
 80017b0:	8370      	strh	r0, [r6, #26]
 80017b2:	2026      	movs	r0, #38	; 0x26
 80017b4:	7230      	strb	r0, [r6, #8]
 80017b6:	2014      	movs	r0, #20
 80017b8:	4669      	mov	r1, sp
 80017ba:	7308      	strb	r0, [r1, #12]
 80017bc:	8b70      	ldrh	r0, [r6, #26]
 80017be:	03a9      	lsls	r1, r5, #14
 80017c0:	4288      	cmp	r0, r1
 80017c2:	d1f1      	bne.n	80017a8 <__iar_annotation$$branch+0x1da>
 80017c4:	2000      	movs	r0, #0
 80017c6:	8370      	strh	r0, [r6, #26]
 80017c8:	e069      	b.n	800189e <__iar_annotation$$branch>
 80017ca:	6860      	ldr	r0, [r4, #4]
 80017cc:	7841      	ldrb	r1, [r0, #1]
 80017ce:	0649      	lsls	r1, r1, #25
 80017d0:	0f49      	lsrs	r1, r1, #29
 80017d2:	2903      	cmp	r1, #3
 80017d4:	d11a      	bne.n	800180c <__iar_annotation$$branch+0x23e>
 80017d6:	6821      	ldr	r1, [r4, #0]
 80017d8:	6849      	ldr	r1, [r1, #4]
 80017da:	070a      	lsls	r2, r1, #28
 80017dc:	0fd2      	lsrs	r2, r2, #31
 80017de:	d015      	beq.n	800180c <__iar_annotation$$branch+0x23e>
 80017e0:	2103      	movs	r1, #3
 80017e2:	0020      	movs	r0, r4
 80017e4:	f001 ffaa 	bl	800373c <PE_Send_SNKCapabilities>
 80017e8:	4f18      	ldr	r7, [pc, #96]	; (800184c <__iar_annotation$$branch+0x27e>)
 80017ea:	7838      	ldrb	r0, [r7, #0]
 80017ec:	0780      	lsls	r0, r0, #30
 80017ee:	d509      	bpl.n	8001804 <__iar_annotation$$branch+0x236>
 80017f0:	2000      	movs	r0, #0
 80017f2:	9000      	str	r0, [sp, #0]
 80017f4:	2300      	movs	r3, #0
 80017f6:	220a      	movs	r2, #10
 80017f8:	7b20      	ldrb	r0, [r4, #12]
 80017fa:	07c1      	lsls	r1, r0, #31
 80017fc:	0fc9      	lsrs	r1, r1, #31
 80017fe:	2009      	movs	r0, #9
 8001800:	68ff      	ldr	r7, [r7, #12]
 8001802:	47b8      	blx	r7
 8001804:	210a      	movs	r1, #10
 8001806:	e4af      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001808:	000081ae 	.word	0x000081ae
 800180c:	7800      	ldrb	r0, [r0, #0]
 800180e:	0780      	lsls	r0, r0, #30
 8001810:	0f80      	lsrs	r0, r0, #30
 8001812:	2802      	cmp	r0, #2
 8001814:	d101      	bne.n	800181a <__iar_annotation$$branch+0x24c>
 8001816:	2001      	movs	r0, #1
 8001818:	e433      	b.n	8001082 <__iar_annotation$$branch+0x68a>
 800181a:	202a      	movs	r0, #42	; 0x2a
 800181c:	e431      	b.n	8001082 <__iar_annotation$$branch+0x68a>
 800181e:	2700      	movs	r7, #0
 8001820:	82e7      	strh	r7, [r4, #22]
 8001822:	7b21      	ldrb	r1, [r4, #12]
 8001824:	07c8      	lsls	r0, r1, #31
 8001826:	0fc0      	lsrs	r0, r0, #31
 8001828:	f003 fba4 	bl	8004f74 <USBPD_PRL_SRCReleaseSinkNG>
 800182c:	2004      	movs	r0, #4
 800182e:	7230      	strb	r0, [r6, #8]
 8001830:	7b20      	ldrb	r0, [r4, #12]
 8001832:	0700      	lsls	r0, r0, #28
 8001834:	0f80      	lsrs	r0, r0, #30
 8001836:	2803      	cmp	r0, #3
 8001838:	d10a      	bne.n	8001850 <__iar_annotation$$branch+0x282>
 800183a:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 800183c:	0440      	lsls	r0, r0, #17
 800183e:	0c40      	lsrs	r0, r0, #17
 8001840:	2800      	cmp	r0, #0
 8001842:	dc06      	bgt.n	8001852 <__iar_annotation$$branch+0x284>
 8001844:	4822      	ldr	r0, [pc, #136]	; (80018d0 <__iar_annotation$$branch+0x12>)
 8001846:	8670      	strh	r0, [r6, #50]	; 0x32
 8001848:	4d22      	ldr	r5, [pc, #136]	; (80018d4 <__iar_annotation$$branch+0x16>)
 800184a:	e002      	b.n	8001852 <__iar_annotation$$branch+0x284>
 800184c:	200019e8 	.word	0x200019e8
 8001850:	8677      	strh	r7, [r6, #50]	; 0x32
 8001852:	4668      	mov	r0, sp
 8001854:	7b00      	ldrb	r0, [r0, #12]
 8001856:	2814      	cmp	r0, #20
 8001858:	d01a      	beq.n	8001890 <__iar_annotation$$branch+0x2c2>
 800185a:	7ab0      	ldrb	r0, [r6, #10]
 800185c:	72f0      	strb	r0, [r6, #11]
 800185e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001860:	0bc0      	lsrs	r0, r0, #15
 8001862:	d003      	beq.n	800186c <__iar_annotation$$branch+0x29e>
 8001864:	0020      	movs	r0, r4
 8001866:	f002 fb57 	bl	8003f18 <PE_Check_ExtendedMessage>
 800186a:	e00d      	b.n	8001888 <__iar_annotation$$branch+0x2ba>
 800186c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800186e:	0bc0      	lsrs	r0, r0, #15
 8001870:	d107      	bne.n	8001882 <__iar_annotation$$branch+0x2b4>
 8001872:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001874:	0b00      	lsrs	r0, r0, #12
 8001876:	0740      	lsls	r0, r0, #29
 8001878:	d103      	bne.n	8001882 <__iar_annotation$$branch+0x2b4>
 800187a:	0020      	movs	r0, r4
 800187c:	f002 f902 	bl	8003a84 <PE_Check_ControlMessage>
 8001880:	e002      	b.n	8001888 <__iar_annotation$$branch+0x2ba>
 8001882:	0020      	movs	r0, r4
 8001884:	f002 fa9a 	bl	8003dbc <PE_Check_DataMessage>
 8001888:	2014      	movs	r0, #20
 800188a:	4669      	mov	r1, sp
 800188c:	7308      	strb	r0, [r1, #12]
 800188e:	e44c      	b.n	800112a <__iar_annotation$$branch+0x732>
 8001890:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 8001892:	2180      	movs	r1, #128	; 0x80
 8001894:	0209      	lsls	r1, r1, #8
 8001896:	4288      	cmp	r0, r1
 8001898:	d103      	bne.n	80018a2 <__iar_annotation$$branch+0x4>
 800189a:	2500      	movs	r5, #0
 800189c:	8675      	strh	r5, [r6, #50]	; 0x32

0800189e <__iar_annotation$$branch>:
 800189e:	f7ff fac8 	bl	8000e32 <__iar_annotation$$branch+0x43a>
 80018a2:	7930      	ldrb	r0, [r6, #4]
 80018a4:	2800      	cmp	r0, #0
 80018a6:	d006      	beq.n	80018b6 <__iar_annotation$$branch+0x18>
 80018a8:	7970      	ldrb	r0, [r6, #5]
 80018aa:	72f0      	strb	r0, [r6, #11]
 80018ac:	7930      	ldrb	r0, [r6, #4]
 80018ae:	7230      	strb	r0, [r6, #8]
 80018b0:	2500      	movs	r5, #0
 80018b2:	7135      	strb	r5, [r6, #4]
 80018b4:	e439      	b.n	800112a <__iar_annotation$$branch+0x732>
 80018b6:	4d08      	ldr	r5, [pc, #32]	; (80018d8 <__iar_annotation$$branch+0x1a>)
 80018b8:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 80018ba:	4028      	ands	r0, r5
 80018bc:	dc01      	bgt.n	80018c2 <__iar_annotation$$branch+0x4>

080018be <__iar_annotation$$branch>:
 80018be:	f7ff faa0 	bl	8000e02 <__iar_annotation$$branch+0x40a>
 80018c2:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 80018c4:	4005      	ands	r5, r0
 80018c6:	e430      	b.n	800112a <__iar_annotation$$branch+0x732>
 80018c8:	0000801a 	.word	0x0000801a
 80018cc:	000081e0 	.word	0x000081e0
 80018d0:	0000b6b0 	.word	0x0000b6b0
 80018d4:	000036b0 	.word	0x000036b0
 80018d8:	00007fff 	.word	0x00007fff
 80018dc:	a80a      	add	r0, sp, #40	; 0x28
 80018de:	7800      	ldrb	r0, [r0, #0]
 80018e0:	68a1      	ldr	r1, [r4, #8]
 80018e2:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
 80018e4:	4788      	blx	r1
 80018e6:	280a      	cmp	r0, #10
 80018e8:	d142      	bne.n	8001970 <__iar_annotation$$branch+0xb2>
 80018ea:	2000      	movs	r0, #0
 80018ec:	9000      	str	r0, [sp, #0]
 80018ee:	2303      	movs	r3, #3
 80018f0:	2203      	movs	r2, #3
 80018f2:	2100      	movs	r1, #0
 80018f4:	0020      	movs	r0, r4
 80018f6:	f001 ff3c 	bl	8003772 <PE_Send_CtrlMessage>
 80018fa:	2800      	cmp	r0, #0
 80018fc:	d170      	bne.n	80019e0 <__iar_annotation$$branch>
 80018fe:	6861      	ldr	r1, [r4, #4]
 8001900:	780a      	ldrb	r2, [r1, #0]
 8001902:	48c8      	ldr	r0, [pc, #800]	; (8001c24 <.text_18>)
 8001904:	68c7      	ldr	r7, [r0, #12]
 8001906:	7800      	ldrb	r0, [r0, #0]
 8001908:	4028      	ands	r0, r5
 800190a:	08d3      	lsrs	r3, r2, #3
 800190c:	07db      	lsls	r3, r3, #31
 800190e:	d40f      	bmi.n	8001930 <__iar_annotation$$branch+0x72>
 8001910:	2308      	movs	r3, #8
 8001912:	4313      	orrs	r3, r2
 8001914:	700b      	strb	r3, [r1, #0]
 8001916:	2800      	cmp	r0, #0
 8001918:	d008      	beq.n	800192c <__iar_annotation$$branch+0x6e>
 800191a:	2000      	movs	r0, #0
 800191c:	9000      	str	r0, [sp, #0]
 800191e:	2300      	movs	r3, #0
 8001920:	2224      	movs	r2, #36	; 0x24
 8001922:	7b20      	ldrb	r0, [r4, #12]
 8001924:	07c1      	lsls	r1, r0, #31
 8001926:	0fc9      	lsrs	r1, r1, #31
 8001928:	2009      	movs	r0, #9
 800192a:	47b8      	blx	r7
 800192c:	2124      	movs	r1, #36	; 0x24
 800192e:	e00e      	b.n	800194e <__iar_annotation$$branch+0x90>
 8001930:	23f7      	movs	r3, #247	; 0xf7
 8001932:	4013      	ands	r3, r2
 8001934:	700b      	strb	r3, [r1, #0]
 8001936:	2800      	cmp	r0, #0
 8001938:	d008      	beq.n	800194c <__iar_annotation$$branch+0x8e>
 800193a:	2000      	movs	r0, #0
 800193c:	9000      	str	r0, [sp, #0]
 800193e:	2300      	movs	r3, #0
 8001940:	2223      	movs	r2, #35	; 0x23
 8001942:	7b20      	ldrb	r0, [r4, #12]
 8001944:	07c1      	lsls	r1, r0, #31
 8001946:	0fc9      	lsrs	r1, r1, #31
 8001948:	2009      	movs	r0, #9
 800194a:	47b8      	blx	r7
 800194c:	2123      	movs	r1, #35	; 0x23
 800194e:	7b22      	ldrb	r2, [r4, #12]
 8001950:	07d0      	lsls	r0, r2, #31
 8001952:	0fc0      	lsrs	r0, r0, #31
 8001954:	68a2      	ldr	r2, [r4, #8]
 8001956:	68d2      	ldr	r2, [r2, #12]
 8001958:	4790      	blx	r2
 800195a:	2001      	movs	r0, #1
 800195c:	6861      	ldr	r1, [r4, #4]
 800195e:	7809      	ldrb	r1, [r1, #0]
 8001960:	08ca      	lsrs	r2, r1, #3
 8001962:	2101      	movs	r1, #1
 8001964:	4011      	ands	r1, r2
 8001966:	68e2      	ldr	r2, [r4, #12]
 8001968:	4010      	ands	r0, r2
 800196a:	f003 fae5 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 800196e:	e037      	b.n	80019e0 <__iar_annotation$$branch>
 8001970:	6860      	ldr	r0, [r4, #4]
 8001972:	e74b      	b.n	800180c <__iar_annotation$$branch+0x23e>
 8001974:	2001      	movs	r0, #1
 8001976:	9000      	str	r0, [sp, #0]
 8001978:	2395      	movs	r3, #149	; 0x95
 800197a:	2209      	movs	r2, #9
 800197c:	2100      	movs	r1, #0
 800197e:	0020      	movs	r0, r4
 8001980:	f001 fef7 	bl	8003772 <PE_Send_CtrlMessage>
 8001984:	2800      	cmp	r0, #0
 8001986:	d12b      	bne.n	80019e0 <__iar_annotation$$branch>
 8001988:	200f      	movs	r0, #15
 800198a:	82e0      	strh	r0, [r4, #22]
 800198c:	48a6      	ldr	r0, [pc, #664]	; (8001c28 <.text_19>)
 800198e:	83b0      	strh	r0, [r6, #28]
 8001990:	251a      	movs	r5, #26
 8001992:	4fa4      	ldr	r7, [pc, #656]	; (8001c24 <.text_18>)
 8001994:	7838      	ldrb	r0, [r7, #0]
 8001996:	0780      	lsls	r0, r0, #30
 8001998:	d509      	bpl.n	80019ae <__iar_annotation$$branch+0xf0>
 800199a:	2000      	movs	r0, #0
 800199c:	9000      	str	r0, [sp, #0]
 800199e:	2300      	movs	r3, #0
 80019a0:	2221      	movs	r2, #33	; 0x21
 80019a2:	7b20      	ldrb	r0, [r4, #12]
 80019a4:	07c1      	lsls	r1, r0, #31
 80019a6:	0fc9      	lsrs	r1, r1, #31
 80019a8:	2009      	movs	r0, #9
 80019aa:	68ff      	ldr	r7, [r7, #12]
 80019ac:	47b8      	blx	r7
 80019ae:	2121      	movs	r1, #33	; 0x21
 80019b0:	e0e7      	b.n	8001b82 <__iar_annotation$$branch>
 80019b2:	8bb2      	ldrh	r2, [r6, #28]
 80019b4:	03ab      	lsls	r3, r5, #14
 80019b6:	429a      	cmp	r2, r3
 80019b8:	d100      	bne.n	80019bc <__iar_annotation$$branch+0xfe>
 80019ba:	e0e8      	b.n	8001b8e <__iar_annotation$$branch+0xc>
 80019bc:	2914      	cmp	r1, #20
 80019be:	d00f      	beq.n	80019e0 <__iar_annotation$$branch>
 80019c0:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80019c2:	0bc9      	lsrs	r1, r1, #15
 80019c4:	d10c      	bne.n	80019e0 <__iar_annotation$$branch>
 80019c6:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80019c8:	0b09      	lsrs	r1, r1, #12
 80019ca:	0749      	lsls	r1, r1, #29
 80019cc:	d108      	bne.n	80019e0 <__iar_annotation$$branch>
 80019ce:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80019d0:	06c9      	lsls	r1, r1, #27
 80019d2:	0ec9      	lsrs	r1, r1, #27
 80019d4:	2903      	cmp	r1, #3
 80019d6:	d005      	beq.n	80019e4 <__iar_annotation$$branch+0x4>
 80019d8:	2904      	cmp	r1, #4
 80019da:	d052      	beq.n	8001a82 <__iar_annotation$$branch+0xa2>
 80019dc:	290c      	cmp	r1, #12
 80019de:	d03c      	beq.n	8001a5a <__iar_annotation$$branch+0x7a>

080019e0 <__iar_annotation$$branch>:
 80019e0:	f7fe fff0 	bl	80009c4 <__iar_annotation$$branch+0x1e8>
 80019e4:	6861      	ldr	r1, [r4, #4]
 80019e6:	780a      	ldrb	r2, [r1, #0]
 80019e8:	08d3      	lsrs	r3, r2, #3
 80019ea:	07db      	lsls	r3, r3, #31
 80019ec:	d410      	bmi.n	8001a10 <__iar_annotation$$branch+0x30>
 80019ee:	2308      	movs	r3, #8
 80019f0:	4313      	orrs	r3, r2
 80019f2:	700b      	strb	r3, [r1, #0]
 80019f4:	2800      	cmp	r0, #0
 80019f6:	d009      	beq.n	8001a0c <__iar_annotation$$branch+0x2c>
 80019f8:	2000      	movs	r0, #0
 80019fa:	9000      	str	r0, [sp, #0]
 80019fc:	2300      	movs	r3, #0
 80019fe:	2224      	movs	r2, #36	; 0x24
 8001a00:	7b20      	ldrb	r0, [r4, #12]
 8001a02:	07c1      	lsls	r1, r0, #31
 8001a04:	0fc9      	lsrs	r1, r1, #31
 8001a06:	2009      	movs	r0, #9
 8001a08:	9f01      	ldr	r7, [sp, #4]
 8001a0a:	47b8      	blx	r7
 8001a0c:	2124      	movs	r1, #36	; 0x24
 8001a0e:	e00f      	b.n	8001a30 <__iar_annotation$$branch+0x50>
 8001a10:	23f7      	movs	r3, #247	; 0xf7
 8001a12:	4013      	ands	r3, r2
 8001a14:	700b      	strb	r3, [r1, #0]
 8001a16:	2800      	cmp	r0, #0
 8001a18:	d009      	beq.n	8001a2e <__iar_annotation$$branch+0x4e>
 8001a1a:	2000      	movs	r0, #0
 8001a1c:	9000      	str	r0, [sp, #0]
 8001a1e:	2300      	movs	r3, #0
 8001a20:	2223      	movs	r2, #35	; 0x23
 8001a22:	7b20      	ldrb	r0, [r4, #12]
 8001a24:	07c1      	lsls	r1, r0, #31
 8001a26:	0fc9      	lsrs	r1, r1, #31
 8001a28:	2009      	movs	r0, #9
 8001a2a:	9f01      	ldr	r7, [sp, #4]
 8001a2c:	47b8      	blx	r7
 8001a2e:	2123      	movs	r1, #35	; 0x23
 8001a30:	7b22      	ldrb	r2, [r4, #12]
 8001a32:	07d0      	lsls	r0, r2, #31
 8001a34:	0fc0      	lsrs	r0, r0, #31
 8001a36:	68a2      	ldr	r2, [r4, #8]
 8001a38:	68d2      	ldr	r2, [r2, #12]
 8001a3a:	4790      	blx	r2
 8001a3c:	2001      	movs	r0, #1
 8001a3e:	6861      	ldr	r1, [r4, #4]
 8001a40:	7809      	ldrb	r1, [r1, #0]
 8001a42:	08ca      	lsrs	r2, r1, #3
 8001a44:	2101      	movs	r1, #1
 8001a46:	4011      	ands	r1, r2
 8001a48:	68e2      	ldr	r2, [r4, #12]
 8001a4a:	4010      	ands	r0, r2
 8001a4c:	f003 fa74 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 8001a50:	2000      	movs	r0, #0
 8001a52:	83b0      	strh	r0, [r6, #28]
 8001a54:	2003      	movs	r0, #3
 8001a56:	7230      	strb	r0, [r6, #8]
 8001a58:	e716      	b.n	8001888 <__iar_annotation$$branch+0x2ba>
 8001a5a:	2800      	cmp	r0, #0
 8001a5c:	d009      	beq.n	8001a72 <__iar_annotation$$branch+0x92>
 8001a5e:	2000      	movs	r0, #0
 8001a60:	9000      	str	r0, [sp, #0]
 8001a62:	2300      	movs	r3, #0
 8001a64:	2225      	movs	r2, #37	; 0x25
 8001a66:	7b20      	ldrb	r0, [r4, #12]
 8001a68:	07c1      	lsls	r1, r0, #31
 8001a6a:	0fc9      	lsrs	r1, r1, #31
 8001a6c:	2009      	movs	r0, #9
 8001a6e:	9f01      	ldr	r7, [sp, #4]
 8001a70:	47b8      	blx	r7
 8001a72:	2125      	movs	r1, #37	; 0x25
 8001a74:	7b22      	ldrb	r2, [r4, #12]
 8001a76:	07d0      	lsls	r0, r2, #31
 8001a78:	0fc0      	lsrs	r0, r0, #31
 8001a7a:	68a2      	ldr	r2, [r4, #8]
 8001a7c:	68d2      	ldr	r2, [r2, #12]
 8001a7e:	4790      	blx	r2
 8001a80:	e7e6      	b.n	8001a50 <__iar_annotation$$branch+0x70>
 8001a82:	2800      	cmp	r0, #0
 8001a84:	d009      	beq.n	8001a9a <__iar_annotation$$branch+0xba>
 8001a86:	2000      	movs	r0, #0
 8001a88:	9000      	str	r0, [sp, #0]
 8001a8a:	2300      	movs	r3, #0
 8001a8c:	2226      	movs	r2, #38	; 0x26
 8001a8e:	7b20      	ldrb	r0, [r4, #12]
 8001a90:	07c1      	lsls	r1, r0, #31
 8001a92:	0fc9      	lsrs	r1, r1, #31
 8001a94:	2009      	movs	r0, #9
 8001a96:	9f01      	ldr	r7, [sp, #4]
 8001a98:	47b8      	blx	r7
 8001a9a:	2126      	movs	r1, #38	; 0x26
 8001a9c:	7b22      	ldrb	r2, [r4, #12]
 8001a9e:	07d0      	lsls	r0, r2, #31
 8001aa0:	0fc0      	lsrs	r0, r0, #31
 8001aa2:	68a2      	ldr	r2, [r4, #8]
 8001aa4:	68d2      	ldr	r2, [r2, #12]
 8001aa6:	4790      	blx	r2
 8001aa8:	e7d2      	b.n	8001a50 <__iar_annotation$$branch+0x70>
 8001aaa:	2000      	movs	r0, #0
 8001aac:	9002      	str	r0, [sp, #8]
 8001aae:	2003      	movs	r0, #3
 8001ab0:	9001      	str	r0, [sp, #4]
 8001ab2:	2001      	movs	r0, #1
 8001ab4:	9000      	str	r0, [sp, #0]
 8001ab6:	20e3      	movs	r0, #227	; 0xe3
 8001ab8:	0080      	lsls	r0, r0, #2
 8001aba:	1823      	adds	r3, r4, r0
 8001abc:	2206      	movs	r2, #6
 8001abe:	2100      	movs	r1, #0
 8001ac0:	0020      	movs	r0, r4
 8001ac2:	f001 fe9d 	bl	8003800 <PE_Send_DataMessage>
 8001ac6:	e78b      	b.n	80019e0 <__iar_annotation$$branch>
 8001ac8:	ab06      	add	r3, sp, #24
 8001aca:	aa05      	add	r2, sp, #20
 8001acc:	210a      	movs	r1, #10
 8001ace:	a80a      	add	r0, sp, #40	; 0x28
 8001ad0:	7800      	ldrb	r0, [r0, #0]
 8001ad2:	68a7      	ldr	r7, [r4, #8]
 8001ad4:	69bf      	ldr	r7, [r7, #24]
 8001ad6:	47b8      	blx	r7
 8001ad8:	2700      	movs	r7, #0
 8001ada:	76e7      	strb	r7, [r4, #27]
 8001adc:	76a7      	strb	r7, [r4, #26]
 8001ade:	7b21      	ldrb	r1, [r4, #12]
 8001ae0:	07c8      	lsls	r0, r1, #31
 8001ae2:	0fc0      	lsrs	r0, r0, #31
 8001ae4:	f002 fcde 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8001ae8:	2800      	cmp	r0, #0
 8001aea:	d103      	bne.n	8001af4 <__iar_annotation$$branch+0x114>
 8001aec:	8b60      	ldrh	r0, [r4, #26]
 8001aee:	03a9      	lsls	r1, r5, #14
 8001af0:	4301      	orrs	r1, r0
 8001af2:	8361      	strh	r1, [r4, #26]
 8001af4:	9805      	ldr	r0, [sp, #20]
 8001af6:	00f9      	lsls	r1, r7, #3
 8001af8:	40c8      	lsrs	r0, r1
 8001afa:	0021      	movs	r1, r4
 8001afc:	311c      	adds	r1, #28
 8001afe:	55c8      	strb	r0, [r1, r7]
 8001b00:	1c7f      	adds	r7, r7, #1
 8001b02:	2f04      	cmp	r7, #4
 8001b04:	dbf6      	blt.n	8001af4 <__iar_annotation$$branch+0x114>
 8001b06:	2000      	movs	r0, #0
 8001b08:	9002      	str	r0, [sp, #8]
 8001b0a:	2003      	movs	r0, #3
 8001b0c:	9001      	str	r0, [sp, #4]
 8001b0e:	2008      	movs	r0, #8
 8001b10:	9000      	str	r0, [sp, #0]
 8001b12:	0023      	movs	r3, r4
 8001b14:	3318      	adds	r3, #24
 8001b16:	228c      	movs	r2, #140	; 0x8c
 8001b18:	2100      	movs	r1, #0
 8001b1a:	0020      	movs	r0, r4
 8001b1c:	f002 fcd2 	bl	80044c4 <PE_Send_ExtendedMessage>
 8001b20:	4f40      	ldr	r7, [pc, #256]	; (8001c24 <.text_18>)
 8001b22:	7838      	ldrb	r0, [r7, #0]
 8001b24:	0780      	lsls	r0, r0, #30
 8001b26:	d509      	bpl.n	8001b3c <__iar_annotation$$branch+0x15c>
 8001b28:	2000      	movs	r0, #0
 8001b2a:	9000      	str	r0, [sp, #0]
 8001b2c:	2300      	movs	r3, #0
 8001b2e:	2249      	movs	r2, #73	; 0x49
 8001b30:	7b20      	ldrb	r0, [r4, #12]
 8001b32:	07c1      	lsls	r1, r0, #31
 8001b34:	0fc9      	lsrs	r1, r1, #31
 8001b36:	2009      	movs	r0, #9
 8001b38:	68ff      	ldr	r7, [r7, #12]
 8001b3a:	47b8      	blx	r7
 8001b3c:	2149      	movs	r1, #73	; 0x49
 8001b3e:	e020      	b.n	8001b82 <__iar_annotation$$branch>
 8001b40:	20e5      	movs	r0, #229	; 0xe5
 8001b42:	0080      	lsls	r0, r0, #2
 8001b44:	1827      	adds	r7, r4, r0
 8001b46:	2001      	movs	r0, #1
 8001b48:	9000      	str	r0, [sp, #0]
 8001b4a:	2339      	movs	r3, #57	; 0x39
 8001b4c:	783a      	ldrb	r2, [r7, #0]
 8001b4e:	7971      	ldrb	r1, [r6, #5]
 8001b50:	0020      	movs	r0, r4
 8001b52:	f001 fe0e 	bl	8003772 <PE_Send_CtrlMessage>
 8001b56:	2800      	cmp	r0, #0
 8001b58:	d128      	bne.n	8001bac <__iar_annotation$$branch+0x2a>
 8001b5a:	8878      	ldrh	r0, [r7, #2]
 8001b5c:	82e0      	strh	r0, [r4, #22]
 8001b5e:	4832      	ldr	r0, [pc, #200]	; (8001c28 <.text_19>)
 8001b60:	83b0      	strh	r0, [r6, #28]
 8001b62:	251a      	movs	r5, #26
 8001b64:	4f2f      	ldr	r7, [pc, #188]	; (8001c24 <.text_18>)
 8001b66:	7838      	ldrb	r0, [r7, #0]
 8001b68:	0780      	lsls	r0, r0, #30
 8001b6a:	d509      	bpl.n	8001b80 <__iar_annotation$$branch+0x1a0>
 8001b6c:	2000      	movs	r0, #0
 8001b6e:	9000      	str	r0, [sp, #0]
 8001b70:	2300      	movs	r3, #0
 8001b72:	2241      	movs	r2, #65	; 0x41
 8001b74:	7b20      	ldrb	r0, [r4, #12]
 8001b76:	07c1      	lsls	r1, r0, #31
 8001b78:	0fc9      	lsrs	r1, r1, #31
 8001b7a:	2009      	movs	r0, #9
 8001b7c:	68ff      	ldr	r7, [r7, #12]
 8001b7e:	47b8      	blx	r7
 8001b80:	2141      	movs	r1, #65	; 0x41

08001b82 <__iar_annotation$$branch>:
 8001b82:	f7fe ffb3 	bl	8000aec <__iar_annotation$$branch+0xf4>
 8001b86:	8bb0      	ldrh	r0, [r6, #28]
 8001b88:	03aa      	lsls	r2, r5, #14
 8001b8a:	4290      	cmp	r0, r2
 8001b8c:	d102      	bne.n	8001b94 <__iar_annotation$$branch+0x12>
 8001b8e:	2000      	movs	r0, #0
 8001b90:	83b0      	strh	r0, [r6, #28]
 8001b92:	e02e      	b.n	8001bf2 <__iar_annotation$$branch>
 8001b94:	2914      	cmp	r1, #20
 8001b96:	d009      	beq.n	8001bac <__iar_annotation$$branch+0x2a>
 8001b98:	2000      	movs	r0, #0
 8001b9a:	83b0      	strh	r0, [r6, #28]
 8001b9c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001b9e:	0bc0      	lsrs	r0, r0, #15
 8001ba0:	d027      	beq.n	8001bf2 <__iar_annotation$$branch>
 8001ba2:	e65f      	b.n	8001864 <__iar_annotation$$branch+0x296>
 8001ba4:	0020      	movs	r0, r4
 8001ba6:	f002 fce0 	bl	800456a <PE_SubStateMachine_ExtendedMessages>
 8001baa:	0005      	movs	r5, r0
 8001bac:	e718      	b.n	80019e0 <__iar_annotation$$branch>
 8001bae:	a903      	add	r1, sp, #12
 8001bb0:	0020      	movs	r0, r4
 8001bb2:	f002 fdf1 	bl	8004798 <PE_SubStateMachine_Generic>
 8001bb6:	e7f8      	b.n	8001baa <__iar_annotation$$branch+0x28>
 8001bb8:	a903      	add	r1, sp, #12
 8001bba:	0020      	movs	r0, r4
 8001bbc:	f002 ff5e 	bl	8004a7c <PE_SubStateMachine_VconnSwap>
 8001bc0:	0005      	movs	r5, r0
 8001bc2:	6860      	ldr	r0, [r4, #4]
 8001bc4:	6800      	ldr	r0, [r0, #0]
 8001bc6:	0340      	lsls	r0, r0, #13
 8001bc8:	0fc1      	lsrs	r1, r0, #31
 8001bca:	a80a      	add	r0, sp, #40	; 0x28
 8001bcc:	7800      	ldrb	r0, [r0, #0]
 8001bce:	f003 f9e4 	bl	8004f9a <USBPD_PRL_CableCapable>
 8001bd2:	e705      	b.n	80019e0 <__iar_annotation$$branch>
 8001bd4:	2106      	movs	r1, #6
 8001bd6:	a80a      	add	r0, sp, #40	; 0x28
 8001bd8:	7800      	ldrb	r0, [r0, #0]
 8001bda:	f007 fde5 	bl	80097a8 <USBPD_PHY_ResetRequest>
 8001bde:	2007      	movs	r0, #7
 8001be0:	6861      	ldr	r1, [r4, #4]
 8001be2:	7849      	ldrb	r1, [r1, #1]
 8001be4:	0909      	lsrs	r1, r1, #4
 8001be6:	2207      	movs	r2, #7
 8001be8:	400a      	ands	r2, r1
 8001bea:	2a03      	cmp	r2, #3
 8001bec:	d001      	beq.n	8001bf2 <__iar_annotation$$branch>

08001bee <__iar_annotation$$branch>:
 8001bee:	f7fe fe67 	bl	80008c0 <__iar_annotation$$branch+0xe4>

08001bf2 <__iar_annotation$$branch>:
 8001bf2:	f7ff f91c 	bl	8000e2e <__iar_annotation$$branch+0x436>
 8001bf6:	7a30      	ldrb	r0, [r6, #8]
 8001bf8:	2803      	cmp	r0, #3
 8001bfa:	d110      	bne.n	8001c1e <__iar_annotation$$branch>
 8001bfc:	200e      	movs	r0, #14
 8001bfe:	5e30      	ldrsh	r0, [r6, r0]
 8001c00:	2800      	cmp	r0, #0
 8001c02:	d00c      	beq.n	8001c1e <__iar_annotation$$branch>
 8001c04:	2016      	movs	r0, #22
 8001c06:	5e20      	ldrsh	r0, [r4, r0]
 8001c08:	2800      	cmp	r0, #0
 8001c0a:	d108      	bne.n	8001c1e <__iar_annotation$$branch>
 8001c0c:	7b30      	ldrb	r0, [r6, #12]
 8001c0e:	7230      	strb	r0, [r6, #8]
 8001c10:	7b70      	ldrb	r0, [r6, #13]
 8001c12:	72f0      	strb	r0, [r6, #11]
 8001c14:	89f0      	ldrh	r0, [r6, #14]
 8001c16:	82e0      	strh	r0, [r4, #22]
 8001c18:	2000      	movs	r0, #0
 8001c1a:	81f0      	strh	r0, [r6, #14]
 8001c1c:	2501      	movs	r5, #1

08001c1e <__iar_annotation$$branch>:
 8001c1e:	f7fe ff0b 	bl	8000a38 <__iar_annotation$$branch+0x40>
	...

08001c24 <.text_18>:
 8001c24:	200019e8 	.word	0x200019e8

08001c28 <.text_19>:
 8001c28:	0000801a 	.word	0x0000801a

08001c2c <USBPD_PE_StateMachine_SNK>:
 8001c2c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001c2e:	b08f      	sub	sp, #60	; 0x3c
 8001c30:	0005      	movs	r5, r0
 8001c32:	48b3      	ldr	r0, [pc, #716]	; (8001f00 <__iar_annotation$$branch+0xce>)
 8001c34:	00a9      	lsls	r1, r5, #2
 8001c36:	1840      	adds	r0, r0, r1
 8001c38:	6840      	ldr	r0, [r0, #4]
 8001c3a:	9006      	str	r0, [sp, #24]
 8001c3c:	2400      	movs	r4, #0
 8001c3e:	21d9      	movs	r1, #217	; 0xd9
 8001c40:	0089      	lsls	r1, r1, #2
 8001c42:	1840      	adds	r0, r0, r1
 8001c44:	9004      	str	r0, [sp, #16]
 8001c46:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8001c48:	8807      	ldrh	r7, [r0, #0]
 8001c4a:	4668      	mov	r0, sp
 8001c4c:	9904      	ldr	r1, [sp, #16]
 8001c4e:	8849      	ldrh	r1, [r1, #2]
 8001c50:	82c1      	strh	r1, [r0, #22]
 8001c52:	9904      	ldr	r1, [sp, #16]
 8001c54:	8889      	ldrh	r1, [r1, #4]
 8001c56:	8281      	strh	r1, [r0, #20]
 8001c58:	9904      	ldr	r1, [sp, #16]
 8001c5a:	88c9      	ldrh	r1, [r1, #6]
 8001c5c:	81c1      	strh	r1, [r0, #14]
 8001c5e:	9904      	ldr	r1, [sp, #16]
 8001c60:	8909      	ldrh	r1, [r1, #8]
 8001c62:	8141      	strh	r1, [r0, #10]
 8001c64:	9904      	ldr	r1, [sp, #16]
 8001c66:	8949      	ldrh	r1, [r1, #10]
 8001c68:	8101      	strh	r1, [r0, #8]
 8001c6a:	9904      	ldr	r1, [sp, #16]
 8001c6c:	8989      	ldrh	r1, [r1, #12]
 8001c6e:	80c1      	strh	r1, [r0, #6]
 8001c70:	9904      	ldr	r1, [sp, #16]
 8001c72:	89c9      	ldrh	r1, [r1, #14]
 8001c74:	8081      	strh	r1, [r0, #4]
 8001c76:	9904      	ldr	r1, [sp, #16]
 8001c78:	89c9      	ldrh	r1, [r1, #14]
 8001c7a:	8041      	strh	r1, [r0, #2]
 8001c7c:	9904      	ldr	r1, [sp, #16]
 8001c7e:	8a09      	ldrh	r1, [r1, #16]
 8001c80:	8001      	strh	r1, [r0, #0]
 8001c82:	9804      	ldr	r0, [sp, #16]
 8001c84:	8a40      	ldrh	r0, [r0, #18]
 8001c86:	9904      	ldr	r1, [sp, #16]
 8001c88:	8a89      	ldrh	r1, [r1, #20]
 8001c8a:	9a04      	ldr	r2, [sp, #16]
 8001c8c:	8ad2      	ldrh	r2, [r2, #22]
 8001c8e:	9b04      	ldr	r3, [sp, #16]
 8001c90:	8c1b      	ldrh	r3, [r3, #32]
 8001c92:	0536      	lsls	r6, r6, #20
 8001c94:	0d36      	lsrs	r6, r6, #20
 8001c96:	19f6      	adds	r6, r6, r7
 8001c98:	466f      	mov	r7, sp
 8001c9a:	8aff      	ldrh	r7, [r7, #22]
 8001c9c:	19f6      	adds	r6, r6, r7
 8001c9e:	466f      	mov	r7, sp
 8001ca0:	8abf      	ldrh	r7, [r7, #20]
 8001ca2:	19f6      	adds	r6, r6, r7
 8001ca4:	466f      	mov	r7, sp
 8001ca6:	89ff      	ldrh	r7, [r7, #14]
 8001ca8:	19f6      	adds	r6, r6, r7
 8001caa:	466f      	mov	r7, sp
 8001cac:	897f      	ldrh	r7, [r7, #10]
 8001cae:	19f6      	adds	r6, r6, r7
 8001cb0:	466f      	mov	r7, sp
 8001cb2:	893f      	ldrh	r7, [r7, #8]
 8001cb4:	19f6      	adds	r6, r6, r7
 8001cb6:	466f      	mov	r7, sp
 8001cb8:	88ff      	ldrh	r7, [r7, #6]
 8001cba:	19f6      	adds	r6, r6, r7
 8001cbc:	466f      	mov	r7, sp
 8001cbe:	88bf      	ldrh	r7, [r7, #4]
 8001cc0:	19f6      	adds	r6, r6, r7
 8001cc2:	466f      	mov	r7, sp
 8001cc4:	887f      	ldrh	r7, [r7, #2]
 8001cc6:	19f6      	adds	r6, r6, r7
 8001cc8:	466f      	mov	r7, sp
 8001cca:	883f      	ldrh	r7, [r7, #0]
 8001ccc:	19f6      	adds	r6, r6, r7
 8001cce:	1830      	adds	r0, r6, r0
 8001cd0:	1840      	adds	r0, r0, r1
 8001cd2:	1880      	adds	r0, r0, r2
 8001cd4:	0519      	lsls	r1, r3, #20
 8001cd6:	0f49      	lsrs	r1, r1, #29
 8001cd8:	1840      	adds	r0, r0, r1
 8001cda:	9904      	ldr	r1, [sp, #16]
 8001cdc:	8c09      	ldrh	r1, [r1, #32]
 8001cde:	06c9      	lsls	r1, r1, #27
 8001ce0:	0ec9      	lsrs	r1, r1, #27
 8001ce2:	1846      	adds	r6, r0, r1
 8001ce4:	b2b6      	uxth	r6, r6
 8001ce6:	9806      	ldr	r0, [sp, #24]
 8001ce8:	f001 fe68 	bl	80039bc <PE_Check_RxEvent>
 8001cec:	4669      	mov	r1, sp
 8001cee:	7308      	strb	r0, [r1, #12]
 8001cf0:	2803      	cmp	r0, #3
 8001cf2:	d001      	beq.n	8001cf8 <__iar_annotation$$branch+0x4>

08001cf4 <__iar_annotation$$branch>:
 8001cf4:	f001 f97c 	bl	8002ff0 <__iar_annotation$$branch+0xaa0>
 8001cf8:	2001      	movs	r0, #1

08001cfa <__iar_annotation$$branch>:
 8001cfa:	f001 f974 	bl	8002fe6 <__iar_annotation$$branch+0xa96>
 8001cfe:	2400      	movs	r4, #0
 8001d00:	43e4      	mvns	r4, r4
 8001d02:	6868      	ldr	r0, [r5, #4]
 8001d04:	6801      	ldr	r1, [r0, #0]
 8001d06:	2210      	movs	r2, #16
 8001d08:	4391      	bics	r1, r2
 8001d0a:	6001      	str	r1, [r0, #0]

08001d0c <__iar_annotation$$branch>:
 8001d0c:	f001 f8fe 	bl	8002f0c <__iar_annotation$$branch+0x9bc>
 8001d10:	6868      	ldr	r0, [r5, #4]
 8001d12:	6800      	ldr	r0, [r0, #0]
 8001d14:	0340      	lsls	r0, r0, #13
 8001d16:	0fc1      	lsrs	r1, r0, #31
 8001d18:	4668      	mov	r0, sp
 8001d1a:	7b40      	ldrb	r0, [r0, #13]
 8001d1c:	f003 f93d 	bl	8004f9a <USBPD_PRL_CableCapable>
 8001d20:	2701      	movs	r7, #1
 8001d22:	68e9      	ldr	r1, [r5, #12]
 8001d24:	2001      	movs	r0, #1
 8001d26:	4008      	ands	r0, r1
 8001d28:	f003 fb94 	bl	8005454 <USBPD_PRL_Reset>
 8001d2c:	6868      	ldr	r0, [r5, #4]
 8001d2e:	6801      	ldr	r1, [r0, #0]
 8001d30:	0ac9      	lsrs	r1, r1, #11
 8001d32:	4039      	ands	r1, r7
 8001d34:	d0ea      	beq.n	8001d0c <__iar_annotation$$branch>
 8001d36:	2103      	movs	r1, #3
 8001d38:	682a      	ldr	r2, [r5, #0]
 8001d3a:	7913      	ldrb	r3, [r2, #4]
 8001d3c:	2203      	movs	r2, #3
 8001d3e:	401a      	ands	r2, r3
 8001d40:	7803      	ldrb	r3, [r0, #0]
 8001d42:	24fc      	movs	r4, #252	; 0xfc
 8001d44:	401c      	ands	r4, r3
 8001d46:	4322      	orrs	r2, r4
 8001d48:	7002      	strb	r2, [r0, #0]
 8001d4a:	6868      	ldr	r0, [r5, #4]
 8001d4c:	7802      	ldrb	r2, [r0, #0]
 8001d4e:	4011      	ands	r1, r2
 8001d50:	2901      	cmp	r1, #1
 8001d52:	d100      	bne.n	8001d56 <__iar_annotation$$branch+0x4a>
 8001d54:	2700      	movs	r7, #0
 8001d56:	219f      	movs	r1, #159	; 0x9f
 8001d58:	4011      	ands	r1, r2
 8001d5a:	017a      	lsls	r2, r7, #5
 8001d5c:	430a      	orrs	r2, r1
 8001d5e:	7002      	strb	r2, [r0, #0]
 8001d60:	48b3      	ldr	r0, [pc, #716]	; (8002030 <__iar_annotation$$branch+0x1fe>)
 8001d62:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001d64:	24fa      	movs	r4, #250	; 0xfa
 8001d66:	0064      	lsls	r4, r4, #1

08001d68 <__iar_annotation$$branch>:
 8001d68:	f001 f8ce 	bl	8002f08 <__iar_annotation$$branch+0x9b8>
 8001d6c:	2911      	cmp	r1, #17
 8001d6e:	d131      	bne.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d70:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d72:	0bc0      	lsrs	r0, r0, #15
 8001d74:	d12e      	bne.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d76:	2707      	movs	r7, #7
 8001d78:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d7a:	0b00      	lsrs	r0, r0, #12
 8001d7c:	4238      	tst	r0, r7
 8001d7e:	d029      	beq.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d80:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d82:	06c0      	lsls	r0, r0, #27
 8001d84:	0ec0      	lsrs	r0, r0, #27
 8001d86:	2801      	cmp	r0, #1
 8001d88:	d124      	bne.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d8a:	2000      	movs	r0, #0
 8001d8c:	7528      	strb	r0, [r5, #20]
 8001d8e:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d90:	0600      	lsls	r0, r0, #24
 8001d92:	0f81      	lsrs	r1, r0, #30
 8001d94:	4668      	mov	r0, sp
 8001d96:	7b40      	ldrb	r0, [r0, #13]
 8001d98:	f002 fb1a 	bl	80043d0 <PE_ExtRevisionInteroperability>
 8001d9c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d9e:	0b00      	lsrs	r0, r0, #12
 8001da0:	4007      	ands	r7, r0
 8001da2:	00bb      	lsls	r3, r7, #2
 8001da4:	209e      	movs	r0, #158	; 0x9e
 8001da6:	0040      	lsls	r0, r0, #1
 8001da8:	182a      	adds	r2, r5, r0
 8001daa:	2104      	movs	r1, #4
 8001dac:	7b2f      	ldrb	r7, [r5, #12]
 8001dae:	07f8      	lsls	r0, r7, #31
 8001db0:	0fc0      	lsrs	r0, r0, #31
 8001db2:	68af      	ldr	r7, [r5, #8]
 8001db4:	69ff      	ldr	r7, [r7, #28]
 8001db6:	47b8      	blx	r7
 8001db8:	2001      	movs	r0, #1
 8001dba:	82e8      	strh	r0, [r5, #22]
 8001dbc:	2044      	movs	r0, #68	; 0x44
 8001dbe:	7130      	strb	r0, [r6, #4]
 8001dc0:	6868      	ldr	r0, [r5, #4]
 8001dc2:	6801      	ldr	r1, [r0, #0]
 8001dc4:	2210      	movs	r2, #16
 8001dc6:	4391      	bics	r1, r2
 8001dc8:	6001      	str	r1, [r0, #0]
 8001dca:	2000      	movs	r0, #0
 8001dcc:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001dce:	2014      	movs	r0, #20
 8001dd0:	4669      	mov	r1, sp
 8001dd2:	7308      	strb	r0, [r1, #12]
 8001dd4:	8cf0      	ldrh	r0, [r6, #38]	; 0x26
 8001dd6:	03a1      	lsls	r1, r4, #14
 8001dd8:	4288      	cmp	r0, r1
 8001dda:	d197      	bne.n	8001d0c <__iar_annotation$$branch>
 8001ddc:	6868      	ldr	r0, [r5, #4]
 8001dde:	6801      	ldr	r1, [r0, #0]
 8001de0:	2210      	movs	r2, #16
 8001de2:	4391      	bics	r1, r2
 8001de4:	6001      	str	r1, [r0, #0]
 8001de6:	2000      	movs	r0, #0
 8001de8:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001dea:	e241      	b.n	8002270 <__iar_annotation$$branch>
 8001dec:	2001      	movs	r0, #1
 8001dee:	82e8      	strh	r0, [r5, #22]
 8001df0:	466a      	mov	r2, sp
 8001df2:	0029      	movs	r1, r5
 8001df4:	3110      	adds	r1, #16
 8001df6:	68eb      	ldr	r3, [r5, #12]
 8001df8:	4018      	ands	r0, r3
 8001dfa:	68ab      	ldr	r3, [r5, #8]
 8001dfc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001dfe:	4798      	blx	r3
 8001e00:	7b28      	ldrb	r0, [r5, #12]
 8001e02:	21f3      	movs	r1, #243	; 0xf3
 8001e04:	4001      	ands	r1, r0
 8001e06:	4668      	mov	r0, sp
 8001e08:	7800      	ldrb	r0, [r0, #0]
 8001e0a:	0080      	lsls	r0, r0, #2
 8001e0c:	220c      	movs	r2, #12
 8001e0e:	4002      	ands	r2, r0
 8001e10:	430a      	orrs	r2, r1
 8001e12:	732a      	strb	r2, [r5, #12]
 8001e14:	2045      	movs	r0, #69	; 0x45
 8001e16:	e181      	b.n	800211c <__iar_annotation$$branch+0x2ea>
 8001e18:	2000      	movs	r0, #0
 8001e1a:	9002      	str	r0, [sp, #8]
 8001e1c:	2046      	movs	r0, #70	; 0x46
 8001e1e:	9001      	str	r0, [sp, #4]
 8001e20:	2001      	movs	r0, #1
 8001e22:	9000      	str	r0, [sp, #0]
 8001e24:	002b      	movs	r3, r5
 8001e26:	3310      	adds	r3, #16
 8001e28:	2202      	movs	r2, #2
 8001e2a:	2100      	movs	r1, #0
 8001e2c:	0028      	movs	r0, r5
 8001e2e:	f001 fce7 	bl	8003800 <PE_Send_DataMessage>

08001e32 <__iar_annotation$$branch>:
 8001e32:	f000 fff6 	bl	8002e22 <__iar_annotation$$branch+0x8d2>
 8001e36:	2911      	cmp	r1, #17
 8001e38:	d111      	bne.n	8001e5e <__iar_annotation$$branch+0x2c>
 8001e3a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001e3c:	0bc9      	lsrs	r1, r1, #15
 8001e3e:	d10e      	bne.n	8001e5e <__iar_annotation$$branch+0x2c>
 8001e40:	2107      	movs	r1, #7
 8001e42:	8e32      	ldrh	r2, [r6, #48]	; 0x30
 8001e44:	0b12      	lsrs	r2, r2, #12
 8001e46:	420a      	tst	r2, r1
 8001e48:	d109      	bne.n	8001e5e <__iar_annotation$$branch+0x2c>
 8001e4a:	8e32      	ldrh	r2, [r6, #48]	; 0x30
 8001e4c:	06d2      	lsls	r2, r2, #27
 8001e4e:	0ed2      	lsrs	r2, r2, #27
 8001e50:	1e92      	subs	r2, r2, #2
 8001e52:	2a01      	cmp	r2, #1
 8001e54:	d904      	bls.n	8001e60 <__iar_annotation$$branch+0x2e>
 8001e56:	1e92      	subs	r2, r2, #2
 8001e58:	d026      	beq.n	8001ea8 <__iar_annotation$$branch+0x76>
 8001e5a:	3a08      	subs	r2, #8
 8001e5c:	d024      	beq.n	8001ea8 <__iar_annotation$$branch+0x76>
 8001e5e:	e08a      	b.n	8001f76 <__iar_annotation$$branch+0x144>
 8001e60:	2100      	movs	r1, #0
 8001e62:	8331      	strh	r1, [r6, #24]
 8001e64:	8471      	strh	r1, [r6, #34]	; 0x22
 8001e66:	2147      	movs	r1, #71	; 0x47
 8001e68:	7131      	strb	r1, [r6, #4]
 8001e6a:	4971      	ldr	r1, [pc, #452]	; (8002030 <__iar_annotation$$branch+0x1fe>)
 8001e6c:	8471      	strh	r1, [r6, #34]	; 0x22
 8001e6e:	24fa      	movs	r4, #250	; 0xfa
 8001e70:	0064      	lsls	r4, r4, #1
 8001e72:	6869      	ldr	r1, [r5, #4]
 8001e74:	784a      	ldrb	r2, [r1, #1]
 8001e76:	238f      	movs	r3, #143	; 0x8f
 8001e78:	4013      	ands	r3, r2
 8001e7a:	2240      	movs	r2, #64	; 0x40
 8001e7c:	431a      	orrs	r2, r3
 8001e7e:	704a      	strb	r2, [r1, #1]
 8001e80:	2800      	cmp	r0, #0
 8001e82:	d009      	beq.n	8001e98 <__iar_annotation$$branch+0x66>
 8001e84:	2000      	movs	r0, #0
 8001e86:	9000      	str	r0, [sp, #0]
 8001e88:	2300      	movs	r3, #0
 8001e8a:	2256      	movs	r2, #86	; 0x56
 8001e8c:	7b28      	ldrb	r0, [r5, #12]
 8001e8e:	07c1      	lsls	r1, r0, #31
 8001e90:	0fc9      	lsrs	r1, r1, #31
 8001e92:	2009      	movs	r0, #9
 8001e94:	9f01      	ldr	r7, [sp, #4]
 8001e96:	47b8      	blx	r7
 8001e98:	2156      	movs	r1, #86	; 0x56
 8001e9a:	7b2a      	ldrb	r2, [r5, #12]
 8001e9c:	07d0      	lsls	r0, r2, #31
 8001e9e:	0fc0      	lsrs	r0, r0, #31
 8001ea0:	68aa      	ldr	r2, [r5, #8]
 8001ea2:	68d2      	ldr	r2, [r2, #12]
 8001ea4:	4790      	blx	r2
 8001ea6:	e016      	b.n	8001ed6 <__iar_annotation$$branch+0xa4>
 8001ea8:	2400      	movs	r4, #0
 8001eaa:	8474      	strh	r4, [r6, #34]	; 0x22
 8001eac:	6868      	ldr	r0, [r5, #4]
 8001eae:	7840      	ldrb	r0, [r0, #1]
 8001eb0:	0900      	lsrs	r0, r0, #4
 8001eb2:	4001      	ands	r1, r0
 8001eb4:	2903      	cmp	r1, #3
 8001eb6:	d005      	beq.n	8001ec4 <__iar_annotation$$branch+0x92>
 8001eb8:	485d      	ldr	r0, [pc, #372]	; (8002030 <__iar_annotation$$branch+0x1fe>)
 8001eba:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001ebc:	24fa      	movs	r4, #250	; 0xfa
 8001ebe:	0064      	lsls	r4, r4, #1
 8001ec0:	2043      	movs	r0, #67	; 0x43
 8001ec2:	e007      	b.n	8001ed4 <__iar_annotation$$branch+0xa2>
 8001ec4:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001ec6:	06c0      	lsls	r0, r0, #27
 8001ec8:	0ec0      	lsrs	r0, r0, #27
 8001eca:	280c      	cmp	r0, #12
 8001ecc:	d101      	bne.n	8001ed2 <__iar_annotation$$branch+0xa0>
 8001ece:	2049      	movs	r0, #73	; 0x49
 8001ed0:	e000      	b.n	8001ed4 <__iar_annotation$$branch+0xa2>
 8001ed2:	2003      	movs	r0, #3
 8001ed4:	7130      	strb	r0, [r6, #4]
 8001ed6:	2014      	movs	r0, #20
 8001ed8:	4669      	mov	r1, sp
 8001eda:	7308      	strb	r0, [r1, #12]
 8001edc:	4808      	ldr	r0, [pc, #32]	; (8001f00 <__iar_annotation$$branch+0xce>)
 8001ede:	68c7      	ldr	r7, [r0, #12]
 8001ee0:	7800      	ldrb	r0, [r0, #0]
 8001ee2:	2102      	movs	r1, #2
 8001ee4:	4008      	ands	r0, r1
 8001ee6:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001ee8:	06c9      	lsls	r1, r1, #27
 8001eea:	0ec9      	lsrs	r1, r1, #27
 8001eec:	2902      	cmp	r1, #2
 8001eee:	d016      	beq.n	8001f1e <__iar_annotation$$branch+0xec>
 8001ef0:	2903      	cmp	r1, #3
 8001ef2:	d007      	beq.n	8001f04 <__iar_annotation$$branch+0xd2>
 8001ef4:	2904      	cmp	r1, #4
 8001ef6:	d01f      	beq.n	8001f38 <__iar_annotation$$branch+0x106>
 8001ef8:	290c      	cmp	r1, #12
 8001efa:	d02a      	beq.n	8001f52 <__iar_annotation$$branch+0x120>
 8001efc:	e03b      	b.n	8001f76 <__iar_annotation$$branch+0x144>
 8001efe:	bf00      	nop
 8001f00:	200019e8 	.word	0x200019e8
 8001f04:	2800      	cmp	r0, #0
 8001f06:	d008      	beq.n	8001f1a <__iar_annotation$$branch+0xe8>
 8001f08:	2000      	movs	r0, #0
 8001f0a:	9000      	str	r0, [sp, #0]
 8001f0c:	2300      	movs	r3, #0
 8001f0e:	2201      	movs	r2, #1
 8001f10:	7b28      	ldrb	r0, [r5, #12]
 8001f12:	07c1      	lsls	r1, r0, #31
 8001f14:	0fc9      	lsrs	r1, r1, #31
 8001f16:	2009      	movs	r0, #9
 8001f18:	47b8      	blx	r7
 8001f1a:	2101      	movs	r1, #1
 8001f1c:	e025      	b.n	8001f6a <__iar_annotation$$branch+0x138>
 8001f1e:	2800      	cmp	r0, #0
 8001f20:	d008      	beq.n	8001f34 <__iar_annotation$$branch+0x102>
 8001f22:	2000      	movs	r0, #0
 8001f24:	9000      	str	r0, [sp, #0]
 8001f26:	2300      	movs	r3, #0
 8001f28:	2204      	movs	r2, #4
 8001f2a:	7b28      	ldrb	r0, [r5, #12]
 8001f2c:	07c1      	lsls	r1, r0, #31
 8001f2e:	0fc9      	lsrs	r1, r1, #31
 8001f30:	2009      	movs	r0, #9
 8001f32:	47b8      	blx	r7
 8001f34:	2104      	movs	r1, #4
 8001f36:	e018      	b.n	8001f6a <__iar_annotation$$branch+0x138>
 8001f38:	2800      	cmp	r0, #0
 8001f3a:	d008      	beq.n	8001f4e <__iar_annotation$$branch+0x11c>
 8001f3c:	2000      	movs	r0, #0
 8001f3e:	9000      	str	r0, [sp, #0]
 8001f40:	2300      	movs	r3, #0
 8001f42:	2202      	movs	r2, #2
 8001f44:	7b28      	ldrb	r0, [r5, #12]
 8001f46:	07c1      	lsls	r1, r0, #31
 8001f48:	0fc9      	lsrs	r1, r1, #31
 8001f4a:	2009      	movs	r0, #9
 8001f4c:	47b8      	blx	r7
 8001f4e:	2102      	movs	r1, #2
 8001f50:	e00b      	b.n	8001f6a <__iar_annotation$$branch+0x138>
 8001f52:	2800      	cmp	r0, #0
 8001f54:	d008      	beq.n	8001f68 <__iar_annotation$$branch+0x136>
 8001f56:	2000      	movs	r0, #0
 8001f58:	9000      	str	r0, [sp, #0]
 8001f5a:	2300      	movs	r3, #0
 8001f5c:	2203      	movs	r2, #3
 8001f5e:	7b28      	ldrb	r0, [r5, #12]
 8001f60:	07c1      	lsls	r1, r0, #31
 8001f62:	0fc9      	lsrs	r1, r1, #31
 8001f64:	2009      	movs	r0, #9
 8001f66:	47b8      	blx	r7
 8001f68:	2103      	movs	r1, #3
 8001f6a:	7b2a      	ldrb	r2, [r5, #12]
 8001f6c:	07d0      	lsls	r0, r2, #31
 8001f6e:	0fc0      	lsrs	r0, r0, #31
 8001f70:	68aa      	ldr	r2, [r5, #8]
 8001f72:	68d2      	ldr	r2, [r2, #12]
 8001f74:	4790      	blx	r2
 8001f76:	8b30      	ldrh	r0, [r6, #24]
 8001f78:	2180      	movs	r1, #128	; 0x80
 8001f7a:	0209      	lsls	r1, r1, #8
 8001f7c:	4288      	cmp	r0, r1
 8001f7e:	d000      	beq.n	8001f82 <__iar_annotation$$branch+0x150>
 8001f80:	e6c4      	b.n	8001d0c <__iar_annotation$$branch>
 8001f82:	2400      	movs	r4, #0
 8001f84:	8334      	strh	r4, [r6, #24]
 8001f86:	e173      	b.n	8002270 <__iar_annotation$$branch>
 8001f88:	2911      	cmp	r1, #17
 8001f8a:	d148      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001f8c:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001f8e:	0bc9      	lsrs	r1, r1, #15
 8001f90:	d145      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001f92:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001f94:	0b09      	lsrs	r1, r1, #12
 8001f96:	0749      	lsls	r1, r1, #29
 8001f98:	d141      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001f9a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001f9c:	06c9      	lsls	r1, r1, #27
 8001f9e:	0ec9      	lsrs	r1, r1, #27
 8001fa0:	2906      	cmp	r1, #6
 8001fa2:	d13c      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001fa4:	2400      	movs	r4, #0
 8001fa6:	8474      	strh	r4, [r6, #34]	; 0x22
 8001fa8:	2114      	movs	r1, #20
 8001faa:	466a      	mov	r2, sp
 8001fac:	7311      	strb	r1, [r2, #12]
 8001fae:	6869      	ldr	r1, [r5, #4]
 8001fb0:	784a      	ldrb	r2, [r1, #1]
 8001fb2:	238f      	movs	r3, #143	; 0x8f
 8001fb4:	4013      	ands	r3, r2
 8001fb6:	2230      	movs	r2, #48	; 0x30
 8001fb8:	431a      	orrs	r2, r3
 8001fba:	704a      	strb	r2, [r1, #1]
 8001fbc:	2800      	cmp	r0, #0
 8001fbe:	d008      	beq.n	8001fd2 <__iar_annotation$$branch+0x1a0>
 8001fc0:	9400      	str	r4, [sp, #0]
 8001fc2:	2300      	movs	r3, #0
 8001fc4:	2256      	movs	r2, #86	; 0x56
 8001fc6:	7b28      	ldrb	r0, [r5, #12]
 8001fc8:	07c1      	lsls	r1, r0, #31
 8001fca:	0fc9      	lsrs	r1, r1, #31
 8001fcc:	2009      	movs	r0, #9
 8001fce:	9f01      	ldr	r7, [sp, #4]
 8001fd0:	47b8      	blx	r7
 8001fd2:	2156      	movs	r1, #86	; 0x56
 8001fd4:	7b2a      	ldrb	r2, [r5, #12]
 8001fd6:	07d0      	lsls	r0, r2, #31
 8001fd8:	0fc0      	lsrs	r0, r0, #31
 8001fda:	68aa      	ldr	r2, [r5, #8]
 8001fdc:	68d2      	ldr	r2, [r2, #12]
 8001fde:	4790      	blx	r2
 8001fe0:	82ec      	strh	r4, [r5, #22]
 8001fe2:	2003      	movs	r0, #3
 8001fe4:	7130      	strb	r0, [r6, #4]
 8001fe6:	4fb0      	ldr	r7, [pc, #704]	; (80022a8 <__iar_annotation$$branch+0x38>)
 8001fe8:	7838      	ldrb	r0, [r7, #0]
 8001fea:	0780      	lsls	r0, r0, #30
 8001fec:	d508      	bpl.n	8002000 <__iar_annotation$$branch+0x1ce>
 8001fee:	9400      	str	r4, [sp, #0]
 8001ff0:	2300      	movs	r3, #0
 8001ff2:	2210      	movs	r2, #16
 8001ff4:	7b28      	ldrb	r0, [r5, #12]
 8001ff6:	07c1      	lsls	r1, r0, #31
 8001ff8:	0fc9      	lsrs	r1, r1, #31
 8001ffa:	2009      	movs	r0, #9
 8001ffc:	68ff      	ldr	r7, [r7, #12]
 8001ffe:	47b8      	blx	r7
 8002000:	2110      	movs	r1, #16
 8002002:	7b2a      	ldrb	r2, [r5, #12]
 8002004:	07d0      	lsls	r0, r2, #31
 8002006:	0fc0      	lsrs	r0, r0, #31
 8002008:	68aa      	ldr	r2, [r5, #8]
 800200a:	68d2      	ldr	r2, [r2, #12]
 800200c:	4790      	blx	r2
 800200e:	7b28      	ldrb	r0, [r5, #12]
 8002010:	0700      	lsls	r0, r0, #28
 8002012:	0f80      	lsrs	r0, r0, #30
 8002014:	2803      	cmp	r0, #3
 8002016:	d102      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8002018:	48a4      	ldr	r0, [pc, #656]	; (80022ac <__iar_annotation$$branch+0x3c>)
 800201a:	85b0      	strh	r0, [r6, #44]	; 0x2c
 800201c:	4ca4      	ldr	r4, [pc, #656]	; (80022b0 <__iar_annotation$$branch+0x40>)
 800201e:	8c70      	ldrh	r0, [r6, #34]	; 0x22
 8002020:	2180      	movs	r1, #128	; 0x80
 8002022:	0209      	lsls	r1, r1, #8
 8002024:	4288      	cmp	r0, r1
 8002026:	d000      	beq.n	800202a <__iar_annotation$$branch+0x1f8>
 8002028:	e670      	b.n	8001d0c <__iar_annotation$$branch>
 800202a:	2400      	movs	r4, #0
 800202c:	8474      	strh	r4, [r6, #34]	; 0x22
 800202e:	e11f      	b.n	8002270 <__iar_annotation$$branch>
 8002030:	000081f4 	.word	0x000081f4
 8002034:	7b69      	ldrb	r1, [r5, #13]
 8002036:	22fc      	movs	r2, #252	; 0xfc
 8002038:	400a      	ands	r2, r1
 800203a:	736a      	strb	r2, [r5, #13]
 800203c:	686a      	ldr	r2, [r5, #4]
 800203e:	2110      	movs	r1, #16
 8002040:	6813      	ldr	r3, [r2, #0]
 8002042:	430b      	orrs	r3, r1
 8002044:	6013      	str	r3, [r2, #0]
 8002046:	2200      	movs	r2, #0
 8002048:	82ea      	strh	r2, [r5, #22]
 800204a:	686a      	ldr	r2, [r5, #4]
 800204c:	7853      	ldrb	r3, [r2, #1]
 800204e:	278f      	movs	r7, #143	; 0x8f
 8002050:	401f      	ands	r7, r3
 8002052:	4339      	orrs	r1, r7
 8002054:	7051      	strb	r1, [r2, #1]
 8002056:	2800      	cmp	r0, #0
 8002058:	d009      	beq.n	800206e <__iar_annotation$$branch+0x23c>
 800205a:	2000      	movs	r0, #0
 800205c:	9000      	str	r0, [sp, #0]
 800205e:	2300      	movs	r3, #0
 8002060:	2256      	movs	r2, #86	; 0x56
 8002062:	7b28      	ldrb	r0, [r5, #12]
 8002064:	07c1      	lsls	r1, r0, #31
 8002066:	0fc9      	lsrs	r1, r1, #31
 8002068:	2009      	movs	r0, #9
 800206a:	9f01      	ldr	r7, [sp, #4]
 800206c:	47b8      	blx	r7
 800206e:	2156      	movs	r1, #86	; 0x56
 8002070:	7b2a      	ldrb	r2, [r5, #12]
 8002072:	07d0      	lsls	r0, r2, #31
 8002074:	0fc0      	lsrs	r0, r0, #31
 8002076:	68aa      	ldr	r2, [r5, #8]
 8002078:	68d2      	ldr	r2, [r2, #12]
 800207a:	4790      	blx	r2
 800207c:	2700      	movs	r7, #0
 800207e:	7037      	strb	r7, [r6, #0]
 8002080:	7d28      	ldrb	r0, [r5, #20]
 8002082:	2803      	cmp	r0, #3
 8002084:	d302      	bcc.n	800208c <__iar_annotation$$branch+0x25a>
 8002086:	752f      	strb	r7, [r5, #20]
 8002088:	7137      	strb	r7, [r6, #4]
 800208a:	e3ab      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800208c:	1c40      	adds	r0, r0, #1
 800208e:	7528      	strb	r0, [r5, #20]
 8002090:	0028      	movs	r0, r5
 8002092:	f001 fc1b 	bl	80038cc <PE_Send_HARDRESET>
 8002096:	2101      	movs	r1, #1
 8002098:	4668      	mov	r0, sp
 800209a:	7b40      	ldrb	r0, [r0, #13]
 800209c:	f002 f877 	bl	800418e <PE_Reset>
 80020a0:	6868      	ldr	r0, [r5, #4]
 80020a2:	6801      	ldr	r1, [r0, #0]
 80020a4:	2210      	movs	r2, #16
 80020a6:	430a      	orrs	r2, r1
 80020a8:	6002      	str	r2, [r0, #0]
 80020aa:	4882      	ldr	r0, [pc, #520]	; (80022b4 <__iar_annotation$$branch+0x44>)
 80020ac:	8270      	strh	r0, [r6, #18]
 80020ae:	209b      	movs	r0, #155	; 0x9b
 80020b0:	7130      	strb	r0, [r6, #4]
 80020b2:	e38d      	b.n	80027d0 <__iar_annotation$$branch+0x280>
 80020b4:	68e8      	ldr	r0, [r5, #12]
 80020b6:	4a80      	ldr	r2, [pc, #512]	; (80022b8 <__iar_annotation$$branch+0x48>)
 80020b8:	4002      	ands	r2, r0
 80020ba:	60ea      	str	r2, [r5, #12]
 80020bc:	2401      	movs	r4, #1
 80020be:	6868      	ldr	r0, [r5, #4]
 80020c0:	6800      	ldr	r0, [r0, #0]
 80020c2:	0c80      	lsrs	r0, r0, #18
 80020c4:	4020      	ands	r0, r4
 80020c6:	d007      	beq.n	80020d8 <__iar_annotation$$branch+0x2a6>
 80020c8:	68a8      	ldr	r0, [r5, #8]
 80020ca:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80020cc:	2b00      	cmp	r3, #0
 80020ce:	d003      	beq.n	80020d8 <__iar_annotation$$branch+0x2a6>
 80020d0:	2100      	movs	r1, #0
 80020d2:	2001      	movs	r0, #1
 80020d4:	4010      	ands	r0, r2
 80020d6:	4798      	blx	r3
 80020d8:	4f73      	ldr	r7, [pc, #460]	; (80022a8 <__iar_annotation$$branch+0x38>)
 80020da:	7838      	ldrb	r0, [r7, #0]
 80020dc:	0780      	lsls	r0, r0, #30
 80020de:	d509      	bpl.n	80020f4 <__iar_annotation$$branch+0x2c2>
 80020e0:	2000      	movs	r0, #0
 80020e2:	9000      	str	r0, [sp, #0]
 80020e4:	2300      	movs	r3, #0
 80020e6:	221d      	movs	r2, #29
 80020e8:	68e8      	ldr	r0, [r5, #12]
 80020ea:	2101      	movs	r1, #1
 80020ec:	4001      	ands	r1, r0
 80020ee:	2009      	movs	r0, #9
 80020f0:	68ff      	ldr	r7, [r7, #12]
 80020f2:	47b8      	blx	r7
 80020f4:	211d      	movs	r1, #29
 80020f6:	68e8      	ldr	r0, [r5, #12]
 80020f8:	4004      	ands	r4, r0
 80020fa:	0020      	movs	r0, r4
 80020fc:	68aa      	ldr	r2, [r5, #8]
 80020fe:	68d2      	ldr	r2, [r2, #12]
 8002100:	4790      	blx	r2
 8002102:	2101      	movs	r1, #1
 8002104:	4668      	mov	r0, sp
 8002106:	7b40      	ldrb	r0, [r0, #13]
 8002108:	f002 f841 	bl	800418e <PE_Reset>
 800210c:	6868      	ldr	r0, [r5, #4]
 800210e:	6801      	ldr	r1, [r0, #0]
 8002110:	2210      	movs	r2, #16
 8002112:	430a      	orrs	r2, r1
 8002114:	6002      	str	r2, [r0, #0]
 8002116:	4867      	ldr	r0, [pc, #412]	; (80022b4 <__iar_annotation$$branch+0x44>)
 8002118:	8270      	strh	r0, [r6, #18]
 800211a:	209b      	movs	r0, #155	; 0x9b
 800211c:	e357      	b.n	80027ce <__iar_annotation$$branch+0x27e>
 800211e:	68a8      	ldr	r0, [r5, #8]
 8002120:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8002122:	2a00      	cmp	r2, #0
 8002124:	d005      	beq.n	8002132 <__iar_annotation$$branch+0x300>
 8002126:	2100      	movs	r1, #0
 8002128:	4668      	mov	r0, sp
 800212a:	7b40      	ldrb	r0, [r0, #13]
 800212c:	4790      	blx	r2
 800212e:	2801      	cmp	r0, #1
 8002130:	d004      	beq.n	800213c <__iar_annotation$$branch+0x30a>
 8002132:	8a70      	ldrh	r0, [r6, #18]
 8002134:	03a1      	lsls	r1, r4, #14
 8002136:	4288      	cmp	r0, r1
 8002138:	d000      	beq.n	800213c <__iar_annotation$$branch+0x30a>
 800213a:	e353      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800213c:	485f      	ldr	r0, [pc, #380]	; (80022bc <__iar_annotation$$branch+0x4c>)
 800213e:	8270      	strh	r0, [r6, #18]
 8002140:	2040      	movs	r0, #64	; 0x40
 8002142:	7130      	strb	r0, [r6, #4]
 8002144:	2400      	movs	r4, #0
 8002146:	4f58      	ldr	r7, [pc, #352]	; (80022a8 <__iar_annotation$$branch+0x38>)
 8002148:	7838      	ldrb	r0, [r7, #0]
 800214a:	0780      	lsls	r0, r0, #30
 800214c:	d508      	bpl.n	8002160 <__iar_annotation$$branch+0x32e>
 800214e:	9400      	str	r4, [sp, #0]
 8002150:	2300      	movs	r3, #0
 8002152:	2213      	movs	r2, #19
 8002154:	7b28      	ldrb	r0, [r5, #12]
 8002156:	07c1      	lsls	r1, r0, #31
 8002158:	0fc9      	lsrs	r1, r1, #31
 800215a:	2009      	movs	r0, #9
 800215c:	68ff      	ldr	r7, [r7, #12]
 800215e:	47b8      	blx	r7
 8002160:	2113      	movs	r1, #19
 8002162:	e377      	b.n	8002854 <__iar_annotation$$branch+0x304>
 8002164:	68a8      	ldr	r0, [r5, #8]
 8002166:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8002168:	2a00      	cmp	r2, #0
 800216a:	d012      	beq.n	8002192 <__iar_annotation$$branch+0x360>
 800216c:	2101      	movs	r1, #1
 800216e:	4668      	mov	r0, sp
 8002170:	7b40      	ldrb	r0, [r0, #13]
 8002172:	4790      	blx	r2
 8002174:	2801      	cmp	r0, #1
 8002176:	d10c      	bne.n	8002192 <__iar_annotation$$branch+0x360>
 8002178:	6868      	ldr	r0, [r5, #4]
 800217a:	6801      	ldr	r1, [r0, #0]
 800217c:	2210      	movs	r2, #16
 800217e:	4391      	bics	r1, r2
 8002180:	6001      	str	r1, [r0, #0]
 8002182:	2000      	movs	r0, #0
 8002184:	8270      	strh	r0, [r6, #18]
 8002186:	484e      	ldr	r0, [pc, #312]	; (80022c0 <__iar_annotation$$branch+0x50>)
 8002188:	84f0      	strh	r0, [r6, #38]	; 0x26
 800218a:	24fa      	movs	r4, #250	; 0xfa
 800218c:	0064      	lsls	r4, r4, #1
 800218e:	2043      	movs	r0, #67	; 0x43
 8002190:	7130      	strb	r0, [r6, #4]
 8002192:	8a70      	ldrh	r0, [r6, #18]
 8002194:	2180      	movs	r1, #128	; 0x80
 8002196:	0209      	lsls	r1, r1, #8
 8002198:	4288      	cmp	r0, r1
 800219a:	d000      	beq.n	800219e <__iar_annotation$$branch+0x36c>
 800219c:	e322      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800219e:	2000      	movs	r0, #0
 80021a0:	8270      	strh	r0, [r6, #18]
 80021a2:	6868      	ldr	r0, [r5, #4]
 80021a4:	6801      	ldr	r1, [r0, #0]
 80021a6:	2210      	movs	r2, #16
 80021a8:	4391      	bics	r1, r2
 80021aa:	6001      	str	r1, [r0, #0]
 80021ac:	e060      	b.n	8002270 <__iar_annotation$$branch>
 80021ae:	0028      	movs	r0, r5
 80021b0:	f001 fbc5 	bl	800393e <PE_PerformSoftReset>
 80021b4:	2000      	movs	r0, #0
 80021b6:	9000      	str	r0, [sp, #0]
 80021b8:	2303      	movs	r3, #3
 80021ba:	2203      	movs	r2, #3
 80021bc:	2100      	movs	r1, #0
 80021be:	0028      	movs	r0, r5
 80021c0:	f001 fad7 	bl	8003772 <PE_Send_CtrlMessage>
 80021c4:	4f38      	ldr	r7, [pc, #224]	; (80022a8 <__iar_annotation$$branch+0x38>)
 80021c6:	7838      	ldrb	r0, [r7, #0]
 80021c8:	0780      	lsls	r0, r0, #30
 80021ca:	d509      	bpl.n	80021e0 <__iar_annotation$$branch+0x3ae>
 80021cc:	2000      	movs	r0, #0
 80021ce:	9000      	str	r0, [sp, #0]
 80021d0:	2300      	movs	r3, #0
 80021d2:	222f      	movs	r2, #47	; 0x2f
 80021d4:	7b28      	ldrb	r0, [r5, #12]
 80021d6:	07c1      	lsls	r1, r0, #31
 80021d8:	0fc9      	lsrs	r1, r1, #31
 80021da:	2009      	movs	r0, #9
 80021dc:	68ff      	ldr	r7, [r7, #12]
 80021de:	47b8      	blx	r7
 80021e0:	212f      	movs	r1, #47	; 0x2f
 80021e2:	e337      	b.n	8002854 <__iar_annotation$$branch+0x304>
 80021e4:	6868      	ldr	r0, [r5, #4]
 80021e6:	7840      	ldrb	r0, [r0, #1]
 80021e8:	0640      	lsls	r0, r0, #25
 80021ea:	0f40      	lsrs	r0, r0, #29
 80021ec:	2804      	cmp	r0, #4
 80021ee:	d101      	bne.n	80021f4 <__iar_annotation$$branch+0x3c2>
 80021f0:	200f      	movs	r0, #15
 80021f2:	e2ec      	b.n	80027ce <__iar_annotation$$branch+0x27e>
 80021f4:	2000      	movs	r0, #0
 80021f6:	9000      	str	r0, [sp, #0]
 80021f8:	2350      	movs	r3, #80	; 0x50
 80021fa:	220d      	movs	r2, #13
 80021fc:	2100      	movs	r1, #0
 80021fe:	0028      	movs	r0, r5
 8002200:	f001 fab7 	bl	8003772 <PE_Send_CtrlMessage>
 8002204:	2800      	cmp	r0, #0
 8002206:	d000      	beq.n	800220a <__iar_annotation$$branch+0x3d8>
 8002208:	e2ec      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800220a:	2003      	movs	r0, #3
 800220c:	82e8      	strh	r0, [r5, #22]
 800220e:	8337      	strh	r7, [r6, #24]
 8002210:	241a      	movs	r4, #26
 8002212:	4f25      	ldr	r7, [pc, #148]	; (80022a8 <__iar_annotation$$branch+0x38>)
 8002214:	7838      	ldrb	r0, [r7, #0]
 8002216:	0780      	lsls	r0, r0, #30
 8002218:	d509      	bpl.n	800222e <__iar_annotation$$branch+0x3fc>
 800221a:	2000      	movs	r0, #0
 800221c:	9000      	str	r0, [sp, #0]
 800221e:	2300      	movs	r3, #0
 8002220:	222e      	movs	r2, #46	; 0x2e
 8002222:	7b28      	ldrb	r0, [r5, #12]
 8002224:	07c1      	lsls	r1, r0, #31
 8002226:	0fc9      	lsrs	r1, r1, #31
 8002228:	2009      	movs	r0, #9
 800222a:	68ff      	ldr	r7, [r7, #12]
 800222c:	47b8      	blx	r7
 800222e:	212e      	movs	r1, #46	; 0x2e
 8002230:	e310      	b.n	8002854 <__iar_annotation$$branch+0x304>
 8002232:	2911      	cmp	r1, #17
 8002234:	d115      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 8002236:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002238:	0bc0      	lsrs	r0, r0, #15
 800223a:	d112      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 800223c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800223e:	0b00      	lsrs	r0, r0, #12
 8002240:	0740      	lsls	r0, r0, #29
 8002242:	d10e      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 8002244:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002246:	06c0      	lsls	r0, r0, #27
 8002248:	0ec0      	lsrs	r0, r0, #27
 800224a:	2803      	cmp	r0, #3
 800224c:	d109      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 800224e:	2000      	movs	r0, #0
 8002250:	8330      	strh	r0, [r6, #24]
 8002252:	0028      	movs	r0, r5
 8002254:	f001 fb73 	bl	800393e <PE_PerformSoftReset>
 8002258:	2003      	movs	r0, #3
 800225a:	7130      	strb	r0, [r6, #4]
 800225c:	2014      	movs	r0, #20
 800225e:	4669      	mov	r1, sp
 8002260:	7308      	strb	r0, [r1, #12]
 8002262:	8b30      	ldrh	r0, [r6, #24]
 8002264:	03a1      	lsls	r1, r4, #14
 8002266:	4288      	cmp	r0, r1
 8002268:	d000      	beq.n	800226c <__iar_annotation$$branch+0x43a>
 800226a:	e2bb      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800226c:	2000      	movs	r0, #0
 800226e:	8330      	strh	r0, [r6, #24]

08002270 <__iar_annotation$$branch>:
 8002270:	f000 fcd3 	bl	8002c1a <__iar_annotation$$branch+0x6ca>
 8002274:	6868      	ldr	r0, [r5, #4]
 8002276:	7840      	ldrb	r0, [r0, #1]
 8002278:	0640      	lsls	r0, r0, #25
 800227a:	0f40      	lsrs	r0, r0, #29
 800227c:	2803      	cmp	r0, #3
 800227e:	d121      	bne.n	80022c4 <__iar_annotation$$branch+0x54>
 8002280:	2103      	movs	r1, #3
 8002282:	0028      	movs	r0, r5
 8002284:	f001 fa5a 	bl	800373c <PE_Send_SNKCapabilities>
 8002288:	4f07      	ldr	r7, [pc, #28]	; (80022a8 <__iar_annotation$$branch+0x38>)
 800228a:	7838      	ldrb	r0, [r7, #0]
 800228c:	0780      	lsls	r0, r0, #30
 800228e:	d509      	bpl.n	80022a4 <__iar_annotation$$branch+0x34>
 8002290:	2000      	movs	r0, #0
 8002292:	9000      	str	r0, [sp, #0]
 8002294:	2300      	movs	r3, #0
 8002296:	220a      	movs	r2, #10
 8002298:	7b28      	ldrb	r0, [r5, #12]
 800229a:	07c1      	lsls	r1, r0, #31
 800229c:	0fc9      	lsrs	r1, r1, #31
 800229e:	2009      	movs	r0, #9
 80022a0:	68ff      	ldr	r7, [r7, #12]
 80022a2:	47b8      	blx	r7
 80022a4:	210a      	movs	r1, #10
 80022a6:	e2d5      	b.n	8002854 <__iar_annotation$$branch+0x304>
 80022a8:	200019e8 	.word	0x200019e8
 80022ac:	0000a328 	.word	0x0000a328
 80022b0:	00002328 	.word	0x00002328
 80022b4:	0000828a 	.word	0x0000828a
 80022b8:	fffff7ff 	.word	0xfffff7ff
 80022bc:	000084fb 	.word	0x000084fb
 80022c0:	000081f4 	.word	0x000081f4
 80022c4:	2000      	movs	r0, #0
 80022c6:	9000      	str	r0, [sp, #0]
 80022c8:	2303      	movs	r3, #3
 80022ca:	2204      	movs	r2, #4
 80022cc:	2100      	movs	r1, #0
 80022ce:	0028      	movs	r0, r5
 80022d0:	f001 fa4f 	bl	8003772 <PE_Send_CtrlMessage>
 80022d4:	e286      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80022d6:	9400      	str	r4, [sp, #0]
 80022d8:	2343      	movs	r3, #67	; 0x43
 80022da:	2207      	movs	r2, #7
 80022dc:	2100      	movs	r1, #0
 80022de:	0028      	movs	r0, r5
 80022e0:	f001 fa47 	bl	8003772 <PE_Send_CtrlMessage>
 80022e4:	2800      	cmp	r0, #0
 80022e6:	d000      	beq.n	80022ea <__iar_annotation$$branch+0x7a>
 80022e8:	e27c      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80022ea:	2006      	movs	r0, #6
 80022ec:	82e8      	strh	r0, [r5, #22]
 80022ee:	8337      	strh	r7, [r6, #24]
 80022f0:	241a      	movs	r4, #26
 80022f2:	4fbf      	ldr	r7, [pc, #764]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 80022f4:	7838      	ldrb	r0, [r7, #0]
 80022f6:	0780      	lsls	r0, r0, #30
 80022f8:	d509      	bpl.n	800230e <__iar_annotation$$branch+0x9e>
 80022fa:	2000      	movs	r0, #0
 80022fc:	9000      	str	r0, [sp, #0]
 80022fe:	2300      	movs	r3, #0
 8002300:	220b      	movs	r2, #11
 8002302:	7b28      	ldrb	r0, [r5, #12]
 8002304:	07c1      	lsls	r1, r0, #31
 8002306:	0fc9      	lsrs	r1, r1, #31
 8002308:	2009      	movs	r0, #9
 800230a:	68ff      	ldr	r7, [r7, #12]
 800230c:	47b8      	blx	r7
 800230e:	210b      	movs	r1, #11
 8002310:	e2a0      	b.n	8002854 <__iar_annotation$$branch+0x304>
 8002312:	2914      	cmp	r1, #20
 8002314:	d00e      	beq.n	8002334 <__iar_annotation$$branch+0xc4>
 8002316:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002318:	0bc0      	lsrs	r0, r0, #15
 800231a:	d10b      	bne.n	8002334 <__iar_annotation$$branch+0xc4>
 800231c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800231e:	0b00      	lsrs	r0, r0, #12
 8002320:	0740      	lsls	r0, r0, #29
 8002322:	d007      	beq.n	8002334 <__iar_annotation$$branch+0xc4>
 8002324:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002326:	06c0      	lsls	r0, r0, #27
 8002328:	0ec0      	lsrs	r0, r0, #27
 800232a:	2803      	cmp	r0, #3
 800232c:	d102      	bne.n	8002334 <__iar_annotation$$branch+0xc4>
 800232e:	2014      	movs	r0, #20
 8002330:	4669      	mov	r1, sp
 8002332:	7308      	strb	r0, [r1, #12]
 8002334:	2011      	movs	r0, #17

08002336 <__iar_annotation$$branch>:
 8002336:	f000 fd1d 	bl	8002d74 <__iar_annotation$$branch+0x824>
 800233a:	2011      	movs	r0, #17
 800233c:	82e8      	strh	r0, [r5, #22]
 800233e:	2105      	movs	r1, #5
 8002340:	7b2a      	ldrb	r2, [r5, #12]
 8002342:	07d0      	lsls	r0, r2, #31
 8002344:	0fc0      	lsrs	r0, r0, #31
 8002346:	f003 f874 	bl	8005432 <USBDPD_PRL_BistCarrierEyeMode>
 800234a:	205d      	movs	r0, #93	; 0x5d
 800234c:	7130      	strb	r0, [r6, #4]
 800234e:	48a9      	ldr	r0, [pc, #676]	; (80025f4 <__iar_annotation$$branch+0xa4>)
 8002350:	8530      	strh	r0, [r6, #40]	; 0x28
 8002352:	243a      	movs	r4, #58	; 0x3a
 8002354:	e246      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002356:	8d30      	ldrh	r0, [r6, #40]	; 0x28
 8002358:	03a1      	lsls	r1, r4, #14
 800235a:	4288      	cmp	r0, r1
 800235c:	d000      	beq.n	8002360 <__iar_annotation$$branch+0x2a>
 800235e:	e241      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002360:	2105      	movs	r1, #5
 8002362:	7b2a      	ldrb	r2, [r5, #12]
 8002364:	07d0      	lsls	r0, r2, #31
 8002366:	0fc0      	lsrs	r0, r0, #31
 8002368:	f003 f86b 	bl	8005442 <USBDPD_PRL_BistCarrierEyeModeExit>
 800236c:	2000      	movs	r0, #0
 800236e:	8530      	strh	r0, [r6, #40]	; 0x28

08002370 <__iar_annotation$$branch>:
 8002370:	f000 fda5 	bl	8002ebe <__iar_annotation$$branch+0x96e>
 8002374:	2911      	cmp	r1, #17
 8002376:	d000      	beq.n	800237a <__iar_annotation$$branch+0xa>
 8002378:	e234      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800237a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800237c:	0bc9      	lsrs	r1, r1, #15
 800237e:	d000      	beq.n	8002382 <__iar_annotation$$branch+0x12>
 8002380:	e230      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002382:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002384:	0b09      	lsrs	r1, r1, #12
 8002386:	0749      	lsls	r1, r1, #29
 8002388:	d000      	beq.n	800238c <__iar_annotation$$branch+0x1c>
 800238a:	e22b      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800238c:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800238e:	06c9      	lsls	r1, r1, #27
 8002390:	0ec9      	lsrs	r1, r1, #27
 8002392:	2906      	cmp	r1, #6
 8002394:	d000      	beq.n	8002398 <__iar_annotation$$branch+0x28>
 8002396:	e225      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002398:	2800      	cmp	r0, #0
 800239a:	d009      	beq.n	80023b0 <__iar_annotation$$branch+0x40>
 800239c:	2000      	movs	r0, #0
 800239e:	9000      	str	r0, [sp, #0]
 80023a0:	2300      	movs	r3, #0
 80023a2:	222a      	movs	r2, #42	; 0x2a
 80023a4:	7b28      	ldrb	r0, [r5, #12]
 80023a6:	07c1      	lsls	r1, r0, #31
 80023a8:	0fc9      	lsrs	r1, r1, #31
 80023aa:	2009      	movs	r0, #9
 80023ac:	9f01      	ldr	r7, [sp, #4]
 80023ae:	47b8      	blx	r7
 80023b0:	212a      	movs	r1, #42	; 0x2a
 80023b2:	7b2a      	ldrb	r2, [r5, #12]
 80023b4:	07d0      	lsls	r0, r2, #31
 80023b6:	0fc0      	lsrs	r0, r0, #31
 80023b8:	68aa      	ldr	r2, [r5, #8]
 80023ba:	68d2      	ldr	r2, [r2, #12]
 80023bc:	4790      	blx	r2

080023be <__iar_annotation$$branch>:
 80023be:	f000 fceb 	bl	8002d98 <__iar_annotation$$branch+0x848>
 80023c2:	9400      	str	r4, [sp, #0]
 80023c4:	2360      	movs	r3, #96	; 0x60
 80023c6:	2208      	movs	r2, #8
 80023c8:	2100      	movs	r1, #0
 80023ca:	0028      	movs	r0, r5
 80023cc:	f001 f9d1 	bl	8003772 <PE_Send_CtrlMessage>
 80023d0:	2800      	cmp	r0, #0
 80023d2:	d000      	beq.n	80023d6 <__iar_annotation$$branch+0x18>
 80023d4:	e206      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80023d6:	2007      	movs	r0, #7
 80023d8:	82e8      	strh	r0, [r5, #22]
 80023da:	8337      	strh	r7, [r6, #24]
 80023dc:	241a      	movs	r4, #26
 80023de:	4f84      	ldr	r7, [pc, #528]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 80023e0:	7838      	ldrb	r0, [r7, #0]
 80023e2:	0780      	lsls	r0, r0, #30
 80023e4:	d509      	bpl.n	80023fa <__iar_annotation$$branch+0x3c>
 80023e6:	2000      	movs	r0, #0
 80023e8:	9000      	str	r0, [sp, #0]
 80023ea:	2300      	movs	r3, #0
 80023ec:	2205      	movs	r2, #5
 80023ee:	7b28      	ldrb	r0, [r5, #12]
 80023f0:	07c1      	lsls	r1, r0, #31
 80023f2:	0fc9      	lsrs	r1, r1, #31
 80023f4:	2009      	movs	r0, #9
 80023f6:	68ff      	ldr	r7, [r7, #12]
 80023f8:	47b8      	blx	r7
 80023fa:	2105      	movs	r1, #5
 80023fc:	e22a      	b.n	8002854 <__iar_annotation$$branch+0x304>
 80023fe:	2911      	cmp	r1, #17
 8002400:	d15e      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 8002402:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002404:	0bc0      	lsrs	r0, r0, #15
 8002406:	d133      	bne.n	8002470 <__iar_annotation$$branch+0xb2>
 8002408:	2007      	movs	r0, #7
 800240a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800240c:	0b09      	lsrs	r1, r1, #12
 800240e:	4201      	tst	r1, r0
 8002410:	d02e      	beq.n	8002470 <__iar_annotation$$branch+0xb2>
 8002412:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002414:	06c9      	lsls	r1, r1, #27
 8002416:	0ec9      	lsrs	r1, r1, #27
 8002418:	2904      	cmp	r1, #4
 800241a:	d129      	bne.n	8002470 <__iar_annotation$$branch+0xb2>
 800241c:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800241e:	0b09      	lsrs	r1, r1, #12
 8002420:	4008      	ands	r0, r1
 8002422:	0083      	lsls	r3, r0, #2
 8002424:	209e      	movs	r0, #158	; 0x9e
 8002426:	0040      	lsls	r0, r0, #1
 8002428:	182a      	adds	r2, r5, r0
 800242a:	2105      	movs	r1, #5
 800242c:	7b2f      	ldrb	r7, [r5, #12]
 800242e:	07f8      	lsls	r0, r7, #31
 8002430:	0fc0      	lsrs	r0, r0, #31
 8002432:	68af      	ldr	r7, [r5, #8]
 8002434:	69ff      	ldr	r7, [r7, #28]
 8002436:	47b8      	blx	r7
 8002438:	2000      	movs	r0, #0
 800243a:	8330      	strh	r0, [r6, #24]
 800243c:	2014      	movs	r0, #20
 800243e:	4669      	mov	r1, sp
 8002440:	7308      	strb	r0, [r1, #12]
 8002442:	2003      	movs	r0, #3
 8002444:	7130      	strb	r0, [r6, #4]
 8002446:	4f6a      	ldr	r7, [pc, #424]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 8002448:	7838      	ldrb	r0, [r7, #0]
 800244a:	0780      	lsls	r0, r0, #30
 800244c:	d509      	bpl.n	8002462 <__iar_annotation$$branch+0xa4>
 800244e:	2000      	movs	r0, #0
 8002450:	9000      	str	r0, [sp, #0]
 8002452:	2300      	movs	r3, #0
 8002454:	2207      	movs	r2, #7
 8002456:	7b28      	ldrb	r0, [r5, #12]
 8002458:	07c1      	lsls	r1, r0, #31
 800245a:	0fc9      	lsrs	r1, r1, #31
 800245c:	2009      	movs	r0, #9
 800245e:	68ff      	ldr	r7, [r7, #12]
 8002460:	47b8      	blx	r7
 8002462:	2107      	movs	r1, #7
 8002464:	7b2a      	ldrb	r2, [r5, #12]
 8002466:	07d0      	lsls	r0, r2, #31
 8002468:	0fc0      	lsrs	r0, r0, #31
 800246a:	68aa      	ldr	r2, [r5, #8]
 800246c:	68d2      	ldr	r2, [r2, #12]
 800246e:	4790      	blx	r2
 8002470:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002472:	0bc0      	lsrs	r0, r0, #15
 8002474:	d124      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 8002476:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002478:	0b00      	lsrs	r0, r0, #12
 800247a:	0740      	lsls	r0, r0, #29
 800247c:	d120      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 800247e:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002480:	06c0      	lsls	r0, r0, #27
 8002482:	0ec0      	lsrs	r0, r0, #27
 8002484:	2804      	cmp	r0, #4
 8002486:	d11b      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 8002488:	2000      	movs	r0, #0
 800248a:	8330      	strh	r0, [r6, #24]
 800248c:	2014      	movs	r0, #20
 800248e:	4669      	mov	r1, sp
 8002490:	7308      	strb	r0, [r1, #12]
 8002492:	2003      	movs	r0, #3
 8002494:	7130      	strb	r0, [r6, #4]
 8002496:	4f56      	ldr	r7, [pc, #344]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 8002498:	7838      	ldrb	r0, [r7, #0]
 800249a:	0780      	lsls	r0, r0, #30
 800249c:	d509      	bpl.n	80024b2 <__iar_annotation$$branch+0xf4>
 800249e:	2000      	movs	r0, #0
 80024a0:	9000      	str	r0, [sp, #0]
 80024a2:	2300      	movs	r3, #0
 80024a4:	2208      	movs	r2, #8
 80024a6:	7b28      	ldrb	r0, [r5, #12]
 80024a8:	07c1      	lsls	r1, r0, #31
 80024aa:	0fc9      	lsrs	r1, r1, #31
 80024ac:	2009      	movs	r0, #9
 80024ae:	68ff      	ldr	r7, [r7, #12]
 80024b0:	47b8      	blx	r7
 80024b2:	2108      	movs	r1, #8
 80024b4:	7b2a      	ldrb	r2, [r5, #12]
 80024b6:	07d0      	lsls	r0, r2, #31
 80024b8:	0fc0      	lsrs	r0, r0, #31
 80024ba:	68aa      	ldr	r2, [r5, #8]
 80024bc:	68d2      	ldr	r2, [r2, #12]
 80024be:	4790      	blx	r2
 80024c0:	8b30      	ldrh	r0, [r6, #24]
 80024c2:	03a1      	lsls	r1, r4, #14
 80024c4:	4288      	cmp	r0, r1
 80024c6:	d000      	beq.n	80024ca <__iar_annotation$$branch>
 80024c8:	e18c      	b.n	80027e4 <__iar_annotation$$branch+0x294>

080024ca <__iar_annotation$$branch>:
 80024ca:	f000 fcf6 	bl	8002eba <__iar_annotation$$branch+0x96a>
 80024ce:	2000      	movs	r0, #0
 80024d0:	9000      	str	r0, [sp, #0]
 80024d2:	2303      	movs	r3, #3
 80024d4:	2204      	movs	r2, #4
 80024d6:	2100      	movs	r1, #0
 80024d8:	0028      	movs	r0, r5
 80024da:	f001 f94a 	bl	8003772 <PE_Send_CtrlMessage>
 80024de:	4844      	ldr	r0, [pc, #272]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 80024e0:	7800      	ldrb	r0, [r0, #0]
 80024e2:	0780      	lsls	r0, r0, #30
 80024e4:	d500      	bpl.n	80024e8 <__iar_annotation$$branch+0x1e>
 80024e6:	e1d5      	b.n	8002894 <__iar_annotation$$branch+0x344>
 80024e8:	e1df      	b.n	80028aa <__iar_annotation$$branch+0x35a>
 80024ea:	4943      	ldr	r1, [pc, #268]	; (80025f8 <__iar_annotation$$branch+0xa8>)
 80024ec:	84b1      	strh	r1, [r6, #36]	; 0x24
 80024ee:	2464      	movs	r4, #100	; 0x64
 80024f0:	2100      	movs	r1, #0
 80024f2:	82e9      	strh	r1, [r5, #22]
 80024f4:	2104      	movs	r1, #4
 80024f6:	7131      	strb	r1, [r6, #4]
 80024f8:	2800      	cmp	r0, #0
 80024fa:	d009      	beq.n	8002510 <__iar_annotation$$branch+0x46>
 80024fc:	2000      	movs	r0, #0
 80024fe:	9000      	str	r0, [sp, #0]
 8002500:	2300      	movs	r3, #0
 8002502:	221f      	movs	r2, #31
 8002504:	7b28      	ldrb	r0, [r5, #12]
 8002506:	07c1      	lsls	r1, r0, #31
 8002508:	0fc9      	lsrs	r1, r1, #31
 800250a:	2009      	movs	r0, #9
 800250c:	9f01      	ldr	r7, [sp, #4]
 800250e:	47b8      	blx	r7
 8002510:	211f      	movs	r1, #31
 8002512:	7b2a      	ldrb	r2, [r5, #12]
 8002514:	07d0      	lsls	r0, r2, #31
 8002516:	0fc0      	lsrs	r0, r0, #31
 8002518:	68aa      	ldr	r2, [r5, #8]
 800251a:	68d2      	ldr	r2, [r2, #12]
 800251c:	4790      	blx	r2
 800251e:	4668      	mov	r0, sp
 8002520:	7b00      	ldrb	r0, [r0, #12]
 8002522:	2814      	cmp	r0, #20
 8002524:	d016      	beq.n	8002554 <__iar_annotation$$branch+0x4>
 8002526:	79b0      	ldrb	r0, [r6, #6]
 8002528:	71f0      	strb	r0, [r6, #7]
 800252a:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800252c:	0bc0      	lsrs	r0, r0, #15
 800252e:	d001      	beq.n	8002534 <__iar_annotation$$branch+0x4>

08002530 <__iar_annotation$$branch>:
 8002530:	f000 fcad 	bl	8002e8e <__iar_annotation$$branch+0x93e>
 8002534:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002536:	0bc0      	lsrs	r0, r0, #15
 8002538:	d107      	bne.n	800254a <__iar_annotation$$branch+0x1a>
 800253a:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800253c:	0b00      	lsrs	r0, r0, #12
 800253e:	0740      	lsls	r0, r0, #29
 8002540:	d103      	bne.n	800254a <__iar_annotation$$branch+0x1a>
 8002542:	0028      	movs	r0, r5
 8002544:	f001 fa9e 	bl	8003a84 <PE_Check_ControlMessage>
 8002548:	e002      	b.n	8002550 <__iar_annotation$$branch>
 800254a:	0028      	movs	r0, r5
 800254c:	f001 fc36 	bl	8003dbc <PE_Check_DataMessage>

08002550 <__iar_annotation$$branch>:
 8002550:	f000 fca0 	bl	8002e94 <__iar_annotation$$branch+0x944>
 8002554:	68e8      	ldr	r0, [r5, #12]
 8002556:	0b00      	lsrs	r0, r0, #12
 8002558:	2180      	movs	r1, #128	; 0x80
 800255a:	0209      	lsls	r1, r1, #8
 800255c:	240f      	movs	r4, #15
 800255e:	2800      	cmp	r0, #0
 8002560:	d01e      	beq.n	80025a0 <__iar_annotation$$branch+0x50>
 8002562:	8a32      	ldrh	r2, [r6, #16]
 8002564:	428a      	cmp	r2, r1
 8002566:	d104      	bne.n	8002572 <__iar_annotation$$branch+0x22>
 8002568:	7134      	strb	r4, [r6, #4]
 800256a:	7d28      	ldrb	r0, [r5, #20]
 800256c:	1c40      	adds	r0, r0, #1
 800256e:	7528      	strb	r0, [r5, #20]
 8002570:	e12e      	b.n	80027d0 <__iar_annotation$$branch+0x280>
 8002572:	6b72      	ldr	r2, [r6, #52]	; 0x34
 8002574:	0512      	lsls	r2, r2, #20
 8002576:	0d12      	lsrs	r2, r2, #20
 8002578:	2307      	movs	r3, #7
 800257a:	8e34      	ldrh	r4, [r6, #48]	; 0x30
 800257c:	0a67      	lsrs	r7, r4, #9
 800257e:	2407      	movs	r4, #7
 8002580:	403c      	ands	r4, r7
 8002582:	1824      	adds	r4, r4, r0
 8002584:	2733      	movs	r7, #51	; 0x33
 8002586:	437c      	muls	r4, r7
 8002588:	18a4      	adds	r4, r4, r2
 800258a:	4321      	orrs	r1, r4
 800258c:	9c04      	ldr	r4, [sp, #16]
 800258e:	8021      	strh	r1, [r4, #0]
 8002590:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002592:	0a49      	lsrs	r1, r1, #9
 8002594:	400b      	ands	r3, r1
 8002596:	1818      	adds	r0, r3, r0
 8002598:	2133      	movs	r1, #51	; 0x33
 800259a:	4348      	muls	r0, r1
 800259c:	1884      	adds	r4, r0, r2
 800259e:	e121      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80025a0:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 80025a2:	4288      	cmp	r0, r1
 80025a4:	d103      	bne.n	80025ae <__iar_annotation$$branch+0x5e>
 80025a6:	2400      	movs	r4, #0
 80025a8:	85b4      	strh	r4, [r6, #44]	; 0x2c
 80025aa:	2044      	movs	r0, #68	; 0x44
 80025ac:	e1b0      	b.n	8002910 <__iar_annotation$$branch+0x3c0>
 80025ae:	7830      	ldrb	r0, [r6, #0]
 80025b0:	2800      	cmp	r0, #0
 80025b2:	d014      	beq.n	80025de <__iar_annotation$$branch+0x8e>
 80025b4:	6868      	ldr	r0, [r5, #4]
 80025b6:	7800      	ldrb	r0, [r0, #0]
 80025b8:	0781      	lsls	r1, r0, #30
 80025ba:	0f89      	lsrs	r1, r1, #30
 80025bc:	2901      	cmp	r1, #1
 80025be:	d007      	beq.n	80025d0 <__iar_annotation$$branch+0x80>
 80025c0:	2902      	cmp	r1, #2
 80025c2:	d10c      	bne.n	80025de <__iar_annotation$$branch+0x8e>
 80025c4:	4668      	mov	r0, sp
 80025c6:	7b40      	ldrb	r0, [r0, #13]
 80025c8:	f002 fcdf 	bl	8004f8a <USBPD_PRL_IsResistor_SinkTxOK>
 80025cc:	2801      	cmp	r0, #1
 80025ce:	d106      	bne.n	80025de <__iar_annotation$$branch+0x8e>
 80025d0:	7870      	ldrb	r0, [r6, #1]
 80025d2:	71f0      	strb	r0, [r6, #7]
 80025d4:	7830      	ldrb	r0, [r6, #0]
 80025d6:	7130      	strb	r0, [r6, #4]
 80025d8:	2400      	movs	r4, #0
 80025da:	7034      	strb	r4, [r6, #0]
 80025dc:	e102      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80025de:	48b4      	ldr	r0, [pc, #720]	; (80028b0 <__iar_annotation$$branch+0x360>)
 80025e0:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 80025e2:	4001      	ands	r1, r0
 80025e4:	2900      	cmp	r1, #0
 80025e6:	dd09      	ble.n	80025fc <__iar_annotation$$branch+0xac>
 80025e8:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 80025ea:	0004      	movs	r4, r0
 80025ec:	400c      	ands	r4, r1
 80025ee:	e0f9      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80025f0:	200019e8 	.word	0x200019e8
 80025f4:	0000803a 	.word	0x0000803a
 80025f8:	00008064 	.word	0x00008064
 80025fc:	7830      	ldrb	r0, [r6, #0]
 80025fe:	2800      	cmp	r0, #0
 8002600:	d000      	beq.n	8002604 <__iar_annotation$$branch+0xb4>
 8002602:	e0ef      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002604:	2400      	movs	r4, #0
 8002606:	43e4      	mvns	r4, r4
 8002608:	e0ec      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800260a:	4668      	mov	r0, sp
 800260c:	7b40      	ldrb	r0, [r0, #13]
 800260e:	68a9      	ldr	r1, [r5, #8]
 8002610:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
 8002612:	4788      	blx	r1
 8002614:	280a      	cmp	r0, #10
 8002616:	d145      	bne.n	80026a4 <__iar_annotation$$branch+0x154>
 8002618:	2000      	movs	r0, #0
 800261a:	9000      	str	r0, [sp, #0]
 800261c:	2303      	movs	r3, #3
 800261e:	2203      	movs	r2, #3
 8002620:	2100      	movs	r1, #0
 8002622:	0028      	movs	r0, r5
 8002624:	f001 f8a5 	bl	8003772 <PE_Send_CtrlMessage>
 8002628:	2800      	cmp	r0, #0
 800262a:	d000      	beq.n	800262e <__iar_annotation$$branch+0xde>
 800262c:	e0da      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800262e:	6868      	ldr	r0, [r5, #4]
 8002630:	7801      	ldrb	r1, [r0, #0]
 8002632:	08ca      	lsrs	r2, r1, #3
 8002634:	07d2      	lsls	r2, r2, #31
 8002636:	d412      	bmi.n	800265e <__iar_annotation$$branch+0x10e>
 8002638:	2208      	movs	r2, #8
 800263a:	430a      	orrs	r2, r1
 800263c:	7002      	strb	r2, [r0, #0]
 800263e:	4f9d      	ldr	r7, [pc, #628]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002640:	7838      	ldrb	r0, [r7, #0]
 8002642:	0780      	lsls	r0, r0, #30
 8002644:	d509      	bpl.n	800265a <__iar_annotation$$branch+0x10a>
 8002646:	2000      	movs	r0, #0
 8002648:	9000      	str	r0, [sp, #0]
 800264a:	2300      	movs	r3, #0
 800264c:	2224      	movs	r2, #36	; 0x24
 800264e:	7b28      	ldrb	r0, [r5, #12]
 8002650:	07c1      	lsls	r1, r0, #31
 8002652:	0fc9      	lsrs	r1, r1, #31
 8002654:	2009      	movs	r0, #9
 8002656:	68ff      	ldr	r7, [r7, #12]
 8002658:	47b8      	blx	r7
 800265a:	2124      	movs	r1, #36	; 0x24
 800265c:	e011      	b.n	8002682 <__iar_annotation$$branch+0x132>
 800265e:	22f7      	movs	r2, #247	; 0xf7
 8002660:	400a      	ands	r2, r1
 8002662:	7002      	strb	r2, [r0, #0]
 8002664:	4f93      	ldr	r7, [pc, #588]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002666:	7838      	ldrb	r0, [r7, #0]
 8002668:	0780      	lsls	r0, r0, #30
 800266a:	d509      	bpl.n	8002680 <__iar_annotation$$branch+0x130>
 800266c:	2000      	movs	r0, #0
 800266e:	9000      	str	r0, [sp, #0]
 8002670:	2300      	movs	r3, #0
 8002672:	2223      	movs	r2, #35	; 0x23
 8002674:	7b28      	ldrb	r0, [r5, #12]
 8002676:	07c1      	lsls	r1, r0, #31
 8002678:	0fc9      	lsrs	r1, r1, #31
 800267a:	2009      	movs	r0, #9
 800267c:	68ff      	ldr	r7, [r7, #12]
 800267e:	47b8      	blx	r7
 8002680:	2123      	movs	r1, #35	; 0x23
 8002682:	7b2a      	ldrb	r2, [r5, #12]
 8002684:	07d0      	lsls	r0, r2, #31
 8002686:	0fc0      	lsrs	r0, r0, #31
 8002688:	68aa      	ldr	r2, [r5, #8]
 800268a:	68d2      	ldr	r2, [r2, #12]
 800268c:	4790      	blx	r2
 800268e:	2001      	movs	r0, #1
 8002690:	6869      	ldr	r1, [r5, #4]
 8002692:	7809      	ldrb	r1, [r1, #0]
 8002694:	08ca      	lsrs	r2, r1, #3
 8002696:	2101      	movs	r1, #1
 8002698:	4011      	ands	r1, r2
 800269a:	68ea      	ldr	r2, [r5, #12]
 800269c:	4010      	ands	r0, r2
 800269e:	f002 fc4b 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 80026a2:	e09f      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026a4:	6868      	ldr	r0, [r5, #4]
 80026a6:	7800      	ldrb	r0, [r0, #0]
 80026a8:	0780      	lsls	r0, r0, #30
 80026aa:	0f80      	lsrs	r0, r0, #30
 80026ac:	2802      	cmp	r0, #2
 80026ae:	d101      	bne.n	80026b4 <__iar_annotation$$branch+0x164>
 80026b0:	2001      	movs	r0, #1
 80026b2:	e12d      	b.n	8002910 <__iar_annotation$$branch+0x3c0>
 80026b4:	202a      	movs	r0, #42	; 0x2a
 80026b6:	e12b      	b.n	8002910 <__iar_annotation$$branch+0x3c0>
 80026b8:	9400      	str	r4, [sp, #0]
 80026ba:	2395      	movs	r3, #149	; 0x95
 80026bc:	2209      	movs	r2, #9
 80026be:	2100      	movs	r1, #0
 80026c0:	0028      	movs	r0, r5
 80026c2:	f001 f856 	bl	8003772 <PE_Send_CtrlMessage>
 80026c6:	2800      	cmp	r0, #0
 80026c8:	d000      	beq.n	80026cc <__iar_annotation$$branch+0x17c>
 80026ca:	e08b      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026cc:	200f      	movs	r0, #15
 80026ce:	82e8      	strh	r0, [r5, #22]
 80026d0:	e3a7      	b.n	8002e22 <__iar_annotation$$branch+0x8d2>
 80026d2:	8b32      	ldrh	r2, [r6, #24]
 80026d4:	03a3      	lsls	r3, r4, #14
 80026d6:	429a      	cmp	r2, r3
 80026d8:	d100      	bne.n	80026dc <__iar_annotation$$branch+0x18c>
 80026da:	e6f6      	b.n	80024ca <__iar_annotation$$branch>
 80026dc:	2914      	cmp	r1, #20
 80026de:	d100      	bne.n	80026e2 <__iar_annotation$$branch+0x192>
 80026e0:	e080      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026e2:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 80026e4:	0bc9      	lsrs	r1, r1, #15
 80026e6:	d000      	beq.n	80026ea <__iar_annotation$$branch+0x19a>
 80026e8:	e07c      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026ea:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 80026ec:	0b09      	lsrs	r1, r1, #12
 80026ee:	0749      	lsls	r1, r1, #29
 80026f0:	d178      	bne.n	80027e4 <__iar_annotation$$branch+0x294>
 80026f2:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 80026f4:	06c9      	lsls	r1, r1, #27
 80026f6:	0ec9      	lsrs	r1, r1, #27
 80026f8:	2903      	cmp	r1, #3
 80026fa:	d004      	beq.n	8002706 <__iar_annotation$$branch+0x1b6>
 80026fc:	2904      	cmp	r1, #4
 80026fe:	d04d      	beq.n	800279c <__iar_annotation$$branch+0x24c>
 8002700:	290c      	cmp	r1, #12
 8002702:	d037      	beq.n	8002774 <__iar_annotation$$branch+0x224>
 8002704:	e06e      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002706:	6869      	ldr	r1, [r5, #4]
 8002708:	780a      	ldrb	r2, [r1, #0]
 800270a:	08d3      	lsrs	r3, r2, #3
 800270c:	07db      	lsls	r3, r3, #31
 800270e:	d410      	bmi.n	8002732 <__iar_annotation$$branch+0x1e2>
 8002710:	2308      	movs	r3, #8
 8002712:	4313      	orrs	r3, r2
 8002714:	700b      	strb	r3, [r1, #0]
 8002716:	2800      	cmp	r0, #0
 8002718:	d009      	beq.n	800272e <__iar_annotation$$branch+0x1de>
 800271a:	2000      	movs	r0, #0
 800271c:	9000      	str	r0, [sp, #0]
 800271e:	2300      	movs	r3, #0
 8002720:	2224      	movs	r2, #36	; 0x24
 8002722:	7b28      	ldrb	r0, [r5, #12]
 8002724:	07c1      	lsls	r1, r0, #31
 8002726:	0fc9      	lsrs	r1, r1, #31
 8002728:	2009      	movs	r0, #9
 800272a:	9f01      	ldr	r7, [sp, #4]
 800272c:	47b8      	blx	r7
 800272e:	2124      	movs	r1, #36	; 0x24
 8002730:	e00f      	b.n	8002752 <__iar_annotation$$branch+0x202>
 8002732:	23f7      	movs	r3, #247	; 0xf7
 8002734:	4013      	ands	r3, r2
 8002736:	700b      	strb	r3, [r1, #0]
 8002738:	2800      	cmp	r0, #0
 800273a:	d009      	beq.n	8002750 <__iar_annotation$$branch+0x200>
 800273c:	2000      	movs	r0, #0
 800273e:	9000      	str	r0, [sp, #0]
 8002740:	2300      	movs	r3, #0
 8002742:	2223      	movs	r2, #35	; 0x23
 8002744:	7b28      	ldrb	r0, [r5, #12]
 8002746:	07c1      	lsls	r1, r0, #31
 8002748:	0fc9      	lsrs	r1, r1, #31
 800274a:	2009      	movs	r0, #9
 800274c:	9f01      	ldr	r7, [sp, #4]
 800274e:	47b8      	blx	r7
 8002750:	2123      	movs	r1, #35	; 0x23
 8002752:	7b2a      	ldrb	r2, [r5, #12]
 8002754:	07d0      	lsls	r0, r2, #31
 8002756:	0fc0      	lsrs	r0, r0, #31
 8002758:	68aa      	ldr	r2, [r5, #8]
 800275a:	68d2      	ldr	r2, [r2, #12]
 800275c:	4790      	blx	r2
 800275e:	2001      	movs	r0, #1
 8002760:	6869      	ldr	r1, [r5, #4]
 8002762:	7809      	ldrb	r1, [r1, #0]
 8002764:	08ca      	lsrs	r2, r1, #3
 8002766:	2101      	movs	r1, #1
 8002768:	4011      	ands	r1, r2
 800276a:	68ea      	ldr	r2, [r5, #12]
 800276c:	4010      	ands	r0, r2
 800276e:	f002 fbe3 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 8002772:	e30f      	b.n	8002d94 <__iar_annotation$$branch+0x844>
 8002774:	2800      	cmp	r0, #0
 8002776:	d009      	beq.n	800278c <__iar_annotation$$branch+0x23c>
 8002778:	2000      	movs	r0, #0
 800277a:	9000      	str	r0, [sp, #0]
 800277c:	2300      	movs	r3, #0
 800277e:	2225      	movs	r2, #37	; 0x25
 8002780:	7b28      	ldrb	r0, [r5, #12]
 8002782:	07c1      	lsls	r1, r0, #31
 8002784:	0fc9      	lsrs	r1, r1, #31
 8002786:	2009      	movs	r0, #9
 8002788:	9f01      	ldr	r7, [sp, #4]
 800278a:	47b8      	blx	r7
 800278c:	2125      	movs	r1, #37	; 0x25
 800278e:	7b2a      	ldrb	r2, [r5, #12]
 8002790:	07d0      	lsls	r0, r2, #31
 8002792:	0fc0      	lsrs	r0, r0, #31
 8002794:	68aa      	ldr	r2, [r5, #8]
 8002796:	68d2      	ldr	r2, [r2, #12]
 8002798:	4790      	blx	r2
 800279a:	e2fb      	b.n	8002d94 <__iar_annotation$$branch+0x844>
 800279c:	2800      	cmp	r0, #0
 800279e:	d009      	beq.n	80027b4 <__iar_annotation$$branch+0x264>
 80027a0:	2000      	movs	r0, #0
 80027a2:	9000      	str	r0, [sp, #0]
 80027a4:	2300      	movs	r3, #0
 80027a6:	2226      	movs	r2, #38	; 0x26
 80027a8:	7b28      	ldrb	r0, [r5, #12]
 80027aa:	07c1      	lsls	r1, r0, #31
 80027ac:	0fc9      	lsrs	r1, r1, #31
 80027ae:	2009      	movs	r0, #9
 80027b0:	9f01      	ldr	r7, [sp, #4]
 80027b2:	47b8      	blx	r7
 80027b4:	2126      	movs	r1, #38	; 0x26
 80027b6:	7b2a      	ldrb	r2, [r5, #12]
 80027b8:	07d0      	lsls	r0, r2, #31
 80027ba:	0fc0      	lsrs	r0, r0, #31
 80027bc:	68aa      	ldr	r2, [r5, #8]
 80027be:	68d2      	ldr	r2, [r2, #12]
 80027c0:	4790      	blx	r2
 80027c2:	e2e7      	b.n	8002d94 <__iar_annotation$$branch+0x844>
 80027c4:	68a8      	ldr	r0, [r5, #8]
 80027c6:	6881      	ldr	r1, [r0, #8]
 80027c8:	2900      	cmp	r1, #0
 80027ca:	d102      	bne.n	80027d2 <__iar_annotation$$branch+0x282>
 80027cc:	202a      	movs	r0, #42	; 0x2a
 80027ce:	7130      	strb	r0, [r6, #4]
 80027d0:	e354      	b.n	8002e7c <__iar_annotation$$branch+0x92c>
 80027d2:	4668      	mov	r0, sp
 80027d4:	7b40      	ldrb	r0, [r0, #13]
 80027d6:	4788      	blx	r1
 80027d8:	280a      	cmp	r0, #10
 80027da:	d004      	beq.n	80027e6 <__iar_annotation$$branch+0x296>
 80027dc:	280c      	cmp	r0, #12
 80027de:	d052      	beq.n	8002886 <__iar_annotation$$branch+0x336>
 80027e0:	280d      	cmp	r0, #13
 80027e2:	d038      	beq.n	8002856 <__iar_annotation$$branch+0x306>
 80027e4:	e392      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 80027e6:	68a8      	ldr	r0, [r5, #8]
 80027e8:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80027ea:	2b00      	cmp	r3, #0
 80027ec:	d005      	beq.n	80027fa <__iar_annotation$$branch+0x2aa>
 80027ee:	2201      	movs	r2, #1
 80027f0:	2100      	movs	r1, #0
 80027f2:	7b2f      	ldrb	r7, [r5, #12]
 80027f4:	07f8      	lsls	r0, r7, #31
 80027f6:	0fc0      	lsrs	r0, r0, #31
 80027f8:	4798      	blx	r3
 80027fa:	2000      	movs	r0, #0
 80027fc:	9000      	str	r0, [sp, #0]
 80027fe:	2352      	movs	r3, #82	; 0x52
 8002800:	2203      	movs	r2, #3
 8002802:	2100      	movs	r1, #0
 8002804:	0028      	movs	r0, r5
 8002806:	f000 ffb4 	bl	8003772 <PE_Send_CtrlMessage>
 800280a:	2800      	cmp	r0, #0
 800280c:	d1ea      	bne.n	80027e4 <__iar_annotation$$branch+0x294>
 800280e:	2008      	movs	r0, #8
 8002810:	82e8      	strh	r0, [r5, #22]
 8002812:	6868      	ldr	r0, [r5, #4]
 8002814:	6801      	ldr	r1, [r0, #0]
 8002816:	2210      	movs	r2, #16
 8002818:	430a      	orrs	r2, r1
 800281a:	6002      	str	r2, [r0, #0]
 800281c:	68a8      	ldr	r0, [r5, #8]
 800281e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002820:	2b00      	cmp	r3, #0
 8002822:	d005      	beq.n	8002830 <__iar_annotation$$branch+0x2e0>
 8002824:	2206      	movs	r2, #6
 8002826:	2100      	movs	r1, #0
 8002828:	7b2c      	ldrb	r4, [r5, #12]
 800282a:	07e0      	lsls	r0, r4, #31
 800282c:	0fc0      	lsrs	r0, r0, #31
 800282e:	4798      	blx	r3
 8002830:	489d      	ldr	r0, [pc, #628]	; (8002aa8 <__iar_annotation$$branch+0x558>)
 8002832:	82b0      	strh	r0, [r6, #20]
 8002834:	4c9d      	ldr	r4, [pc, #628]	; (8002aac <__iar_annotation$$branch+0x55c>)
 8002836:	4f1f      	ldr	r7, [pc, #124]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002838:	7838      	ldrb	r0, [r7, #0]
 800283a:	0780      	lsls	r0, r0, #30
 800283c:	d509      	bpl.n	8002852 <__iar_annotation$$branch+0x302>
 800283e:	2000      	movs	r0, #0
 8002840:	9000      	str	r0, [sp, #0]
 8002842:	2300      	movs	r3, #0
 8002844:	2238      	movs	r2, #56	; 0x38
 8002846:	7b28      	ldrb	r0, [r5, #12]
 8002848:	07c1      	lsls	r1, r0, #31
 800284a:	0fc9      	lsrs	r1, r1, #31
 800284c:	2009      	movs	r0, #9
 800284e:	68ff      	ldr	r7, [r7, #12]
 8002850:	47b8      	blx	r7
 8002852:	2138      	movs	r1, #56	; 0x38
 8002854:	e2fe      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 8002856:	2000      	movs	r0, #0
 8002858:	9000      	str	r0, [sp, #0]
 800285a:	2303      	movs	r3, #3
 800285c:	220c      	movs	r2, #12
 800285e:	2100      	movs	r1, #0
 8002860:	0028      	movs	r0, r5
 8002862:	f000 ff86 	bl	8003772 <PE_Send_CtrlMessage>
 8002866:	4f13      	ldr	r7, [pc, #76]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002868:	7838      	ldrb	r0, [r7, #0]
 800286a:	0780      	lsls	r0, r0, #30
 800286c:	d509      	bpl.n	8002882 <__iar_annotation$$branch+0x332>
 800286e:	2000      	movs	r0, #0
 8002870:	9000      	str	r0, [sp, #0]
 8002872:	2300      	movs	r3, #0
 8002874:	2239      	movs	r2, #57	; 0x39
 8002876:	7b28      	ldrb	r0, [r5, #12]
 8002878:	07c1      	lsls	r1, r0, #31
 800287a:	0fc9      	lsrs	r1, r1, #31
 800287c:	2009      	movs	r0, #9
 800287e:	68ff      	ldr	r7, [r7, #12]
 8002880:	47b8      	blx	r7
 8002882:	2139      	movs	r1, #57	; 0x39
 8002884:	e2e6      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 8002886:	202a      	movs	r0, #42	; 0x2a
 8002888:	7130      	strb	r0, [r6, #4]
 800288a:	2400      	movs	r4, #0
 800288c:	4809      	ldr	r0, [pc, #36]	; (80028b4 <__iar_annotation$$branch+0x364>)
 800288e:	7800      	ldrb	r0, [r0, #0]
 8002890:	0780      	lsls	r0, r0, #30
 8002892:	d50a      	bpl.n	80028aa <__iar_annotation$$branch+0x35a>
 8002894:	2000      	movs	r0, #0
 8002896:	9000      	str	r0, [sp, #0]
 8002898:	2300      	movs	r3, #0
 800289a:	2216      	movs	r2, #22
 800289c:	7b28      	ldrb	r0, [r5, #12]
 800289e:	07c1      	lsls	r1, r0, #31
 80028a0:	0fc9      	lsrs	r1, r1, #31
 80028a2:	2009      	movs	r0, #9
 80028a4:	4f03      	ldr	r7, [pc, #12]	; (80028b4 <__iar_annotation$$branch+0x364>)
 80028a6:	68ff      	ldr	r7, [r7, #12]
 80028a8:	47b8      	blx	r7
 80028aa:	2116      	movs	r1, #22
 80028ac:	e2d2      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 80028ae:	bf00      	nop
 80028b0:	00007fff 	.word	0x00007fff
 80028b4:	200019e8 	.word	0x200019e8
 80028b8:	2911      	cmp	r1, #17
 80028ba:	d11c      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028bc:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 80028be:	0bc0      	lsrs	r0, r0, #15
 80028c0:	d119      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028c2:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 80028c4:	0b00      	lsrs	r0, r0, #12
 80028c6:	0740      	lsls	r0, r0, #29
 80028c8:	d115      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028ca:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 80028cc:	06c0      	lsls	r0, r0, #27
 80028ce:	0ec0      	lsrs	r0, r0, #27
 80028d0:	2806      	cmp	r0, #6
 80028d2:	d110      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028d4:	2000      	movs	r0, #0
 80028d6:	82f0      	strh	r0, [r6, #22]
 80028d8:	68a8      	ldr	r0, [r5, #8]
 80028da:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80028dc:	2b00      	cmp	r3, #0
 80028de:	d005      	beq.n	80028ec <__iar_annotation$$branch+0x39c>
 80028e0:	2209      	movs	r2, #9
 80028e2:	2100      	movs	r1, #0
 80028e4:	7b2f      	ldrb	r7, [r5, #12]
 80028e6:	07f8      	lsls	r0, r7, #31
 80028e8:	0fc0      	lsrs	r0, r0, #31
 80028ea:	4798      	blx	r3
 80028ec:	2053      	movs	r0, #83	; 0x53
 80028ee:	7130      	strb	r0, [r6, #4]
 80028f0:	2014      	movs	r0, #20
 80028f2:	4669      	mov	r1, sp
 80028f4:	7308      	strb	r0, [r1, #12]
 80028f6:	8ab0      	ldrh	r0, [r6, #20]
 80028f8:	03a1      	lsls	r1, r4, #14
 80028fa:	4288      	cmp	r0, r1
 80028fc:	d000      	beq.n	8002900 <__iar_annotation$$branch+0x3b0>
 80028fe:	e305      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002900:	2000      	movs	r0, #0
 8002902:	82b0      	strh	r0, [r6, #20]
 8002904:	68a8      	ldr	r0, [r5, #8]
 8002906:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8002908:	2800      	cmp	r0, #0
 800290a:	d100      	bne.n	800290e <__iar_annotation$$branch+0x3be>
 800290c:	e185      	b.n	8002c1a <__iar_annotation$$branch+0x6ca>
 800290e:	2092      	movs	r0, #146	; 0x92
 8002910:	e2fb      	b.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002912:	6869      	ldr	r1, [r5, #4]
 8002914:	784a      	ldrb	r2, [r1, #1]
 8002916:	238f      	movs	r3, #143	; 0x8f
 8002918:	4013      	ands	r3, r2
 800291a:	2240      	movs	r2, #64	; 0x40
 800291c:	431a      	orrs	r2, r3
 800291e:	704a      	strb	r2, [r1, #1]
 8002920:	2800      	cmp	r0, #0
 8002922:	d009      	beq.n	8002938 <__iar_annotation$$branch+0x3e8>
 8002924:	2000      	movs	r0, #0
 8002926:	9000      	str	r0, [sp, #0]
 8002928:	2300      	movs	r3, #0
 800292a:	2256      	movs	r2, #86	; 0x56
 800292c:	7b28      	ldrb	r0, [r5, #12]
 800292e:	07c1      	lsls	r1, r0, #31
 8002930:	0fc9      	lsrs	r1, r1, #31
 8002932:	2009      	movs	r0, #9
 8002934:	9f01      	ldr	r7, [sp, #4]
 8002936:	47b8      	blx	r7
 8002938:	2701      	movs	r7, #1
 800293a:	2156      	movs	r1, #86	; 0x56
 800293c:	68ea      	ldr	r2, [r5, #12]
 800293e:	2001      	movs	r0, #1
 8002940:	4010      	ands	r0, r2
 8002942:	68aa      	ldr	r2, [r5, #8]
 8002944:	68d2      	ldr	r2, [r2, #12]
 8002946:	4790      	blx	r2
 8002948:	68a8      	ldr	r0, [r5, #8]
 800294a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800294c:	2b00      	cmp	r3, #0
 800294e:	d005      	beq.n	800295c <__iar_annotation$$branch+0x40c>
 8002950:	220a      	movs	r2, #10
 8002952:	68e9      	ldr	r1, [r5, #12]
 8002954:	2001      	movs	r0, #1
 8002956:	4008      	ands	r0, r1
 8002958:	2100      	movs	r1, #0
 800295a:	4798      	blx	r3
 800295c:	68e9      	ldr	r1, [r5, #12]
 800295e:	2001      	movs	r0, #1
 8002960:	4008      	ands	r0, r1
 8002962:	f002 fb03 	bl	8004f6c <USBPD_PRL_SRCSetSinkNG>
 8002966:	68a8      	ldr	r0, [r5, #8]
 8002968:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800296a:	2b00      	cmp	r3, #0
 800296c:	d005      	beq.n	800297a <__iar_annotation$$branch+0x42a>
 800296e:	220b      	movs	r2, #11
 8002970:	68e9      	ldr	r1, [r5, #12]
 8002972:	2001      	movs	r0, #1
 8002974:	4008      	ands	r0, r1
 8002976:	2101      	movs	r1, #1
 8002978:	4798      	blx	r3
 800297a:	2101      	movs	r1, #1
 800297c:	4668      	mov	r0, sp
 800297e:	7b40      	ldrb	r0, [r0, #13]
 8002980:	f002 facf 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8002984:	2000      	movs	r0, #0
 8002986:	9000      	str	r0, [sp, #0]
 8002988:	2354      	movs	r3, #84	; 0x54
 800298a:	2206      	movs	r2, #6
 800298c:	2100      	movs	r1, #0
 800298e:	0028      	movs	r0, r5
 8002990:	f000 feef 	bl	8003772 <PE_Send_CtrlMessage>
 8002994:	2800      	cmp	r0, #0
 8002996:	d10c      	bne.n	80029b2 <__iar_annotation$$branch+0x462>
 8002998:	68a8      	ldr	r0, [r5, #8]
 800299a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800299c:	2b00      	cmp	r3, #0
 800299e:	d005      	beq.n	80029ac <__iar_annotation$$branch+0x45c>
 80029a0:	220c      	movs	r2, #12
 80029a2:	2100      	movs	r1, #0
 80029a4:	68ec      	ldr	r4, [r5, #12]
 80029a6:	2001      	movs	r0, #1
 80029a8:	4020      	ands	r0, r4
 80029aa:	4798      	blx	r3
 80029ac:	48b2      	ldr	r0, [pc, #712]	; (8002c78 <__iar_annotation$$branch+0x728>)
 80029ae:	8430      	strh	r0, [r6, #32]
 80029b0:	2414      	movs	r4, #20
 80029b2:	7930      	ldrb	r0, [r6, #4]
 80029b4:	2854      	cmp	r0, #84	; 0x54
 80029b6:	d05c      	beq.n	8002a72 <__iar_annotation$$branch+0x522>
 80029b8:	2100      	movs	r1, #0
 80029ba:	4668      	mov	r0, sp
 80029bc:	7b40      	ldrb	r0, [r0, #13]
 80029be:	f002 fab0 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 80029c2:	68a8      	ldr	r0, [r5, #8]
 80029c4:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80029c6:	2b00      	cmp	r3, #0
 80029c8:	d053      	beq.n	8002a72 <__iar_annotation$$branch+0x522>
 80029ca:	2206      	movs	r2, #6
 80029cc:	68e9      	ldr	r1, [r5, #12]
 80029ce:	2001      	movs	r0, #1
 80029d0:	4008      	ands	r0, r1
 80029d2:	2101      	movs	r1, #1
 80029d4:	4798      	blx	r3
 80029d6:	68a8      	ldr	r0, [r5, #8]
 80029d8:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80029da:	2b00      	cmp	r3, #0
 80029dc:	d049      	beq.n	8002a72 <__iar_annotation$$branch+0x522>
 80029de:	2207      	movs	r2, #7
 80029e0:	2100      	movs	r1, #0
 80029e2:	68e8      	ldr	r0, [r5, #12]
 80029e4:	4007      	ands	r7, r0
 80029e6:	0038      	movs	r0, r7
 80029e8:	e151      	b.n	8002c8e <__iar_annotation$$branch+0x73e>
 80029ea:	8c30      	ldrh	r0, [r6, #32]
 80029ec:	03a1      	lsls	r1, r4, #14
 80029ee:	4288      	cmp	r0, r1
 80029f0:	d13f      	bne.n	8002a72 <__iar_annotation$$branch+0x522>
 80029f2:	2000      	movs	r0, #0
 80029f4:	8430      	strh	r0, [r6, #32]
 80029f6:	2101      	movs	r1, #1
 80029f8:	0028      	movs	r0, r5
 80029fa:	f000 ffcf 	bl	800399c <PE_ChangePowerRole>
 80029fe:	68a8      	ldr	r0, [r5, #8]
 8002a00:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002a02:	2b00      	cmp	r3, #0
 8002a04:	d005      	beq.n	8002a12 <__iar_annotation$$branch+0x4c2>
 8002a06:	220e      	movs	r2, #14
 8002a08:	2101      	movs	r1, #1
 8002a0a:	7b2f      	ldrb	r7, [r5, #12]
 8002a0c:	07f8      	lsls	r0, r7, #31
 8002a0e:	0fc0      	lsrs	r0, r0, #31
 8002a10:	4798      	blx	r3
 8002a12:	7b29      	ldrb	r1, [r5, #12]
 8002a14:	07c8      	lsls	r0, r1, #31
 8002a16:	0fc0      	lsrs	r0, r0, #31
 8002a18:	f002 faac 	bl	8004f74 <USBPD_PRL_SRCReleaseSinkNG>
 8002a1c:	0028      	movs	r0, r5
 8002a1e:	f001 fc67 	bl	80042f0 <PE_ResetDuringSwap>
 8002a22:	48b0      	ldr	r0, [pc, #704]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002a24:	7800      	ldrb	r0, [r0, #0]
 8002a26:	0780      	lsls	r0, r0, #30
 8002a28:	d500      	bpl.n	8002a2c <__iar_annotation$$branch+0x4dc>
 8002a2a:	e14d      	b.n	8002cc8 <__iar_annotation$$branch+0x778>
 8002a2c:	e157      	b.n	8002cde <__iar_annotation$$branch+0x78e>
 8002a2e:	68a8      	ldr	r0, [r5, #8]
 8002a30:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002a32:	2b00      	cmp	r3, #0
 8002a34:	d005      	beq.n	8002a42 <__iar_annotation$$branch+0x4f2>
 8002a36:	2202      	movs	r2, #2
 8002a38:	7b29      	ldrb	r1, [r5, #12]
 8002a3a:	07c8      	lsls	r0, r1, #31
 8002a3c:	0fc0      	lsrs	r0, r0, #31
 8002a3e:	2100      	movs	r1, #0
 8002a40:	4798      	blx	r3
 8002a42:	9400      	str	r4, [sp, #0]
 8002a44:	2358      	movs	r3, #88	; 0x58
 8002a46:	20e5      	movs	r0, #229	; 0xe5
 8002a48:	0080      	lsls	r0, r0, #2
 8002a4a:	5c2a      	ldrb	r2, [r5, r0]
 8002a4c:	2100      	movs	r1, #0
 8002a4e:	0028      	movs	r0, r5
 8002a50:	f000 fe8f 	bl	8003772 <PE_Send_CtrlMessage>
 8002a54:	2800      	cmp	r0, #0
 8002a56:	d000      	beq.n	8002a5a <__iar_annotation$$branch+0x50a>
 8002a58:	e110      	b.n	8002c7c <__iar_annotation$$branch+0x72c>
 8002a5a:	20e5      	movs	r0, #229	; 0xe5
 8002a5c:	0080      	lsls	r0, r0, #2
 8002a5e:	1828      	adds	r0, r5, r0
 8002a60:	8840      	ldrh	r0, [r0, #2]
 8002a62:	82e8      	strh	r0, [r5, #22]
 8002a64:	8337      	strh	r7, [r6, #24]
 8002a66:	241a      	movs	r4, #26
 8002a68:	6868      	ldr	r0, [r5, #4]
 8002a6a:	6801      	ldr	r1, [r0, #0]
 8002a6c:	2210      	movs	r2, #16
 8002a6e:	430a      	orrs	r2, r1
 8002a70:	6002      	str	r2, [r0, #0]
 8002a72:	e24b      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002a74:	2911      	cmp	r1, #17
 8002a76:	d111      	bne.n	8002a9c <__iar_annotation$$branch+0x54c>
 8002a78:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002a7a:	0bc9      	lsrs	r1, r1, #15
 8002a7c:	d10e      	bne.n	8002a9c <__iar_annotation$$branch+0x54c>
 8002a7e:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002a80:	0b09      	lsrs	r1, r1, #12
 8002a82:	0749      	lsls	r1, r1, #29
 8002a84:	d10a      	bne.n	8002a9c <__iar_annotation$$branch+0x54c>
 8002a86:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002a88:	06c9      	lsls	r1, r1, #27
 8002a8a:	0ec9      	lsrs	r1, r1, #27
 8002a8c:	2903      	cmp	r1, #3
 8002a8e:	d006      	beq.n	8002a9e <__iar_annotation$$branch+0x54e>
 8002a90:	2904      	cmp	r1, #4
 8002a92:	d066      	beq.n	8002b62 <__iar_annotation$$branch+0x612>
 8002a94:	290c      	cmp	r1, #12
 8002a96:	d049      	beq.n	8002b2c <__iar_annotation$$branch+0x5dc>
 8002a98:	2910      	cmp	r1, #16
 8002a9a:	d077      	beq.n	8002b8c <__iar_annotation$$branch+0x63c>
 8002a9c:	e090      	b.n	8002bc0 <__iar_annotation$$branch+0x670>
 8002a9e:	4802      	ldr	r0, [pc, #8]	; (8002aa8 <__iar_annotation$$branch+0x558>)
 8002aa0:	82b0      	strh	r0, [r6, #20]
 8002aa2:	4c02      	ldr	r4, [pc, #8]	; (8002aac <__iar_annotation$$branch+0x55c>)
 8002aa4:	e004      	b.n	8002ab0 <__iar_annotation$$branch+0x560>
 8002aa6:	bf00      	nop
 8002aa8:	00008343 	.word	0x00008343
 8002aac:	00000343 	.word	0x00000343
 8002ab0:	2000      	movs	r0, #0
 8002ab2:	8330      	strh	r0, [r6, #24]
 8002ab4:	2014      	movs	r0, #20
 8002ab6:	4669      	mov	r1, sp
 8002ab8:	7308      	strb	r0, [r1, #12]
 8002aba:	2059      	movs	r0, #89	; 0x59
 8002abc:	7130      	strb	r0, [r6, #4]
 8002abe:	68a8      	ldr	r0, [r5, #8]
 8002ac0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002ac2:	2b00      	cmp	r3, #0
 8002ac4:	d005      	beq.n	8002ad2 <__iar_annotation$$branch+0x582>
 8002ac6:	2206      	movs	r2, #6
 8002ac8:	2100      	movs	r1, #0
 8002aca:	7b2f      	ldrb	r7, [r5, #12]
 8002acc:	07f8      	lsls	r0, r7, #31
 8002ace:	0fc0      	lsrs	r0, r0, #31
 8002ad0:	4798      	blx	r3
 8002ad2:	6868      	ldr	r0, [r5, #4]
 8002ad4:	7841      	ldrb	r1, [r0, #1]
 8002ad6:	228f      	movs	r2, #143	; 0x8f
 8002ad8:	400a      	ands	r2, r1
 8002ada:	2140      	movs	r1, #64	; 0x40
 8002adc:	4311      	orrs	r1, r2
 8002ade:	7041      	strb	r1, [r0, #1]
 8002ae0:	4880      	ldr	r0, [pc, #512]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002ae2:	7800      	ldrb	r0, [r0, #0]
 8002ae4:	0780      	lsls	r0, r0, #30
 8002ae6:	d50a      	bpl.n	8002afe <__iar_annotation$$branch+0x5ae>
 8002ae8:	2000      	movs	r0, #0
 8002aea:	9000      	str	r0, [sp, #0]
 8002aec:	2300      	movs	r3, #0
 8002aee:	2256      	movs	r2, #86	; 0x56
 8002af0:	7b28      	ldrb	r0, [r5, #12]
 8002af2:	07c1      	lsls	r1, r0, #31
 8002af4:	0fc9      	lsrs	r1, r1, #31
 8002af6:	2009      	movs	r0, #9
 8002af8:	4f7a      	ldr	r7, [pc, #488]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002afa:	68ff      	ldr	r7, [r7, #12]
 8002afc:	47b8      	blx	r7
 8002afe:	2156      	movs	r1, #86	; 0x56
 8002b00:	7b2a      	ldrb	r2, [r5, #12]
 8002b02:	07d0      	lsls	r0, r2, #31
 8002b04:	0fc0      	lsrs	r0, r0, #31
 8002b06:	68aa      	ldr	r2, [r5, #8]
 8002b08:	68d2      	ldr	r2, [r2, #12]
 8002b0a:	4790      	blx	r2
 8002b0c:	4f75      	ldr	r7, [pc, #468]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002b0e:	7838      	ldrb	r0, [r7, #0]
 8002b10:	0780      	lsls	r0, r0, #30
 8002b12:	d509      	bpl.n	8002b28 <__iar_annotation$$branch+0x5d8>
 8002b14:	2000      	movs	r0, #0
 8002b16:	9000      	str	r0, [sp, #0]
 8002b18:	2300      	movs	r3, #0
 8002b1a:	2238      	movs	r2, #56	; 0x38
 8002b1c:	7b28      	ldrb	r0, [r5, #12]
 8002b1e:	07c1      	lsls	r1, r0, #31
 8002b20:	0fc9      	lsrs	r1, r1, #31
 8002b22:	2009      	movs	r0, #9
 8002b24:	68ff      	ldr	r7, [r7, #12]
 8002b26:	47b8      	blx	r7
 8002b28:	2138      	movs	r1, #56	; 0x38
 8002b2a:	e043      	b.n	8002bb4 <__iar_annotation$$branch+0x664>
 8002b2c:	2800      	cmp	r0, #0
 8002b2e:	d009      	beq.n	8002b44 <__iar_annotation$$branch+0x5f4>
 8002b30:	2000      	movs	r0, #0
 8002b32:	9000      	str	r0, [sp, #0]
 8002b34:	2300      	movs	r3, #0
 8002b36:	2239      	movs	r2, #57	; 0x39
 8002b38:	7b28      	ldrb	r0, [r5, #12]
 8002b3a:	07c1      	lsls	r1, r0, #31
 8002b3c:	0fc9      	lsrs	r1, r1, #31
 8002b3e:	2009      	movs	r0, #9
 8002b40:	9f01      	ldr	r7, [sp, #4]
 8002b42:	47b8      	blx	r7
 8002b44:	2139      	movs	r1, #57	; 0x39
 8002b46:	7b2a      	ldrb	r2, [r5, #12]
 8002b48:	07d0      	lsls	r0, r2, #31
 8002b4a:	0fc0      	lsrs	r0, r0, #31
 8002b4c:	68aa      	ldr	r2, [r5, #8]
 8002b4e:	68d2      	ldr	r2, [r2, #12]
 8002b50:	4790      	blx	r2
 8002b52:	2000      	movs	r0, #0
 8002b54:	8330      	strh	r0, [r6, #24]
 8002b56:	2014      	movs	r0, #20
 8002b58:	4669      	mov	r1, sp
 8002b5a:	7308      	strb	r0, [r1, #12]
 8002b5c:	2003      	movs	r0, #3
 8002b5e:	7130      	strb	r0, [r6, #4]
 8002b60:	e02e      	b.n	8002bc0 <__iar_annotation$$branch+0x670>
 8002b62:	2100      	movs	r1, #0
 8002b64:	8331      	strh	r1, [r6, #24]
 8002b66:	2114      	movs	r1, #20
 8002b68:	466a      	mov	r2, sp
 8002b6a:	7311      	strb	r1, [r2, #12]
 8002b6c:	2103      	movs	r1, #3
 8002b6e:	7131      	strb	r1, [r6, #4]
 8002b70:	2800      	cmp	r0, #0
 8002b72:	d009      	beq.n	8002b88 <__iar_annotation$$branch+0x638>
 8002b74:	2000      	movs	r0, #0
 8002b76:	9000      	str	r0, [sp, #0]
 8002b78:	2300      	movs	r3, #0
 8002b7a:	2216      	movs	r2, #22
 8002b7c:	7b28      	ldrb	r0, [r5, #12]
 8002b7e:	07c1      	lsls	r1, r0, #31
 8002b80:	0fc9      	lsrs	r1, r1, #31
 8002b82:	2009      	movs	r0, #9
 8002b84:	9f01      	ldr	r7, [sp, #4]
 8002b86:	47b8      	blx	r7
 8002b88:	2116      	movs	r1, #22
 8002b8a:	e013      	b.n	8002bb4 <__iar_annotation$$branch+0x664>
 8002b8c:	2100      	movs	r1, #0
 8002b8e:	8331      	strh	r1, [r6, #24]
 8002b90:	2114      	movs	r1, #20
 8002b92:	466a      	mov	r2, sp
 8002b94:	7311      	strb	r1, [r2, #12]
 8002b96:	2103      	movs	r1, #3
 8002b98:	7131      	strb	r1, [r6, #4]
 8002b9a:	2800      	cmp	r0, #0
 8002b9c:	d009      	beq.n	8002bb2 <__iar_annotation$$branch+0x662>
 8002b9e:	2000      	movs	r0, #0
 8002ba0:	9000      	str	r0, [sp, #0]
 8002ba2:	2300      	movs	r3, #0
 8002ba4:	2255      	movs	r2, #85	; 0x55
 8002ba6:	7b28      	ldrb	r0, [r5, #12]
 8002ba8:	07c1      	lsls	r1, r0, #31
 8002baa:	0fc9      	lsrs	r1, r1, #31
 8002bac:	2009      	movs	r0, #9
 8002bae:	9f01      	ldr	r7, [sp, #4]
 8002bb0:	47b8      	blx	r7
 8002bb2:	2155      	movs	r1, #85	; 0x55
 8002bb4:	7b2a      	ldrb	r2, [r5, #12]
 8002bb6:	07d0      	lsls	r0, r2, #31
 8002bb8:	0fc0      	lsrs	r0, r0, #31
 8002bba:	68aa      	ldr	r2, [r5, #8]
 8002bbc:	68d2      	ldr	r2, [r2, #12]
 8002bbe:	4790      	blx	r2
 8002bc0:	8b30      	ldrh	r0, [r6, #24]
 8002bc2:	2180      	movs	r1, #128	; 0x80
 8002bc4:	0209      	lsls	r1, r1, #8
 8002bc6:	4288      	cmp	r0, r1
 8002bc8:	d155      	bne.n	8002c76 <__iar_annotation$$branch+0x726>
 8002bca:	2400      	movs	r4, #0
 8002bcc:	8334      	strh	r4, [r6, #24]
 8002bce:	e176      	b.n	8002ebe <__iar_annotation$$branch+0x96e>
 8002bd0:	2911      	cmp	r1, #17
 8002bd2:	d112      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002bd4:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002bd6:	0bc0      	lsrs	r0, r0, #15
 8002bd8:	d10f      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002bda:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002bdc:	0b00      	lsrs	r0, r0, #12
 8002bde:	0740      	lsls	r0, r0, #29
 8002be0:	d10b      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002be2:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002be4:	06c0      	lsls	r0, r0, #27
 8002be6:	0ec0      	lsrs	r0, r0, #27
 8002be8:	2806      	cmp	r0, #6
 8002bea:	d106      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002bec:	2000      	movs	r0, #0
 8002bee:	82b0      	strh	r0, [r6, #20]
 8002bf0:	205a      	movs	r0, #90	; 0x5a
 8002bf2:	7130      	strb	r0, [r6, #4]
 8002bf4:	2014      	movs	r0, #20
 8002bf6:	4669      	mov	r1, sp
 8002bf8:	7308      	strb	r0, [r1, #12]
 8002bfa:	8ab0      	ldrh	r0, [r6, #20]
 8002bfc:	03a1      	lsls	r1, r4, #14
 8002bfe:	4288      	cmp	r0, r1
 8002c00:	d139      	bne.n	8002c76 <__iar_annotation$$branch+0x726>
 8002c02:	68a8      	ldr	r0, [r5, #8]
 8002c04:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c06:	2b00      	cmp	r3, #0
 8002c08:	d005      	beq.n	8002c16 <__iar_annotation$$branch+0x6c6>
 8002c0a:	220f      	movs	r2, #15
 8002c0c:	2100      	movs	r1, #0
 8002c0e:	7b2f      	ldrb	r7, [r5, #12]
 8002c10:	07f8      	lsls	r0, r7, #31
 8002c12:	0fc0      	lsrs	r0, r0, #31
 8002c14:	4798      	blx	r3
 8002c16:	2000      	movs	r0, #0
 8002c18:	82b0      	strh	r0, [r6, #20]
 8002c1a:	200f      	movs	r0, #15
 8002c1c:	e175      	b.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002c1e:	68a8      	ldr	r0, [r5, #8]
 8002c20:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c22:	2701      	movs	r7, #1
 8002c24:	2b00      	cmp	r3, #0
 8002c26:	d00f      	beq.n	8002c48 <__iar_annotation$$branch+0x6f8>
 8002c28:	220a      	movs	r2, #10
 8002c2a:	68e9      	ldr	r1, [r5, #12]
 8002c2c:	2001      	movs	r0, #1
 8002c2e:	4008      	ands	r0, r1
 8002c30:	2100      	movs	r1, #0
 8002c32:	4798      	blx	r3
 8002c34:	68a8      	ldr	r0, [r5, #8]
 8002c36:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c38:	2b00      	cmp	r3, #0
 8002c3a:	d005      	beq.n	8002c48 <__iar_annotation$$branch+0x6f8>
 8002c3c:	220b      	movs	r2, #11
 8002c3e:	68e9      	ldr	r1, [r5, #12]
 8002c40:	2001      	movs	r0, #1
 8002c42:	4008      	ands	r0, r1
 8002c44:	2101      	movs	r1, #1
 8002c46:	4798      	blx	r3
 8002c48:	2000      	movs	r0, #0
 8002c4a:	9000      	str	r0, [sp, #0]
 8002c4c:	235b      	movs	r3, #91	; 0x5b
 8002c4e:	2206      	movs	r2, #6
 8002c50:	2100      	movs	r1, #0
 8002c52:	0028      	movs	r0, r5
 8002c54:	f000 fd8d 	bl	8003772 <PE_Send_CtrlMessage>
 8002c58:	2800      	cmp	r0, #0
 8002c5a:	d10f      	bne.n	8002c7c <__iar_annotation$$branch+0x72c>
 8002c5c:	68a8      	ldr	r0, [r5, #8]
 8002c5e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c60:	2b00      	cmp	r3, #0
 8002c62:	d005      	beq.n	8002c70 <__iar_annotation$$branch+0x720>
 8002c64:	220c      	movs	r2, #12
 8002c66:	2100      	movs	r1, #0
 8002c68:	68e8      	ldr	r0, [r5, #12]
 8002c6a:	4007      	ands	r7, r0
 8002c6c:	0038      	movs	r0, r7
 8002c6e:	4798      	blx	r3
 8002c70:	4801      	ldr	r0, [pc, #4]	; (8002c78 <__iar_annotation$$branch+0x728>)
 8002c72:	8430      	strh	r0, [r6, #32]
 8002c74:	2414      	movs	r4, #20
 8002c76:	e149      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002c78:	00008014 	.word	0x00008014
 8002c7c:	68a8      	ldr	r0, [r5, #8]
 8002c7e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c80:	2b00      	cmp	r3, #0
 8002c82:	d0f8      	beq.n	8002c76 <__iar_annotation$$branch+0x726>
 8002c84:	220f      	movs	r2, #15
 8002c86:	2100      	movs	r1, #0
 8002c88:	7b2f      	ldrb	r7, [r5, #12]
 8002c8a:	07f8      	lsls	r0, r7, #31
 8002c8c:	0fc0      	lsrs	r0, r0, #31
 8002c8e:	4798      	blx	r3
 8002c90:	e13c      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002c92:	8c30      	ldrh	r0, [r6, #32]
 8002c94:	03a1      	lsls	r1, r4, #14
 8002c96:	4288      	cmp	r0, r1
 8002c98:	d1fa      	bne.n	8002c90 <__iar_annotation$$branch+0x740>
 8002c9a:	2000      	movs	r0, #0
 8002c9c:	8430      	strh	r0, [r6, #32]
 8002c9e:	2101      	movs	r1, #1
 8002ca0:	0028      	movs	r0, r5
 8002ca2:	f000 fe7b 	bl	800399c <PE_ChangePowerRole>
 8002ca6:	0028      	movs	r0, r5
 8002ca8:	f001 fb22 	bl	80042f0 <PE_ResetDuringSwap>
 8002cac:	68a8      	ldr	r0, [r5, #8]
 8002cae:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002cb0:	2b00      	cmp	r3, #0
 8002cb2:	d005      	beq.n	8002cc0 <__iar_annotation$$branch+0x770>
 8002cb4:	220e      	movs	r2, #14
 8002cb6:	2101      	movs	r1, #1
 8002cb8:	7b2f      	ldrb	r7, [r5, #12]
 8002cba:	07f8      	lsls	r0, r7, #31
 8002cbc:	0fc0      	lsrs	r0, r0, #31
 8002cbe:	4798      	blx	r3
 8002cc0:	4808      	ldr	r0, [pc, #32]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002cc2:	7800      	ldrb	r0, [r0, #0]
 8002cc4:	0780      	lsls	r0, r0, #30
 8002cc6:	d50a      	bpl.n	8002cde <__iar_annotation$$branch+0x78e>
 8002cc8:	2000      	movs	r0, #0
 8002cca:	9000      	str	r0, [sp, #0]
 8002ccc:	2300      	movs	r3, #0
 8002cce:	2215      	movs	r2, #21
 8002cd0:	7b28      	ldrb	r0, [r5, #12]
 8002cd2:	07c1      	lsls	r1, r0, #31
 8002cd4:	0fc9      	lsrs	r1, r1, #31
 8002cd6:	2009      	movs	r0, #9
 8002cd8:	4f02      	ldr	r7, [pc, #8]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002cda:	68ff      	ldr	r7, [r7, #12]
 8002cdc:	47b8      	blx	r7
 8002cde:	2115      	movs	r1, #21
 8002ce0:	e0b8      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 8002ce2:	bf00      	nop
 8002ce4:	200019e8 	.word	0x200019e8
 8002ce8:	ab05      	add	r3, sp, #20
 8002cea:	aa08      	add	r2, sp, #32
 8002cec:	2100      	movs	r1, #0
 8002cee:	7b2f      	ldrb	r7, [r5, #12]
 8002cf0:	07f8      	lsls	r0, r7, #31
 8002cf2:	0fc0      	lsrs	r0, r0, #31
 8002cf4:	68af      	ldr	r7, [r5, #8]
 8002cf6:	69bf      	ldr	r7, [r7, #24]
 8002cf8:	47b8      	blx	r7
 8002cfa:	2000      	movs	r0, #0
 8002cfc:	9002      	str	r0, [sp, #8]
 8002cfe:	2003      	movs	r0, #3
 8002d00:	9001      	str	r0, [sp, #4]
 8002d02:	9805      	ldr	r0, [sp, #20]
 8002d04:	0880      	lsrs	r0, r0, #2
 8002d06:	9000      	str	r0, [sp, #0]
 8002d08:	ab08      	add	r3, sp, #32
 8002d0a:	2201      	movs	r2, #1
 8002d0c:	2100      	movs	r1, #0
 8002d0e:	0028      	movs	r0, r5
 8002d10:	f000 fd76 	bl	8003800 <PE_Send_DataMessage>
 8002d14:	e0fa      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002d16:	9402      	str	r4, [sp, #8]
 8002d18:	2003      	movs	r0, #3
 8002d1a:	9001      	str	r0, [sp, #4]
 8002d1c:	2001      	movs	r0, #1
 8002d1e:	9000      	str	r0, [sp, #0]
 8002d20:	20e3      	movs	r0, #227	; 0xe3
 8002d22:	0080      	lsls	r0, r0, #2
 8002d24:	182b      	adds	r3, r5, r0
 8002d26:	2206      	movs	r2, #6
 8002d28:	2100      	movs	r1, #0
 8002d2a:	0028      	movs	r0, r5
 8002d2c:	f000 fd68 	bl	8003800 <PE_Send_DataMessage>
 8002d30:	e0ec      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002d32:	9400      	str	r4, [sp, #0]
 8002d34:	2366      	movs	r3, #102	; 0x66
 8002d36:	2214      	movs	r2, #20
 8002d38:	2100      	movs	r1, #0
 8002d3a:	0028      	movs	r0, r5
 8002d3c:	f000 fd19 	bl	8003772 <PE_Send_CtrlMessage>
 8002d40:	2800      	cmp	r0, #0
 8002d42:	d1f5      	bne.n	8002d30 <__iar_annotation$$branch+0x7e0>
 8002d44:	8337      	strh	r7, [r6, #24]
 8002d46:	241a      	movs	r4, #26
 8002d48:	4fa8      	ldr	r7, [pc, #672]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002d4a:	7838      	ldrb	r0, [r7, #0]
 8002d4c:	0780      	lsls	r0, r0, #30
 8002d4e:	d509      	bpl.n	8002d64 <__iar_annotation$$branch+0x814>
 8002d50:	2000      	movs	r0, #0
 8002d52:	9000      	str	r0, [sp, #0]
 8002d54:	2300      	movs	r3, #0
 8002d56:	2247      	movs	r2, #71	; 0x47
 8002d58:	7b28      	ldrb	r0, [r5, #12]
 8002d5a:	07c1      	lsls	r1, r0, #31
 8002d5c:	0fc9      	lsrs	r1, r1, #31
 8002d5e:	2009      	movs	r0, #9
 8002d60:	68ff      	ldr	r7, [r7, #12]
 8002d62:	47b8      	blx	r7
 8002d64:	2147      	movs	r1, #71	; 0x47
 8002d66:	7b2a      	ldrb	r2, [r5, #12]
 8002d68:	07d0      	lsls	r0, r2, #31
 8002d6a:	0fc0      	lsrs	r0, r0, #31
 8002d6c:	68aa      	ldr	r2, [r5, #8]
 8002d6e:	68d2      	ldr	r2, [r2, #12]
 8002d70:	4790      	blx	r2
 8002d72:	200b      	movs	r0, #11
 8002d74:	82e8      	strh	r0, [r5, #22]
 8002d76:	e0c9      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002d78:	2911      	cmp	r1, #17
 8002d7a:	d107      	bne.n	8002d8c <__iar_annotation$$branch+0x83c>
 8002d7c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002d7e:	0bc0      	lsrs	r0, r0, #15
 8002d80:	d004      	beq.n	8002d8c <__iar_annotation$$branch+0x83c>
 8002d82:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002d84:	0b00      	lsrs	r0, r0, #12
 8002d86:	0740      	lsls	r0, r0, #29
 8002d88:	d000      	beq.n	8002d8c <__iar_annotation$$branch+0x83c>
 8002d8a:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002d8c:	8b30      	ldrh	r0, [r6, #24]
 8002d8e:	03a1      	lsls	r1, r4, #14
 8002d90:	4288      	cmp	r0, r1
 8002d92:	d1f0      	bne.n	8002d76 <__iar_annotation$$branch+0x826>
 8002d94:	2000      	movs	r0, #0
 8002d96:	8330      	strh	r0, [r6, #24]
 8002d98:	2003      	movs	r0, #3
 8002d9a:	7130      	strb	r0, [r6, #4]
 8002d9c:	e07a      	b.n	8002e94 <__iar_annotation$$branch+0x944>
 8002d9e:	9400      	str	r4, [sp, #0]
 8002da0:	2339      	movs	r3, #57	; 0x39
 8002da2:	20e5      	movs	r0, #229	; 0xe5
 8002da4:	0080      	lsls	r0, r0, #2
 8002da6:	5c2a      	ldrb	r2, [r5, r0]
 8002da8:	2100      	movs	r1, #0
 8002daa:	0028      	movs	r0, r5
 8002dac:	f000 fce1 	bl	8003772 <PE_Send_CtrlMessage>
 8002db0:	2800      	cmp	r0, #0
 8002db2:	d139      	bne.n	8002e28 <__iar_annotation$$branch+0x8d8>
 8002db4:	20e5      	movs	r0, #229	; 0xe5
 8002db6:	0080      	lsls	r0, r0, #2
 8002db8:	1828      	adds	r0, r5, r0
 8002dba:	8840      	ldrh	r0, [r0, #2]
 8002dbc:	82e8      	strh	r0, [r5, #22]
 8002dbe:	6868      	ldr	r0, [r5, #4]
 8002dc0:	7841      	ldrb	r1, [r0, #1]
 8002dc2:	228f      	movs	r2, #143	; 0x8f
 8002dc4:	400a      	ands	r2, r1
 8002dc6:	2130      	movs	r1, #48	; 0x30
 8002dc8:	4311      	orrs	r1, r2
 8002dca:	7041      	strb	r1, [r0, #1]
 8002dcc:	4887      	ldr	r0, [pc, #540]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002dce:	7800      	ldrb	r0, [r0, #0]
 8002dd0:	0780      	lsls	r0, r0, #30
 8002dd2:	d50a      	bpl.n	8002dea <__iar_annotation$$branch+0x89a>
 8002dd4:	2000      	movs	r0, #0
 8002dd6:	9000      	str	r0, [sp, #0]
 8002dd8:	2300      	movs	r3, #0
 8002dda:	2256      	movs	r2, #86	; 0x56
 8002ddc:	7b28      	ldrb	r0, [r5, #12]
 8002dde:	07c1      	lsls	r1, r0, #31
 8002de0:	0fc9      	lsrs	r1, r1, #31
 8002de2:	2009      	movs	r0, #9
 8002de4:	4c81      	ldr	r4, [pc, #516]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002de6:	68e4      	ldr	r4, [r4, #12]
 8002de8:	47a0      	blx	r4
 8002dea:	2156      	movs	r1, #86	; 0x56
 8002dec:	7b2a      	ldrb	r2, [r5, #12]
 8002dee:	07d0      	lsls	r0, r2, #31
 8002df0:	0fc0      	lsrs	r0, r0, #31
 8002df2:	68aa      	ldr	r2, [r5, #8]
 8002df4:	68d2      	ldr	r2, [r2, #12]
 8002df6:	4790      	blx	r2
 8002df8:	4c7c      	ldr	r4, [pc, #496]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002dfa:	7820      	ldrb	r0, [r4, #0]
 8002dfc:	0780      	lsls	r0, r0, #30
 8002dfe:	d509      	bpl.n	8002e14 <__iar_annotation$$branch+0x8c4>
 8002e00:	2000      	movs	r0, #0
 8002e02:	9000      	str	r0, [sp, #0]
 8002e04:	2300      	movs	r3, #0
 8002e06:	2241      	movs	r2, #65	; 0x41
 8002e08:	7b28      	ldrb	r0, [r5, #12]
 8002e0a:	07c1      	lsls	r1, r0, #31
 8002e0c:	0fc9      	lsrs	r1, r1, #31
 8002e0e:	2009      	movs	r0, #9
 8002e10:	68e4      	ldr	r4, [r4, #12]
 8002e12:	47a0      	blx	r4
 8002e14:	2141      	movs	r1, #65	; 0x41
 8002e16:	7b2a      	ldrb	r2, [r5, #12]
 8002e18:	07d0      	lsls	r0, r2, #31
 8002e1a:	0fc0      	lsrs	r0, r0, #31
 8002e1c:	68aa      	ldr	r2, [r5, #8]
 8002e1e:	68d2      	ldr	r2, [r2, #12]
 8002e20:	4790      	blx	r2
 8002e22:	8337      	strh	r7, [r6, #24]
 8002e24:	241a      	movs	r4, #26
 8002e26:	e071      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e28:	6868      	ldr	r0, [r5, #4]
 8002e2a:	7841      	ldrb	r1, [r0, #1]
 8002e2c:	228f      	movs	r2, #143	; 0x8f
 8002e2e:	400a      	ands	r2, r1
 8002e30:	2130      	movs	r1, #48	; 0x30
 8002e32:	4311      	orrs	r1, r2
 8002e34:	7041      	strb	r1, [r0, #1]
 8002e36:	4f6d      	ldr	r7, [pc, #436]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002e38:	7838      	ldrb	r0, [r7, #0]
 8002e3a:	0780      	lsls	r0, r0, #30
 8002e3c:	d509      	bpl.n	8002e52 <__iar_annotation$$branch+0x902>
 8002e3e:	2000      	movs	r0, #0
 8002e40:	9000      	str	r0, [sp, #0]
 8002e42:	2300      	movs	r3, #0
 8002e44:	2256      	movs	r2, #86	; 0x56
 8002e46:	7b28      	ldrb	r0, [r5, #12]
 8002e48:	07c1      	lsls	r1, r0, #31
 8002e4a:	0fc9      	lsrs	r1, r1, #31
 8002e4c:	2009      	movs	r0, #9
 8002e4e:	68ff      	ldr	r7, [r7, #12]
 8002e50:	47b8      	blx	r7
 8002e52:	2156      	movs	r1, #86	; 0x56
 8002e54:	7b2a      	ldrb	r2, [r5, #12]
 8002e56:	07d0      	lsls	r0, r2, #31
 8002e58:	0fc0      	lsrs	r0, r0, #31
 8002e5a:	68aa      	ldr	r2, [r5, #8]
 8002e5c:	68d2      	ldr	r2, [r2, #12]
 8002e5e:	4790      	blx	r2
 8002e60:	e054      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e62:	8b30      	ldrh	r0, [r6, #24]
 8002e64:	03a2      	lsls	r2, r4, #14
 8002e66:	4290      	cmp	r0, r2
 8002e68:	d10a      	bne.n	8002e80 <__iar_annotation$$branch+0x930>
 8002e6a:	2000      	movs	r0, #0
 8002e6c:	8330      	strh	r0, [r6, #24]
 8002e6e:	2103      	movs	r1, #3
 8002e70:	22e5      	movs	r2, #229	; 0xe5
 8002e72:	0092      	lsls	r2, r2, #2
 8002e74:	5caa      	ldrb	r2, [r5, r2]
 8002e76:	2a11      	cmp	r2, #17
 8002e78:	7131      	strb	r1, [r6, #4]
 8002e7a:	d147      	bne.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e7c:	2400      	movs	r4, #0
 8002e7e:	e045      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e80:	2914      	cmp	r1, #20
 8002e82:	d043      	beq.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e84:	2000      	movs	r0, #0
 8002e86:	8330      	strh	r0, [r6, #24]
 8002e88:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002e8a:	0bc0      	lsrs	r0, r0, #15
 8002e8c:	d006      	beq.n	8002e9c <__iar_annotation$$branch+0x94c>
 8002e8e:	0028      	movs	r0, r5
 8002e90:	f001 f842 	bl	8003f18 <PE_Check_ExtendedMessage>
 8002e94:	2014      	movs	r0, #20
 8002e96:	4669      	mov	r1, sp
 8002e98:	7308      	strb	r0, [r1, #12]
 8002e9a:	e037      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e9c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002e9e:	0bc0      	lsrs	r0, r0, #15
 8002ea0:	d10b      	bne.n	8002eba <__iar_annotation$$branch+0x96a>
 8002ea2:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002ea4:	0b00      	lsrs	r0, r0, #12
 8002ea6:	0740      	lsls	r0, r0, #29
 8002ea8:	d107      	bne.n	8002eba <__iar_annotation$$branch+0x96a>
 8002eaa:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002eac:	06c0      	lsls	r0, r0, #27
 8002eae:	0ec0      	lsrs	r0, r0, #27
 8002eb0:	2810      	cmp	r0, #16
 8002eb2:	d102      	bne.n	8002eba <__iar_annotation$$branch+0x96a>
 8002eb4:	2014      	movs	r0, #20
 8002eb6:	4669      	mov	r1, sp
 8002eb8:	7308      	strb	r0, [r1, #12]
 8002eba:	2000      	movs	r0, #0
 8002ebc:	8330      	strh	r0, [r6, #24]
 8002ebe:	2003      	movs	r0, #3
 8002ec0:	e023      	b.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002ec2:	0028      	movs	r0, r5
 8002ec4:	f001 fb51 	bl	800456a <PE_SubStateMachine_ExtendedMessages>
 8002ec8:	e003      	b.n	8002ed2 <__iar_annotation$$branch+0x982>
 8002eca:	a903      	add	r1, sp, #12
 8002ecc:	0028      	movs	r0, r5
 8002ece:	f001 fc63 	bl	8004798 <PE_SubStateMachine_Generic>
 8002ed2:	0004      	movs	r4, r0
 8002ed4:	e01a      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002ed6:	a903      	add	r1, sp, #12
 8002ed8:	0028      	movs	r0, r5
 8002eda:	f001 fdcf 	bl	8004a7c <PE_SubStateMachine_VconnSwap>
 8002ede:	0004      	movs	r4, r0
 8002ee0:	6868      	ldr	r0, [r5, #4]
 8002ee2:	6800      	ldr	r0, [r0, #0]
 8002ee4:	0340      	lsls	r0, r0, #13
 8002ee6:	0fc1      	lsrs	r1, r0, #31
 8002ee8:	4668      	mov	r0, sp
 8002eea:	7b40      	ldrb	r0, [r0, #13]
 8002eec:	f002 f855 	bl	8004f9a <USBPD_PRL_CableCapable>
 8002ef0:	e00c      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002ef2:	2106      	movs	r1, #6
 8002ef4:	4668      	mov	r0, sp
 8002ef6:	7b40      	ldrb	r0, [r0, #13]
 8002ef8:	f006 fc56 	bl	80097a8 <USBPD_PHY_ResetRequest>
 8002efc:	6868      	ldr	r0, [r5, #4]
 8002efe:	7840      	ldrb	r0, [r0, #1]
 8002f00:	0640      	lsls	r0, r0, #25
 8002f02:	0f40      	lsrs	r0, r0, #29
 8002f04:	2803      	cmp	r0, #3
 8002f06:	d000      	beq.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002f08:	2043      	movs	r0, #67	; 0x43
 8002f0a:	7130      	strb	r0, [r6, #4]
 8002f0c:	4837      	ldr	r0, [pc, #220]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002f0e:	68c7      	ldr	r7, [r0, #12]
 8002f10:	2f00      	cmp	r7, #0
 8002f12:	d00f      	beq.n	8002f34 <__iar_annotation$$branch+0x9e4>
 8002f14:	7800      	ldrb	r0, [r0, #0]
 8002f16:	07c0      	lsls	r0, r0, #31
 8002f18:	d50c      	bpl.n	8002f34 <__iar_annotation$$branch+0x9e4>
 8002f1a:	7932      	ldrb	r2, [r6, #4]
 8002f1c:	7970      	ldrb	r0, [r6, #5]
 8002f1e:	4290      	cmp	r0, r2
 8002f20:	d008      	beq.n	8002f34 <__iar_annotation$$branch+0x9e4>
 8002f22:	7172      	strb	r2, [r6, #5]
 8002f24:	2000      	movs	r0, #0
 8002f26:	9000      	str	r0, [sp, #0]
 8002f28:	2300      	movs	r3, #0
 8002f2a:	7b28      	ldrb	r0, [r5, #12]
 8002f2c:	07c1      	lsls	r1, r0, #31
 8002f2e:	0fc9      	lsrs	r1, r1, #31
 8002f30:	2004      	movs	r0, #4
 8002f32:	47b8      	blx	r7
 8002f34:	4668      	mov	r0, sp
 8002f36:	7b00      	ldrb	r0, [r0, #12]
 8002f38:	2814      	cmp	r0, #20
 8002f3a:	d01d      	beq.n	8002f78 <__iar_annotation$$branch+0xa28>
 8002f3c:	0028      	movs	r0, r5
 8002f3e:	f000 fd69 	bl	8003a14 <PE_Check_AMSConflict>
 8002f42:	2815      	cmp	r0, #21
 8002f44:	d102      	bne.n	8002f4c <__iar_annotation$$branch+0x9fc>
 8002f46:	2014      	movs	r0, #20
 8002f48:	4669      	mov	r1, sp
 8002f4a:	7308      	strb	r0, [r1, #12]
 8002f4c:	4827      	ldr	r0, [pc, #156]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002f4e:	68c4      	ldr	r4, [r0, #12]
 8002f50:	2c00      	cmp	r4, #0
 8002f52:	d00f      	beq.n	8002f74 <__iar_annotation$$branch+0xa24>
 8002f54:	7800      	ldrb	r0, [r0, #0]
 8002f56:	07c0      	lsls	r0, r0, #31
 8002f58:	d50c      	bpl.n	8002f74 <__iar_annotation$$branch+0xa24>
 8002f5a:	7932      	ldrb	r2, [r6, #4]
 8002f5c:	7970      	ldrb	r0, [r6, #5]
 8002f5e:	4290      	cmp	r0, r2
 8002f60:	d008      	beq.n	8002f74 <__iar_annotation$$branch+0xa24>
 8002f62:	7172      	strb	r2, [r6, #5]
 8002f64:	2000      	movs	r0, #0
 8002f66:	9000      	str	r0, [sp, #0]
 8002f68:	2300      	movs	r3, #0
 8002f6a:	7b28      	ldrb	r0, [r5, #12]
 8002f6c:	07c1      	lsls	r1, r0, #31
 8002f6e:	0fc9      	lsrs	r1, r1, #31
 8002f70:	2004      	movs	r0, #4
 8002f72:	47a0      	blx	r4
 8002f74:	2400      	movs	r4, #0
 8002f76:	e012      	b.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f78:	7930      	ldrb	r0, [r6, #4]
 8002f7a:	2803      	cmp	r0, #3
 8002f7c:	d10f      	bne.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f7e:	200a      	movs	r0, #10
 8002f80:	5e30      	ldrsh	r0, [r6, r0]
 8002f82:	2800      	cmp	r0, #0
 8002f84:	d00b      	beq.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f86:	2116      	movs	r1, #22
 8002f88:	5e69      	ldrsh	r1, [r5, r1]
 8002f8a:	2900      	cmp	r1, #0
 8002f8c:	d107      	bne.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f8e:	7a31      	ldrb	r1, [r6, #8]
 8002f90:	7131      	strb	r1, [r6, #4]
 8002f92:	7a71      	ldrb	r1, [r6, #9]
 8002f94:	71f1      	strb	r1, [r6, #7]
 8002f96:	82e8      	strh	r0, [r5, #22]
 8002f98:	2000      	movs	r0, #0
 8002f9a:	8170      	strh	r0, [r6, #10]
 8002f9c:	2401      	movs	r4, #1
 8002f9e:	9807      	ldr	r0, [sp, #28]
 8002fa0:	2800      	cmp	r0, #0
 8002fa2:	d01d      	beq.n	8002fe0 <__iar_annotation$$branch+0xa90>
 8002fa4:	4811      	ldr	r0, [pc, #68]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002fa6:	6901      	ldr	r1, [r0, #16]
 8002fa8:	4aa9      	ldr	r2, [pc, #676]	; (8003250 <.text_23>)
 8002faa:	4291      	cmp	r1, r2
 8002fac:	d018      	beq.n	8002fe0 <__iar_annotation$$branch+0xa90>
 8002fae:	2101      	movs	r1, #1
 8002fb0:	1d02      	adds	r2, r0, #4
 8002fb2:	68eb      	ldr	r3, [r5, #12]
 8002fb4:	400b      	ands	r3, r1
 8002fb6:	009b      	lsls	r3, r3, #2
 8002fb8:	58d2      	ldr	r2, [r2, r3]
 8002fba:	68d7      	ldr	r7, [r2, #12]
 8002fbc:	0b3e      	lsrs	r6, r7, #12
 8002fbe:	1c76      	adds	r6, r6, #1
 8002fc0:	4ba4      	ldr	r3, [pc, #656]	; (8003254 <.text_24>)
 8002fc2:	401f      	ands	r7, r3
 8002fc4:	0336      	lsls	r6, r6, #12
 8002fc6:	433e      	orrs	r6, r7
 8002fc8:	60d6      	str	r6, [r2, #12]
 8002fca:	1d00      	adds	r0, r0, #4
 8002fcc:	68ea      	ldr	r2, [r5, #12]
 8002fce:	4011      	ands	r1, r2
 8002fd0:	0089      	lsls	r1, r1, #2
 8002fd2:	5840      	ldr	r0, [r0, r1]
 8002fd4:	68c1      	ldr	r1, [r0, #12]
 8002fd6:	0b0a      	lsrs	r2, r1, #12
 8002fd8:	2a08      	cmp	r2, #8
 8002fda:	db01      	blt.n	8002fe0 <__iar_annotation$$branch+0xa90>
 8002fdc:	400b      	ands	r3, r1
 8002fde:	60c3      	str	r3, [r0, #12]
 8002fe0:	2c00      	cmp	r4, #0
 8002fe2:	d00a      	beq.n	8002ffa <__iar_annotation$$branch+0xaaa>
 8002fe4:	0020      	movs	r0, r4
 8002fe6:	b00f      	add	sp, #60	; 0x3c
 8002fe8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002fea:	bf00      	nop
 8002fec:	200019e8 	.word	0x200019e8
 8002ff0:	4668      	mov	r0, sp
 8002ff2:	7345      	strb	r5, [r0, #13]
 8002ff4:	9d06      	ldr	r5, [sp, #24]
 8002ff6:	9407      	str	r4, [sp, #28]
 8002ff8:	9606      	str	r6, [sp, #24]
 8002ffa:	2402      	movs	r4, #2
 8002ffc:	20d5      	movs	r0, #213	; 0xd5
 8002ffe:	0080      	lsls	r0, r0, #2
 8003000:	182e      	adds	r6, r5, r0
 8003002:	7832      	ldrb	r2, [r6, #0]
 8003004:	2a0f      	cmp	r2, #15
 8003006:	d115      	bne.n	8003034 <__iar_annotation$$branch+0xae4>
 8003008:	7132      	strb	r2, [r6, #4]
 800300a:	2000      	movs	r0, #0
 800300c:	7030      	strb	r0, [r6, #0]
 800300e:	4892      	ldr	r0, [pc, #584]	; (8003258 <.text_25>)
 8003010:	68c7      	ldr	r7, [r0, #12]
 8003012:	2f00      	cmp	r7, #0
 8003014:	d00e      	beq.n	8003034 <__iar_annotation$$branch+0xae4>
 8003016:	7800      	ldrb	r0, [r0, #0]
 8003018:	07c0      	lsls	r0, r0, #31
 800301a:	d50b      	bpl.n	8003034 <__iar_annotation$$branch+0xae4>
 800301c:	7970      	ldrb	r0, [r6, #5]
 800301e:	4290      	cmp	r0, r2
 8003020:	d008      	beq.n	8003034 <__iar_annotation$$branch+0xae4>
 8003022:	7172      	strb	r2, [r6, #5]
 8003024:	2000      	movs	r0, #0
 8003026:	9000      	str	r0, [sp, #0]
 8003028:	2300      	movs	r3, #0
 800302a:	7b28      	ldrb	r0, [r5, #12]
 800302c:	07c1      	lsls	r1, r0, #31
 800302e:	0fc9      	lsrs	r1, r1, #31
 8003030:	2004      	movs	r0, #4
 8003032:	47b8      	blx	r7
 8003034:	9806      	ldr	r0, [sp, #24]
 8003036:	2800      	cmp	r0, #0
 8003038:	d006      	beq.n	8003048 <__iar_annotation$$branch+0xaf8>
 800303a:	2107      	movs	r1, #7
 800303c:	f002 fe2a 	bl	8005c94 <__aeabi_idivmod>
 8003040:	2900      	cmp	r1, #0
 8003042:	d101      	bne.n	8003048 <__iar_annotation$$branch+0xaf8>
 8003044:	2001      	movs	r0, #1
 8003046:	9007      	str	r0, [sp, #28]
 8003048:	4983      	ldr	r1, [pc, #524]	; (8003258 <.text_25>)
 800304a:	7808      	ldrb	r0, [r1, #0]
 800304c:	4020      	ands	r0, r4
 800304e:	68c9      	ldr	r1, [r1, #12]
 8003050:	9101      	str	r1, [sp, #4]
 8003052:	4669      	mov	r1, sp
 8003054:	7b09      	ldrb	r1, [r1, #12]
 8003056:	4f81      	ldr	r7, [pc, #516]	; (800325c <.text_26>)
 8003058:	7932      	ldrb	r2, [r6, #4]
 800305a:	2a00      	cmp	r2, #0
 800305c:	d101      	bne.n	8003062 <__iar_annotation$$branch+0x4>

0800305e <__iar_annotation$$branch>:
 800305e:	f7fe fe4e 	bl	8001cfe <__iar_annotation$$branch+0x4>
 8003062:	1e52      	subs	r2, r2, #1
 8003064:	d046      	beq.n	80030f4 <__iar_annotation$$branch+0x2c>
 8003066:	1e92      	subs	r2, r2, #2
 8003068:	d101      	bne.n	800306e <__iar_annotation$$branch+0x4>

0800306a <__iar_annotation$$branch>:
 800306a:	f7ff fa41 	bl	80024f0 <__iar_annotation$$branch+0x26>
 800306e:	1e52      	subs	r2, r2, #1
 8003070:	d101      	bne.n	8003076 <__iar_annotation$$branch+0x4>

08003072 <__iar_annotation$$branch>:
 8003072:	f7ff fa54 	bl	800251e <__iar_annotation$$branch+0x54>
 8003076:	3a0b      	subs	r2, #11
 8003078:	d101      	bne.n	800307e <__iar_annotation$$branch+0x4>

0800307a <__iar_annotation$$branch>:
 800307a:	f7fe ffdb 	bl	8002034 <__iar_annotation$$branch+0x202>
 800307e:	1e52      	subs	r2, r2, #1
 8003080:	d101      	bne.n	8003086 <__iar_annotation$$branch+0x4>

08003082 <__iar_annotation$$branch>:
 8003082:	f7ff f894 	bl	80021ae <__iar_annotation$$branch+0x37c>
 8003086:	1e52      	subs	r2, r2, #1
 8003088:	d101      	bne.n	800308e <__iar_annotation$$branch+0x4>

0800308a <__iar_annotation$$branch>:
 800308a:	f7ff f8ab 	bl	80021e4 <__iar_annotation$$branch+0x3b2>
 800308e:	1fd2      	subs	r2, r2, #7
 8003090:	d101      	bne.n	8003096 <__iar_annotation$$branch+0x4>

08003092 <__iar_annotation$$branch>:
 8003092:	f7ff f996 	bl	80023c2 <__iar_annotation$$branch+0x4>
 8003096:	1e92      	subs	r2, r2, #2
 8003098:	d101      	bne.n	800309e <__iar_annotation$$branch+0x4>

0800309a <__iar_annotation$$branch>:
 800309a:	f7ff f91c 	bl	80022d6 <__iar_annotation$$branch+0x66>
 800309e:	1ed2      	subs	r2, r2, #3
 80030a0:	d101      	bne.n	80030a6 <__iar_annotation$$branch+0x4>

080030a2 <__iar_annotation$$branch>:
 80030a2:	f7ff f8e7 	bl	8002274 <__iar_annotation$$branch+0x4>
 80030a6:	1e52      	subs	r2, r2, #1
 80030a8:	d100      	bne.n	80030ac <__iar_annotation$$branch+0xa>
 80030aa:	e4c0      	b.n	8002a2e <__iar_annotation$$branch+0x4de>
 80030ac:	1f12      	subs	r2, r2, #4
 80030ae:	d101      	bne.n	80030b4 <__iar_annotation$$branch+0x4>

080030b0 <__iar_annotation$$branch>:
 80030b0:	f7ff fb88 	bl	80027c4 <__iar_annotation$$branch+0x274>
 80030b4:	1f52      	subs	r2, r2, #5
 80030b6:	d101      	bne.n	80030bc <__iar_annotation$$branch+0x4>

080030b8 <__iar_annotation$$branch>:
 80030b8:	f7ff f93f 	bl	800233a <__iar_annotation$$branch+0x4>
 80030bc:	1e92      	subs	r2, r2, #2
 80030be:	d101      	bne.n	80030c4 <__iar_annotation$$branch+0x4>

080030c0 <__iar_annotation$$branch>:
 80030c0:	f7ff f927 	bl	8002312 <__iar_annotation$$branch+0xa2>
 80030c4:	1e52      	subs	r2, r2, #1
 80030c6:	d101      	bne.n	80030cc <__iar_annotation$$branch+0x4>

080030c8 <__iar_annotation$$branch>:
 80030c8:	f7ff fa01 	bl	80024ce <__iar_annotation$$branch+0x4>
 80030cc:	1e52      	subs	r2, r2, #1
 80030ce:	d100      	bne.n	80030d2 <__iar_annotation$$branch+0xa>
 80030d0:	e621      	b.n	8002d16 <__iar_annotation$$branch+0x7c6>
 80030d2:	1e52      	subs	r2, r2, #1
 80030d4:	d00e      	beq.n	80030f4 <__iar_annotation$$branch+0x2c>
 80030d6:	1e92      	subs	r2, r2, #2
 80030d8:	d100      	bne.n	80030dc <__iar_annotation$$branch+0x14>
 80030da:	e660      	b.n	8002d9e <__iar_annotation$$branch+0x84e>
 80030dc:	1e52      	subs	r2, r2, #1
 80030de:	2a01      	cmp	r2, #1
 80030e0:	d908      	bls.n	80030f4 <__iar_annotation$$branch+0x2c>
 80030e2:	1e92      	subs	r2, r2, #2
 80030e4:	2a07      	cmp	r2, #7
 80030e6:	d800      	bhi.n	80030ea <__iar_annotation$$branch+0x22>
 80030e8:	e6eb      	b.n	8002ec2 <__iar_annotation$$branch+0x972>
 80030ea:	3a08      	subs	r2, #8
 80030ec:	d100      	bne.n	80030f0 <__iar_annotation$$branch+0x28>
 80030ee:	e6b8      	b.n	8002e62 <__iar_annotation$$branch+0x912>
 80030f0:	1e52      	subs	r2, r2, #1
 80030f2:	2a03      	cmp	r2, #3
 80030f4:	d800      	bhi.n	80030f8 <__iar_annotation$$branch+0x30>
 80030f6:	e6e8      	b.n	8002eca <__iar_annotation$$branch+0x97a>
 80030f8:	1f12      	subs	r2, r2, #4
 80030fa:	d101      	bne.n	8003100 <__iar_annotation$$branch+0x4>

080030fc <__iar_annotation$$branch>:
 80030fc:	f7fe fe08 	bl	8001d10 <__iar_annotation$$branch+0x4>
 8003100:	1e52      	subs	r2, r2, #1
 8003102:	d101      	bne.n	8003108 <__iar_annotation$$branch+0x4>

08003104 <__iar_annotation$$branch>:
 8003104:	f7fe ffd6 	bl	80020b4 <__iar_annotation$$branch+0x282>
 8003108:	1e52      	subs	r2, r2, #1
 800310a:	d101      	bne.n	8003110 <__iar_annotation$$branch+0x4>

0800310c <__iar_annotation$$branch>:
 800310c:	f7ff f82a 	bl	8002164 <__iar_annotation$$branch+0x332>
 8003110:	1ed2      	subs	r2, r2, #3
 8003112:	d101      	bne.n	8003118 <__iar_annotation$$branch+0x4>

08003114 <__iar_annotation$$branch>:
 8003114:	f7fe fe2a 	bl	8001d6c <__iar_annotation$$branch+0x4>
 8003118:	1e52      	subs	r2, r2, #1
 800311a:	d101      	bne.n	8003120 <__iar_annotation$$branch+0x4>

0800311c <__iar_annotation$$branch>:
 800311c:	f7fe fe66 	bl	8001dec <__iar_annotation$$branch+0x84>
 8003120:	1e52      	subs	r2, r2, #1
 8003122:	d101      	bne.n	8003128 <__iar_annotation$$branch+0x4>

08003124 <__iar_annotation$$branch>:
 8003124:	f7fe fe78 	bl	8001e18 <__iar_annotation$$branch+0xb0>
 8003128:	1e52      	subs	r2, r2, #1
 800312a:	d101      	bne.n	8003130 <__iar_annotation$$branch+0x4>

0800312c <__iar_annotation$$branch>:
 800312c:	f7fe fe83 	bl	8001e36 <__iar_annotation$$branch+0x4>
 8003130:	1e52      	subs	r2, r2, #1
 8003132:	d101      	bne.n	8003138 <__iar_annotation$$branch+0x4>

08003134 <__iar_annotation$$branch>:
 8003134:	f7fe ff28 	bl	8001f88 <__iar_annotation$$branch+0x156>
 8003138:	1e92      	subs	r2, r2, #2
 800313a:	d101      	bne.n	8003140 <__iar_annotation$$branch+0x4>

0800313c <__iar_annotation$$branch>:
 800313c:	f7ff f9d5 	bl	80024ea <__iar_annotation$$branch+0x20>
 8003140:	1ed2      	subs	r2, r2, #3
 8003142:	d100      	bne.n	8003146 <__iar_annotation$$branch+0xa>
 8003144:	e5d0      	b.n	8002ce8 <__iar_annotation$$branch+0x798>
 8003146:	1f12      	subs	r2, r2, #4
 8003148:	d101      	bne.n	800314e <__iar_annotation$$branch+0x4>

0800314a <__iar_annotation$$branch>:
 800314a:	f7ff f872 	bl	8002232 <__iar_annotation$$branch+0x400>
 800314e:	1e92      	subs	r2, r2, #2
 8003150:	d101      	bne.n	8003156 <__iar_annotation$$branch+0x4>

08003152 <__iar_annotation$$branch>:
 8003152:	f7ff fbb1 	bl	80028b8 <__iar_annotation$$branch+0x368>
 8003156:	1e52      	subs	r2, r2, #1
 8003158:	d101      	bne.n	800315e <__iar_annotation$$branch+0x4>

0800315a <__iar_annotation$$branch>:
 800315a:	f7ff fbda 	bl	8002912 <__iar_annotation$$branch+0x3c2>
 800315e:	1e52      	subs	r2, r2, #1
 8003160:	d100      	bne.n	8003164 <__iar_annotation$$branch+0xa>
 8003162:	e442      	b.n	80029ea <__iar_annotation$$branch+0x49a>
 8003164:	1f12      	subs	r2, r2, #4
 8003166:	d100      	bne.n	800316a <__iar_annotation$$branch+0x10>
 8003168:	e484      	b.n	8002a74 <__iar_annotation$$branch+0x524>
 800316a:	1e52      	subs	r2, r2, #1
 800316c:	d100      	bne.n	8003170 <__iar_annotation$$branch+0x16>
 800316e:	e52f      	b.n	8002bd0 <__iar_annotation$$branch+0x680>
 8003170:	1e52      	subs	r2, r2, #1
 8003172:	d100      	bne.n	8003176 <__iar_annotation$$branch+0x1c>
 8003174:	e553      	b.n	8002c1e <__iar_annotation$$branch+0x6ce>
 8003176:	1e52      	subs	r2, r2, #1
 8003178:	d100      	bne.n	800317c <__iar_annotation$$branch+0x22>
 800317a:	e58a      	b.n	8002c92 <__iar_annotation$$branch+0x742>
 800317c:	1e92      	subs	r2, r2, #2
 800317e:	d101      	bne.n	8003184 <__iar_annotation$$branch+0x4>

08003180 <__iar_annotation$$branch>:
 8003180:	f7ff f8e9 	bl	8002356 <__iar_annotation$$branch+0x20>
 8003184:	1ed2      	subs	r2, r2, #3
 8003186:	d101      	bne.n	800318c <__iar_annotation$$branch+0x4>

08003188 <__iar_annotation$$branch>:
 8003188:	f7ff f939 	bl	80023fe <__iar_annotation$$branch+0x40>
 800318c:	1e92      	subs	r2, r2, #2
 800318e:	2a01      	cmp	r2, #1
 8003190:	d9b0      	bls.n	80030f4 <__iar_annotation$$branch+0x2c>
 8003192:	1ed2      	subs	r2, r2, #3
 8003194:	d100      	bne.n	8003198 <__iar_annotation$$branch+0x10>
 8003196:	e5cc      	b.n	8002d32 <__iar_annotation$$branch+0x7e2>
 8003198:	1e52      	subs	r2, r2, #1
 800319a:	d100      	bne.n	800319e <__iar_annotation$$branch+0x16>
 800319c:	e5ec      	b.n	8002d78 <__iar_annotation$$branch+0x828>
 800319e:	3a0e      	subs	r2, #14
 80031a0:	d0a8      	beq.n	80030f4 <__iar_annotation$$branch+0x2c>
 80031a2:	3a1e      	subs	r2, #30
 80031a4:	d01e      	beq.n	80031e4 <__iar_annotation$$branch+0x14>
 80031a6:	1e52      	subs	r2, r2, #1
 80031a8:	d101      	bne.n	80031ae <__iar_annotation$$branch+0x4>

080031aa <__iar_annotation$$branch>:
 80031aa:	f7ff fa2e 	bl	800260a <__iar_annotation$$branch+0xba>
 80031ae:	1e52      	subs	r2, r2, #1
 80031b0:	d101      	bne.n	80031b6 <__iar_annotation$$branch+0x4>

080031b2 <__iar_annotation$$branch>:
 80031b2:	f7ff fa81 	bl	80026b8 <__iar_annotation$$branch+0x168>
 80031b6:	1e52      	subs	r2, r2, #1
 80031b8:	d101      	bne.n	80031be <__iar_annotation$$branch+0x4>

080031ba <__iar_annotation$$branch>:
 80031ba:	f7ff fa8a 	bl	80026d2 <__iar_annotation$$branch+0x182>
 80031be:	1ed2      	subs	r2, r2, #3
 80031c0:	d101      	bne.n	80031c6 <__iar_annotation$$branch+0x4>

080031c2 <__iar_annotation$$branch>:
 80031c2:	f7ff f8d7 	bl	8002374 <__iar_annotation$$branch+0x4>
 80031c6:	1e52      	subs	r2, r2, #1
 80031c8:	d100      	bne.n	80031cc <__iar_annotation$$branch+0xa>
 80031ca:	e692      	b.n	8002ef2 <__iar_annotation$$branch+0x9a2>
 80031cc:	1e92      	subs	r2, r2, #2
 80031ce:	d101      	bne.n	80031d4 <__iar_annotation$$branch+0x4>

080031d0 <__iar_annotation$$branch>:
 80031d0:	f7fe ffa5 	bl	800211e <__iar_annotation$$branch+0x2ec>
 80031d4:	1e52      	subs	r2, r2, #1
 80031d6:	2a08      	cmp	r2, #8
 80031d8:	d800      	bhi.n	80031dc <__iar_annotation$$branch+0xc>
 80031da:	e67c      	b.n	8002ed6 <__iar_annotation$$branch+0x986>
 80031dc:	3a09      	subs	r2, #9
 80031de:	d100      	bne.n	80031e2 <__iar_annotation$$branch+0x12>
 80031e0:	e66f      	b.n	8002ec2 <__iar_annotation$$branch+0x972>
 80031e2:	e693      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 80031e4:	68a8      	ldr	r0, [r5, #8]
 80031e6:	6b81      	ldr	r1, [r0, #56]	; 0x38
 80031e8:	2900      	cmp	r1, #0
 80031ea:	d003      	beq.n	80031f4 <__iar_annotation$$branch+0x24>
 80031ec:	7b2a      	ldrb	r2, [r5, #12]
 80031ee:	07d0      	lsls	r0, r2, #31
 80031f0:	0fc0      	lsrs	r0, r0, #31
 80031f2:	4788      	blx	r1
 80031f4:	2014      	movs	r0, #20
 80031f6:	4669      	mov	r1, sp
 80031f8:	7308      	strb	r0, [r1, #12]
 80031fa:	2101      	movs	r1, #1
 80031fc:	4668      	mov	r0, sp
 80031fe:	7b40      	ldrb	r0, [r0, #13]
 8003200:	f000 ffc5 	bl	800418e <PE_Reset>
 8003204:	4668      	mov	r0, sp
 8003206:	7b40      	ldrb	r0, [r0, #13]
 8003208:	f002 f924 	bl	8005454 <USBPD_PRL_Reset>
 800320c:	e67e      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>

0800320e <USBPD_PE_StateMachine_DRP>:
 800320e:	b580      	push	{r7, lr}
 8003210:	4911      	ldr	r1, [pc, #68]	; (8003258 <.text_25>)
 8003212:	0082      	lsls	r2, r0, #2
 8003214:	1889      	adds	r1, r1, r2
 8003216:	6849      	ldr	r1, [r1, #4]
 8003218:	6849      	ldr	r1, [r1, #4]
 800321a:	7809      	ldrb	r1, [r1, #0]
 800321c:	0889      	lsrs	r1, r1, #2
 800321e:	07c9      	lsls	r1, r1, #31
 8003220:	d502      	bpl.n	8003228 <USBPD_PE_StateMachine_DRP+0x1a>
 8003222:	f7fd f973 	bl	800050c <USBPD_PE_StateMachine_SRC>
 8003226:	bd02      	pop	{r1, pc}
 8003228:	f7fe fd00 	bl	8001c2c <USBPD_PE_StateMachine_SNK>
 800322c:	bd02      	pop	{r1, pc}

0800322e <USBPD_PE_Request_HardReset>:
 800322e:	b580      	push	{r7, lr}
 8003230:	4909      	ldr	r1, [pc, #36]	; (8003258 <.text_25>)
 8003232:	0082      	lsls	r2, r0, #2
 8003234:	1889      	adds	r1, r1, r2
 8003236:	6849      	ldr	r1, [r1, #4]
 8003238:	22d5      	movs	r2, #213	; 0xd5
 800323a:	0092      	lsls	r2, r2, #2
 800323c:	188a      	adds	r2, r1, r2
 800323e:	2300      	movs	r3, #0
 8003240:	7053      	strb	r3, [r2, #1]
 8003242:	230f      	movs	r3, #15
 8003244:	7013      	strb	r3, [r2, #0]
 8003246:	6889      	ldr	r1, [r1, #8]
 8003248:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800324a:	4788      	blx	r1
 800324c:	2000      	movs	r0, #0
 800324e:	bd02      	pop	{r1, pc}

08003250 <.text_23>:
 8003250:	b5e8b5cd 	.word	0xb5e8b5cd

08003254 <.text_24>:
 8003254:	00000fff 	.word	0x00000fff

08003258 <.text_25>:
 8003258:	200019e8 	.word	0x200019e8

0800325c <.text_26>:
 800325c:	0000801a 	.word	0x0000801a

08003260 <USBPD_PE_Request_CtrlMessage>:
 8003260:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 8003262:	b082      	sub	sp, #8
 8003264:	48b9      	ldr	r0, [pc, #740]	; (800354c <.text_29>)
 8003266:	466b      	mov	r3, sp
 8003268:	7a1b      	ldrb	r3, [r3, #8]
 800326a:	009b      	lsls	r3, r3, #2
 800326c:	58c0      	ldr	r0, [r0, r3]
 800326e:	9000      	str	r0, [sp, #0]
 8003270:	2402      	movs	r4, #2
 8003272:	23d5      	movs	r3, #213	; 0xd5
 8003274:	009b      	lsls	r3, r3, #2
 8003276:	18c0      	adds	r0, r0, r3
 8003278:	7803      	ldrb	r3, [r0, #0]
 800327a:	2b00      	cmp	r3, #0
 800327c:	d106      	bne.n	800328c <USBPD_PE_Request_CtrlMessage+0x2c>
 800327e:	9b00      	ldr	r3, [sp, #0]
 8003280:	685b      	ldr	r3, [r3, #4]
 8003282:	2501      	movs	r5, #1
 8003284:	681e      	ldr	r6, [r3, #0]
 8003286:	0af6      	lsrs	r6, r6, #11
 8003288:	402e      	ands	r6, r5
 800328a:	d101      	bne.n	8003290 <USBPD_PE_Request_CtrlMessage+0x30>
 800328c:	2003      	movs	r0, #3
 800328e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8003290:	466e      	mov	r6, sp
 8003292:	7132      	strb	r2, [r6, #4]
 8003294:	466a      	mov	r2, sp
 8003296:	7151      	strb	r1, [r2, #5]
 8003298:	9900      	ldr	r1, [sp, #0]
 800329a:	22e5      	movs	r2, #229	; 0xe5
 800329c:	0092      	lsls	r2, r2, #2
 800329e:	1889      	adds	r1, r1, r2
 80032a0:	222e      	movs	r2, #46	; 0x2e
 80032a2:	2603      	movs	r6, #3
 80032a4:	466f      	mov	r7, sp
 80032a6:	797f      	ldrb	r7, [r7, #5]
 80032a8:	2f02      	cmp	r7, #2
 80032aa:	d01a      	beq.n	80032e2 <USBPD_PE_Request_CtrlMessage+0x82>
 80032ac:	2f07      	cmp	r7, #7
 80032ae:	d029      	beq.n	8003304 <USBPD_PE_Request_CtrlMessage+0xa4>
 80032b0:	2f08      	cmp	r7, #8
 80032b2:	d03a      	beq.n	800332a <USBPD_PE_Request_CtrlMessage+0xca>
 80032b4:	2f09      	cmp	r7, #9
 80032b6:	d04b      	beq.n	8003350 <USBPD_PE_Request_CtrlMessage+0xf0>
 80032b8:	2f0a      	cmp	r7, #10
 80032ba:	d052      	beq.n	8003362 <USBPD_PE_Request_CtrlMessage+0x102>
 80032bc:	2f0b      	cmp	r7, #11
 80032be:	d063      	beq.n	8003388 <USBPD_PE_Request_CtrlMessage+0x128>
 80032c0:	2f0d      	cmp	r7, #13
 80032c2:	d06c      	beq.n	800339e <USBPD_PE_Request_CtrlMessage+0x13e>
 80032c4:	2f11      	cmp	r7, #17
 80032c6:	d071      	beq.n	80033ac <USBPD_PE_Request_CtrlMessage+0x14c>
 80032c8:	2f12      	cmp	r7, #18
 80032ca:	d100      	bne.n	80032ce <USBPD_PE_Request_CtrlMessage+0x6e>
 80032cc:	e082      	b.n	80033d4 <USBPD_PE_Request_CtrlMessage+0x174>
 80032ce:	2f13      	cmp	r7, #19
 80032d0:	d100      	bne.n	80032d4 <USBPD_PE_Request_CtrlMessage+0x74>
 80032d2:	e090      	b.n	80033f6 <USBPD_PE_Request_CtrlMessage+0x196>
 80032d4:	2f14      	cmp	r7, #20
 80032d6:	d100      	bne.n	80032da <USBPD_PE_Request_CtrlMessage+0x7a>
 80032d8:	e0a3      	b.n	8003422 <USBPD_PE_Request_CtrlMessage+0x1c2>
 80032da:	2f15      	cmp	r7, #21
 80032dc:	d100      	bne.n	80032e0 <USBPD_PE_Request_CtrlMessage+0x80>
 80032de:	e0b8      	b.n	8003452 <USBPD_PE_Request_CtrlMessage+0x1f2>
 80032e0:	e0d0      	b.n	8003484 <USBPD_PE_Request_CtrlMessage+0x224>
 80032e2:	781a      	ldrb	r2, [r3, #0]
 80032e4:	0892      	lsrs	r2, r2, #2
 80032e6:	422a      	tst	r2, r5
 80032e8:	d00a      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80032ea:	804c      	strh	r4, [r1, #2]
 80032ec:	2400      	movs	r4, #0
 80032ee:	7044      	strb	r4, [r0, #1]
 80032f0:	2196      	movs	r1, #150	; 0x96
 80032f2:	7001      	strb	r1, [r0, #0]
 80032f4:	4668      	mov	r0, sp
 80032f6:	7a00      	ldrb	r0, [r0, #8]
 80032f8:	9900      	ldr	r1, [sp, #0]
 80032fa:	6889      	ldr	r1, [r1, #8]
 80032fc:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80032fe:	4788      	blx	r1
 8003300:	0020      	movs	r0, r4
 8003302:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8003304:	7859      	ldrb	r1, [r3, #1]
 8003306:	0649      	lsls	r1, r1, #25
 8003308:	0f49      	lsrs	r1, r1, #29
 800330a:	2903      	cmp	r1, #3
 800330c:	d1f8      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 800330e:	9900      	ldr	r1, [sp, #0]
 8003310:	6809      	ldr	r1, [r1, #0]
 8003312:	6849      	ldr	r1, [r1, #4]
 8003314:	08c9      	lsrs	r1, r1, #3
 8003316:	4029      	ands	r1, r5
 8003318:	d103      	bne.n	8003322 <USBPD_PE_Request_CtrlMessage+0xc2>
 800331a:	7819      	ldrb	r1, [r3, #0]
 800331c:	0889      	lsrs	r1, r1, #2
 800331e:	4229      	tst	r1, r5
 8003320:	d1ee      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003322:	2400      	movs	r4, #0
 8003324:	7044      	strb	r4, [r0, #1]
 8003326:	211a      	movs	r1, #26
 8003328:	e7e3      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 800332a:	7859      	ldrb	r1, [r3, #1]
 800332c:	0649      	lsls	r1, r1, #25
 800332e:	0f49      	lsrs	r1, r1, #29
 8003330:	2903      	cmp	r1, #3
 8003332:	d1e5      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003334:	9900      	ldr	r1, [sp, #0]
 8003336:	6809      	ldr	r1, [r1, #0]
 8003338:	6849      	ldr	r1, [r1, #4]
 800333a:	08c9      	lsrs	r1, r1, #3
 800333c:	4029      	ands	r1, r5
 800333e:	d103      	bne.n	8003348 <USBPD_PE_Request_CtrlMessage+0xe8>
 8003340:	7819      	ldrb	r1, [r3, #0]
 8003342:	0889      	lsrs	r1, r1, #2
 8003344:	4229      	tst	r1, r5
 8003346:	d0db      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003348:	2400      	movs	r4, #0
 800334a:	7044      	strb	r4, [r0, #1]
 800334c:	2118      	movs	r1, #24
 800334e:	e7d0      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003350:	7859      	ldrb	r1, [r3, #1]
 8003352:	0649      	lsls	r1, r1, #25
 8003354:	0f49      	lsrs	r1, r1, #29
 8003356:	2903      	cmp	r1, #3
 8003358:	d1d2      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 800335a:	2400      	movs	r4, #0
 800335c:	7044      	strb	r4, [r0, #1]
 800335e:	2194      	movs	r1, #148	; 0x94
 8003360:	e7c7      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003362:	785a      	ldrb	r2, [r3, #1]
 8003364:	0652      	lsls	r2, r2, #25
 8003366:	0f52      	lsrs	r2, r2, #29
 8003368:	2a03      	cmp	r2, #3
 800336a:	d1c9      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 800336c:	9a00      	ldr	r2, [sp, #0]
 800336e:	6812      	ldr	r2, [r2, #0]
 8003370:	6852      	ldr	r2, [r2, #4]
 8003372:	08d2      	lsrs	r2, r2, #3
 8003374:	4015      	ands	r5, r2
 8003376:	d0c3      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003378:	220a      	movs	r2, #10
 800337a:	700a      	strb	r2, [r1, #0]
 800337c:	2208      	movs	r2, #8
 800337e:	804a      	strh	r2, [r1, #2]
 8003380:	2400      	movs	r4, #0
 8003382:	7044      	strb	r4, [r0, #1]
 8003384:	211e      	movs	r1, #30
 8003386:	e7b4      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003388:	9a00      	ldr	r2, [sp, #0]
 800338a:	6892      	ldr	r2, [r2, #8]
 800338c:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800338e:	2a00      	cmp	r2, #0
 8003390:	d0b6      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003392:	2210      	movs	r2, #16
 8003394:	804a      	strh	r2, [r1, #2]
 8003396:	2400      	movs	r4, #0
 8003398:	7044      	strb	r4, [r0, #1]
 800339a:	21a2      	movs	r1, #162	; 0xa2
 800339c:	e7a9      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 800339e:	4669      	mov	r1, sp
 80033a0:	7909      	ldrb	r1, [r1, #4]
 80033a2:	7041      	strb	r1, [r0, #1]
 80033a4:	2111      	movs	r1, #17
 80033a6:	7001      	strb	r1, [r0, #0]
 80033a8:	2400      	movs	r4, #0
 80033aa:	e7a3      	b.n	80032f4 <USBPD_PE_Request_CtrlMessage+0x94>
 80033ac:	785f      	ldrb	r7, [r3, #1]
 80033ae:	067f      	lsls	r7, r7, #25
 80033b0:	0f7f      	lsrs	r7, r7, #29
 80033b2:	2f03      	cmp	r7, #3
 80033b4:	d1a4      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033b6:	781b      	ldrb	r3, [r3, #0]
 80033b8:	401e      	ands	r6, r3
 80033ba:	2e01      	cmp	r6, #1
 80033bc:	dda0      	ble.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033be:	089b      	lsrs	r3, r3, #2
 80033c0:	422b      	tst	r3, r5
 80033c2:	d19d      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033c4:	2311      	movs	r3, #17
 80033c6:	700b      	strb	r3, [r1, #0]
 80033c8:	230a      	movs	r3, #10
 80033ca:	804b      	strh	r3, [r1, #2]
 80033cc:	2400      	movs	r4, #0
 80033ce:	7044      	strb	r4, [r0, #1]
 80033d0:	7002      	strb	r2, [r0, #0]
 80033d2:	e78f      	b.n	80032f4 <USBPD_PE_Request_CtrlMessage+0x94>
 80033d4:	785d      	ldrb	r5, [r3, #1]
 80033d6:	066d      	lsls	r5, r5, #25
 80033d8:	0f6d      	lsrs	r5, r5, #29
 80033da:	2d03      	cmp	r5, #3
 80033dc:	d190      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033de:	781b      	ldrb	r3, [r3, #0]
 80033e0:	401e      	ands	r6, r3
 80033e2:	2e01      	cmp	r6, #1
 80033e4:	dd8c      	ble.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033e6:	7002      	strb	r2, [r0, #0]
 80033e8:	2212      	movs	r2, #18
 80033ea:	700a      	strb	r2, [r1, #0]
 80033ec:	220b      	movs	r2, #11
 80033ee:	804a      	strh	r2, [r1, #2]
 80033f0:	2400      	movs	r4, #0
 80033f2:	7044      	strb	r4, [r0, #1]
 80033f4:	e77e      	b.n	80032f4 <USBPD_PE_Request_CtrlMessage+0x94>
 80033f6:	785a      	ldrb	r2, [r3, #1]
 80033f8:	0652      	lsls	r2, r2, #25
 80033fa:	0f52      	lsrs	r2, r2, #29
 80033fc:	2a03      	cmp	r2, #3
 80033fe:	d1ed      	bne.n	80033dc <USBPD_PE_Request_CtrlMessage+0x17c>
 8003400:	781a      	ldrb	r2, [r3, #0]
 8003402:	4016      	ands	r6, r2
 8003404:	2e01      	cmp	r6, #1
 8003406:	dded      	ble.n	80033e4 <USBPD_PE_Request_CtrlMessage+0x184>
 8003408:	0892      	lsrs	r2, r2, #2
 800340a:	422a      	tst	r2, r5
 800340c:	d1e6      	bne.n	80033dc <USBPD_PE_Request_CtrlMessage+0x17c>
 800340e:	9a00      	ldr	r2, [sp, #0]
 8003410:	6812      	ldr	r2, [r2, #0]
 8003412:	88d2      	ldrh	r2, [r2, #6]
 8003414:	0852      	lsrs	r2, r2, #1
 8003416:	422a      	tst	r2, r5
 8003418:	d0e4      	beq.n	80033e4 <USBPD_PE_Request_CtrlMessage+0x184>
 800341a:	2213      	movs	r2, #19
 800341c:	700a      	strb	r2, [r1, #0]
 800341e:	2209      	movs	r2, #9
 8003420:	e7ad      	b.n	800337e <USBPD_PE_Request_CtrlMessage+0x11e>
 8003422:	785a      	ldrb	r2, [r3, #1]
 8003424:	0652      	lsls	r2, r2, #25
 8003426:	0f52      	lsrs	r2, r2, #29
 8003428:	2a03      	cmp	r2, #3
 800342a:	d1d7      	bne.n	80033dc <USBPD_PE_Request_CtrlMessage+0x17c>
 800342c:	781a      	ldrb	r2, [r3, #0]
 800342e:	4016      	ands	r6, r2
 8003430:	2e01      	cmp	r6, #1
 8003432:	ddd7      	ble.n	80033e4 <USBPD_PE_Request_CtrlMessage+0x184>
 8003434:	0892      	lsrs	r2, r2, #2
 8003436:	422a      	tst	r2, r5
 8003438:	d125      	bne.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 800343a:	9a00      	ldr	r2, [sp, #0]
 800343c:	6812      	ldr	r2, [r2, #0]
 800343e:	88d2      	ldrh	r2, [r2, #6]
 8003440:	0892      	lsrs	r2, r2, #2
 8003442:	422a      	tst	r2, r5
 8003444:	d01f      	beq.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 8003446:	220b      	movs	r2, #11
 8003448:	804a      	strh	r2, [r1, #2]
 800344a:	2400      	movs	r4, #0
 800344c:	7044      	strb	r4, [r0, #1]
 800344e:	2165      	movs	r1, #101	; 0x65
 8003450:	e74f      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003452:	785f      	ldrb	r7, [r3, #1]
 8003454:	067f      	lsls	r7, r7, #25
 8003456:	0f7f      	lsrs	r7, r7, #29
 8003458:	2f03      	cmp	r7, #3
 800345a:	d114      	bne.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 800345c:	781b      	ldrb	r3, [r3, #0]
 800345e:	401e      	ands	r6, r3
 8003460:	2e01      	cmp	r6, #1
 8003462:	dd10      	ble.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 8003464:	9b00      	ldr	r3, [sp, #0]
 8003466:	681b      	ldr	r3, [r3, #0]
 8003468:	88db      	ldrh	r3, [r3, #6]
 800346a:	0a1b      	lsrs	r3, r3, #8
 800346c:	422b      	tst	r3, r5
 800346e:	d00a      	beq.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 8003470:	466b      	mov	r3, sp
 8003472:	791b      	ldrb	r3, [r3, #4]
 8003474:	7043      	strb	r3, [r0, #1]
 8003476:	23ff      	movs	r3, #255	; 0xff
 8003478:	330e      	adds	r3, #14
 800347a:	804b      	strh	r3, [r1, #2]
 800347c:	2315      	movs	r3, #21
 800347e:	700b      	strb	r3, [r1, #0]
 8003480:	7002      	strb	r2, [r0, #0]
 8003482:	e791      	b.n	80033a8 <USBPD_PE_Request_CtrlMessage+0x148>
 8003484:	2410      	movs	r4, #16
 8003486:	e73b      	b.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>

08003488 <USBPD_PE_Request_DataMessage>:
 8003488:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 800348a:	b084      	sub	sp, #16
 800348c:	482f      	ldr	r0, [pc, #188]	; (800354c <.text_29>)
 800348e:	466b      	mov	r3, sp
 8003490:	7c1b      	ldrb	r3, [r3, #16]
 8003492:	009b      	lsls	r3, r3, #2
 8003494:	58c0      	ldr	r0, [r0, r3]
 8003496:	9001      	str	r0, [sp, #4]
 8003498:	2402      	movs	r4, #2
 800349a:	23d5      	movs	r3, #213	; 0xd5
 800349c:	009b      	lsls	r3, r3, #2
 800349e:	18c0      	adds	r0, r0, r3
 80034a0:	7803      	ldrb	r3, [r0, #0]
 80034a2:	2b00      	cmp	r3, #0
 80034a4:	d106      	bne.n	80034b4 <USBPD_PE_Request_DataMessage+0x2c>
 80034a6:	9b01      	ldr	r3, [sp, #4]
 80034a8:	685b      	ldr	r3, [r3, #4]
 80034aa:	2501      	movs	r5, #1
 80034ac:	681e      	ldr	r6, [r3, #0]
 80034ae:	0af6      	lsrs	r6, r6, #11
 80034b0:	402e      	ands	r6, r5
 80034b2:	d101      	bne.n	80034b8 <USBPD_PE_Request_DataMessage+0x30>
 80034b4:	2003      	movs	r0, #3
 80034b6:	e022      	b.n	80034fe <USBPD_PE_Request_DataMessage+0x76>
 80034b8:	9203      	str	r2, [sp, #12]
 80034ba:	466a      	mov	r2, sp
 80034bc:	7011      	strb	r1, [r2, #0]
 80034be:	9901      	ldr	r1, [sp, #4]
 80034c0:	4a9c      	ldr	r2, [pc, #624]	; (8003734 <.text_33>)
 80034c2:	1889      	adds	r1, r1, r2
 80034c4:	9102      	str	r1, [sp, #8]
 80034c6:	2103      	movs	r1, #3
 80034c8:	2207      	movs	r2, #7
 80034ca:	2600      	movs	r6, #0
 80034cc:	466f      	mov	r7, sp
 80034ce:	783f      	ldrb	r7, [r7, #0]
 80034d0:	2f01      	cmp	r7, #1
 80034d2:	d004      	beq.n	80034de <USBPD_PE_Request_DataMessage+0x56>
 80034d4:	2f06      	cmp	r7, #6
 80034d6:	d014      	beq.n	8003502 <USBPD_PE_Request_DataMessage+0x7a>
 80034d8:	2f07      	cmp	r7, #7
 80034da:	d022      	beq.n	8003522 <USBPD_PE_Request_DataMessage+0x9a>
 80034dc:	e034      	b.n	8003548 <USBPD_PE_Request_DataMessage+0xc0>
 80034de:	7819      	ldrb	r1, [r3, #0]
 80034e0:	0889      	lsrs	r1, r1, #2
 80034e2:	4229      	tst	r1, r5
 80034e4:	d00a      	beq.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 80034e6:	9902      	ldr	r1, [sp, #8]
 80034e8:	800d      	strh	r5, [r1, #0]
 80034ea:	7046      	strb	r6, [r0, #1]
 80034ec:	7002      	strb	r2, [r0, #0]
 80034ee:	2400      	movs	r4, #0
 80034f0:	4668      	mov	r0, sp
 80034f2:	7c00      	ldrb	r0, [r0, #16]
 80034f4:	9901      	ldr	r1, [sp, #4]
 80034f6:	6889      	ldr	r1, [r1, #8]
 80034f8:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80034fa:	4788      	blx	r1
 80034fc:	0020      	movs	r0, r4
 80034fe:	b005      	add	sp, #20
 8003500:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003502:	785d      	ldrb	r5, [r3, #1]
 8003504:	092d      	lsrs	r5, r5, #4
 8003506:	402a      	ands	r2, r5
 8003508:	2a03      	cmp	r2, #3
 800350a:	d1f7      	bne.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 800350c:	781a      	ldrb	r2, [r3, #0]
 800350e:	4011      	ands	r1, r2
 8003510:	2901      	cmp	r1, #1
 8003512:	ddf3      	ble.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 8003514:	7046      	strb	r6, [r0, #1]
 8003516:	9903      	ldr	r1, [sp, #12]
 8003518:	6809      	ldr	r1, [r1, #0]
 800351a:	6381      	str	r1, [r0, #56]	; 0x38
 800351c:	212b      	movs	r1, #43	; 0x2b
 800351e:	7001      	strb	r1, [r0, #0]
 8003520:	e7e5      	b.n	80034ee <USBPD_PE_Request_DataMessage+0x66>
 8003522:	785d      	ldrb	r5, [r3, #1]
 8003524:	092d      	lsrs	r5, r5, #4
 8003526:	402a      	ands	r2, r5
 8003528:	2a03      	cmp	r2, #3
 800352a:	d1e7      	bne.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 800352c:	781a      	ldrb	r2, [r3, #0]
 800352e:	4011      	ands	r1, r2
 8003530:	2901      	cmp	r1, #1
 8003532:	dde3      	ble.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 8003534:	9903      	ldr	r1, [sp, #12]
 8003536:	6809      	ldr	r1, [r1, #0]
 8003538:	6381      	str	r1, [r0, #56]	; 0x38
 800353a:	21ff      	movs	r1, #255	; 0xff
 800353c:	310e      	adds	r1, #14
 800353e:	9a02      	ldr	r2, [sp, #8]
 8003540:	8011      	strh	r1, [r2, #0]
 8003542:	7046      	strb	r6, [r0, #1]
 8003544:	2162      	movs	r1, #98	; 0x62
 8003546:	e7ea      	b.n	800351e <USBPD_PE_Request_DataMessage+0x96>
 8003548:	2410      	movs	r4, #16
 800354a:	e7d7      	b.n	80034fc <USBPD_PE_Request_DataMessage+0x74>

0800354c <.text_29>:
 800354c:	200019ec 	.word	0x200019ec

08003550 <USBPD_PE_Send_Request>:
 8003550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003552:	4b79      	ldr	r3, [pc, #484]	; (8003738 <.text_34>)
 8003554:	0084      	lsls	r4, r0, #2
 8003556:	591b      	ldr	r3, [r3, r4]
 8003558:	24d5      	movs	r4, #213	; 0xd5
 800355a:	00a4      	lsls	r4, r4, #2
 800355c:	191c      	adds	r4, r3, r4
 800355e:	7825      	ldrb	r5, [r4, #0]
 8003560:	2d00      	cmp	r5, #0
 8003562:	d105      	bne.n	8003570 <USBPD_PE_Send_Request+0x20>
 8003564:	685d      	ldr	r5, [r3, #4]
 8003566:	2601      	movs	r6, #1
 8003568:	682f      	ldr	r7, [r5, #0]
 800356a:	0aff      	lsrs	r7, r7, #11
 800356c:	4037      	ands	r7, r6
 800356e:	d101      	bne.n	8003574 <USBPD_PE_Send_Request+0x24>
 8003570:	2003      	movs	r0, #3
 8003572:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 8003574:	786f      	ldrb	r7, [r5, #1]
 8003576:	067f      	lsls	r7, r7, #25
 8003578:	0f7f      	lsrs	r7, r7, #29
 800357a:	2f03      	cmp	r7, #3
 800357c:	d115      	bne.n	80035aa <USBPD_PE_Send_Request+0x5a>
 800357e:	782d      	ldrb	r5, [r5, #0]
 8003580:	08ad      	lsrs	r5, r5, #2
 8003582:	4235      	tst	r5, r6
 8003584:	d111      	bne.n	80035aa <USBPD_PE_Send_Request+0x5a>
 8003586:	2545      	movs	r5, #69	; 0x45
 8003588:	7025      	strb	r5, [r4, #0]
 800358a:	6119      	str	r1, [r3, #16]
 800358c:	7b19      	ldrb	r1, [r3, #12]
 800358e:	25f3      	movs	r5, #243	; 0xf3
 8003590:	400d      	ands	r5, r1
 8003592:	0091      	lsls	r1, r2, #2
 8003594:	220c      	movs	r2, #12
 8003596:	400a      	ands	r2, r1
 8003598:	432a      	orrs	r2, r5
 800359a:	731a      	strb	r2, [r3, #12]
 800359c:	2100      	movs	r1, #0
 800359e:	7061      	strb	r1, [r4, #1]
 80035a0:	6899      	ldr	r1, [r3, #8]
 80035a2:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80035a4:	4788      	blx	r1
 80035a6:	2000      	movs	r0, #0
 80035a8:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 80035aa:	2002      	movs	r0, #2
 80035ac:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

080035ae <USBPD_PE_SendExtendedMessage>:
 80035ae:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
 80035b0:	b083      	sub	sp, #12
 80035b2:	2600      	movs	r6, #0
 80035b4:	9601      	str	r6, [sp, #4]
 80035b6:	4860      	ldr	r0, [pc, #384]	; (8003738 <.text_34>)
 80035b8:	4669      	mov	r1, sp
 80035ba:	7b09      	ldrb	r1, [r1, #12]
 80035bc:	0089      	lsls	r1, r1, #2
 80035be:	5844      	ldr	r4, [r0, r1]
 80035c0:	20d3      	movs	r0, #211	; 0xd3
 80035c2:	0080      	lsls	r0, r0, #2
 80035c4:	1825      	adds	r5, r4, r0
 80035c6:	7a28      	ldrb	r0, [r5, #8]
 80035c8:	2800      	cmp	r0, #0
 80035ca:	d104      	bne.n	80035d6 <USBPD_PE_SendExtendedMessage+0x28>
 80035cc:	6860      	ldr	r0, [r4, #4]
 80035ce:	6801      	ldr	r1, [r0, #0]
 80035d0:	050f      	lsls	r7, r1, #20
 80035d2:	0fff      	lsrs	r7, r7, #31
 80035d4:	d101      	bne.n	80035da <USBPD_PE_SendExtendedMessage+0x2c>
 80035d6:	2003      	movs	r0, #3
 80035d8:	e06f      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 80035da:	7841      	ldrb	r1, [r0, #1]
 80035dc:	0649      	lsls	r1, r1, #25
 80035de:	0f49      	lsrs	r1, r1, #29
 80035e0:	2903      	cmp	r1, #3
 80035e2:	d10c      	bne.n	80035fe <USBPD_PE_SendExtendedMessage+0x50>
 80035e4:	7800      	ldrb	r0, [r0, #0]
 80035e6:	0780      	lsls	r0, r0, #30
 80035e8:	0f80      	lsrs	r0, r0, #30
 80035ea:	2801      	cmp	r0, #1
 80035ec:	dc01      	bgt.n	80035f2 <USBPD_PE_SendExtendedMessage+0x44>
 80035ee:	2001      	movs	r0, #1
 80035f0:	e063      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 80035f2:	4668      	mov	r0, sp
 80035f4:	8d00      	ldrh	r0, [r0, #40]	; 0x28
 80035f6:	21ff      	movs	r1, #255	; 0xff
 80035f8:	1d89      	adds	r1, r1, #6
 80035fa:	4288      	cmp	r0, r1
 80035fc:	d301      	bcc.n	8003602 <USBPD_PE_SendExtendedMessage+0x54>
 80035fe:	2002      	movs	r0, #2
 8003600:	e05b      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 8003602:	4668      	mov	r0, sp
 8003604:	7002      	strb	r2, [r0, #0]
 8003606:	68e0      	ldr	r0, [r4, #12]
 8003608:	2110      	movs	r1, #16
 800360a:	4388      	bics	r0, r1
 800360c:	60e0      	str	r0, [r4, #12]
 800360e:	4949      	ldr	r1, [pc, #292]	; (8003734 <.text_33>)
 8003610:	1861      	adds	r1, r4, r1
 8003612:	2210      	movs	r2, #16
 8003614:	466f      	mov	r7, sp
 8003616:	783f      	ldrb	r7, [r7, #0]
 8003618:	2f83      	cmp	r7, #131	; 0x83
 800361a:	d00c      	beq.n	8003636 <USBPD_PE_SendExtendedMessage+0x88>
 800361c:	2f84      	cmp	r7, #132	; 0x84
 800361e:	d021      	beq.n	8003664 <USBPD_PE_SendExtendedMessage+0xb6>
 8003620:	2f86      	cmp	r7, #134	; 0x86
 8003622:	d021      	beq.n	8003668 <USBPD_PE_SendExtendedMessage+0xba>
 8003624:	2f88      	cmp	r7, #136	; 0x88
 8003626:	d021      	beq.n	800366c <USBPD_PE_SendExtendedMessage+0xbe>
 8003628:	2f89      	cmp	r7, #137	; 0x89
 800362a:	d009      	beq.n	8003640 <USBPD_PE_SendExtendedMessage+0x92>
 800362c:	2f8a      	cmp	r7, #138	; 0x8a
 800362e:	d023      	beq.n	8003678 <USBPD_PE_SendExtendedMessage+0xca>
 8003630:	2f8b      	cmp	r7, #139	; 0x8b
 8003632:	d005      	beq.n	8003640 <USBPD_PE_SendExtendedMessage+0x92>
 8003634:	e025      	b.n	8003682 <USBPD_PE_SendExtendedMessage+0xd4>
 8003636:	200c      	movs	r0, #12
 8003638:	8008      	strh	r0, [r1, #0]
 800363a:	68e0      	ldr	r0, [r4, #12]
 800363c:	4302      	orrs	r2, r0
 800363e:	60e2      	str	r2, [r4, #12]
 8003640:	4668      	mov	r0, sp
 8003642:	8d00      	ldrh	r0, [r0, #40]	; 0x28
 8003644:	2800      	cmp	r0, #0
 8003646:	d028      	beq.n	800369a <USBPD_PE_SendExtendedMessage+0xec>
 8003648:	001f      	movs	r7, r3
 800364a:	4668      	mov	r0, sp
 800364c:	7b00      	ldrb	r0, [r0, #12]
 800364e:	f000 ff29 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8003652:	2801      	cmp	r0, #1
 8003654:	d100      	bne.n	8003658 <USBPD_PE_SendExtendedMessage+0xaa>
 8003656:	2604      	movs	r6, #4
 8003658:	9702      	str	r7, [sp, #8]
 800365a:	9801      	ldr	r0, [sp, #4]
 800365c:	4669      	mov	r1, sp
 800365e:	8d09      	ldrh	r1, [r1, #40]	; 0x28
 8003660:	4fc3      	ldr	r7, [pc, #780]	; (8003970 <.text_40>)
 8003662:	e016      	b.n	8003692 <USBPD_PE_SendExtendedMessage+0xe4>
 8003664:	200d      	movs	r0, #13
 8003666:	e7e7      	b.n	8003638 <USBPD_PE_SendExtendedMessage+0x8a>
 8003668:	200e      	movs	r0, #14
 800366a:	e7e5      	b.n	8003638 <USBPD_PE_SendExtendedMessage+0x8a>
 800366c:	4302      	orrs	r2, r0
 800366e:	60e2      	str	r2, [r4, #12]
 8003670:	20ff      	movs	r0, #255	; 0xff
 8003672:	300c      	adds	r0, #12
 8003674:	8008      	strh	r0, [r1, #0]
 8003676:	e7e3      	b.n	8003640 <USBPD_PE_SendExtendedMessage+0x92>
 8003678:	4302      	orrs	r2, r0
 800367a:	60e2      	str	r2, [r4, #12]
 800367c:	2086      	movs	r0, #134	; 0x86
 800367e:	0040      	lsls	r0, r0, #1
 8003680:	e7f8      	b.n	8003674 <USBPD_PE_SendExtendedMessage+0xc6>
 8003682:	2010      	movs	r0, #16
 8003684:	e019      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 8003686:	9a02      	ldr	r2, [sp, #8]
 8003688:	5c12      	ldrb	r2, [r2, r0]
 800368a:	1983      	adds	r3, r0, r6
 800368c:	18e3      	adds	r3, r4, r3
 800368e:	55da      	strb	r2, [r3, r7]
 8003690:	1c40      	adds	r0, r0, #1
 8003692:	4288      	cmp	r0, r1
 8003694:	d3f7      	bcc.n	8003686 <USBPD_PE_SendExtendedMessage+0xd8>
 8003696:	8029      	strh	r1, [r5, #0]
 8003698:	e000      	b.n	800369c <USBPD_PE_SendExtendedMessage+0xee>
 800369a:	802e      	strh	r6, [r5, #0]
 800369c:	4668      	mov	r0, sp
 800369e:	7c00      	ldrb	r0, [r0, #16]
 80036a0:	7268      	strb	r0, [r5, #9]
 80036a2:	4668      	mov	r0, sp
 80036a4:	7800      	ldrb	r0, [r0, #0]
 80036a6:	49bc      	ldr	r1, [pc, #752]	; (8003998 <.text_43>)
 80036a8:	5460      	strb	r0, [r4, r1]
 80036aa:	2031      	movs	r0, #49	; 0x31
 80036ac:	7228      	strb	r0, [r5, #8]
 80036ae:	4668      	mov	r0, sp
 80036b0:	7b00      	ldrb	r0, [r0, #12]
 80036b2:	68a1      	ldr	r1, [r4, #8]
 80036b4:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80036b6:	4788      	blx	r1
 80036b8:	2000      	movs	r0, #0
 80036ba:	b005      	add	sp, #20
 80036bc:	bdf0      	pop	{r4, r5, r6, r7, pc}

080036be <PE_Send_SRCCapabilities>:
 80036be:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80036c0:	b084      	sub	sp, #16
 80036c2:	0005      	movs	r5, r0
 80036c4:	000f      	movs	r7, r1
 80036c6:	20e2      	movs	r0, #226	; 0xe2
 80036c8:	0080      	lsls	r0, r0, #2
 80036ca:	582e      	ldr	r6, [r5, r0]
 80036cc:	211e      	movs	r1, #30
 80036ce:	0028      	movs	r0, r5
 80036d0:	3018      	adds	r0, #24
 80036d2:	f008 fed1 	bl	800c478 <__aeabi_memclr>
 80036d6:	ab02      	add	r3, sp, #8
 80036d8:	002a      	movs	r2, r5
 80036da:	321a      	adds	r2, #26
 80036dc:	2100      	movs	r1, #0
 80036de:	7b2c      	ldrb	r4, [r5, #12]
 80036e0:	07e0      	lsls	r0, r4, #31
 80036e2:	0fc0      	lsrs	r0, r0, #31
 80036e4:	68ac      	ldr	r4, [r5, #8]
 80036e6:	69a4      	ldr	r4, [r4, #24]
 80036e8:	47a0      	blx	r4
 80036ea:	9802      	ldr	r0, [sp, #8]
 80036ec:	1c80      	adds	r0, r0, #2
 80036ee:	b2c0      	uxtb	r0, r0
 80036f0:	4669      	mov	r1, sp
 80036f2:	8188      	strh	r0, [r1, #12]
 80036f4:	2401      	movs	r4, #1
 80036f6:	9701      	str	r7, [sp, #4]
 80036f8:	4668      	mov	r0, sp
 80036fa:	8980      	ldrh	r0, [r0, #12]
 80036fc:	9000      	str	r0, [sp, #0]
 80036fe:	002b      	movs	r3, r5
 8003700:	3318      	adds	r3, #24
 8003702:	2201      	movs	r2, #1
 8003704:	68e9      	ldr	r1, [r5, #12]
 8003706:	2001      	movs	r0, #1
 8003708:	4008      	ands	r0, r1
 800370a:	2100      	movs	r1, #0
 800370c:	f001 fc5a 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8003710:	2803      	cmp	r0, #3
 8003712:	d10c      	bne.n	800372e <PE_Send_SRCCapabilities+0x70>
 8003714:	20e2      	movs	r0, #226	; 0xe2
 8003716:	0080      	lsls	r0, r0, #2
 8003718:	5828      	ldr	r0, [r5, r0]
 800371a:	1b80      	subs	r0, r0, r6
 800371c:	49b9      	ldr	r1, [pc, #740]	; (8003a04 <.text_46>)
 800371e:	4288      	cmp	r0, r1
 8003720:	d204      	bcs.n	800372c <PE_Send_SRCCapabilities+0x6e>
 8003722:	6868      	ldr	r0, [r5, #4]
 8003724:	6800      	ldr	r0, [r0, #0]
 8003726:	0ac0      	lsrs	r0, r0, #11
 8003728:	4004      	ands	r4, r0
 800372a:	d1e3      	bne.n	80036f4 <PE_Send_SRCCapabilities+0x36>
 800372c:	2010      	movs	r0, #16
 800372e:	b005      	add	sp, #20
 8003730:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08003734 <.text_33>:
 8003734:	00000396 	.word	0x00000396

08003738 <.text_34>:
 8003738:	200019ec 	.word	0x200019ec

0800373c <PE_Send_SNKCapabilities>:
 800373c:	b578      	push	{r3, r4, r5, r6, lr}
 800373e:	b08b      	sub	sp, #44	; 0x2c
 8003740:	0004      	movs	r4, r0
 8003742:	000d      	movs	r5, r1
 8003744:	ab03      	add	r3, sp, #12
 8003746:	aa04      	add	r2, sp, #16
 8003748:	2101      	movs	r1, #1
 800374a:	7b26      	ldrb	r6, [r4, #12]
 800374c:	07f0      	lsls	r0, r6, #31
 800374e:	0fc0      	lsrs	r0, r0, #31
 8003750:	68a6      	ldr	r6, [r4, #8]
 8003752:	69b6      	ldr	r6, [r6, #24]
 8003754:	47b0      	blx	r6
 8003756:	2000      	movs	r0, #0
 8003758:	9002      	str	r0, [sp, #8]
 800375a:	9501      	str	r5, [sp, #4]
 800375c:	9803      	ldr	r0, [sp, #12]
 800375e:	0880      	lsrs	r0, r0, #2
 8003760:	9000      	str	r0, [sp, #0]
 8003762:	ab04      	add	r3, sp, #16
 8003764:	2204      	movs	r2, #4
 8003766:	2100      	movs	r1, #0
 8003768:	0020      	movs	r0, r4
 800376a:	f000 f849 	bl	8003800 <PE_Send_DataMessage>
 800376e:	b00c      	add	sp, #48	; 0x30
 8003770:	bd70      	pop	{r4, r5, r6, pc}

08003772 <PE_Send_CtrlMessage>:
 8003772:	b5fc      	push	{r2, r3, r4, r5, r6, r7, lr}
 8003774:	b083      	sub	sp, #12
 8003776:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8003778:	0005      	movs	r5, r0
 800377a:	4668      	mov	r0, sp
 800377c:	7201      	strb	r1, [r0, #8]
 800377e:	0016      	movs	r6, r2
 8003780:	2401      	movs	r4, #1
 8003782:	9701      	str	r7, [sp, #4]
 8003784:	2002      	movs	r0, #2
 8003786:	9000      	str	r0, [sp, #0]
 8003788:	002b      	movs	r3, r5
 800378a:	3318      	adds	r3, #24
 800378c:	0032      	movs	r2, r6
 800378e:	4668      	mov	r0, sp
 8003790:	7a01      	ldrb	r1, [r0, #8]
 8003792:	468c      	mov	ip, r1
 8003794:	68e9      	ldr	r1, [r5, #12]
 8003796:	2001      	movs	r0, #1
 8003798:	4008      	ands	r0, r1
 800379a:	4661      	mov	r1, ip
 800379c:	f001 fc12 	bl	8004fc4 <USBPD_PRL_SendMessage>
 80037a0:	2803      	cmp	r0, #3
 80037a2:	d11a      	bne.n	80037da <PE_Send_CtrlMessage+0x68>
 80037a4:	6868      	ldr	r0, [r5, #4]
 80037a6:	6800      	ldr	r0, [r0, #0]
 80037a8:	0ac0      	lsrs	r0, r0, #11
 80037aa:	4004      	ands	r4, r0
 80037ac:	d1e8      	bne.n	8003780 <PE_Send_CtrlMessage+0xe>
 80037ae:	2000      	movs	r0, #0
 80037b0:	21d5      	movs	r1, #213	; 0xd5
 80037b2:	0089      	lsls	r1, r1, #2
 80037b4:	1869      	adds	r1, r5, r1
 80037b6:	e00c      	b.n	80037d2 <PE_Send_CtrlMessage+0x60>
 80037b8:	700a      	strb	r2, [r1, #0]
 80037ba:	e00b      	b.n	80037d4 <PE_Send_CtrlMessage+0x62>
 80037bc:	6868      	ldr	r0, [r5, #4]
 80037be:	7840      	ldrb	r0, [r0, #1]
 80037c0:	0640      	lsls	r0, r0, #25
 80037c2:	0f40      	lsrs	r0, r0, #29
 80037c4:	2804      	cmp	r0, #4
 80037c6:	d001      	beq.n	80037cc <PE_Send_CtrlMessage+0x5a>
 80037c8:	2e0d      	cmp	r6, #13
 80037ca:	d101      	bne.n	80037d0 <PE_Send_CtrlMessage+0x5e>
 80037cc:	200f      	movs	r0, #15
 80037ce:	e000      	b.n	80037d2 <PE_Send_CtrlMessage+0x60>
 80037d0:	2011      	movs	r0, #17
 80037d2:	7108      	strb	r0, [r1, #4]
 80037d4:	2010      	movs	r0, #16
 80037d6:	b005      	add	sp, #20
 80037d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80037da:	21d5      	movs	r1, #213	; 0xd5
 80037dc:	0089      	lsls	r1, r1, #2
 80037de:	1869      	adds	r1, r5, r1
 80037e0:	2200      	movs	r2, #0
 80037e2:	2805      	cmp	r0, #5
 80037e4:	d006      	beq.n	80037f4 <PE_Send_CtrlMessage+0x82>
 80037e6:	2806      	cmp	r0, #6
 80037e8:	d0e6      	beq.n	80037b8 <PE_Send_CtrlMessage+0x46>
 80037ea:	2807      	cmp	r0, #7
 80037ec:	d0e6      	beq.n	80037bc <PE_Send_CtrlMessage+0x4a>
 80037ee:	2809      	cmp	r0, #9
 80037f0:	d0f1      	beq.n	80037d6 <PE_Send_CtrlMessage+0x64>
 80037f2:	e7ef      	b.n	80037d4 <PE_Send_CtrlMessage+0x62>
 80037f4:	4668      	mov	r0, sp
 80037f6:	7c00      	ldrb	r0, [r0, #16]
 80037f8:	7108      	strb	r0, [r1, #4]
 80037fa:	700a      	strb	r2, [r1, #0]
 80037fc:	2000      	movs	r0, #0
 80037fe:	e7ea      	b.n	80037d6 <PE_Send_CtrlMessage+0x64>

08003800 <PE_Send_DataMessage>:
 8003800:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8003802:	b082      	sub	sp, #8
 8003804:	0005      	movs	r5, r0
 8003806:	2000      	movs	r0, #0
 8003808:	e00c      	b.n	8003824 <PE_Send_DataMessage+0x24>
 800380a:	2600      	movs	r6, #0
 800380c:	0081      	lsls	r1, r0, #2
 800380e:	1869      	adds	r1, r5, r1
 8003810:	198a      	adds	r2, r1, r6
 8003812:	6819      	ldr	r1, [r3, #0]
 8003814:	00f7      	lsls	r7, r6, #3
 8003816:	40f9      	lsrs	r1, r7
 8003818:	7691      	strb	r1, [r2, #26]
 800381a:	1c76      	adds	r6, r6, #1
 800381c:	2e04      	cmp	r6, #4
 800381e:	dbf5      	blt.n	800380c <PE_Send_DataMessage+0xc>
 8003820:	1d1b      	adds	r3, r3, #4
 8003822:	1c40      	adds	r0, r0, #1
 8003824:	990a      	ldr	r1, [sp, #40]	; 0x28
 8003826:	4288      	cmp	r0, r1
 8003828:	d3ef      	bcc.n	800380a <PE_Send_DataMessage+0xa>
 800382a:	2401      	movs	r4, #1
 800382c:	a80c      	add	r0, sp, #48	; 0x30
 800382e:	7800      	ldrb	r0, [r0, #0]
 8003830:	9001      	str	r0, [sp, #4]
 8003832:	980a      	ldr	r0, [sp, #40]	; 0x28
 8003834:	0080      	lsls	r0, r0, #2
 8003836:	1c80      	adds	r0, r0, #2
 8003838:	b280      	uxth	r0, r0
 800383a:	9000      	str	r0, [sp, #0]
 800383c:	002b      	movs	r3, r5
 800383e:	3318      	adds	r3, #24
 8003840:	4668      	mov	r0, sp
 8003842:	7c02      	ldrb	r2, [r0, #16]
 8003844:	7b01      	ldrb	r1, [r0, #12]
 8003846:	68ee      	ldr	r6, [r5, #12]
 8003848:	2001      	movs	r0, #1
 800384a:	4030      	ands	r0, r6
 800384c:	f001 fbba 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8003850:	2803      	cmp	r0, #3
 8003852:	d117      	bne.n	8003884 <PE_Send_DataMessage+0x84>
 8003854:	6868      	ldr	r0, [r5, #4]
 8003856:	6800      	ldr	r0, [r0, #0]
 8003858:	0ac0      	lsrs	r0, r0, #11
 800385a:	4004      	ands	r4, r0
 800385c:	d1e5      	bne.n	800382a <PE_Send_DataMessage+0x2a>
 800385e:	2010      	movs	r0, #16
 8003860:	e00e      	b.n	8003880 <PE_Send_DataMessage+0x80>
 8003862:	2a00      	cmp	r2, #0
 8003864:	d001      	beq.n	800386a <PE_Send_DataMessage+0x6a>
 8003866:	2099      	movs	r0, #153	; 0x99
 8003868:	e008      	b.n	800387c <PE_Send_DataMessage+0x7c>
 800386a:	6868      	ldr	r0, [r5, #4]
 800386c:	7840      	ldrb	r0, [r0, #1]
 800386e:	0640      	lsls	r0, r0, #25
 8003870:	0f40      	lsrs	r0, r0, #29
 8003872:	2804      	cmp	r0, #4
 8003874:	d101      	bne.n	800387a <PE_Send_DataMessage+0x7a>
 8003876:	200f      	movs	r0, #15
 8003878:	e000      	b.n	800387c <PE_Send_DataMessage+0x7c>
 800387a:	2011      	movs	r0, #17
 800387c:	7008      	strb	r0, [r1, #0]
 800387e:	2000      	movs	r0, #0
 8003880:	b005      	add	sp, #20
 8003882:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003884:	4669      	mov	r1, sp
 8003886:	7b0a      	ldrb	r2, [r1, #12]
 8003888:	21d6      	movs	r1, #214	; 0xd6
 800388a:	0089      	lsls	r1, r1, #2
 800388c:	1869      	adds	r1, r5, r1
 800388e:	2805      	cmp	r0, #5
 8003890:	d004      	beq.n	800389c <PE_Send_DataMessage+0x9c>
 8003892:	2807      	cmp	r0, #7
 8003894:	d0e5      	beq.n	8003862 <PE_Send_DataMessage+0x62>
 8003896:	2809      	cmp	r0, #9
 8003898:	d0f2      	beq.n	8003880 <PE_Send_DataMessage+0x80>
 800389a:	e7f0      	b.n	800387e <PE_Send_DataMessage+0x7e>
 800389c:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800389e:	7008      	strb	r0, [r1, #0]
 80038a0:	4e59      	ldr	r6, [pc, #356]	; (8003a08 <.text_47>)
 80038a2:	7830      	ldrb	r0, [r6, #0]
 80038a4:	0780      	lsls	r0, r0, #30
 80038a6:	d509      	bpl.n	80038bc <PE_Send_DataMessage+0xbc>
 80038a8:	2000      	movs	r0, #0
 80038aa:	9000      	str	r0, [sp, #0]
 80038ac:	2300      	movs	r3, #0
 80038ae:	2242      	movs	r2, #66	; 0x42
 80038b0:	68e8      	ldr	r0, [r5, #12]
 80038b2:	2101      	movs	r1, #1
 80038b4:	4001      	ands	r1, r0
 80038b6:	2009      	movs	r0, #9
 80038b8:	68f6      	ldr	r6, [r6, #12]
 80038ba:	47b0      	blx	r6
 80038bc:	2142      	movs	r1, #66	; 0x42
 80038be:	68e8      	ldr	r0, [r5, #12]
 80038c0:	4004      	ands	r4, r0
 80038c2:	0020      	movs	r0, r4
 80038c4:	68aa      	ldr	r2, [r5, #8]
 80038c6:	68d2      	ldr	r2, [r2, #12]
 80038c8:	4790      	blx	r2
 80038ca:	e7d8      	b.n	800387e <PE_Send_DataMessage+0x7e>

080038cc <PE_Send_HARDRESET>:
 80038cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80038ce:	0004      	movs	r4, r0
 80038d0:	20e2      	movs	r0, #226	; 0xe2
 80038d2:	0080      	lsls	r0, r0, #2
 80038d4:	5825      	ldr	r5, [r4, r0]
 80038d6:	2601      	movs	r6, #1
 80038d8:	4f4b      	ldr	r7, [pc, #300]	; (8003a08 <.text_47>)
 80038da:	7838      	ldrb	r0, [r7, #0]
 80038dc:	0780      	lsls	r0, r0, #30
 80038de:	d509      	bpl.n	80038f4 <PE_Send_HARDRESET+0x28>
 80038e0:	2000      	movs	r0, #0
 80038e2:	9000      	str	r0, [sp, #0]
 80038e4:	2300      	movs	r3, #0
 80038e6:	221e      	movs	r2, #30
 80038e8:	68e0      	ldr	r0, [r4, #12]
 80038ea:	2101      	movs	r1, #1
 80038ec:	4001      	ands	r1, r0
 80038ee:	2009      	movs	r0, #9
 80038f0:	68ff      	ldr	r7, [r7, #12]
 80038f2:	47b8      	blx	r7
 80038f4:	211e      	movs	r1, #30
 80038f6:	68e2      	ldr	r2, [r4, #12]
 80038f8:	2001      	movs	r0, #1
 80038fa:	4010      	ands	r0, r2
 80038fc:	68a2      	ldr	r2, [r4, #8]
 80038fe:	68d2      	ldr	r2, [r2, #12]
 8003900:	4790      	blx	r2
 8003902:	68e1      	ldr	r1, [r4, #12]
 8003904:	2001      	movs	r0, #1
 8003906:	4008      	ands	r0, r1
 8003908:	f001 fd3f 	bl	800538a <USBPD_PRL_ResetRequestReset>
 800390c:	20e2      	movs	r0, #226	; 0xe2
 800390e:	0080      	lsls	r0, r0, #2
 8003910:	1820      	adds	r0, r4, r0
 8003912:	9000      	str	r0, [sp, #0]
 8003914:	4f3b      	ldr	r7, [pc, #236]	; (8003a04 <.text_46>)
 8003916:	2105      	movs	r1, #5
 8003918:	68e2      	ldr	r2, [r4, #12]
 800391a:	2001      	movs	r0, #1
 800391c:	4010      	ands	r0, r2
 800391e:	f001 fd3f 	bl	80053a0 <USBPD_PRL_ResetRequestProcess>
 8003922:	2803      	cmp	r0, #3
 8003924:	d10a      	bne.n	800393c <PE_Send_HARDRESET+0x70>
 8003926:	9800      	ldr	r0, [sp, #0]
 8003928:	6800      	ldr	r0, [r0, #0]
 800392a:	1b40      	subs	r0, r0, r5
 800392c:	42b8      	cmp	r0, r7
 800392e:	d204      	bcs.n	800393a <PE_Send_HARDRESET+0x6e>
 8003930:	6860      	ldr	r0, [r4, #4]
 8003932:	6800      	ldr	r0, [r0, #0]
 8003934:	0ac0      	lsrs	r0, r0, #11
 8003936:	4030      	ands	r0, r6
 8003938:	d1ed      	bne.n	8003916 <PE_Send_HARDRESET+0x4a>
 800393a:	2004      	movs	r0, #4
 800393c:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

0800393e <PE_PerformSoftReset>:
 800393e:	b538      	push	{r3, r4, r5, lr}
 8003940:	0004      	movs	r4, r0
 8003942:	2500      	movs	r5, #0
 8003944:	2001      	movs	r0, #1
 8003946:	6861      	ldr	r1, [r4, #4]
 8003948:	7809      	ldrb	r1, [r1, #0]
 800394a:	0889      	lsrs	r1, r1, #2
 800394c:	4201      	tst	r1, r0
 800394e:	d006      	beq.n	800395e <PE_PerformSoftReset+0x20>
 8003950:	7565      	strb	r5, [r4, #21]
 8003952:	2101      	movs	r1, #1
 8003954:	68e2      	ldr	r2, [r4, #12]
 8003956:	4010      	ands	r0, r2
 8003958:	f001 fae3 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 800395c:	bd31      	pop	{r0, r4, r5, pc}
 800395e:	2100      	movs	r1, #0
 8003960:	68e2      	ldr	r2, [r4, #12]
 8003962:	4010      	ands	r0, r2
 8003964:	f001 fadd 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8003968:	4828      	ldr	r0, [pc, #160]	; (8003a0c <.text_48>)
 800396a:	5225      	strh	r5, [r4, r0]
 800396c:	7525      	strb	r5, [r4, #20]
 800396e:	bd31      	pop	{r0, r4, r5, pc}

08003970 <.text_40>:
 8003970:	00000242 	.word	0x00000242

08003974 <PE_Get_DataRole>:
 8003974:	4924      	ldr	r1, [pc, #144]	; (8003a08 <.text_47>)
 8003976:	0080      	lsls	r0, r0, #2
 8003978:	1808      	adds	r0, r1, r0
 800397a:	6840      	ldr	r0, [r0, #4]
 800397c:	6840      	ldr	r0, [r0, #4]
 800397e:	7800      	ldrb	r0, [r0, #0]
 8003980:	0701      	lsls	r1, r0, #28
 8003982:	0fc8      	lsrs	r0, r1, #31
 8003984:	4770      	bx	lr

08003986 <PE_Get_SpecRevision>:
 8003986:	4920      	ldr	r1, [pc, #128]	; (8003a08 <.text_47>)
 8003988:	0080      	lsls	r0, r0, #2
 800398a:	1808      	adds	r0, r1, r0
 800398c:	6840      	ldr	r0, [r0, #4]
 800398e:	6840      	ldr	r0, [r0, #4]
 8003990:	7800      	ldrb	r0, [r0, #0]
 8003992:	0780      	lsls	r0, r0, #30
 8003994:	0f80      	lsrs	r0, r0, #30
 8003996:	4770      	bx	lr

08003998 <.text_43>:
 8003998:	00000393 	.word	0x00000393

0800399c <PE_ChangePowerRole>:
 800399c:	b538      	push	{r3, r4, r5, lr}
 800399e:	6842      	ldr	r2, [r0, #4]
 80039a0:	7813      	ldrb	r3, [r2, #0]
 80039a2:	24fb      	movs	r4, #251	; 0xfb
 80039a4:	401c      	ands	r4, r3
 80039a6:	008b      	lsls	r3, r1, #2
 80039a8:	2504      	movs	r5, #4
 80039aa:	402b      	ands	r3, r5
 80039ac:	4323      	orrs	r3, r4
 80039ae:	7013      	strb	r3, [r2, #0]
 80039b0:	7b02      	ldrb	r2, [r0, #12]
 80039b2:	07d0      	lsls	r0, r2, #31
 80039b4:	0fc0      	lsrs	r0, r0, #31
 80039b6:	f001 fab4 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 80039ba:	bd31      	pop	{r0, r4, r5, pc}

080039bc <PE_Check_RxEvent>:
 80039bc:	b081      	sub	sp, #4
 80039be:	0001      	movs	r1, r0
 80039c0:	2014      	movs	r0, #20
 80039c2:	4a13      	ldr	r2, [pc, #76]	; (8003a10 <.text_49>)
 80039c4:	1889      	adds	r1, r1, r2
 80039c6:	780a      	ldrb	r2, [r1, #0]
 80039c8:	2a00      	cmp	r2, #0
 80039ca:	d019      	beq.n	8003a00 <PE_Check_RxEvent+0x44>
 80039cc:	780a      	ldrb	r2, [r1, #0]
 80039ce:	0692      	lsls	r2, r2, #26
 80039d0:	d401      	bmi.n	80039d6 <PE_Check_RxEvent+0x1a>
 80039d2:	2003      	movs	r0, #3
 80039d4:	e014      	b.n	8003a00 <PE_Check_RxEvent+0x44>
 80039d6:	2200      	movs	r2, #0
 80039d8:	780b      	ldrb	r3, [r1, #0]
 80039da:	06db      	lsls	r3, r3, #27
 80039dc:	0edb      	lsrs	r3, r3, #27
 80039de:	2b01      	cmp	r3, #1
 80039e0:	d004      	beq.n	80039ec <PE_Check_RxEvent+0x30>
 80039e2:	2b02      	cmp	r3, #2
 80039e4:	d005      	beq.n	80039f2 <PE_Check_RxEvent+0x36>
 80039e6:	2b04      	cmp	r3, #4
 80039e8:	d006      	beq.n	80039f8 <PE_Check_RxEvent+0x3c>
 80039ea:	e008      	b.n	80039fe <PE_Check_RxEvent+0x42>
 80039ec:	2011      	movs	r0, #17
 80039ee:	710a      	strb	r2, [r1, #4]
 80039f0:	e005      	b.n	80039fe <PE_Check_RxEvent+0x42>
 80039f2:	2012      	movs	r0, #18
 80039f4:	2301      	movs	r3, #1
 80039f6:	e001      	b.n	80039fc <PE_Check_RxEvent+0x40>
 80039f8:	2013      	movs	r0, #19
 80039fa:	2302      	movs	r3, #2
 80039fc:	710b      	strb	r3, [r1, #4]
 80039fe:	700a      	strb	r2, [r1, #0]
 8003a00:	b001      	add	sp, #4
 8003a02:	4770      	bx	lr

08003a04 <.text_46>:
 8003a04:	00001771 	.word	0x00001771

08003a08 <.text_47>:
 8003a08:	200019e8 	.word	0x200019e8

08003a0c <.text_48>:
 8003a0c:	0000036e 	.word	0x0000036e

08003a10 <.text_49>:
 8003a10:	00000356 	.word	0x00000356

08003a14 <PE_Check_AMSConflict>:
 8003a14:	b081      	sub	sp, #4
 8003a16:	21d6      	movs	r1, #214	; 0xd6
 8003a18:	0089      	lsls	r1, r1, #2
 8003a1a:	1841      	adds	r1, r0, r1
 8003a1c:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
 8003a1e:	0bd2      	lsrs	r2, r2, #15
 8003a20:	d10a      	bne.n	8003a38 <PE_Check_AMSConflict+0x24>
 8003a22:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
 8003a24:	0452      	lsls	r2, r2, #17
 8003a26:	0f52      	lsrs	r2, r2, #29
 8003a28:	d106      	bne.n	8003a38 <PE_Check_AMSConflict+0x24>
 8003a2a:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
 8003a2c:	06d2      	lsls	r2, r2, #27
 8003a2e:	0ed2      	lsrs	r2, r2, #27
 8003a30:	2a0d      	cmp	r2, #13
 8003a32:	d101      	bne.n	8003a38 <PE_Check_AMSConflict+0x24>
 8003a34:	2010      	movs	r0, #16
 8003a36:	e01a      	b.n	8003a6e <PE_Check_AMSConflict+0x5a>
 8003a38:	2216      	movs	r2, #22
 8003a3a:	5e80      	ldrsh	r0, [r0, r2]
 8003a3c:	2203      	movs	r2, #3
 8003a3e:	0003      	movs	r3, r0
 8003a40:	d00f      	beq.n	8003a62 <PE_Check_AMSConflict+0x4e>
 8003a42:	1e43      	subs	r3, r0, #1
 8003a44:	2b01      	cmp	r3, #1
 8003a46:	d90f      	bls.n	8003a68 <PE_Check_AMSConflict+0x54>
 8003a48:	1e9b      	subs	r3, r3, #2
 8003a4a:	d00f      	beq.n	8003a6c <PE_Check_AMSConflict+0x58>
 8003a4c:	1e5b      	subs	r3, r3, #1
 8003a4e:	d00f      	beq.n	8003a70 <PE_Check_AMSConflict+0x5c>
 8003a50:	1e5b      	subs	r3, r3, #1
 8003a52:	2b0b      	cmp	r3, #11
 8003a54:	d908      	bls.n	8003a68 <PE_Check_AMSConflict+0x54>
 8003a56:	3b0c      	subs	r3, #12
 8003a58:	d00f      	beq.n	8003a7a <PE_Check_AMSConflict+0x66>
 8003a5a:	3bef      	subs	r3, #239	; 0xef
 8003a5c:	2b0e      	cmp	r3, #14
 8003a5e:	d909      	bls.n	8003a74 <PE_Check_AMSConflict+0x60>
 8003a60:	e00c      	b.n	8003a7c <PE_Check_AMSConflict+0x68>
 8003a62:	2004      	movs	r0, #4
 8003a64:	7008      	strb	r0, [r1, #0]
 8003a66:	e009      	b.n	8003a7c <PE_Check_AMSConflict+0x68>
 8003a68:	2011      	movs	r0, #17
 8003a6a:	e000      	b.n	8003a6e <PE_Check_AMSConflict+0x5a>
 8003a6c:	200f      	movs	r0, #15
 8003a6e:	7008      	strb	r0, [r1, #0]
 8003a70:	2015      	movs	r0, #21
 8003a72:	e004      	b.n	8003a7e <PE_Check_AMSConflict+0x6a>
 8003a74:	80c8      	strh	r0, [r1, #6]
 8003a76:	7808      	ldrb	r0, [r1, #0]
 8003a78:	7108      	strb	r0, [r1, #4]
 8003a7a:	700a      	strb	r2, [r1, #0]
 8003a7c:	2000      	movs	r0, #0
 8003a7e:	b001      	add	sp, #4
 8003a80:	4770      	bx	lr
	...

08003a84 <PE_Check_ControlMessage>:
 8003a84:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 8003a86:	0004      	movs	r4, r0
 8003a88:	48ca      	ldr	r0, [pc, #808]	; (8003db4 <.text_52>)
 8003a8a:	68c1      	ldr	r1, [r0, #12]
 8003a8c:	9101      	str	r1, [sp, #4]
 8003a8e:	7800      	ldrb	r0, [r0, #0]
 8003a90:	2102      	movs	r1, #2
 8003a92:	4008      	ands	r0, r1
 8003a94:	21d6      	movs	r1, #214	; 0xd6
 8003a96:	0089      	lsls	r1, r1, #2
 8003a98:	1866      	adds	r6, r4, r1
 8003a9a:	2103      	movs	r1, #3
 8003a9c:	2501      	movs	r5, #1
 8003a9e:	222a      	movs	r2, #42	; 0x2a
 8003aa0:	8db3      	ldrh	r3, [r6, #44]	; 0x2c
 8003aa2:	06db      	lsls	r3, r3, #27
 8003aa4:	0edb      	lsrs	r3, r3, #27
 8003aa6:	1e5b      	subs	r3, r3, #1
 8003aa8:	2b14      	cmp	r3, #20
 8003aaa:	d900      	bls.n	8003aae <PE_Check_ControlMessage+0x2a>
 8003aac:	e17b      	b.n	8003da6 <PE_Check_ControlMessage+0x322>
 8003aae:	a702      	add	r7, pc, #8	; (adr r7, 8003ab8 <PE_Check_ControlMessage+0x34>)
 8003ab0:	005b      	lsls	r3, r3, #1
 8003ab2:	5aff      	ldrh	r7, [r7, r3]
 8003ab4:	44bf      	add	pc, r7
 8003ab6:	bf00      	nop
 8003ab8:	002a02fa 	.word	0x002a02fa
 8003abc:	02e802e8 	.word	0x02e802e8
 8003ac0:	02e80090 	.word	0x02e80090
 8003ac4:	01d400ac 	.word	0x01d400ac
 8003ac8:	016e01b8 	.word	0x016e01b8
 8003acc:	02e801a8 	.word	0x02e801a8
 8003ad0:	02ee0064 	.word	0x02ee0064
 8003ad4:	02fa02ee 	.word	0x02fa02ee
 8003ad8:	025e021e 	.word	0x025e021e
 8003adc:	028c02e2 	.word	0x028c02e2
 8003ae0:	02d4      	.short	0x02d4
 8003ae2:	6861      	ldr	r1, [r4, #4]
 8003ae4:	7809      	ldrb	r1, [r1, #0]
 8003ae6:	0889      	lsrs	r1, r1, #2
 8003ae8:	4229      	tst	r1, r5
 8003aea:	d000      	beq.n	8003aee <PE_Check_ControlMessage+0x6a>
 8003aec:	e161      	b.n	8003db2 <PE_Check_ControlMessage+0x32e>
 8003aee:	2102      	movs	r1, #2
 8003af0:	82e1      	strh	r1, [r4, #22]
 8003af2:	2800      	cmp	r0, #0
 8003af4:	d009      	beq.n	8003b0a <PE_Check_ControlMessage+0x86>
 8003af6:	2000      	movs	r0, #0
 8003af8:	9000      	str	r0, [sp, #0]
 8003afa:	2300      	movs	r3, #0
 8003afc:	2229      	movs	r2, #41	; 0x29
 8003afe:	68e0      	ldr	r0, [r4, #12]
 8003b00:	2101      	movs	r1, #1
 8003b02:	4001      	ands	r1, r0
 8003b04:	2009      	movs	r0, #9
 8003b06:	9f01      	ldr	r7, [sp, #4]
 8003b08:	47b8      	blx	r7
 8003b0a:	2129      	movs	r1, #41	; 0x29
 8003b0c:	68e0      	ldr	r0, [r4, #12]
 8003b0e:	4005      	ands	r5, r0
 8003b10:	0028      	movs	r0, r5
 8003b12:	68a2      	ldr	r2, [r4, #8]
 8003b14:	68d2      	ldr	r2, [r2, #12]
 8003b16:	4790      	blx	r2
 8003b18:	2098      	movs	r0, #152	; 0x98
 8003b1a:	e142      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003b1c:	82e1      	strh	r1, [r4, #22]
 8003b1e:	2800      	cmp	r0, #0
 8003b20:	d009      	beq.n	8003b36 <PE_Check_ControlMessage+0xb2>
 8003b22:	2000      	movs	r0, #0
 8003b24:	9000      	str	r0, [sp, #0]
 8003b26:	2300      	movs	r3, #0
 8003b28:	2230      	movs	r2, #48	; 0x30
 8003b2a:	68e0      	ldr	r0, [r4, #12]
 8003b2c:	2101      	movs	r1, #1
 8003b2e:	4001      	ands	r1, r0
 8003b30:	2009      	movs	r0, #9
 8003b32:	9f01      	ldr	r7, [sp, #4]
 8003b34:	47b8      	blx	r7
 8003b36:	2130      	movs	r1, #48	; 0x30
 8003b38:	68e0      	ldr	r0, [r4, #12]
 8003b3a:	4005      	ands	r5, r0
 8003b3c:	0028      	movs	r0, r5
 8003b3e:	68a2      	ldr	r2, [r4, #8]
 8003b40:	68d2      	ldr	r2, [r2, #12]
 8003b42:	4790      	blx	r2
 8003b44:	2010      	movs	r0, #16
 8003b46:	e12c      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003b48:	2800      	cmp	r0, #0
 8003b4a:	d009      	beq.n	8003b60 <PE_Check_ControlMessage+0xdc>
 8003b4c:	2000      	movs	r0, #0
 8003b4e:	9000      	str	r0, [sp, #0]
 8003b50:	2300      	movs	r3, #0
 8003b52:	2231      	movs	r2, #49	; 0x31
 8003b54:	68e0      	ldr	r0, [r4, #12]
 8003b56:	2101      	movs	r1, #1
 8003b58:	4001      	ands	r1, r0
 8003b5a:	2009      	movs	r0, #9
 8003b5c:	9e01      	ldr	r6, [sp, #4]
 8003b5e:	47b0      	blx	r6
 8003b60:	2131      	movs	r1, #49	; 0x31
 8003b62:	e10c      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003b64:	2306      	movs	r3, #6
 8003b66:	82e3      	strh	r3, [r4, #22]
 8003b68:	466b      	mov	r3, sp
 8003b6a:	6867      	ldr	r7, [r4, #4]
 8003b6c:	783f      	ldrb	r7, [r7, #0]
 8003b6e:	701f      	strb	r7, [r3, #0]
 8003b70:	463b      	mov	r3, r7
 8003b72:	089f      	lsrs	r7, r3, #2
 8003b74:	422f      	tst	r7, r5
 8003b76:	d04d      	beq.n	8003c14 <PE_Check_ControlMessage+0x190>
 8003b78:	2800      	cmp	r0, #0
 8003b7a:	d009      	beq.n	8003b90 <PE_Check_ControlMessage+0x10c>
 8003b7c:	2000      	movs	r0, #0
 8003b7e:	9000      	str	r0, [sp, #0]
 8003b80:	2300      	movs	r3, #0
 8003b82:	220c      	movs	r2, #12
 8003b84:	68e0      	ldr	r0, [r4, #12]
 8003b86:	2101      	movs	r1, #1
 8003b88:	4001      	ands	r1, r0
 8003b8a:	2009      	movs	r0, #9
 8003b8c:	9f01      	ldr	r7, [sp, #4]
 8003b8e:	47b8      	blx	r7
 8003b90:	210c      	movs	r1, #12
 8003b92:	68e2      	ldr	r2, [r4, #12]
 8003b94:	2001      	movs	r0, #1
 8003b96:	4010      	ands	r0, r2
 8003b98:	68a2      	ldr	r2, [r4, #8]
 8003b9a:	68d2      	ldr	r2, [r2, #12]
 8003b9c:	4790      	blx	r2
 8003b9e:	2100      	movs	r1, #0
 8003ba0:	0020      	movs	r0, r4
 8003ba2:	f7ff fd8c 	bl	80036be <PE_Send_SRCCapabilities>
 8003ba6:	2805      	cmp	r0, #5
 8003ba8:	d002      	beq.n	8003bb0 <PE_Check_ControlMessage+0x12c>
 8003baa:	2000      	movs	r0, #0
 8003bac:	82e0      	strh	r0, [r4, #22]
 8003bae:	e0f7      	b.n	8003da0 <PE_Check_ControlMessage+0x31c>
 8003bb0:	6860      	ldr	r0, [r4, #4]
 8003bb2:	7841      	ldrb	r1, [r0, #1]
 8003bb4:	228f      	movs	r2, #143	; 0x8f
 8003bb6:	400a      	ands	r2, r1
 8003bb8:	2140      	movs	r1, #64	; 0x40
 8003bba:	4311      	orrs	r1, r2
 8003bbc:	7041      	strb	r1, [r0, #1]
 8003bbe:	487d      	ldr	r0, [pc, #500]	; (8003db4 <.text_52>)
 8003bc0:	7800      	ldrb	r0, [r0, #0]
 8003bc2:	0780      	lsls	r0, r0, #30
 8003bc4:	d50a      	bpl.n	8003bdc <PE_Check_ControlMessage+0x158>
 8003bc6:	2000      	movs	r0, #0
 8003bc8:	9000      	str	r0, [sp, #0]
 8003bca:	2300      	movs	r3, #0
 8003bcc:	2256      	movs	r2, #86	; 0x56
 8003bce:	68e0      	ldr	r0, [r4, #12]
 8003bd0:	2101      	movs	r1, #1
 8003bd2:	4001      	ands	r1, r0
 8003bd4:	2009      	movs	r0, #9
 8003bd6:	4f77      	ldr	r7, [pc, #476]	; (8003db4 <.text_52>)
 8003bd8:	68ff      	ldr	r7, [r7, #12]
 8003bda:	47b8      	blx	r7
 8003bdc:	2156      	movs	r1, #86	; 0x56
 8003bde:	68e2      	ldr	r2, [r4, #12]
 8003be0:	2001      	movs	r0, #1
 8003be2:	4010      	ands	r0, r2
 8003be4:	68a2      	ldr	r2, [r4, #8]
 8003be6:	68d2      	ldr	r2, [r2, #12]
 8003be8:	4790      	blx	r2
 8003bea:	82e5      	strh	r5, [r4, #22]
 8003bec:	4872      	ldr	r0, [pc, #456]	; (8003db8 <.text_53>)
 8003bee:	82b0      	strh	r0, [r6, #20]
 8003bf0:	2016      	movs	r0, #22
 8003bf2:	7030      	strb	r0, [r6, #0]
 8003bf4:	4e6f      	ldr	r6, [pc, #444]	; (8003db4 <.text_52>)
 8003bf6:	7830      	ldrb	r0, [r6, #0]
 8003bf8:	0780      	lsls	r0, r0, #30
 8003bfa:	d509      	bpl.n	8003c10 <PE_Check_ControlMessage+0x18c>
 8003bfc:	2000      	movs	r0, #0
 8003bfe:	9000      	str	r0, [sp, #0]
 8003c00:	2300      	movs	r3, #0
 8003c02:	220f      	movs	r2, #15
 8003c04:	68e0      	ldr	r0, [r4, #12]
 8003c06:	2101      	movs	r1, #1
 8003c08:	4001      	ands	r1, r0
 8003c0a:	2009      	movs	r0, #9
 8003c0c:	68f6      	ldr	r6, [r6, #12]
 8003c0e:	47b0      	blx	r6
 8003c10:	210f      	movs	r1, #15
 8003c12:	e0b4      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003c14:	6820      	ldr	r0, [r4, #0]
 8003c16:	6840      	ldr	r0, [r0, #4]
 8003c18:	08c0      	lsrs	r0, r0, #3
 8003c1a:	4028      	ands	r0, r5
 8003c1c:	d001      	beq.n	8003c22 <PE_Check_ControlMessage+0x19e>
 8003c1e:	204c      	movs	r0, #76	; 0x4c
 8003c20:	e0bf      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003c22:	4019      	ands	r1, r3
 8003c24:	e02b      	b.n	8003c7e <PE_Check_ControlMessage+0x1fa>
 8003c26:	6823      	ldr	r3, [r4, #0]
 8003c28:	685b      	ldr	r3, [r3, #4]
 8003c2a:	08db      	lsrs	r3, r3, #3
 8003c2c:	402b      	ands	r3, r5
 8003c2e:	d023      	beq.n	8003c78 <PE_Check_ControlMessage+0x1f4>
 8003c30:	2122      	movs	r1, #34	; 0x22
 8003c32:	7031      	strb	r1, [r6, #0]
 8003c34:	2800      	cmp	r0, #0
 8003c36:	d009      	beq.n	8003c4c <PE_Check_ControlMessage+0x1c8>
 8003c38:	2000      	movs	r0, #0
 8003c3a:	9000      	str	r0, [sp, #0]
 8003c3c:	2300      	movs	r3, #0
 8003c3e:	223a      	movs	r2, #58	; 0x3a
 8003c40:	68e0      	ldr	r0, [r4, #12]
 8003c42:	2101      	movs	r1, #1
 8003c44:	4001      	ands	r1, r0
 8003c46:	2009      	movs	r0, #9
 8003c48:	9e01      	ldr	r6, [sp, #4]
 8003c4a:	47b0      	blx	r6
 8003c4c:	213a      	movs	r1, #58	; 0x3a
 8003c4e:	68e0      	ldr	r0, [r4, #12]
 8003c50:	4005      	ands	r5, r0
 8003c52:	0028      	movs	r0, r5
 8003c54:	68a2      	ldr	r2, [r4, #8]
 8003c56:	68d2      	ldr	r2, [r2, #12]
 8003c58:	4790      	blx	r2
 8003c5a:	2008      	movs	r0, #8
 8003c5c:	82e0      	strh	r0, [r4, #22]
 8003c5e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003c60:	68a0      	ldr	r0, [r4, #8]
 8003c62:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8003c64:	2800      	cmp	r0, #0
 8003c66:	d007      	beq.n	8003c78 <PE_Check_ControlMessage+0x1f4>
 8003c68:	2010      	movs	r0, #16
 8003c6a:	82e0      	strh	r0, [r4, #22]
 8003c6c:	209d      	movs	r0, #157	; 0x9d
 8003c6e:	e098      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003c70:	68a0      	ldr	r0, [r4, #8]
 8003c72:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 8003c74:	2800      	cmp	r0, #0
 8003c76:	d105      	bne.n	8003c84 <PE_Check_ControlMessage+0x200>
 8003c78:	6860      	ldr	r0, [r4, #4]
 8003c7a:	7800      	ldrb	r0, [r0, #0]
 8003c7c:	4001      	ands	r1, r0
 8003c7e:	2902      	cmp	r1, #2
 8003c80:	d127      	bne.n	8003cd2 <PE_Check_ControlMessage+0x24e>
 8003c82:	e095      	b.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003c84:	200f      	movs	r0, #15
 8003c86:	82e0      	strh	r0, [r4, #22]
 8003c88:	2093      	movs	r0, #147	; 0x93
 8003c8a:	e08a      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003c8c:	2307      	movs	r3, #7
 8003c8e:	82e3      	strh	r3, [r4, #22]
 8003c90:	466b      	mov	r3, sp
 8003c92:	6867      	ldr	r7, [r4, #4]
 8003c94:	783f      	ldrb	r7, [r7, #0]
 8003c96:	701f      	strb	r7, [r3, #0]
 8003c98:	08bf      	lsrs	r7, r7, #2
 8003c9a:	422f      	tst	r7, r5
 8003c9c:	d004      	beq.n	8003ca8 <PE_Check_ControlMessage+0x224>
 8003c9e:	6823      	ldr	r3, [r4, #0]
 8003ca0:	685b      	ldr	r3, [r3, #4]
 8003ca2:	08db      	lsrs	r3, r3, #3
 8003ca4:	402b      	ands	r3, r5
 8003ca6:	d00f      	beq.n	8003cc8 <PE_Check_ControlMessage+0x244>
 8003ca8:	211d      	movs	r1, #29
 8003caa:	7031      	strb	r1, [r6, #0]
 8003cac:	2800      	cmp	r0, #0
 8003cae:	d009      	beq.n	8003cc4 <PE_Check_ControlMessage+0x240>
 8003cb0:	2000      	movs	r0, #0
 8003cb2:	9000      	str	r0, [sp, #0]
 8003cb4:	2300      	movs	r3, #0
 8003cb6:	2206      	movs	r2, #6
 8003cb8:	68e0      	ldr	r0, [r4, #12]
 8003cba:	2101      	movs	r1, #1
 8003cbc:	4001      	ands	r1, r0
 8003cbe:	2009      	movs	r0, #9
 8003cc0:	9e01      	ldr	r6, [sp, #4]
 8003cc2:	47b0      	blx	r6
 8003cc4:	2106      	movs	r1, #6
 8003cc6:	e05a      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003cc8:	4668      	mov	r0, sp
 8003cca:	7800      	ldrb	r0, [r0, #0]
 8003ccc:	4001      	ands	r1, r0
 8003cce:	2902      	cmp	r1, #2
 8003cd0:	d06e      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003cd2:	7032      	strb	r2, [r6, #0]
 8003cd4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003cd6:	6821      	ldr	r1, [r4, #0]
 8003cd8:	88ca      	ldrh	r2, [r1, #6]
 8003cda:	08d2      	lsrs	r2, r2, #3
 8003cdc:	422a      	tst	r2, r5
 8003cde:	d067      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003ce0:	6862      	ldr	r2, [r4, #4]
 8003ce2:	7812      	ldrb	r2, [r2, #0]
 8003ce4:	0892      	lsrs	r2, r2, #2
 8003ce6:	422a      	tst	r2, r5
 8003ce8:	d103      	bne.n	8003cf2 <PE_Check_ControlMessage+0x26e>
 8003cea:	6849      	ldr	r1, [r1, #4]
 8003cec:	08c9      	lsrs	r1, r1, #3
 8003cee:	4029      	ands	r1, r5
 8003cf0:	d05e      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003cf2:	210a      	movs	r1, #10
 8003cf4:	82e1      	strh	r1, [r4, #22]
 8003cf6:	2163      	movs	r1, #99	; 0x63
 8003cf8:	7031      	strb	r1, [r6, #0]
 8003cfa:	2800      	cmp	r0, #0
 8003cfc:	d009      	beq.n	8003d12 <PE_Check_ControlMessage+0x28e>
 8003cfe:	2000      	movs	r0, #0
 8003d00:	9000      	str	r0, [sp, #0]
 8003d02:	2300      	movs	r3, #0
 8003d04:	2243      	movs	r2, #67	; 0x43
 8003d06:	68e0      	ldr	r0, [r4, #12]
 8003d08:	2101      	movs	r1, #1
 8003d0a:	4001      	ands	r1, r0
 8003d0c:	2009      	movs	r0, #9
 8003d0e:	9e01      	ldr	r6, [sp, #4]
 8003d10:	47b0      	blx	r6
 8003d12:	2143      	movs	r1, #67	; 0x43
 8003d14:	e033      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003d16:	6821      	ldr	r1, [r4, #0]
 8003d18:	88c9      	ldrh	r1, [r1, #6]
 8003d1a:	0949      	lsrs	r1, r1, #5
 8003d1c:	4229      	tst	r1, r5
 8003d1e:	d047      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003d20:	210b      	movs	r1, #11
 8003d22:	82e1      	strh	r1, [r4, #22]
 8003d24:	2130      	movs	r1, #48	; 0x30
 8003d26:	7031      	strb	r1, [r6, #0]
 8003d28:	2800      	cmp	r0, #0
 8003d2a:	d009      	beq.n	8003d40 <PE_Check_ControlMessage+0x2bc>
 8003d2c:	2000      	movs	r0, #0
 8003d2e:	9000      	str	r0, [sp, #0]
 8003d30:	2300      	movs	r3, #0
 8003d32:	224a      	movs	r2, #74	; 0x4a
 8003d34:	68e0      	ldr	r0, [r4, #12]
 8003d36:	2101      	movs	r1, #1
 8003d38:	4001      	ands	r1, r0
 8003d3a:	2009      	movs	r0, #9
 8003d3c:	9e01      	ldr	r6, [sp, #4]
 8003d3e:	47b0      	blx	r6
 8003d40:	214a      	movs	r1, #74	; 0x4a
 8003d42:	e01c      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003d44:	6821      	ldr	r1, [r4, #0]
 8003d46:	88c9      	ldrh	r1, [r1, #6]
 8003d48:	0889      	lsrs	r1, r1, #2
 8003d4a:	4229      	tst	r1, r5
 8003d4c:	d030      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003d4e:	210b      	movs	r1, #11
 8003d50:	82e1      	strh	r1, [r4, #22]
 8003d52:	6861      	ldr	r1, [r4, #4]
 8003d54:	7809      	ldrb	r1, [r1, #0]
 8003d56:	0889      	lsrs	r1, r1, #2
 8003d58:	4229      	tst	r1, r5
 8003d5a:	d001      	beq.n	8003d60 <PE_Check_ControlMessage+0x2dc>
 8003d5c:	212d      	movs	r1, #45	; 0x2d
 8003d5e:	e000      	b.n	8003d62 <PE_Check_ControlMessage+0x2de>
 8003d60:	2111      	movs	r1, #17
 8003d62:	7031      	strb	r1, [r6, #0]
 8003d64:	2800      	cmp	r0, #0
 8003d66:	d009      	beq.n	8003d7c <PE_Check_ControlMessage+0x2f8>
 8003d68:	2000      	movs	r0, #0
 8003d6a:	9000      	str	r0, [sp, #0]
 8003d6c:	2300      	movs	r3, #0
 8003d6e:	2246      	movs	r2, #70	; 0x46
 8003d70:	68e0      	ldr	r0, [r4, #12]
 8003d72:	2101      	movs	r1, #1
 8003d74:	4001      	ands	r1, r0
 8003d76:	2009      	movs	r0, #9
 8003d78:	9e01      	ldr	r6, [sp, #4]
 8003d7a:	47b0      	blx	r6
 8003d7c:	2146      	movs	r1, #70	; 0x46
 8003d7e:	68e0      	ldr	r0, [r4, #12]
 8003d80:	4005      	ands	r5, r0
 8003d82:	0028      	movs	r0, r5
 8003d84:	68a2      	ldr	r2, [r4, #8]
 8003d86:	68d2      	ldr	r2, [r2, #12]
 8003d88:	4790      	blx	r2
 8003d8a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003d8c:	6820      	ldr	r0, [r4, #0]
 8003d8e:	88c0      	ldrh	r0, [r0, #6]
 8003d90:	0a00      	lsrs	r0, r0, #8
 8003d92:	4228      	tst	r0, r5
 8003d94:	d00c      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003d96:	202f      	movs	r0, #47	; 0x2f
 8003d98:	e003      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003d9a:	2009      	movs	r0, #9
 8003d9c:	82e0      	strh	r0, [r4, #22]
 8003d9e:	e007      	b.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003da0:	2011      	movs	r0, #17
 8003da2:	7030      	strb	r0, [r6, #0]
 8003da4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003da6:	6860      	ldr	r0, [r4, #4]
 8003da8:	7800      	ldrb	r0, [r0, #0]
 8003daa:	4001      	ands	r1, r0
 8003dac:	2902      	cmp	r1, #2
 8003dae:	d100      	bne.n	8003db2 <PE_Check_ControlMessage+0x32e>
 8003db0:	7035      	strb	r5, [r6, #0]
 8003db2:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

08003db4 <.text_52>:
 8003db4:	200019e8 	.word	0x200019e8

08003db8 <.text_53>:
 8003db8:	0000801a 	.word	0x0000801a

08003dbc <PE_Check_DataMessage>:
 8003dbc:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 8003dbe:	0004      	movs	r4, r0
 8003dc0:	209e      	movs	r0, #158	; 0x9e
 8003dc2:	0040      	lsls	r0, r0, #1
 8003dc4:	1827      	adds	r7, r4, r0
 8003dc6:	20d6      	movs	r0, #214	; 0xd6
 8003dc8:	0080      	lsls	r0, r0, #2
 8003dca:	1826      	adds	r6, r4, r0
 8003dcc:	2501      	movs	r5, #1
 8003dce:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 8003dd0:	06c0      	lsls	r0, r0, #27
 8003dd2:	0ec0      	lsrs	r0, r0, #27
 8003dd4:	2801      	cmp	r0, #1
 8003dd6:	d02f      	beq.n	8003e38 <PE_Check_DataMessage+0x7c>
 8003dd8:	2802      	cmp	r0, #2
 8003dda:	d009      	beq.n	8003df0 <PE_Check_DataMessage+0x34>
 8003ddc:	2803      	cmp	r0, #3
 8003dde:	d047      	beq.n	8003e70 <PE_Check_DataMessage+0xb4>
 8003de0:	2806      	cmp	r0, #6
 8003de2:	d07d      	beq.n	8003ee0 <PE_Check_DataMessage+0x124>
 8003de4:	2807      	cmp	r0, #7
 8003de6:	d100      	bne.n	8003dea <PE_Check_DataMessage+0x2e>
 8003de8:	e08a      	b.n	8003f00 <PE_Check_DataMessage+0x144>
 8003dea:	280f      	cmp	r0, #15
 8003dec:	d071      	beq.n	8003ed2 <PE_Check_DataMessage+0x116>
 8003dee:	e090      	b.n	8003f12 <PE_Check_DataMessage+0x156>
 8003df0:	6860      	ldr	r0, [r4, #4]
 8003df2:	7800      	ldrb	r0, [r0, #0]
 8003df4:	0880      	lsrs	r0, r0, #2
 8003df6:	4228      	tst	r0, r5
 8003df8:	d100      	bne.n	8003dfc <PE_Check_DataMessage+0x40>
 8003dfa:	e08c      	b.n	8003f16 <PE_Check_DataMessage+0x15a>
 8003dfc:	7838      	ldrb	r0, [r7, #0]
 8003dfe:	7879      	ldrb	r1, [r7, #1]
 8003e00:	0209      	lsls	r1, r1, #8
 8003e02:	1840      	adds	r0, r0, r1
 8003e04:	78b9      	ldrb	r1, [r7, #2]
 8003e06:	0409      	lsls	r1, r1, #16
 8003e08:	1840      	adds	r0, r0, r1
 8003e0a:	78f9      	ldrb	r1, [r7, #3]
 8003e0c:	0609      	lsls	r1, r1, #24
 8003e0e:	1840      	adds	r0, r0, r1
 8003e10:	9000      	str	r0, [sp, #0]
 8003e12:	2304      	movs	r3, #4
 8003e14:	466a      	mov	r2, sp
 8003e16:	2106      	movs	r1, #6
 8003e18:	68e7      	ldr	r7, [r4, #12]
 8003e1a:	2001      	movs	r0, #1
 8003e1c:	4038      	ands	r0, r7
 8003e1e:	68a7      	ldr	r7, [r4, #8]
 8003e20:	69ff      	ldr	r7, [r7, #28]
 8003e22:	47b8      	blx	r7
 8003e24:	82e5      	strh	r5, [r4, #22]
 8003e26:	8d70      	ldrh	r0, [r6, #42]	; 0x2a
 8003e28:	0440      	lsls	r0, r0, #17
 8003e2a:	0c40      	lsrs	r0, r0, #17
 8003e2c:	2801      	cmp	r0, #1
 8003e2e:	db01      	blt.n	8003e34 <PE_Check_DataMessage+0x78>
 8003e30:	2000      	movs	r0, #0
 8003e32:	8570      	strh	r0, [r6, #42]	; 0x2a
 8003e34:	2009      	movs	r0, #9
 8003e36:	e06d      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003e38:	6860      	ldr	r0, [r4, #4]
 8003e3a:	7800      	ldrb	r0, [r0, #0]
 8003e3c:	0880      	lsrs	r0, r0, #2
 8003e3e:	4228      	tst	r0, r5
 8003e40:	d169      	bne.n	8003f16 <PE_Check_DataMessage+0x15a>
 8003e42:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 8003e44:	0600      	lsls	r0, r0, #24
 8003e46:	0f81      	lsrs	r1, r0, #30
 8003e48:	68e2      	ldr	r2, [r4, #12]
 8003e4a:	2001      	movs	r0, #1
 8003e4c:	4010      	ands	r0, r2
 8003e4e:	f000 fabf 	bl	80043d0 <PE_ExtRevisionInteroperability>
 8003e52:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 8003e54:	0440      	lsls	r0, r0, #17
 8003e56:	0f40      	lsrs	r0, r0, #29
 8003e58:	0083      	lsls	r3, r0, #2
 8003e5a:	003a      	movs	r2, r7
 8003e5c:	2104      	movs	r1, #4
 8003e5e:	68e7      	ldr	r7, [r4, #12]
 8003e60:	2001      	movs	r0, #1
 8003e62:	4038      	ands	r0, r7
 8003e64:	68a7      	ldr	r7, [r4, #8]
 8003e66:	69ff      	ldr	r7, [r7, #28]
 8003e68:	47b8      	blx	r7
 8003e6a:	82e5      	strh	r5, [r4, #22]
 8003e6c:	2044      	movs	r0, #68	; 0x44
 8003e6e:	e051      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003e70:	2000      	movs	r0, #0
 8003e72:	9001      	str	r0, [sp, #4]
 8003e74:	9000      	str	r0, [sp, #0]
 8003e76:	7838      	ldrb	r0, [r7, #0]
 8003e78:	7879      	ldrb	r1, [r7, #1]
 8003e7a:	0209      	lsls	r1, r1, #8
 8003e7c:	1840      	adds	r0, r0, r1
 8003e7e:	78b9      	ldrb	r1, [r7, #2]
 8003e80:	0409      	lsls	r1, r1, #16
 8003e82:	1840      	adds	r0, r0, r1
 8003e84:	78f9      	ldrb	r1, [r7, #3]
 8003e86:	0609      	lsls	r1, r1, #24
 8003e88:	1847      	adds	r7, r0, r1
 8003e8a:	466b      	mov	r3, sp
 8003e8c:	aa01      	add	r2, sp, #4
 8003e8e:	2103      	movs	r1, #3
 8003e90:	68e0      	ldr	r0, [r4, #12]
 8003e92:	4005      	ands	r5, r0
 8003e94:	0028      	movs	r0, r5
 8003e96:	68a5      	ldr	r5, [r4, #8]
 8003e98:	69ad      	ldr	r5, [r5, #24]
 8003e9a:	47a8      	blx	r5
 8003e9c:	9800      	ldr	r0, [sp, #0]
 8003e9e:	2804      	cmp	r0, #4
 8003ea0:	d115      	bne.n	8003ece <PE_Check_DataMessage+0x112>
 8003ea2:	6860      	ldr	r0, [r4, #4]
 8003ea4:	7840      	ldrb	r0, [r0, #1]
 8003ea6:	0640      	lsls	r0, r0, #25
 8003ea8:	0f40      	lsrs	r0, r0, #29
 8003eaa:	2803      	cmp	r0, #3
 8003eac:	d10f      	bne.n	8003ece <PE_Check_DataMessage+0x112>
 8003eae:	9801      	ldr	r0, [sp, #4]
 8003eb0:	49b4      	ldr	r1, [pc, #720]	; (8004184 <.text_57>)
 8003eb2:	4288      	cmp	r0, r1
 8003eb4:	d10b      	bne.n	8003ece <PE_Check_DataMessage+0x112>
 8003eb6:	0f38      	lsrs	r0, r7, #28
 8003eb8:	d003      	beq.n	8003ec2 <PE_Check_DataMessage+0x106>
 8003eba:	2805      	cmp	r0, #5
 8003ebc:	d003      	beq.n	8003ec6 <PE_Check_DataMessage+0x10a>
 8003ebe:	2808      	cmp	r0, #8
 8003ec0:	d103      	bne.n	8003eca <PE_Check_DataMessage+0x10e>
 8003ec2:	2029      	movs	r0, #41	; 0x29
 8003ec4:	e026      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003ec6:	2027      	movs	r0, #39	; 0x27
 8003ec8:	e024      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003eca:	202a      	movs	r0, #42	; 0x2a
 8003ecc:	e022      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003ece:	2003      	movs	r0, #3
 8003ed0:	e020      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003ed2:	6860      	ldr	r0, [r4, #4]
 8003ed4:	7800      	ldrb	r0, [r0, #0]
 8003ed6:	0780      	lsls	r0, r0, #30
 8003ed8:	0f80      	lsrs	r0, r0, #30
 8003eda:	2802      	cmp	r0, #2
 8003edc:	d11b      	bne.n	8003f16 <PE_Check_DataMessage+0x15a>
 8003ede:	e016      	b.n	8003f0e <PE_Check_DataMessage+0x152>
 8003ee0:	6820      	ldr	r0, [r4, #0]
 8003ee2:	88c0      	ldrh	r0, [r0, #6]
 8003ee4:	0900      	lsrs	r0, r0, #4
 8003ee6:	4228      	tst	r0, r5
 8003ee8:	d011      	beq.n	8003f0e <PE_Check_DataMessage+0x152>
 8003eea:	2304      	movs	r3, #4
 8003eec:	003a      	movs	r2, r7
 8003eee:	210b      	movs	r1, #11
 8003ef0:	68e0      	ldr	r0, [r4, #12]
 8003ef2:	4005      	ands	r5, r0
 8003ef4:	0028      	movs	r0, r5
 8003ef6:	68a4      	ldr	r4, [r4, #8]
 8003ef8:	69e4      	ldr	r4, [r4, #28]
 8003efa:	47a0      	blx	r4
 8003efc:	202c      	movs	r0, #44	; 0x2c
 8003efe:	e009      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003f00:	6820      	ldr	r0, [r4, #0]
 8003f02:	88c0      	ldrh	r0, [r0, #6]
 8003f04:	0a40      	lsrs	r0, r0, #9
 8003f06:	4228      	tst	r0, r5
 8003f08:	d001      	beq.n	8003f0e <PE_Check_DataMessage+0x152>
 8003f0a:	203d      	movs	r0, #61	; 0x3d
 8003f0c:	e002      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003f0e:	7035      	strb	r5, [r6, #0]
 8003f10:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003f12:	2011      	movs	r0, #17
 8003f14:	7030      	strb	r0, [r6, #0]
 8003f16:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

08003f18 <PE_Check_ExtendedMessage>:
 8003f18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003f1a:	0005      	movs	r5, r0
 8003f1c:	209e      	movs	r0, #158	; 0x9e
 8003f1e:	0040      	lsls	r0, r0, #1
 8003f20:	1828      	adds	r0, r5, r0
 8003f22:	7801      	ldrb	r1, [r0, #0]
 8003f24:	7840      	ldrb	r0, [r0, #1]
 8003f26:	0200      	lsls	r0, r0, #8
 8003f28:	1808      	adds	r0, r1, r0
 8003f2a:	21e4      	movs	r1, #228	; 0xe4
 8003f2c:	0089      	lsls	r1, r1, #2
 8003f2e:	1869      	adds	r1, r5, r1
 8003f30:	8008      	strh	r0, [r1, #0]
 8003f32:	4a95      	ldr	r2, [pc, #596]	; (8004188 <.text_58>)
 8003f34:	18ac      	adds	r4, r5, r2
 8003f36:	8f62      	ldrh	r2, [r4, #58]	; 0x3a
 8003f38:	06d2      	lsls	r2, r2, #27
 8003f3a:	0ed2      	lsrs	r2, r2, #27
 8003f3c:	2380      	movs	r3, #128	; 0x80
 8003f3e:	4313      	orrs	r3, r2
 8003f40:	708b      	strb	r3, [r1, #2]
 8003f42:	2601      	movs	r6, #1
 8003f44:	0402      	lsls	r2, r0, #16
 8003f46:	0e92      	lsrs	r2, r2, #26
 8003f48:	2101      	movs	r1, #1
 8003f4a:	4011      	ands	r1, r2
 8003f4c:	0402      	lsls	r2, r0, #16
 8003f4e:	0ed2      	lsrs	r2, r2, #27
 8003f50:	0712      	lsls	r2, r2, #28
 8003f52:	d003      	beq.n	8003f5c <PE_Check_ExtendedMessage+0x44>
 8003f54:	000a      	movs	r2, r1
 8003f56:	d001      	beq.n	8003f5c <PE_Check_ExtendedMessage+0x44>
 8003f58:	2034      	movs	r0, #52	; 0x34
 8003f5a:	e0a7      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8003f5c:	05c2      	lsls	r2, r0, #23
 8003f5e:	0dd2      	lsrs	r2, r2, #23
 8003f60:	0403      	lsls	r3, r0, #16
 8003f62:	0fdb      	lsrs	r3, r3, #31
 8003f64:	d10c      	bne.n	8003f80 <PE_Check_ExtendedMessage+0x68>
 8003f66:	8022      	strh	r2, [r4, #0]
 8003f68:	2000      	movs	r0, #0
 8003f6a:	2336      	movs	r3, #54	; 0x36
 8003f6c:	8821      	ldrh	r1, [r4, #0]
 8003f6e:	4288      	cmp	r0, r1
 8003f70:	d218      	bcs.n	8003fa4 <PE_Check_ExtendedMessage+0x8c>
 8003f72:	1829      	adds	r1, r5, r0
 8003f74:	229f      	movs	r2, #159	; 0x9f
 8003f76:	0052      	lsls	r2, r2, #1
 8003f78:	5c8a      	ldrb	r2, [r1, r2]
 8003f7a:	54ca      	strb	r2, [r1, r3]
 8003f7c:	1c40      	adds	r0, r0, #1
 8003f7e:	e7f5      	b.n	8003f6c <PE_Check_ExtendedMessage+0x54>
 8003f80:	23f8      	movs	r3, #248	; 0xf8
 8003f82:	01db      	lsls	r3, r3, #7
 8003f84:	4003      	ands	r3, r0
 8003f86:	d108      	bne.n	8003f9a <PE_Check_ExtendedMessage+0x82>
 8003f88:	8f60      	ldrh	r0, [r4, #58]	; 0x3a
 8003f8a:	0440      	lsls	r0, r0, #17
 8003f8c:	0f40      	lsrs	r0, r0, #29
 8003f8e:	2806      	cmp	r0, #6
 8003f90:	dc00      	bgt.n	8003f94 <PE_Check_ExtendedMessage+0x7c>
 8003f92:	e08f      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003f94:	2a1b      	cmp	r2, #27
 8003f96:	d200      	bcs.n	8003f9a <PE_Check_ExtendedMessage+0x82>
 8003f98:	e08c      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003f9a:	2900      	cmp	r1, #0
 8003f9c:	d000      	beq.n	8003fa0 <PE_Check_ExtendedMessage+0x88>
 8003f9e:	e089      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003fa0:	8820      	ldrh	r0, [r4, #0]
 8003fa2:	4290      	cmp	r0, r2
 8003fa4:	d300      	bcc.n	8003fa8 <PE_Check_ExtendedMessage+0x90>
 8003fa6:	e085      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003fa8:	2037      	movs	r0, #55	; 0x37
 8003faa:	e07f      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8003fac:	2305      	movs	r3, #5
 8003fae:	2109      	movs	r1, #9
 8003fb0:	68ef      	ldr	r7, [r5, #12]
 8003fb2:	2001      	movs	r0, #1
 8003fb4:	4038      	ands	r0, r7
 8003fb6:	68af      	ldr	r7, [r5, #8]
 8003fb8:	69ff      	ldr	r7, [r7, #28]
 8003fba:	47b8      	blx	r7
 8003fbc:	2003      	movs	r0, #3
 8003fbe:	73a0      	strb	r0, [r4, #14]
 8003fc0:	4cca      	ldr	r4, [pc, #808]	; (80042ec <.text_61>)
 8003fc2:	7820      	ldrb	r0, [r4, #0]
 8003fc4:	0780      	lsls	r0, r0, #30
 8003fc6:	d509      	bpl.n	8003fdc <PE_Check_ExtendedMessage+0xc4>
 8003fc8:	2000      	movs	r0, #0
 8003fca:	9000      	str	r0, [sp, #0]
 8003fcc:	2300      	movs	r3, #0
 8003fce:	224b      	movs	r2, #75	; 0x4b
 8003fd0:	68e8      	ldr	r0, [r5, #12]
 8003fd2:	2101      	movs	r1, #1
 8003fd4:	4001      	ands	r1, r0
 8003fd6:	2009      	movs	r0, #9
 8003fd8:	68e4      	ldr	r4, [r4, #12]
 8003fda:	47a0      	blx	r4
 8003fdc:	214b      	movs	r1, #75	; 0x4b
 8003fde:	e0a4      	b.n	800412a <PE_Check_ExtendedMessage+0x212>
 8003fe0:	6828      	ldr	r0, [r5, #0]
 8003fe2:	88c0      	ldrh	r0, [r0, #6]
 8003fe4:	0980      	lsrs	r0, r0, #6
 8003fe6:	4230      	tst	r0, r6
 8003fe8:	d062      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8003fea:	2301      	movs	r3, #1
 8003fec:	2110      	movs	r1, #16
 8003fee:	68e8      	ldr	r0, [r5, #12]
 8003ff0:	4006      	ands	r6, r0
 8003ff2:	0030      	movs	r0, r6
 8003ff4:	68ad      	ldr	r5, [r5, #8]
 8003ff6:	69ed      	ldr	r5, [r5, #28]
 8003ff8:	47a8      	blx	r5
 8003ffa:	203a      	movs	r0, #58	; 0x3a
 8003ffc:	e056      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8003ffe:	6828      	ldr	r0, [r5, #0]
 8004000:	88c0      	ldrh	r0, [r0, #6]
 8004002:	0980      	lsrs	r0, r0, #6
 8004004:	4230      	tst	r0, r6
 8004006:	d053      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004008:	2301      	movs	r3, #1
 800400a:	210e      	movs	r1, #14
 800400c:	68e8      	ldr	r0, [r5, #12]
 800400e:	4006      	ands	r6, r0
 8004010:	0030      	movs	r0, r6
 8004012:	68ad      	ldr	r5, [r5, #8]
 8004014:	69ed      	ldr	r5, [r5, #28]
 8004016:	47a8      	blx	r5
 8004018:	203b      	movs	r0, #59	; 0x3b
 800401a:	e047      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 800401c:	6828      	ldr	r0, [r5, #0]
 800401e:	88c0      	ldrh	r0, [r0, #6]
 8004020:	09c0      	lsrs	r0, r0, #7
 8004022:	4230      	tst	r0, r6
 8004024:	d044      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004026:	2302      	movs	r3, #2
 8004028:	210c      	movs	r1, #12
 800402a:	68e8      	ldr	r0, [r5, #12]
 800402c:	4006      	ands	r6, r0
 800402e:	0030      	movs	r0, r6
 8004030:	68ad      	ldr	r5, [r5, #8]
 8004032:	69ed      	ldr	r5, [r5, #28]
 8004034:	47a8      	blx	r5
 8004036:	203c      	movs	r0, #60	; 0x3c
 8004038:	e038      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 800403a:	68a9      	ldr	r1, [r5, #8]
 800403c:	694f      	ldr	r7, [r1, #20]
 800403e:	2f00      	cmp	r7, #0
 8004040:	d036      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004042:	8823      	ldrh	r3, [r4, #0]
 8004044:	002a      	movs	r2, r5
 8004046:	3236      	adds	r2, #54	; 0x36
 8004048:	7881      	ldrb	r1, [r0, #2]
 800404a:	68e8      	ldr	r0, [r5, #12]
 800404c:	4006      	ands	r6, r0
 800404e:	0030      	movs	r0, r6
 8004050:	47b8      	blx	r7
 8004052:	2038      	movs	r0, #56	; 0x38
 8004054:	e02a      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8004056:	6829      	ldr	r1, [r5, #0]
 8004058:	88c9      	ldrh	r1, [r1, #6]
 800405a:	0ac9      	lsrs	r1, r1, #11
 800405c:	4231      	tst	r1, r6
 800405e:	d027      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004060:	68a9      	ldr	r1, [r5, #8]
 8004062:	6949      	ldr	r1, [r1, #20]
 8004064:	2900      	cmp	r1, #0
 8004066:	d116      	bne.n	8004096 <PE_Check_ExtendedMessage+0x17e>
 8004068:	e022      	b.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 800406a:	68a9      	ldr	r1, [r5, #8]
 800406c:	694f      	ldr	r7, [r1, #20]
 800406e:	2f00      	cmp	r7, #0
 8004070:	d01f      	beq.n	80040b2 <PE_Check_ExtendedMessage+0x19a>
 8004072:	8823      	ldrh	r3, [r4, #0]
 8004074:	002a      	movs	r2, r5
 8004076:	3236      	adds	r2, #54	; 0x36
 8004078:	7881      	ldrb	r1, [r0, #2]
 800407a:	68e8      	ldr	r0, [r5, #12]
 800407c:	4006      	ands	r6, r0
 800407e:	0030      	movs	r0, r6
 8004080:	47b8      	blx	r7
 8004082:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
 8004084:	6829      	ldr	r1, [r5, #0]
 8004086:	88c9      	ldrh	r1, [r1, #6]
 8004088:	0a89      	lsrs	r1, r1, #10
 800408a:	4231      	tst	r1, r6
 800408c:	d010      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 800408e:	68a9      	ldr	r1, [r5, #8]
 8004090:	6949      	ldr	r1, [r1, #20]
 8004092:	2900      	cmp	r1, #0
 8004094:	d00c      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004096:	8823      	ldrh	r3, [r4, #0]
 8004098:	002a      	movs	r2, r5
 800409a:	3236      	adds	r2, #54	; 0x36
 800409c:	7881      	ldrb	r1, [r0, #2]
 800409e:	68e8      	ldr	r0, [r5, #12]
 80040a0:	4006      	ands	r6, r0
 80040a2:	0030      	movs	r0, r6
 80040a4:	68ad      	ldr	r5, [r5, #8]
 80040a6:	696d      	ldr	r5, [r5, #20]
 80040a8:	47a8      	blx	r5
 80040aa:	20a5      	movs	r0, #165	; 0xa5
 80040ac:	73a0      	strb	r0, [r4, #14]
 80040ae:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
 80040b0:	73a6      	strb	r6, [r4, #14]
 80040b2:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
 80040b4:	20e4      	movs	r0, #228	; 0xe4
 80040b6:	0080      	lsls	r0, r0, #2
 80040b8:	1828      	adds	r0, r5, r0
 80040ba:	219f      	movs	r1, #159	; 0x9f
 80040bc:	0049      	lsls	r1, r1, #1
 80040be:	186a      	adds	r2, r5, r1
 80040c0:	7881      	ldrb	r1, [r0, #2]
 80040c2:	3981      	subs	r1, #129	; 0x81
 80040c4:	d018      	beq.n	80040f8 <PE_Check_ExtendedMessage+0x1e0>
 80040c6:	1e49      	subs	r1, r1, #1
 80040c8:	d100      	bne.n	80040cc <PE_Check_ExtendedMessage+0x1b4>
 80040ca:	e76f      	b.n	8003fac <PE_Check_ExtendedMessage+0x94>
 80040cc:	1e49      	subs	r1, r1, #1
 80040ce:	d087      	beq.n	8003fe0 <PE_Check_ExtendedMessage+0xc8>
 80040d0:	1e49      	subs	r1, r1, #1
 80040d2:	d094      	beq.n	8003ffe <PE_Check_ExtendedMessage+0xe6>
 80040d4:	1e49      	subs	r1, r1, #1
 80040d6:	d0b0      	beq.n	800403a <PE_Check_ExtendedMessage+0x122>
 80040d8:	1e49      	subs	r1, r1, #1
 80040da:	d09f      	beq.n	800401c <PE_Check_ExtendedMessage+0x104>
 80040dc:	1e49      	subs	r1, r1, #1
 80040de:	d0ac      	beq.n	800403a <PE_Check_ExtendedMessage+0x122>
 80040e0:	1e49      	subs	r1, r1, #1
 80040e2:	d0cf      	beq.n	8004084 <PE_Check_ExtendedMessage+0x16c>
 80040e4:	1e49      	subs	r1, r1, #1
 80040e6:	d0e4      	beq.n	80040b2 <PE_Check_ExtendedMessage+0x19a>
 80040e8:	1e49      	subs	r1, r1, #1
 80040ea:	d0b4      	beq.n	8004056 <PE_Check_ExtendedMessage+0x13e>
 80040ec:	1e49      	subs	r1, r1, #1
 80040ee:	d0bc      	beq.n	800406a <PE_Check_ExtendedMessage+0x152>
 80040f0:	1e89      	subs	r1, r1, #2
 80040f2:	2901      	cmp	r1, #1
 80040f4:	d9a1      	bls.n	800403a <PE_Check_ExtendedMessage+0x122>
 80040f6:	e7db      	b.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 80040f8:	2318      	movs	r3, #24
 80040fa:	2108      	movs	r1, #8
 80040fc:	68ef      	ldr	r7, [r5, #12]
 80040fe:	2001      	movs	r0, #1
 8004100:	4038      	ands	r0, r7
 8004102:	68af      	ldr	r7, [r5, #8]
 8004104:	69ff      	ldr	r7, [r7, #28]
 8004106:	47b8      	blx	r7
 8004108:	2003      	movs	r0, #3
 800410a:	73a0      	strb	r0, [r4, #14]
 800410c:	4c77      	ldr	r4, [pc, #476]	; (80042ec <.text_61>)
 800410e:	7820      	ldrb	r0, [r4, #0]
 8004110:	0780      	lsls	r0, r0, #30
 8004112:	d509      	bpl.n	8004128 <PE_Check_ExtendedMessage+0x210>
 8004114:	2000      	movs	r0, #0
 8004116:	9000      	str	r0, [sp, #0]
 8004118:	2300      	movs	r3, #0
 800411a:	2244      	movs	r2, #68	; 0x44
 800411c:	68e8      	ldr	r0, [r5, #12]
 800411e:	2101      	movs	r1, #1
 8004120:	4001      	ands	r1, r0
 8004122:	2009      	movs	r0, #9
 8004124:	68e4      	ldr	r4, [r4, #12]
 8004126:	47a0      	blx	r4
 8004128:	2144      	movs	r1, #68	; 0x44
 800412a:	68e8      	ldr	r0, [r5, #12]
 800412c:	4006      	ands	r6, r0
 800412e:	0030      	movs	r0, r6
 8004130:	68aa      	ldr	r2, [r5, #8]
 8004132:	68d2      	ldr	r2, [r2, #12]
 8004134:	4790      	blx	r2
 8004136:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}

08004138 <PE_PRL_HardResetReceived>:
 8004138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800413a:	0007      	movs	r7, r0
 800413c:	48cf      	ldr	r0, [pc, #828]	; (800447c <.text_65>)
 800413e:	00b9      	lsls	r1, r7, #2
 8004140:	5844      	ldr	r4, [r0, r1]
 8004142:	48d7      	ldr	r0, [pc, #860]	; (80044a0 <.text_67>)
 8004144:	1825      	adds	r5, r4, r0
 8004146:	2600      	movs	r6, #0
 8004148:	702e      	strb	r6, [r5, #0]
 800414a:	0038      	movs	r0, r7
 800414c:	f001 f982 	bl	8005454 <USBPD_PRL_Reset>
 8004150:	6860      	ldr	r0, [r4, #4]
 8004152:	2101      	movs	r1, #1
 8004154:	7802      	ldrb	r2, [r0, #0]
 8004156:	0892      	lsrs	r2, r2, #2
 8004158:	420a      	tst	r2, r1
 800415a:	d001      	beq.n	8004160 <PE_PRL_HardResetReceived+0x28>
 800415c:	2014      	movs	r0, #20
 800415e:	e005      	b.n	800416c <PE_PRL_HardResetReceived+0x34>
 8004160:	6802      	ldr	r2, [r0, #0]
 8004162:	2310      	movs	r3, #16
 8004164:	4313      	orrs	r3, r2
 8004166:	6003      	str	r3, [r0, #0]
 8004168:	842e      	strh	r6, [r5, #32]
 800416a:	203f      	movs	r0, #63	; 0x3f
 800416c:	70a8      	strb	r0, [r5, #2]
 800416e:	7b60      	ldrb	r0, [r4, #13]
 8004170:	22fc      	movs	r2, #252	; 0xfc
 8004172:	4002      	ands	r2, r0
 8004174:	4311      	orrs	r1, r2
 8004176:	7361      	strb	r1, [r4, #13]
 8004178:	0038      	movs	r0, r7
 800417a:	68a1      	ldr	r1, [r4, #8]
 800417c:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800417e:	4788      	blx	r1
 8004180:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
	...

08004184 <.text_57>:
 8004184:	00001388 	.word	0x00001388

08004188 <.text_58>:
 8004188:	0000034a 	.word	0x0000034a

0800418c <PE_PRL_BistCompleted>:
 800418c:	4770      	bx	lr

0800418e <PE_Reset>:
 800418e:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 8004190:	b084      	sub	sp, #16
 8004192:	000e      	movs	r6, r1
 8004194:	48c8      	ldr	r0, [pc, #800]	; (80044b8 <.text_69>)
 8004196:	1d01      	adds	r1, r0, #4
 8004198:	466a      	mov	r2, sp
 800419a:	7c12      	ldrb	r2, [r2, #16]
 800419c:	0092      	lsls	r2, r2, #2
 800419e:	588c      	ldr	r4, [r1, r2]
 80041a0:	2500      	movs	r5, #0
 80041a2:	9502      	str	r5, [sp, #8]
 80041a4:	68e1      	ldr	r1, [r4, #12]
 80041a6:	2203      	movs	r2, #3
 80041a8:	4391      	bics	r1, r2
 80041aa:	466a      	mov	r2, sp
 80041ac:	7c12      	ldrb	r2, [r2, #16]
 80041ae:	07d3      	lsls	r3, r2, #31
 80041b0:	0fdb      	lsrs	r3, r3, #31
 80041b2:	430b      	orrs	r3, r1
 80041b4:	60e3      	str	r3, [r4, #12]
 80041b6:	6861      	ldr	r1, [r4, #4]
 80041b8:	680a      	ldr	r2, [r1, #0]
 80041ba:	2310      	movs	r3, #16
 80041bc:	439a      	bics	r2, r3
 80041be:	600a      	str	r2, [r1, #0]
 80041c0:	6861      	ldr	r1, [r4, #4]
 80041c2:	784a      	ldrb	r2, [r1, #1]
 80041c4:	238f      	movs	r3, #143	; 0x8f
 80041c6:	4013      	ands	r3, r2
 80041c8:	704b      	strb	r3, [r1, #1]
 80041ca:	7800      	ldrb	r0, [r0, #0]
 80041cc:	0780      	lsls	r0, r0, #30
 80041ce:	d509      	bpl.n	80041e4 <PE_Reset+0x56>
 80041d0:	9500      	str	r5, [sp, #0]
 80041d2:	2300      	movs	r3, #0
 80041d4:	2256      	movs	r2, #86	; 0x56
 80041d6:	7b20      	ldrb	r0, [r4, #12]
 80041d8:	07c1      	lsls	r1, r0, #31
 80041da:	0fc9      	lsrs	r1, r1, #31
 80041dc:	2009      	movs	r0, #9
 80041de:	4fb6      	ldr	r7, [pc, #728]	; (80044b8 <.text_69>)
 80041e0:	68ff      	ldr	r7, [r7, #12]
 80041e2:	47b8      	blx	r7
 80041e4:	4668      	mov	r0, sp
 80041e6:	7006      	strb	r6, [r0, #0]
 80041e8:	2156      	movs	r1, #86	; 0x56
 80041ea:	7b22      	ldrb	r2, [r4, #12]
 80041ec:	07d0      	lsls	r0, r2, #31
 80041ee:	0fc0      	lsrs	r0, r0, #31
 80041f0:	68a2      	ldr	r2, [r4, #8]
 80041f2:	68d2      	ldr	r2, [r2, #12]
 80041f4:	4790      	blx	r2
 80041f6:	48b1      	ldr	r0, [pc, #708]	; (80044bc <.text_70>)
 80041f8:	1826      	adds	r6, r4, r0
 80041fa:	82b5      	strh	r5, [r6, #20]
 80041fc:	82e5      	strh	r5, [r4, #22]
 80041fe:	72b5      	strb	r5, [r6, #10]
 8004200:	4668      	mov	r0, sp
 8004202:	7800      	ldrb	r0, [r0, #0]
 8004204:	2800      	cmp	r0, #0
 8004206:	d100      	bne.n	800420a <PE_Reset+0x7c>
 8004208:	7525      	strb	r5, [r4, #20]
 800420a:	7335      	strb	r5, [r6, #12]
 800420c:	7475      	strb	r5, [r6, #17]
 800420e:	72f5      	strb	r5, [r6, #11]
 8004210:	6860      	ldr	r0, [r4, #4]
 8004212:	7800      	ldrb	r0, [r0, #0]
 8004214:	0880      	lsrs	r0, r0, #2
 8004216:	07c0      	lsls	r0, r0, #31
 8004218:	d51d      	bpl.n	8004256 <PE_Reset+0xc8>
 800421a:	6820      	ldr	r0, [r4, #0]
 800421c:	7900      	ldrb	r0, [r0, #4]
 800421e:	0783      	lsls	r3, r0, #30
 8004220:	0f9b      	lsrs	r3, r3, #30
 8004222:	2201      	movs	r2, #1
 8004224:	2101      	movs	r1, #1
 8004226:	4668      	mov	r0, sp
 8004228:	7c00      	ldrb	r0, [r0, #16]
 800422a:	f000 fe5d 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800422e:	6860      	ldr	r0, [r4, #4]
 8004230:	7801      	ldrb	r1, [r0, #0]
 8004232:	2208      	movs	r2, #8
 8004234:	430a      	orrs	r2, r1
 8004236:	7002      	strb	r2, [r0, #0]
 8004238:	2002      	movs	r0, #2
 800423a:	73b0      	strb	r0, [r6, #14]
 800423c:	2304      	movs	r3, #4
 800423e:	aa02      	add	r2, sp, #8
 8004240:	2102      	movs	r1, #2
 8004242:	4668      	mov	r0, sp
 8004244:	7c00      	ldrb	r0, [r0, #16]
 8004246:	68a7      	ldr	r7, [r4, #8]
 8004248:	69ff      	ldr	r7, [r7, #28]
 800424a:	47b8      	blx	r7
 800424c:	6860      	ldr	r0, [r4, #4]
 800424e:	7800      	ldrb	r0, [r0, #0]
 8004250:	0880      	lsrs	r0, r0, #2
 8004252:	07c0      	lsls	r0, r0, #31
 8004254:	d428      	bmi.n	80042a8 <PE_Reset+0x11a>
 8004256:	6820      	ldr	r0, [r4, #0]
 8004258:	7900      	ldrb	r0, [r0, #4]
 800425a:	0783      	lsls	r3, r0, #30
 800425c:	0f9b      	lsrs	r3, r3, #30
 800425e:	2200      	movs	r2, #0
 8004260:	2100      	movs	r1, #0
 8004262:	4668      	mov	r0, sp
 8004264:	7c00      	ldrb	r0, [r0, #16]
 8004266:	f000 fe3f 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800426a:	6860      	ldr	r0, [r4, #4]
 800426c:	7801      	ldrb	r1, [r0, #0]
 800426e:	22f7      	movs	r2, #247	; 0xf7
 8004270:	400a      	ands	r2, r1
 8004272:	7002      	strb	r2, [r0, #0]
 8004274:	4668      	mov	r0, sp
 8004276:	7800      	ldrb	r0, [r0, #0]
 8004278:	2800      	cmp	r0, #0
 800427a:	d101      	bne.n	8004280 <PE_Reset+0xf2>
 800427c:	203e      	movs	r0, #62	; 0x3e
 800427e:	73b0      	strb	r0, [r6, #14]
 8004280:	7375      	strb	r5, [r6, #13]
 8004282:	2080      	movs	r0, #128	; 0x80
 8004284:	0440      	lsls	r0, r0, #17
 8004286:	9001      	str	r0, [sp, #4]
 8004288:	2304      	movs	r3, #4
 800428a:	aa01      	add	r2, sp, #4
 800428c:	2107      	movs	r1, #7
 800428e:	4668      	mov	r0, sp
 8004290:	7c00      	ldrb	r0, [r0, #16]
 8004292:	68a7      	ldr	r7, [r4, #8]
 8004294:	69ff      	ldr	r7, [r7, #28]
 8004296:	47b8      	blx	r7
 8004298:	2304      	movs	r3, #4
 800429a:	aa02      	add	r2, sp, #8
 800429c:	2102      	movs	r1, #2
 800429e:	4668      	mov	r0, sp
 80042a0:	7c00      	ldrb	r0, [r0, #16]
 80042a2:	68a7      	ldr	r7, [r4, #8]
 80042a4:	69ff      	ldr	r7, [r7, #28]
 80042a6:	47b8      	blx	r7
 80042a8:	8035      	strh	r5, [r6, #0]
 80042aa:	8075      	strh	r5, [r6, #2]
 80042ac:	2124      	movs	r1, #36	; 0x24
 80042ae:	20d8      	movs	r0, #216	; 0xd8
 80042b0:	0080      	lsls	r0, r0, #2
 80042b2:	1820      	adds	r0, r4, r0
 80042b4:	f008 f8e0 	bl	800c478 <__aeabi_memclr>
 80042b8:	487f      	ldr	r0, [pc, #508]	; (80044b8 <.text_69>)
 80042ba:	68c5      	ldr	r5, [r0, #12]
 80042bc:	2d00      	cmp	r5, #0
 80042be:	d00f      	beq.n	80042e0 <PE_Reset+0x152>
 80042c0:	7800      	ldrb	r0, [r0, #0]
 80042c2:	07c0      	lsls	r0, r0, #31
 80042c4:	d50c      	bpl.n	80042e0 <PE_Reset+0x152>
 80042c6:	7bb2      	ldrb	r2, [r6, #14]
 80042c8:	7bf0      	ldrb	r0, [r6, #15]
 80042ca:	4290      	cmp	r0, r2
 80042cc:	d008      	beq.n	80042e0 <PE_Reset+0x152>
 80042ce:	73f2      	strb	r2, [r6, #15]
 80042d0:	2000      	movs	r0, #0
 80042d2:	9000      	str	r0, [sp, #0]
 80042d4:	2300      	movs	r3, #0
 80042d6:	7b20      	ldrb	r0, [r4, #12]
 80042d8:	07c1      	lsls	r1, r0, #31
 80042da:	0fc9      	lsrs	r1, r1, #31
 80042dc:	2004      	movs	r0, #4
 80042de:	47a8      	blx	r5
 80042e0:	4668      	mov	r0, sp
 80042e2:	7c00      	ldrb	r0, [r0, #16]
 80042e4:	f001 f8b6 	bl	8005454 <USBPD_PRL_Reset>
 80042e8:	b005      	add	sp, #20
 80042ea:	bdf0      	pop	{r4, r5, r6, r7, pc}

080042ec <.text_61>:
 80042ec:	200019e8 	.word	0x200019e8

080042f0 <PE_ResetDuringSwap>:
 80042f0:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 80042f2:	0004      	movs	r4, r0
 80042f4:	2700      	movs	r7, #0
 80042f6:	9701      	str	r7, [sp, #4]
 80042f8:	6860      	ldr	r0, [r4, #4]
 80042fa:	7841      	ldrb	r1, [r0, #1]
 80042fc:	228f      	movs	r2, #143	; 0x8f
 80042fe:	400a      	ands	r2, r1
 8004300:	2110      	movs	r1, #16
 8004302:	4311      	orrs	r1, r2
 8004304:	7041      	strb	r1, [r0, #1]
 8004306:	4d6c      	ldr	r5, [pc, #432]	; (80044b8 <.text_69>)
 8004308:	2601      	movs	r6, #1
 800430a:	7828      	ldrb	r0, [r5, #0]
 800430c:	0780      	lsls	r0, r0, #30
 800430e:	d508      	bpl.n	8004322 <PE_ResetDuringSwap+0x32>
 8004310:	9700      	str	r7, [sp, #0]
 8004312:	2300      	movs	r3, #0
 8004314:	2256      	movs	r2, #86	; 0x56
 8004316:	68e0      	ldr	r0, [r4, #12]
 8004318:	2101      	movs	r1, #1
 800431a:	4001      	ands	r1, r0
 800431c:	2009      	movs	r0, #9
 800431e:	68ed      	ldr	r5, [r5, #12]
 8004320:	47a8      	blx	r5
 8004322:	2156      	movs	r1, #86	; 0x56
 8004324:	68e2      	ldr	r2, [r4, #12]
 8004326:	2001      	movs	r0, #1
 8004328:	4010      	ands	r0, r2
 800432a:	68a2      	ldr	r2, [r4, #8]
 800432c:	68d2      	ldr	r2, [r2, #12]
 800432e:	4790      	blx	r2
 8004330:	4863      	ldr	r0, [pc, #396]	; (80044c0 <.text_71>)
 8004332:	1825      	adds	r5, r4, r0
 8004334:	702f      	strb	r7, [r5, #0]
 8004336:	712f      	strb	r7, [r5, #4]
 8004338:	68e1      	ldr	r1, [r4, #12]
 800433a:	2001      	movs	r0, #1
 800433c:	4008      	ands	r0, r1
 800433e:	6861      	ldr	r1, [r4, #4]
 8004340:	7809      	ldrb	r1, [r1, #0]
 8004342:	0889      	lsrs	r1, r1, #2
 8004344:	4231      	tst	r1, r6
 8004346:	d014      	beq.n	8004372 <PE_ResetDuringSwap+0x82>
 8004348:	f7ff fb14 	bl	8003974 <PE_Get_DataRole>
 800434c:	6861      	ldr	r1, [r4, #4]
 800434e:	7809      	ldrb	r1, [r1, #0]
 8004350:	2303      	movs	r3, #3
 8004352:	400b      	ands	r3, r1
 8004354:	0002      	movs	r2, r0
 8004356:	2101      	movs	r1, #1
 8004358:	68e7      	ldr	r7, [r4, #12]
 800435a:	2001      	movs	r0, #1
 800435c:	4038      	ands	r0, r7
 800435e:	f000 fdc3 	bl	8004ee8 <USBPD_PRL_SetHeader>
 8004362:	2002      	movs	r0, #2
 8004364:	7068      	strb	r0, [r5, #1]
 8004366:	6860      	ldr	r0, [r4, #4]
 8004368:	6801      	ldr	r1, [r0, #0]
 800436a:	2210      	movs	r2, #16
 800436c:	4391      	bics	r1, r2
 800436e:	6001      	str	r1, [r0, #0]
 8004370:	e019      	b.n	80043a6 <PE_ResetDuringSwap+0xb6>
 8004372:	f7ff faff 	bl	8003974 <PE_Get_DataRole>
 8004376:	6861      	ldr	r1, [r4, #4]
 8004378:	7809      	ldrb	r1, [r1, #0]
 800437a:	2303      	movs	r3, #3
 800437c:	400b      	ands	r3, r1
 800437e:	0002      	movs	r2, r0
 8004380:	2100      	movs	r1, #0
 8004382:	68e7      	ldr	r7, [r4, #12]
 8004384:	2001      	movs	r0, #1
 8004386:	4038      	ands	r0, r7
 8004388:	f000 fdae 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800438c:	203e      	movs	r0, #62	; 0x3e
 800438e:	7068      	strb	r0, [r5, #1]
 8004390:	0630      	lsls	r0, r6, #24
 8004392:	9000      	str	r0, [sp, #0]
 8004394:	2304      	movs	r3, #4
 8004396:	466a      	mov	r2, sp
 8004398:	2107      	movs	r1, #7
 800439a:	68e5      	ldr	r5, [r4, #12]
 800439c:	2001      	movs	r0, #1
 800439e:	4028      	ands	r0, r5
 80043a0:	68a5      	ldr	r5, [r4, #8]
 80043a2:	69ed      	ldr	r5, [r5, #28]
 80043a4:	47a8      	blx	r5
 80043a6:	2304      	movs	r3, #4
 80043a8:	aa01      	add	r2, sp, #4
 80043aa:	2102      	movs	r1, #2
 80043ac:	68e5      	ldr	r5, [r4, #12]
 80043ae:	2001      	movs	r0, #1
 80043b0:	4028      	ands	r0, r5
 80043b2:	68a5      	ldr	r5, [r4, #8]
 80043b4:	69ed      	ldr	r5, [r5, #28]
 80043b6:	47a8      	blx	r5
 80043b8:	2124      	movs	r1, #36	; 0x24
 80043ba:	20d8      	movs	r0, #216	; 0xd8
 80043bc:	0080      	lsls	r0, r0, #2
 80043be:	1820      	adds	r0, r4, r0
 80043c0:	f008 f85a 	bl	800c478 <__aeabi_memclr>
 80043c4:	68e0      	ldr	r0, [r4, #12]
 80043c6:	4006      	ands	r6, r0
 80043c8:	0030      	movs	r0, r6
 80043ca:	f001 f843 	bl	8005454 <USBPD_PRL_Reset>
 80043ce:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

080043d0 <PE_ExtRevisionInteroperability>:
 80043d0:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 80043d2:	000a      	movs	r2, r1
 80043d4:	4c38      	ldr	r4, [pc, #224]	; (80044b8 <.text_69>)
 80043d6:	0081      	lsls	r1, r0, #2
 80043d8:	1861      	adds	r1, r4, r1
 80043da:	9101      	str	r1, [sp, #4]
 80043dc:	684e      	ldr	r6, [r1, #4]
 80043de:	2103      	movs	r1, #3
 80043e0:	6873      	ldr	r3, [r6, #4]
 80043e2:	781b      	ldrb	r3, [r3, #0]
 80043e4:	400b      	ands	r3, r1
 80043e6:	4293      	cmp	r3, r2
 80043e8:	d03a      	beq.n	8004460 <PE_ExtRevisionInteroperability+0x90>
 80043ea:	6873      	ldr	r3, [r6, #4]
 80043ec:	781b      	ldrb	r3, [r3, #0]
 80043ee:	079b      	lsls	r3, r3, #30
 80043f0:	0f9b      	lsrs	r3, r3, #30
 80043f2:	429a      	cmp	r2, r3
 80043f4:	d300      	bcc.n	80043f8 <PE_ExtRevisionInteroperability+0x28>
 80043f6:	001a      	movs	r2, r3
 80043f8:	6873      	ldr	r3, [r6, #4]
 80043fa:	781d      	ldrb	r5, [r3, #0]
 80043fc:	27fc      	movs	r7, #252	; 0xfc
 80043fe:	402f      	ands	r7, r5
 8004400:	400a      	ands	r2, r1
 8004402:	433a      	orrs	r2, r7
 8004404:	701a      	strb	r2, [r3, #0]
 8004406:	6872      	ldr	r2, [r6, #4]
 8004408:	7812      	ldrb	r2, [r2, #0]
 800440a:	2501      	movs	r5, #1
 800440c:	2303      	movs	r3, #3
 800440e:	4013      	ands	r3, r2
 8004410:	2b01      	cmp	r3, #1
 8004412:	d101      	bne.n	8004418 <PE_ExtRevisionInteroperability+0x48>
 8004414:	2700      	movs	r7, #0
 8004416:	e000      	b.n	800441a <PE_ExtRevisionInteroperability+0x4a>
 8004418:	2701      	movs	r7, #1
 800441a:	239f      	movs	r3, #159	; 0x9f
 800441c:	4013      	ands	r3, r2
 800441e:	017a      	lsls	r2, r7, #5
 8004420:	431a      	orrs	r2, r3
 8004422:	6873      	ldr	r3, [r6, #4]
 8004424:	701a      	strb	r2, [r3, #0]
 8004426:	6872      	ldr	r2, [r6, #4]
 8004428:	7812      	ldrb	r2, [r2, #0]
 800442a:	4011      	ands	r1, r2
 800442c:	f000 fd91 	bl	8004f52 <USBPD_PRL_SetHeaderSpecification>
 8004430:	7820      	ldrb	r0, [r4, #0]
 8004432:	0780      	lsls	r0, r0, #30
 8004434:	d50b      	bpl.n	800444e <PE_ExtRevisionInteroperability+0x7e>
 8004436:	2000      	movs	r0, #0
 8004438:	9000      	str	r0, [sp, #0]
 800443a:	2300      	movs	r3, #0
 800443c:	2236      	movs	r2, #54	; 0x36
 800443e:	9801      	ldr	r0, [sp, #4]
 8004440:	6840      	ldr	r0, [r0, #4]
 8004442:	68c0      	ldr	r0, [r0, #12]
 8004444:	2101      	movs	r1, #1
 8004446:	4001      	ands	r1, r0
 8004448:	2009      	movs	r0, #9
 800444a:	68e4      	ldr	r4, [r4, #12]
 800444c:	47a0      	blx	r4
 800444e:	9801      	ldr	r0, [sp, #4]
 8004450:	6842      	ldr	r2, [r0, #4]
 8004452:	2136      	movs	r1, #54	; 0x36
 8004454:	68d0      	ldr	r0, [r2, #12]
 8004456:	4005      	ands	r5, r0
 8004458:	0028      	movs	r0, r5
 800445a:	6892      	ldr	r2, [r2, #8]
 800445c:	68d2      	ldr	r2, [r2, #12]
 800445e:	4790      	blx	r2
 8004460:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

08004462 <PE_PRL_PostReceiveEvent>:
 8004462:	4b15      	ldr	r3, [pc, #84]	; (80044b8 <.text_69>)
 8004464:	0080      	lsls	r0, r0, #2
 8004466:	1818      	adds	r0, r3, r0
 8004468:	6840      	ldr	r0, [r0, #4]
 800446a:	4b0d      	ldr	r3, [pc, #52]	; (80044a0 <.text_67>)
 800446c:	18c0      	adds	r0, r0, r3
 800446e:	2301      	movs	r3, #1
 8004470:	408b      	lsls	r3, r1
 8004472:	7003      	strb	r3, [r0, #0]
 8004474:	8811      	ldrh	r1, [r2, #0]
 8004476:	85c1      	strh	r1, [r0, #46]	; 0x2e
 8004478:	4770      	bx	lr
	...

0800447c <.text_65>:
 800447c:	200019ec 	.word	0x200019ec

08004480 <PE_PRL_PostReceiveEventComplete>:
 8004480:	b510      	push	{r4, lr}
 8004482:	490d      	ldr	r1, [pc, #52]	; (80044b8 <.text_69>)
 8004484:	0082      	lsls	r2, r0, #2
 8004486:	1889      	adds	r1, r1, r2
 8004488:	6849      	ldr	r1, [r1, #4]
 800448a:	4a05      	ldr	r2, [pc, #20]	; (80044a0 <.text_67>)
 800448c:	188a      	adds	r2, r1, r2
 800448e:	7813      	ldrb	r3, [r2, #0]
 8004490:	2420      	movs	r4, #32
 8004492:	431c      	orrs	r4, r3
 8004494:	7014      	strb	r4, [r2, #0]
 8004496:	6889      	ldr	r1, [r1, #8]
 8004498:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800449a:	4788      	blx	r1
 800449c:	bd10      	pop	{r4, pc}
	...

080044a0 <.text_67>:
 80044a0:	00000356 	.word	0x00000356

080044a4 <PE_Get_UnchunkedSupport>:
 80044a4:	4904      	ldr	r1, [pc, #16]	; (80044b8 <.text_69>)
 80044a6:	0080      	lsls	r0, r0, #2
 80044a8:	1808      	adds	r0, r1, r0
 80044aa:	6840      	ldr	r0, [r0, #4]
 80044ac:	6840      	ldr	r0, [r0, #4]
 80044ae:	6800      	ldr	r0, [r0, #0]
 80044b0:	0301      	lsls	r1, r0, #12
 80044b2:	0fc8      	lsrs	r0, r1, #31
 80044b4:	4770      	bx	lr
	...

080044b8 <.text_69>:
 80044b8:	200019e8 	.word	0x200019e8

080044bc <.text_70>:
 80044bc:	0000034a 	.word	0x0000034a

080044c0 <.text_71>:
 80044c0:	00000357 	.word	0x00000357

080044c4 <PE_Send_ExtendedMessage>:
 80044c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80044c6:	b085      	sub	sp, #20
 80044c8:	6844      	ldr	r4, [r0, #4]
 80044ca:	25d6      	movs	r5, #214	; 0xd6
 80044cc:	00ad      	lsls	r5, r5, #2
 80044ce:	1945      	adds	r5, r0, r5
 80044d0:	9503      	str	r5, [sp, #12]
 80044d2:	2511      	movs	r5, #17
 80044d4:	7866      	ldrb	r6, [r4, #1]
 80044d6:	0676      	lsls	r6, r6, #25
 80044d8:	0f76      	lsrs	r6, r6, #29
 80044da:	2e03      	cmp	r6, #3
 80044dc:	d129      	bne.n	8004532 <PE_Send_ExtendedMessage+0x6e>
 80044de:	7824      	ldrb	r4, [r4, #0]
 80044e0:	07a4      	lsls	r4, r4, #30
 80044e2:	0fa4      	lsrs	r4, r4, #30
 80044e4:	2c01      	cmp	r4, #1
 80044e6:	dd24      	ble.n	8004532 <PE_Send_ExtendedMessage+0x6e>
 80044e8:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 80044ea:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80044ec:	9304      	str	r3, [sp, #16]
 80044ee:	23ff      	movs	r3, #255	; 0xff
 80044f0:	330a      	adds	r3, #10
 80044f2:	429f      	cmp	r7, r3
 80044f4:	d21d      	bcs.n	8004532 <PE_Send_ExtendedMessage+0x6e>
 80044f6:	0006      	movs	r6, r0
 80044f8:	4668      	mov	r0, sp
 80044fa:	7241      	strb	r1, [r0, #9]
 80044fc:	7202      	strb	r2, [r0, #8]
 80044fe:	970a      	str	r7, [sp, #40]	; 0x28
 8004500:	a80c      	add	r0, sp, #48	; 0x30
 8004502:	7004      	strb	r4, [r0, #0]
 8004504:	2401      	movs	r4, #1
 8004506:	a80c      	add	r0, sp, #48	; 0x30
 8004508:	7800      	ldrb	r0, [r0, #0]
 800450a:	9001      	str	r0, [sp, #4]
 800450c:	980a      	ldr	r0, [sp, #40]	; 0x28
 800450e:	b280      	uxth	r0, r0
 8004510:	9000      	str	r0, [sp, #0]
 8004512:	9b04      	ldr	r3, [sp, #16]
 8004514:	4668      	mov	r0, sp
 8004516:	7a02      	ldrb	r2, [r0, #8]
 8004518:	7a41      	ldrb	r1, [r0, #9]
 800451a:	68f7      	ldr	r7, [r6, #12]
 800451c:	2001      	movs	r0, #1
 800451e:	4038      	ands	r0, r7
 8004520:	f000 fd50 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8004524:	2803      	cmp	r0, #3
 8004526:	d117      	bne.n	8004558 <PE_Send_ExtendedMessage+0x94>
 8004528:	6870      	ldr	r0, [r6, #4]
 800452a:	6800      	ldr	r0, [r0, #0]
 800452c:	0ac0      	lsrs	r0, r0, #11
 800452e:	4004      	ands	r4, r0
 8004530:	d1e8      	bne.n	8004504 <PE_Send_ExtendedMessage+0x40>
 8004532:	9803      	ldr	r0, [sp, #12]
 8004534:	7005      	strb	r5, [r0, #0]
 8004536:	2010      	movs	r0, #16
 8004538:	e00c      	b.n	8004554 <PE_Send_ExtendedMessage+0x90>
 800453a:	6870      	ldr	r0, [r6, #4]
 800453c:	7840      	ldrb	r0, [r0, #1]
 800453e:	0640      	lsls	r0, r0, #25
 8004540:	0f40      	lsrs	r0, r0, #29
 8004542:	2804      	cmp	r0, #4
 8004544:	d103      	bne.n	800454e <PE_Send_ExtendedMessage+0x8a>
 8004546:	200f      	movs	r0, #15
 8004548:	9903      	ldr	r1, [sp, #12]
 800454a:	7008      	strb	r0, [r1, #0]
 800454c:	e001      	b.n	8004552 <PE_Send_ExtendedMessage+0x8e>
 800454e:	9803      	ldr	r0, [sp, #12]
 8004550:	7005      	strb	r5, [r0, #0]
 8004552:	2000      	movs	r0, #0
 8004554:	b005      	add	sp, #20
 8004556:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004558:	2805      	cmp	r0, #5
 800455a:	d004      	beq.n	8004566 <PE_Send_ExtendedMessage+0xa2>
 800455c:	2807      	cmp	r0, #7
 800455e:	d0ec      	beq.n	800453a <PE_Send_ExtendedMessage+0x76>
 8004560:	2809      	cmp	r0, #9
 8004562:	d0f7      	beq.n	8004554 <PE_Send_ExtendedMessage+0x90>
 8004564:	e7f5      	b.n	8004552 <PE_Send_ExtendedMessage+0x8e>
 8004566:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8004568:	e7ee      	b.n	8004548 <PE_Send_ExtendedMessage+0x84>

0800456a <PE_SubStateMachine_ExtendedMessages>:
 800456a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800456c:	b084      	sub	sp, #16
 800456e:	0005      	movs	r5, r0
 8004570:	2702      	movs	r7, #2
 8004572:	4886      	ldr	r0, [pc, #536]	; (800478c <.text_74>)
 8004574:	1828      	adds	r0, r5, r0
 8004576:	9002      	str	r0, [sp, #8]
 8004578:	4885      	ldr	r0, [pc, #532]	; (8004790 <.text_75>)
 800457a:	182c      	adds	r4, r5, r0
 800457c:	4985      	ldr	r1, [pc, #532]	; (8004794 <.text_76>)
 800457e:	2600      	movs	r6, #0
 8004580:	2003      	movs	r0, #3
 8004582:	7ba2      	ldrb	r2, [r4, #14]
 8004584:	2a31      	cmp	r2, #49	; 0x31
 8004586:	d016      	beq.n	80045b6 <PE_SubStateMachine_ExtendedMessages+0x4c>
 8004588:	2a32      	cmp	r2, #50	; 0x32
 800458a:	d049      	beq.n	8004620 <PE_SubStateMachine_ExtendedMessages+0xb6>
 800458c:	2a33      	cmp	r2, #51	; 0x33
 800458e:	d074      	beq.n	800467a <PE_SubStateMachine_ExtendedMessages+0x110>
 8004590:	2a34      	cmp	r2, #52	; 0x34
 8004592:	d100      	bne.n	8004596 <PE_SubStateMachine_ExtendedMessages+0x2c>
 8004594:	e083      	b.n	800469e <PE_SubStateMachine_ExtendedMessages+0x134>
 8004596:	2a35      	cmp	r2, #53	; 0x35
 8004598:	d100      	bne.n	800459c <PE_SubStateMachine_ExtendedMessages+0x32>
 800459a:	e0b6      	b.n	800470a <PE_SubStateMachine_ExtendedMessages+0x1a0>
 800459c:	2a36      	cmp	r2, #54	; 0x36
 800459e:	d100      	bne.n	80045a2 <PE_SubStateMachine_ExtendedMessages+0x38>
 80045a0:	e0c3      	b.n	800472a <PE_SubStateMachine_ExtendedMessages+0x1c0>
 80045a2:	2a37      	cmp	r2, #55	; 0x37
 80045a4:	d100      	bne.n	80045a8 <PE_SubStateMachine_ExtendedMessages+0x3e>
 80045a6:	e0c9      	b.n	800473c <PE_SubStateMachine_ExtendedMessages+0x1d2>
 80045a8:	2a38      	cmp	r2, #56	; 0x38
 80045aa:	d100      	bne.n	80045ae <PE_SubStateMachine_ExtendedMessages+0x44>
 80045ac:	e0e8      	b.n	8004780 <PE_SubStateMachine_ExtendedMessages+0x216>
 80045ae:	2aa5      	cmp	r2, #165	; 0xa5
 80045b0:	d100      	bne.n	80045b4 <PE_SubStateMachine_ExtendedMessages+0x4a>
 80045b2:	e0d9      	b.n	8004768 <PE_SubStateMachine_ExtendedMessages+0x1fe>
 80045b4:	e0e7      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 80045b6:	8026      	strh	r6, [r4, #0]
 80045b8:	2701      	movs	r7, #1
 80045ba:	68e9      	ldr	r1, [r5, #12]
 80045bc:	2001      	movs	r0, #1
 80045be:	4008      	ands	r0, r1
 80045c0:	f7ff ff70 	bl	80044a4 <PE_Get_UnchunkedSupport>
 80045c4:	2801      	cmp	r0, #1
 80045c6:	d105      	bne.n	80045d4 <PE_SubStateMachine_ExtendedMessages+0x6a>
 80045c8:	2091      	movs	r0, #145	; 0x91
 80045ca:	0080      	lsls	r0, r0, #2
 80045cc:	1828      	adds	r0, r5, r0
 80045ce:	7046      	strb	r6, [r0, #1]
 80045d0:	7006      	strb	r6, [r0, #0]
 80045d2:	e023      	b.n	800461c <PE_SubStateMachine_ExtendedMessages+0xb2>
 80045d4:	76ee      	strb	r6, [r5, #27]
 80045d6:	76ae      	strb	r6, [r5, #26]
 80045d8:	68e8      	ldr	r0, [r5, #12]
 80045da:	4007      	ands	r7, r0
 80045dc:	0038      	movs	r0, r7
 80045de:	f7ff ff61 	bl	80044a4 <PE_Get_UnchunkedSupport>
 80045e2:	2800      	cmp	r0, #0
 80045e4:	d104      	bne.n	80045f0 <PE_SubStateMachine_ExtendedMessages+0x86>
 80045e6:	8b68      	ldrh	r0, [r5, #26]
 80045e8:	2180      	movs	r1, #128	; 0x80
 80045ea:	0209      	lsls	r1, r1, #8
 80045ec:	4301      	orrs	r1, r0
 80045ee:	8369      	strh	r1, [r5, #26]
 80045f0:	4866      	ldr	r0, [pc, #408]	; (800478c <.text_74>)
 80045f2:	1828      	adds	r0, r5, r0
 80045f4:	8861      	ldrh	r1, [r4, #2]
 80045f6:	291a      	cmp	r1, #26
 80045f8:	4631      	mov	r1, r6
 80045fa:	d90c      	bls.n	8004616 <PE_SubStateMachine_ExtendedMessages+0xac>
 80045fc:	5c42      	ldrb	r2, [r0, r1]
 80045fe:	002b      	movs	r3, r5
 8004600:	331c      	adds	r3, #28
 8004602:	545a      	strb	r2, [r3, r1]
 8004604:	1c49      	adds	r1, r1, #1
 8004606:	291a      	cmp	r1, #26
 8004608:	d208      	bcs.n	800461c <PE_SubStateMachine_ExtendedMessages+0xb2>
 800460a:	e7f7      	b.n	80045fc <PE_SubStateMachine_ExtendedMessages+0x92>
 800460c:	5c42      	ldrb	r2, [r0, r1]
 800460e:	002b      	movs	r3, r5
 8004610:	331c      	adds	r3, #28
 8004612:	545a      	strb	r2, [r3, r1]
 8004614:	1c49      	adds	r1, r1, #1
 8004616:	8862      	ldrh	r2, [r4, #2]
 8004618:	4291      	cmp	r1, r2
 800461a:	d3f7      	bcc.n	800460c <PE_SubStateMachine_ExtendedMessages+0xa2>
 800461c:	2032      	movs	r0, #50	; 0x32
 800461e:	e08b      	b.n	8004738 <PE_SubStateMachine_ExtendedMessages+0x1ce>
 8004620:	0028      	movs	r0, r5
 8004622:	3018      	adds	r0, #24
 8004624:	9003      	str	r0, [sp, #12]
 8004626:	7b29      	ldrb	r1, [r5, #12]
 8004628:	07c8      	lsls	r0, r1, #31
 800462a:	0fc0      	lsrs	r0, r0, #31
 800462c:	f7ff ff3a 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004630:	2801      	cmp	r0, #1
 8004632:	d101      	bne.n	8004638 <PE_SubStateMachine_ExtendedMessages+0xce>
 8004634:	9802      	ldr	r0, [sp, #8]
 8004636:	9003      	str	r0, [sp, #12]
 8004638:	2001      	movs	r0, #1
 800463a:	68e9      	ldr	r1, [r5, #12]
 800463c:	0909      	lsrs	r1, r1, #4
 800463e:	4001      	ands	r1, r0
 8004640:	d006      	beq.n	8004650 <PE_SubStateMachine_ExtendedMessages+0xe6>
 8004642:	6869      	ldr	r1, [r5, #4]
 8004644:	7809      	ldrb	r1, [r1, #0]
 8004646:	0889      	lsrs	r1, r1, #2
 8004648:	4201      	tst	r1, r0
 800464a:	d102      	bne.n	8004652 <PE_SubStateMachine_ExtendedMessages+0xe8>
 800464c:	2002      	movs	r0, #2
 800464e:	e000      	b.n	8004652 <PE_SubStateMachine_ExtendedMessages+0xe8>
 8004650:	2000      	movs	r0, #0
 8004652:	21e4      	movs	r1, #228	; 0xe4
 8004654:	0089      	lsls	r1, r1, #2
 8004656:	186e      	adds	r6, r5, r1
 8004658:	9002      	str	r0, [sp, #8]
 800465a:	2033      	movs	r0, #51	; 0x33
 800465c:	9001      	str	r0, [sp, #4]
 800465e:	8860      	ldrh	r0, [r4, #2]
 8004660:	1d00      	adds	r0, r0, #4
 8004662:	9000      	str	r0, [sp, #0]
 8004664:	9b03      	ldr	r3, [sp, #12]
 8004666:	78f2      	ldrb	r2, [r6, #3]
 8004668:	7ae1      	ldrb	r1, [r4, #11]
 800466a:	0028      	movs	r0, r5
 800466c:	f7ff ff2a 	bl	80044c4 <PE_Send_ExtendedMessage>
 8004670:	2800      	cmp	r0, #0
 8004672:	d101      	bne.n	8004678 <PE_SubStateMachine_ExtendedMessages+0x10e>
 8004674:	88f0      	ldrh	r0, [r6, #6]
 8004676:	82e8      	strh	r0, [r5, #22]
 8004678:	e085      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800467a:	68ea      	ldr	r2, [r5, #12]
 800467c:	06d3      	lsls	r3, r2, #27
 800467e:	0fdb      	lsrs	r3, r3, #31
 8004680:	d009      	beq.n	8004696 <PE_SubStateMachine_ExtendedMessages+0x12c>
 8004682:	8461      	strh	r1, [r4, #34]	; 0x22
 8004684:	271a      	movs	r7, #26
 8004686:	20e4      	movs	r0, #228	; 0xe4
 8004688:	0080      	lsls	r0, r0, #2
 800468a:	1828      	adds	r0, r5, r0
 800468c:	78c0      	ldrb	r0, [r0, #3]
 800468e:	2884      	cmp	r0, #132	; 0x84
 8004690:	d166      	bne.n	8004760 <PE_SubStateMachine_ExtendedMessages+0x1f6>
 8004692:	2074      	movs	r0, #116	; 0x74
 8004694:	e072      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 8004696:	73a0      	strb	r0, [r4, #14]
 8004698:	2700      	movs	r7, #0
 800469a:	8466      	strh	r6, [r4, #34]	; 0x22
 800469c:	e073      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800469e:	4669      	mov	r1, sp
 80046a0:	22e4      	movs	r2, #228	; 0xe4
 80046a2:	0092      	lsls	r2, r2, #2
 80046a4:	5aaa      	ldrh	r2, [r5, r2]
 80046a6:	0452      	lsls	r2, r2, #17
 80046a8:	0f12      	lsrs	r2, r2, #28
 80046aa:	800a      	strh	r2, [r1, #0]
 80046ac:	4611      	mov	r1, r2
 80046ae:	221a      	movs	r2, #26
 80046b0:	434a      	muls	r2, r1
 80046b2:	9201      	str	r2, [sp, #4]
 80046b4:	8861      	ldrh	r1, [r4, #2]
 80046b6:	428a      	cmp	r2, r1
 80046b8:	da03      	bge.n	80046c2 <PE_SubStateMachine_ExtendedMessages+0x158>
 80046ba:	466a      	mov	r2, sp
 80046bc:	8812      	ldrh	r2, [r2, #0]
 80046be:	2a0a      	cmp	r2, #10
 80046c0:	db01      	blt.n	80046c6 <PE_SubStateMachine_ExtendedMessages+0x15c>
 80046c2:	8466      	strh	r6, [r4, #34]	; 0x22
 80046c4:	e05a      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 80046c6:	9a01      	ldr	r2, [sp, #4]
 80046c8:	1a88      	subs	r0, r1, r2
 80046ca:	281a      	cmp	r0, #26
 80046cc:	d202      	bcs.n	80046d4 <PE_SubStateMachine_ExtendedMessages+0x16a>
 80046ce:	1a89      	subs	r1, r1, r2
 80046d0:	b2c9      	uxtb	r1, r1
 80046d2:	e000      	b.n	80046d6 <PE_SubStateMachine_ExtendedMessages+0x16c>
 80046d4:	211a      	movs	r1, #26
 80046d6:	2000      	movs	r0, #0
 80046d8:	e006      	b.n	80046e8 <PE_SubStateMachine_ExtendedMessages+0x17e>
 80046da:	9b02      	ldr	r3, [sp, #8]
 80046dc:	1817      	adds	r7, r2, r0
 80046de:	5ddb      	ldrb	r3, [r3, r7]
 80046e0:	002f      	movs	r7, r5
 80046e2:	371c      	adds	r7, #28
 80046e4:	543b      	strb	r3, [r7, r0]
 80046e6:	1c40      	adds	r0, r0, #1
 80046e8:	4288      	cmp	r0, r1
 80046ea:	d3f6      	bcc.n	80046da <PE_SubStateMachine_ExtendedMessages+0x170>
 80046ec:	002b      	movs	r3, r5
 80046ee:	3318      	adds	r3, #24
 80046f0:	8862      	ldrh	r2, [r4, #2]
 80046f2:	20e4      	movs	r0, #228	; 0xe4
 80046f4:	0080      	lsls	r0, r0, #2
 80046f6:	5a28      	ldrh	r0, [r5, r0]
 80046f8:	0440      	lsls	r0, r0, #17
 80046fa:	0f01      	lsrs	r1, r0, #28
 80046fc:	7b2d      	ldrb	r5, [r5, #12]
 80046fe:	07e8      	lsls	r0, r5, #31
 8004700:	0fc0      	lsrs	r0, r0, #31
 8004702:	f001 f8cb 	bl	800589c <USBPD_PRL_PrepareExtendedTxChunkSending>
 8004706:	2035      	movs	r0, #53	; 0x35
 8004708:	e016      	b.n	8004738 <PE_SubStateMachine_ExtendedMessages+0x1ce>
 800470a:	9602      	str	r6, [sp, #8]
 800470c:	2036      	movs	r0, #54	; 0x36
 800470e:	9001      	str	r0, [sp, #4]
 8004710:	8860      	ldrh	r0, [r4, #2]
 8004712:	9000      	str	r0, [sp, #0]
 8004714:	002b      	movs	r3, r5
 8004716:	3318      	adds	r3, #24
 8004718:	20e4      	movs	r0, #228	; 0xe4
 800471a:	0080      	lsls	r0, r0, #2
 800471c:	1828      	adds	r0, r5, r0
 800471e:	78c2      	ldrb	r2, [r0, #3]
 8004720:	7ae1      	ldrb	r1, [r4, #11]
 8004722:	0028      	movs	r0, r5
 8004724:	f7ff fece 	bl	80044c4 <PE_Send_ExtendedMessage>
 8004728:	e02d      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800472a:	8026      	strh	r6, [r4, #0]
 800472c:	68ea      	ldr	r2, [r5, #12]
 800472e:	06d3      	lsls	r3, r2, #27
 8004730:	0fdb      	lsrs	r3, r3, #31
 8004732:	d001      	beq.n	8004738 <PE_SubStateMachine_ExtendedMessages+0x1ce>
 8004734:	8461      	strh	r1, [r4, #34]	; 0x22
 8004736:	2039      	movs	r0, #57	; 0x39
 8004738:	73a0      	strb	r0, [r4, #14]
 800473a:	e01d      	b.n	8004778 <PE_SubStateMachine_ExtendedMessages+0x20e>
 800473c:	8c60      	ldrh	r0, [r4, #34]	; 0x22
 800473e:	03ba      	lsls	r2, r7, #14
 8004740:	4290      	cmp	r0, r2
 8004742:	d101      	bne.n	8004748 <PE_SubStateMachine_ExtendedMessages+0x1de>
 8004744:	8466      	strh	r6, [r4, #34]	; 0x22
 8004746:	e00d      	b.n	8004764 <PE_SubStateMachine_ExtendedMessages+0x1fa>
 8004748:	8461      	strh	r1, [r4, #34]	; 0x22
 800474a:	271a      	movs	r7, #26
 800474c:	48c9      	ldr	r0, [pc, #804]	; (8004a74 <.text_78>)
 800474e:	182a      	adds	r2, r5, r0
 8004750:	7ae1      	ldrb	r1, [r4, #11]
 8004752:	7b2b      	ldrb	r3, [r5, #12]
 8004754:	07d8      	lsls	r0, r3, #31
 8004756:	0fc0      	lsrs	r0, r0, #31
 8004758:	f001 f8c8 	bl	80058ec <USBPD_PRL_ManageExtendedRx>
 800475c:	2800      	cmp	r0, #0
 800475e:	d101      	bne.n	8004764 <PE_SubStateMachine_ExtendedMessages+0x1fa>
 8004760:	2039      	movs	r0, #57	; 0x39
 8004762:	e00b      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 8004764:	200f      	movs	r0, #15
 8004766:	e009      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 8004768:	7aa1      	ldrb	r1, [r4, #10]
 800476a:	2900      	cmp	r1, #0
 800476c:	d006      	beq.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 800476e:	7ae0      	ldrb	r0, [r4, #11]
 8004770:	7460      	strb	r0, [r4, #17]
 8004772:	7aa0      	ldrb	r0, [r4, #10]
 8004774:	73a0      	strb	r0, [r4, #14]
 8004776:	72a6      	strb	r6, [r4, #10]
 8004778:	2700      	movs	r7, #0
 800477a:	e004      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800477c:	73a0      	strb	r0, [r4, #14]
 800477e:	e002      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 8004780:	8466      	strh	r6, [r4, #34]	; 0x22
 8004782:	73a0      	strb	r0, [r4, #14]
 8004784:	8026      	strh	r6, [r4, #0]
 8004786:	0038      	movs	r0, r7
 8004788:	b005      	add	sp, #20
 800478a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800478c <.text_74>:
 800478c:	00000242 	.word	0x00000242

08004790 <.text_75>:
 8004790:	0000034a 	.word	0x0000034a

08004794 <.text_76>:
 8004794:	0000801a 	.word	0x0000801a

08004798 <PE_SubStateMachine_Generic>:
 8004798:	b5f0      	push	{r4, r5, r6, r7, lr}
 800479a:	b085      	sub	sp, #20
 800479c:	0004      	movs	r4, r0
 800479e:	2601      	movs	r6, #1
 80047a0:	2703      	movs	r7, #3
 80047a2:	2500      	movs	r5, #0
 80047a4:	20d6      	movs	r0, #214	; 0xd6
 80047a6:	0080      	lsls	r0, r0, #2
 80047a8:	5c20      	ldrb	r0, [r4, r0]
 80047aa:	2801      	cmp	r0, #1
 80047ac:	d013      	beq.n	80047d6 <PE_SubStateMachine_Generic+0x3e>
 80047ae:	282c      	cmp	r0, #44	; 0x2c
 80047b0:	d100      	bne.n	80047b4 <PE_SubStateMachine_Generic+0x1c>
 80047b2:	e136      	b.n	8004a22 <PE_SubStateMachine_Generic+0x28a>
 80047b4:	2830      	cmp	r0, #48	; 0x30
 80047b6:	d05a      	beq.n	800486e <PE_SubStateMachine_Generic+0xd6>
 80047b8:	283a      	cmp	r0, #58	; 0x3a
 80047ba:	d100      	bne.n	80047be <PE_SubStateMachine_Generic+0x26>
 80047bc:	e10b      	b.n	80049d6 <PE_SubStateMachine_Generic+0x23e>
 80047be:	283b      	cmp	r0, #59	; 0x3b
 80047c0:	d100      	bne.n	80047c4 <PE_SubStateMachine_Generic+0x2c>
 80047c2:	e0e6      	b.n	8004992 <PE_SubStateMachine_Generic+0x1fa>
 80047c4:	283c      	cmp	r0, #60	; 0x3c
 80047c6:	d100      	bne.n	80047ca <PE_SubStateMachine_Generic+0x32>
 80047c8:	e0c1      	b.n	800494e <PE_SubStateMachine_Generic+0x1b6>
 80047ca:	2863      	cmp	r0, #99	; 0x63
 80047cc:	d01a      	beq.n	8004804 <PE_SubStateMachine_Generic+0x6c>
 80047ce:	2874      	cmp	r0, #116	; 0x74
 80047d0:	d100      	bne.n	80047d4 <PE_SubStateMachine_Generic+0x3c>
 80047d2:	e087      	b.n	80048e4 <PE_SubStateMachine_Generic+0x14c>
 80047d4:	e147      	b.n	8004a66 <PE_SubStateMachine_Generic+0x2ce>
 80047d6:	9500      	str	r5, [sp, #0]
 80047d8:	2303      	movs	r3, #3
 80047da:	2210      	movs	r2, #16
 80047dc:	2100      	movs	r1, #0
 80047de:	0020      	movs	r0, r4
 80047e0:	f7fe ffc7 	bl	8003772 <PE_Send_CtrlMessage>
 80047e4:	4da4      	ldr	r5, [pc, #656]	; (8004a78 <.text_79>)
 80047e6:	7828      	ldrb	r0, [r5, #0]
 80047e8:	0780      	lsls	r0, r0, #30
 80047ea:	d509      	bpl.n	8004800 <PE_SubStateMachine_Generic+0x68>
 80047ec:	2000      	movs	r0, #0
 80047ee:	9000      	str	r0, [sp, #0]
 80047f0:	2300      	movs	r3, #0
 80047f2:	2255      	movs	r2, #85	; 0x55
 80047f4:	68e0      	ldr	r0, [r4, #12]
 80047f6:	2101      	movs	r1, #1
 80047f8:	4001      	ands	r1, r0
 80047fa:	2009      	movs	r0, #9
 80047fc:	68ed      	ldr	r5, [r5, #12]
 80047fe:	47a8      	blx	r5
 8004800:	2155      	movs	r1, #85	; 0x55
 8004802:	e068      	b.n	80048d6 <PE_SubStateMachine_Generic+0x13e>
 8004804:	9503      	str	r5, [sp, #12]
 8004806:	ab03      	add	r3, sp, #12
 8004808:	0022      	movs	r2, r4
 800480a:	321c      	adds	r2, #28
 800480c:	2108      	movs	r1, #8
 800480e:	68e7      	ldr	r7, [r4, #12]
 8004810:	2001      	movs	r0, #1
 8004812:	4038      	ands	r0, r7
 8004814:	68a7      	ldr	r7, [r4, #8]
 8004816:	69bf      	ldr	r7, [r7, #24]
 8004818:	47b8      	blx	r7
 800481a:	76e5      	strb	r5, [r4, #27]
 800481c:	76a5      	strb	r5, [r4, #26]
 800481e:	68e1      	ldr	r1, [r4, #12]
 8004820:	2001      	movs	r0, #1
 8004822:	4008      	ands	r0, r1
 8004824:	f7ff fe3e 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004828:	2800      	cmp	r0, #0
 800482a:	d103      	bne.n	8004834 <PE_SubStateMachine_Generic+0x9c>
 800482c:	8b60      	ldrh	r0, [r4, #26]
 800482e:	03f1      	lsls	r1, r6, #15
 8004830:	4301      	orrs	r1, r0
 8004832:	8361      	strh	r1, [r4, #26]
 8004834:	9502      	str	r5, [sp, #8]
 8004836:	2003      	movs	r0, #3
 8004838:	9001      	str	r0, [sp, #4]
 800483a:	9803      	ldr	r0, [sp, #12]
 800483c:	1d00      	adds	r0, r0, #4
 800483e:	9000      	str	r0, [sp, #0]
 8004840:	0023      	movs	r3, r4
 8004842:	3318      	adds	r3, #24
 8004844:	2281      	movs	r2, #129	; 0x81
 8004846:	2100      	movs	r1, #0
 8004848:	0020      	movs	r0, r4
 800484a:	f7ff fe3b 	bl	80044c4 <PE_Send_ExtendedMessage>
 800484e:	4d8a      	ldr	r5, [pc, #552]	; (8004a78 <.text_79>)
 8004850:	7828      	ldrb	r0, [r5, #0]
 8004852:	0780      	lsls	r0, r0, #30
 8004854:	d509      	bpl.n	800486a <PE_SubStateMachine_Generic+0xd2>
 8004856:	2000      	movs	r0, #0
 8004858:	9000      	str	r0, [sp, #0]
 800485a:	2300      	movs	r3, #0
 800485c:	2245      	movs	r2, #69	; 0x45
 800485e:	68e0      	ldr	r0, [r4, #12]
 8004860:	2101      	movs	r1, #1
 8004862:	4001      	ands	r1, r0
 8004864:	2009      	movs	r0, #9
 8004866:	68ed      	ldr	r5, [r5, #12]
 8004868:	47a8      	blx	r5
 800486a:	2145      	movs	r1, #69	; 0x45
 800486c:	e033      	b.n	80048d6 <PE_SubStateMachine_Generic+0x13e>
 800486e:	9503      	str	r5, [sp, #12]
 8004870:	ab03      	add	r3, sp, #12
 8004872:	0022      	movs	r2, r4
 8004874:	321c      	adds	r2, #28
 8004876:	2109      	movs	r1, #9
 8004878:	68e7      	ldr	r7, [r4, #12]
 800487a:	2001      	movs	r0, #1
 800487c:	4038      	ands	r0, r7
 800487e:	68a7      	ldr	r7, [r4, #8]
 8004880:	69bf      	ldr	r7, [r7, #24]
 8004882:	47b8      	blx	r7
 8004884:	76e5      	strb	r5, [r4, #27]
 8004886:	76a5      	strb	r5, [r4, #26]
 8004888:	68e1      	ldr	r1, [r4, #12]
 800488a:	2001      	movs	r0, #1
 800488c:	4008      	ands	r0, r1
 800488e:	f7ff fe09 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004892:	2800      	cmp	r0, #0
 8004894:	d103      	bne.n	800489e <PE_SubStateMachine_Generic+0x106>
 8004896:	8b60      	ldrh	r0, [r4, #26]
 8004898:	03f1      	lsls	r1, r6, #15
 800489a:	4301      	orrs	r1, r0
 800489c:	8361      	strh	r1, [r4, #26]
 800489e:	9502      	str	r5, [sp, #8]
 80048a0:	2003      	movs	r0, #3
 80048a2:	9001      	str	r0, [sp, #4]
 80048a4:	9803      	ldr	r0, [sp, #12]
 80048a6:	1d00      	adds	r0, r0, #4
 80048a8:	9000      	str	r0, [sp, #0]
 80048aa:	0023      	movs	r3, r4
 80048ac:	3318      	adds	r3, #24
 80048ae:	2282      	movs	r2, #130	; 0x82
 80048b0:	2100      	movs	r1, #0
 80048b2:	0020      	movs	r0, r4
 80048b4:	f7ff fe06 	bl	80044c4 <PE_Send_ExtendedMessage>
 80048b8:	4d6f      	ldr	r5, [pc, #444]	; (8004a78 <.text_79>)
 80048ba:	7828      	ldrb	r0, [r5, #0]
 80048bc:	0780      	lsls	r0, r0, #30
 80048be:	d509      	bpl.n	80048d4 <PE_SubStateMachine_Generic+0x13c>
 80048c0:	2000      	movs	r0, #0
 80048c2:	9000      	str	r0, [sp, #0]
 80048c4:	2300      	movs	r3, #0
 80048c6:	224c      	movs	r2, #76	; 0x4c
 80048c8:	68e0      	ldr	r0, [r4, #12]
 80048ca:	2101      	movs	r1, #1
 80048cc:	4001      	ands	r1, r0
 80048ce:	2009      	movs	r0, #9
 80048d0:	68ed      	ldr	r5, [r5, #12]
 80048d2:	47a8      	blx	r5
 80048d4:	214c      	movs	r1, #76	; 0x4c
 80048d6:	68e0      	ldr	r0, [r4, #12]
 80048d8:	4006      	ands	r6, r0
 80048da:	0030      	movs	r0, r6
 80048dc:	68a2      	ldr	r2, [r4, #8]
 80048de:	68d2      	ldr	r2, [r2, #12]
 80048e0:	4790      	blx	r2
 80048e2:	e0c3      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 80048e4:	9100      	str	r1, [sp, #0]
 80048e6:	7808      	ldrb	r0, [r1, #0]
 80048e8:	2814      	cmp	r0, #20
 80048ea:	d025      	beq.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 80048ec:	20d6      	movs	r0, #214	; 0xd6
 80048ee:	0080      	lsls	r0, r0, #2
 80048f0:	1820      	adds	r0, r4, r0
 80048f2:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
 80048f4:	0bc0      	lsrs	r0, r0, #15
 80048f6:	d11f      	bne.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 80048f8:	20d6      	movs	r0, #214	; 0xd6
 80048fa:	0080      	lsls	r0, r0, #2
 80048fc:	1820      	adds	r0, r4, r0
 80048fe:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
 8004900:	0440      	lsls	r0, r0, #17
 8004902:	0f40      	lsrs	r0, r0, #29
 8004904:	d018      	beq.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 8004906:	20d6      	movs	r0, #214	; 0xd6
 8004908:	0080      	lsls	r0, r0, #2
 800490a:	1820      	adds	r0, r4, r0
 800490c:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
 800490e:	06c0      	lsls	r0, r0, #27
 8004910:	0ec0      	lsrs	r0, r0, #27
 8004912:	2805      	cmp	r0, #5
 8004914:	d110      	bne.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 8004916:	2318      	movs	r3, #24
 8004918:	209f      	movs	r0, #159	; 0x9f
 800491a:	0040      	lsls	r0, r0, #1
 800491c:	1822      	adds	r2, r4, r0
 800491e:	210f      	movs	r1, #15
 8004920:	68e0      	ldr	r0, [r4, #12]
 8004922:	4006      	ands	r6, r0
 8004924:	0030      	movs	r0, r6
 8004926:	68a6      	ldr	r6, [r4, #8]
 8004928:	69f6      	ldr	r6, [r6, #28]
 800492a:	47b0      	blx	r6
 800492c:	20d6      	movs	r0, #214	; 0xd6
 800492e:	0080      	lsls	r0, r0, #2
 8004930:	5427      	strb	r7, [r4, r0]
 8004932:	2014      	movs	r0, #20
 8004934:	9900      	ldr	r1, [sp, #0]
 8004936:	7008      	strb	r0, [r1, #0]
 8004938:	20d6      	movs	r0, #214	; 0xd6
 800493a:	0080      	lsls	r0, r0, #2
 800493c:	1820      	adds	r0, r4, r0
 800493e:	8a81      	ldrh	r1, [r0, #20]
 8004940:	2280      	movs	r2, #128	; 0x80
 8004942:	0212      	lsls	r2, r2, #8
 8004944:	4291      	cmp	r1, r2
 8004946:	d101      	bne.n	800494c <PE_SubStateMachine_Generic+0x1b4>
 8004948:	8285      	strh	r5, [r0, #20]
 800494a:	7007      	strb	r7, [r0, #0]
 800494c:	e08e      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 800494e:	ab03      	add	r3, sp, #12
 8004950:	0022      	movs	r2, r4
 8004952:	321c      	adds	r2, #28
 8004954:	210d      	movs	r1, #13
 8004956:	68e7      	ldr	r7, [r4, #12]
 8004958:	2001      	movs	r0, #1
 800495a:	4038      	ands	r0, r7
 800495c:	68a7      	ldr	r7, [r4, #8]
 800495e:	69bf      	ldr	r7, [r7, #24]
 8004960:	47b8      	blx	r7
 8004962:	76e5      	strb	r5, [r4, #27]
 8004964:	76a5      	strb	r5, [r4, #26]
 8004966:	68e0      	ldr	r0, [r4, #12]
 8004968:	4006      	ands	r6, r0
 800496a:	0030      	movs	r0, r6
 800496c:	f7ff fd9a 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004970:	2800      	cmp	r0, #0
 8004972:	d104      	bne.n	800497e <PE_SubStateMachine_Generic+0x1e6>
 8004974:	8b60      	ldrh	r0, [r4, #26]
 8004976:	2180      	movs	r1, #128	; 0x80
 8004978:	0209      	lsls	r1, r1, #8
 800497a:	4301      	orrs	r1, r0
 800497c:	8361      	strh	r1, [r4, #26]
 800497e:	9502      	str	r5, [sp, #8]
 8004980:	2003      	movs	r0, #3
 8004982:	9001      	str	r0, [sp, #4]
 8004984:	9803      	ldr	r0, [sp, #12]
 8004986:	1d00      	adds	r0, r0, #4
 8004988:	9000      	str	r0, [sp, #0]
 800498a:	0023      	movs	r3, r4
 800498c:	3318      	adds	r3, #24
 800498e:	2287      	movs	r2, #135	; 0x87
 8004990:	e042      	b.n	8004a18 <PE_SubStateMachine_Generic+0x280>
 8004992:	9503      	str	r5, [sp, #12]
 8004994:	ab04      	add	r3, sp, #16
 8004996:	0022      	movs	r2, r4
 8004998:	321c      	adds	r2, #28
 800499a:	210f      	movs	r1, #15
 800499c:	68e0      	ldr	r0, [r4, #12]
 800499e:	4006      	ands	r6, r0
 80049a0:	0030      	movs	r0, r6
 80049a2:	68a5      	ldr	r5, [r4, #8]
 80049a4:	69ad      	ldr	r5, [r5, #24]
 80049a6:	47a8      	blx	r5
 80049a8:	7fe0      	ldrb	r0, [r4, #31]
 80049aa:	0600      	lsls	r0, r0, #24
 80049ac:	7fa1      	ldrb	r1, [r4, #30]
 80049ae:	0409      	lsls	r1, r1, #16
 80049b0:	4301      	orrs	r1, r0
 80049b2:	7f60      	ldrb	r0, [r4, #29]
 80049b4:	0200      	lsls	r0, r0, #8
 80049b6:	4308      	orrs	r0, r1
 80049b8:	7f21      	ldrb	r1, [r4, #28]
 80049ba:	4301      	orrs	r1, r0
 80049bc:	9103      	str	r1, [sp, #12]
 80049be:	2000      	movs	r0, #0
 80049c0:	9002      	str	r0, [sp, #8]
 80049c2:	9701      	str	r7, [sp, #4]
 80049c4:	2001      	movs	r0, #1
 80049c6:	9000      	str	r0, [sp, #0]
 80049c8:	ab03      	add	r3, sp, #12
 80049ca:	2205      	movs	r2, #5
 80049cc:	2100      	movs	r1, #0
 80049ce:	0020      	movs	r0, r4
 80049d0:	f7fe ff16 	bl	8003800 <PE_Send_DataMessage>
 80049d4:	e04a      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 80049d6:	ab03      	add	r3, sp, #12
 80049d8:	0022      	movs	r2, r4
 80049da:	321c      	adds	r2, #28
 80049dc:	2111      	movs	r1, #17
 80049de:	68e7      	ldr	r7, [r4, #12]
 80049e0:	2001      	movs	r0, #1
 80049e2:	4038      	ands	r0, r7
 80049e4:	68a7      	ldr	r7, [r4, #8]
 80049e6:	69bf      	ldr	r7, [r7, #24]
 80049e8:	47b8      	blx	r7
 80049ea:	76e5      	strb	r5, [r4, #27]
 80049ec:	76a5      	strb	r5, [r4, #26]
 80049ee:	68e0      	ldr	r0, [r4, #12]
 80049f0:	4006      	ands	r6, r0
 80049f2:	0030      	movs	r0, r6
 80049f4:	f7ff fd56 	bl	80044a4 <PE_Get_UnchunkedSupport>
 80049f8:	2800      	cmp	r0, #0
 80049fa:	d104      	bne.n	8004a06 <PE_SubStateMachine_Generic+0x26e>
 80049fc:	8b60      	ldrh	r0, [r4, #26]
 80049fe:	2180      	movs	r1, #128	; 0x80
 8004a00:	0209      	lsls	r1, r1, #8
 8004a02:	4301      	orrs	r1, r0
 8004a04:	8361      	strh	r1, [r4, #26]
 8004a06:	9502      	str	r5, [sp, #8]
 8004a08:	2003      	movs	r0, #3
 8004a0a:	9001      	str	r0, [sp, #4]
 8004a0c:	9803      	ldr	r0, [sp, #12]
 8004a0e:	1d00      	adds	r0, r0, #4
 8004a10:	9000      	str	r0, [sp, #0]
 8004a12:	0023      	movs	r3, r4
 8004a14:	3318      	adds	r3, #24
 8004a16:	2285      	movs	r2, #133	; 0x85
 8004a18:	2100      	movs	r1, #0
 8004a1a:	0020      	movs	r0, r4
 8004a1c:	f7ff fd52 	bl	80044c4 <PE_Send_ExtendedMessage>
 8004a20:	e024      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 8004a22:	4d15      	ldr	r5, [pc, #84]	; (8004a78 <.text_79>)
 8004a24:	7828      	ldrb	r0, [r5, #0]
 8004a26:	0780      	lsls	r0, r0, #30
 8004a28:	d509      	bpl.n	8004a3e <PE_SubStateMachine_Generic+0x2a6>
 8004a2a:	2000      	movs	r0, #0
 8004a2c:	9000      	str	r0, [sp, #0]
 8004a2e:	2300      	movs	r3, #0
 8004a30:	224d      	movs	r2, #77	; 0x4d
 8004a32:	68e0      	ldr	r0, [r4, #12]
 8004a34:	2101      	movs	r1, #1
 8004a36:	4001      	ands	r1, r0
 8004a38:	2009      	movs	r0, #9
 8004a3a:	68ed      	ldr	r5, [r5, #12]
 8004a3c:	47a8      	blx	r5
 8004a3e:	214d      	movs	r1, #77	; 0x4d
 8004a40:	68e2      	ldr	r2, [r4, #12]
 8004a42:	2001      	movs	r0, #1
 8004a44:	4010      	ands	r0, r2
 8004a46:	68a2      	ldr	r2, [r4, #8]
 8004a48:	68d2      	ldr	r2, [r2, #12]
 8004a4a:	4790      	blx	r2
 8004a4c:	2300      	movs	r3, #0
 8004a4e:	2200      	movs	r2, #0
 8004a50:	210b      	movs	r1, #11
 8004a52:	68e0      	ldr	r0, [r4, #12]
 8004a54:	4006      	ands	r6, r0
 8004a56:	0030      	movs	r0, r6
 8004a58:	68a5      	ldr	r5, [r4, #8]
 8004a5a:	69ad      	ldr	r5, [r5, #24]
 8004a5c:	47a8      	blx	r5
 8004a5e:	20d6      	movs	r0, #214	; 0xd6
 8004a60:	0080      	lsls	r0, r0, #2
 8004a62:	5427      	strb	r7, [r4, r0]
 8004a64:	e002      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 8004a66:	20d6      	movs	r0, #214	; 0xd6
 8004a68:	0080      	lsls	r0, r0, #2
 8004a6a:	5426      	strb	r6, [r4, r0]
 8004a6c:	2002      	movs	r0, #2
 8004a6e:	b005      	add	sp, #20
 8004a70:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08004a74 <.text_78>:
 8004a74:	00000392 	.word	0x00000392

08004a78 <.text_79>:
 8004a78:	200019e8 	.word	0x200019e8

08004a7c <PE_SubStateMachine_VconnSwap>:
 8004a7c:	b5f2      	push	{r1, r4, r5, r6, r7, lr}
 8004a7e:	b082      	sub	sp, #8
 8004a80:	0004      	movs	r4, r0
 8004a82:	2002      	movs	r0, #2
 8004a84:	9001      	str	r0, [sp, #4]
 8004a86:	20d6      	movs	r0, #214	; 0xd6
 8004a88:	0080      	lsls	r0, r0, #2
 8004a8a:	1826      	adds	r6, r4, r0
 8004a8c:	201f      	movs	r0, #31
 8004a8e:	4d82      	ldr	r5, [pc, #520]	; (8004c98 <PE_SubStateMachine_VconnSwap+0x21c>)
 8004a90:	2107      	movs	r1, #7
 8004a92:	7832      	ldrb	r2, [r6, #0]
 8004a94:	2a9d      	cmp	r2, #157	; 0x9d
 8004a96:	d011      	beq.n	8004abc <PE_SubStateMachine_VconnSwap+0x40>
 8004a98:	d30f      	bcc.n	8004aba <PE_SubStateMachine_VconnSwap+0x3e>
 8004a9a:	2a9f      	cmp	r2, #159	; 0x9f
 8004a9c:	d077      	beq.n	8004b8e <PE_SubStateMachine_VconnSwap+0x112>
 8004a9e:	d34b      	bcc.n	8004b38 <PE_SubStateMachine_VconnSwap+0xbc>
 8004aa0:	2aa1      	cmp	r2, #161	; 0xa1
 8004aa2:	d100      	bne.n	8004aa6 <PE_SubStateMachine_VconnSwap+0x2a>
 8004aa4:	e0b0      	b.n	8004c08 <PE_SubStateMachine_VconnSwap+0x18c>
 8004aa6:	d200      	bcs.n	8004aaa <PE_SubStateMachine_VconnSwap+0x2e>
 8004aa8:	e0a3      	b.n	8004bf2 <PE_SubStateMachine_VconnSwap+0x176>
 8004aaa:	2aa3      	cmp	r2, #163	; 0xa3
 8004aac:	d100      	bne.n	8004ab0 <PE_SubStateMachine_VconnSwap+0x34>
 8004aae:	e0f5      	b.n	8004c9c <PE_SubStateMachine_VconnSwap+0x220>
 8004ab0:	d200      	bcs.n	8004ab4 <PE_SubStateMachine_VconnSwap+0x38>
 8004ab2:	e0c9      	b.n	8004c48 <PE_SubStateMachine_VconnSwap+0x1cc>
 8004ab4:	2aa4      	cmp	r2, #164	; 0xa4
 8004ab6:	d100      	bne.n	8004aba <PE_SubStateMachine_VconnSwap+0x3e>
 8004ab8:	e18f      	b.n	8004dda <PE_SubStateMachine_VconnSwap+0x35e>
 8004aba:	e1a3      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004abc:	6860      	ldr	r0, [r4, #4]
 8004abe:	2703      	movs	r7, #3
 8004ac0:	7842      	ldrb	r2, [r0, #1]
 8004ac2:	0912      	lsrs	r2, r2, #4
 8004ac4:	4011      	ands	r1, r2
 8004ac6:	2903      	cmp	r1, #3
 8004ac8:	d169      	bne.n	8004b9e <PE_SubStateMachine_VconnSwap+0x122>
 8004aca:	6800      	ldr	r0, [r0, #0]
 8004acc:	0501      	lsls	r1, r0, #20
 8004ace:	0fc9      	lsrs	r1, r1, #31
 8004ad0:	d065      	beq.n	8004b9e <PE_SubStateMachine_VconnSwap+0x122>
 8004ad2:	7b21      	ldrb	r1, [r4, #12]
 8004ad4:	07c8      	lsls	r0, r1, #31
 8004ad6:	0fc0      	lsrs	r0, r0, #31
 8004ad8:	68a1      	ldr	r1, [r4, #8]
 8004ada:	6b09      	ldr	r1, [r1, #48]	; 0x30
 8004adc:	4788      	blx	r1
 8004ade:	280a      	cmp	r0, #10
 8004ae0:	d002      	beq.n	8004ae8 <PE_SubStateMachine_VconnSwap+0x6c>
 8004ae2:	280d      	cmp	r0, #13
 8004ae4:	d008      	beq.n	8004af8 <PE_SubStateMachine_VconnSwap+0x7c>
 8004ae6:	e01e      	b.n	8004b26 <PE_SubStateMachine_VconnSwap+0xaa>
 8004ae8:	209e      	movs	r0, #158	; 0x9e
 8004aea:	7030      	strb	r0, [r6, #0]
 8004aec:	68e0      	ldr	r0, [r4, #12]
 8004aee:	2180      	movs	r1, #128	; 0x80
 8004af0:	0109      	lsls	r1, r1, #4
 8004af2:	4301      	orrs	r1, r0
 8004af4:	60e1      	str	r1, [r4, #12]
 8004af6:	e185      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004af8:	2000      	movs	r0, #0
 8004afa:	9000      	str	r0, [sp, #0]
 8004afc:	2303      	movs	r3, #3
 8004afe:	220c      	movs	r2, #12
 8004b00:	2100      	movs	r1, #0
 8004b02:	0020      	movs	r0, r4
 8004b04:	f7fe fe35 	bl	8003772 <PE_Send_CtrlMessage>
 8004b08:	7828      	ldrb	r0, [r5, #0]
 8004b0a:	0780      	lsls	r0, r0, #30
 8004b0c:	d509      	bpl.n	8004b22 <PE_SubStateMachine_VconnSwap+0xa6>
 8004b0e:	2000      	movs	r0, #0
 8004b10:	9000      	str	r0, [sp, #0]
 8004b12:	2300      	movs	r3, #0
 8004b14:	223e      	movs	r2, #62	; 0x3e
 8004b16:	7b20      	ldrb	r0, [r4, #12]
 8004b18:	07c1      	lsls	r1, r0, #31
 8004b1a:	0fc9      	lsrs	r1, r1, #31
 8004b1c:	2009      	movs	r0, #9
 8004b1e:	68ed      	ldr	r5, [r5, #12]
 8004b20:	47a8      	blx	r5
 8004b22:	213e      	movs	r1, #62	; 0x3e
 8004b24:	e08c      	b.n	8004c40 <PE_SubStateMachine_VconnSwap+0x1c4>
 8004b26:	2000      	movs	r0, #0
 8004b28:	9000      	str	r0, [sp, #0]
 8004b2a:	2303      	movs	r3, #3
 8004b2c:	2204      	movs	r2, #4
 8004b2e:	2100      	movs	r1, #0
 8004b30:	0020      	movs	r0, r4
 8004b32:	f7fe fe1e 	bl	8003772 <PE_Send_CtrlMessage>
 8004b36:	e036      	b.n	8004ba6 <PE_SubStateMachine_VconnSwap+0x12a>
 8004b38:	2000      	movs	r0, #0
 8004b3a:	9000      	str	r0, [sp, #0]
 8004b3c:	239e      	movs	r3, #158	; 0x9e
 8004b3e:	2203      	movs	r2, #3
 8004b40:	2100      	movs	r1, #0
 8004b42:	0020      	movs	r0, r4
 8004b44:	f7fe fe15 	bl	8003772 <PE_Send_CtrlMessage>
 8004b48:	2800      	cmp	r0, #0
 8004b4a:	d1d4      	bne.n	8004af6 <PE_SubStateMachine_VconnSwap+0x7a>
 8004b4c:	2701      	movs	r7, #1
 8004b4e:	6860      	ldr	r0, [r4, #4]
 8004b50:	6800      	ldr	r0, [r0, #0]
 8004b52:	0c80      	lsrs	r0, r0, #18
 8004b54:	4038      	ands	r0, r7
 8004b56:	d006      	beq.n	8004b66 <PE_SubStateMachine_VconnSwap+0xea>
 8004b58:	209f      	movs	r0, #159	; 0x9f
 8004b5a:	7030      	strb	r0, [r6, #0]
 8004b5c:	48aa      	ldr	r0, [pc, #680]	; (8004e08 <.text_81>)
 8004b5e:	84f0      	strh	r0, [r6, #38]	; 0x26
 8004b60:	2064      	movs	r0, #100	; 0x64
 8004b62:	9001      	str	r0, [sp, #4]
 8004b64:	e001      	b.n	8004b6a <PE_SubStateMachine_VconnSwap+0xee>
 8004b66:	20a0      	movs	r0, #160	; 0xa0
 8004b68:	7030      	strb	r0, [r6, #0]
 8004b6a:	7828      	ldrb	r0, [r5, #0]
 8004b6c:	0780      	lsls	r0, r0, #30
 8004b6e:	d509      	bpl.n	8004b84 <PE_SubStateMachine_VconnSwap+0x108>
 8004b70:	2000      	movs	r0, #0
 8004b72:	9000      	str	r0, [sp, #0]
 8004b74:	2300      	movs	r3, #0
 8004b76:	223d      	movs	r2, #61	; 0x3d
 8004b78:	68e0      	ldr	r0, [r4, #12]
 8004b7a:	2101      	movs	r1, #1
 8004b7c:	4001      	ands	r1, r0
 8004b7e:	2009      	movs	r0, #9
 8004b80:	68ed      	ldr	r5, [r5, #12]
 8004b82:	47a8      	blx	r5
 8004b84:	213d      	movs	r1, #61	; 0x3d
 8004b86:	68e0      	ldr	r0, [r4, #12]
 8004b88:	4007      	ands	r7, r0
 8004b8a:	0038      	movs	r0, r7
 8004b8c:	e080      	b.n	8004c90 <PE_SubStateMachine_VconnSwap+0x214>
 8004b8e:	2703      	movs	r7, #3
 8004b90:	8cf2      	ldrh	r2, [r6, #38]	; 0x26
 8004b92:	2380      	movs	r3, #128	; 0x80
 8004b94:	021b      	lsls	r3, r3, #8
 8004b96:	429a      	cmp	r2, r3
 8004b98:	d107      	bne.n	8004baa <PE_SubStateMachine_VconnSwap+0x12e>
 8004b9a:	2000      	movs	r0, #0
 8004b9c:	84f0      	strh	r0, [r6, #38]	; 0x26
 8004b9e:	68e0      	ldr	r0, [r4, #12]
 8004ba0:	499a      	ldr	r1, [pc, #616]	; (8004e0c <.text_82>)
 8004ba2:	4001      	ands	r1, r0
 8004ba4:	60e1      	str	r1, [r4, #12]
 8004ba6:	7037      	strb	r7, [r6, #0]
 8004ba8:	e12c      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004baa:	9a02      	ldr	r2, [sp, #8]
 8004bac:	7812      	ldrb	r2, [r2, #0]
 8004bae:	2a11      	cmp	r2, #17
 8004bb0:	d1fa      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bb2:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004bb4:	0bd2      	lsrs	r2, r2, #15
 8004bb6:	d1f7      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bb8:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004bba:	0b12      	lsrs	r2, r2, #12
 8004bbc:	420a      	tst	r2, r1
 8004bbe:	d1f3      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bc0:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 8004bc2:	4008      	ands	r0, r1
 8004bc4:	2806      	cmp	r0, #6
 8004bc6:	d1ef      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bc8:	2014      	movs	r0, #20
 8004bca:	9902      	ldr	r1, [sp, #8]
 8004bcc:	7008      	strb	r0, [r1, #0]
 8004bce:	68a0      	ldr	r0, [r4, #8]
 8004bd0:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004bd2:	2a00      	cmp	r2, #0
 8004bd4:	d004      	beq.n	8004be0 <PE_SubStateMachine_VconnSwap+0x164>
 8004bd6:	2100      	movs	r1, #0
 8004bd8:	7b23      	ldrb	r3, [r4, #12]
 8004bda:	07d8      	lsls	r0, r3, #31
 8004bdc:	0fc0      	lsrs	r0, r0, #31
 8004bde:	4790      	blx	r2
 8004be0:	68e0      	ldr	r0, [r4, #12]
 8004be2:	498a      	ldr	r1, [pc, #552]	; (8004e0c <.text_82>)
 8004be4:	4001      	ands	r1, r0
 8004be6:	60e1      	str	r1, [r4, #12]
 8004be8:	7037      	strb	r7, [r6, #0]
 8004bea:	7828      	ldrb	r0, [r5, #0]
 8004bec:	0780      	lsls	r0, r0, #30
 8004bee:	d41c      	bmi.n	8004c2a <PE_SubStateMachine_VconnSwap+0x1ae>
 8004bf0:	e025      	b.n	8004c3e <PE_SubStateMachine_VconnSwap+0x1c2>
 8004bf2:	68a0      	ldr	r0, [r4, #8]
 8004bf4:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004bf6:	2a00      	cmp	r2, #0
 8004bf8:	d004      	beq.n	8004c04 <PE_SubStateMachine_VconnSwap+0x188>
 8004bfa:	2101      	movs	r1, #1
 8004bfc:	7b23      	ldrb	r3, [r4, #12]
 8004bfe:	07d8      	lsls	r0, r3, #31
 8004c00:	0fc0      	lsrs	r0, r0, #31
 8004c02:	4790      	blx	r2
 8004c04:	20a1      	movs	r0, #161	; 0xa1
 8004c06:	e0fc      	b.n	8004e02 <PE_SubStateMachine_VconnSwap+0x386>
 8004c08:	2000      	movs	r0, #0
 8004c0a:	9000      	str	r0, [sp, #0]
 8004c0c:	2303      	movs	r3, #3
 8004c0e:	2206      	movs	r2, #6
 8004c10:	2100      	movs	r1, #0
 8004c12:	0020      	movs	r0, r4
 8004c14:	f7fe fdad 	bl	8003772 <PE_Send_CtrlMessage>
 8004c18:	2800      	cmp	r0, #0
 8004c1a:	d1c5      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004c1c:	68e0      	ldr	r0, [r4, #12]
 8004c1e:	497b      	ldr	r1, [pc, #492]	; (8004e0c <.text_82>)
 8004c20:	4001      	ands	r1, r0
 8004c22:	60e1      	str	r1, [r4, #12]
 8004c24:	7828      	ldrb	r0, [r5, #0]
 8004c26:	0780      	lsls	r0, r0, #30
 8004c28:	d509      	bpl.n	8004c3e <PE_SubStateMachine_VconnSwap+0x1c2>
 8004c2a:	2000      	movs	r0, #0
 8004c2c:	9000      	str	r0, [sp, #0]
 8004c2e:	2300      	movs	r3, #0
 8004c30:	2240      	movs	r2, #64	; 0x40
 8004c32:	7b20      	ldrb	r0, [r4, #12]
 8004c34:	07c1      	lsls	r1, r0, #31
 8004c36:	0fc9      	lsrs	r1, r1, #31
 8004c38:	2009      	movs	r0, #9
 8004c3a:	68ed      	ldr	r5, [r5, #12]
 8004c3c:	47a8      	blx	r5
 8004c3e:	2140      	movs	r1, #64	; 0x40
 8004c40:	7b22      	ldrb	r2, [r4, #12]
 8004c42:	07d0      	lsls	r0, r2, #31
 8004c44:	0fc0      	lsrs	r0, r0, #31
 8004c46:	e023      	b.n	8004c90 <PE_SubStateMachine_VconnSwap+0x214>
 8004c48:	2000      	movs	r0, #0
 8004c4a:	9000      	str	r0, [sp, #0]
 8004c4c:	23a3      	movs	r3, #163	; 0xa3
 8004c4e:	220b      	movs	r2, #11
 8004c50:	2100      	movs	r1, #0
 8004c52:	0020      	movs	r0, r4
 8004c54:	f7fe fd8d 	bl	8003772 <PE_Send_CtrlMessage>
 8004c58:	2800      	cmp	r0, #0
 8004c5a:	d11c      	bne.n	8004c96 <PE_SubStateMachine_VconnSwap+0x21a>
 8004c5c:	68e1      	ldr	r1, [r4, #12]
 8004c5e:	2080      	movs	r0, #128	; 0x80
 8004c60:	0100      	lsls	r0, r0, #4
 8004c62:	4308      	orrs	r0, r1
 8004c64:	60e0      	str	r0, [r4, #12]
 8004c66:	496a      	ldr	r1, [pc, #424]	; (8004e10 <.text_83>)
 8004c68:	82b1      	strh	r1, [r6, #20]
 8004c6a:	211a      	movs	r1, #26
 8004c6c:	9101      	str	r1, [sp, #4]
 8004c6e:	2601      	movs	r6, #1
 8004c70:	7829      	ldrb	r1, [r5, #0]
 8004c72:	0789      	lsls	r1, r1, #30
 8004c74:	d508      	bpl.n	8004c88 <PE_SubStateMachine_VconnSwap+0x20c>
 8004c76:	2100      	movs	r1, #0
 8004c78:	9100      	str	r1, [sp, #0]
 8004c7a:	2300      	movs	r3, #0
 8004c7c:	223c      	movs	r2, #60	; 0x3c
 8004c7e:	2101      	movs	r1, #1
 8004c80:	4001      	ands	r1, r0
 8004c82:	2009      	movs	r0, #9
 8004c84:	68ed      	ldr	r5, [r5, #12]
 8004c86:	47a8      	blx	r5
 8004c88:	213c      	movs	r1, #60	; 0x3c
 8004c8a:	68e0      	ldr	r0, [r4, #12]
 8004c8c:	4006      	ands	r6, r0
 8004c8e:	0030      	movs	r0, r6
 8004c90:	68a2      	ldr	r2, [r4, #8]
 8004c92:	68d2      	ldr	r2, [r2, #12]
 8004c94:	4790      	blx	r2
 8004c96:	e0b5      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004c98:	200019e8 	.word	0x200019e8
 8004c9c:	9a02      	ldr	r2, [sp, #8]
 8004c9e:	7812      	ldrb	r2, [r2, #0]
 8004ca0:	2a11      	cmp	r2, #17
 8004ca2:	d110      	bne.n	8004cc6 <PE_SubStateMachine_VconnSwap+0x24a>
 8004ca4:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004ca6:	0bd2      	lsrs	r2, r2, #15
 8004ca8:	d10d      	bne.n	8004cc6 <PE_SubStateMachine_VconnSwap+0x24a>
 8004caa:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004cac:	0b12      	lsrs	r2, r2, #12
 8004cae:	420a      	tst	r2, r1
 8004cb0:	d109      	bne.n	8004cc6 <PE_SubStateMachine_VconnSwap+0x24a>
 8004cb2:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 8004cb4:	4008      	ands	r0, r1
 8004cb6:	2803      	cmp	r0, #3
 8004cb8:	d006      	beq.n	8004cc8 <PE_SubStateMachine_VconnSwap+0x24c>
 8004cba:	2804      	cmp	r0, #4
 8004cbc:	d03f      	beq.n	8004d3e <PE_SubStateMachine_VconnSwap+0x2c2>
 8004cbe:	280c      	cmp	r0, #12
 8004cc0:	d020      	beq.n	8004d04 <PE_SubStateMachine_VconnSwap+0x288>
 8004cc2:	2810      	cmp	r0, #16
 8004cc4:	d05a      	beq.n	8004d7c <PE_SubStateMachine_VconnSwap+0x300>
 8004cc6:	e080      	b.n	8004dca <PE_SubStateMachine_VconnSwap+0x34e>
 8004cc8:	2000      	movs	r0, #0
 8004cca:	82b0      	strh	r0, [r6, #20]
 8004ccc:	2701      	movs	r7, #1
 8004cce:	6860      	ldr	r0, [r4, #4]
 8004cd0:	6800      	ldr	r0, [r0, #0]
 8004cd2:	0c80      	lsrs	r0, r0, #18
 8004cd4:	4038      	ands	r0, r7
 8004cd6:	d001      	beq.n	8004cdc <PE_SubStateMachine_VconnSwap+0x260>
 8004cd8:	209f      	movs	r0, #159	; 0x9f
 8004cda:	e000      	b.n	8004cde <PE_SubStateMachine_VconnSwap+0x262>
 8004cdc:	20a0      	movs	r0, #160	; 0xa0
 8004cde:	7030      	strb	r0, [r6, #0]
 8004ce0:	2014      	movs	r0, #20
 8004ce2:	9902      	ldr	r1, [sp, #8]
 8004ce4:	7008      	strb	r0, [r1, #0]
 8004ce6:	7828      	ldrb	r0, [r5, #0]
 8004ce8:	0780      	lsls	r0, r0, #30
 8004cea:	d509      	bpl.n	8004d00 <PE_SubStateMachine_VconnSwap+0x284>
 8004cec:	2000      	movs	r0, #0
 8004cee:	9000      	str	r0, [sp, #0]
 8004cf0:	2300      	movs	r3, #0
 8004cf2:	223d      	movs	r2, #61	; 0x3d
 8004cf4:	68e0      	ldr	r0, [r4, #12]
 8004cf6:	2101      	movs	r1, #1
 8004cf8:	4001      	ands	r1, r0
 8004cfa:	2009      	movs	r0, #9
 8004cfc:	68ed      	ldr	r5, [r5, #12]
 8004cfe:	47a8      	blx	r5
 8004d00:	213d      	movs	r1, #61	; 0x3d
 8004d02:	e05c      	b.n	8004dbe <PE_SubStateMachine_VconnSwap+0x342>
 8004d04:	2000      	movs	r0, #0
 8004d06:	82b0      	strh	r0, [r6, #20]
 8004d08:	68e0      	ldr	r0, [r4, #12]
 8004d0a:	4940      	ldr	r1, [pc, #256]	; (8004e0c <.text_82>)
 8004d0c:	4001      	ands	r1, r0
 8004d0e:	60e1      	str	r1, [r4, #12]
 8004d10:	2003      	movs	r0, #3
 8004d12:	7030      	strb	r0, [r6, #0]
 8004d14:	2014      	movs	r0, #20
 8004d16:	9902      	ldr	r1, [sp, #8]
 8004d18:	7008      	strb	r0, [r1, #0]
 8004d1a:	7828      	ldrb	r0, [r5, #0]
 8004d1c:	0780      	lsls	r0, r0, #30
 8004d1e:	d509      	bpl.n	8004d34 <PE_SubStateMachine_VconnSwap+0x2b8>
 8004d20:	2000      	movs	r0, #0
 8004d22:	9000      	str	r0, [sp, #0]
 8004d24:	2300      	movs	r3, #0
 8004d26:	223e      	movs	r2, #62	; 0x3e
 8004d28:	7b20      	ldrb	r0, [r4, #12]
 8004d2a:	07c1      	lsls	r1, r0, #31
 8004d2c:	0fc9      	lsrs	r1, r1, #31
 8004d2e:	2009      	movs	r0, #9
 8004d30:	68ed      	ldr	r5, [r5, #12]
 8004d32:	47a8      	blx	r5
 8004d34:	213e      	movs	r1, #62	; 0x3e
 8004d36:	7b22      	ldrb	r2, [r4, #12]
 8004d38:	07d0      	lsls	r0, r2, #31
 8004d3a:	0fc0      	lsrs	r0, r0, #31
 8004d3c:	e042      	b.n	8004dc4 <PE_SubStateMachine_VconnSwap+0x348>
 8004d3e:	2000      	movs	r0, #0
 8004d40:	82b0      	strh	r0, [r6, #20]
 8004d42:	68e0      	ldr	r0, [r4, #12]
 8004d44:	4931      	ldr	r1, [pc, #196]	; (8004e0c <.text_82>)
 8004d46:	4001      	ands	r1, r0
 8004d48:	60e1      	str	r1, [r4, #12]
 8004d4a:	2003      	movs	r0, #3
 8004d4c:	7030      	strb	r0, [r6, #0]
 8004d4e:	2014      	movs	r0, #20
 8004d50:	9902      	ldr	r1, [sp, #8]
 8004d52:	7008      	strb	r0, [r1, #0]
 8004d54:	7828      	ldrb	r0, [r5, #0]
 8004d56:	0780      	lsls	r0, r0, #30
 8004d58:	d509      	bpl.n	8004d6e <PE_SubStateMachine_VconnSwap+0x2f2>
 8004d5a:	2000      	movs	r0, #0
 8004d5c:	9000      	str	r0, [sp, #0]
 8004d5e:	2300      	movs	r3, #0
 8004d60:	223f      	movs	r2, #63	; 0x3f
 8004d62:	7b20      	ldrb	r0, [r4, #12]
 8004d64:	07c1      	lsls	r1, r0, #31
 8004d66:	0fc9      	lsrs	r1, r1, #31
 8004d68:	2009      	movs	r0, #9
 8004d6a:	68ef      	ldr	r7, [r5, #12]
 8004d6c:	47b8      	blx	r7
 8004d6e:	213f      	movs	r1, #63	; 0x3f
 8004d70:	7b22      	ldrb	r2, [r4, #12]
 8004d72:	07d0      	lsls	r0, r2, #31
 8004d74:	0fc0      	lsrs	r0, r0, #31
 8004d76:	68a2      	ldr	r2, [r4, #8]
 8004d78:	68d2      	ldr	r2, [r2, #12]
 8004d7a:	4790      	blx	r2
 8004d7c:	2000      	movs	r0, #0
 8004d7e:	82b0      	strh	r0, [r6, #20]
 8004d80:	2701      	movs	r7, #1
 8004d82:	6860      	ldr	r0, [r4, #4]
 8004d84:	6800      	ldr	r0, [r0, #0]
 8004d86:	0c80      	lsrs	r0, r0, #18
 8004d88:	4038      	ands	r0, r7
 8004d8a:	d101      	bne.n	8004d90 <PE_SubStateMachine_VconnSwap+0x314>
 8004d8c:	20a4      	movs	r0, #164	; 0xa4
 8004d8e:	e004      	b.n	8004d9a <PE_SubStateMachine_VconnSwap+0x31e>
 8004d90:	68e0      	ldr	r0, [r4, #12]
 8004d92:	491e      	ldr	r1, [pc, #120]	; (8004e0c <.text_82>)
 8004d94:	4001      	ands	r1, r0
 8004d96:	60e1      	str	r1, [r4, #12]
 8004d98:	2003      	movs	r0, #3
 8004d9a:	7030      	strb	r0, [r6, #0]
 8004d9c:	2014      	movs	r0, #20
 8004d9e:	9902      	ldr	r1, [sp, #8]
 8004da0:	7008      	strb	r0, [r1, #0]
 8004da2:	7828      	ldrb	r0, [r5, #0]
 8004da4:	0780      	lsls	r0, r0, #30
 8004da6:	d509      	bpl.n	8004dbc <PE_SubStateMachine_VconnSwap+0x340>
 8004da8:	2000      	movs	r0, #0
 8004daa:	9000      	str	r0, [sp, #0]
 8004dac:	2300      	movs	r3, #0
 8004dae:	2255      	movs	r2, #85	; 0x55
 8004db0:	68e0      	ldr	r0, [r4, #12]
 8004db2:	2101      	movs	r1, #1
 8004db4:	4001      	ands	r1, r0
 8004db6:	2009      	movs	r0, #9
 8004db8:	68ed      	ldr	r5, [r5, #12]
 8004dba:	47a8      	blx	r5
 8004dbc:	2155      	movs	r1, #85	; 0x55
 8004dbe:	68e0      	ldr	r0, [r4, #12]
 8004dc0:	4007      	ands	r7, r0
 8004dc2:	0038      	movs	r0, r7
 8004dc4:	68a2      	ldr	r2, [r4, #8]
 8004dc6:	68d2      	ldr	r2, [r2, #12]
 8004dc8:	4790      	blx	r2
 8004dca:	8ab0      	ldrh	r0, [r6, #20]
 8004dcc:	2180      	movs	r1, #128	; 0x80
 8004dce:	0209      	lsls	r1, r1, #8
 8004dd0:	4288      	cmp	r0, r1
 8004dd2:	d117      	bne.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004dd4:	2000      	movs	r0, #0
 8004dd6:	82b0      	strh	r0, [r6, #20]
 8004dd8:	e00e      	b.n	8004df8 <PE_SubStateMachine_VconnSwap+0x37c>
 8004dda:	68a0      	ldr	r0, [r4, #8]
 8004ddc:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004dde:	2a00      	cmp	r2, #0
 8004de0:	d004      	beq.n	8004dec <PE_SubStateMachine_VconnSwap+0x370>
 8004de2:	2101      	movs	r1, #1
 8004de4:	7b23      	ldrb	r3, [r4, #12]
 8004de6:	07d8      	lsls	r0, r3, #31
 8004de8:	0fc0      	lsrs	r0, r0, #31
 8004dea:	4790      	blx	r2
 8004dec:	6860      	ldr	r0, [r4, #4]
 8004dee:	6801      	ldr	r1, [r0, #0]
 8004df0:	2280      	movs	r2, #128	; 0x80
 8004df2:	02d2      	lsls	r2, r2, #11
 8004df4:	430a      	orrs	r2, r1
 8004df6:	6002      	str	r2, [r0, #0]
 8004df8:	68e0      	ldr	r0, [r4, #12]
 8004dfa:	4904      	ldr	r1, [pc, #16]	; (8004e0c <.text_82>)
 8004dfc:	4001      	ands	r1, r0
 8004dfe:	60e1      	str	r1, [r4, #12]
 8004e00:	2003      	movs	r0, #3
 8004e02:	7030      	strb	r0, [r6, #0]
 8004e04:	9801      	ldr	r0, [sp, #4]
 8004e06:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08004e08 <.text_81>:
 8004e08:	00008064 	.word	0x00008064

08004e0c <.text_82>:
 8004e0c:	fffff7ff 	.word	0xfffff7ff

08004e10 <.text_83>:
 8004e10:	0000801a 	.word	0x0000801a

08004e14 <USBPD_PE_ExecFastRoleSwapSignalling>:
 8004e14:	b580      	push	{r7, lr}
 8004e16:	f000 f8bc 	bl	8004f92 <USBPD_PRL_FastRoleSwapSignalling>
 8004e1a:	bd01      	pop	{r0, pc}

08004e1c <USBPD_PRL_TimerCounter>:
 8004e1c:	b081      	sub	sp, #4
 8004e1e:	4965      	ldr	r1, [pc, #404]	; (8004fb4 <.text_17>)
 8004e20:	0080      	lsls	r0, r0, #2
 8004e22:	1808      	adds	r0, r1, r0
 8004e24:	6841      	ldr	r1, [r0, #4]
 8004e26:	7a8a      	ldrb	r2, [r1, #10]
 8004e28:	2a00      	cmp	r2, #0
 8004e2a:	d001      	beq.n	8004e30 <USBPD_PRL_TimerCounter+0x14>
 8004e2c:	1e52      	subs	r2, r2, #1
 8004e2e:	728a      	strb	r2, [r1, #10]
 8004e30:	6840      	ldr	r0, [r0, #4]
 8004e32:	8e81      	ldrh	r1, [r0, #52]	; 0x34
 8004e34:	2900      	cmp	r1, #0
 8004e36:	d001      	beq.n	8004e3c <USBPD_PRL_TimerCounter+0x20>
 8004e38:	1e49      	subs	r1, r1, #1
 8004e3a:	8681      	strh	r1, [r0, #52]	; 0x34
 8004e3c:	b001      	add	sp, #4
 8004e3e:	4770      	bx	lr

08004e40 <USBPD_PRL_Init>:
 8004e40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8004e42:	b082      	sub	sp, #8
 8004e44:	001c      	movs	r4, r3
 8004e46:	4668      	mov	r0, sp
 8004e48:	7a00      	ldrb	r0, [r0, #8]
 8004e4a:	2801      	cmp	r0, #1
 8004e4c:	d83a      	bhi.n	8004ec4 <USBPD_PRL_Init+0x84>
 8004e4e:	2038      	movs	r0, #56	; 0x38
 8004e50:	f007 fb42 	bl	800c4d8 <malloc>
 8004e54:	4957      	ldr	r1, [pc, #348]	; (8004fb4 <.text_17>)
 8004e56:	466a      	mov	r2, sp
 8004e58:	7a12      	ldrb	r2, [r2, #8]
 8004e5a:	0092      	lsls	r2, r2, #2
 8004e5c:	188d      	adds	r5, r1, r2
 8004e5e:	6068      	str	r0, [r5, #4]
 8004e60:	2800      	cmp	r0, #0
 8004e62:	d101      	bne.n	8004e68 <USBPD_PRL_Init+0x28>
 8004e64:	2016      	movs	r0, #22
 8004e66:	e02e      	b.n	8004ec6 <USBPD_PRL_Init+0x86>
 8004e68:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8004e6a:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8004e6c:	4669      	mov	r1, sp
 8004e6e:	710c      	strb	r4, [r1, #4]
 8004e70:	2138      	movs	r1, #56	; 0x38
 8004e72:	f007 fb01 	bl	800c478 <__aeabi_memclr>
 8004e76:	6868      	ldr	r0, [r5, #4]
 8004e78:	2400      	movs	r4, #0
 8004e7a:	7104      	strb	r4, [r0, #4]
 8004e7c:	7144      	strb	r4, [r0, #5]
 8004e7e:	6006      	str	r6, [r0, #0]
 8004e80:	7284      	strb	r4, [r0, #10]
 8004e82:	6869      	ldr	r1, [r5, #4]
 8004e84:	72cc      	strb	r4, [r1, #11]
 8004e86:	220f      	movs	r2, #15
 8004e88:	2103      	movs	r1, #3
 8004e8a:	6868      	ldr	r0, [r5, #4]
 8004e8c:	1d80      	adds	r0, r0, #6
 8004e8e:	f007 faf8 	bl	800c482 <__aeabi_memset>
 8004e92:	6869      	ldr	r1, [r5, #4]
 8004e94:	730c      	strb	r4, [r1, #12]
 8004e96:	6868      	ldr	r0, [r5, #4]
 8004e98:	9904      	ldr	r1, [sp, #16]
 8004e9a:	62c1      	str	r1, [r0, #44]	; 0x2c
 8004e9c:	990a      	ldr	r1, [sp, #40]	; 0x28
 8004e9e:	6281      	str	r1, [r0, #40]	; 0x28
 8004ea0:	6247      	str	r7, [r0, #36]	; 0x24
 8004ea2:	9903      	ldr	r1, [sp, #12]
 8004ea4:	6301      	str	r1, [r0, #48]	; 0x30
 8004ea6:	7344      	strb	r4, [r0, #13]
 8004ea8:	6868      	ldr	r0, [r5, #4]
 8004eaa:	7384      	strb	r4, [r0, #14]
 8004eac:	2001      	movs	r0, #1
 8004eae:	9000      	str	r0, [sp, #0]
 8004eb0:	4668      	mov	r0, sp
 8004eb2:	7903      	ldrb	r3, [r0, #4]
 8004eb4:	6868      	ldr	r0, [r5, #4]
 8004eb6:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8004eb8:	a104      	add	r1, pc, #16	; (adr r1, 8004ecc <PRL_PhyCallbacks>)
 8004eba:	4668      	mov	r0, sp
 8004ebc:	7a00      	ldrb	r0, [r0, #8]
 8004ebe:	f004 fb7b 	bl	80095b8 <USBPD_PHY_Init>
 8004ec2:	e000      	b.n	8004ec6 <USBPD_PRL_Init+0x86>
 8004ec4:	2002      	movs	r0, #2
 8004ec6:	b005      	add	sp, #20
 8004ec8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08004ecc <PRL_PhyCallbacks>:
 8004ecc:	54af 0800 57d1 0800 5819 0800 5827 0800     .T...W...X..'X..
 8004edc:	5839 0800 5855 0800                         9X..UX..

08004ee4 <USBPD_PRL_GetMemoryConsumption>:
 8004ee4:	2070      	movs	r0, #112	; 0x70
 8004ee6:	4770      	bx	lr

08004ee8 <USBPD_PRL_SetHeader>:
 8004ee8:	b530      	push	{r4, r5, lr}
 8004eea:	4c32      	ldr	r4, [pc, #200]	; (8004fb4 <.text_17>)
 8004eec:	0080      	lsls	r0, r0, #2
 8004eee:	1820      	adds	r0, r4, r0
 8004ef0:	6840      	ldr	r0, [r0, #4]
 8004ef2:	8a84      	ldrh	r4, [r0, #20]
 8004ef4:	4d30      	ldr	r5, [pc, #192]	; (8004fb8 <.text_18>)
 8004ef6:	4025      	ands	r5, r4
 8004ef8:	0209      	lsls	r1, r1, #8
 8004efa:	2480      	movs	r4, #128	; 0x80
 8004efc:	0064      	lsls	r4, r4, #1
 8004efe:	4021      	ands	r1, r4
 8004f00:	4329      	orrs	r1, r5
 8004f02:	8281      	strh	r1, [r0, #20]
 8004f04:	4c2d      	ldr	r4, [pc, #180]	; (8004fbc <.text_19>)
 8004f06:	400c      	ands	r4, r1
 8004f08:	0151      	lsls	r1, r2, #5
 8004f0a:	2220      	movs	r2, #32
 8004f0c:	4011      	ands	r1, r2
 8004f0e:	4321      	orrs	r1, r4
 8004f10:	8281      	strh	r1, [r0, #20]
 8004f12:	4a2b      	ldr	r2, [pc, #172]	; (8004fc0 <.text_20>)
 8004f14:	400a      	ands	r2, r1
 8004f16:	0199      	lsls	r1, r3, #6
 8004f18:	23c0      	movs	r3, #192	; 0xc0
 8004f1a:	400b      	ands	r3, r1
 8004f1c:	4313      	orrs	r3, r2
 8004f1e:	8283      	strh	r3, [r0, #20]
 8004f20:	bd30      	pop	{r4, r5, pc}

08004f22 <USBPD_PRL_SetHeaderPowerRole>:
 8004f22:	4a24      	ldr	r2, [pc, #144]	; (8004fb4 <.text_17>)
 8004f24:	0080      	lsls	r0, r0, #2
 8004f26:	1810      	adds	r0, r2, r0
 8004f28:	6840      	ldr	r0, [r0, #4]
 8004f2a:	8a82      	ldrh	r2, [r0, #20]
 8004f2c:	4b22      	ldr	r3, [pc, #136]	; (8004fb8 <.text_18>)
 8004f2e:	4013      	ands	r3, r2
 8004f30:	0209      	lsls	r1, r1, #8
 8004f32:	2280      	movs	r2, #128	; 0x80
 8004f34:	0052      	lsls	r2, r2, #1
 8004f36:	e008      	b.n	8004f4a <.text_10>

08004f38 <USBPD_PRL_SetHeaderDataRole>:
 8004f38:	4a1e      	ldr	r2, [pc, #120]	; (8004fb4 <.text_17>)
 8004f3a:	0080      	lsls	r0, r0, #2
 8004f3c:	1810      	adds	r0, r2, r0
 8004f3e:	6840      	ldr	r0, [r0, #4]
 8004f40:	8a82      	ldrh	r2, [r0, #20]
 8004f42:	4b1e      	ldr	r3, [pc, #120]	; (8004fbc <.text_19>)
 8004f44:	4013      	ands	r3, r2
 8004f46:	0149      	lsls	r1, r1, #5
 8004f48:	2220      	movs	r2, #32

08004f4a <.text_10>:
 8004f4a:	4011      	ands	r1, r2
 8004f4c:	4319      	orrs	r1, r3
 8004f4e:	8281      	strh	r1, [r0, #20]
 8004f50:	4770      	bx	lr

08004f52 <USBPD_PRL_SetHeaderSpecification>:
 8004f52:	4a18      	ldr	r2, [pc, #96]	; (8004fb4 <.text_17>)
 8004f54:	0080      	lsls	r0, r0, #2
 8004f56:	1810      	adds	r0, r2, r0
 8004f58:	6840      	ldr	r0, [r0, #4]
 8004f5a:	8a82      	ldrh	r2, [r0, #20]
 8004f5c:	4b18      	ldr	r3, [pc, #96]	; (8004fc0 <.text_20>)
 8004f5e:	4013      	ands	r3, r2
 8004f60:	0189      	lsls	r1, r1, #6
 8004f62:	22c0      	movs	r2, #192	; 0xc0
 8004f64:	400a      	ands	r2, r1
 8004f66:	431a      	orrs	r2, r3
 8004f68:	8282      	strh	r2, [r0, #20]
 8004f6a:	4770      	bx	lr

08004f6c <USBPD_PRL_SRCSetSinkNG>:
 8004f6c:	b580      	push	{r7, lr}
 8004f6e:	f004 faf7 	bl	8009560 <USBPD_PHY_SetResistor_SinkTxNG>
 8004f72:	bd01      	pop	{r0, pc}

08004f74 <USBPD_PRL_SRCReleaseSinkNG>:
 8004f74:	b510      	push	{r4, lr}
 8004f76:	0004      	movs	r4, r0
 8004f78:	f004 fafa 	bl	8009570 <USBPD_PHY_SetResistor_SinkTxOK>
 8004f7c:	480d      	ldr	r0, [pc, #52]	; (8004fb4 <.text_17>)
 8004f7e:	00a1      	lsls	r1, r4, #2
 8004f80:	1840      	adds	r0, r0, r1
 8004f82:	6840      	ldr	r0, [r0, #4]
 8004f84:	2106      	movs	r1, #6
 8004f86:	7101      	strb	r1, [r0, #4]
 8004f88:	bd10      	pop	{r4, pc}

08004f8a <USBPD_PRL_IsResistor_SinkTxOK>:
 8004f8a:	b580      	push	{r7, lr}
 8004f8c:	f004 faf9 	bl	8009582 <USBPD_PHY_IsResistor_SinkTxOk>
 8004f90:	bd02      	pop	{r1, pc}

08004f92 <USBPD_PRL_FastRoleSwapSignalling>:
 8004f92:	b580      	push	{r7, lr}
 8004f94:	f004 faf9 	bl	800958a <USBPD_PHY_FastRoleSwapSignalling>
 8004f98:	bd01      	pop	{r0, pc}

08004f9a <USBPD_PRL_CableCapable>:
 8004f9a:	b580      	push	{r7, lr}
 8004f9c:	2901      	cmp	r1, #1
 8004f9e:	d105      	bne.n	8004fac <USBPD_PRL_CableCapable+0x12>
 8004fa0:	4904      	ldr	r1, [pc, #16]	; (8004fb4 <.text_17>)
 8004fa2:	0082      	lsls	r2, r0, #2
 8004fa4:	1889      	adds	r1, r1, r2
 8004fa6:	6849      	ldr	r1, [r1, #4]
 8004fa8:	6809      	ldr	r1, [r1, #0]
 8004faa:	e000      	b.n	8004fae <USBPD_PRL_CableCapable+0x14>
 8004fac:	2101      	movs	r1, #1
 8004fae:	f004 fae7 	bl	8009580 <USBPD_PHY_SOPSupported>
 8004fb2:	bd01      	pop	{r0, pc}

08004fb4 <.text_17>:
 8004fb4:	200019fc 	.word	0x200019fc

08004fb8 <.text_18>:
 8004fb8:	0000feff 	.word	0x0000feff

08004fbc <.text_19>:
 8004fbc:	0000ffdf 	.word	0x0000ffdf

08004fc0 <.text_20>:
 8004fc0:	0000ff3f 	.word	0x0000ff3f

08004fc4 <USBPD_PRL_SendMessage>:
 8004fc4:	b5f5      	push	{r0, r2, r4, r5, r6, r7, lr}
 8004fc6:	b083      	sub	sp, #12
 8004fc8:	2703      	movs	r7, #3
 8004fca:	48b2      	ldr	r0, [pc, #712]	; (8005294 <USBPD_PRL_SendMessage+0x2d0>)
 8004fcc:	466a      	mov	r2, sp
 8004fce:	7b12      	ldrb	r2, [r2, #12]
 8004fd0:	0092      	lsls	r2, r2, #2
 8004fd2:	1884      	adds	r4, r0, r2
 8004fd4:	6860      	ldr	r0, [r4, #4]
 8004fd6:	7a42      	ldrb	r2, [r0, #9]
 8004fd8:	2a00      	cmp	r2, #0
 8004fda:	d104      	bne.n	8004fe6 <USBPD_PRL_SendMessage+0x22>
 8004fdc:	7902      	ldrb	r2, [r0, #4]
 8004fde:	2a06      	cmp	r2, #6
 8004fe0:	dd01      	ble.n	8004fe6 <USBPD_PRL_SendMessage+0x22>
 8004fe2:	220e      	movs	r2, #14
 8004fe4:	7102      	strb	r2, [r0, #4]
 8004fe6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8004fe8:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8004fea:	9302      	str	r3, [sp, #8]
 8004fec:	466b      	mov	r3, sp
 8004fee:	7119      	strb	r1, [r3, #4]
 8004ff0:	9200      	str	r2, [sp, #0]
 8004ff2:	2606      	movs	r6, #6
 8004ff4:	2200      	movs	r2, #0
 8004ff6:	7901      	ldrb	r1, [r0, #4]
 8004ff8:	290f      	cmp	r1, #15
 8004ffa:	d900      	bls.n	8004ffe <USBPD_PRL_SendMessage+0x3a>
 8004ffc:	e1c0      	b.n	8005380 <USBPD_PRL_SendMessage+0x3bc>
 8004ffe:	a302      	add	r3, pc, #8	; (adr r3, 8005008 <USBPD_PRL_SendMessage+0x44>)
 8005000:	0049      	lsls	r1, r1, #1
 8005002:	5a5b      	ldrh	r3, [r3, r1]
 8005004:	449f      	add	pc, r3
 8005006:	bf00      	nop
 8005008:	002e0020 	.word	0x002e0020
 800500c:	03780042 	.word	0x03780042
 8005010:	00900052 	.word	0x00900052
 8005014:	011e0078 	.word	0x011e0078
 8005018:	02900130 	.word	0x02900130
 800501c:	02dc02b6 	.word	0x02dc02b6
 8005020:	037802fc 	.word	0x037802fc
 8005024:	032e0372 	.word	0x032e0372
 8005028:	4668      	mov	r0, sp
 800502a:	7b00      	ldrb	r0, [r0, #12]
 800502c:	f004 fac0 	bl	80095b0 <USBPD_PHY_Reset>
 8005030:	6860      	ldr	r0, [r4, #4]
 8005032:	7106      	strb	r6, [r0, #4]
 8005034:	e1a6      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005036:	4668      	mov	r0, sp
 8005038:	7b00      	ldrb	r0, [r0, #12]
 800503a:	f004 fa91 	bl	8009560 <USBPD_PHY_SetResistor_SinkTxNG>
 800503e:	6860      	ldr	r0, [r4, #4]
 8005040:	2102      	movs	r1, #2
 8005042:	7101      	strb	r1, [r0, #4]
 8005044:	2111      	movs	r1, #17
 8005046:	8681      	strh	r1, [r0, #52]	; 0x34
 8005048:	e19c      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 800504a:	9900      	ldr	r1, [sp, #0]
 800504c:	2901      	cmp	r1, #1
 800504e:	d1ef      	bne.n	8005030 <USBPD_PRL_SendMessage+0x6c>
 8005050:	8e81      	ldrh	r1, [r0, #52]	; 0x34
 8005052:	2900      	cmp	r1, #0
 8005054:	d112      	bne.n	800507c <USBPD_PRL_SendMessage+0xb8>
 8005056:	2105      	movs	r1, #5
 8005058:	e168      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 800505a:	9800      	ldr	r0, [sp, #0]
 800505c:	2802      	cmp	r0, #2
 800505e:	d1e7      	bne.n	8005030 <USBPD_PRL_SendMessage+0x6c>
 8005060:	4668      	mov	r0, sp
 8005062:	7b00      	ldrb	r0, [r0, #12]
 8005064:	f004 fa8d 	bl	8009582 <USBPD_PHY_IsResistor_SinkTxOk>
 8005068:	2801      	cmp	r0, #1
 800506a:	d107      	bne.n	800507c <USBPD_PRL_SendMessage+0xb8>
 800506c:	2005      	movs	r0, #5
 800506e:	6861      	ldr	r1, [r4, #4]
 8005070:	7108      	strb	r0, [r1, #4]
 8005072:	4668      	mov	r0, sp
 8005074:	7b00      	ldrb	r0, [r0, #12]
 8005076:	f004 fa84 	bl	8009582 <USBPD_PHY_IsResistor_SinkTxOk>
 800507a:	e183      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 800507c:	2009      	movs	r0, #9
 800507e:	e182      	b.n	8005386 <USBPD_PRL_SendMessage+0x3c2>
 8005080:	8a81      	ldrh	r1, [r0, #20]
 8005082:	0609      	lsls	r1, r1, #24
 8005084:	0f89      	lsrs	r1, r1, #30
 8005086:	2902      	cmp	r1, #2
 8005088:	d106      	bne.n	8005098 <USBPD_PRL_SendMessage+0xd4>
 800508a:	9900      	ldr	r1, [sp, #0]
 800508c:	2901      	cmp	r1, #1
 800508e:	d002      	beq.n	8005096 <USBPD_PRL_SendMessage+0xd2>
 8005090:	2902      	cmp	r1, #2
 8005092:	d101      	bne.n	8005098 <USBPD_PRL_SendMessage+0xd4>
 8005094:	2104      	movs	r1, #4
 8005096:	e149      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 8005098:	4669      	mov	r1, sp
 800509a:	7c09      	ldrb	r1, [r1, #16]
 800509c:	23ff      	movs	r3, #255	; 0xff
 800509e:	7243      	strb	r3, [r0, #9]
 80050a0:	8a86      	ldrh	r6, [r0, #20]
 80050a2:	4bbd      	ldr	r3, [pc, #756]	; (8005398 <.text_23>)
 80050a4:	4033      	ands	r3, r6
 80050a6:	06ce      	lsls	r6, r1, #27
 80050a8:	0ef6      	lsrs	r6, r6, #27
 80050aa:	431e      	orrs	r6, r3
 80050ac:	8286      	strh	r6, [r0, #20]
 80050ae:	0473      	lsls	r3, r6, #17
 80050b0:	0c5b      	lsrs	r3, r3, #17
 80050b2:	09ce      	lsrs	r6, r1, #7
 80050b4:	03f6      	lsls	r6, r6, #15
 80050b6:	431e      	orrs	r6, r3
 80050b8:	8286      	strh	r6, [r0, #20]
 80050ba:	7302      	strb	r2, [r0, #12]
 80050bc:	6860      	ldr	r0, [r4, #4]
 80050be:	8a83      	ldrh	r3, [r0, #20]
 80050c0:	0bdc      	lsrs	r4, r3, #15
 80050c2:	d018      	beq.n	80050f6 <USBPD_PRL_SendMessage+0x132>
 80050c4:	9b02      	ldr	r3, [sp, #8]
 80050c6:	789b      	ldrb	r3, [r3, #2]
 80050c8:	9c02      	ldr	r4, [sp, #8]
 80050ca:	78e4      	ldrb	r4, [r4, #3]
 80050cc:	0224      	lsls	r4, r4, #8
 80050ce:	191b      	adds	r3, r3, r4
 80050d0:	8343      	strh	r3, [r0, #26]
 80050d2:	8b43      	ldrh	r3, [r0, #26]
 80050d4:	0a9c      	lsrs	r4, r3, #10
 80050d6:	07e4      	lsls	r4, r4, #31
 80050d8:	d41a      	bmi.n	8005110 <USBPD_PRL_SendMessage+0x14c>
 80050da:	0ada      	lsrs	r2, r3, #11
 80050dc:	0712      	lsls	r2, r2, #28
 80050de:	d118      	bne.n	8005112 <USBPD_PRL_SendMessage+0x14e>
 80050e0:	1f2a      	subs	r2, r5, #4
 80050e2:	8402      	strh	r2, [r0, #32]
 80050e4:	05d2      	lsls	r2, r2, #23
 80050e6:	0dd2      	lsrs	r2, r2, #23
 80050e8:	8b43      	ldrh	r3, [r0, #26]
 80050ea:	24fe      	movs	r4, #254	; 0xfe
 80050ec:	0224      	lsls	r4, r4, #8
 80050ee:	401c      	ands	r4, r3
 80050f0:	4322      	orrs	r2, r4
 80050f2:	8342      	strh	r2, [r0, #26]
 80050f4:	e00d      	b.n	8005112 <USBPD_PRL_SendMessage+0x14e>
 80050f6:	1eac      	subs	r4, r5, #2
 80050f8:	4da8      	ldr	r5, [pc, #672]	; (800539c <.text_24>)
 80050fa:	401d      	ands	r5, r3
 80050fc:	1063      	asrs	r3, r4, #1
 80050fe:	0f9b      	lsrs	r3, r3, #30
 8005100:	191b      	adds	r3, r3, r4
 8005102:	109b      	asrs	r3, r3, #2
 8005104:	031b      	lsls	r3, r3, #12
 8005106:	24e0      	movs	r4, #224	; 0xe0
 8005108:	01e4      	lsls	r4, r4, #7
 800510a:	401c      	ands	r4, r3
 800510c:	432c      	orrs	r4, r5
 800510e:	8284      	strh	r4, [r0, #20]
 8005110:	8402      	strh	r2, [r0, #32]
 8005112:	290d      	cmp	r1, #13
 8005114:	d103      	bne.n	800511e <USBPD_PRL_SendMessage+0x15a>
 8005116:	8a81      	ldrh	r1, [r0, #20]
 8005118:	22f0      	movs	r2, #240	; 0xf0
 800511a:	0212      	lsls	r2, r2, #8
 800511c:	400a      	ands	r2, r1
 800511e:	d000      	beq.n	8005122 <USBPD_PRL_SendMessage+0x15e>
 8005120:	e103      	b.n	800532a <USBPD_PRL_SendMessage+0x366>
 8005122:	2107      	movs	r1, #7
 8005124:	e102      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 8005126:	72c2      	strb	r2, [r0, #11]
 8005128:	220f      	movs	r2, #15
 800512a:	2103      	movs	r1, #3
 800512c:	6860      	ldr	r0, [r4, #4]
 800512e:	1d80      	adds	r0, r0, #6
 8005130:	f007 f9a7 	bl	800c482 <__aeabi_memset>
 8005134:	2008      	movs	r0, #8
 8005136:	e0bf      	b.n	80052b8 <USBPD_PRL_SendMessage+0x2f4>
 8005138:	8a81      	ldrh	r1, [r0, #20]
 800513a:	0bc9      	lsrs	r1, r1, #15
 800513c:	d06f      	beq.n	800521e <USBPD_PRL_SendMessage+0x25a>
 800513e:	8b41      	ldrh	r1, [r0, #26]
 8005140:	0a89      	lsrs	r1, r1, #10
 8005142:	07c9      	lsls	r1, r1, #31
 8005144:	d462      	bmi.n	800520c <USBPD_PRL_SendMessage+0x248>
 8005146:	8c03      	ldrh	r3, [r0, #32]
 8005148:	2b1b      	cmp	r3, #27
 800514a:	d302      	bcc.n	8005152 <USBPD_PRL_SendMessage+0x18e>
 800514c:	8b41      	ldrh	r1, [r0, #26]
 800514e:	0bc9      	lsrs	r1, r1, #15
 8005150:	d153      	bne.n	80051fa <USBPD_PRL_SendMessage+0x236>
 8005152:	4950      	ldr	r1, [pc, #320]	; (8005294 <USBPD_PRL_SendMessage+0x2d0>)
 8005154:	466e      	mov	r6, sp
 8005156:	7b36      	ldrb	r6, [r6, #12]
 8005158:	00b6      	lsls	r6, r6, #2
 800515a:	1989      	adds	r1, r1, r6
 800515c:	6849      	ldr	r1, [r1, #4]
 800515e:	8b49      	ldrh	r1, [r1, #26]
 8005160:	0ace      	lsrs	r6, r1, #11
 8005162:	0736      	lsls	r6, r6, #28
 8005164:	d106      	bne.n	8005174 <USBPD_PRL_SendMessage+0x1b0>
 8005166:	26fe      	movs	r6, #254	; 0xfe
 8005168:	0236      	lsls	r6, r6, #8
 800516a:	400e      	ands	r6, r1
 800516c:	05d9      	lsls	r1, r3, #23
 800516e:	0dc9      	lsrs	r1, r1, #23
 8005170:	4331      	orrs	r1, r6
 8005172:	8341      	strh	r1, [r0, #26]
 8005174:	8a83      	ldrh	r3, [r0, #20]
 8005176:	4989      	ldr	r1, [pc, #548]	; (800539c <.text_24>)
 8005178:	4019      	ands	r1, r3
 800517a:	8281      	strh	r1, [r0, #20]
 800517c:	8b43      	ldrh	r3, [r0, #26]
 800517e:	0bdb      	lsrs	r3, r3, #15
 8005180:	d038      	beq.n	80051f4 <USBPD_PRL_SendMessage+0x230>
 8005182:	8c03      	ldrh	r3, [r0, #32]
 8005184:	1c9b      	adds	r3, r3, #2
 8005186:	105d      	asrs	r5, r3, #1
 8005188:	0fad      	lsrs	r5, r5, #30
 800518a:	18eb      	adds	r3, r5, r3
 800518c:	109b      	asrs	r3, r3, #2
 800518e:	031b      	lsls	r3, r3, #12
 8005190:	25e0      	movs	r5, #224	; 0xe0
 8005192:	01ed      	lsls	r5, r5, #7
 8005194:	401d      	ands	r5, r3
 8005196:	430d      	orrs	r5, r1
 8005198:	8285      	strh	r5, [r0, #20]
 800519a:	8c00      	ldrh	r0, [r0, #32]
 800519c:	1c81      	adds	r1, r0, #2
 800519e:	1c80      	adds	r0, r0, #2
 80051a0:	104b      	asrs	r3, r1, #1
 80051a2:	0f9b      	lsrs	r3, r3, #30
 80051a4:	1859      	adds	r1, r3, r1
 80051a6:	1089      	asrs	r1, r1, #2
 80051a8:	0089      	lsls	r1, r1, #2
 80051aa:	1a40      	subs	r0, r0, r1
 80051ac:	b2c0      	uxtb	r0, r0
 80051ae:	2800      	cmp	r0, #0
 80051b0:	d01a      	beq.n	80051e8 <USBPD_PRL_SendMessage+0x224>
 80051b2:	2500      	movs	r5, #0
 80051b4:	9000      	str	r0, [sp, #0]
 80051b6:	e005      	b.n	80051c4 <USBPD_PRL_SendMessage+0x200>
 80051b8:	9902      	ldr	r1, [sp, #8]
 80051ba:	1d09      	adds	r1, r1, #4
 80051bc:	8c1b      	ldrh	r3, [r3, #32]
 80051be:	1818      	adds	r0, r3, r0
 80051c0:	540a      	strb	r2, [r1, r0]
 80051c2:	1c6d      	adds	r5, r5, #1
 80051c4:	6863      	ldr	r3, [r4, #4]
 80051c6:	b2e8      	uxtb	r0, r5
 80051c8:	2104      	movs	r1, #4
 80051ca:	9e00      	ldr	r6, [sp, #0]
 80051cc:	1b89      	subs	r1, r1, r6
 80051ce:	4288      	cmp	r0, r1
 80051d0:	dbf2      	blt.n	80051b8 <USBPD_PRL_SendMessage+0x1f4>
 80051d2:	8a99      	ldrh	r1, [r3, #20]
 80051d4:	4871      	ldr	r0, [pc, #452]	; (800539c <.text_24>)
 80051d6:	4008      	ands	r0, r1
 80051d8:	0b09      	lsrs	r1, r1, #12
 80051da:	1c49      	adds	r1, r1, #1
 80051dc:	0309      	lsls	r1, r1, #12
 80051de:	25e0      	movs	r5, #224	; 0xe0
 80051e0:	01ed      	lsls	r5, r5, #7
 80051e2:	400d      	ands	r5, r1
 80051e4:	4305      	orrs	r5, r0
 80051e6:	829d      	strh	r5, [r3, #20]
 80051e8:	6860      	ldr	r0, [r4, #4]
 80051ea:	8a80      	ldrh	r0, [r0, #20]
 80051ec:	0440      	lsls	r0, r0, #17
 80051ee:	0f40      	lsrs	r0, r0, #29
 80051f0:	0085      	lsls	r5, r0, #2
 80051f2:	1cad      	adds	r5, r5, #2
 80051f4:	6860      	ldr	r0, [r4, #4]
 80051f6:	8402      	strh	r2, [r0, #32]
 80051f8:	e008      	b.n	800520c <USBPD_PRL_SendMessage+0x248>
 80051fa:	8a81      	ldrh	r1, [r0, #20]
 80051fc:	22e0      	movs	r2, #224	; 0xe0
 80051fe:	01d2      	lsls	r2, r2, #7
 8005200:	430a      	orrs	r2, r1
 8005202:	8282      	strh	r2, [r0, #20]
 8005204:	8c01      	ldrh	r1, [r0, #32]
 8005206:	391a      	subs	r1, #26
 8005208:	8401      	strh	r1, [r0, #32]
 800520a:	251e      	movs	r5, #30
 800520c:	6860      	ldr	r0, [r4, #4]
 800520e:	8b40      	ldrh	r0, [r0, #26]
 8005210:	9902      	ldr	r1, [sp, #8]
 8005212:	7088      	strb	r0, [r1, #2]
 8005214:	6860      	ldr	r0, [r4, #4]
 8005216:	8b40      	ldrh	r0, [r0, #26]
 8005218:	0a00      	lsrs	r0, r0, #8
 800521a:	9902      	ldr	r1, [sp, #8]
 800521c:	70c8      	strb	r0, [r1, #3]
 800521e:	6860      	ldr	r0, [r4, #4]
 8005220:	7ac2      	ldrb	r2, [r0, #11]
 8005222:	8a83      	ldrh	r3, [r0, #20]
 8005224:	4999      	ldr	r1, [pc, #612]	; (800548c <.text_29>)
 8005226:	4019      	ands	r1, r3
 8005228:	0253      	lsls	r3, r2, #9
 800522a:	22e0      	movs	r2, #224	; 0xe0
 800522c:	0112      	lsls	r2, r2, #4
 800522e:	401a      	ands	r2, r3
 8005230:	430a      	orrs	r2, r1
 8005232:	8282      	strh	r2, [r0, #20]
 8005234:	4668      	mov	r0, sp
 8005236:	7900      	ldrb	r0, [r0, #4]
 8005238:	2800      	cmp	r0, #0
 800523a:	d004      	beq.n	8005246 <USBPD_PRL_SendMessage+0x282>
 800523c:	4894      	ldr	r0, [pc, #592]	; (8005490 <.text_30>)
 800523e:	4010      	ands	r0, r2
 8005240:	9a02      	ldr	r2, [sp, #8]
 8005242:	7010      	strb	r0, [r2, #0]
 8005244:	e003      	b.n	800524e <USBPD_PRL_SendMessage+0x28a>
 8005246:	9802      	ldr	r0, [sp, #8]
 8005248:	7002      	strb	r2, [r0, #0]
 800524a:	6860      	ldr	r0, [r4, #4]
 800524c:	8a80      	ldrh	r0, [r0, #20]
 800524e:	0a00      	lsrs	r0, r0, #8
 8005250:	9902      	ldr	r1, [sp, #8]
 8005252:	7048      	strb	r0, [r1, #1]
 8005254:	480f      	ldr	r0, [pc, #60]	; (8005294 <USBPD_PRL_SendMessage+0x2d0>)
 8005256:	8005      	strh	r5, [r0, #0]
 8005258:	6860      	ldr	r0, [r4, #4]
 800525a:	2109      	movs	r1, #9
 800525c:	7101      	strb	r1, [r0, #4]
 800525e:	2102      	movs	r1, #2
 8005260:	7481      	strb	r1, [r0, #18]
 8005262:	488c      	ldr	r0, [pc, #560]	; (8005494 <.text_31>)
 8005264:	6804      	ldr	r4, [r0, #0]
 8005266:	2c00      	cmp	r4, #0
 8005268:	d007      	beq.n	800527a <USBPD_PRL_SendMessage+0x2b6>
 800526a:	b2a8      	uxth	r0, r5
 800526c:	9000      	str	r0, [sp, #0]
 800526e:	9b02      	ldr	r3, [sp, #8]
 8005270:	4668      	mov	r0, sp
 8005272:	7902      	ldrb	r2, [r0, #4]
 8005274:	7b01      	ldrb	r1, [r0, #12]
 8005276:	2002      	movs	r0, #2
 8005278:	47a0      	blx	r4
 800527a:	4668      	mov	r0, sp
 800527c:	7b00      	ldrb	r0, [r0, #12]
 800527e:	2800      	cmp	r0, #0
 8005280:	d101      	bne.n	8005286 <USBPD_PRL_SendMessage+0x2c2>
 8005282:	2001      	movs	r0, #1
 8005284:	e000      	b.n	8005288 <USBPD_PRL_SendMessage+0x2c4>
 8005286:	2003      	movs	r0, #3
 8005288:	4983      	ldr	r1, [pc, #524]	; (8005498 <.text_32>)
 800528a:	f006 f803 	bl	800b294 <USBPD_TIM_Start>
 800528e:	b2ab      	uxth	r3, r5
 8005290:	e06c      	b.n	800536c <USBPD_PRL_SendMessage+0x3a8>
 8005292:	bf00      	nop
 8005294:	200019fc 	.word	0x200019fc
 8005298:	4668      	mov	r0, sp
 800529a:	7b00      	ldrb	r0, [r0, #12]
 800529c:	2800      	cmp	r0, #0
 800529e:	d101      	bne.n	80052a4 <USBPD_PRL_SendMessage+0x2e0>
 80052a0:	2001      	movs	r0, #1
 80052a2:	e000      	b.n	80052a6 <USBPD_PRL_SendMessage+0x2e2>
 80052a4:	2003      	movs	r0, #3
 80052a6:	f006 f824 	bl	800b2f2 <USBPD_TIM_IsExpired>
 80052aa:	2801      	cmp	r0, #1
 80052ac:	d003      	beq.n	80052b6 <USBPD_PRL_SendMessage+0x2f2>
 80052ae:	6860      	ldr	r0, [r4, #4]
 80052b0:	7b80      	ldrb	r0, [r0, #14]
 80052b2:	2801      	cmp	r0, #1
 80052b4:	d166      	bne.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 80052b6:	200c      	movs	r0, #12
 80052b8:	6861      	ldr	r1, [r4, #4]
 80052ba:	7108      	strb	r0, [r1, #4]
 80052bc:	e062      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 80052be:	7ac1      	ldrb	r1, [r0, #11]
 80052c0:	2207      	movs	r2, #7
 80052c2:	8b03      	ldrh	r3, [r0, #24]
 80052c4:	0a5d      	lsrs	r5, r3, #9
 80052c6:	2307      	movs	r3, #7
 80052c8:	402b      	ands	r3, r5
 80052ca:	4299      	cmp	r1, r3
 80052cc:	d1f3      	bne.n	80052b6 <USBPD_PRL_SendMessage+0x2f2>
 80052ce:	7e03      	ldrb	r3, [r0, #24]
 80052d0:	06db      	lsls	r3, r3, #27
 80052d2:	0edb      	lsrs	r3, r3, #27
 80052d4:	2b01      	cmp	r3, #1
 80052d6:	d1ee      	bne.n	80052b6 <USBPD_PRL_SendMessage+0x2f2>
 80052d8:	1c49      	adds	r1, r1, #1
 80052da:	400a      	ands	r2, r1
 80052dc:	72c2      	strb	r2, [r0, #11]
 80052de:	6860      	ldr	r0, [r4, #4]
 80052e0:	7106      	strb	r6, [r0, #4]
 80052e2:	e00d      	b.n	8005300 <USBPD_PRL_SendMessage+0x33c>
 80052e4:	7ac1      	ldrb	r1, [r0, #11]
 80052e6:	1c49      	adds	r1, r1, #1
 80052e8:	0749      	lsls	r1, r1, #29
 80052ea:	0f49      	lsrs	r1, r1, #29
 80052ec:	72c1      	strb	r1, [r0, #11]
 80052ee:	6860      	ldr	r0, [r4, #4]
 80052f0:	7106      	strb	r6, [r0, #4]
 80052f2:	8b42      	ldrh	r2, [r0, #26]
 80052f4:	4969      	ldr	r1, [pc, #420]	; (800549c <.text_33>)
 80052f6:	4011      	ands	r1, r2
 80052f8:	8341      	strh	r1, [r0, #26]
 80052fa:	4a69      	ldr	r2, [pc, #420]	; (80054a0 <.text_34>)
 80052fc:	400a      	ands	r2, r1
 80052fe:	8342      	strh	r2, [r0, #26]
 8005300:	2705      	movs	r7, #5
 8005302:	e03f      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005304:	7b01      	ldrb	r1, [r0, #12]
 8005306:	1c49      	adds	r1, r1, #1
 8005308:	7301      	strb	r1, [r0, #12]
 800530a:	6860      	ldr	r0, [r4, #4]
 800530c:	8a81      	ldrh	r1, [r0, #20]
 800530e:	2203      	movs	r2, #3
 8005310:	098b      	lsrs	r3, r1, #6
 8005312:	2403      	movs	r4, #3
 8005314:	401c      	ands	r4, r3
 8005316:	2c01      	cmp	r4, #1
 8005318:	d000      	beq.n	800531c <USBPD_PRL_SendMessage+0x358>
 800531a:	2202      	movs	r2, #2
 800531c:	7b03      	ldrb	r3, [r0, #12]
 800531e:	429a      	cmp	r2, r3
 8005320:	d306      	bcc.n	8005330 <USBPD_PRL_SendMessage+0x36c>
 8005322:	0bc9      	lsrs	r1, r1, #15
 8005324:	d001      	beq.n	800532a <USBPD_PRL_SendMessage+0x366>
 8005326:	210f      	movs	r1, #15
 8005328:	e000      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 800532a:	2108      	movs	r1, #8
 800532c:	7101      	strb	r1, [r0, #4]
 800532e:	e029      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005330:	7106      	strb	r6, [r0, #4]
 8005332:	2707      	movs	r7, #7
 8005334:	e026      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005336:	2109      	movs	r1, #9
 8005338:	7101      	strb	r1, [r0, #4]
 800533a:	2102      	movs	r1, #2
 800533c:	7481      	strb	r1, [r0, #18]
 800533e:	4668      	mov	r0, sp
 8005340:	7b00      	ldrb	r0, [r0, #12]
 8005342:	2800      	cmp	r0, #0
 8005344:	d101      	bne.n	800534a <USBPD_PRL_SendMessage+0x386>
 8005346:	2001      	movs	r0, #1
 8005348:	e000      	b.n	800534c <USBPD_PRL_SendMessage+0x388>
 800534a:	2003      	movs	r0, #3
 800534c:	4955      	ldr	r1, [pc, #340]	; (80054a4 <.text_35>)
 800534e:	f005 ffa1 	bl	800b294 <USBPD_TIM_Start>
 8005352:	4850      	ldr	r0, [pc, #320]	; (8005494 <.text_31>)
 8005354:	6804      	ldr	r4, [r0, #0]
 8005356:	2c00      	cmp	r4, #0
 8005358:	d006      	beq.n	8005368 <USBPD_PRL_SendMessage+0x3a4>
 800535a:	9500      	str	r5, [sp, #0]
 800535c:	9b02      	ldr	r3, [sp, #8]
 800535e:	4668      	mov	r0, sp
 8005360:	7902      	ldrb	r2, [r0, #4]
 8005362:	7b01      	ldrb	r1, [r0, #12]
 8005364:	2002      	movs	r0, #2
 8005366:	47a0      	blx	r4
 8005368:	484f      	ldr	r0, [pc, #316]	; (80054a8 <.text_36>)
 800536a:	8803      	ldrh	r3, [r0, #0]
 800536c:	9a02      	ldr	r2, [sp, #8]
 800536e:	4668      	mov	r0, sp
 8005370:	7901      	ldrb	r1, [r0, #4]
 8005372:	7b00      	ldrb	r0, [r0, #12]
 8005374:	f004 f9f8 	bl	8009768 <USBPD_PHY_SendMessage>
 8005378:	e004      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 800537a:	7106      	strb	r6, [r0, #4]
 800537c:	2706      	movs	r7, #6
 800537e:	e001      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005380:	7106      	strb	r6, [r0, #4]
 8005382:	2710      	movs	r7, #16
 8005384:	0038      	movs	r0, r7
 8005386:	b005      	add	sp, #20
 8005388:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800538a <USBPD_PRL_ResetRequestReset>:
 800538a:	4947      	ldr	r1, [pc, #284]	; (80054a8 <.text_36>)
 800538c:	0080      	lsls	r0, r0, #2
 800538e:	1808      	adds	r0, r1, r0
 8005390:	6840      	ldr	r0, [r0, #4]
 8005392:	2100      	movs	r1, #0
 8005394:	7141      	strb	r1, [r0, #5]
 8005396:	4770      	bx	lr

08005398 <.text_23>:
 8005398:	0000ffe0 	.word	0x0000ffe0

0800539c <.text_24>:
 800539c:	00008fff 	.word	0x00008fff

080053a0 <USBPD_PRL_ResetRequestProcess>:
 80053a0:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 80053a2:	b082      	sub	sp, #8
 80053a4:	000d      	movs	r5, r1
 80053a6:	2403      	movs	r4, #3
 80053a8:	483f      	ldr	r0, [pc, #252]	; (80054a8 <.text_36>)
 80053aa:	4669      	mov	r1, sp
 80053ac:	7a09      	ldrb	r1, [r1, #8]
 80053ae:	0089      	lsls	r1, r1, #2
 80053b0:	1846      	adds	r6, r0, r1
 80053b2:	6871      	ldr	r1, [r6, #4]
 80053b4:	2000      	movs	r0, #0
 80053b6:	2202      	movs	r2, #2
 80053b8:	794b      	ldrb	r3, [r1, #5]
 80053ba:	2b00      	cmp	r3, #0
 80053bc:	d003      	beq.n	80053c6 <USBPD_PRL_ResetRequestProcess+0x26>
 80053be:	2b02      	cmp	r3, #2
 80053c0:	d030      	beq.n	8005424 <USBPD_PRL_ResetRequestProcess+0x84>
 80053c2:	d323      	bcc.n	800540c <USBPD_PRL_ResetRequestProcess+0x6c>
 80053c4:	e031      	b.n	800542a <USBPD_PRL_ResetRequestProcess+0x8a>
 80053c6:	7348      	strb	r0, [r1, #13]
 80053c8:	6871      	ldr	r1, [r6, #4]
 80053ca:	72c8      	strb	r0, [r1, #11]
 80053cc:	220f      	movs	r2, #15
 80053ce:	2103      	movs	r1, #3
 80053d0:	6870      	ldr	r0, [r6, #4]
 80053d2:	1d80      	adds	r0, r0, #6
 80053d4:	f007 f855 	bl	800c482 <__aeabi_memset>
 80053d8:	2006      	movs	r0, #6
 80053da:	6871      	ldr	r1, [r6, #4]
 80053dc:	7108      	strb	r0, [r1, #4]
 80053de:	482d      	ldr	r0, [pc, #180]	; (8005494 <.text_31>)
 80053e0:	6807      	ldr	r7, [r0, #0]
 80053e2:	2f00      	cmp	r7, #0
 80053e4:	d007      	beq.n	80053f6 <USBPD_PRL_ResetRequestProcess+0x56>
 80053e6:	2000      	movs	r0, #0
 80053e8:	9000      	str	r0, [sp, #0]
 80053ea:	2300      	movs	r3, #0
 80053ec:	2205      	movs	r2, #5
 80053ee:	4668      	mov	r0, sp
 80053f0:	7a01      	ldrb	r1, [r0, #8]
 80053f2:	2002      	movs	r0, #2
 80053f4:	47b8      	blx	r7
 80053f6:	0029      	movs	r1, r5
 80053f8:	4668      	mov	r0, sp
 80053fa:	7a00      	ldrb	r0, [r0, #8]
 80053fc:	f004 f9d4 	bl	80097a8 <USBPD_PHY_ResetRequest>
 8005400:	6870      	ldr	r0, [r6, #4]
 8005402:	2101      	movs	r1, #1
 8005404:	7141      	strb	r1, [r0, #5]
 8005406:	2105      	movs	r1, #5
 8005408:	7281      	strb	r1, [r0, #10]
 800540a:	e010      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 800540c:	7b4b      	ldrb	r3, [r1, #13]
 800540e:	2b01      	cmp	r3, #1
 8005410:	d102      	bne.n	8005418 <USBPD_PRL_ResetRequestProcess+0x78>
 8005412:	714a      	strb	r2, [r1, #5]
 8005414:	7348      	strb	r0, [r1, #13]
 8005416:	e00a      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 8005418:	7a8a      	ldrb	r2, [r1, #10]
 800541a:	2a00      	cmp	r2, #0
 800541c:	d107      	bne.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 800541e:	7148      	strb	r0, [r1, #5]
 8005420:	2404      	movs	r4, #4
 8005422:	e004      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 8005424:	7148      	strb	r0, [r1, #5]
 8005426:	2400      	movs	r4, #0
 8005428:	e001      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 800542a:	7148      	strb	r0, [r1, #5]
 800542c:	2402      	movs	r4, #2
 800542e:	0020      	movs	r0, r4
 8005430:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08005432 <USBDPD_PRL_BistCarrierEyeMode>:
 8005432:	b580      	push	{r7, lr}
 8005434:	2905      	cmp	r1, #5
 8005436:	d102      	bne.n	800543e <USBDPD_PRL_BistCarrierEyeMode+0xc>
 8005438:	f004 f882 	bl	8009540 <USBPD_PHY_Send_BIST_Pattern>
 800543c:	bd02      	pop	{r1, pc}
 800543e:	2010      	movs	r0, #16
 8005440:	bd02      	pop	{r1, pc}

08005442 <USBDPD_PRL_BistCarrierEyeModeExit>:
 8005442:	b580      	push	{r7, lr}
 8005444:	2905      	cmp	r1, #5
 8005446:	d103      	bne.n	8005450 <USBDPD_PRL_BistCarrierEyeModeExit+0xe>
 8005448:	2107      	movs	r1, #7
 800544a:	f004 f887 	bl	800955c <USBPD_PHY_ExitTransmit>
 800544e:	bd02      	pop	{r1, pc}
 8005450:	2010      	movs	r0, #16
 8005452:	bd02      	pop	{r1, pc}

08005454 <USBPD_PRL_Reset>:
 8005454:	b538      	push	{r3, r4, r5, lr}
 8005456:	4914      	ldr	r1, [pc, #80]	; (80054a8 <.text_36>)
 8005458:	0080      	lsls	r0, r0, #2
 800545a:	180c      	adds	r4, r1, r0
 800545c:	6860      	ldr	r0, [r4, #4]
 800545e:	2500      	movs	r5, #0
 8005460:	7105      	strb	r5, [r0, #4]
 8005462:	7145      	strb	r5, [r0, #5]
 8005464:	7285      	strb	r5, [r0, #10]
 8005466:	6860      	ldr	r0, [r4, #4]
 8005468:	72c5      	strb	r5, [r0, #11]
 800546a:	220f      	movs	r2, #15
 800546c:	2103      	movs	r1, #3
 800546e:	6860      	ldr	r0, [r4, #4]
 8005470:	1d80      	adds	r0, r0, #6
 8005472:	f007 f806 	bl	800c482 <__aeabi_memset>
 8005476:	6860      	ldr	r0, [r4, #4]
 8005478:	7305      	strb	r5, [r0, #12]
 800547a:	6860      	ldr	r0, [r4, #4]
 800547c:	7345      	strb	r5, [r0, #13]
 800547e:	6860      	ldr	r0, [r4, #4]
 8005480:	7385      	strb	r5, [r0, #14]
 8005482:	6860      	ldr	r0, [r4, #4]
 8005484:	2123      	movs	r1, #35	; 0x23
 8005486:	5445      	strb	r5, [r0, r1]
 8005488:	bd31      	pop	{r0, r4, r5, pc}
	...

0800548c <.text_29>:
 800548c:	0000f1ff 	.word	0x0000f1ff

08005490 <.text_30>:
 8005490:	0000fedf 	.word	0x0000fedf

08005494 <.text_31>:
 8005494:	200019f4 	.word	0x200019f4

08005498 <.text_32>:
 8005498:	00002710 	.word	0x00002710

0800549c <.text_33>:
 800549c:	000087ff 	.word	0x000087ff

080054a0 <.text_34>:
 80054a0:	0000fbff 	.word	0x0000fbff

080054a4 <.text_35>:
 80054a4:	000009c4 	.word	0x000009c4

080054a8 <.text_36>:
 80054a8:	200019fc 	.word	0x200019fc

080054ac <USBPD_PRL_DeInit>:
 80054ac:	4770      	bx	lr

080054ae <PRL_Received>:
 80054ae:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
 80054b0:	b083      	sub	sp, #12
 80054b2:	48c4      	ldr	r0, [pc, #784]	; (80057c4 <.text_39>)
 80054b4:	8800      	ldrh	r0, [r0, #0]
 80054b6:	4669      	mov	r1, sp
 80054b8:	80c8      	strh	r0, [r1, #6]
 80054ba:	48c3      	ldr	r0, [pc, #780]	; (80057c8 <.text_40>)
 80054bc:	7b09      	ldrb	r1, [r1, #12]
 80054be:	0089      	lsls	r1, r1, #2
 80054c0:	1846      	adds	r6, r0, r1
 80054c2:	6870      	ldr	r0, [r6, #4]
 80054c4:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80054c6:	780a      	ldrb	r2, [r1, #0]
 80054c8:	7849      	ldrb	r1, [r1, #1]
 80054ca:	0209      	lsls	r1, r1, #8
 80054cc:	1851      	adds	r1, r2, r1
 80054ce:	466a      	mov	r2, sp
 80054d0:	8091      	strh	r1, [r2, #4]
 80054d2:	4fbe      	ldr	r7, [pc, #760]	; (80057cc <.text_41>)
 80054d4:	683c      	ldr	r4, [r7, #0]
 80054d6:	4669      	mov	r1, sp
 80054d8:	8889      	ldrh	r1, [r1, #4]
 80054da:	0bc9      	lsrs	r1, r1, #15
 80054dc:	d00b      	beq.n	80054f6 <PRL_Received+0x48>
 80054de:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80054e0:	7898      	ldrb	r0, [r3, #2]
 80054e2:	78d9      	ldrb	r1, [r3, #3]
 80054e4:	0209      	lsls	r1, r1, #8
 80054e6:	1845      	adds	r5, r0, r1
 80054e8:	2c00      	cmp	r4, #0
 80054ea:	d013      	beq.n	8005514 <PRL_Received+0x66>
 80054ec:	05e8      	lsls	r0, r5, #23
 80054ee:	0dc0      	lsrs	r0, r0, #23
 80054f0:	1d00      	adds	r0, r0, #4
 80054f2:	9000      	str	r0, [sp, #0]
 80054f4:	e009      	b.n	800550a <PRL_Received+0x5c>
 80054f6:	2c00      	cmp	r4, #0
 80054f8:	d00c      	beq.n	8005514 <PRL_Received+0x66>
 80054fa:	4669      	mov	r1, sp
 80054fc:	8889      	ldrh	r1, [r1, #4]
 80054fe:	0449      	lsls	r1, r1, #17
 8005500:	0f49      	lsrs	r1, r1, #29
 8005502:	0089      	lsls	r1, r1, #2
 8005504:	1c89      	adds	r1, r1, #2
 8005506:	9100      	str	r1, [sp, #0]
 8005508:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800550a:	4668      	mov	r0, sp
 800550c:	7c02      	ldrb	r2, [r0, #16]
 800550e:	7b01      	ldrb	r1, [r0, #12]
 8005510:	2001      	movs	r0, #1
 8005512:	47a0      	blx	r4
 8005514:	6870      	ldr	r0, [r6, #4]
 8005516:	49c7      	ldr	r1, [pc, #796]	; (8005834 <.text_45>)
 8005518:	466a      	mov	r2, sp
 800551a:	8892      	ldrh	r2, [r2, #4]
 800551c:	400a      	ands	r2, r1
 800551e:	2a01      	cmp	r2, #1
 8005520:	d105      	bne.n	800552e <PRL_Received+0x80>
 8005522:	210a      	movs	r1, #10
 8005524:	7101      	strb	r1, [r0, #4]
 8005526:	4669      	mov	r1, sp
 8005528:	8889      	ldrh	r1, [r1, #4]
 800552a:	8301      	strh	r1, [r0, #24]
 800552c:	e13b      	b.n	80057a6 <PRL_Received+0x2f8>
 800552e:	466a      	mov	r2, sp
 8005530:	7c12      	ldrb	r2, [r2, #16]
 8005532:	7242      	strb	r2, [r0, #9]
 8005534:	2400      	movs	r4, #0
 8005536:	466a      	mov	r2, sp
 8005538:	8892      	ldrh	r2, [r2, #4]
 800553a:	4011      	ands	r1, r2
 800553c:	290d      	cmp	r1, #13
 800553e:	d108      	bne.n	8005552 <PRL_Received+0xa4>
 8005540:	72c4      	strb	r4, [r0, #11]
 8005542:	220f      	movs	r2, #15
 8005544:	2103      	movs	r1, #3
 8005546:	6870      	ldr	r0, [r6, #4]
 8005548:	1d80      	adds	r0, r0, #6
 800554a:	f006 ff9a 	bl	800c482 <__aeabi_memset>
 800554e:	6871      	ldr	r1, [r6, #4]
 8005550:	710c      	strb	r4, [r1, #4]
 8005552:	4668      	mov	r0, sp
 8005554:	88c0      	ldrh	r0, [r0, #6]
 8005556:	49bd      	ldr	r1, [pc, #756]	; (800584c <.text_47>)
 8005558:	4001      	ands	r1, r0
 800555a:	2001      	movs	r0, #1
 800555c:	4308      	orrs	r0, r1
 800555e:	4669      	mov	r1, sp
 8005560:	4abb      	ldr	r2, [pc, #748]	; (8005850 <.text_48>)
 8005562:	4002      	ands	r2, r0
 8005564:	800a      	strh	r2, [r1, #0]
 8005566:	4668      	mov	r0, sp
 8005568:	7c00      	ldrb	r0, [r0, #16]
 800556a:	2800      	cmp	r0, #0
 800556c:	d10e      	bne.n	800558c <PRL_Received+0xde>
 800556e:	6870      	ldr	r0, [r6, #4]
 8005570:	8a82      	ldrh	r2, [r0, #20]
 8005572:	2101      	movs	r1, #1
 8005574:	0953      	lsrs	r3, r2, #5
 8005576:	2001      	movs	r0, #1
 8005578:	4018      	ands	r0, r3
 800557a:	0a12      	lsrs	r2, r2, #8
 800557c:	4011      	ands	r1, r2
 800557e:	466a      	mov	r2, sp
 8005580:	8812      	ldrh	r2, [r2, #0]
 8005582:	0140      	lsls	r0, r0, #5
 8005584:	4310      	orrs	r0, r2
 8005586:	0209      	lsls	r1, r1, #8
 8005588:	4301      	orrs	r1, r0
 800558a:	e000      	b.n	800558e <PRL_Received+0xe0>
 800558c:	4611      	mov	r1, r2
 800558e:	48c2      	ldr	r0, [pc, #776]	; (8005898 <.text_50>)
 8005590:	4008      	ands	r0, r1
 8005592:	4669      	mov	r1, sp
 8005594:	8889      	ldrh	r1, [r1, #4]
 8005596:	0609      	lsls	r1, r1, #24
 8005598:	0f89      	lsrs	r1, r1, #30
 800559a:	2902      	cmp	r1, #2
 800559c:	da02      	bge.n	80055a4 <PRL_Received+0xf6>
 800559e:	0001      	movs	r1, r0
 80055a0:	2040      	movs	r0, #64	; 0x40
 80055a2:	4308      	orrs	r0, r1
 80055a4:	05c1      	lsls	r1, r0, #23
 80055a6:	0dc9      	lsrs	r1, r1, #23
 80055a8:	4668      	mov	r0, sp
 80055aa:	8882      	ldrh	r2, [r0, #4]
 80055ac:	20e0      	movs	r0, #224	; 0xe0
 80055ae:	0100      	lsls	r0, r0, #4
 80055b0:	4010      	ands	r0, r2
 80055b2:	4308      	orrs	r0, r1
 80055b4:	6872      	ldr	r2, [r6, #4]
 80055b6:	7590      	strb	r0, [r2, #22]
 80055b8:	0a00      	lsrs	r0, r0, #8
 80055ba:	6871      	ldr	r1, [r6, #4]
 80055bc:	75c8      	strb	r0, [r1, #23]
 80055be:	6870      	ldr	r0, [r6, #4]
 80055c0:	2101      	movs	r1, #1
 80055c2:	7481      	strb	r1, [r0, #18]
 80055c4:	683f      	ldr	r7, [r7, #0]
 80055c6:	2f00      	cmp	r7, #0
 80055c8:	d008      	beq.n	80055dc <PRL_Received+0x12e>
 80055ca:	2102      	movs	r1, #2
 80055cc:	9100      	str	r1, [sp, #0]
 80055ce:	0003      	movs	r3, r0
 80055d0:	3316      	adds	r3, #22
 80055d2:	4668      	mov	r0, sp
 80055d4:	7c02      	ldrb	r2, [r0, #16]
 80055d6:	7b01      	ldrb	r1, [r0, #12]
 80055d8:	2002      	movs	r0, #2
 80055da:	47b8      	blx	r7
 80055dc:	2302      	movs	r3, #2
 80055de:	6872      	ldr	r2, [r6, #4]
 80055e0:	3216      	adds	r2, #22
 80055e2:	4668      	mov	r0, sp
 80055e4:	7c01      	ldrb	r1, [r0, #16]
 80055e6:	7b00      	ldrb	r0, [r0, #12]
 80055e8:	f004 f8be 	bl	8009768 <USBPD_PHY_SendMessage>
 80055ec:	2800      	cmp	r0, #0
 80055ee:	d19d      	bne.n	800552c <PRL_Received+0x7e>
 80055f0:	6870      	ldr	r0, [r6, #4]
 80055f2:	1d81      	adds	r1, r0, #6
 80055f4:	466a      	mov	r2, sp
 80055f6:	7c12      	ldrb	r2, [r2, #16]
 80055f8:	1889      	adds	r1, r1, r2
 80055fa:	9100      	str	r1, [sp, #0]
 80055fc:	4669      	mov	r1, sp
 80055fe:	8889      	ldrh	r1, [r1, #4]
 8005600:	0a49      	lsrs	r1, r1, #9
 8005602:	2207      	movs	r2, #7
 8005604:	9b00      	ldr	r3, [sp, #0]
 8005606:	781b      	ldrb	r3, [r3, #0]
 8005608:	2707      	movs	r7, #7
 800560a:	400f      	ands	r7, r1
 800560c:	42bb      	cmp	r3, r7
 800560e:	d100      	bne.n	8005612 <PRL_Received+0x164>
 8005610:	e0c8      	b.n	80057a4 <PRL_Received+0x2f6>
 8005612:	2007      	movs	r0, #7
 8005614:	4008      	ands	r0, r1
 8005616:	9900      	ldr	r1, [sp, #0]
 8005618:	7008      	strb	r0, [r1, #0]
 800561a:	6873      	ldr	r3, [r6, #4]
 800561c:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800561e:	7881      	ldrb	r1, [r0, #2]
 8005620:	78c7      	ldrb	r7, [r0, #3]
 8005622:	023f      	lsls	r7, r7, #8
 8005624:	19c9      	adds	r1, r1, r7
 8005626:	7907      	ldrb	r7, [r0, #4]
 8005628:	043f      	lsls	r7, r7, #16
 800562a:	19c9      	adds	r1, r1, r7
 800562c:	7940      	ldrb	r0, [r0, #5]
 800562e:	0600      	lsls	r0, r0, #24
 8005630:	1808      	adds	r0, r1, r0
 8005632:	4669      	mov	r1, sp
 8005634:	8889      	ldrh	r1, [r1, #4]
 8005636:	0b09      	lsrs	r1, r1, #12
 8005638:	4211      	tst	r1, r2
 800563a:	d00f      	beq.n	800565c <PRL_Received+0x1ae>
 800563c:	4669      	mov	r1, sp
 800563e:	8889      	ldrh	r1, [r1, #4]
 8005640:	06c9      	lsls	r1, r1, #27
 8005642:	0ec9      	lsrs	r1, r1, #27
 8005644:	2903      	cmp	r1, #3
 8005646:	d109      	bne.n	800565c <PRL_Received+0x1ae>
 8005648:	0f00      	lsrs	r0, r0, #28
 800564a:	2808      	cmp	r0, #8
 800564c:	d001      	beq.n	8005652 <PRL_Received+0x1a4>
 800564e:	2800      	cmp	r0, #0
 8005650:	d104      	bne.n	800565c <PRL_Received+0x1ae>
 8005652:	aa01      	add	r2, sp, #4
 8005654:	4668      	mov	r0, sp
 8005656:	7c01      	ldrb	r1, [r0, #16]
 8005658:	7b00      	ldrb	r0, [r0, #12]
 800565a:	e09f      	b.n	800579c <PRL_Received+0x2ee>
 800565c:	4668      	mov	r0, sp
 800565e:	8880      	ldrh	r0, [r0, #4]
 8005660:	83d8      	strh	r0, [r3, #30]
 8005662:	4668      	mov	r0, sp
 8005664:	8880      	ldrh	r0, [r0, #4]
 8005666:	0bc0      	lsrs	r0, r0, #15
 8005668:	d031      	beq.n	80056ce <PRL_Received+0x220>
 800566a:	0428      	lsls	r0, r5, #16
 800566c:	0fc0      	lsrs	r0, r0, #31
 800566e:	d02e      	beq.n	80056ce <PRL_Received+0x220>
 8005670:	839d      	strh	r5, [r3, #28]
 8005672:	200f      	movs	r0, #15
 8005674:	4669      	mov	r1, sp
 8005676:	8889      	ldrh	r1, [r1, #4]
 8005678:	0b09      	lsrs	r1, r1, #12
 800567a:	400a      	ands	r2, r1
 800567c:	21f8      	movs	r1, #248	; 0xf8
 800567e:	01c9      	lsls	r1, r1, #7
 8005680:	4029      	ands	r1, r5
 8005682:	d138      	bne.n	80056f6 <PRL_Received+0x248>
 8005684:	2a06      	cmp	r2, #6
 8005686:	dd03      	ble.n	8005690 <PRL_Received+0x1e2>
 8005688:	05e9      	lsls	r1, r5, #23
 800568a:	0dc9      	lsrs	r1, r1, #23
 800568c:	291a      	cmp	r1, #26
 800568e:	d821      	bhi.n	80056d4 <PRL_Received+0x226>
 8005690:	2100      	movs	r1, #0
 8005692:	042a      	lsls	r2, r5, #16
 8005694:	0ed2      	lsrs	r2, r2, #27
 8005696:	4010      	ands	r0, r2
 8005698:	221a      	movs	r2, #26
 800569a:	4342      	muls	r2, r0
 800569c:	2307      	movs	r3, #7
 800569e:	e007      	b.n	80056b0 <PRL_Received+0x202>
 80056a0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80056a2:	1d00      	adds	r0, r0, #4
 80056a4:	5c40      	ldrb	r0, [r0, r1]
 80056a6:	6aa4      	ldr	r4, [r4, #40]	; 0x28
 80056a8:	188f      	adds	r7, r1, r2
 80056aa:	55e0      	strb	r0, [r4, r7]
 80056ac:	1c49      	adds	r1, r1, #1
 80056ae:	b289      	uxth	r1, r1
 80056b0:	4668      	mov	r0, sp
 80056b2:	8880      	ldrh	r0, [r0, #4]
 80056b4:	0b00      	lsrs	r0, r0, #12
 80056b6:	4018      	ands	r0, r3
 80056b8:	0080      	lsls	r0, r0, #2
 80056ba:	1e80      	subs	r0, r0, #2
 80056bc:	6874      	ldr	r4, [r6, #4]
 80056be:	4281      	cmp	r1, r0
 80056c0:	dbee      	blt.n	80056a0 <PRL_Received+0x1f2>
 80056c2:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80056c4:	05e9      	lsls	r1, r5, #23
 80056c6:	0dc9      	lsrs	r1, r1, #23
 80056c8:	4288      	cmp	r0, r1
 80056ca:	da01      	bge.n	80056d0 <PRL_Received+0x222>
 80056cc:	8010      	strh	r0, [r2, #0]
 80056ce:	e060      	b.n	8005792 <PRL_Received+0x2e4>
 80056d0:	8011      	strh	r1, [r2, #0]
 80056d2:	e05e      	b.n	8005792 <PRL_Received+0x2e4>
 80056d4:	2001      	movs	r0, #1
 80056d6:	2123      	movs	r1, #35	; 0x23
 80056d8:	5458      	strb	r0, [r3, r1]
 80056da:	6870      	ldr	r0, [r6, #4]
 80056dc:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80056de:	1d09      	adds	r1, r1, #4
 80056e0:	5d09      	ldrb	r1, [r1, r4]
 80056e2:	6a80      	ldr	r0, [r0, #40]	; 0x28
 80056e4:	5501      	strb	r1, [r0, r4]
 80056e6:	1c64      	adds	r4, r4, #1
 80056e8:	2c1a      	cmp	r4, #26
 80056ea:	d3f6      	bcc.n	80056da <PRL_Received+0x22c>
 80056ec:	201a      	movs	r0, #26
 80056ee:	6871      	ldr	r1, [r6, #4]
 80056f0:	6a49      	ldr	r1, [r1, #36]	; 0x24
 80056f2:	8008      	strh	r0, [r1, #0]
 80056f4:	e04d      	b.n	8005792 <PRL_Received+0x2e4>
 80056f6:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80056f8:	8809      	ldrh	r1, [r1, #0]
 80056fa:	0092      	lsls	r2, r2, #2
 80056fc:	188a      	adds	r2, r1, r2
 80056fe:	1e92      	subs	r2, r2, #2
 8005700:	27ff      	movs	r7, #255	; 0xff
 8005702:	1dbf      	adds	r7, r7, #6
 8005704:	311a      	adds	r1, #26
 8005706:	42b9      	cmp	r1, r7
 8005708:	d21e      	bcs.n	8005748 <PRL_Received+0x29a>
 800570a:	05e9      	lsls	r1, r5, #23
 800570c:	0dc9      	lsrs	r1, r1, #23
 800570e:	428a      	cmp	r2, r1
 8005710:	da1a      	bge.n	8005748 <PRL_Received+0x29a>
 8005712:	2101      	movs	r1, #1
 8005714:	2223      	movs	r2, #35	; 0x23
 8005716:	5499      	strb	r1, [r3, r2]
 8005718:	0429      	lsls	r1, r5, #16
 800571a:	0ec9      	lsrs	r1, r1, #27
 800571c:	4008      	ands	r0, r1
 800571e:	211a      	movs	r1, #26
 8005720:	4341      	muls	r1, r0
 8005722:	2007      	movs	r0, #7
 8005724:	466a      	mov	r2, sp
 8005726:	8892      	ldrh	r2, [r2, #4]
 8005728:	0b12      	lsrs	r2, r2, #12
 800572a:	4002      	ands	r2, r0
 800572c:	0092      	lsls	r2, r2, #2
 800572e:	1e92      	subs	r2, r2, #2
 8005730:	4294      	cmp	r4, r2
 8005732:	da3a      	bge.n	80057aa <PRL_Received+0x2fc>
 8005734:	6872      	ldr	r2, [r6, #4]
 8005736:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8005738:	1d1b      	adds	r3, r3, #4
 800573a:	5d1b      	ldrb	r3, [r3, r4]
 800573c:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800573e:	1865      	adds	r5, r4, r1
 8005740:	5553      	strb	r3, [r2, r5]
 8005742:	1c64      	adds	r4, r4, #1
 8005744:	b2a4      	uxth	r4, r4
 8005746:	e7ed      	b.n	8005724 <PRL_Received+0x276>
 8005748:	42ba      	cmp	r2, r7
 800574a:	d21e      	bcs.n	800578a <PRL_Received+0x2dc>
 800574c:	05e9      	lsls	r1, r5, #23
 800574e:	0dc9      	lsrs	r1, r1, #23
 8005750:	428a      	cmp	r2, r1
 8005752:	db1a      	blt.n	800578a <PRL_Received+0x2dc>
 8005754:	2101      	movs	r1, #1
 8005756:	2223      	movs	r2, #35	; 0x23
 8005758:	5499      	strb	r1, [r3, r2]
 800575a:	0429      	lsls	r1, r5, #16
 800575c:	0ec9      	lsrs	r1, r1, #27
 800575e:	4008      	ands	r0, r1
 8005760:	211a      	movs	r1, #26
 8005762:	4341      	muls	r1, r0
 8005764:	2007      	movs	r0, #7
 8005766:	466a      	mov	r2, sp
 8005768:	8892      	ldrh	r2, [r2, #4]
 800576a:	0b12      	lsrs	r2, r2, #12
 800576c:	4002      	ands	r2, r0
 800576e:	0092      	lsls	r2, r2, #2
 8005770:	1e92      	subs	r2, r2, #2
 8005772:	4294      	cmp	r4, r2
 8005774:	da19      	bge.n	80057aa <PRL_Received+0x2fc>
 8005776:	6872      	ldr	r2, [r6, #4]
 8005778:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 800577a:	1d1b      	adds	r3, r3, #4
 800577c:	5d1b      	ldrb	r3, [r3, r4]
 800577e:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8005780:	1865      	adds	r5, r4, r1
 8005782:	5553      	strb	r3, [r2, r5]
 8005784:	1c64      	adds	r4, r4, #1
 8005786:	b2a4      	uxth	r4, r4
 8005788:	e7ed      	b.n	8005766 <PRL_Received+0x2b8>
 800578a:	2123      	movs	r1, #35	; 0x23
 800578c:	545c      	strb	r4, [r3, r1]
 800578e:	6870      	ldr	r0, [r6, #4]
 8005790:	7104      	strb	r4, [r0, #4]
 8005792:	aa01      	add	r2, sp, #4
 8005794:	4668      	mov	r0, sp
 8005796:	7c01      	ldrb	r1, [r0, #16]
 8005798:	7b00      	ldrb	r0, [r0, #12]
 800579a:	6873      	ldr	r3, [r6, #4]
 800579c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800579e:	681b      	ldr	r3, [r3, #0]
 80057a0:	4798      	blx	r3
 80057a2:	e000      	b.n	80057a6 <PRL_Received+0x2f8>
 80057a4:	7484      	strb	r4, [r0, #18]
 80057a6:	b005      	add	sp, #20
 80057a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80057aa:	6870      	ldr	r0, [r6, #4]
 80057ac:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80057ae:	8801      	ldrh	r1, [r0, #0]
 80057b0:	466a      	mov	r2, sp
 80057b2:	8892      	ldrh	r2, [r2, #4]
 80057b4:	0a92      	lsrs	r2, r2, #10
 80057b6:	231c      	movs	r3, #28
 80057b8:	4013      	ands	r3, r2
 80057ba:	1e9a      	subs	r2, r3, #2
 80057bc:	1889      	adds	r1, r1, r2
 80057be:	8001      	strh	r1, [r0, #0]
 80057c0:	e7e7      	b.n	8005792 <PRL_Received+0x2e4>
	...

080057c4 <.text_39>:
 80057c4:	0800c7d0 	.word	0x0800c7d0

080057c8 <.text_40>:
 80057c8:	200019fc 	.word	0x200019fc

080057cc <.text_41>:
 80057cc:	200019f4 	.word	0x200019f4

080057d0 <PRL_ResetIndicate>:
 80057d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80057d2:	0005      	movs	r5, r0
 80057d4:	000e      	movs	r6, r1
 80057d6:	4869      	ldr	r0, [pc, #420]	; (800597c <.text_53>)
 80057d8:	00a9      	lsls	r1, r5, #2
 80057da:	1844      	adds	r4, r0, r1
 80057dc:	2000      	movs	r0, #0
 80057de:	6861      	ldr	r1, [r4, #4]
 80057e0:	72c8      	strb	r0, [r1, #11]
 80057e2:	220f      	movs	r2, #15
 80057e4:	2103      	movs	r1, #3
 80057e6:	6860      	ldr	r0, [r4, #4]
 80057e8:	1d80      	adds	r0, r0, #6
 80057ea:	f006 fe4a 	bl	800c482 <__aeabi_memset>
 80057ee:	2006      	movs	r0, #6
 80057f0:	6861      	ldr	r1, [r4, #4]
 80057f2:	7108      	strb	r0, [r1, #4]
 80057f4:	4862      	ldr	r0, [pc, #392]	; (8005980 <.text_54>)
 80057f6:	6807      	ldr	r7, [r0, #0]
 80057f8:	2f00      	cmp	r7, #0
 80057fa:	d006      	beq.n	800580a <PRL_ResetIndicate+0x3a>
 80057fc:	2000      	movs	r0, #0
 80057fe:	9000      	str	r0, [sp, #0]
 8005800:	2300      	movs	r3, #0
 8005802:	0032      	movs	r2, r6
 8005804:	0029      	movs	r1, r5
 8005806:	2001      	movs	r0, #1
 8005808:	47b8      	blx	r7
 800580a:	0031      	movs	r1, r6
 800580c:	0028      	movs	r0, r5
 800580e:	6862      	ldr	r2, [r4, #4]
 8005810:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8005812:	6892      	ldr	r2, [r2, #8]
 8005814:	4790      	blx	r2
 8005816:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}

08005818 <PRL_ResetCompleted>:
 8005818:	4958      	ldr	r1, [pc, #352]	; (800597c <.text_53>)
 800581a:	0080      	lsls	r0, r0, #2
 800581c:	1808      	adds	r0, r1, r0
 800581e:	6840      	ldr	r0, [r0, #4]
 8005820:	2101      	movs	r1, #1
 8005822:	7341      	strb	r1, [r0, #13]
 8005824:	4770      	bx	lr

08005826 <PRL_IdleAfterBusy>:
 8005826:	4955      	ldr	r1, [pc, #340]	; (800597c <.text_53>)
 8005828:	0080      	lsls	r0, r0, #2
 800582a:	1808      	adds	r0, r1, r0
 800582c:	6840      	ldr	r0, [r0, #4]
 800582e:	2101      	movs	r1, #1
 8005830:	7381      	strb	r1, [r0, #14]
 8005832:	4770      	bx	lr

08005834 <.text_45>:
 8005834:	0000f01f 	.word	0x0000f01f

08005838 <PRL_BistCompleted>:
 8005838:	b580      	push	{r7, lr}
 800583a:	4b50      	ldr	r3, [pc, #320]	; (800597c <.text_53>)
 800583c:	0082      	lsls	r2, r0, #2
 800583e:	189a      	adds	r2, r3, r2
 8005840:	6852      	ldr	r2, [r2, #4]
 8005842:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8005844:	68d2      	ldr	r2, [r2, #12]
 8005846:	4790      	blx	r2
 8005848:	bd01      	pop	{r0, pc}
	...

0800584c <.text_47>:
 800584c:	0000ffe0 	.word	0x0000ffe0

08005850 <.text_48>:
 8005850:	0000fedf 	.word	0x0000fedf

08005854 <PRL_TxCompleted>:
 8005854:	b538      	push	{r3, r4, r5, lr}
 8005856:	0005      	movs	r5, r0
 8005858:	4848      	ldr	r0, [pc, #288]	; (800597c <.text_53>)
 800585a:	00a9      	lsls	r1, r5, #2
 800585c:	1844      	adds	r4, r0, r1
 800585e:	6861      	ldr	r1, [r4, #4]
 8005860:	7c88      	ldrb	r0, [r1, #18]
 8005862:	2801      	cmp	r0, #1
 8005864:	d002      	beq.n	800586c <PRL_TxCompleted+0x18>
 8005866:	2802      	cmp	r0, #2
 8005868:	d005      	beq.n	8005876 <PRL_TxCompleted+0x22>
 800586a:	e010      	b.n	800588e <PRL_TxCompleted+0x3a>
 800586c:	0028      	movs	r0, r5
 800586e:	6b09      	ldr	r1, [r1, #48]	; 0x30
 8005870:	6849      	ldr	r1, [r1, #4]
 8005872:	4788      	blx	r1
 8005874:	e00b      	b.n	800588e <PRL_TxCompleted+0x3a>
 8005876:	0028      	movs	r0, r5
 8005878:	f003 fe5e 	bl	8009538 <USBPD_PHY_GetRetryTimerValue>
 800587c:	2d00      	cmp	r5, #0
 800587e:	d101      	bne.n	8005884 <PRL_TxCompleted+0x30>
 8005880:	2201      	movs	r2, #1
 8005882:	e000      	b.n	8005886 <PRL_TxCompleted+0x32>
 8005884:	2203      	movs	r2, #3
 8005886:	b281      	uxth	r1, r0
 8005888:	0010      	movs	r0, r2
 800588a:	f005 fd03 	bl	800b294 <USBPD_TIM_Start>
 800588e:	2000      	movs	r0, #0
 8005890:	6861      	ldr	r1, [r4, #4]
 8005892:	7488      	strb	r0, [r1, #18]
 8005894:	bd31      	pop	{r0, r4, r5, pc}
	...

08005898 <.text_50>:
 8005898:	0000ff3f 	.word	0x0000ff3f

0800589c <USBPD_PRL_PrepareExtendedTxChunkSending>:
 800589c:	b570      	push	{r4, r5, r6, lr}
 800589e:	4c37      	ldr	r4, [pc, #220]	; (800597c <.text_53>)
 80058a0:	0080      	lsls	r0, r0, #2
 80058a2:	1820      	adds	r0, r4, r0
 80058a4:	6840      	ldr	r0, [r0, #4]
 80058a6:	2480      	movs	r4, #128	; 0x80
 80058a8:	0224      	lsls	r4, r4, #8
 80058aa:	8b45      	ldrh	r5, [r0, #26]
 80058ac:	4e35      	ldr	r6, [pc, #212]	; (8005984 <.text_55>)
 80058ae:	402e      	ands	r6, r5
 80058b0:	02c9      	lsls	r1, r1, #11
 80058b2:	4331      	orrs	r1, r6
 80058b4:	25fe      	movs	r5, #254	; 0xfe
 80058b6:	022d      	lsls	r5, r5, #8
 80058b8:	400d      	ands	r5, r1
 80058ba:	05d1      	lsls	r1, r2, #23
 80058bc:	0dc9      	lsrs	r1, r1, #23
 80058be:	4329      	orrs	r1, r5
 80058c0:	4321      	orrs	r1, r4
 80058c2:	8341      	strh	r1, [r0, #26]
 80058c4:	8a81      	ldrh	r1, [r0, #20]
 80058c6:	430c      	orrs	r4, r1
 80058c8:	8284      	strh	r4, [r0, #20]
 80058ca:	4a2f      	ldr	r2, [pc, #188]	; (8005988 <.text_56>)
 80058cc:	4022      	ands	r2, r4
 80058ce:	7f81      	ldrb	r1, [r0, #30]
 80058d0:	06c9      	lsls	r1, r1, #27
 80058d2:	0ec9      	lsrs	r1, r1, #27
 80058d4:	4311      	orrs	r1, r2
 80058d6:	8281      	strh	r1, [r0, #20]
 80058d8:	7019      	strb	r1, [r3, #0]
 80058da:	8a81      	ldrh	r1, [r0, #20]
 80058dc:	0a09      	lsrs	r1, r1, #8
 80058de:	7059      	strb	r1, [r3, #1]
 80058e0:	8b41      	ldrh	r1, [r0, #26]
 80058e2:	7099      	strb	r1, [r3, #2]
 80058e4:	8b40      	ldrh	r0, [r0, #26]
 80058e6:	0a00      	lsrs	r0, r0, #8
 80058e8:	70d8      	strb	r0, [r3, #3]
 80058ea:	bd70      	pop	{r4, r5, r6, pc}

080058ec <USBPD_PRL_ManageExtendedRx>:
 80058ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80058ee:	b084      	sub	sp, #16
 80058f0:	4a22      	ldr	r2, [pc, #136]	; (800597c <.text_53>)
 80058f2:	0083      	lsls	r3, r0, #2
 80058f4:	18d2      	adds	r2, r2, r3
 80058f6:	6853      	ldr	r3, [r2, #4]
 80058f8:	8b5a      	ldrh	r2, [r3, #26]
 80058fa:	2484      	movs	r4, #132	; 0x84
 80058fc:	0224      	lsls	r4, r4, #8
 80058fe:	4314      	orrs	r4, r2
 8005900:	835c      	strh	r4, [r3, #26]
 8005902:	2286      	movs	r2, #134	; 0x86
 8005904:	0212      	lsls	r2, r2, #8
 8005906:	4022      	ands	r2, r4
 8005908:	8b9c      	ldrh	r4, [r3, #28]
 800590a:	0ae4      	lsrs	r4, r4, #11
 800590c:	1c64      	adds	r4, r4, #1
 800590e:	02e4      	lsls	r4, r4, #11
 8005910:	25f0      	movs	r5, #240	; 0xf0
 8005912:	01ed      	lsls	r5, r5, #7
 8005914:	4025      	ands	r5, r4
 8005916:	4315      	orrs	r5, r2
 8005918:	835d      	strh	r5, [r3, #26]
 800591a:	8bdd      	ldrh	r5, [r3, #30]
 800591c:	221f      	movs	r2, #31
 800591e:	261f      	movs	r6, #31
 8005920:	402e      	ands	r6, r5
 8005922:	2480      	movs	r4, #128	; 0x80
 8005924:	4334      	orrs	r4, r6
 8005926:	8a9f      	ldrh	r7, [r3, #20]
 8005928:	4e18      	ldr	r6, [pc, #96]	; (800598c <.text_57>)
 800592a:	403e      	ands	r6, r7
 800592c:	2790      	movs	r7, #144	; 0x90
 800592e:	023f      	lsls	r7, r7, #8
 8005930:	4337      	orrs	r7, r6
 8005932:	829f      	strh	r7, [r3, #20]
 8005934:	4e14      	ldr	r6, [pc, #80]	; (8005988 <.text_56>)
 8005936:	403e      	ands	r6, r7
 8005938:	402a      	ands	r2, r5
 800593a:	4332      	orrs	r2, r6
 800593c:	829a      	strh	r2, [r3, #20]
 800593e:	2506      	movs	r5, #6
 8005940:	711d      	strb	r5, [r3, #4]
 8005942:	ad02      	add	r5, sp, #8
 8005944:	702a      	strb	r2, [r5, #0]
 8005946:	8a9a      	ldrh	r2, [r3, #20]
 8005948:	0a12      	lsrs	r2, r2, #8
 800594a:	706a      	strb	r2, [r5, #1]
 800594c:	8b5a      	ldrh	r2, [r3, #26]
 800594e:	70aa      	strb	r2, [r5, #2]
 8005950:	8b5a      	ldrh	r2, [r3, #26]
 8005952:	0a12      	lsrs	r2, r2, #8
 8005954:	70ea      	strb	r2, [r5, #3]
 8005956:	2200      	movs	r2, #0
 8005958:	80aa      	strh	r2, [r5, #4]
 800595a:	0006      	movs	r6, r0
 800595c:	000d      	movs	r5, r1
 800595e:	2000      	movs	r0, #0
 8005960:	9001      	str	r0, [sp, #4]
 8005962:	2006      	movs	r0, #6
 8005964:	9000      	str	r0, [sp, #0]
 8005966:	ab02      	add	r3, sp, #8
 8005968:	0022      	movs	r2, r4
 800596a:	0029      	movs	r1, r5
 800596c:	0030      	movs	r0, r6
 800596e:	f7ff fb29 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8005972:	2803      	cmp	r0, #3
 8005974:	d0f3      	beq.n	800595e <USBPD_PRL_ManageExtendedRx+0x72>
 8005976:	2000      	movs	r0, #0
 8005978:	b005      	add	sp, #20
 800597a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800597c <.text_53>:
 800597c:	200019fc 	.word	0x200019fc

08005980 <.text_54>:
 8005980:	200019f4 	.word	0x200019f4

08005984 <.text_55>:
 8005984:	000083ff 	.word	0x000083ff

08005988 <.text_56>:
 8005988:	0000ffe0 	.word	0x0000ffe0

0800598c <.text_57>:
 800598c:	00008fff 	.word	0x00008fff

08005990 <strlen>:
 8005990:	2300      	movs	r3, #0
 8005992:	5cc2      	ldrb	r2, [r0, r3]
 8005994:	3301      	adds	r3, #1
 8005996:	2a00      	cmp	r2, #0
 8005998:	d1fb      	bne.n	8005992 <strlen+0x2>
 800599a:	1e58      	subs	r0, r3, #1
 800599c:	4770      	bx	lr
	...

080059a0 <__gnu_thumb1_case_uqi>:
 80059a0:	b402      	push	{r1}
 80059a2:	4671      	mov	r1, lr
 80059a4:	0849      	lsrs	r1, r1, #1
 80059a6:	0049      	lsls	r1, r1, #1
 80059a8:	5c09      	ldrb	r1, [r1, r0]
 80059aa:	0049      	lsls	r1, r1, #1
 80059ac:	448e      	add	lr, r1
 80059ae:	bc02      	pop	{r1}
 80059b0:	4770      	bx	lr
 80059b2:	46c0      	nop			; (mov r8, r8)

080059b4 <__udivsi3>:
 80059b4:	2200      	movs	r2, #0
 80059b6:	0843      	lsrs	r3, r0, #1
 80059b8:	428b      	cmp	r3, r1
 80059ba:	d374      	bcc.n	8005aa6 <__udivsi3+0xf2>
 80059bc:	0903      	lsrs	r3, r0, #4
 80059be:	428b      	cmp	r3, r1
 80059c0:	d35f      	bcc.n	8005a82 <__udivsi3+0xce>
 80059c2:	0a03      	lsrs	r3, r0, #8
 80059c4:	428b      	cmp	r3, r1
 80059c6:	d344      	bcc.n	8005a52 <__udivsi3+0x9e>
 80059c8:	0b03      	lsrs	r3, r0, #12
 80059ca:	428b      	cmp	r3, r1
 80059cc:	d328      	bcc.n	8005a20 <__udivsi3+0x6c>
 80059ce:	0c03      	lsrs	r3, r0, #16
 80059d0:	428b      	cmp	r3, r1
 80059d2:	d30d      	bcc.n	80059f0 <__udivsi3+0x3c>
 80059d4:	22ff      	movs	r2, #255	; 0xff
 80059d6:	0209      	lsls	r1, r1, #8
 80059d8:	ba12      	rev	r2, r2
 80059da:	0c03      	lsrs	r3, r0, #16
 80059dc:	428b      	cmp	r3, r1
 80059de:	d302      	bcc.n	80059e6 <__udivsi3+0x32>
 80059e0:	1212      	asrs	r2, r2, #8
 80059e2:	0209      	lsls	r1, r1, #8
 80059e4:	d065      	beq.n	8005ab2 <__udivsi3+0xfe>
 80059e6:	0b03      	lsrs	r3, r0, #12
 80059e8:	428b      	cmp	r3, r1
 80059ea:	d319      	bcc.n	8005a20 <__udivsi3+0x6c>
 80059ec:	e000      	b.n	80059f0 <__udivsi3+0x3c>
 80059ee:	0a09      	lsrs	r1, r1, #8
 80059f0:	0bc3      	lsrs	r3, r0, #15
 80059f2:	428b      	cmp	r3, r1
 80059f4:	d301      	bcc.n	80059fa <__udivsi3+0x46>
 80059f6:	03cb      	lsls	r3, r1, #15
 80059f8:	1ac0      	subs	r0, r0, r3
 80059fa:	4152      	adcs	r2, r2
 80059fc:	0b83      	lsrs	r3, r0, #14
 80059fe:	428b      	cmp	r3, r1
 8005a00:	d301      	bcc.n	8005a06 <__udivsi3+0x52>
 8005a02:	038b      	lsls	r3, r1, #14
 8005a04:	1ac0      	subs	r0, r0, r3
 8005a06:	4152      	adcs	r2, r2
 8005a08:	0b43      	lsrs	r3, r0, #13
 8005a0a:	428b      	cmp	r3, r1
 8005a0c:	d301      	bcc.n	8005a12 <__udivsi3+0x5e>
 8005a0e:	034b      	lsls	r3, r1, #13
 8005a10:	1ac0      	subs	r0, r0, r3
 8005a12:	4152      	adcs	r2, r2
 8005a14:	0b03      	lsrs	r3, r0, #12
 8005a16:	428b      	cmp	r3, r1
 8005a18:	d301      	bcc.n	8005a1e <__udivsi3+0x6a>
 8005a1a:	030b      	lsls	r3, r1, #12
 8005a1c:	1ac0      	subs	r0, r0, r3
 8005a1e:	4152      	adcs	r2, r2
 8005a20:	0ac3      	lsrs	r3, r0, #11
 8005a22:	428b      	cmp	r3, r1
 8005a24:	d301      	bcc.n	8005a2a <__udivsi3+0x76>
 8005a26:	02cb      	lsls	r3, r1, #11
 8005a28:	1ac0      	subs	r0, r0, r3
 8005a2a:	4152      	adcs	r2, r2
 8005a2c:	0a83      	lsrs	r3, r0, #10
 8005a2e:	428b      	cmp	r3, r1
 8005a30:	d301      	bcc.n	8005a36 <__udivsi3+0x82>
 8005a32:	028b      	lsls	r3, r1, #10
 8005a34:	1ac0      	subs	r0, r0, r3
 8005a36:	4152      	adcs	r2, r2
 8005a38:	0a43      	lsrs	r3, r0, #9
 8005a3a:	428b      	cmp	r3, r1
 8005a3c:	d301      	bcc.n	8005a42 <__udivsi3+0x8e>
 8005a3e:	024b      	lsls	r3, r1, #9
 8005a40:	1ac0      	subs	r0, r0, r3
 8005a42:	4152      	adcs	r2, r2
 8005a44:	0a03      	lsrs	r3, r0, #8
 8005a46:	428b      	cmp	r3, r1
 8005a48:	d301      	bcc.n	8005a4e <__udivsi3+0x9a>
 8005a4a:	020b      	lsls	r3, r1, #8
 8005a4c:	1ac0      	subs	r0, r0, r3
 8005a4e:	4152      	adcs	r2, r2
 8005a50:	d2cd      	bcs.n	80059ee <__udivsi3+0x3a>
 8005a52:	09c3      	lsrs	r3, r0, #7
 8005a54:	428b      	cmp	r3, r1
 8005a56:	d301      	bcc.n	8005a5c <__udivsi3+0xa8>
 8005a58:	01cb      	lsls	r3, r1, #7
 8005a5a:	1ac0      	subs	r0, r0, r3
 8005a5c:	4152      	adcs	r2, r2
 8005a5e:	0983      	lsrs	r3, r0, #6
 8005a60:	428b      	cmp	r3, r1
 8005a62:	d301      	bcc.n	8005a68 <__udivsi3+0xb4>
 8005a64:	018b      	lsls	r3, r1, #6
 8005a66:	1ac0      	subs	r0, r0, r3
 8005a68:	4152      	adcs	r2, r2
 8005a6a:	0943      	lsrs	r3, r0, #5
 8005a6c:	428b      	cmp	r3, r1
 8005a6e:	d301      	bcc.n	8005a74 <__udivsi3+0xc0>
 8005a70:	014b      	lsls	r3, r1, #5
 8005a72:	1ac0      	subs	r0, r0, r3
 8005a74:	4152      	adcs	r2, r2
 8005a76:	0903      	lsrs	r3, r0, #4
 8005a78:	428b      	cmp	r3, r1
 8005a7a:	d301      	bcc.n	8005a80 <__udivsi3+0xcc>
 8005a7c:	010b      	lsls	r3, r1, #4
 8005a7e:	1ac0      	subs	r0, r0, r3
 8005a80:	4152      	adcs	r2, r2
 8005a82:	08c3      	lsrs	r3, r0, #3
 8005a84:	428b      	cmp	r3, r1
 8005a86:	d301      	bcc.n	8005a8c <__udivsi3+0xd8>
 8005a88:	00cb      	lsls	r3, r1, #3
 8005a8a:	1ac0      	subs	r0, r0, r3
 8005a8c:	4152      	adcs	r2, r2
 8005a8e:	0883      	lsrs	r3, r0, #2
 8005a90:	428b      	cmp	r3, r1
 8005a92:	d301      	bcc.n	8005a98 <__udivsi3+0xe4>
 8005a94:	008b      	lsls	r3, r1, #2
 8005a96:	1ac0      	subs	r0, r0, r3
 8005a98:	4152      	adcs	r2, r2
 8005a9a:	0843      	lsrs	r3, r0, #1
 8005a9c:	428b      	cmp	r3, r1
 8005a9e:	d301      	bcc.n	8005aa4 <__udivsi3+0xf0>
 8005aa0:	004b      	lsls	r3, r1, #1
 8005aa2:	1ac0      	subs	r0, r0, r3
 8005aa4:	4152      	adcs	r2, r2
 8005aa6:	1a41      	subs	r1, r0, r1
 8005aa8:	d200      	bcs.n	8005aac <__udivsi3+0xf8>
 8005aaa:	4601      	mov	r1, r0
 8005aac:	4152      	adcs	r2, r2
 8005aae:	4610      	mov	r0, r2
 8005ab0:	4770      	bx	lr
 8005ab2:	e7ff      	b.n	8005ab4 <__udivsi3+0x100>
 8005ab4:	b501      	push	{r0, lr}
 8005ab6:	2000      	movs	r0, #0
 8005ab8:	f000 f8f0 	bl	8005c9c <__aeabi_idiv0>
 8005abc:	bd02      	pop	{r1, pc}
 8005abe:	46c0      	nop			; (mov r8, r8)

08005ac0 <__aeabi_uidivmod>:
 8005ac0:	2900      	cmp	r1, #0
 8005ac2:	d0f7      	beq.n	8005ab4 <__udivsi3+0x100>
 8005ac4:	e776      	b.n	80059b4 <__udivsi3>
 8005ac6:	4770      	bx	lr

08005ac8 <__divsi3>:
 8005ac8:	4603      	mov	r3, r0
 8005aca:	430b      	orrs	r3, r1
 8005acc:	d47f      	bmi.n	8005bce <__divsi3+0x106>
 8005ace:	2200      	movs	r2, #0
 8005ad0:	0843      	lsrs	r3, r0, #1
 8005ad2:	428b      	cmp	r3, r1
 8005ad4:	d374      	bcc.n	8005bc0 <__divsi3+0xf8>
 8005ad6:	0903      	lsrs	r3, r0, #4
 8005ad8:	428b      	cmp	r3, r1
 8005ada:	d35f      	bcc.n	8005b9c <__divsi3+0xd4>
 8005adc:	0a03      	lsrs	r3, r0, #8
 8005ade:	428b      	cmp	r3, r1
 8005ae0:	d344      	bcc.n	8005b6c <__divsi3+0xa4>
 8005ae2:	0b03      	lsrs	r3, r0, #12
 8005ae4:	428b      	cmp	r3, r1
 8005ae6:	d328      	bcc.n	8005b3a <__divsi3+0x72>
 8005ae8:	0c03      	lsrs	r3, r0, #16
 8005aea:	428b      	cmp	r3, r1
 8005aec:	d30d      	bcc.n	8005b0a <__divsi3+0x42>
 8005aee:	22ff      	movs	r2, #255	; 0xff
 8005af0:	0209      	lsls	r1, r1, #8
 8005af2:	ba12      	rev	r2, r2
 8005af4:	0c03      	lsrs	r3, r0, #16
 8005af6:	428b      	cmp	r3, r1
 8005af8:	d302      	bcc.n	8005b00 <__divsi3+0x38>
 8005afa:	1212      	asrs	r2, r2, #8
 8005afc:	0209      	lsls	r1, r1, #8
 8005afe:	d065      	beq.n	8005bcc <__divsi3+0x104>
 8005b00:	0b03      	lsrs	r3, r0, #12
 8005b02:	428b      	cmp	r3, r1
 8005b04:	d319      	bcc.n	8005b3a <__divsi3+0x72>
 8005b06:	e000      	b.n	8005b0a <__divsi3+0x42>
 8005b08:	0a09      	lsrs	r1, r1, #8
 8005b0a:	0bc3      	lsrs	r3, r0, #15
 8005b0c:	428b      	cmp	r3, r1
 8005b0e:	d301      	bcc.n	8005b14 <__divsi3+0x4c>
 8005b10:	03cb      	lsls	r3, r1, #15
 8005b12:	1ac0      	subs	r0, r0, r3
 8005b14:	4152      	adcs	r2, r2
 8005b16:	0b83      	lsrs	r3, r0, #14
 8005b18:	428b      	cmp	r3, r1
 8005b1a:	d301      	bcc.n	8005b20 <__divsi3+0x58>
 8005b1c:	038b      	lsls	r3, r1, #14
 8005b1e:	1ac0      	subs	r0, r0, r3
 8005b20:	4152      	adcs	r2, r2
 8005b22:	0b43      	lsrs	r3, r0, #13
 8005b24:	428b      	cmp	r3, r1
 8005b26:	d301      	bcc.n	8005b2c <__divsi3+0x64>
 8005b28:	034b      	lsls	r3, r1, #13
 8005b2a:	1ac0      	subs	r0, r0, r3
 8005b2c:	4152      	adcs	r2, r2
 8005b2e:	0b03      	lsrs	r3, r0, #12
 8005b30:	428b      	cmp	r3, r1
 8005b32:	d301      	bcc.n	8005b38 <__divsi3+0x70>
 8005b34:	030b      	lsls	r3, r1, #12
 8005b36:	1ac0      	subs	r0, r0, r3
 8005b38:	4152      	adcs	r2, r2
 8005b3a:	0ac3      	lsrs	r3, r0, #11
 8005b3c:	428b      	cmp	r3, r1
 8005b3e:	d301      	bcc.n	8005b44 <__divsi3+0x7c>
 8005b40:	02cb      	lsls	r3, r1, #11
 8005b42:	1ac0      	subs	r0, r0, r3
 8005b44:	4152      	adcs	r2, r2
 8005b46:	0a83      	lsrs	r3, r0, #10
 8005b48:	428b      	cmp	r3, r1
 8005b4a:	d301      	bcc.n	8005b50 <__divsi3+0x88>
 8005b4c:	028b      	lsls	r3, r1, #10
 8005b4e:	1ac0      	subs	r0, r0, r3
 8005b50:	4152      	adcs	r2, r2
 8005b52:	0a43      	lsrs	r3, r0, #9
 8005b54:	428b      	cmp	r3, r1
 8005b56:	d301      	bcc.n	8005b5c <__divsi3+0x94>
 8005b58:	024b      	lsls	r3, r1, #9
 8005b5a:	1ac0      	subs	r0, r0, r3
 8005b5c:	4152      	adcs	r2, r2
 8005b5e:	0a03      	lsrs	r3, r0, #8
 8005b60:	428b      	cmp	r3, r1
 8005b62:	d301      	bcc.n	8005b68 <__divsi3+0xa0>
 8005b64:	020b      	lsls	r3, r1, #8
 8005b66:	1ac0      	subs	r0, r0, r3
 8005b68:	4152      	adcs	r2, r2
 8005b6a:	d2cd      	bcs.n	8005b08 <__divsi3+0x40>
 8005b6c:	09c3      	lsrs	r3, r0, #7
 8005b6e:	428b      	cmp	r3, r1
 8005b70:	d301      	bcc.n	8005b76 <__divsi3+0xae>
 8005b72:	01cb      	lsls	r3, r1, #7
 8005b74:	1ac0      	subs	r0, r0, r3
 8005b76:	4152      	adcs	r2, r2
 8005b78:	0983      	lsrs	r3, r0, #6
 8005b7a:	428b      	cmp	r3, r1
 8005b7c:	d301      	bcc.n	8005b82 <__divsi3+0xba>
 8005b7e:	018b      	lsls	r3, r1, #6
 8005b80:	1ac0      	subs	r0, r0, r3
 8005b82:	4152      	adcs	r2, r2
 8005b84:	0943      	lsrs	r3, r0, #5
 8005b86:	428b      	cmp	r3, r1
 8005b88:	d301      	bcc.n	8005b8e <__divsi3+0xc6>
 8005b8a:	014b      	lsls	r3, r1, #5
 8005b8c:	1ac0      	subs	r0, r0, r3
 8005b8e:	4152      	adcs	r2, r2
 8005b90:	0903      	lsrs	r3, r0, #4
 8005b92:	428b      	cmp	r3, r1
 8005b94:	d301      	bcc.n	8005b9a <__divsi3+0xd2>
 8005b96:	010b      	lsls	r3, r1, #4
 8005b98:	1ac0      	subs	r0, r0, r3
 8005b9a:	4152      	adcs	r2, r2
 8005b9c:	08c3      	lsrs	r3, r0, #3
 8005b9e:	428b      	cmp	r3, r1
 8005ba0:	d301      	bcc.n	8005ba6 <__divsi3+0xde>
 8005ba2:	00cb      	lsls	r3, r1, #3
 8005ba4:	1ac0      	subs	r0, r0, r3
 8005ba6:	4152      	adcs	r2, r2
 8005ba8:	0883      	lsrs	r3, r0, #2
 8005baa:	428b      	cmp	r3, r1
 8005bac:	d301      	bcc.n	8005bb2 <__divsi3+0xea>
 8005bae:	008b      	lsls	r3, r1, #2
 8005bb0:	1ac0      	subs	r0, r0, r3
 8005bb2:	4152      	adcs	r2, r2
 8005bb4:	0843      	lsrs	r3, r0, #1
 8005bb6:	428b      	cmp	r3, r1
 8005bb8:	d301      	bcc.n	8005bbe <__divsi3+0xf6>
 8005bba:	004b      	lsls	r3, r1, #1
 8005bbc:	1ac0      	subs	r0, r0, r3
 8005bbe:	4152      	adcs	r2, r2
 8005bc0:	1a41      	subs	r1, r0, r1
 8005bc2:	d200      	bcs.n	8005bc6 <__divsi3+0xfe>
 8005bc4:	4601      	mov	r1, r0
 8005bc6:	4152      	adcs	r2, r2
 8005bc8:	4610      	mov	r0, r2
 8005bca:	4770      	bx	lr
 8005bcc:	e05d      	b.n	8005c8a <__divsi3+0x1c2>
 8005bce:	0fca      	lsrs	r2, r1, #31
 8005bd0:	d000      	beq.n	8005bd4 <__divsi3+0x10c>
 8005bd2:	4249      	negs	r1, r1
 8005bd4:	1003      	asrs	r3, r0, #32
 8005bd6:	d300      	bcc.n	8005bda <__divsi3+0x112>
 8005bd8:	4240      	negs	r0, r0
 8005bda:	4053      	eors	r3, r2
 8005bdc:	2200      	movs	r2, #0
 8005bde:	469c      	mov	ip, r3
 8005be0:	0903      	lsrs	r3, r0, #4
 8005be2:	428b      	cmp	r3, r1
 8005be4:	d32d      	bcc.n	8005c42 <__divsi3+0x17a>
 8005be6:	0a03      	lsrs	r3, r0, #8
 8005be8:	428b      	cmp	r3, r1
 8005bea:	d312      	bcc.n	8005c12 <__divsi3+0x14a>
 8005bec:	22fc      	movs	r2, #252	; 0xfc
 8005bee:	0189      	lsls	r1, r1, #6
 8005bf0:	ba12      	rev	r2, r2
 8005bf2:	0a03      	lsrs	r3, r0, #8
 8005bf4:	428b      	cmp	r3, r1
 8005bf6:	d30c      	bcc.n	8005c12 <__divsi3+0x14a>
 8005bf8:	0189      	lsls	r1, r1, #6
 8005bfa:	1192      	asrs	r2, r2, #6
 8005bfc:	428b      	cmp	r3, r1
 8005bfe:	d308      	bcc.n	8005c12 <__divsi3+0x14a>
 8005c00:	0189      	lsls	r1, r1, #6
 8005c02:	1192      	asrs	r2, r2, #6
 8005c04:	428b      	cmp	r3, r1
 8005c06:	d304      	bcc.n	8005c12 <__divsi3+0x14a>
 8005c08:	0189      	lsls	r1, r1, #6
 8005c0a:	d03a      	beq.n	8005c82 <__divsi3+0x1ba>
 8005c0c:	1192      	asrs	r2, r2, #6
 8005c0e:	e000      	b.n	8005c12 <__divsi3+0x14a>
 8005c10:	0989      	lsrs	r1, r1, #6
 8005c12:	09c3      	lsrs	r3, r0, #7
 8005c14:	428b      	cmp	r3, r1
 8005c16:	d301      	bcc.n	8005c1c <__divsi3+0x154>
 8005c18:	01cb      	lsls	r3, r1, #7
 8005c1a:	1ac0      	subs	r0, r0, r3
 8005c1c:	4152      	adcs	r2, r2
 8005c1e:	0983      	lsrs	r3, r0, #6
 8005c20:	428b      	cmp	r3, r1
 8005c22:	d301      	bcc.n	8005c28 <__divsi3+0x160>
 8005c24:	018b      	lsls	r3, r1, #6
 8005c26:	1ac0      	subs	r0, r0, r3
 8005c28:	4152      	adcs	r2, r2
 8005c2a:	0943      	lsrs	r3, r0, #5
 8005c2c:	428b      	cmp	r3, r1
 8005c2e:	d301      	bcc.n	8005c34 <__divsi3+0x16c>
 8005c30:	014b      	lsls	r3, r1, #5
 8005c32:	1ac0      	subs	r0, r0, r3
 8005c34:	4152      	adcs	r2, r2
 8005c36:	0903      	lsrs	r3, r0, #4
 8005c38:	428b      	cmp	r3, r1
 8005c3a:	d301      	bcc.n	8005c40 <__divsi3+0x178>
 8005c3c:	010b      	lsls	r3, r1, #4
 8005c3e:	1ac0      	subs	r0, r0, r3
 8005c40:	4152      	adcs	r2, r2
 8005c42:	08c3      	lsrs	r3, r0, #3
 8005c44:	428b      	cmp	r3, r1
 8005c46:	d301      	bcc.n	8005c4c <__divsi3+0x184>
 8005c48:	00cb      	lsls	r3, r1, #3
 8005c4a:	1ac0      	subs	r0, r0, r3
 8005c4c:	4152      	adcs	r2, r2
 8005c4e:	0883      	lsrs	r3, r0, #2
 8005c50:	428b      	cmp	r3, r1
 8005c52:	d301      	bcc.n	8005c58 <__divsi3+0x190>
 8005c54:	008b      	lsls	r3, r1, #2
 8005c56:	1ac0      	subs	r0, r0, r3
 8005c58:	4152      	adcs	r2, r2
 8005c5a:	d2d9      	bcs.n	8005c10 <__divsi3+0x148>
 8005c5c:	0843      	lsrs	r3, r0, #1
 8005c5e:	428b      	cmp	r3, r1
 8005c60:	d301      	bcc.n	8005c66 <__divsi3+0x19e>
 8005c62:	004b      	lsls	r3, r1, #1
 8005c64:	1ac0      	subs	r0, r0, r3
 8005c66:	4152      	adcs	r2, r2
 8005c68:	1a41      	subs	r1, r0, r1
 8005c6a:	d200      	bcs.n	8005c6e <__divsi3+0x1a6>
 8005c6c:	4601      	mov	r1, r0
 8005c6e:	4663      	mov	r3, ip
 8005c70:	4152      	adcs	r2, r2
 8005c72:	105b      	asrs	r3, r3, #1
 8005c74:	4610      	mov	r0, r2
 8005c76:	d301      	bcc.n	8005c7c <__divsi3+0x1b4>
 8005c78:	4240      	negs	r0, r0
 8005c7a:	2b00      	cmp	r3, #0
 8005c7c:	d500      	bpl.n	8005c80 <__divsi3+0x1b8>
 8005c7e:	4249      	negs	r1, r1
 8005c80:	4770      	bx	lr
 8005c82:	4663      	mov	r3, ip
 8005c84:	105b      	asrs	r3, r3, #1
 8005c86:	d300      	bcc.n	8005c8a <__divsi3+0x1c2>
 8005c88:	4240      	negs	r0, r0
 8005c8a:	b501      	push	{r0, lr}
 8005c8c:	2000      	movs	r0, #0
 8005c8e:	f000 f805 	bl	8005c9c <__aeabi_idiv0>
 8005c92:	bd02      	pop	{r1, pc}

08005c94 <__aeabi_idivmod>:
 8005c94:	2900      	cmp	r1, #0
 8005c96:	d0f8      	beq.n	8005c8a <__divsi3+0x1c2>
 8005c98:	e716      	b.n	8005ac8 <__divsi3>
 8005c9a:	4770      	bx	lr

08005c9c <__aeabi_idiv0>:
 8005c9c:	4770      	bx	lr
 8005c9e:	46c0      	nop			; (mov r8, r8)

08005ca0 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8005ca0:	480d      	ldr	r0, [pc, #52]	; (8005cd8 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8005ca2:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 8005ca4:	2100      	movs	r1, #0
  b LoopCopyDataInit
 8005ca6:	e003      	b.n	8005cb0 <LoopCopyDataInit>

08005ca8 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 8005ca8:	4b0c      	ldr	r3, [pc, #48]	; (8005cdc <LoopForever+0x6>)
  ldr r3, [r3, r1]
 8005caa:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 8005cac:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 8005cae:	3104      	adds	r1, #4

08005cb0 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 8005cb0:	480b      	ldr	r0, [pc, #44]	; (8005ce0 <LoopForever+0xa>)
  ldr r3, =_edata
 8005cb2:	4b0c      	ldr	r3, [pc, #48]	; (8005ce4 <LoopForever+0xe>)
  adds r2, r0, r1
 8005cb4:	1842      	adds	r2, r0, r1
  cmp r2, r3
 8005cb6:	429a      	cmp	r2, r3
  bcc CopyDataInit
 8005cb8:	d3f6      	bcc.n	8005ca8 <CopyDataInit>
  ldr r2, =_sbss
 8005cba:	4a0b      	ldr	r2, [pc, #44]	; (8005ce8 <LoopForever+0x12>)
  b LoopFillZerobss
 8005cbc:	e002      	b.n	8005cc4 <LoopFillZerobss>

08005cbe <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 8005cbe:	2300      	movs	r3, #0
  str  r3, [r2]
 8005cc0:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8005cc2:	3204      	adds	r2, #4

08005cc4 <LoopFillZerobss>:


LoopFillZerobss:
  ldr r3, = _ebss
 8005cc4:	4b09      	ldr	r3, [pc, #36]	; (8005cec <LoopForever+0x16>)
  cmp r2, r3
 8005cc6:	429a      	cmp	r2, r3
  bcc FillZerobss
 8005cc8:	d3f9      	bcc.n	8005cbe <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 8005cca:	f001 f8f3 	bl	8006eb4 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 8005cce:	f006 fbdf 	bl	800c490 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8005cd2:	f000 f80f 	bl	8005cf4 <main>

08005cd6 <LoopForever>:

LoopForever:
    b LoopForever
 8005cd6:	e7fe      	b.n	8005cd6 <LoopForever>
  ldr   r0, =_estack
 8005cd8:	20004000 	.word	0x20004000
  ldr r3, =_sidata
 8005cdc:	0800c800 	.word	0x0800c800
  ldr r0, =_sdata
 8005ce0:	20000000 	.word	0x20000000
  ldr r3, =_edata
 8005ce4:	200002cc 	.word	0x200002cc
  ldr r2, =_sbss
 8005ce8:	200002cc 	.word	0x200002cc
  ldr r3, = _ebss
 8005cec:	20001d2c 	.word	0x20001d2c

08005cf0 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8005cf0:	e7fe      	b.n	8005cf0 <ADC1_COMP_IRQHandler>
	...

08005cf4 <main>:
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
 8005cf4:	b510      	push	{r4, lr}
  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8005cf6:	f001 f91f 	bl	8006f38 <HAL_Init>
  *         @arg @ref LL_FLASH_LATENCY_1
  * @retval None
  */
__STATIC_INLINE void LL_FLASH_SetLatency(uint32_t Latency)
{
  MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
 8005cfa:	2101      	movs	r1, #1
 8005cfc:	4a2b      	ldr	r2, [pc, #172]	; (8005dac <main+0xb8>)
 8005cfe:	6813      	ldr	r3, [r2, #0]
 8005d00:	430b      	orrs	r3, r1
 8005d02:	6013      	str	r3, [r2, #0]
  * @rmtoll CR2          HSI48ON       LL_RCC_HSI48_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI48_Enable(void)
{
  SET_BIT(RCC->CR2, RCC_CR2_HSI48ON);
 8005d04:	2280      	movs	r2, #128	; 0x80
 8005d06:	4b2a      	ldr	r3, [pc, #168]	; (8005db0 <main+0xbc>)
 8005d08:	0252      	lsls	r2, r2, #9
 8005d0a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8005d0c:	430a      	orrs	r2, r1
 8005d0e:	635a      	str	r2, [r3, #52]	; 0x34
  * @rmtoll CR2          HSI48RDY      LL_RCC_HSI48_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI48_IsReady(void)
{
  return (READ_BIT(RCC->CR2, RCC_CR2_HSI48RDY) == (RCC_CR2_HSI48RDY));
 8005d10:	2280      	movs	r2, #128	; 0x80
 8005d12:	0292      	lsls	r2, r2, #10
 8005d14:	6b59      	ldr	r1, [r3, #52]	; 0x34
  /* Set FLASH latency */ 
  LL_FLASH_SetLatency(LL_FLASH_LATENCY_1);

  /* Enable HSI48 and wait for activation*/
  LL_RCC_HSI48_Enable(); 
  while(LL_RCC_HSI48_IsReady() != 1) 
 8005d16:	4211      	tst	r1, r2
 8005d18:	d0fc      	beq.n	8005d14 <main+0x20>
  *         @arg @ref LL_RCC_PREDIV_DIV_16
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_ConfigDomain_SYS(uint32_t Source, uint32_t PLLMul, uint32_t PLLDiv)
{
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL, Source | PLLMul);
 8005d1a:	685a      	ldr	r2, [r3, #4]
 8005d1c:	4925      	ldr	r1, [pc, #148]	; (8005db4 <main+0xc0>)
 8005d1e:	4011      	ands	r1, r2
 8005d20:	22c0      	movs	r2, #192	; 0xc0
 8005d22:	0252      	lsls	r2, r2, #9
 8005d24:	430a      	orrs	r2, r1
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, PLLDiv);
 8005d26:	210f      	movs	r1, #15
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL, Source | PLLMul);
 8005d28:	605a      	str	r2, [r3, #4]
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, PLLDiv);
 8005d2a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005d2c:	438a      	bics	r2, r1
 8005d2e:	0011      	movs	r1, r2
 8005d30:	2201      	movs	r2, #1
 8005d32:	430a      	orrs	r2, r1
 8005d34:	62da      	str	r2, [r3, #44]	; 0x2c
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 8005d36:	2280      	movs	r2, #128	; 0x80
 8005d38:	6819      	ldr	r1, [r3, #0]
 8005d3a:	0452      	lsls	r2, r2, #17
 8005d3c:	430a      	orrs	r2, r1
 8005d3e:	601a      	str	r2, [r3, #0]
  return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
 8005d40:	2280      	movs	r2, #128	; 0x80
 8005d42:	0492      	lsls	r2, r2, #18
 8005d44:	6819      	ldr	r1, [r3, #0]
  
  /* Main PLL configuration and activation */
  LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI48, LL_RCC_PLL_MUL_2, LL_RCC_PREDIV_DIV_2);
  
  LL_RCC_PLL_Enable();
  while(LL_RCC_PLL_IsReady() != 1)
 8005d46:	4211      	tst	r1, r2
 8005d48:	d0fc      	beq.n	8005d44 <main+0x50>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 8005d4a:	21f0      	movs	r1, #240	; 0xf0
 8005d4c:	685a      	ldr	r2, [r3, #4]
 8005d4e:	438a      	bics	r2, r1
 8005d50:	605a      	str	r2, [r3, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8005d52:	685a      	ldr	r2, [r3, #4]
 8005d54:	39ed      	subs	r1, #237	; 0xed
 8005d56:	438a      	bics	r2, r1
 8005d58:	0011      	movs	r1, r2
 8005d5a:	2202      	movs	r2, #2
 8005d5c:	430a      	orrs	r2, r1
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8005d5e:	210c      	movs	r1, #12
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8005d60:	605a      	str	r2, [r3, #4]
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8005d62:	685a      	ldr	r2, [r3, #4]
 8005d64:	400a      	ands	r2, r1
  };
  
  /* Sysclk activation on the main PLL */
  LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
  LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
  while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
 8005d66:	2a08      	cmp	r2, #8
 8005d68:	d1fb      	bne.n	8005d62 <main+0x6e>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, Prescaler);
 8005d6a:	685a      	ldr	r2, [r3, #4]
 8005d6c:	4912      	ldr	r1, [pc, #72]	; (8005db8 <main+0xc4>)
  LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);
  
  /* Set systick to 1ms in using frequency set to 48MHz */
  /* This frequency can be calculated through LL RCC macro */
  /* ex: __LL_RCC_CALC_PLLCLK_FREQ (HSI48_VALUE, LL_RCC_PLL_MUL_2, LL_RCC_PREDIV_DIV_2) */
  LL_Init1msTick(48000000);
 8005d6e:	4813      	ldr	r0, [pc, #76]	; (8005dbc <main+0xc8>)
 8005d70:	400a      	ands	r2, r1
 8005d72:	605a      	str	r2, [r3, #4]
 8005d74:	f003 f912 	bl	8008f9c <LL_Init1msTick>
  
  /* Update CMSIS variable (which can be updated also through SystemCoreClockUpdate function) */
  LL_SetSystemCoreClock(48000000);
 8005d78:	4810      	ldr	r0, [pc, #64]	; (8005dbc <main+0xc8>)
 8005d7a:	f003 f91f 	bl	8008fbc <LL_SetSystemCoreClock>
  HAL_NVIC_SetPriority(SysTick_IRQn, TICK_INT_PRIORITY ,0U);
 8005d7e:	2001      	movs	r0, #1
 8005d80:	2200      	movs	r2, #0
 8005d82:	4240      	negs	r0, r0
 8005d84:	2103      	movs	r1, #3
 8005d86:	f001 fb61 	bl	800744c <HAL_NVIC_SetPriority>
  * @rmtoll STK_CTRL     TICKINT       LL_SYSTICK_EnableIT
  * @retval None
  */
__STATIC_INLINE void LL_SYSTICK_EnableIT(void)
{
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 8005d8a:	2302      	movs	r3, #2
 8005d8c:	4a0c      	ldr	r2, [pc, #48]	; (8005dc0 <main+0xcc>)
 8005d8e:	6811      	ldr	r1, [r2, #0]
 8005d90:	430b      	orrs	r3, r1
 8005d92:	6013      	str	r3, [r2, #0]
  USBPD_BSP_LED_Init();
 8005d94:	f001 f866 	bl	8006e64 <USBPD_BSP_LED_Init>
  USBPD_HW_IF_GlobalHwInit();
 8005d98:	f004 f90a 	bl	8009fb0 <USBPD_HW_IF_GlobalHwInit>
  if( USBPD_ERROR == USBPD_DPM_Init())
 8005d9c:	f003 f9b2 	bl	8009104 <USBPD_DPM_Init>
 8005da0:	2802      	cmp	r0, #2
 8005da2:	d100      	bne.n	8005da6 <main+0xb2>
 8005da4:	e7fe      	b.n	8005da4 <main+0xb0>
}
 8005da6:	2000      	movs	r0, #0
 8005da8:	bd10      	pop	{r4, pc}
 8005daa:	46c0      	nop			; (mov r8, r8)
 8005dac:	40022000 	.word	0x40022000
 8005db0:	40021000 	.word	0x40021000
 8005db4:	ffc27fff 	.word	0xffc27fff
 8005db8:	fffff8ff 	.word	0xfffff8ff
 8005dbc:	02dc6c00 	.word	0x02dc6c00
 8005dc0:	e000e010 	.word	0xe000e010

08005dc4 <HAL_MspInit>:
  *         level initialization (GPIOs, clock, DMA, interrupt).
  * @retval None
  */
void HAL_MspInit(void)
{
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005dc4:	2001      	movs	r0, #1
 8005dc6:	4b1c      	ldr	r3, [pc, #112]	; (8005e38 <HAL_MspInit+0x74>)
{
 8005dc8:	b086      	sub	sp, #24
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005dca:	6999      	ldr	r1, [r3, #24]
 8005dcc:	4301      	orrs	r1, r0
 8005dce:	6199      	str	r1, [r3, #24]
 8005dd0:	699a      	ldr	r2, [r3, #24]
 8005dd2:	4002      	ands	r2, r0
  /* Enable the RCC peripheral clock associated to all the selected GPIOs */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8005dd4:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005dd6:	9200      	str	r2, [sp, #0]
 8005dd8:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8005dda:	6959      	ldr	r1, [r3, #20]
 8005ddc:	0280      	lsls	r0, r0, #10
 8005dde:	4301      	orrs	r1, r0
 8005de0:	6159      	str	r1, [r3, #20]
 8005de2:	695a      	ldr	r2, [r3, #20]
 8005de4:	4002      	ands	r2, r0
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8005de6:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8005de8:	9201      	str	r2, [sp, #4]
 8005dea:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8005dec:	6959      	ldr	r1, [r3, #20]
 8005dee:	02c0      	lsls	r0, r0, #11
 8005df0:	4301      	orrs	r1, r0
 8005df2:	6159      	str	r1, [r3, #20]
 8005df4:	695a      	ldr	r2, [r3, #20]
 8005df6:	4002      	ands	r2, r0
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8005df8:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8005dfa:	9202      	str	r2, [sp, #8]
 8005dfc:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8005dfe:	6959      	ldr	r1, [r3, #20]
 8005e00:	0300      	lsls	r0, r0, #12
 8005e02:	4301      	orrs	r1, r0
 8005e04:	6159      	str	r1, [r3, #20]
 8005e06:	695a      	ldr	r2, [r3, #20]
 8005e08:	4002      	ands	r2, r0
#if defined(GPIOD)
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e0a:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8005e0c:	9203      	str	r2, [sp, #12]
 8005e0e:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e10:	6959      	ldr	r1, [r3, #20]
 8005e12:	0340      	lsls	r0, r0, #13
 8005e14:	4301      	orrs	r1, r0
 8005e16:	6159      	str	r1, [r3, #20]
#endif /* GPIOD */
#if defined(GPIOF)
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8005e18:	2180      	movs	r1, #128	; 0x80
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e1a:	695a      	ldr	r2, [r3, #20]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8005e1c:	03c9      	lsls	r1, r1, #15
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e1e:	4002      	ands	r2, r0
 8005e20:	9204      	str	r2, [sp, #16]
 8005e22:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8005e24:	695a      	ldr	r2, [r3, #20]
 8005e26:	430a      	orrs	r2, r1
 8005e28:	615a      	str	r2, [r3, #20]
 8005e2a:	695b      	ldr	r3, [r3, #20]
 8005e2c:	400b      	ands	r3, r1
 8005e2e:	9305      	str	r3, [sp, #20]
 8005e30:	9b05      	ldr	r3, [sp, #20]
#endif /* GPIOD */
}
 8005e32:	b006      	add	sp, #24
 8005e34:	4770      	bx	lr
 8005e36:	46c0      	nop			; (mov r8, r8)
 8005e38:	40021000 	.word	0x40021000

08005e3c <HAL_ADC_MspInit>:
  * @brief ADC MSP Initialization
  * @param hadc: ADC handle pointer
  * @retval None
  */
void HAL_ADC_MspInit(ADC_HandleTypeDef *hadc)
{
 8005e3c:	b513      	push	{r0, r1, r4, lr}
  /* Enable clock of ADCx peripheral */
  ADCx_CLK_ENABLE();
 8005e3e:	2180      	movs	r1, #128	; 0x80
 8005e40:	4c0a      	ldr	r4, [pc, #40]	; (8005e6c <HAL_ADC_MspInit+0x30>)
 8005e42:	0089      	lsls	r1, r1, #2
 8005e44:	69a2      	ldr	r2, [r4, #24]
 8005e46:	430a      	orrs	r2, r1
 8005e48:	61a2      	str	r2, [r4, #24]
 8005e4a:	69a3      	ldr	r3, [r4, #24]
 8005e4c:	400b      	ands	r3, r1
 8005e4e:	9300      	str	r3, [sp, #0]
 8005e50:	9b00      	ldr	r3, [sp, #0]
  PHY_HW_IF_ADCAnalogGPIO_Init();
 8005e52:	f003 fde7 	bl	8009a24 <PHY_HW_IF_ADCAnalogGPIO_Init>
  
  /* Enable clock of DMA associated to the peripheral */
  ADCx_DMA_CLK_ENABLE();
 8005e56:	2101      	movs	r1, #1
 8005e58:	6962      	ldr	r2, [r4, #20]
 8005e5a:	430a      	orrs	r2, r1
 8005e5c:	6162      	str	r2, [r4, #20]
 8005e5e:	6963      	ldr	r3, [r4, #20]
 8005e60:	400b      	ands	r3, r1
 8005e62:	9301      	str	r3, [sp, #4]
 8005e64:	9b01      	ldr	r3, [sp, #4]
  PHY_HW_IF_ADCDMA_Init();
 8005e66:	f003 fdfb 	bl	8009a60 <PHY_HW_IF_ADCDMA_Init>
}
 8005e6a:	bd13      	pop	{r0, r1, r4, pc}
 8005e6c:	40021000 	.word	0x40021000

08005e70 <HAL_SPI_MspInit>:
  * @brief SPI MSP Initialization
  * @param hspi: SPI handle pointer
  * @retval None
  */
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8005e70:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  
  uint8_t port_num = GET_PORT_FROM_SPI(hspi);
 8005e72:	4b38      	ldr	r3, [pc, #224]	; (8005f54 <HAL_SPI_MspInit+0xe4>)
 8005e74:	6804      	ldr	r4, [r0, #0]
  
  /* Peripheral clock enable */
  SPI_CLK_ENABLE(port_num);
 8005e76:	4e38      	ldr	r6, [pc, #224]	; (8005f58 <HAL_SPI_MspInit+0xe8>)
  uint8_t port_num = GET_PORT_FROM_SPI(hspi);
 8005e78:	18e5      	adds	r5, r4, r3
 8005e7a:	1e6b      	subs	r3, r5, #1
 8005e7c:	419d      	sbcs	r5, r3
{
 8005e7e:	b089      	sub	sp, #36	; 0x24
  uint8_t port_num = GET_PORT_FROM_SPI(hspi);
 8005e80:	b2ed      	uxtb	r5, r5
 8005e82:	4a36      	ldr	r2, [pc, #216]	; (8005f5c <HAL_SPI_MspInit+0xec>)
  SPI_CLK_ENABLE(port_num);
 8005e84:	42b4      	cmp	r4, r6
 8005e86:	d159      	bne.n	8005f3c <HAL_SPI_MspInit+0xcc>
 8005e88:	2380      	movs	r3, #128	; 0x80
 8005e8a:	69d1      	ldr	r1, [r2, #28]
 8005e8c:	01db      	lsls	r3, r3, #7
 8005e8e:	4319      	orrs	r1, r3
 8005e90:	61d1      	str	r1, [r2, #28]
 8005e92:	69d2      	ldr	r2, [r2, #28]
 8005e94:	401a      	ands	r2, r3
 8005e96:	9201      	str	r2, [sp, #4]
 8005e98:	9a01      	ldr	r2, [sp, #4]
  
  GPIO_InitStruct.Pin = SPI_MISO_PIN(port_num);
 8005e9a:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005e9c:	2203      	movs	r2, #3
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005e9e:	2300      	movs	r3, #0
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005ea0:	2702      	movs	r7, #2
  GPIO_InitStruct.Alternate = SPI_MISO_ALTERNATE(port_num);
  HAL_GPIO_Init(SPI_MISO_PORT(port_num), &GPIO_InitStruct);
 8005ea2:	a903      	add	r1, sp, #12
 8005ea4:	482e      	ldr	r0, [pc, #184]	; (8005f60 <HAL_SPI_MspInit+0xf0>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005ea6:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = SPI_MISO_ALTERNATE(port_num);
 8005ea8:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005eaa:	9704      	str	r7, [sp, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005eac:	9206      	str	r2, [sp, #24]
  HAL_GPIO_Init(SPI_MISO_PORT(port_num), &GPIO_InitStruct);
 8005eae:	f001 fca7 	bl	8007800 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = SPI_MOSI_PIN(port_num);
 8005eb2:	2320      	movs	r3, #32
 8005eb4:	42b4      	cmp	r4, r6
 8005eb6:	d101      	bne.n	8005ebc <HAL_SPI_MspInit+0x4c>
 8005eb8:	2380      	movs	r3, #128	; 0x80
 8005eba:	021b      	lsls	r3, r3, #8
 8005ebc:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005ebe:	2301      	movs	r3, #1
 8005ec0:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005ec2:	3302      	adds	r3, #2
 8005ec4:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Alternate = SPI_MOSI_ALTERNATE(port_num);
 8005ec6:	2300      	movs	r3, #0
  HAL_GPIO_Init(SPI_MOSI_PORT(port_num), &GPIO_InitStruct);
 8005ec8:	a903      	add	r1, sp, #12
 8005eca:	4825      	ldr	r0, [pc, #148]	; (8005f60 <HAL_SPI_MspInit+0xf0>)
  GPIO_InitStruct.Alternate = SPI_MOSI_ALTERNATE(port_num);
 8005ecc:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005ece:	9704      	str	r7, [sp, #16]
  HAL_GPIO_Init(SPI_MOSI_PORT(port_num), &GPIO_InitStruct);
 8005ed0:	f001 fc96 	bl	8007800 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = SPI_CLK_PIN(port_num);
 8005ed4:	2308      	movs	r3, #8
 8005ed6:	42b4      	cmp	r4, r6
 8005ed8:	d101      	bne.n	8005ede <HAL_SPI_MspInit+0x6e>
 8005eda:	2380      	movs	r3, #128	; 0x80
 8005edc:	019b      	lsls	r3, r3, #6
 8005ede:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005ee0:	2702      	movs	r7, #2
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005ee2:	2601      	movs	r6, #1
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005ee4:	2303      	movs	r3, #3
  GPIO_InitStruct.Alternate = SPI_CLK_ALTERNATE(port_num);
 8005ee6:	2200      	movs	r2, #0
  HAL_GPIO_Init(SPI_CLK_PORT(port_num), &GPIO_InitStruct);
 8005ee8:	a903      	add	r1, sp, #12
 8005eea:	481d      	ldr	r0, [pc, #116]	; (8005f60 <HAL_SPI_MspInit+0xf0>)
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005eec:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Alternate = SPI_CLK_ALTERNATE(port_num);
 8005eee:	9207      	str	r2, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005ef0:	9704      	str	r7, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005ef2:	9605      	str	r6, [sp, #20]
  HAL_GPIO_Init(SPI_CLK_PORT(port_num), &GPIO_InitStruct);
 8005ef4:	f001 fc84 	bl	8007800 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = SPI_NSS_PIN(port_num);
 8005ef8:	4916      	ldr	r1, [pc, #88]	; (8005f54 <HAL_SPI_MspInit+0xe4>)
 8005efa:	4b1a      	ldr	r3, [pc, #104]	; (8005f64 <HAL_SPI_MspInit+0xf4>)
 8005efc:	1864      	adds	r4, r4, r1
 8005efe:	4260      	negs	r0, r4
 8005f00:	4160      	adcs	r0, r4
 8005f02:	2180      	movs	r1, #128	; 0x80
 8005f04:	4240      	negs	r0, r0
 8005f06:	4003      	ands	r3, r0
 8005f08:	0209      	lsls	r1, r1, #8
 8005f0a:	185b      	adds	r3, r3, r1
 8005f0c:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005f0e:	2303      	movs	r3, #3
  GPIO_InitStruct.Alternate = SPI_NSS_ALTERNATE(port_num);
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f10:	2480      	movs	r4, #128	; 0x80
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005f12:	9306      	str	r3, [sp, #24]
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f14:	2390      	movs	r3, #144	; 0x90
  GPIO_InitStruct.Alternate = SPI_NSS_ALTERNATE(port_num);
 8005f16:	2200      	movs	r2, #0
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f18:	00e4      	lsls	r4, r4, #3
 8005f1a:	05db      	lsls	r3, r3, #23
 8005f1c:	4020      	ands	r0, r4
 8005f1e:	18c0      	adds	r0, r0, r3
 8005f20:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Alternate = SPI_NSS_ALTERNATE(port_num);
 8005f22:	9207      	str	r2, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005f24:	9704      	str	r7, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005f26:	9605      	str	r6, [sp, #20]
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f28:	f001 fc6a 	bl	8007800 <HAL_GPIO_Init>

  /* TX DMA Initialization */
  STUSB16xx_HW_IF_TX_DMA_Init(port_num);
 8005f2c:	0028      	movs	r0, r5
 8005f2e:	f004 fdd1 	bl	800aad4 <STUSB16xx_HW_IF_TX_DMA_Init>

  /* RX DMA Initialization */
  STUSB16xx_HW_IF_RX_DMA_Init(port_num);  
 8005f32:	0028      	movs	r0, r5
 8005f34:	f004 fe0a 	bl	800ab4c <STUSB16xx_HW_IF_RX_DMA_Init>
}
 8005f38:	b009      	add	sp, #36	; 0x24
 8005f3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  SPI_CLK_ENABLE(port_num);
 8005f3c:	2080      	movs	r0, #128	; 0x80
 8005f3e:	6991      	ldr	r1, [r2, #24]
 8005f40:	0140      	lsls	r0, r0, #5
 8005f42:	4301      	orrs	r1, r0
 8005f44:	6191      	str	r1, [r2, #24]
 8005f46:	6993      	ldr	r3, [r2, #24]
 8005f48:	4003      	ands	r3, r0
 8005f4a:	9302      	str	r3, [sp, #8]
 8005f4c:	9b02      	ldr	r3, [sp, #8]
  GPIO_InitStruct.Pin = SPI_MISO_PIN(port_num);
 8005f4e:	2310      	movs	r3, #16
 8005f50:	e7a3      	b.n	8005e9a <HAL_SPI_MspInit+0x2a>
 8005f52:	46c0      	nop			; (mov r8, r8)
 8005f54:	bfffc800 	.word	0xbfffc800
 8005f58:	40003800 	.word	0x40003800
 8005f5c:	40021000 	.word	0x40021000
 8005f60:	48000400 	.word	0x48000400
 8005f64:	ffff9000 	.word	0xffff9000

08005f68 <HAL_I2C_MspInit>:
{
  GPIO_InitTypeDef GPIO_InitStruct;

  uint8_t port_num = GET_PORT_FROM_I2C(hi2c);

  GPIO_InitStruct.Pin       = I2C_SCL_PIN(port_num)|I2C_SDA_PIN(port_num);
 8005f68:	23c0      	movs	r3, #192	; 0xc0
{
 8005f6a:	b510      	push	{r4, lr}
  GPIO_InitStruct.Pin       = I2C_SCL_PIN(port_num)|I2C_SDA_PIN(port_num);
 8005f6c:	011b      	lsls	r3, r3, #4
{
 8005f6e:	b088      	sub	sp, #32
  GPIO_InitStruct.Pin       = I2C_SCL_PIN(port_num)|I2C_SDA_PIN(port_num);
 8005f70:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode      = I2C_MODE(port_num);
 8005f72:	2312      	movs	r3, #18
 8005f74:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pull      = I2C_PULL(port_num);
 8005f76:	2300      	movs	r3, #0
 8005f78:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Speed     = I2C_SPEED(port_num);
 8005f7a:	3303      	adds	r3, #3
  uint8_t port_num = GET_PORT_FROM_I2C(hi2c);
 8005f7c:	6804      	ldr	r4, [r0, #0]
  GPIO_InitStruct.Speed     = I2C_SPEED(port_num);
 8005f7e:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Alternate = I2C_ALTERNATE(port_num);
  HAL_GPIO_Init(I2C_PORT(port_num), &GPIO_InitStruct);
 8005f80:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Alternate = I2C_ALTERNATE(port_num);
 8005f82:	3b02      	subs	r3, #2
  HAL_GPIO_Init(I2C_PORT(port_num), &GPIO_InitStruct);
 8005f84:	480e      	ldr	r0, [pc, #56]	; (8005fc0 <HAL_I2C_MspInit+0x58>)
  GPIO_InitStruct.Alternate = I2C_ALTERNATE(port_num);
 8005f86:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(I2C_PORT(port_num), &GPIO_InitStruct);
 8005f88:	f001 fc3a 	bl	8007800 <HAL_GPIO_Init>

  /* Peripheral clock enable */
  I2C_CLK_ENABLE(port_num);
 8005f8c:	4a0d      	ldr	r2, [pc, #52]	; (8005fc4 <HAL_I2C_MspInit+0x5c>)
 8005f8e:	4b0e      	ldr	r3, [pc, #56]	; (8005fc8 <HAL_I2C_MspInit+0x60>)
 8005f90:	4294      	cmp	r4, r2
 8005f92:	d10a      	bne.n	8005faa <HAL_I2C_MspInit+0x42>
 8005f94:	2180      	movs	r1, #128	; 0x80
 8005f96:	69da      	ldr	r2, [r3, #28]
 8005f98:	03c9      	lsls	r1, r1, #15
 8005f9a:	430a      	orrs	r2, r1
 8005f9c:	61da      	str	r2, [r3, #28]
 8005f9e:	69db      	ldr	r3, [r3, #28]
 8005fa0:	400b      	ands	r3, r1
 8005fa2:	9301      	str	r3, [sp, #4]
 8005fa4:	9b01      	ldr	r3, [sp, #4]
  UNUSED(port_num);
}
 8005fa6:	b008      	add	sp, #32
 8005fa8:	bd10      	pop	{r4, pc}
  I2C_CLK_ENABLE(port_num);
 8005faa:	2180      	movs	r1, #128	; 0x80
 8005fac:	69da      	ldr	r2, [r3, #28]
 8005fae:	0389      	lsls	r1, r1, #14
 8005fb0:	430a      	orrs	r2, r1
 8005fb2:	61da      	str	r2, [r3, #28]
 8005fb4:	69db      	ldr	r3, [r3, #28]
 8005fb6:	400b      	ands	r3, r1
 8005fb8:	9302      	str	r3, [sp, #8]
 8005fba:	9b02      	ldr	r3, [sp, #8]
}
 8005fbc:	e7f3      	b.n	8005fa6 <HAL_I2C_MspInit+0x3e>
 8005fbe:	46c0      	nop			; (mov r8, r8)
 8005fc0:	48000400 	.word	0x48000400
 8005fc4:	40005800 	.word	0x40005800
 8005fc8:	40021000 	.word	0x40021000

08005fcc <HAL_CRC_MspInit>:
  * @retval None
  */
void HAL_CRC_MspInit(CRC_HandleTypeDef *hcrc)
{
  /* CRC Peripheral clock enable */
  __HAL_RCC_CRC_CLK_ENABLE();
 8005fcc:	2040      	movs	r0, #64	; 0x40
 8005fce:	4a05      	ldr	r2, [pc, #20]	; (8005fe4 <HAL_CRC_MspInit+0x18>)
{
 8005fd0:	b082      	sub	sp, #8
  __HAL_RCC_CRC_CLK_ENABLE();
 8005fd2:	6951      	ldr	r1, [r2, #20]
 8005fd4:	4301      	orrs	r1, r0
 8005fd6:	6151      	str	r1, [r2, #20]
 8005fd8:	6953      	ldr	r3, [r2, #20]
 8005fda:	4003      	ands	r3, r0
 8005fdc:	9301      	str	r3, [sp, #4]
 8005fde:	9b01      	ldr	r3, [sp, #4]
}
 8005fe0:	b002      	add	sp, #8
 8005fe2:	4770      	bx	lr
 8005fe4:	40021000 	.word	0x40021000

08005fe8 <HAL_TIM_Base_MspInit>:
  * @param htim_base: TIM handle pointer
  * @retval None
  */
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
  uint8_t port_num = GET_PORT_FROM_TIM(htim_base);
 8005fe8:	6803      	ldr	r3, [r0, #0]
  if(IS_RX_COUNTTIM(htim_base))  /* RX COUNT TIMER IDENTIFIED */
 8005fea:	4a13      	ldr	r2, [pc, #76]	; (8006038 <HAL_TIM_Base_MspInit+0x50>)
{
 8005fec:	b513      	push	{r0, r1, r4, lr}
  if(IS_RX_COUNTTIM(htim_base))  /* RX COUNT TIMER IDENTIFIED */
 8005fee:	4293      	cmp	r3, r2
 8005ff0:	d113      	bne.n	800601a <HAL_TIM_Base_MspInit+0x32>
  {
    /* Peripheral clock enable */
    RX_COUNTTIM_CLK_ENABLE(port_num);
 8005ff2:	2080      	movs	r0, #128	; 0x80

    /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(RX_COUNTTIM_IRQN(port_num), RX_COUNTTIMIRQ_PRIO(port_num), 0);
 8005ff4:	2415      	movs	r4, #21
    RX_COUNTTIM_CLK_ENABLE(port_num);
 8005ff6:	4a11      	ldr	r2, [pc, #68]	; (800603c <HAL_TIM_Base_MspInit+0x54>)
 8005ff8:	0280      	lsls	r0, r0, #10
 8005ffa:	6991      	ldr	r1, [r2, #24]
 8005ffc:	4301      	orrs	r1, r0
 8005ffe:	6191      	str	r1, [r2, #24]
 8006000:	6993      	ldr	r3, [r2, #24]
 8006002:	4003      	ands	r3, r0
 8006004:	9300      	str	r3, [sp, #0]
 8006006:	9b00      	ldr	r3, [sp, #0]
    HAL_NVIC_SetPriority(RX_COUNTTIM_IRQN(port_num), RX_COUNTTIMIRQ_PRIO(port_num), 0);
 8006008:	0020      	movs	r0, r4
 800600a:	2200      	movs	r2, #0
 800600c:	2101      	movs	r1, #1
 800600e:	f001 fa1d 	bl	800744c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RX_COUNTTIM_IRQN(port_num));
 8006012:	0020      	movs	r0, r4
 8006014:	f001 fa44 	bl	80074a0 <HAL_NVIC_EnableIRQ>
  }
  UNUSED(port_num);
}
 8006018:	bd13      	pop	{r0, r1, r4, pc}
  if(IS_RX_COUNTTIM(htim_base))  /* RX COUNT TIMER IDENTIFIED */
 800601a:	4a09      	ldr	r2, [pc, #36]	; (8006040 <HAL_TIM_Base_MspInit+0x58>)
 800601c:	4293      	cmp	r3, r2
 800601e:	d1fb      	bne.n	8006018 <HAL_TIM_Base_MspInit+0x30>
    RX_COUNTTIM_CLK_ENABLE(port_num);
 8006020:	2080      	movs	r0, #128	; 0x80
 8006022:	4a06      	ldr	r2, [pc, #24]	; (800603c <HAL_TIM_Base_MspInit+0x54>)
 8006024:	02c0      	lsls	r0, r0, #11
 8006026:	6991      	ldr	r1, [r2, #24]
    HAL_NVIC_SetPriority(RX_COUNTTIM_IRQN(port_num), RX_COUNTTIMIRQ_PRIO(port_num), 0);
 8006028:	2416      	movs	r4, #22
    RX_COUNTTIM_CLK_ENABLE(port_num);
 800602a:	4301      	orrs	r1, r0
 800602c:	6191      	str	r1, [r2, #24]
 800602e:	6993      	ldr	r3, [r2, #24]
 8006030:	4003      	ands	r3, r0
 8006032:	9301      	str	r3, [sp, #4]
 8006034:	9b01      	ldr	r3, [sp, #4]
 8006036:	e7e7      	b.n	8006008 <HAL_TIM_Base_MspInit+0x20>
 8006038:	40014400 	.word	0x40014400
 800603c:	40021000 	.word	0x40021000
 8006040:	40014800 	.word	0x40014800

08006044 <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
 8006044:	4770      	bx	lr

08006046 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8006046:	e7fe      	b.n	8006046 <HardFault_Handler>

08006048 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 8006048:	b510      	push	{r4, lr}
  HAL_IncTick();
 800604a:	f000 ff85 	bl	8006f58 <HAL_IncTick>
  USBPD_DPM_TimerCounter();
 800604e:	f003 f8c1 	bl	80091d4 <USBPD_DPM_TimerCounter>
}
 8006052:	bd10      	pop	{r4, pc}

08006054 <EXTI0_1_IRQHandler>:
  * @brief  This function handles EXTI line 4_15 interrupts.
  * @param  None
  * @retval None
  */
void EXTI0_1_IRQHandler(void)
{
 8006054:	b510      	push	{r4, lr}
  HAL_GPIO_EXTI_IRQHandler(ALERT_GPIO_PIN(0));
 8006056:	2002      	movs	r0, #2
 8006058:	f001 fc9e 	bl	8007998 <HAL_GPIO_EXTI_IRQHandler>
}
 800605c:	bd10      	pop	{r4, pc}

0800605e <EXTI2_3_IRQHandler>:
  * @brief  This function handles EXTI line 2 to 3 interrupts.
  * @param  None
  * @retval None
  */
void EXTI2_3_IRQHandler(void)
{  
 800605e:	b510      	push	{r4, lr}
  HAL_GPIO_EXTI_IRQHandler(ALERT_GPIO_PIN(1));
 8006060:	2004      	movs	r0, #4
 8006062:	f001 fc99 	bl	8007998 <HAL_GPIO_EXTI_IRQHandler>
  
}
 8006066:	bd10      	pop	{r4, pc}

08006068 <EXTI4_15_IRQHandler>:
  * @param  None
  * @retval None
  */
void EXTI4_15_IRQHandler(void)
{
  HAL_GPIO_EXTI_IRQHandler(USER_BUTTON_PIN);
 8006068:	2080      	movs	r0, #128	; 0x80
{
 800606a:	b510      	push	{r4, lr}
  HAL_GPIO_EXTI_IRQHandler(USER_BUTTON_PIN);
 800606c:	0180      	lsls	r0, r0, #6
 800606e:	f001 fc93 	bl	8007998 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(SPI_NSS_PIN(0));
 8006072:	2080      	movs	r0, #128	; 0x80
 8006074:	0140      	lsls	r0, r0, #5
 8006076:	f001 fc8f 	bl	8007998 <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(SPI_NSS_PIN(1));
 800607a:	2080      	movs	r0, #128	; 0x80
 800607c:	0200      	lsls	r0, r0, #8
 800607e:	f001 fc8b 	bl	8007998 <HAL_GPIO_EXTI_IRQHandler>
}
 8006082:	bd10      	pop	{r4, pc}

08006084 <DMA1_Channel4_5_6_7_IRQHandler>:
  * @brief  This function handles DMA Channel 4 to 7 interrupts.
  * @param  None
  * @retval None
  */
void DMA1_Channel4_5_6_7_IRQHandler(void)
{
 8006084:	b510      	push	{r4, lr}
  USBPD_DMA_PORT0_IRQHandler();
 8006086:	f003 f90b 	bl	80092a0 <USBPD_DMA_PORT0_IRQHandler>
}
 800608a:	bd10      	pop	{r4, pc}

0800608c <TIM16_IRQHandler>:
  * @brief  This function handles TIM6 interrupt.
  * @param  None
  * @retval None
  */
void TIM16_IRQHandler(void)
{
 800608c:	b510      	push	{r4, lr}
  USBPD_RX_PORT0_COUNTTIM_IRQHandler();
 800608e:	f003 f98f 	bl	80093b0 <USBPD_RX_PORT0_COUNTTIM_IRQHandler>
}
 8006092:	bd10      	pop	{r4, pc}

08006094 <DPM_AssertRp>:
  * @brief  Assert Rp resistor.
  * @param  PortNum The current port number
  * @retval None
  */
static void DPM_AssertRp(uint8_t PortNum)
{
 8006094:	b510      	push	{r4, lr}
 8006096:	0004      	movs	r4, r0
  USBPD_CAD_AssertRp(PortNum);
 8006098:	f7fa f8d4 	bl	8000244 <USBPD_CAD_AssertRp>

  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT1_ROLE) , LED_MODE_BLINK_ROLE_SRC, 0);
 800609c:	2001      	movs	r0, #1
 800609e:	2c00      	cmp	r4, #0
 80060a0:	d000      	beq.n	80060a4 <DPM_AssertRp+0x10>
 80060a2:	3003      	adds	r0, #3
 80060a4:	2200      	movs	r2, #0
 80060a6:	2104      	movs	r1, #4
 80060a8:	f006 f932 	bl	800c310 <Led_Set>
}
 80060ac:	bd10      	pop	{r4, pc}

080060ae <DPM_TurnOffPower.isra.0>:
static USBPD_StatusTypeDef DPM_TurnOffPower(uint8_t PortNum, USBPD_PortPowerRole_TypeDef Role)
 80060ae:	b570      	push	{r4, r5, r6, lr}
 80060b0:	0004      	movs	r4, r0
  status = USBPD_PWR_IF_VBUSDisable(PortNum);
 80060b2:	f000 fb4f 	bl	8006754 <USBPD_PWR_IF_VBUSDisable>
 80060b6:	0005      	movs	r5, r0
  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT1_VBUS) , LED_MODE_OFF, 0);
 80060b8:	2002      	movs	r0, #2
 80060ba:	2c00      	cmp	r4, #0
 80060bc:	d000      	beq.n	80060c0 <DPM_TurnOffPower.isra.0+0x12>
 80060be:	3003      	adds	r0, #3
 80060c0:	2200      	movs	r2, #0
 80060c2:	0011      	movs	r1, r2
 80060c4:	f006 f924 	bl	800c310 <Led_Set>
}
 80060c8:	0028      	movs	r0, r5
 80060ca:	bd70      	pop	{r4, r5, r6, pc}

080060cc <USBPD_DPM_UserInit>:
{
 80060cc:	b5f0      	push	{r4, r5, r6, r7, lr}
          ((DPM_Settings[USBPD_PORT_0].PE_DefaultRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC),
 80060ce:	2404      	movs	r4, #4
{
 80060d0:	b089      	sub	sp, #36	; 0x24
  Led_Init();
 80060d2:	f006 f907 	bl	800c2e4 <Led_Init>
          ((DPM_Settings[USBPD_PORT_0].PE_DefaultRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC),
 80060d6:	4b17      	ldr	r3, [pc, #92]	; (8006134 <USBPD_DPM_UserInit+0x68>)
  Led_Set(LED_PORT0_ROLE,
 80060d8:	2200      	movs	r2, #0
 80060da:	7919      	ldrb	r1, [r3, #4]
 80060dc:	2001      	movs	r0, #1
 80060de:	4021      	ands	r1, r4
 80060e0:	424b      	negs	r3, r1
 80060e2:	4159      	adcs	r1, r3
 80060e4:	1909      	adds	r1, r1, r4
 80060e6:	f006 f913 	bl	800c310 <Led_Set>
  Led_Set(LED_PORT1_ROLE, LED_MODE_OFF, 0);
 80060ea:	2200      	movs	r2, #0
 80060ec:	0020      	movs	r0, r4
 80060ee:	0011      	movs	r1, r2
 80060f0:	f006 f90e 	bl	800c310 <Led_Set>
  USBPD_PWR_IF_Init();
 80060f4:	f000 fad0 	bl	8006698 <USBPD_PWR_IF_Init>
  if(USBPD_OK != USBPD_PWR_IF_PowerResetGlobal()) return USBPD_ERROR;
 80060f8:	f000 fafe 	bl	80066f8 <USBPD_PWR_IF_PowerResetGlobal>
 80060fc:	1e05      	subs	r5, r0, #0
 80060fe:	d003      	beq.n	8006108 <USBPD_DPM_UserInit+0x3c>
 8006100:	2502      	movs	r5, #2
}
 8006102:	0028      	movs	r0, r5
 8006104:	b009      	add	sp, #36	; 0x24
 8006106:	bdf0      	pop	{r4, r5, r6, r7, pc}
  osMessageQDef(MsgBox, DPM_BOX_MESSAGES_MAX, uint32_t);
 8006108:	a801      	add	r0, sp, #4
 800610a:	0003      	movs	r3, r0
 800610c:	4c0a      	ldr	r4, [pc, #40]	; (8006138 <USBPD_DPM_UserInit+0x6c>)
 800610e:	cc06      	ldmia	r4!, {r1, r2}
 8006110:	c306      	stmia	r3!, {r1, r2}
  DPMMsgBox = osMessageCreate(osMessageQ(MsgBox), NULL);
 8006112:	0029      	movs	r1, r5
 8006114:	f005 f92d 	bl	800b372 <osMessageCreate>
 8006118:	4908      	ldr	r1, [pc, #32]	; (800613c <USBPD_DPM_UserInit+0x70>)
 800611a:	6008      	str	r0, [r1, #0]
  osThreadDef(DPM, USBPD_DPM_UserExecute, osPriorityLow, 0, 120);
 800611c:	a803      	add	r0, sp, #12
 800611e:	0003      	movs	r3, r0
 8006120:	ccc4      	ldmia	r4!, {r2, r6, r7}
 8006122:	c3c4      	stmia	r3!, {r2, r6, r7}
 8006124:	cc44      	ldmia	r4!, {r2, r6}
 8006126:	c344      	stmia	r3!, {r2, r6}
  if(NULL == osThreadCreate(osThread(DPM), &DPMMsgBox))
 8006128:	f005 f8fd 	bl	800b326 <osThreadCreate>
 800612c:	2800      	cmp	r0, #0
 800612e:	d1e8      	bne.n	8006102 <USBPD_DPM_UserInit+0x36>
 8006130:	e7e6      	b.n	8006100 <USBPD_DPM_UserInit+0x34>
 8006132:	46c0      	nop			; (mov r8, r8)
 8006134:	0800c68c 	.word	0x0800c68c
 8006138:	0800c62c 	.word	0x0800c62c
 800613c:	20001a14 	.word	0x20001a14

08006140 <USBPD_DPM_UserTimerCounter>:
  if((DPM_Ports[PortNum].DPM_TimerSRCExtendedCapa & DPM_TIMER_READ_MSK) > 0)
 8006140:	2388      	movs	r3, #136	; 0x88
 8006142:	4343      	muls	r3, r0
 8006144:	4805      	ldr	r0, [pc, #20]	; (800615c <USBPD_DPM_UserTimerCounter+0x1c>)
 8006146:	18c0      	adds	r0, r0, r3
 8006148:	306a      	adds	r0, #106	; 0x6a
 800614a:	8803      	ldrh	r3, [r0, #0]
 800614c:	045b      	lsls	r3, r3, #17
 800614e:	d003      	beq.n	8006158 <USBPD_DPM_UserTimerCounter+0x18>
    DPM_Ports[PortNum].DPM_TimerSRCExtendedCapa--;
 8006150:	8803      	ldrh	r3, [r0, #0]
 8006152:	3b01      	subs	r3, #1
 8006154:	b29b      	uxth	r3, r3
 8006156:	8003      	strh	r3, [r0, #0]
}
 8006158:	4770      	bx	lr
 800615a:	46c0      	nop			; (mov r8, r8)
 800615c:	200002e8 	.word	0x200002e8

08006160 <USBPD_DPM_UserCableDetection>:
{
 8006160:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006162:	0004      	movs	r4, r0
 8006164:	4e55      	ldr	r6, [pc, #340]	; (80062bc <USBPD_DPM_UserCableDetection+0x15c>)
 8006166:	00c5      	lsls	r5, r0, #3
  switch(State)
 8006168:	2904      	cmp	r1, #4
 800616a:	d016      	beq.n	800619a <USBPD_DPM_UserCableDetection+0x3a>
 800616c:	2907      	cmp	r1, #7
 800616e:	d054      	beq.n	800621a <USBPD_DPM_UserCableDetection+0xba>
 8006170:	2902      	cmp	r1, #2
 8006172:	d000      	beq.n	8006176 <USBPD_DPM_UserCableDetection+0x16>
 8006174:	e076      	b.n	8006264 <USBPD_DPM_UserCableDetection+0x104>
    if(USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 8006176:	5d73      	ldrb	r3, [r6, r5]
 8006178:	075b      	lsls	r3, r3, #29
 800617a:	d511      	bpl.n	80061a0 <USBPD_DPM_UserCableDetection+0x40>
      if (USBPD_OK != USBPD_PWR_IF_VBUSEnable(PortNum))
 800617c:	f000 fad6 	bl	800672c <USBPD_PWR_IF_VBUSEnable>
 8006180:	2800      	cmp	r0, #0
 8006182:	d149      	bne.n	8006218 <USBPD_DPM_UserCableDetection+0xb8>
 8006184:	0027      	movs	r7, r4
 8006186:	1e7b      	subs	r3, r7, #1
 8006188:	419f      	sbcs	r7, r3
 800618a:	3728      	adds	r7, #40	; 0x28
      while (STUSB1602_VBUS_Valid_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_within_VALID_vrange)
 800618c:	0038      	movs	r0, r7
 800618e:	f000 fba5 	bl	80068dc <STUSB1602_VBUS_Valid_Get>
 8006192:	2801      	cmp	r0, #1
 8006194:	d004      	beq.n	80061a0 <USBPD_DPM_UserCableDetection+0x40>
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 8006196:	46c0      	nop			; (mov r8, r8)
 8006198:	e7f8      	b.n	800618c <USBPD_DPM_UserCableDetection+0x2c>
    if(USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 800619a:	5d73      	ldrb	r3, [r6, r5]
 800619c:	075b      	lsls	r3, r3, #29
 800619e:	d42b      	bmi.n	80061f8 <USBPD_DPM_UserCableDetection+0x98>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_CC : LED_PORT1_CC) , (DPM_Params[PortNum].ActiveCCIs == CC1 ? LED_MODE_BLINK_CC1 : LED_MODE_BLINK_CC2), 0);
 80061a0:	2006      	movs	r0, #6
 80061a2:	2c00      	cmp	r4, #0
 80061a4:	d100      	bne.n	80061a8 <USBPD_DPM_UserCableDetection+0x48>
 80061a6:	3803      	subs	r0, #3
 80061a8:	1973      	adds	r3, r6, r5
 80061aa:	7859      	ldrb	r1, [r3, #1]
 80061ac:	2200      	movs	r2, #0
 80061ae:	0789      	lsls	r1, r1, #30
 80061b0:	0f89      	lsrs	r1, r1, #30
 80061b2:	3901      	subs	r1, #1
 80061b4:	1e4b      	subs	r3, r1, #1
 80061b6:	4199      	sbcs	r1, r3
 80061b8:	3108      	adds	r1, #8
 80061ba:	f006 f8a9 	bl	800c310 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT1_VBUS) , LED_MODE_BLINK_VBUS, 0);
 80061be:	2005      	movs	r0, #5
 80061c0:	2c00      	cmp	r4, #0
 80061c2:	d100      	bne.n	80061c6 <USBPD_DPM_UserCableDetection+0x66>
 80061c4:	3803      	subs	r0, #3
 80061c6:	2200      	movs	r2, #0
 80061c8:	2107      	movs	r1, #7
 80061ca:	f006 f8a1 	bl	800c310 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT1_ROLE) , ((DPM_Params[PortNum].PE_PowerRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC), 0);
 80061ce:	2004      	movs	r0, #4
 80061d0:	2c00      	cmp	r4, #0
 80061d2:	d100      	bne.n	80061d6 <USBPD_DPM_UserCableDetection+0x76>
 80061d4:	3803      	subs	r0, #3
 80061d6:	5d71      	ldrb	r1, [r6, r5]
 80061d8:	2200      	movs	r2, #0
 80061da:	0749      	lsls	r1, r1, #29
 80061dc:	0fc9      	lsrs	r1, r1, #31
 80061de:	424b      	negs	r3, r1
 80061e0:	4159      	adcs	r1, r3
 80061e2:	3104      	adds	r1, #4
 80061e4:	f006 f894 	bl	800c310 <Led_Set>
    DPM_Ports[PortNum].DPM_IsConnected = 1;
 80061e8:	2388      	movs	r3, #136	; 0x88
 80061ea:	4363      	muls	r3, r4
 80061ec:	4c34      	ldr	r4, [pc, #208]	; (80062c0 <USBPD_DPM_UserCableDetection+0x160>)
 80061ee:	18e4      	adds	r4, r4, r3
 80061f0:	2301      	movs	r3, #1
 80061f2:	3464      	adds	r4, #100	; 0x64
 80061f4:	7023      	strb	r3, [r4, #0]
}
 80061f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (USBPD_OK != USBPD_PWR_IF_VBUSEnable(PortNum))
 80061f8:	f000 fa98 	bl	800672c <USBPD_PWR_IF_VBUSEnable>
 80061fc:	2800      	cmp	r0, #0
 80061fe:	d10a      	bne.n	8006216 <USBPD_DPM_UserCableDetection+0xb6>
 8006200:	0027      	movs	r7, r4
 8006202:	1e7b      	subs	r3, r7, #1
 8006204:	419f      	sbcs	r7, r3
 8006206:	3728      	adds	r7, #40	; 0x28
      while (STUSB1602_VBUS_Valid_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_within_VALID_vrange)
 8006208:	0038      	movs	r0, r7
 800620a:	f000 fb67 	bl	80068dc <STUSB1602_VBUS_Valid_Get>
 800620e:	2801      	cmp	r0, #1
 8006210:	d0c6      	beq.n	80061a0 <USBPD_DPM_UserCableDetection+0x40>
 8006212:	46c0      	nop			; (mov r8, r8)
 8006214:	e7f8      	b.n	8006208 <USBPD_DPM_UserCableDetection+0xa8>
 8006216:	e7fe      	b.n	8006216 <USBPD_DPM_UserCableDetection+0xb6>
 8006218:	e7fe      	b.n	8006218 <USBPD_DPM_UserCableDetection+0xb8>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_CC : LED_PORT1_CC) , (DPM_Params[PortNum].ActiveCCIs == CC1 ? LED_MODE_BLINK_CC1 : LED_MODE_BLINK_CC2), 0);
 800621a:	2006      	movs	r0, #6
 800621c:	2c00      	cmp	r4, #0
 800621e:	d100      	bne.n	8006222 <USBPD_DPM_UserCableDetection+0xc2>
 8006220:	3803      	subs	r0, #3
 8006222:	1973      	adds	r3, r6, r5
 8006224:	7859      	ldrb	r1, [r3, #1]
 8006226:	2200      	movs	r2, #0
 8006228:	0789      	lsls	r1, r1, #30
 800622a:	0f89      	lsrs	r1, r1, #30
 800622c:	3901      	subs	r1, #1
 800622e:	1e4b      	subs	r3, r1, #1
 8006230:	4199      	sbcs	r1, r3
 8006232:	3108      	adds	r1, #8
 8006234:	f006 f86c 	bl	800c310 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT1_VBUS) , LED_MODE_BLINK_VBUS, 0);
 8006238:	2005      	movs	r0, #5
 800623a:	2c00      	cmp	r4, #0
 800623c:	d100      	bne.n	8006240 <USBPD_DPM_UserCableDetection+0xe0>
 800623e:	3803      	subs	r0, #3
 8006240:	2200      	movs	r2, #0
 8006242:	2107      	movs	r1, #7
 8006244:	f006 f864 	bl	800c310 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT1_ROLE) , ((DPM_Params[PortNum].PE_PowerRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC), 0);
 8006248:	2004      	movs	r0, #4
 800624a:	2c00      	cmp	r4, #0
 800624c:	d100      	bne.n	8006250 <USBPD_DPM_UserCableDetection+0xf0>
 800624e:	3803      	subs	r0, #3
 8006250:	5d71      	ldrb	r1, [r6, r5]
            ((DPM_Settings[PortNum].PE_DefaultRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC),
 8006252:	0749      	lsls	r1, r1, #29
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT1_ROLE),
 8006254:	0fc9      	lsrs	r1, r1, #31
 8006256:	424b      	negs	r3, r1
 8006258:	4159      	adcs	r1, r3
 800625a:	2200      	movs	r2, #0
 800625c:	3104      	adds	r1, #4
 800625e:	f006 f857 	bl	800c310 <Led_Set>
}
 8006262:	e7c8      	b.n	80061f6 <USBPD_DPM_UserCableDetection+0x96>
    memset(&DPM_Ports[PortNum], 0, sizeof(DPM_Ports[PortNum]));
 8006264:	2288      	movs	r2, #136	; 0x88
 8006266:	0010      	movs	r0, r2
 8006268:	4360      	muls	r0, r4
 800626a:	4b15      	ldr	r3, [pc, #84]	; (80062c0 <USBPD_DPM_UserCableDetection+0x160>)
 800626c:	2100      	movs	r1, #0
 800626e:	18c0      	adds	r0, r0, r3
 8006270:	f006 f945 	bl	800c4fe <memset>
    if(USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 8006274:	5d73      	ldrb	r3, [r6, r5]
 8006276:	075b      	lsls	r3, r3, #29
 8006278:	d505      	bpl.n	8006286 <USBPD_DPM_UserCableDetection+0x126>
      if (USBPD_OK != USBPD_PWR_IF_VBUSDisable(PortNum))
 800627a:	0020      	movs	r0, r4
 800627c:	f000 fa6a 	bl	8006754 <USBPD_PWR_IF_VBUSDisable>
 8006280:	2800      	cmp	r0, #0
 8006282:	d000      	beq.n	8006286 <USBPD_DPM_UserCableDetection+0x126>
 8006284:	e7fe      	b.n	8006284 <USBPD_DPM_UserCableDetection+0x124>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_CC : LED_PORT1_CC) , LED_MODE_OFF, 0);
 8006286:	2006      	movs	r0, #6
 8006288:	2c00      	cmp	r4, #0
 800628a:	d100      	bne.n	800628e <USBPD_DPM_UserCableDetection+0x12e>
 800628c:	3803      	subs	r0, #3
 800628e:	2200      	movs	r2, #0
 8006290:	0011      	movs	r1, r2
 8006292:	f006 f83d 	bl	800c310 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT1_VBUS) , LED_MODE_OFF, 0);
 8006296:	2005      	movs	r0, #5
 8006298:	2c00      	cmp	r4, #0
 800629a:	d100      	bne.n	800629e <USBPD_DPM_UserCableDetection+0x13e>
 800629c:	3803      	subs	r0, #3
 800629e:	2200      	movs	r2, #0
 80062a0:	0011      	movs	r1, r2
 80062a2:	f006 f835 	bl	800c310 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT1_ROLE),
 80062a6:	2004      	movs	r0, #4
 80062a8:	2c00      	cmp	r4, #0
 80062aa:	d100      	bne.n	80062ae <USBPD_DPM_UserCableDetection+0x14e>
 80062ac:	3803      	subs	r0, #3
            ((DPM_Settings[PortNum].PE_DefaultRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC),
 80062ae:	230c      	movs	r3, #12
 80062b0:	4363      	muls	r3, r4
 80062b2:	4c04      	ldr	r4, [pc, #16]	; (80062c4 <USBPD_DPM_UserCableDetection+0x164>)
 80062b4:	18e4      	adds	r4, r4, r3
 80062b6:	7921      	ldrb	r1, [r4, #4]
 80062b8:	e7cb      	b.n	8006252 <USBPD_DPM_UserCableDetection+0xf2>
 80062ba:	46c0      	nop			; (mov r8, r8)
 80062bc:	20001bc0 	.word	0x20001bc0
 80062c0:	200002e8 	.word	0x200002e8
 80062c4:	0800c68c 	.word	0x0800c68c

080062c8 <USBPD_DPM_HardReset>:
{
 80062c8:	b570      	push	{r4, r5, r6, lr}
 80062ca:	0004      	movs	r4, r0
 80062cc:	000d      	movs	r5, r1
  switch(Status)
 80062ce:	2a06      	cmp	r2, #6
 80062d0:	d813      	bhi.n	80062fa <USBPD_DPM_HardReset+0x32>
 80062d2:	0010      	movs	r0, r2
 80062d4:	f7ff fb64 	bl	80059a0 <__gnu_thumb1_case_uqi>
 80062d8:	11111204 	.word	0x11111204
 80062dc:	2819      	.short	0x2819
 80062de:	44          	.byte	0x44
 80062df:	00          	.byte	0x00
    if (USBPD_PORTPOWERROLE_SRC == CurrentRole)
 80062e0:	2901      	cmp	r1, #1
 80062e2:	d102      	bne.n	80062ea <USBPD_DPM_HardReset+0x22>
      DPM_AssertRp(PortNum);
 80062e4:	0020      	movs	r0, r4
 80062e6:	f7ff fed5 	bl	8006094 <DPM_AssertRp>
    USBPD_HW_IF_HR_Start(PortNum, CurrentRole, ACKNOWLEDGE);
 80062ea:	2200      	movs	r2, #0
    USBPD_HW_IF_HR_Start(PortNum, CurrentRole, REQUEST);
 80062ec:	0029      	movs	r1, r5
 80062ee:	0020      	movs	r0, r4
 80062f0:	f003 ffea 	bl	800a2c8 <USBPD_HW_IF_HR_Start>
    DPM_TurnOffPower(PortNum, CurrentRole);
 80062f4:	0020      	movs	r0, r4
 80062f6:	f7ff feda 	bl	80060ae <DPM_TurnOffPower.isra.0>
}
 80062fa:	bd70      	pop	{r4, r5, r6, pc}
    if (USBPD_PORTPOWERROLE_SRC == CurrentRole)
 80062fc:	2901      	cmp	r1, #1
 80062fe:	d102      	bne.n	8006306 <USBPD_DPM_HardReset+0x3e>
      DPM_AssertRp(PortNum);
 8006300:	0020      	movs	r0, r4
 8006302:	f7ff fec7 	bl	8006094 <DPM_AssertRp>
    USBPD_HW_IF_HR_Start(PortNum, CurrentRole, REQUEST);
 8006306:	2201      	movs	r2, #1
 8006308:	e7f0      	b.n	80062ec <USBPD_DPM_HardReset+0x24>
    USBPD_HW_IF_HR_CheckVbusVSafe0V(PortNum, CurrentRole);
 800630a:	0020      	movs	r0, r4
 800630c:	f004 f830 	bl	800a370 <USBPD_HW_IF_HR_CheckVbusVSafe0V>
    if (CurrentRole == USBPD_PORTPOWERROLE_SNK)
 8006310:	2d00      	cmp	r5, #0
 8006312:	d1f2      	bne.n	80062fa <USBPD_DPM_HardReset+0x32>
 8006314:	1e63      	subs	r3, r4, #1
 8006316:	419c      	sbcs	r4, r3
 8006318:	3428      	adds	r4, #40	; 0x28
      while (STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_below_VSAFE0V_threshold)
 800631a:	0020      	movs	r0, r4
 800631c:	f000 faea 	bl	80068f4 <STUSB1602_VBUS_VSAFE0V_Get>
 8006320:	2801      	cmp	r0, #1
 8006322:	d0ea      	beq.n	80062fa <USBPD_DPM_HardReset+0x32>
 8006324:	46c0      	nop			; (mov r8, r8)
 8006326:	e7f8      	b.n	800631a <USBPD_DPM_HardReset+0x52>
    USBPD_HW_IF_HR_End(PortNum, CurrentRole);
 8006328:	0020      	movs	r0, r4
 800632a:	f004 f833 	bl	800a394 <USBPD_HW_IF_HR_End>
  status = USBPD_PWR_IF_VBUSEnable(PortNum);
 800632e:	0020      	movs	r0, r4
 8006330:	f000 f9fc 	bl	800672c <USBPD_PWR_IF_VBUSEnable>
  if(USBPD_PORTPOWERROLE_SRC == Role)
 8006334:	2d01      	cmp	r5, #1
 8006336:	d008      	beq.n	800634a <USBPD_DPM_HardReset+0x82>
  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT1_VBUS) , LED_MODE_BLINK_VBUS, 0);
 8006338:	2002      	movs	r0, #2
 800633a:	2c00      	cmp	r4, #0
 800633c:	d000      	beq.n	8006340 <USBPD_DPM_HardReset+0x78>
 800633e:	3003      	adds	r0, #3
 8006340:	2200      	movs	r2, #0
 8006342:	2107      	movs	r1, #7
 8006344:	f005 ffe4 	bl	800c310 <Led_Set>
 8006348:	e7d7      	b.n	80062fa <USBPD_DPM_HardReset+0x32>
 800634a:	0025      	movs	r5, r4
 800634c:	1e6b      	subs	r3, r5, #1
 800634e:	419d      	sbcs	r5, r3
 8006350:	3528      	adds	r5, #40	; 0x28
    while (STUSB1602_VBUS_Valid_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_within_VALID_vrange)
 8006352:	0028      	movs	r0, r5
 8006354:	f000 fac2 	bl	80068dc <STUSB1602_VBUS_Valid_Get>
 8006358:	2801      	cmp	r0, #1
 800635a:	d0ed      	beq.n	8006338 <USBPD_DPM_HardReset+0x70>
 800635c:	46c0      	nop			; (mov r8, r8)
 800635e:	e7f8      	b.n	8006352 <USBPD_DPM_HardReset+0x8a>
    USBPD_HW_IF_HR_End(PortNum, CurrentRole);
 8006360:	0020      	movs	r0, r4
 8006362:	f004 f817 	bl	800a394 <USBPD_HW_IF_HR_End>
}
 8006366:	e7c8      	b.n	80062fa <USBPD_DPM_HardReset+0x32>

08006368 <USBPD_DPM_SetupNewPower>:
  rdoposition = DPM_Ports[PortNum].DPM_RDOPosition;
 8006368:	2288      	movs	r2, #136	; 0x88
 800636a:	4342      	muls	r2, r0
 800636c:	4b06      	ldr	r3, [pc, #24]	; (8006388 <USBPD_DPM_SetupNewPower+0x20>)
{
 800636e:	b510      	push	{r4, lr}
  rdoposition = DPM_Ports[PortNum].DPM_RDOPosition;
 8006370:	189b      	adds	r3, r3, r2
 8006372:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006374:	b2d1      	uxtb	r1, r2
    status = USBPD_PWR_IF_SetProfile(PortNum, 0, 0);
 8006376:	1e0a      	subs	r2, r1, #0
  if (rdoposition > 0)
 8006378:	d003      	beq.n	8006382 <USBPD_DPM_SetupNewPower+0x1a>
  previous_rdoposition = DPM_Ports[PortNum].DPM_RDOPositionPrevious;
 800637a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    status = USBPD_PWR_IF_SetProfile(PortNum, rdoposition-1, previous_rdoposition);
 800637c:	3901      	subs	r1, #1
 800637e:	b2d2      	uxtb	r2, r2
 8006380:	b2c9      	uxtb	r1, r1
    status = USBPD_PWR_IF_SetProfile(PortNum, 0, 0);
 8006382:	f000 f995 	bl	80066b0 <USBPD_PWR_IF_SetProfile>
}
 8006386:	bd10      	pop	{r4, pc}
 8006388:	200002e8 	.word	0x200002e8

0800638c <USBPD_DPM_EvaluatePowerRoleSwap>:
}
 800638c:	200a      	movs	r0, #10
 800638e:	4770      	bx	lr

08006390 <USBPD_DPM_Notification>:
{
 8006390:	b510      	push	{r4, lr}
  switch(EventVal)
 8006392:	2910      	cmp	r1, #16
 8006394:	d108      	bne.n	80063a8 <USBPD_DPM_Notification+0x18>
      Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT1_VBUS) , LED_MODE_ON, 0);
 8006396:	2302      	movs	r3, #2
 8006398:	2800      	cmp	r0, #0
 800639a:	d000      	beq.n	800639e <USBPD_DPM_Notification+0xe>
 800639c:	3303      	adds	r3, #3
 800639e:	2200      	movs	r2, #0
 80063a0:	2101      	movs	r1, #1
 80063a2:	0018      	movs	r0, r3
 80063a4:	f005 ffb4 	bl	800c310 <Led_Set>
}
 80063a8:	bd10      	pop	{r4, pc}

080063aa <USBPD_DPM_IsContractStillValid>:
}
 80063aa:	2000      	movs	r0, #0
 80063ac:	4770      	bx	lr
	...

080063b0 <USBPD_DPM_GetDataInfo>:
{
 80063b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80063b2:	0005      	movs	r5, r0
 80063b4:	0016      	movs	r6, r2
 80063b6:	001c      	movs	r4, r3
  switch (DataId)
 80063b8:	290d      	cmp	r1, #13
 80063ba:	d866      	bhi.n	800648a <USBPD_DPM_GetDataInfo+0xda>
 80063bc:	0008      	movs	r0, r1
 80063be:	f7ff faef 	bl	80059a0 <__gnu_thumb1_case_uqi>
 80063c2:	2424      	.short	0x2424
 80063c4:	07162b64 	.word	0x07162b64
 80063c8:	64393364 	.word	0x64393364
 80063cc:	43646464 	.word	0x43646464
 80063d0:	2188      	movs	r1, #136	; 0x88
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO; index++)
 80063d2:	2200      	movs	r2, #0
 80063d4:	434d      	muls	r5, r1
 80063d6:	492e      	ldr	r1, [pc, #184]	; (8006490 <USBPD_DPM_GetDataInfo+0xe0>)
 80063d8:	1948      	adds	r0, r1, r5
 80063da:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 80063dc:	4293      	cmp	r3, r2
 80063de:	d918      	bls.n	8006412 <USBPD_DPM_GetDataInfo+0x62>
 80063e0:	0097      	lsls	r7, r2, #2
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSNKPDO[index];
 80063e2:	19eb      	adds	r3, r5, r7
 80063e4:	185b      	adds	r3, r3, r1
 80063e6:	6a1b      	ldr	r3, [r3, #32]
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO; index++)
 80063e8:	3201      	adds	r2, #1
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSNKPDO[index];
 80063ea:	51f3      	str	r3, [r6, r7]
 80063ec:	e7f5      	b.n	80063da <USBPD_DPM_GetDataInfo+0x2a>
 80063ee:	2188      	movs	r1, #136	; 0x88
 80063f0:	434d      	muls	r5, r1
 80063f2:	4927      	ldr	r1, [pc, #156]	; (8006490 <USBPD_DPM_GetDataInfo+0xe0>)
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO; index++)
 80063f4:	2200      	movs	r2, #0
 80063f6:	186d      	adds	r5, r5, r1
 80063f8:	0029      	movs	r1, r5
 80063fa:	69cb      	ldr	r3, [r1, #28]
 80063fc:	4293      	cmp	r3, r2
 80063fe:	d908      	bls.n	8006412 <USBPD_DPM_GetDataInfo+0x62>
 8006400:	0093      	lsls	r3, r2, #2
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index];
 8006402:	58e8      	ldr	r0, [r5, r3]
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO; index++)
 8006404:	3201      	adds	r2, #1
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index];
 8006406:	50f0      	str	r0, [r6, r3]
 8006408:	e7f7      	b.n	80063fa <USBPD_DPM_GetDataInfo+0x4a>
    USBPD_PWR_IF_GetPortPDOs(PortNum, DataId, Ptr, Size);
 800640a:	0028      	movs	r0, r5
 800640c:	f000 f9b6 	bl	800677c <USBPD_PWR_IF_GetPortPDOs>
    *Size *= 4;
 8006410:	6823      	ldr	r3, [r4, #0]
    *Size = (DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO * 4);
 8006412:	009b      	lsls	r3, r3, #2
    *Size = 0;
 8006414:	6023      	str	r3, [r4, #0]
}
 8006416:	e016      	b.n	8006446 <USBPD_DPM_GetDataInfo+0x96>
    *Ptr = DPM_Ports[PortNum].DPM_RequestedVoltage;
 8006418:	2188      	movs	r1, #136	; 0x88
 800641a:	4369      	muls	r1, r5
 800641c:	4d1c      	ldr	r5, [pc, #112]	; (8006490 <USBPD_DPM_GetDataInfo+0xe0>)
 800641e:	186d      	adds	r5, r5, r1
 8006420:	6c6b      	ldr	r3, [r5, #68]	; 0x44
    *Ptr = DPM_Ports[PortNum].DPM_RequestDOMsg;
 8006422:	6033      	str	r3, [r6, #0]
    *Size = 4;
 8006424:	2304      	movs	r3, #4
 8006426:	e7f5      	b.n	8006414 <USBPD_DPM_GetDataInfo+0x64>
    *Ptr = DPM_Ports[PortNum].DPM_RequestDOMsg;
 8006428:	2188      	movs	r1, #136	; 0x88
 800642a:	4369      	muls	r1, r5
 800642c:	4d18      	ldr	r5, [pc, #96]	; (8006490 <USBPD_DPM_GetDataInfo+0xe0>)
 800642e:	186d      	adds	r5, r5, r1
 8006430:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8006432:	e7f6      	b.n	8006422 <USBPD_DPM_GetDataInfo+0x72>
      memcpy((uint8_t*)Ptr, (uint8_t *)&DPM_USER_Settings[PortNum].DPM_SRCExtendedCapa, *Size);
 8006434:	2138      	movs	r1, #56	; 0x38
      *Size = sizeof(USBPD_SCEDB_TypeDef);
 8006436:	2218      	movs	r2, #24
      memcpy((uint8_t*)Ptr, (uint8_t *)&DPM_USER_Settings[PortNum].DPM_SRCExtendedCapa, *Size);
 8006438:	434d      	muls	r5, r1
 800643a:	4916      	ldr	r1, [pc, #88]	; (8006494 <USBPD_DPM_GetDataInfo+0xe4>)
      *Size = sizeof(USBPD_SCEDB_TypeDef);
 800643c:	601a      	str	r2, [r3, #0]
      memcpy((uint8_t*)Ptr, (uint8_t *)&DPM_USER_Settings[PortNum].DPM_SRCExtendedCapa, *Size);
 800643e:	1869      	adds	r1, r5, r1
      memcpy((uint8_t*)Ptr, (uint8_t *)manu_info, *Size);
 8006440:	0030      	movs	r0, r6
 8006442:	f006 f853 	bl	800c4ec <memcpy>
}
 8006446:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 8006448:	2188      	movs	r1, #136	; 0x88
 800644a:	2338      	movs	r3, #56	; 0x38
 800644c:	4369      	muls	r1, r5
 800644e:	436b      	muls	r3, r5
 8006450:	4d0f      	ldr	r5, [pc, #60]	; (8006490 <USBPD_DPM_GetDataInfo+0xe0>)
      manu_info = (USBPD_MIDB_TypeDef*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort;
 8006452:	001f      	movs	r7, r3
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 8006454:	186d      	adds	r5, r5, r1
 8006456:	0029      	movs	r1, r5
 8006458:	3184      	adds	r1, #132	; 0x84
      manu_info = (USBPD_MIDB_TypeDef*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort;
 800645a:	4a0e      	ldr	r2, [pc, #56]	; (8006494 <USBPD_DPM_GetDataInfo+0xe4>)
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 800645c:	7809      	ldrb	r1, [r1, #0]
      manu_info = (USBPD_MIDB_TypeDef*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort;
 800645e:	3718      	adds	r7, #24
 8006460:	18bf      	adds	r7, r7, r2
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 8006462:	2901      	cmp	r1, #1
 8006464:	d803      	bhi.n	800646e <USBPD_DPM_GetDataInfo+0xbe>
      || (DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoRef > USBPD_MANUFINFO_REF_MAX_VALUES))
 8006466:	3585      	adds	r5, #133	; 0x85
 8006468:	7828      	ldrb	r0, [r5, #0]
 800646a:	2807      	cmp	r0, #7
 800646c:	d904      	bls.n	8006478 <USBPD_DPM_GetDataInfo+0xc8>
        *Size = 4; /* VID (2) + .PID(2) */
 800646e:	2304      	movs	r3, #4
 8006470:	6023      	str	r3, [r4, #0]
      memcpy((uint8_t*)Ptr, (uint8_t *)manu_info, *Size);
 8006472:	6822      	ldr	r2, [r4, #0]
 8006474:	0039      	movs	r1, r7
 8006476:	e7e3      	b.n	8006440 <USBPD_DPM_GetDataInfo+0x90>
        if (USBPD_MANUFINFO_TARGET_PORT_CABLE_PLUG == DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget)
 8006478:	2900      	cmp	r1, #0
 800647a:	d1f8      	bne.n	800646e <USBPD_DPM_GetDataInfo+0xbe>
          *Size = 4 + strlen((char*)(DPM_USER_Settings[PortNum].DPM_ManuInfoPort.ManuString));
 800647c:	331c      	adds	r3, #28
 800647e:	1898      	adds	r0, r3, r2
 8006480:	f7ff fa86 	bl	8005990 <strlen>
 8006484:	3004      	adds	r0, #4
 8006486:	6020      	str	r0, [r4, #0]
 8006488:	e7f3      	b.n	8006472 <USBPD_DPM_GetDataInfo+0xc2>
    *Size = 0;
 800648a:	2300      	movs	r3, #0
 800648c:	e7c2      	b.n	8006414 <USBPD_DPM_GetDataInfo+0x64>
 800648e:	46c0      	nop			; (mov r8, r8)
 8006490:	200002e8 	.word	0x200002e8
 8006494:	0800c708 	.word	0x0800c708

08006498 <USBPD_DPM_SetDataInfo>:
{
 8006498:	b570      	push	{r4, r5, r6, lr}
 800649a:	0005      	movs	r5, r0
  switch (DataId)
 800649c:	1e88      	subs	r0, r1, #2
{
 800649e:	0014      	movs	r4, r2
  switch (DataId)
 80064a0:	280a      	cmp	r0, #10
 80064a2:	d811      	bhi.n	80064c8 <USBPD_DPM_SetDataInfo+0x30>
 80064a4:	f7ff fa7c 	bl	80059a0 <__gnu_thumb1_case_uqi>
 80064a8:	341a1106 	.word	0x341a1106
 80064ac:	10584f4f 	.word	0x10584f4f
 80064b0:	1010      	.short	0x1010
 80064b2:	62          	.byte	0x62
 80064b3:	00          	.byte	0x00
    if (Size == 4)
 80064b4:	2b04      	cmp	r3, #4
 80064b6:	d107      	bne.n	80064c8 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_RDOPosition = *Ptr;
 80064b8:	2088      	movs	r0, #136	; 0x88
 80064ba:	4368      	muls	r0, r5
 80064bc:	4d31      	ldr	r5, [pc, #196]	; (8006584 <USBPD_DPM_SetDataInfo+0xec>)
 80064be:	6813      	ldr	r3, [r2, #0]
 80064c0:	182d      	adds	r5, r5, r0
 80064c2:	642b      	str	r3, [r5, #64]	; 0x40
      DPM_Ports[PortNum].DPM_RDOPositionPrevious = *Ptr;
 80064c4:	6813      	ldr	r3, [r2, #0]
 80064c6:	652b      	str	r3, [r5, #80]	; 0x50
}
 80064c8:	bd70      	pop	{r4, r5, r6, pc}
    if (Size == 4)
 80064ca:	2b04      	cmp	r3, #4
 80064cc:	d1fc      	bne.n	80064c8 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_RequestedVoltage = *Ptr;
 80064ce:	2088      	movs	r0, #136	; 0x88
 80064d0:	4368      	muls	r0, r5
 80064d2:	4d2c      	ldr	r5, [pc, #176]	; (8006584 <USBPD_DPM_SetDataInfo+0xec>)
 80064d4:	6813      	ldr	r3, [r2, #0]
 80064d6:	182d      	adds	r5, r5, r0
 80064d8:	646b      	str	r3, [r5, #68]	; 0x44
 80064da:	e7f5      	b.n	80064c8 <USBPD_DPM_SetDataInfo+0x30>
    if (Size <= (USBPD_MAX_NB_PDO * 4))
 80064dc:	2b1c      	cmp	r3, #28
 80064de:	d8f3      	bhi.n	80064c8 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO = (Size / 4);
 80064e0:	2088      	movs	r0, #136	; 0x88
      for (index = 0; index < (Size / 4); index++)
 80064e2:	2100      	movs	r1, #0
      DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO = (Size / 4);
 80064e4:	4345      	muls	r5, r0
 80064e6:	4827      	ldr	r0, [pc, #156]	; (8006584 <USBPD_DPM_SetDataInfo+0xec>)
 80064e8:	089b      	lsrs	r3, r3, #2
 80064ea:	1940      	adds	r0, r0, r5
 80064ec:	61c3      	str	r3, [r0, #28]
      for (index = 0; index < (Size / 4); index++)
 80064ee:	428b      	cmp	r3, r1
 80064f0:	d0ea      	beq.n	80064c8 <USBPD_DPM_SetDataInfo+0x30>
        DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index] = LE32(Ptr + index);
 80064f2:	7862      	ldrb	r2, [r4, #1]
 80064f4:	78a6      	ldrb	r6, [r4, #2]
 80064f6:	0212      	lsls	r2, r2, #8
 80064f8:	0436      	lsls	r6, r6, #16
 80064fa:	1992      	adds	r2, r2, r6
 80064fc:	7826      	ldrb	r6, [r4, #0]
 80064fe:	008d      	lsls	r5, r1, #2
 8006500:	1992      	adds	r2, r2, r6
 8006502:	78e6      	ldrb	r6, [r4, #3]
      for (index = 0; index < (Size / 4); index++)
 8006504:	3101      	adds	r1, #1
        DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index] = LE32(Ptr + index);
 8006506:	0636      	lsls	r6, r6, #24
 8006508:	1992      	adds	r2, r2, r6
 800650a:	5142      	str	r2, [r0, r5]
 800650c:	3404      	adds	r4, #4
 800650e:	e7ee      	b.n	80064ee <USBPD_DPM_SetDataInfo+0x56>
    if (Size <= (USBPD_MAX_NB_PDO * 4))
 8006510:	2b1c      	cmp	r3, #28
 8006512:	d8d9      	bhi.n	80064c8 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO = (Size / 4);
 8006514:	2088      	movs	r0, #136	; 0x88
 8006516:	4345      	muls	r5, r0
 8006518:	4a1a      	ldr	r2, [pc, #104]	; (8006584 <USBPD_DPM_SetDataInfo+0xec>)
 800651a:	089b      	lsrs	r3, r3, #2
 800651c:	1951      	adds	r1, r2, r5
 800651e:	63cb      	str	r3, [r1, #60]	; 0x3c
 8006520:	3520      	adds	r5, #32
 8006522:	009b      	lsls	r3, r3, #2
 8006524:	18ad      	adds	r5, r5, r2
 8006526:	18e3      	adds	r3, r4, r3
      for (index = 0; index < (Size / 4); index++)
 8006528:	429c      	cmp	r4, r3
 800652a:	d0cd      	beq.n	80064c8 <USBPD_DPM_SetDataInfo+0x30>
        DPM_Ports[PortNum].DPM_ListOfRcvSNKPDO[index] = LE32(Ptr + index);
 800652c:	7860      	ldrb	r0, [r4, #1]
 800652e:	78a2      	ldrb	r2, [r4, #2]
 8006530:	0200      	lsls	r0, r0, #8
 8006532:	0412      	lsls	r2, r2, #16
 8006534:	1880      	adds	r0, r0, r2
 8006536:	7822      	ldrb	r2, [r4, #0]
 8006538:	1880      	adds	r0, r0, r2
 800653a:	78e2      	ldrb	r2, [r4, #3]
 800653c:	3404      	adds	r4, #4
 800653e:	0612      	lsls	r2, r2, #24
 8006540:	1880      	adds	r0, r0, r2
 8006542:	c501      	stmia	r5!, {r0}
 8006544:	e7f0      	b.n	8006528 <USBPD_DPM_SetDataInfo+0x90>
    if (Size == 4)
 8006546:	2b04      	cmp	r3, #4
 8006548:	d1be      	bne.n	80064c8 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_RcvRequestDOMsg = *Ptr;
 800654a:	2088      	movs	r0, #136	; 0x88
 800654c:	4368      	muls	r0, r5
 800654e:	4d0d      	ldr	r5, [pc, #52]	; (8006584 <USBPD_DPM_SetDataInfo+0xec>)
 8006550:	6813      	ldr	r3, [r2, #0]
 8006552:	182d      	adds	r5, r5, r0
 8006554:	65eb      	str	r3, [r5, #92]	; 0x5c
 8006556:	e7b7      	b.n	80064c8 <USBPD_DPM_SetDataInfo+0x30>
      ext_capa = (uint8_t*)&DPM_Ports[PortNum].DPM_RcvSRCExtendedCapa;
 8006558:	2088      	movs	r0, #136	; 0x88
 800655a:	4368      	muls	r0, r5
 800655c:	4d09      	ldr	r5, [pc, #36]	; (8006584 <USBPD_DPM_SetDataInfo+0xec>)
 800655e:	306c      	adds	r0, #108	; 0x6c
 8006560:	1940      	adds	r0, r0, r5
      memcpy(ext_capa, Ptr, Size);
 8006562:	001a      	movs	r2, r3
 8006564:	0021      	movs	r1, r4
 8006566:	f005 ffc1 	bl	800c4ec <memcpy>
    break;
 800656a:	e7ad      	b.n	80064c8 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget = *temp;
 800656c:	2088      	movs	r0, #136	; 0x88
 800656e:	4368      	muls	r0, r5
 8006570:	4d04      	ldr	r5, [pc, #16]	; (8006584 <USBPD_DPM_SetDataInfo+0xec>)
 8006572:	7812      	ldrb	r2, [r2, #0]
 8006574:	182d      	adds	r5, r5, r0
 8006576:	002b      	movs	r3, r5
 8006578:	3384      	adds	r3, #132	; 0x84
 800657a:	701a      	strb	r2, [r3, #0]
      DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoRef    = *(temp + 1);
 800657c:	7863      	ldrb	r3, [r4, #1]
 800657e:	3585      	adds	r5, #133	; 0x85
 8006580:	702b      	strb	r3, [r5, #0]
}
 8006582:	e7a1      	b.n	80064c8 <USBPD_DPM_SetDataInfo+0x30>
 8006584:	200002e8 	.word	0x200002e8

08006588 <USBPD_DPM_EvaluateRequest>:
{
 8006588:	b5f0      	push	{r4, r5, r6, r7, lr}
  rdo.d32 = pdhandle->DPM_RcvRequestDOMsg;
 800658a:	2488      	movs	r4, #136	; 0x88
 800658c:	4344      	muls	r4, r0
 800658e:	4b1a      	ldr	r3, [pc, #104]	; (80065f8 <USBPD_DPM_EvaluateRequest+0x70>)
{
 8006590:	b085      	sub	sp, #20
  rdo.d32 = pdhandle->DPM_RcvRequestDOMsg;
 8006592:	191c      	adds	r4, r3, r4
  pdhandle->DPM_RDOPosition = 0;
 8006594:	2300      	movs	r3, #0
  rdo.d32 = pdhandle->DPM_RcvRequestDOMsg;
 8006596:	6de5      	ldr	r5, [r4, #92]	; 0x5c
  if (USBPD_PWR_IF_SearchRequestedPDO(PortNum, rdoobjposition, &pdo.d32) != USBPD_OK)
 8006598:	af03      	add	r7, sp, #12
  rdoobjposition  = rdo.GenericRDO.ObjectPosition;
 800659a:	006e      	lsls	r6, r5, #1
 800659c:	0f76      	lsrs	r6, r6, #29
{
 800659e:	9101      	str	r1, [sp, #4]
  pdhandle->DPM_RDOPosition = 0;
 80065a0:	6423      	str	r3, [r4, #64]	; 0x40
  if (USBPD_PWR_IF_SearchRequestedPDO(PortNum, rdoobjposition, &pdo.d32) != USBPD_OK)
 80065a2:	003a      	movs	r2, r7
 80065a4:	0031      	movs	r1, r6
 80065a6:	f000 f905 	bl	80067b4 <USBPD_PWR_IF_SearchRequestedPDO>
 80065aa:	2800      	cmp	r0, #0
 80065ac:	d001      	beq.n	80065b2 <USBPD_DPM_EvaluateRequest+0x2a>
      return USBPD_REJECT;
 80065ae:	200c      	movs	r0, #12
 80065b0:	e01f      	b.n	80065f2 <USBPD_DPM_EvaluateRequest+0x6a>
  switch(pdo.GenericPDO.PowerObject)
 80065b2:	ab02      	add	r3, sp, #8
 80065b4:	79da      	ldrb	r2, [r3, #7]
 80065b6:	0992      	lsrs	r2, r2, #6
 80065b8:	b2d3      	uxtb	r3, r2
 80065ba:	2b00      	cmp	r3, #0
 80065bc:	d1f7      	bne.n	80065ae <USBPD_DPM_EvaluateRequest+0x26>
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 80065be:	200a      	movs	r0, #10
      pdomaxcurrent = pdo.SRCFixedPDO.MaxCurrentIn10mAunits;
 80065c0:	883b      	ldrh	r3, [r7, #0]
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 80065c2:	0007      	movs	r7, r0
      rdomaxcurrent = rdo.FixedVariableRDO.MaxOperatingCurrent10mAunits;
 80065c4:	05a9      	lsls	r1, r5, #22
      rdoopcurrent  = rdo.FixedVariableRDO.OperatingCurrentIn10mAunits;
 80065c6:	032d      	lsls	r5, r5, #12
 80065c8:	0dad      	lsrs	r5, r5, #22
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 80065ca:	436f      	muls	r7, r5
      pdomaxcurrent = pdo.SRCFixedPDO.MaxCurrentIn10mAunits;
 80065cc:	059b      	lsls	r3, r3, #22
 80065ce:	0d9b      	lsrs	r3, r3, #22
      rdomaxcurrent = rdo.FixedVariableRDO.MaxOperatingCurrent10mAunits;
 80065d0:	0d89      	lsrs	r1, r1, #22
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 80065d2:	64a7      	str	r7, [r4, #72]	; 0x48
      if(rdoopcurrent > pdomaxcurrent)
 80065d4:	42ab      	cmp	r3, r5
 80065d6:	d3ea      	bcc.n	80065ae <USBPD_DPM_EvaluateRequest+0x26>
      if(rdomaxcurrent > pdomaxcurrent)
 80065d8:	428b      	cmp	r3, r1
 80065da:	d3e8      	bcc.n	80065ae <USBPD_DPM_EvaluateRequest+0x26>
  pdhandle->DPM_RequestedVoltage = pdo.SRCFixedPDO.VoltageIn50mVunits * 50;
 80065dc:	2132      	movs	r1, #50	; 0x32
 80065de:	9b03      	ldr	r3, [sp, #12]
 80065e0:	031b      	lsls	r3, r3, #12
 80065e2:	0d9b      	lsrs	r3, r3, #22
 80065e4:	434b      	muls	r3, r1
 80065e6:	6463      	str	r3, [r4, #68]	; 0x44
  pdhandle->DPM_RDOPositionPrevious = pdhandle->DPM_RDOPosition;
 80065e8:	6c23      	ldr	r3, [r4, #64]	; 0x40
  pdhandle->DPM_RDOPosition = rdoobjposition;
 80065ea:	6426      	str	r6, [r4, #64]	; 0x40
  pdhandle->DPM_RDOPositionPrevious = pdhandle->DPM_RDOPosition;
 80065ec:	6523      	str	r3, [r4, #80]	; 0x50
  *PtrPowerObject = pdo.GenericPDO.PowerObject;
 80065ee:	9b01      	ldr	r3, [sp, #4]
 80065f0:	701a      	strb	r2, [r3, #0]
}
 80065f2:	b005      	add	sp, #20
 80065f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80065f6:	46c0      	nop			; (mov r8, r8)
 80065f8:	200002e8 	.word	0x200002e8

080065fc <USBPD_DPM_ExtendedMessageReceived>:
}
 80065fc:	4770      	bx	lr

080065fe <USBPD_DPM_EnterErrorRecovery>:
{
 80065fe:	b510      	push	{r4, lr}
 8006600:	0004      	movs	r4, r0
  DPM_TurnOffPower(PortNum, DPM_Params[PortNum].PE_PowerRole);
 8006602:	f7ff fd54 	bl	80060ae <DPM_TurnOffPower.isra.0>
  USBPD_CAD_EnterErrorRecovery(PortNum);
 8006606:	0020      	movs	r0, r4
 8006608:	f7f9 fe24 	bl	8000254 <USBPD_CAD_EnterErrorRecovery>
}
 800660c:	bd10      	pop	{r4, pc}
	...

08006610 <USBPD_DPM_EvaluateDataRoleSwap>:
  if (USBPD_TRUE == DPM_USER_Settings[PortNum].PE_DataSwap)
 8006610:	2238      	movs	r2, #56	; 0x38
 8006612:	4342      	muls	r2, r0
 8006614:	4b06      	ldr	r3, [pc, #24]	; (8006630 <USBPD_DPM_EvaluateDataRoleSwap+0x20>)
{
 8006616:	b510      	push	{r4, lr}
  if (USBPD_TRUE == DPM_USER_Settings[PortNum].PE_DataSwap)
 8006618:	189b      	adds	r3, r3, r2
 800661a:	3330      	adds	r3, #48	; 0x30
 800661c:	789a      	ldrb	r2, [r3, #2]
  USBPD_StatusTypeDef status = USBPD_REJECT;
 800661e:	230c      	movs	r3, #12
  if (USBPD_TRUE == DPM_USER_Settings[PortNum].PE_DataSwap)
 8006620:	07d2      	lsls	r2, r2, #31
 8006622:	d502      	bpl.n	800662a <USBPD_DPM_EvaluateDataRoleSwap+0x1a>
    STUSB16xx_HW_IF_DataRoleSwap(PortNum);
 8006624:	f004 fd9e 	bl	800b164 <STUSB16xx_HW_IF_DataRoleSwap>
    status = USBPD_ACCEPT;
 8006628:	230a      	movs	r3, #10
}
 800662a:	0018      	movs	r0, r3
 800662c:	bd10      	pop	{r4, pc}
 800662e:	46c0      	nop			; (mov r8, r8)
 8006630:	0800c708 	.word	0x0800c708

08006634 <USBPD_DPM_IsPowerReady>:
{
 8006634:	b510      	push	{r4, lr}
  return ((USBPD_OK == USBPD_PWR_IF_SupplyReady(PortNum, Vsafe)) ? USBPD_ENABLE : USBPD_DISABLE);
 8006636:	f000 f861 	bl	80066fc <USBPD_PWR_IF_SupplyReady>
 800663a:	4243      	negs	r3, r0
 800663c:	4158      	adcs	r0, r3
 800663e:	b2c0      	uxtb	r0, r0
}
 8006640:	bd10      	pop	{r4, pc}

08006642 <USBPD_DPM_RequestGetSourceCapabilityExt>:
{
 8006642:	b510      	push	{r4, lr}
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_GET_SRC_CAPEXT, USBPD_SOPTYPE_SOP);
 8006644:	2200      	movs	r2, #0
 8006646:	2111      	movs	r1, #17
 8006648:	f7fc fe0a 	bl	8003260 <USBPD_PE_Request_CtrlMessage>
}
 800664c:	bd10      	pop	{r4, pc}
	...

08006650 <USBPD_DPM_UserExecute>:
{
 8006650:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint32_t _timing = osWaitForever;
 8006652:	2201      	movs	r2, #1
    switch (((DPM_USER_EVENT)event.value.v & 0xF))
 8006654:	250f      	movs	r5, #15
  osMessageQId  queue = *(osMessageQId *)argument;
 8006656:	6804      	ldr	r4, [r0, #0]
  uint32_t _timing = osWaitForever;
 8006658:	4252      	negs	r2, r2
    osEvent event = osMessageGet(queue, _timing);
 800665a:	a801      	add	r0, sp, #4
 800665c:	0021      	movs	r1, r4
 800665e:	f004 feb5 	bl	800b3cc <osMessageGet>
    switch (((DPM_USER_EVENT)event.value.v & 0xF))
 8006662:	9802      	ldr	r0, [sp, #8]
 8006664:	4e09      	ldr	r6, [pc, #36]	; (800668c <USBPD_DPM_UserExecute+0x3c>)
 8006666:	4028      	ands	r0, r5
 8006668:	d109      	bne.n	800667e <USBPD_DPM_UserExecute+0x2e>
      if (DPM_TIMER_ENABLE_MSK == DPM_Ports[USBPD_PORT_0].DPM_TimerSRCExtendedCapa)
 800666a:	0033      	movs	r3, r6
 800666c:	2280      	movs	r2, #128	; 0x80
 800666e:	336a      	adds	r3, #106	; 0x6a
 8006670:	8819      	ldrh	r1, [r3, #0]
 8006672:	0212      	lsls	r2, r2, #8
 8006674:	4291      	cmp	r1, r2
 8006676:	d102      	bne.n	800667e <USBPD_DPM_UserExecute+0x2e>
        DPM_Ports[USBPD_PORT_0].DPM_TimerSRCExtendedCapa = 0;
 8006678:	8018      	strh	r0, [r3, #0]
        USBPD_DPM_RequestGetSourceCapabilityExt(USBPD_PORT_0);
 800667a:	f7ff ffe2 	bl	8006642 <USBPD_DPM_RequestGetSourceCapabilityExt>
{
  uint32_t _timing = osWaitForever;
  uint32_t _current_timing;

  /* Calculate the minimum timers to wake-up DPM tasks */
  _current_timing = DPM_Ports[USBPD_PORT_0].DPM_TimerSRCExtendedCapa & DPM_TIMER_READ_MSK;
 800667e:	366a      	adds	r6, #106	; 0x6a
 8006680:	8832      	ldrh	r2, [r6, #0]
 8006682:	0452      	lsls	r2, r2, #17
 8006684:	0c52      	lsrs	r2, r2, #17
  if(_current_timing > 0)
 8006686:	d1e8      	bne.n	800665a <USBPD_DPM_UserExecute+0xa>
  uint32_t _timing = osWaitForever;
 8006688:	3a01      	subs	r2, #1
  do{
 800668a:	e7e6      	b.n	800665a <USBPD_DPM_UserExecute+0xa>
 800668c:	200002e8 	.word	0x200002e8

08006690 <HAL_GPIO_EXTI_Callback>:
{
 8006690:	b510      	push	{r4, lr}
  USBPD_HW_IF_EXTI_Callback(GPIO_Pin);
 8006692:	f002 fddf 	bl	8009254 <USBPD_HW_IF_EXTI_Callback>
}
 8006696:	bd10      	pop	{r4, pc}

08006698 <USBPD_PWR_IF_Init>:
{

  /* Set links to PDO values and number for Port 0 (defined in PDO arrays in H file).
   */
#if (PORT0_NB_SOURCEPDO > 0)
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.ListOfPDO = (uint32_t *) PORT0_PDO_ListSRC;
 8006698:	4b03      	ldr	r3, [pc, #12]	; (80066a8 <USBPD_PWR_IF_Init+0x10>)
 800669a:	4a04      	ldr	r2, [pc, #16]	; (80066ac <USBPD_PWR_IF_Init+0x14>)
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.NumberOfPDO = PORT0_NB_SOURCEPDO;
#endif


  return USBPD_OK;
}
 800669c:	2000      	movs	r0, #0
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.ListOfPDO = (uint32_t *) PORT0_PDO_ListSRC;
 800669e:	601a      	str	r2, [r3, #0]
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.NumberOfPDO = PORT0_NB_SOURCEPDO;
 80066a0:	2201      	movs	r2, #1
 80066a2:	711a      	strb	r2, [r3, #4]
}
 80066a4:	4770      	bx	lr
 80066a6:	46c0      	nop			; (mov r8, r8)
 80066a8:	20001a18 	.word	0x20001a18
 80066ac:	0800c648 	.word	0x0800c648

080066b0 <USBPD_PWR_IF_SetProfile>:
  * @param  Profile          Number of the required Power Data Objects
  * @param  PreviousPowerProfile  Number of the previous required Power Data Objects
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_PWR_IF_SetProfile(uint8_t PortNum, uint8_t Profile, uint8_t PreviousPowerProfile)
{
 80066b0:	b510      	push	{r4, lr}
  uint32_t timeout_end;
#endif /* (PORT0_NB_SOURCEPDO >= 2)|| (PORT0_NB_SOURCEAPDO > 0) */
  USBPD_StatusTypeDef      ret = USBPD_ERROR;

  /* Check if valid port */
  if ( !USBPD_PORT_IsValid(PortNum) )
 80066b2:	2800      	cmp	r0, #0
 80066b4:	d001      	beq.n	80066ba <USBPD_PWR_IF_SetProfile+0xa>
  {
    return USBPD_ERROR;
 80066b6:	2002      	movs	r0, #2
      ret = USBPD_OK;
    }
  }
#endif
  return ret;
}
 80066b8:	bd10      	pop	{r4, pc}
  if (USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 80066ba:	4b0d      	ldr	r3, [pc, #52]	; (80066f0 <USBPD_PWR_IF_SetProfile+0x40>)
 80066bc:	781b      	ldrb	r3, [r3, #0]
 80066be:	075b      	lsls	r3, r3, #29
 80066c0:	d5f9      	bpl.n	80066b6 <USBPD_PWR_IF_SetProfile+0x6>
    if (Profile >= PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO)
 80066c2:	4b0c      	ldr	r3, [pc, #48]	; (80066f4 <USBPD_PWR_IF_SetProfile+0x44>)
 80066c4:	791a      	ldrb	r2, [r3, #4]
 80066c6:	428a      	cmp	r2, r1
 80066c8:	d9f5      	bls.n	80066b6 <USBPD_PWR_IF_SetProfile+0x6>
    if (0 == PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO)
 80066ca:	2a00      	cmp	r2, #0
 80066cc:	d0f3      	beq.n	80066b6 <USBPD_PWR_IF_SetProfile+0x6>
    pdo.d32 = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO[Profile];
 80066ce:	681b      	ldr	r3, [r3, #0]
 80066d0:	0089      	lsls	r1, r1, #2
 80066d2:	58c9      	ldr	r1, [r1, r3]
    if (pdo.GenericPDO.PowerObject == USBPD_PDO_TYPE_FIXED)
 80066d4:	233f      	movs	r3, #63	; 0x3f
 80066d6:	0e0c      	lsrs	r4, r1, #24
 80066d8:	439c      	bics	r4, r3
 80066da:	d1ec      	bne.n	80066b6 <USBPD_PWR_IF_SetProfile+0x6>
      vbusTargetInmv = (pdo.SRCFixedPDO.VoltageIn50mVunits * 50);
 80066dc:	0309      	lsls	r1, r1, #12
      HW_IF_PWR_SetVoltage(PortNum, vbusTargetInmv);
 80066de:	3b0d      	subs	r3, #13
      vbusTargetInmv = (pdo.SRCFixedPDO.VoltageIn50mVunits * 50);
 80066e0:	0d89      	lsrs	r1, r1, #22
      HW_IF_PWR_SetVoltage(PortNum, vbusTargetInmv);
 80066e2:	4359      	muls	r1, r3
 80066e4:	0020      	movs	r0, r4
 80066e6:	f003 fd15 	bl	800a114 <HW_IF_PWR_SetVoltage>
      ret = USBPD_OK;
 80066ea:	0020      	movs	r0, r4
 80066ec:	e7e4      	b.n	80066b8 <USBPD_PWR_IF_SetProfile+0x8>
 80066ee:	46c0      	nop			; (mov r8, r8)
 80066f0:	20001bc0 	.word	0x20001bc0
 80066f4:	20001a18 	.word	0x20001a18

080066f8 <USBPD_PWR_IF_PowerResetGlobal>:
  for(i = 0; i < USBPD_PORT_COUNT; i++)
  {
    USBPD_PWR_IF_PowerReset(i);
  }
  return USBPD_OK;
}
 80066f8:	2000      	movs	r0, #0
 80066fa:	4770      	bx	lr

080066fc <USBPD_PWR_IF_SupplyReady>:
  * @param  PortNum Port number
  * @param  Vsafe   Vsafe status based on @ref USBPD_VSAFE_StatusTypeDef
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_PWR_IF_SupplyReady(uint8_t PortNum, USBPD_VSAFE_StatusTypeDef Vsafe)
{
 80066fc:	b510      	push	{r4, lr}
  USBPD_StatusTypeDef status = USBPD_ERROR;

  /* check for valid port */
  if (!USBPD_PORT_IsValid(PortNum))
 80066fe:	2800      	cmp	r0, #0
 8006700:	d10f      	bne.n	8006722 <USBPD_PWR_IF_SupplyReady+0x26>
  {
    return USBPD_ERROR;
  }

  if (USBPD_VSAFE_0V == Vsafe)
 8006702:	2900      	cmp	r1, #0
 8006704:	d107      	bne.n	8006716 <USBPD_PWR_IF_SupplyReady+0x1a>
  {
    /* Vsafe0V */
    status = (HW_IF_PWR_GetVoltage(PortNum) < CAD_threshold_VBus? USBPD_OK: USBPD_ERROR);
 8006706:	0008      	movs	r0, r1
 8006708:	f003 fd6a 	bl	800a1e0 <HW_IF_PWR_GetVoltage>
 800670c:	4b06      	ldr	r3, [pc, #24]	; (8006728 <USBPD_PWR_IF_SupplyReady+0x2c>)
 800670e:	4298      	cmp	r0, r3
 8006710:	d807      	bhi.n	8006722 <USBPD_PWR_IF_SupplyReady+0x26>
 8006712:	2000      	movs	r0, #0
  {
    /* Vsafe5V */
    status = (HW_IF_PWR_GetVoltage(PortNum) > CAD_threshold_VBus? USBPD_OK: USBPD_ERROR);
  }
  return status;
}
 8006714:	bd10      	pop	{r4, pc}
    status = (HW_IF_PWR_GetVoltage(PortNum) > CAD_threshold_VBus? USBPD_OK: USBPD_ERROR);
 8006716:	f003 fd63 	bl	800a1e0 <HW_IF_PWR_GetVoltage>
 800671a:	239b      	movs	r3, #155	; 0x9b
 800671c:	009b      	lsls	r3, r3, #2
 800671e:	4298      	cmp	r0, r3
 8006720:	d8f7      	bhi.n	8006712 <USBPD_PWR_IF_SupplyReady+0x16>
    status = (HW_IF_PWR_GetVoltage(PortNum) < CAD_threshold_VBus? USBPD_OK: USBPD_ERROR);
 8006722:	2002      	movs	r0, #2
 8006724:	e7f6      	b.n	8006714 <USBPD_PWR_IF_SupplyReady+0x18>
 8006726:	46c0      	nop			; (mov r8, r8)
 8006728:	0000026b 	.word	0x0000026b

0800672c <USBPD_PWR_IF_VBUSEnable>:
  * @brief  Enables VBUS power on a specified port
  * @param  PortNum Port number
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_PWR_IF_VBUSEnable(uint8_t PortNum)
{
 800672c:	b507      	push	{r0, r1, r2, lr}
  USBPD_StatusTypeDef _status = USBPD_ERROR;
 800672e:	2302      	movs	r3, #2
  
  /* check for valid port */
  if (USBPD_PORT_IsValid(PortNum))
 8006730:	2800      	cmp	r0, #0
 8006732:	d10a      	bne.n	800674a <USBPD_PWR_IF_VBUSEnable+0x1e>
#if defined(_TRACE)
    char str[20];
    sprintf(str, "CC:%d VCONN:%d", DPM_Params[PortNum].VconnCCIs, DPM_Params[PortNum].VconnStatus);
    POWER_IF_TRACE(PortNum, (uint8_t*)str, strlen(str));
#endif /* _TRACE */
    _status = (USBPD_StatusTypeDef)HW_IF_PWR_Enable(PortNum, USBPD_ENABLE, DPM_Params[PortNum].VconnCCIs, DPM_Params[PortNum].VconnStatus, USBPD_PORTPOWERROLE_SRC);
 8006734:	2101      	movs	r1, #1
 8006736:	4b06      	ldr	r3, [pc, #24]	; (8006750 <USBPD_PWR_IF_VBUSEnable+0x24>)
 8006738:	789a      	ldrb	r2, [r3, #2]
 800673a:	9100      	str	r1, [sp, #0]
 800673c:	0753      	lsls	r3, r2, #29
 800673e:	0792      	lsls	r2, r2, #30
 8006740:	0fdb      	lsrs	r3, r3, #31
 8006742:	0f92      	lsrs	r2, r2, #30
 8006744:	f003 fd54 	bl	800a1f0 <HW_IF_PWR_Enable>
 8006748:	0003      	movs	r3, r0
  }
  return _status;
}
 800674a:	0018      	movs	r0, r3
 800674c:	bd0e      	pop	{r1, r2, r3, pc}
 800674e:	46c0      	nop			; (mov r8, r8)
 8006750:	20001bc0 	.word	0x20001bc0

08006754 <USBPD_PWR_IF_VBUSDisable>:
  * @brief  Disbale VBUS/VCONN the power on a specified port
  * @param  PortNum Port number
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_PWR_IF_VBUSDisable(uint8_t PortNum)
{
 8006754:	b507      	push	{r0, r1, r2, lr}
  USBPD_StatusTypeDef _status = USBPD_ERROR;
 8006756:	2302      	movs	r3, #2
  
  /* check for valid port */
  if (USBPD_PORT_IsValid(PortNum))
 8006758:	2800      	cmp	r0, #0
 800675a:	d10b      	bne.n	8006774 <USBPD_PWR_IF_VBUSDisable+0x20>
  {
    POWER_IF_TRACE(PortNum, "DIS VBUS", 8);
    /* Set the new state */
    _status = (USBPD_StatusTypeDef)HW_IF_PWR_Enable(PortNum, USBPD_DISABLE, DPM_Params[PortNum].VconnCCIs, DPM_Params[PortNum].VconnStatus, USBPD_PORTPOWERROLE_SRC);
 800675c:	2101      	movs	r1, #1
 800675e:	4b06      	ldr	r3, [pc, #24]	; (8006778 <USBPD_PWR_IF_VBUSDisable+0x24>)
 8006760:	789a      	ldrb	r2, [r3, #2]
 8006762:	9100      	str	r1, [sp, #0]
 8006764:	0753      	lsls	r3, r2, #29
 8006766:	0792      	lsls	r2, r2, #30
 8006768:	0fdb      	lsrs	r3, r3, #31
 800676a:	0f92      	lsrs	r2, r2, #30
 800676c:	0001      	movs	r1, r0
 800676e:	f003 fd3f 	bl	800a1f0 <HW_IF_PWR_Enable>
 8006772:	0003      	movs	r3, r0
  }
  return _status;
}
 8006774:	0018      	movs	r0, r3
 8006776:	bd0e      	pop	{r1, r2, r3, pc}
 8006778:	20001bc0 	.word	0x20001bc0

0800677c <USBPD_PWR_IF_GetPortPDOs>:
  * @param  Ptr Pointer on address where PDO values should be written (u32 pointer)
  * @param  Size Pointer on nb of u32 written by PWR_IF (nb of PDOs)
  * @retval None
  */
void USBPD_PWR_IF_GetPortPDOs(uint8_t PortNum, USBPD_CORE_DataInfoType_TypeDef DataId, uint32_t *Ptr, uint32_t *Size)
{
 800677c:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t   nbpdo, index, nb_valid_pdo = 0;
  uint32_t   *ptpdoarray = NULL;

  /* Check if valid port */
  if (USBPD_PORT_IsValid(PortNum))
 800677e:	2800      	cmp	r0, #0
 8006780:	d10a      	bne.n	8006798 <USBPD_PWR_IF_GetPortPDOs+0x1c>
    case USBPD_CORE_DATATYPE_SRC_PDO:
      nbpdo       = PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO;
      ptpdoarray  = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO;
      break;
    default:
      nbpdo = 0;
 8006782:	0006      	movs	r6, r0
    switch (DataId)
 8006784:	2900      	cmp	r1, #0
 8006786:	d102      	bne.n	800678e <USBPD_PWR_IF_GetPortPDOs+0x12>
      nbpdo       = PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO;
 8006788:	4909      	ldr	r1, [pc, #36]	; (80067b0 <USBPD_PWR_IF_GetPortPDOs+0x34>)
 800678a:	790e      	ldrb	r6, [r1, #4]
      ptpdoarray  = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO;
 800678c:	6808      	ldr	r0, [r1, #0]
 800678e:	00b4      	lsls	r4, r6, #2
 8006790:	1904      	adds	r4, r0, r4
      break;
    }

    /* Copy PDO data in output buffer */
    for (index = 0; index < nbpdo; index++)
 8006792:	42a0      	cmp	r0, r4
 8006794:	d101      	bne.n	800679a <USBPD_PWR_IF_GetPortPDOs+0x1e>
        nb_valid_pdo++;
      }
      ptpdoarray++;
    }
    /* Set nb of read PDO (nb of u32 elements); */
    *Size = nb_valid_pdo;
 8006796:	601e      	str	r6, [r3, #0]
  }
}
 8006798:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800679a:	2100      	movs	r1, #0
        USPBPD_WRITE32((uint32_t *)(Ptr + nb_valid_pdo), *ptpdoarray);
 800679c:	6807      	ldr	r7, [r0, #0]
 800679e:	00cd      	lsls	r5, r1, #3
 80067a0:	40ef      	lsrs	r7, r5
 80067a2:	5457      	strb	r7, [r2, r1]
 80067a4:	3101      	adds	r1, #1
 80067a6:	2904      	cmp	r1, #4
 80067a8:	d1f8      	bne.n	800679c <USBPD_PWR_IF_GetPortPDOs+0x20>
      ptpdoarray++;
 80067aa:	3004      	adds	r0, #4
 80067ac:	3204      	adds	r2, #4
 80067ae:	e7f0      	b.n	8006792 <USBPD_PWR_IF_GetPortPDOs+0x16>
 80067b0:	20001a18 	.word	0x20001a18

080067b4 <USBPD_PWR_IF_SearchRequestedPDO>:
  * @retval Status of search
  *         USBPD_OK : Src PDO found for requested DO position (output Pdo parameter is set)
  *         USBPD_FAIL : Position is not compliant with current Src PDO for this port (no corresponding PDO value)
  */
USBPD_StatusTypeDef USBPD_PWR_IF_SearchRequestedPDO(uint8_t PortNum, uint32_t RdoPosition, uint32_t *Pdo)
{
 80067b4:	0003      	movs	r3, r0
 80067b6:	b530      	push	{r4, r5, lr}
  if((RdoPosition == 0) || (RdoPosition > PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO))
  {
    /* Invalid PDO index */
    return USBPD_FAIL;
 80067b8:	2010      	movs	r0, #16
  if((RdoPosition == 0) || (RdoPosition > PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO))
 80067ba:	2900      	cmp	r1, #0
 80067bc:	d00d      	beq.n	80067da <USBPD_PWR_IF_SearchRequestedPDO+0x26>
 80067be:	4c07      	ldr	r4, [pc, #28]	; (80067dc <USBPD_PWR_IF_SearchRequestedPDO+0x28>)
 80067c0:	00db      	lsls	r3, r3, #3
 80067c2:	18e0      	adds	r0, r4, r3
 80067c4:	7905      	ldrb	r5, [r0, #4]
    return USBPD_FAIL;
 80067c6:	2010      	movs	r0, #16
  if((RdoPosition == 0) || (RdoPosition > PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO))
 80067c8:	428d      	cmp	r5, r1
 80067ca:	d306      	bcc.n	80067da <USBPD_PWR_IF_SearchRequestedPDO+0x26>
  }

  *Pdo = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO[RdoPosition - 1];
 80067cc:	4804      	ldr	r0, [pc, #16]	; (80067e0 <USBPD_PWR_IF_SearchRequestedPDO+0x2c>)
 80067ce:	591b      	ldr	r3, [r3, r4]
 80067d0:	1809      	adds	r1, r1, r0
  return USBPD_OK;
 80067d2:	2000      	movs	r0, #0
  *Pdo = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO[RdoPosition - 1];
 80067d4:	0089      	lsls	r1, r1, #2
 80067d6:	58cb      	ldr	r3, [r1, r3]
 80067d8:	6013      	str	r3, [r2, #0]
}
 80067da:	bd30      	pop	{r4, r5, pc}
 80067dc:	20001a18 	.word	0x20001a18
 80067e0:	3fffffff 	.word	0x3fffffff

080067e4 <STUSB1602_Driver_Init>:
  * @param  PortNum     Port number value
  * @param  I2CxHandle  External I2C handle
  * @retval None
  */
void STUSB1602_Driver_Init(uint8_t PortNum, I2C_HandleTypeDef I2CxHandle)
{
 80067e4:	b084      	sub	sp, #16
 80067e6:	b510      	push	{r4, lr}
 80067e8:	9103      	str	r1, [sp, #12]
 80067ea:	9204      	str	r2, [sp, #16]
 80067ec:	9305      	str	r3, [sp, #20]
  if (0 == PortNum)
  {
    STUSB16xx_I2CxHandle = I2CxHandle;
 80067ee:	224c      	movs	r2, #76	; 0x4c
 80067f0:	a903      	add	r1, sp, #12
  if (0 == PortNum)
 80067f2:	2800      	cmp	r0, #0
 80067f4:	d106      	bne.n	8006804 <STUSB1602_Driver_Init+0x20>
    STUSB16xx_I2CxHandle = I2CxHandle;
 80067f6:	4804      	ldr	r0, [pc, #16]	; (8006808 <STUSB1602_Driver_Init+0x24>)
  }
  else
  {
    STUSB16xx_I2CxHandle_P1 = I2CxHandle;
 80067f8:	f005 fe78 	bl	800c4ec <memcpy>
  }
}
 80067fc:	bc10      	pop	{r4}
 80067fe:	bc08      	pop	{r3}
 8006800:	b004      	add	sp, #16
 8006802:	4718      	bx	r3
    STUSB16xx_I2CxHandle_P1 = I2CxHandle;
 8006804:	4801      	ldr	r0, [pc, #4]	; (800680c <STUSB1602_Driver_Init+0x28>)
 8006806:	e7f7      	b.n	80067f8 <STUSB1602_Driver_Init+0x14>
 8006808:	20001a20 	.word	0x20001a20
 800680c:	20001b70 	.word	0x20001b70

08006810 <STUSB1602_ReadReg>:
  * @param Reg          Address of first register to be read
  * @param Size         Amount of bytes to be read
  * @retval STUSB1602_StatusTypeDef Allowed values are STUSB1602_OK, STUSB1602_ERROR, STUSB1602_BUSY, STUSB1602_TIMEOUT
  */
STUSB1602_StatusTypeDef STUSB1602_ReadReg(uint8_t* pBuffer, uint8_t Addr, uint8_t Reg, uint16_t Size)
  {
 8006810:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if (Addr == 0x29)
    {
      return STUSB1602_OK;
    }
#endif
    status = (STUSB1602_StatusTypeDef) HAL_I2C_Mem_Read(&STUSB16xx_I2CxHandle, (Addr<<1), (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size, TIMEOUT_MAX);
 8006812:	24fa      	movs	r4, #250	; 0xfa
 8006814:	00e4      	lsls	r4, r4, #3
 8006816:	9301      	str	r3, [sp, #4]
 8006818:	9000      	str	r0, [sp, #0]
 800681a:	b292      	uxth	r2, r2
 800681c:	0049      	lsls	r1, r1, #1
 800681e:	9402      	str	r4, [sp, #8]
 8006820:	2301      	movs	r3, #1
 8006822:	4802      	ldr	r0, [pc, #8]	; (800682c <STUSB1602_ReadReg+0x1c>)
 8006824:	f001 fb1a 	bl	8007e5c <HAL_I2C_Mem_Read>
    return status;
  }
 8006828:	b004      	add	sp, #16
 800682a:	bd10      	pop	{r4, pc}
 800682c:	20001a20 	.word	0x20001a20

08006830 <STUSB1602_WriteReg>:
  * @param Reg          Address of first register to be write
  * @param Size         Amount of bytes to be write
  * @retval STUSB1602_StatusTypeDef Allowed values are STUSB1602_OK, STUSB1602_ERROR, STUSB1602_BUSY, STUSB1602_TIMEOUT
  */
STUSB1602_StatusTypeDef STUSB1602_WriteReg(uint8_t* pBuffer, uint8_t Addr, uint8_t Reg, uint16_t Size)
  {
 8006830:	b51f      	push	{r0, r1, r2, r3, r4, lr}
      return STUSB1602_OK;
    }
#endif
    STUSB1602_StatusTypeDef status = STUSB1602_OK;

    status = (STUSB1602_StatusTypeDef)HAL_I2C_Mem_Write(&STUSB16xx_I2CxHandle, (Addr<<1), (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size,
 8006832:	24fa      	movs	r4, #250	; 0xfa
 8006834:	00e4      	lsls	r4, r4, #3
 8006836:	9301      	str	r3, [sp, #4]
 8006838:	9000      	str	r0, [sp, #0]
 800683a:	b292      	uxth	r2, r2
 800683c:	0049      	lsls	r1, r1, #1
 800683e:	9402      	str	r4, [sp, #8]
 8006840:	2301      	movs	r3, #1
 8006842:	4802      	ldr	r0, [pc, #8]	; (800684c <STUSB1602_WriteReg+0x1c>)
 8006844:	f001 fa50 	bl	8007ce8 <HAL_I2C_Mem_Write>
                            TIMEOUT_MAX);
 
    return status;
  }
 8006848:	b004      	add	sp, #16
 800684a:	bd10      	pop	{r4, pc}
 800684c:	20001a20 	.word	0x20001a20

08006850 <STUSB1602_Alert_Monitoring_Get>:
  * @brief  Check registers from 0x0B to 0x12
  * @param  Addr I2C address of port controller device
  * @retval STUSB1602_ALERT_MONITORING_TypeDef 
  */ 
STUSB1602_ALERT_MONITORING_TypeDef STUSB1602_Alert_Monitoring_Get(uint8_t Addr)
{
 8006850:	b513      	push	{r0, r1, r4, lr}
 8006852:	0004      	movs	r4, r0
    STUSB1602_ALERT_MONITORING_TypeDef reg;

    STUSB1602_ReadReg(&reg.reg_0B.d8, Addr, STUSB1602_ALERT_STATUS_REG, 8); 
 8006854:	2308      	movs	r3, #8
 8006856:	220b      	movs	r2, #11
 8006858:	4668      	mov	r0, sp
 800685a:	f7ff ffd9 	bl	8006810 <STUSB1602_ReadReg>

    return (reg);
 800685e:	2208      	movs	r2, #8
 8006860:	4669      	mov	r1, sp
 8006862:	0020      	movs	r0, r4
 8006864:	f005 fe42 	bl	800c4ec <memcpy>
}
 8006868:	0020      	movs	r0, r4
 800686a:	bd16      	pop	{r1, r2, r4, pc}

0800686c <STUSB1602_CC_Detect_Alrt_Int_Mask_Set>:
  * @param  Addr I2C address of port controller device
  * @param  st Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */ 
STUSB1602_StatusTypeDef STUSB1602_CC_Detect_Alrt_Int_Mask_Set(uint8_t Addr, CC_Detect_Alrt_Int_Mask_Status_TypeDef st)
{
 800686c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  

    STUSB1602_ALERT_STATUS_MASK_reg_TypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_ALERT_STATUS_MASK_REG, 1); 
 800686e:	ac01      	add	r4, sp, #4
{
 8006870:	0005      	movs	r5, r0
 8006872:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_ALERT_STATUS_MASK_REG, 1); 
 8006874:	2301      	movs	r3, #1
 8006876:	0001      	movs	r1, r0
 8006878:	220c      	movs	r2, #12
 800687a:	0020      	movs	r0, r4
 800687c:	f7ff ffc8 	bl	8006810 <STUSB1602_ReadReg>

    reg.b.CC_DETECTION_STATUS_AL_MASK = st;
 8006880:	2301      	movs	r3, #1
 8006882:	2240      	movs	r2, #64	; 0x40
 8006884:	7821      	ldrb	r1, [r4, #0]
 8006886:	401e      	ands	r6, r3
 8006888:	01b6      	lsls	r6, r6, #6
 800688a:	4391      	bics	r1, r2
 800688c:	4331      	orrs	r1, r6
 800688e:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_ALERT_STATUS_MASK_REG, 1);
 8006890:	3a34      	subs	r2, #52	; 0x34
 8006892:	0029      	movs	r1, r5
 8006894:	0020      	movs	r0, r4
 8006896:	f7ff ffcb 	bl	8006830 <STUSB1602_WriteReg>

    return status;
}
 800689a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

0800689c <STUSB1602_Attach_State_Trans_Get>:
  * @brief  STUSB1602 Checks Attach State Transition Reg (Bit0 0x0D -- RC)
  * @param  Addr I2C address of port controller device
  * @retval Attach_State_Trans_TypeDef 
  */ 
Attach_State_Trans_TypeDef STUSB1602_Attach_State_Trans_Get(uint8_t Addr)
{
 800689c:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_DETECTION_STATUS_TRANS_RegTypeDef reg;

    /* Check if a Transition occurred on ATTACH_STATE bit */
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_TRANS_REG, 1); 
 800689e:	ac01      	add	r4, sp, #4
{
 80068a0:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_TRANS_REG, 1); 
 80068a2:	2301      	movs	r3, #1
 80068a4:	220d      	movs	r2, #13
 80068a6:	0020      	movs	r0, r4
 80068a8:	f7ff ffb2 	bl	8006810 <STUSB1602_ReadReg>

    return (Attach_State_Trans_TypeDef)(reg.b.ATTACH_STATE_TRANS);
 80068ac:	7820      	ldrb	r0, [r4, #0]
 80068ae:	07c0      	lsls	r0, r0, #31
 80068b0:	0fc0      	lsrs	r0, r0, #31
}
 80068b2:	bd16      	pop	{r1, r2, r4, pc}

080068b4 <STUSB1602_CC_Detection_Status_Get>:
  * @brief  STUSB1602 CC Detection Status  (Register 0x0E -- RO)
  * @param  Addr I2C address of port controller device
  * @retval STUSB1602_CC_DETECTION_STATUS_RegTypeDef
  */ 
STUSB1602_CC_DETECTION_STATUS_RegTypeDef STUSB1602_CC_Detection_Status_Get(uint8_t Addr)
{
 80068b4:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_DETECTION_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_REG, 1); 
 80068b6:	ac01      	add	r4, sp, #4
{
 80068b8:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_REG, 1); 
 80068ba:	2301      	movs	r3, #1
 80068bc:	220e      	movs	r2, #14
 80068be:	0020      	movs	r0, r4
 80068c0:	f7ff ffa6 	bl	8006810 <STUSB1602_ReadReg>

    return (reg);
 80068c4:	7820      	ldrb	r0, [r4, #0]
}
 80068c6:	bd16      	pop	{r1, r2, r4, pc}

080068c8 <STUSB1602_Monitoring_Status_Trans_Reg_Get>:
  * @brief STUSB1602 checks the entire Monitoring_Status_Trans_Reg (bit0-7 0x0F -- RC)
  * @param Addr I2C address of port controller device 
  * @retval STUSB1602_MONITORING_STATUS_TRANS_RegTypeDef
  */ 
STUSB1602_MONITORING_STATUS_TRANS_RegTypeDef STUSB1602_Monitoring_Status_Trans_Reg_Get(uint8_t Addr)
{
 80068c8:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_TRANS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_TRANS_REG, 1); 
 80068ca:	ac01      	add	r4, sp, #4
{
 80068cc:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_TRANS_REG, 1); 
 80068ce:	2301      	movs	r3, #1
 80068d0:	220f      	movs	r2, #15
 80068d2:	0020      	movs	r0, r4
 80068d4:	f7ff ff9c 	bl	8006810 <STUSB1602_ReadReg>

    return (reg);
 80068d8:	7820      	ldrb	r0, [r4, #0]
}
 80068da:	bd16      	pop	{r1, r2, r4, pc}

080068dc <STUSB1602_VBUS_Valid_Get>:
  * @brief STUSB1602 checks VBUS_Valid (bit3 0x10 -- RO)
  * @param Addr I2C address of port controller device  
  * @retval @ref VBUS_Valid_TypeDef
  */ 
VBUS_Valid_TypeDef STUSB1602_VBUS_Valid_Get(uint8_t Addr)
{
 80068dc:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 80068de:	ac01      	add	r4, sp, #4
{
 80068e0:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 80068e2:	2301      	movs	r3, #1
 80068e4:	2210      	movs	r2, #16
 80068e6:	0020      	movs	r0, r4
 80068e8:	f7ff ff92 	bl	8006810 <STUSB1602_ReadReg>

    return (VBUS_Valid_TypeDef)(reg.b.VBUS_VALID);
 80068ec:	7820      	ldrb	r0, [r4, #0]
 80068ee:	0700      	lsls	r0, r0, #28
 80068f0:	0fc0      	lsrs	r0, r0, #31
}
 80068f2:	bd16      	pop	{r1, r2, r4, pc}

080068f4 <STUSB1602_VBUS_VSAFE0V_Get>:
  * @brief  STUSB1602 checks VBUS_VSAFE0V (bit2 0x10 -- RO)
  * @param Addr I2C address of port controller device   
  * @retval @ref VBUS_VSAFE0V_TypeDef
  */
VBUS_VSAFE0V_TypeDef STUSB1602_VBUS_VSAFE0V_Get(uint8_t Addr)
{
 80068f4:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 80068f6:	ac01      	add	r4, sp, #4
{
 80068f8:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 80068fa:	2301      	movs	r3, #1
 80068fc:	2210      	movs	r2, #16
 80068fe:	0020      	movs	r0, r4
 8006900:	f7ff ff86 	bl	8006810 <STUSB1602_ReadReg>

    return (VBUS_VSAFE0V_TypeDef)(reg.b.VBUS_VSAFE0V);
 8006904:	7820      	ldrb	r0, [r4, #0]
 8006906:	0740      	lsls	r0, r0, #29
 8006908:	0fc0      	lsrs	r0, r0, #31
}
 800690a:	bd16      	pop	{r1, r2, r4, pc}

0800690c <STUSB1602_VBUS_Presence_Get>:
  * @brief STUSB1602 checks VBUS_Presence (bit1 0x10 -- RO)
  * @param Addr I2C address of port controller device   
  * @retval VBUS_Presence_TypeDef
  */ 
VBUS_Presence_TypeDef STUSB1602_VBUS_Presence_Get(uint8_t Addr)
{
 800690c:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 800690e:	ac01      	add	r4, sp, #4
{
 8006910:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 8006912:	2301      	movs	r3, #1
 8006914:	2210      	movs	r2, #16
 8006916:	0020      	movs	r0, r4
 8006918:	f7ff ff7a 	bl	8006810 <STUSB1602_ReadReg>

    return (VBUS_Presence_TypeDef)(reg.b.VBUS_PRESENCE);
 800691c:	7820      	ldrb	r0, [r4, #0]
 800691e:	0780      	lsls	r0, r0, #30
 8006920:	0fc0      	lsrs	r0, r0, #31
}
 8006922:	bd16      	pop	{r1, r2, r4, pc}

08006924 <STUSB1602_Sink_Power_State_Get>:
  * @brief STUSB1602 checks the Sink_Power_State mode (bit6-5 0x11 -- RO)
  * @param Addr I2C address of port controller device
  * @retval Sink_Power_State_TypeDef
  */ 
Sink_Power_State_TypeDef STUSB1602_Sink_Power_State_Get(uint8_t Addr)
{
 8006924:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_CONNECTION_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 8006926:	ac01      	add	r4, sp, #4
{
 8006928:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 800692a:	2301      	movs	r3, #1
 800692c:	2211      	movs	r2, #17
 800692e:	0020      	movs	r0, r4
 8006930:	f7ff ff6e 	bl	8006810 <STUSB1602_ReadReg>

    return (Sink_Power_State_TypeDef)(reg.b.SINK_POWER_STATE);
 8006934:	7820      	ldrb	r0, [r4, #0]
 8006936:	0640      	lsls	r0, r0, #25
 8006938:	0f80      	lsrs	r0, r0, #30
}
 800693a:	bd16      	pop	{r1, r2, r4, pc}

0800693c <STUSB1602_TypeC_FSM_State_Get>:
  * @brief STUSB1602 checks the TypeC_FSM_State (bit4-0 0x11 -- RO)
  * @param Addr I2C address of port controller device
  * @retval TypeC_FSM_State_TypeDef
  */
TypeC_FSM_State_TypeDef STUSB1602_TypeC_FSM_State_Get(uint8_t Addr)
{
 800693c:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_CONNECTION_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 800693e:	ac01      	add	r4, sp, #4
{
 8006940:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 8006942:	2301      	movs	r3, #1
 8006944:	2211      	movs	r2, #17
 8006946:	0020      	movs	r0, r4
 8006948:	f7ff ff62 	bl	8006810 <STUSB1602_ReadReg>

    return (TypeC_FSM_State_TypeDef)(reg.b.TYPEC_FSM_STATE);
 800694c:	7820      	ldrb	r0, [r4, #0]
 800694e:	06c0      	lsls	r0, r0, #27
 8006950:	0ec0      	lsrs	r0, r0, #27
}
 8006952:	bd16      	pop	{r1, r2, r4, pc}

08006954 <STUSB1602_Hard_Fault_Trans_Status_Get>:
  * @brief STUSB1602 checks the entire HW_FAULT_STATUS_TRANS reg (bit7 0x12 -- RC)
  * @param Addr Address of the used port
  * @retval     STUSB1602_HW_FAULT_STATUS_TRANS_RegTypeDef
  */
STUSB1602_HW_FAULT_STATUS_TRANS_RegTypeDef STUSB1602_Hard_Fault_Trans_Status_Get(uint8_t Addr)
{
 8006954:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_HW_FAULT_STATUS_TRANS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_HW_FAULT_STATUS_TRANS_REG, 1); 
 8006956:	ac01      	add	r4, sp, #4
{
 8006958:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_HW_FAULT_STATUS_TRANS_REG, 1); 
 800695a:	2301      	movs	r3, #1
 800695c:	2212      	movs	r2, #18
 800695e:	0020      	movs	r0, r4
 8006960:	f7ff ff56 	bl	8006810 <STUSB1602_ReadReg>

    return (reg);
 8006964:	7820      	ldrb	r0, [r4, #0]
}  
 8006966:	bd16      	pop	{r1, r2, r4, pc}

08006968 <STUSB1602_Current_Advertised_Set>:
  * @param Addr I2C address of port controller device
  * @param curr_cap Current Capability Advertised  of the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_Current_Advertised_Set(uint8_t Addr, Current_Capability_Advertised_TypeDef curr_cap)
{
 8006968:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 800696a:	ac01      	add	r4, sp, #4
{
 800696c:	0005      	movs	r5, r0
 800696e:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006970:	2301      	movs	r3, #1
 8006972:	0001      	movs	r1, r0
 8006974:	2218      	movs	r2, #24
 8006976:	0020      	movs	r0, r4
 8006978:	f7ff ff4a 	bl	8006810 <STUSB1602_ReadReg>
    
    reg.b.CC_CURRENT_ADVERTISED = curr_cap;
 800697c:	233f      	movs	r3, #63	; 0x3f
 800697e:	7821      	ldrb	r1, [r4, #0]
 8006980:	01b6      	lsls	r6, r6, #6
 8006982:	4019      	ands	r1, r3
 8006984:	4331      	orrs	r1, r6
 8006986:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006988:	3b3e      	subs	r3, #62	; 0x3e
 800698a:	0029      	movs	r1, r5
 800698c:	2218      	movs	r2, #24
 800698e:	0020      	movs	r0, r4
 8006990:	f7ff ff4e 	bl	8006830 <STUSB1602_WriteReg>
       
    return status;
}
 8006994:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006996 <STUSB1602_SNK_Disconnect_Mode_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st SNK_DISCONNECT_MODE to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_SNK_Disconnect_Mode_Status_Set(uint8_t Addr, SNK_Disconnect_Mode_TypeDef st)
{
 8006996:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006998:	ac01      	add	r4, sp, #4
{
 800699a:	0005      	movs	r5, r0
 800699c:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 800699e:	2301      	movs	r3, #1
 80069a0:	0001      	movs	r1, r0
 80069a2:	2218      	movs	r2, #24
 80069a4:	0020      	movs	r0, r4
 80069a6:	f7ff ff33 	bl	8006810 <STUSB1602_ReadReg>

    reg.b.SNK_DISCONNECT_MODE = st;
 80069aa:	2301      	movs	r3, #1
 80069ac:	2220      	movs	r2, #32
 80069ae:	7821      	ldrb	r1, [r4, #0]
 80069b0:	401e      	ands	r6, r3
 80069b2:	0176      	lsls	r6, r6, #5
 80069b4:	4391      	bics	r1, r2
 80069b6:	4331      	orrs	r1, r6
 80069b8:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 80069ba:	3a08      	subs	r2, #8
 80069bc:	0029      	movs	r1, r5
 80069be:	0020      	movs	r0, r4
 80069c0:	f7ff ff36 	bl	8006830 <STUSB1602_WriteReg>

    return status;
}
 80069c4:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

080069c6 <STUSB1602_VCONN_Discharge_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st VCONN_Discharge_Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Discharge_Status_Set(uint8_t Addr, VCONN_Discharge_Status_TypeDef st)
{
 80069c6:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 80069c8:	ac01      	add	r4, sp, #4
{
 80069ca:	0005      	movs	r5, r0
 80069cc:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 80069ce:	2301      	movs	r3, #1
 80069d0:	0001      	movs	r1, r0
 80069d2:	2218      	movs	r2, #24
 80069d4:	0020      	movs	r0, r4
 80069d6:	f7ff ff1b 	bl	8006810 <STUSB1602_ReadReg>
    
    reg.b.CC_VCONN_DISCHARGE_EN = st;
 80069da:	2301      	movs	r3, #1
 80069dc:	2210      	movs	r2, #16
 80069de:	7821      	ldrb	r1, [r4, #0]
 80069e0:	401e      	ands	r6, r3
 80069e2:	0136      	lsls	r6, r6, #4
 80069e4:	4391      	bics	r1, r2
 80069e6:	4331      	orrs	r1, r6
 80069e8:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 80069ea:	3208      	adds	r2, #8
 80069ec:	0029      	movs	r1, r5
 80069ee:	0020      	movs	r0, r4
 80069f0:	f7ff ff1e 	bl	8006830 <STUSB1602_WriteReg>
       
    return status;
}
 80069f4:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

080069f6 <STUSB1602_Data_Role_Swap_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */ 
STUSB1602_StatusTypeDef STUSB1602_Data_Role_Swap_Status_Set(uint8_t Addr, Data_Role_Swap_TypeDef st)
{
 80069f6:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 80069f8:	ac01      	add	r4, sp, #4
{
 80069fa:	0005      	movs	r5, r0
 80069fc:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 80069fe:	2301      	movs	r3, #1
 8006a00:	0001      	movs	r1, r0
 8006a02:	2218      	movs	r2, #24
 8006a04:	0020      	movs	r0, r4
 8006a06:	f7ff ff03 	bl	8006810 <STUSB1602_ReadReg>
    
    reg.b.DR_SWAP_EN = st;
 8006a0a:	2301      	movs	r3, #1
 8006a0c:	2208      	movs	r2, #8
 8006a0e:	7821      	ldrb	r1, [r4, #0]
 8006a10:	401e      	ands	r6, r3
 8006a12:	00f6      	lsls	r6, r6, #3
 8006a14:	4391      	bics	r1, r2
 8006a16:	4331      	orrs	r1, r6
 8006a18:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006a1a:	3210      	adds	r2, #16
 8006a1c:	0029      	movs	r1, r5
 8006a1e:	0020      	movs	r0, r4
 8006a20:	f7ff ff06 	bl	8006830 <STUSB1602_WriteReg>
    
    return status;
}
 8006a24:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006a26 <STUSB1602_Power_Role_Swap_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */ 
STUSB1602_StatusTypeDef STUSB1602_Power_Role_Swap_Status_Set(uint8_t Addr, Power_Role_Swap_TypeDef st)
{
 8006a26:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 8006a28:	ac01      	add	r4, sp, #4
{
 8006a2a:	0005      	movs	r5, r0
 8006a2c:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 8006a2e:	2301      	movs	r3, #1
 8006a30:	0001      	movs	r1, r0
 8006a32:	2218      	movs	r2, #24
 8006a34:	0020      	movs	r0, r4
 8006a36:	f7ff feeb 	bl	8006810 <STUSB1602_ReadReg>
    
    reg.b.PR_SWAP_EN = st;
 8006a3a:	2301      	movs	r3, #1
 8006a3c:	2204      	movs	r2, #4
 8006a3e:	7821      	ldrb	r1, [r4, #0]
 8006a40:	401e      	ands	r6, r3
 8006a42:	00b6      	lsls	r6, r6, #2
 8006a44:	4391      	bics	r1, r2
 8006a46:	4331      	orrs	r1, r6
 8006a48:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006a4a:	3214      	adds	r2, #20
 8006a4c:	0029      	movs	r1, r5
 8006a4e:	0020      	movs	r0, r4
 8006a50:	f7ff feee 	bl	8006830 <STUSB1602_WriteReg>
    
    return status;
}
 8006a54:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006a56 <STUSB1602_VCONN_Supply_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st VCONN_Supply_Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Supply_Status_Set(uint8_t Addr, VCONN_Supply_Status_TypeDef st)
{
 8006a56:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006a58:	ac01      	add	r4, sp, #4
{
 8006a5a:	0005      	movs	r5, r0
 8006a5c:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006a5e:	2301      	movs	r3, #1
 8006a60:	0001      	movs	r1, r0
 8006a62:	2218      	movs	r2, #24
 8006a64:	0020      	movs	r0, r4
 8006a66:	f7ff fed3 	bl	8006810 <STUSB1602_ReadReg>
    
    reg.b.CC_VCONN_SUPPLY_EN = st;
 8006a6a:	2301      	movs	r3, #1
 8006a6c:	7821      	ldrb	r1, [r4, #0]
 8006a6e:	401e      	ands	r6, r3
 8006a70:	4399      	bics	r1, r3
 8006a72:	4331      	orrs	r1, r6
 8006a74:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006a76:	2218      	movs	r2, #24
 8006a78:	0029      	movs	r1, r5
 8006a7a:	0020      	movs	r0, r4
 8006a7c:	f7ff fed8 	bl	8006830 <STUSB1602_WriteReg>
       
    return status;
}
 8006a80:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006a82 <STUSB1602_VCONN_Switch_Current_Limit_Set>:
  * @param Addr I2C address of port controller device
  * @param curr_lim Current limit value to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Switch_Current_Limit_Set(uint8_t Addr, VCONN_Switch_Current_Limit_TypeDef curr_lim)
{
 8006a82:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_CC_VCONN_SWITCH_CTRL_RegTypeDef reg; 
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_VCONN_SWITCH_CTRL_REG, 1); 
 8006a84:	ac01      	add	r4, sp, #4
{
 8006a86:	0005      	movs	r5, r0
 8006a88:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_VCONN_SWITCH_CTRL_REG, 1); 
 8006a8a:	2301      	movs	r3, #1
 8006a8c:	0001      	movs	r1, r0
 8006a8e:	221e      	movs	r2, #30
 8006a90:	0020      	movs	r0, r4
 8006a92:	f7ff febd 	bl	8006810 <STUSB1602_ReadReg>
  
    reg.b.CC_VCONN_SWITCH_ILIM = curr_lim;
 8006a96:	230f      	movs	r3, #15
 8006a98:	7821      	ldrb	r1, [r4, #0]
 8006a9a:	401e      	ands	r6, r3
 8006a9c:	4399      	bics	r1, r3
 8006a9e:	4331      	orrs	r1, r6
 8006aa0:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_VCONN_SWITCH_CTRL_REG, 1);
 8006aa2:	3b0e      	subs	r3, #14
 8006aa4:	0029      	movs	r1, r5
 8006aa6:	221e      	movs	r2, #30
 8006aa8:	0020      	movs	r0, r4
 8006aaa:	f7ff fec1 	bl	8006830 <STUSB1602_WriteReg>

    return status;
}
 8006aae:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006ab0 <STUSB1602_Type_C_Control_Set>:
  * @param Addr I2C address of port controller device
  * @param Ctrl Control to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_Type_C_Control_Set(uint8_t Addr, Type_C_CTRL_TypeDef Ctrl)
{
 8006ab0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_CC_MODE_CTRL_RegTypeDef reg; 
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_MODE_CTRL_REG, 1); 
 8006ab2:	ac01      	add	r4, sp, #4
{
 8006ab4:	0005      	movs	r5, r0
 8006ab6:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_MODE_CTRL_REG, 1); 
 8006ab8:	2301      	movs	r3, #1
 8006aba:	0001      	movs	r1, r0
 8006abc:	221f      	movs	r2, #31
 8006abe:	0020      	movs	r0, r4
 8006ac0:	f7ff fea6 	bl	8006810 <STUSB1602_ReadReg>
  
    reg.b.TYPEC_CTRL = Ctrl;
 8006ac4:	230f      	movs	r3, #15
 8006ac6:	7821      	ldrb	r1, [r4, #0]
 8006ac8:	0136      	lsls	r6, r6, #4
 8006aca:	4019      	ands	r1, r3
 8006acc:	4331      	orrs	r1, r6
 8006ace:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_MODE_CTRL_REG, 1);
 8006ad0:	3b0e      	subs	r3, #14
 8006ad2:	0029      	movs	r1, r5
 8006ad4:	221f      	movs	r2, #31
 8006ad6:	0020      	movs	r0, r4
 8006ad8:	f7ff feaa 	bl	8006830 <STUSB1602_WriteReg>

    return status;
}
 8006adc:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006ade <STUSB1602_VCONN_Monitor_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st Power mode to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Monitor_Status_Set(uint8_t Addr, VCONN_Monitoring_TypeDef st)
{
 8006ade:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VCONN_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006ae0:	ac01      	add	r4, sp, #4
{
 8006ae2:	0005      	movs	r5, r0
 8006ae4:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006ae6:	2301      	movs	r3, #1
 8006ae8:	0001      	movs	r1, r0
 8006aea:	2220      	movs	r2, #32
 8006aec:	0020      	movs	r0, r4
 8006aee:	f7ff fe8f 	bl	8006810 <STUSB1602_ReadReg>
  
    reg.b.VCONN_MONITORING_EN = st;
 8006af2:	237f      	movs	r3, #127	; 0x7f
 8006af4:	7821      	ldrb	r1, [r4, #0]
 8006af6:	01f6      	lsls	r6, r6, #7
 8006af8:	4019      	ands	r1, r3
 8006afa:	4331      	orrs	r1, r6
 8006afc:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1);
 8006afe:	3b7e      	subs	r3, #126	; 0x7e
 8006b00:	0029      	movs	r1, r5
 8006b02:	2220      	movs	r2, #32
 8006b04:	0020      	movs	r0, r4
 8006b06:	f7ff fe93 	bl	8006830 <STUSB1602_WriteReg>

    return status;
}
 8006b0a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006b0c <STUSB1602_VCONN_UVLO_Thresh_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param thr Power mode to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_UVLO_Thresh_Status_Set(uint8_t Addr, VCONN_UVLO_Threshold_TypeDef thr)
{
 8006b0c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VCONN_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006b0e:	ac01      	add	r4, sp, #4
{
 8006b10:	0005      	movs	r5, r0
 8006b12:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006b14:	2301      	movs	r3, #1
 8006b16:	0001      	movs	r1, r0
 8006b18:	2220      	movs	r2, #32
 8006b1a:	0020      	movs	r0, r4
 8006b1c:	f7ff fe78 	bl	8006810 <STUSB1602_ReadReg>
  
    reg.b.VCONN_UVLO_THRESHOLD = thr;
 8006b20:	2301      	movs	r3, #1
 8006b22:	2240      	movs	r2, #64	; 0x40
 8006b24:	7821      	ldrb	r1, [r4, #0]
 8006b26:	401e      	ands	r6, r3
 8006b28:	01b6      	lsls	r6, r6, #6
 8006b2a:	4391      	bics	r1, r2
 8006b2c:	4331      	orrs	r1, r6
 8006b2e:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1);
 8006b30:	3a20      	subs	r2, #32
 8006b32:	0029      	movs	r1, r5
 8006b34:	0020      	movs	r0, r4
 8006b36:	f7ff fe7b 	bl	8006830 <STUSB1602_WriteReg>

    return status;
}
 8006b3a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006b3c <STUSB1602_VBUS_Select_Status_Get>:
  * @brief STUSB1602 checks the VBUS_SELECT (bit7:0 0x21 -- R/W)
  * @param Addr I2C address of port controller device
  * @retval uint16_t 
  */   
uint16_t STUSB1602_VBUS_Select_Status_Get(uint8_t Addr)
{
 8006b3c:	b513      	push	{r0, r1, r4, lr}
    uint8_t reg; /* first default value = 50 */
    uint16_t DAC_mV=0;
#ifndef __VVAR     
    STUSB1602_ReadReg(&reg, Addr, STUSB1602_VBUS_SELECT_REG, 1);
 8006b3e:	466b      	mov	r3, sp
 8006b40:	1ddc      	adds	r4, r3, #7
{
 8006b42:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg, Addr, STUSB1602_VBUS_SELECT_REG, 1);
 8006b44:	2301      	movs	r3, #1
 8006b46:	2221      	movs	r2, #33	; 0x21
 8006b48:	0020      	movs	r0, r4
 8006b4a:	f7ff fe61 	bl	8006810 <STUSB1602_ReadReg>
#else
    STUSB1602_ReadReg_P1(&reg, Addr+1, STUSB1602_VBUS_SELECT_REG, 1);
#endif
    DAC_mV=(uint16_t)(reg*100);
 8006b4e:	2364      	movs	r3, #100	; 0x64
 8006b50:	7820      	ldrb	r0, [r4, #0]
 8006b52:	4358      	muls	r0, r3
    
    return DAC_mV;
}
 8006b54:	bd16      	pop	{r1, r2, r4, pc}
	...

08006b58 <STUSB1602_VBUS_Select_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param mV The value (expressed in mV) to set the internal reference DAC
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_Select_Status_Set(uint8_t Addr, uint16_t mV)
{
 8006b58:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8006b5a:	0004      	movs	r4, r0
 8006b5c:	0008      	movs	r0, r1
    
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    uint8_t reg; /* first default value = 50 */     
    
    reg =(uint8_t)(mV/100);
 8006b5e:	2164      	movs	r1, #100	; 0x64
 8006b60:	f7fe ff28 	bl	80059b4 <__udivsi3>
 8006b64:	466b      	mov	r3, sp
    real_val[k] = reg;
 8006b66:	4907      	ldr	r1, [pc, #28]	; (8006b84 <STUSB1602_VBUS_Select_Status_Set+0x2c>)
    reg =(uint8_t)(mV/100);
 8006b68:	b2c2      	uxtb	r2, r0
    real_val[k] = reg;
 8006b6a:	4d07      	ldr	r5, [pc, #28]	; (8006b88 <STUSB1602_VBUS_Select_Status_Set+0x30>)
    reg =(uint8_t)(mV/100);
 8006b6c:	1dd8      	adds	r0, r3, #7
    real_val[k] = reg;
 8006b6e:	780b      	ldrb	r3, [r1, #0]
    reg =(uint8_t)(mV/100);
 8006b70:	7002      	strb	r2, [r0, #0]
    real_val[k] = reg;
 8006b72:	54ea      	strb	r2, [r5, r3]
      
    k++;
 8006b74:	3301      	adds	r3, #1
 8006b76:	700b      	strb	r3, [r1, #0]
#ifdef __VVAR
    STUSB1602_WriteReg_P1(&reg, Addr+1, STUSB1602_VBUS_SELECT_REG, 1);
#endif
    status = STUSB1602_WriteReg(&reg, Addr, STUSB1602_VBUS_SELECT_REG, 1);
 8006b78:	2221      	movs	r2, #33	; 0x21
 8006b7a:	2301      	movs	r3, #1
 8006b7c:	0021      	movs	r1, r4
 8006b7e:	f7ff fe57 	bl	8006830 <STUSB1602_WriteReg>
             
    return status;
}
 8006b82:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8006b84:	20001a6c 	.word	0x20001a6c
 8006b88:	20001a6d 	.word	0x20001a6d

08006b8c <STUSB1602_VBUS_VShift_High_Set>:
  * @param Addr I2C address of port controller device
  * @param Set The VShift_High value >= 5% (expressed in %) to set the high threshold value  
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_VShift_High_Set(uint8_t Addr, uint8_t Set)
{
 8006b8c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VBUS_RANGE_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006b8e:	ac01      	add	r4, sp, #4
{
 8006b90:	0005      	movs	r5, r0
 8006b92:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006b94:	2301      	movs	r3, #1
 8006b96:	0001      	movs	r1, r0
 8006b98:	2222      	movs	r2, #34	; 0x22
 8006b9a:	0020      	movs	r0, r4
 8006b9c:	f7ff fe38 	bl	8006810 <STUSB1602_ReadReg>
  
    reg.b.VBUS_VSHIFT_HIGH = (Set - 5);
 8006ba0:	230f      	movs	r3, #15
 8006ba2:	7821      	ldrb	r1, [r4, #0]
 8006ba4:	3e05      	subs	r6, #5
 8006ba6:	0136      	lsls	r6, r6, #4
 8006ba8:	4019      	ands	r1, r3
 8006baa:	4331      	orrs	r1, r6
 8006bac:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1);
 8006bae:	3b0e      	subs	r3, #14
 8006bb0:	0029      	movs	r1, r5
 8006bb2:	2222      	movs	r2, #34	; 0x22
 8006bb4:	0020      	movs	r0, r4
 8006bb6:	f7ff fe3b 	bl	8006830 <STUSB1602_WriteReg>
        
    return status;
}
 8006bba:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006bbc <STUSB1602_VBUS_VShift_Low_Set>:
  * @param Addr I2C address of port controller device
  * @param Set The VShift_Low value <=5% (expressed in %) to set the low threshold value
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_VShift_Low_Set(uint8_t Addr, int8_t Set)
{
 8006bbc:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8006bbe:	000c      	movs	r4, r1
    Set = (Set>0) ? -Set : Set;
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VBUS_RANGE_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006bc0:	ad01      	add	r5, sp, #4
{
 8006bc2:	0006      	movs	r6, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006bc4:	0001      	movs	r1, r0
 8006bc6:	2301      	movs	r3, #1
 8006bc8:	0028      	movs	r0, r5
 8006bca:	2222      	movs	r2, #34	; 0x22
 8006bcc:	f7ff fe20 	bl	8006810 <STUSB1602_ReadReg>
  
    reg.b.VBUS_VSHIFT_LOW = (-Set - 5);
 8006bd0:	220f      	movs	r2, #15
    Set = (Set>0) ? -Set : Set;
 8006bd2:	17e3      	asrs	r3, r4, #31
 8006bd4:	18e4      	adds	r4, r4, r3
 8006bd6:	405c      	eors	r4, r3
    reg.b.VBUS_VSHIFT_LOW = (-Set - 5);
 8006bd8:	782b      	ldrb	r3, [r5, #0]
 8006bda:	3c05      	subs	r4, #5
 8006bdc:	4393      	bics	r3, r2
 8006bde:	4014      	ands	r4, r2
 8006be0:	431c      	orrs	r4, r3
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1);
 8006be2:	0031      	movs	r1, r6
 8006be4:	0028      	movs	r0, r5
 8006be6:	2301      	movs	r3, #1
 8006be8:	3213      	adds	r2, #19
    reg.b.VBUS_VSHIFT_LOW = (-Set - 5);
 8006bea:	702c      	strb	r4, [r5, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1);
 8006bec:	f7ff fe20 	bl	8006830 <STUSB1602_WriteReg>
        
    return status;
}
 8006bf0:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006bf2 <STUSB1602_SW_RESET_Set>:
  * @param Addr I2C address of port controller device
  * @param Rst Enable or Disable of the SW RST function
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_SW_RESET_Set(uint8_t Addr, SW_RESET_TypeDef Rst)
{  
 8006bf2:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
    STUSB1602_RESET_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_RESET_CTRL_REG, 1); 
 8006bf4:	ac01      	add	r4, sp, #4
{  
 8006bf6:	0005      	movs	r5, r0
 8006bf8:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_RESET_CTRL_REG, 1); 
 8006bfa:	2301      	movs	r3, #1
 8006bfc:	0001      	movs	r1, r0
 8006bfe:	2223      	movs	r2, #35	; 0x23
 8006c00:	0020      	movs	r0, r4
 8006c02:	f7ff fe05 	bl	8006810 <STUSB1602_ReadReg>
  
    reg.b.SW_RESET_EN = Rst;
 8006c06:	2301      	movs	r3, #1
 8006c08:	7821      	ldrb	r1, [r4, #0]
 8006c0a:	401e      	ands	r6, r3
 8006c0c:	4399      	bics	r1, r3
 8006c0e:	4331      	orrs	r1, r6
 8006c10:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_RESET_CTRL_REG, 1);
 8006c12:	2223      	movs	r2, #35	; 0x23
 8006c14:	0029      	movs	r1, r5
 8006c16:	0020      	movs	r0, r4
 8006c18:	f7ff fe0a 	bl	8006830 <STUSB1602_WriteReg>
             
    return status;
}
 8006c1c:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006c1e <STUSB1602_Pwr_Acc_Detect_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_Pwr_Acc_Detect_Set(uint8_t Addr, Pwr_Acc_Detect_TypeDef st)
{    
 8006c1e:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
   STUSB1602_CC_POWERED_ACCESSORY_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_POWERED_ACCESSORY_CTRL_REG, 1);
 8006c20:	ac01      	add	r4, sp, #4
{    
 8006c22:	0005      	movs	r5, r0
 8006c24:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_POWERED_ACCESSORY_CTRL_REG, 1);
 8006c26:	2301      	movs	r3, #1
 8006c28:	0001      	movs	r1, r0
 8006c2a:	2224      	movs	r2, #36	; 0x24
 8006c2c:	0020      	movs	r0, r4
 8006c2e:	f7ff fdef 	bl	8006810 <STUSB1602_ReadReg>
  
   reg.b.PWR_ACC_DETECT_EN = st;    
 8006c32:	2301      	movs	r3, #1
 8006c34:	7821      	ldrb	r1, [r4, #0]
 8006c36:	401e      	ands	r6, r3
 8006c38:	4399      	bics	r1, r3
 8006c3a:	4331      	orrs	r1, r6
 8006c3c:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_POWERED_ACCESSORY_CTRL_REG, 1);
 8006c3e:	2224      	movs	r2, #36	; 0x24
 8006c40:	0029      	movs	r1, r5
 8006c42:	0020      	movs	r0, r4
 8006c44:	f7ff fdf4 	bl	8006830 <STUSB1602_WriteReg>
             
   return status;
}
 8006c48:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006c4a <STUSB1602_VBUS_Discharge_Time_to_0V_Set>:
  * @param Addr I2C address of port controller device
  * @param tim  VBUS discharge time in msec
  * @retval STUSB1602_StatusTypeDef
  */
STUSB1602_StatusTypeDef STUSB1602_VBUS_Discharge_Time_to_0V_Set(uint8_t Addr, uint16_t tim)
{
 8006c4a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8006c4c:	000e      	movs	r6, r1
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_DISCHARGE_TIME_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006c4e:	ac01      	add	r4, sp, #4
{
 8006c50:	0005      	movs	r5, r0
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006c52:	2301      	movs	r3, #1
 8006c54:	2225      	movs	r2, #37	; 0x25
 8006c56:	0001      	movs	r1, r0
 8006c58:	0020      	movs	r0, r4
 8006c5a:	f7ff fdd9 	bl	8006810 <STUSB1602_ReadReg>
   
   reg.b.VBUS_DISCHARGE_TIME_TO_0V = (uint8_t)(tim/84);
 8006c5e:	0030      	movs	r0, r6
 8006c60:	2154      	movs	r1, #84	; 0x54
 8006c62:	f7fe fea7 	bl	80059b4 <__udivsi3>
 8006c66:	220f      	movs	r2, #15
 8006c68:	0103      	lsls	r3, r0, #4
 8006c6a:	7820      	ldrb	r0, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1); 
 8006c6c:	0029      	movs	r1, r5
   reg.b.VBUS_DISCHARGE_TIME_TO_0V = (uint8_t)(tim/84);
 8006c6e:	4010      	ands	r0, r2
 8006c70:	4318      	orrs	r0, r3
 8006c72:	7020      	strb	r0, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1); 
 8006c74:	2301      	movs	r3, #1
 8006c76:	3216      	adds	r2, #22
 8006c78:	0020      	movs	r0, r4
 8006c7a:	f7ff fdd9 	bl	8006830 <STUSB1602_WriteReg>
    
   return status;
}
 8006c7e:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006c80 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>:
  * @param Addr I2C address of port controller device
  * @param tim VBUS discharge time in msec
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_Discharge_Time_to_PDO_Set(uint8_t Addr, uint16_t tim)
{
 8006c80:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8006c82:	000e      	movs	r6, r1
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_DISCHARGE_TIME_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006c84:	ac01      	add	r4, sp, #4
{
 8006c86:	0005      	movs	r5, r0
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006c88:	2301      	movs	r3, #1
 8006c8a:	2225      	movs	r2, #37	; 0x25
 8006c8c:	0001      	movs	r1, r0
 8006c8e:	0020      	movs	r0, r4
 8006c90:	f7ff fdbe 	bl	8006810 <STUSB1602_ReadReg>
   
   reg.b.VBUS_DISCHARGE_TIME_TO_PDO = (uint8_t)(tim/20);
 8006c94:	0030      	movs	r0, r6
 8006c96:	2114      	movs	r1, #20
 8006c98:	f7fe fe8c 	bl	80059b4 <__udivsi3>
 8006c9c:	220f      	movs	r2, #15
 8006c9e:	0003      	movs	r3, r0
 8006ca0:	7820      	ldrb	r0, [r4, #0]
 8006ca2:	4013      	ands	r3, r2
 8006ca4:	4390      	bics	r0, r2
 8006ca6:	4318      	orrs	r0, r3
 8006ca8:	7020      	strb	r0, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1); 
 8006caa:	0029      	movs	r1, r5
 8006cac:	2301      	movs	r3, #1
 8006cae:	3216      	adds	r2, #22
 8006cb0:	0020      	movs	r0, r4
 8006cb2:	f7ff fdbd 	bl	8006830 <STUSB1602_WriteReg>
    
   return status;
}
 8006cb6:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006cb8 <STUSB1602_VBUS_Discharge_State_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set
  * @retval STUSB1602_StatusTypeDef 
  */
STUSB1602_StatusTypeDef STUSB1602_VBUS_Discharge_State_Set(uint8_t Addr, VBUS_Discharge_State_TypeDef st)
{    
 8006cb8:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_DISCHARGE_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1); 
 8006cba:	ac01      	add	r4, sp, #4
{    
 8006cbc:	0005      	movs	r5, r0
 8006cbe:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1); 
 8006cc0:	2301      	movs	r3, #1
 8006cc2:	0001      	movs	r1, r0
 8006cc4:	2226      	movs	r2, #38	; 0x26
 8006cc6:	0020      	movs	r0, r4
 8006cc8:	f7ff fda2 	bl	8006810 <STUSB1602_ReadReg>
   
   reg.b.VBUS_DISCHARGE_EN = st;
 8006ccc:	237f      	movs	r3, #127	; 0x7f
 8006cce:	7821      	ldrb	r1, [r4, #0]
 8006cd0:	01f6      	lsls	r6, r6, #7
 8006cd2:	4019      	ands	r1, r3
 8006cd4:	4331      	orrs	r1, r6
 8006cd6:	7021      	strb	r1, [r4, #0]
#ifdef __VVAR
   STUSB1602_WriteReg_P1(&reg.d8, Addr+1, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1);
#endif
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1);
 8006cd8:	3b7e      	subs	r3, #126	; 0x7e
 8006cda:	0029      	movs	r1, r5
 8006cdc:	2226      	movs	r2, #38	; 0x26
 8006cde:	0020      	movs	r0, r4
 8006ce0:	f7ff fda6 	bl	8006830 <STUSB1602_WriteReg>
   
   return status;   
}
 8006ce4:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006ce6 <STUSB1602_Power_Mode_Set>:
  * @param Addr I2C address of port controller device
  * @param Pwr Power mode to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_Power_Mode_Set(uint8_t Addr, Power_Mode_TypeDef Pwr)
{
 8006ce6:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_MODE_CTRL_RegTypeDef reg; 
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MODE_CTRL_REG, 1); 
 8006ce8:	ac01      	add	r4, sp, #4
{
 8006cea:	0005      	movs	r5, r0
 8006cec:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MODE_CTRL_REG, 1); 
 8006cee:	2301      	movs	r3, #1
 8006cf0:	0001      	movs	r1, r0
 8006cf2:	2228      	movs	r2, #40	; 0x28
 8006cf4:	0020      	movs	r0, r4
 8006cf6:	f7ff fd8b 	bl	8006810 <STUSB1602_ReadReg>
  
    reg.b.POWER_MODE = Pwr;
 8006cfa:	2307      	movs	r3, #7
 8006cfc:	7821      	ldrb	r1, [r4, #0]
 8006cfe:	401e      	ands	r6, r3
 8006d00:	4399      	bics	r1, r3
 8006d02:	4331      	orrs	r1, r6
 8006d04:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_MODE_CTRL_REG, 1);
 8006d06:	3b06      	subs	r3, #6
 8006d08:	0029      	movs	r1, r5
 8006d0a:	2228      	movs	r2, #40	; 0x28
 8006d0c:	0020      	movs	r0, r4
 8006d0e:	f7ff fd8f 	bl	8006830 <STUSB1602_WriteReg>
             
    return status;
}
 8006d12:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006d14 <STUSB1602_NVM_OK_Get>:
  * @brief It checks if NVM is loaded correctly (bit0:1 0x2F -- R)
  * @param Addr I2C address of port controller device
  * @retval NVM_OK_TypeDef 
  */  
NVM_OK_TypeDef STUSB1602_NVM_OK_Get(uint8_t Addr)
{
 8006d14:	b513      	push	{r0, r1, r4, lr}
   STUSB1602_DEVICE_CUT_RegTypeDef reg;
        
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006d16:	ac01      	add	r4, sp, #4
{
 8006d18:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006d1a:	2301      	movs	r3, #1
 8006d1c:	222f      	movs	r2, #47	; 0x2f
 8006d1e:	0020      	movs	r0, r4
 8006d20:	f7ff fd76 	bl	8006810 <STUSB1602_ReadReg>
      
    return (NVM_OK_TypeDef)(reg.b.Reserved_0_2);
 8006d24:	7820      	ldrb	r0, [r4, #0]
 8006d26:	0780      	lsls	r0, r0, #30
 8006d28:	0f80      	lsrs	r0, r0, #30
}
 8006d2a:	bd16      	pop	{r1, r2, r4, pc}

08006d2c <STUSB1602_DEVICE_CUT_Get>:
  * @brief It gets the cut number (bit2:4 0x2F -- R)
  * @param Addr I2C address of port controller device
  * @retval DEVICE_CUT_TypeDef 
  */ 
DEVICE_CUT_TypeDef STUSB1602_DEVICE_CUT_Get(uint8_t Addr)
{
 8006d2c:	b513      	push	{r0, r1, r4, lr}
   STUSB1602_DEVICE_CUT_RegTypeDef reg;
        
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006d2e:	ac01      	add	r4, sp, #4
{
 8006d30:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006d32:	2301      	movs	r3, #1
 8006d34:	222f      	movs	r2, #47	; 0x2f
 8006d36:	0020      	movs	r0, r4
 8006d38:	f7ff fd6a 	bl	8006810 <STUSB1602_ReadReg>
      
    return (DEVICE_CUT_TypeDef)(reg.b.DEVICE_CUT);
 8006d3c:	7820      	ldrb	r0, [r4, #0]
 8006d3e:	06c0      	lsls	r0, r0, #27
 8006d40:	0f40      	lsrs	r0, r0, #29
}
 8006d42:	bd16      	pop	{r1, r2, r4, pc}

08006d44 <STUSB1602_VDD_OVLO_Threshold_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VDD_OVLO_Threshold_Set(uint8_t Addr, VDD_OVLO_Threshold_TypeDef st)
{      
 8006d44:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006d46:	ac01      	add	r4, sp, #4
{      
 8006d48:	0005      	movs	r5, r0
 8006d4a:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006d4c:	2301      	movs	r3, #1
 8006d4e:	0001      	movs	r1, r0
 8006d50:	222e      	movs	r2, #46	; 0x2e
 8006d52:	0020      	movs	r0, r4
 8006d54:	f7ff fd5c 	bl	8006810 <STUSB1602_ReadReg>
   
   reg.b.VDD_OVLO_DISABLE = st;
 8006d58:	2301      	movs	r3, #1
 8006d5a:	2240      	movs	r2, #64	; 0x40
 8006d5c:	7821      	ldrb	r1, [r4, #0]
 8006d5e:	401e      	ands	r6, r3
 8006d60:	01b6      	lsls	r6, r6, #6
 8006d62:	4391      	bics	r1, r2
 8006d64:	4331      	orrs	r1, r6
 8006d66:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006d68:	3a12      	subs	r2, #18
 8006d6a:	0029      	movs	r1, r5
 8006d6c:	0020      	movs	r0, r4
 8006d6e:	f7ff fd5f 	bl	8006830 <STUSB1602_WriteReg>
     
   return status;  
}
 8006d72:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006d74 <STUSB1602_VBUS_Range_State_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_Range_State_Set(uint8_t Addr, VBUS_Range_State_TypeDef st)
{      
 8006d74:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006d76:	ac01      	add	r4, sp, #4
{      
 8006d78:	0005      	movs	r5, r0
 8006d7a:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006d7c:	2301      	movs	r3, #1
 8006d7e:	0001      	movs	r1, r0
 8006d80:	222e      	movs	r2, #46	; 0x2e
 8006d82:	0020      	movs	r0, r4
 8006d84:	f7ff fd44 	bl	8006810 <STUSB1602_ReadReg>
   
   reg.b.VBUS_RANGE_DISABLE = st;
 8006d88:	2301      	movs	r3, #1
 8006d8a:	2210      	movs	r2, #16
 8006d8c:	7821      	ldrb	r1, [r4, #0]
 8006d8e:	401e      	ands	r6, r3
 8006d90:	0136      	lsls	r6, r6, #4
 8006d92:	4391      	bics	r1, r2
 8006d94:	4331      	orrs	r1, r6
 8006d96:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006d98:	321e      	adds	r2, #30
 8006d9a:	0029      	movs	r1, r5
 8006d9c:	0020      	movs	r0, r4
 8006d9e:	f7ff fd47 	bl	8006830 <STUSB1602_WriteReg>
     
   return status;  
}
 8006da2:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006da4 <STUSB1602_VBUS_VSAFE0V_Threshold_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_VSAFE0V_Threshold_Set(uint8_t Addr, VBUS_VSAFE0V_Threshold_TypeDef st)
{      
 8006da4:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006da6:	ac01      	add	r4, sp, #4
{      
 8006da8:	0005      	movs	r5, r0
 8006daa:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006dac:	2301      	movs	r3, #1
 8006dae:	0001      	movs	r1, r0
 8006db0:	222e      	movs	r2, #46	; 0x2e
 8006db2:	0020      	movs	r0, r4
 8006db4:	f7ff fd2c 	bl	8006810 <STUSB1602_ReadReg>
   
   reg.b.VBUS_VSAFE0V_THRESHOLD = st;
 8006db8:	2103      	movs	r1, #3
 8006dba:	2306      	movs	r3, #6
 8006dbc:	400e      	ands	r6, r1
 8006dbe:	7821      	ldrb	r1, [r4, #0]
 8006dc0:	0076      	lsls	r6, r6, #1
 8006dc2:	4399      	bics	r1, r3
 8006dc4:	4331      	orrs	r1, r6
 8006dc6:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006dc8:	3b05      	subs	r3, #5
 8006dca:	0029      	movs	r1, r5
 8006dcc:	222e      	movs	r2, #46	; 0x2e
 8006dce:	0020      	movs	r0, r4
 8006dd0:	f7ff fd2e 	bl	8006830 <STUSB1602_WriteReg>
     
   return status;  
}
 8006dd4:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006dd6 <STUSB1602_VDD_UVLO_Threshold_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VDD_UVLO_Threshold_Set(uint8_t Addr, VDD_UVLO_Threshold_TypeDef st)
{      
 8006dd6:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006dd8:	ac01      	add	r4, sp, #4
{      
 8006dda:	0005      	movs	r5, r0
 8006ddc:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006dde:	2301      	movs	r3, #1
 8006de0:	0001      	movs	r1, r0
 8006de2:	222e      	movs	r2, #46	; 0x2e
 8006de4:	0020      	movs	r0, r4
 8006de6:	f7ff fd13 	bl	8006810 <STUSB1602_ReadReg>
   
   reg.b.VDD_UVLO_DISABLE = st;
 8006dea:	2301      	movs	r3, #1
 8006dec:	7821      	ldrb	r1, [r4, #0]
 8006dee:	401e      	ands	r6, r3
 8006df0:	4399      	bics	r1, r3
 8006df2:	4331      	orrs	r1, r6
 8006df4:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006df6:	222e      	movs	r2, #46	; 0x2e
 8006df8:	0029      	movs	r1, r5
 8006dfa:	0020      	movs	r0, r4
 8006dfc:	f7ff fd18 	bl	8006830 <STUSB1602_WriteReg>
     
   return status;  
}
 8006e00:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006e02 <STUSB1602_Type_C_Command>:
  * @param Addr I2C address of port controller device
  * @param Ctrl Control to be set
  * @retval STUSB1602_StatusTypeDef
  */
STUSB1602_StatusTypeDef STUSB1602_Type_C_Command(uint8_t Addr, Type_C_CTRL_TypeDef Ctrl)
{
 8006e02:	b510      	push	{r4, lr}
    STUSB1602_StatusTypeDef ret = STUSB1602_Type_C_Control_Set(Addr, Ctrl); /* register */
 8006e04:	f7ff fe54 	bl	8006ab0 <STUSB1602_Type_C_Control_Set>
    return timeout > 0 ? ret : STUSB1602_TIMEOUT;
#else
    return ret;
#endif /* _DEBUG_ACK_ENABLE */

}
 8006e08:	bd10      	pop	{r4, pc}
	...

08006e0c <USBPD_BSP_LED_Set>:
  * @param  Value: value to set the led on or off.
  * @retval None
  */
  void USBPD_BSP_LED_Set(USBPD_BSP_Led_TypeDef Led, uint8_t Value)
  {
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, Value ? GPIO_PIN_RESET : GPIO_PIN_SET);
 8006e0c:	230c      	movs	r3, #12
 8006e0e:	424a      	negs	r2, r1
 8006e10:	414a      	adcs	r2, r1
 8006e12:	4358      	muls	r0, r3
  {
 8006e14:	b510      	push	{r4, lr}
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, Value ? GPIO_PIN_RESET : GPIO_PIN_SET);
 8006e16:	4c04      	ldr	r4, [pc, #16]	; (8006e28 <USBPD_BSP_LED_Set+0x1c>)
 8006e18:	b2d2      	uxtb	r2, r2
 8006e1a:	1823      	adds	r3, r4, r0
 8006e1c:	8899      	ldrh	r1, [r3, #4]
 8006e1e:	5900      	ldr	r0, [r0, r4]
 8006e20:	f000 fdb0 	bl	8007984 <HAL_GPIO_WritePin>
  }
 8006e24:	bd10      	pop	{r4, pc}
 8006e26:	46c0      	nop			; (mov r8, r8)
 8006e28:	20000000 	.word	0x20000000

08006e2c <USBPD_BSP_LED_On>:
  * @retval None
  */  
  
  void USBPD_BSP_LED_On(USBPD_BSP_Led_TypeDef Led)
  {
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_RESET);
 8006e2c:	230c      	movs	r3, #12
 8006e2e:	4358      	muls	r0, r3
  {
 8006e30:	b510      	push	{r4, lr}
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_RESET);
 8006e32:	4c04      	ldr	r4, [pc, #16]	; (8006e44 <USBPD_BSP_LED_On+0x18>)
 8006e34:	2200      	movs	r2, #0
 8006e36:	1823      	adds	r3, r4, r0
 8006e38:	8899      	ldrh	r1, [r3, #4]
 8006e3a:	5900      	ldr	r0, [r0, r4]
 8006e3c:	f000 fda2 	bl	8007984 <HAL_GPIO_WritePin>
  }
 8006e40:	bd10      	pop	{r4, pc}
 8006e42:	46c0      	nop			; (mov r8, r8)
 8006e44:	20000000 	.word	0x20000000

08006e48 <USBPD_BSP_LED_Off>:
  * @retval None
  */  
  
  void USBPD_BSP_LED_Off(USBPD_BSP_Led_TypeDef Led)
  {
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_SET);
 8006e48:	230c      	movs	r3, #12
 8006e4a:	4358      	muls	r0, r3
  {
 8006e4c:	b510      	push	{r4, lr}
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_SET);
 8006e4e:	4c04      	ldr	r4, [pc, #16]	; (8006e60 <USBPD_BSP_LED_Off+0x18>)
 8006e50:	2201      	movs	r2, #1
 8006e52:	1823      	adds	r3, r4, r0
 8006e54:	8899      	ldrh	r1, [r3, #4]
 8006e56:	5900      	ldr	r0, [r0, r4]
 8006e58:	f000 fd94 	bl	8007984 <HAL_GPIO_WritePin>
  }
 8006e5c:	bd10      	pop	{r4, pc}
 8006e5e:	46c0      	nop			; (mov r8, r8)
 8006e60:	20000000 	.word	0x20000000

08006e64 <USBPD_BSP_LED_Init>:
  {
 8006e64:	b530      	push	{r4, r5, lr}
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8006e66:	2301      	movs	r3, #1
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006e68:	2400      	movs	r4, #0
 8006e6a:	250c      	movs	r5, #12
  {
 8006e6c:	b087      	sub	sp, #28
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8006e6e:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006e70:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;    
 8006e72:	9404      	str	r4, [sp, #16]
 8006e74:	002a      	movs	r2, r5
 8006e76:	4362      	muls	r2, r4
        GPIO_InitStruct.Pin = USBPD_BSP_LEDs[led].GPIO_Pin;
 8006e78:	4b07      	ldr	r3, [pc, #28]	; (8006e98 <USBPD_BSP_LED_Init+0x34>)
 8006e7a:	1899      	adds	r1, r3, r2
 8006e7c:	8889      	ldrh	r1, [r1, #4]
        HAL_GPIO_Init(USBPD_BSP_LEDs[led].GPIOx, &GPIO_InitStruct);
 8006e7e:	58d0      	ldr	r0, [r2, r3]
        GPIO_InitStruct.Pin = USBPD_BSP_LEDs[led].GPIO_Pin;
 8006e80:	9101      	str	r1, [sp, #4]
        HAL_GPIO_Init(USBPD_BSP_LEDs[led].GPIOx, &GPIO_InitStruct);
 8006e82:	a901      	add	r1, sp, #4
 8006e84:	f000 fcbc 	bl	8007800 <HAL_GPIO_Init>
        USBPD_BSP_LED_Off((USBPD_BSP_Led_TypeDef)led);
 8006e88:	b260      	sxtb	r0, r4
 8006e8a:	3401      	adds	r4, #1
 8006e8c:	f7ff ffdc 	bl	8006e48 <USBPD_BSP_LED_Off>
    for(led=0;led<USBPD_BSP_LEDn;led++)
 8006e90:	2c07      	cmp	r4, #7
 8006e92:	d1ef      	bne.n	8006e74 <USBPD_BSP_LED_Init+0x10>
  }
 8006e94:	b007      	add	sp, #28
 8006e96:	bd30      	pop	{r4, r5, pc}
 8006e98:	20000000 	.word	0x20000000

08006e9c <USBPD_BSP_LED_Toggle>:
  * @retval None
  */ 
  
  void USBPD_BSP_LED_Toggle(USBPD_BSP_Led_TypeDef Led)
  {
    HAL_GPIO_TogglePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin);
 8006e9c:	230c      	movs	r3, #12
 8006e9e:	4358      	muls	r0, r3
  {
 8006ea0:	b510      	push	{r4, lr}
    HAL_GPIO_TogglePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin);
 8006ea2:	4a03      	ldr	r2, [pc, #12]	; (8006eb0 <USBPD_BSP_LED_Toggle+0x14>)
 8006ea4:	1813      	adds	r3, r2, r0
 8006ea6:	8899      	ldrh	r1, [r3, #4]
 8006ea8:	5880      	ldr	r0, [r0, r2]
 8006eaa:	f000 fd71 	bl	8007990 <HAL_GPIO_TogglePin>
  }
 8006eae:	bd10      	pop	{r4, pc}
 8006eb0:	20000000 	.word	0x20000000

08006eb4 <SystemInit>:
  */
void SystemInit(void)
{
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001U;
 8006eb4:	2101      	movs	r1, #1
 8006eb6:	4b11      	ldr	r3, [pc, #68]	; (8006efc <SystemInit+0x48>)
#if defined (STM32F051x8) || defined (STM32F058x8)
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE and MCOSEL[2:0] bits */
  RCC->CFGR &= (uint32_t)0xF8FFB80CU;
#else
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */
  RCC->CFGR &= (uint32_t)0x08FFB80CU;
 8006eb8:	4811      	ldr	r0, [pc, #68]	; (8006f00 <SystemInit+0x4c>)
  RCC->CR |= (uint32_t)0x00000001U;
 8006eba:	681a      	ldr	r2, [r3, #0]
 8006ebc:	430a      	orrs	r2, r1
 8006ebe:	601a      	str	r2, [r3, #0]
  RCC->CFGR &= (uint32_t)0x08FFB80CU;
 8006ec0:	685a      	ldr	r2, [r3, #4]
 8006ec2:	4002      	ands	r2, r0
 8006ec4:	605a      	str	r2, [r3, #4]
#endif /* STM32F051x8 or STM32F058x8 */
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFFU;
 8006ec6:	681a      	ldr	r2, [r3, #0]
 8006ec8:	480e      	ldr	r0, [pc, #56]	; (8006f04 <SystemInit+0x50>)
 8006eca:	4002      	ands	r2, r0
 8006ecc:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFFU;
 8006ece:	681a      	ldr	r2, [r3, #0]
 8006ed0:	480d      	ldr	r0, [pc, #52]	; (8006f08 <SystemInit+0x54>)
 8006ed2:	4002      	ands	r2, r0
 8006ed4:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  RCC->CFGR &= (uint32_t)0xFFC0FFFFU;
 8006ed6:	685a      	ldr	r2, [r3, #4]
 8006ed8:	480c      	ldr	r0, [pc, #48]	; (8006f0c <SystemInit+0x58>)
 8006eda:	4002      	ands	r2, r0

  /* Reset PREDIV[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0U;
 8006edc:	200f      	movs	r0, #15
  RCC->CFGR &= (uint32_t)0xFFC0FFFFU;
 8006ede:	605a      	str	r2, [r3, #4]
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0U;
 8006ee0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8006ee2:	4382      	bics	r2, r0
 8006ee4:	62da      	str	r2, [r3, #44]	; 0x2c

#if defined (STM32F072xB) || defined (STM32F078xx)
  /* Reset USART2SW[1:0], USART1SW[1:0], I2C1SW, CECSW, USBSW and ADCSW bits */
  RCC->CFGR3 &= (uint32_t)0xFFFCFE2CU;
 8006ee6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006ee8:	4809      	ldr	r0, [pc, #36]	; (8006f10 <SystemInit+0x5c>)
 8006eea:	4002      	ands	r2, r0
 8006eec:	631a      	str	r2, [r3, #48]	; 0x30
#else
 #warning "No target selected"
#endif

  /* Reset HSI14 bit */
  RCC->CR2 &= (uint32_t)0xFFFFFFFEU;
 8006eee:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8006ef0:	438a      	bics	r2, r1
 8006ef2:	635a      	str	r2, [r3, #52]	; 0x34

  /* Disable all interrupts */
  RCC->CIR = 0x00000000U;
 8006ef4:	2200      	movs	r2, #0
 8006ef6:	609a      	str	r2, [r3, #8]

}
 8006ef8:	4770      	bx	lr
 8006efa:	46c0      	nop			; (mov r8, r8)
 8006efc:	40021000 	.word	0x40021000
 8006f00:	08ffb80c 	.word	0x08ffb80c
 8006f04:	fef6ffff 	.word	0xfef6ffff
 8006f08:	fffbffff 	.word	0xfffbffff
 8006f0c:	ffc0ffff 	.word	0xffc0ffff
 8006f10:	fffcfe2c 	.word	0xfffcfe2c

08006f14 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8006f14:	b510      	push	{r4, lr}
 8006f16:	0004      	movs	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000U);
 8006f18:	f001 f884 	bl	8008024 <HAL_RCC_GetHCLKFreq>
 8006f1c:	21fa      	movs	r1, #250	; 0xfa
 8006f1e:	0089      	lsls	r1, r1, #2
 8006f20:	f7fe fd48 	bl	80059b4 <__udivsi3>
 8006f24:	f000 fac6 	bl	80074b4 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 8006f28:	2001      	movs	r0, #1
 8006f2a:	2200      	movs	r2, #0
 8006f2c:	0021      	movs	r1, r4
 8006f2e:	4240      	negs	r0, r0
 8006f30:	f000 fa8c 	bl	800744c <HAL_NVIC_SetPriority>

   /* Return function status */
  return HAL_OK;
}
 8006f34:	2000      	movs	r0, #0
 8006f36:	bd10      	pop	{r4, pc}

08006f38 <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8006f38:	2310      	movs	r3, #16
 8006f3a:	4a06      	ldr	r2, [pc, #24]	; (8006f54 <HAL_Init+0x1c>)
{
 8006f3c:	b510      	push	{r4, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8006f3e:	6811      	ldr	r1, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 8006f40:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8006f42:	430b      	orrs	r3, r1
 8006f44:	6013      	str	r3, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 8006f46:	f7ff ffe5 	bl	8006f14 <HAL_InitTick>
  HAL_MspInit();
 8006f4a:	f7fe ff3b 	bl	8005dc4 <HAL_MspInit>
}
 8006f4e:	2000      	movs	r0, #0
 8006f50:	bd10      	pop	{r4, pc}
 8006f52:	46c0      	nop			; (mov r8, r8)
 8006f54:	40022000 	.word	0x40022000

08006f58 <HAL_IncTick>:
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8006f58:	4a02      	ldr	r2, [pc, #8]	; (8006f64 <HAL_IncTick+0xc>)
 8006f5a:	6813      	ldr	r3, [r2, #0]
 8006f5c:	3301      	adds	r3, #1
 8006f5e:	6013      	str	r3, [r2, #0]
}
 8006f60:	4770      	bx	lr
 8006f62:	46c0      	nop			; (mov r8, r8)
 8006f64:	20001bbc 	.word	0x20001bbc

08006f68 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8006f68:	4b01      	ldr	r3, [pc, #4]	; (8006f70 <HAL_GetTick+0x8>)
 8006f6a:	6818      	ldr	r0, [r3, #0]
}
 8006f6c:	4770      	bx	lr
 8006f6e:	46c0      	nop			; (mov r8, r8)
 8006f70:	20001bbc 	.word	0x20001bbc

08006f74 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 8006f74:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8006f76:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = HAL_GetTick();
 8006f78:	f7ff fff6 	bl	8006f68 <HAL_GetTick>
  uint32_t wait = Delay;
 8006f7c:	9c01      	ldr	r4, [sp, #4]
  uint32_t tickstart = HAL_GetTick();
 8006f7e:	0005      	movs	r5, r0
  
  /* Add a period to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
  {
     wait++;
 8006f80:	1c63      	adds	r3, r4, #1
 8006f82:	1e5a      	subs	r2, r3, #1
 8006f84:	4193      	sbcs	r3, r2
 8006f86:	18e4      	adds	r4, r4, r3
  }
  
  while((HAL_GetTick() - tickstart) < wait)
 8006f88:	f7ff ffee 	bl	8006f68 <HAL_GetTick>
 8006f8c:	1b40      	subs	r0, r0, r5
 8006f8e:	42a0      	cmp	r0, r4
 8006f90:	d3fa      	bcc.n	8006f88 <HAL_Delay+0x14>
  {
  }
}
 8006f92:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

08006f94 <ADC_Enable>:
  * @retval HAL status.
  */
static HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
{
  uint32_t tickstart = 0U;
  __IO uint32_t wait_loop_index = 0U;
 8006f94:	2300      	movs	r3, #0
{
 8006f96:	b573      	push	{r0, r1, r4, r5, r6, lr}
  
  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (ADC_IS_ENABLE(hadc) == RESET)
 8006f98:	2103      	movs	r1, #3
  __IO uint32_t wait_loop_index = 0U;
 8006f9a:	9301      	str	r3, [sp, #4]
  if (ADC_IS_ENABLE(hadc) == RESET)
 8006f9c:	6803      	ldr	r3, [r0, #0]
{
 8006f9e:	0004      	movs	r4, r0
  if (ADC_IS_ENABLE(hadc) == RESET)
 8006fa0:	689a      	ldr	r2, [r3, #8]
 8006fa2:	400a      	ands	r2, r1
 8006fa4:	2a01      	cmp	r2, #1
 8006fa6:	d107      	bne.n	8006fb8 <ADC_Enable+0x24>
 8006fa8:	6819      	ldr	r1, [r3, #0]
 8006faa:	4211      	tst	r1, r2
 8006fac:	d001      	beq.n	8006fb2 <ADC_Enable+0x1e>
    }   
    
  }
   
  /* Return HAL status */
  return HAL_OK;
 8006fae:	2000      	movs	r0, #0
}
 8006fb0:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
  if (ADC_IS_ENABLE(hadc) == RESET)
 8006fb2:	68da      	ldr	r2, [r3, #12]
 8006fb4:	0412      	lsls	r2, r2, #16
 8006fb6:	d4fa      	bmi.n	8006fae <ADC_Enable+0x1a>
    if (ADC_ENABLING_CONDITIONS(hadc) == RESET)
 8006fb8:	6899      	ldr	r1, [r3, #8]
 8006fba:	4a19      	ldr	r2, [pc, #100]	; (8007020 <ADC_Enable+0x8c>)
 8006fbc:	4211      	tst	r1, r2
 8006fbe:	d008      	beq.n	8006fd2 <ADC_Enable+0x3e>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8006fc0:	2310      	movs	r3, #16
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8006fc2:	2001      	movs	r0, #1
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8006fc4:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8006fc6:	4313      	orrs	r3, r2
 8006fc8:	6463      	str	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8006fca:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8006fcc:	4303      	orrs	r3, r0
 8006fce:	64a3      	str	r3, [r4, #72]	; 0x48
      return HAL_ERROR;
 8006fd0:	e7ee      	b.n	8006fb0 <ADC_Enable+0x1c>
    __HAL_ADC_ENABLE(hadc);
 8006fd2:	2201      	movs	r2, #1
 8006fd4:	6899      	ldr	r1, [r3, #8]
 8006fd6:	430a      	orrs	r2, r1
 8006fd8:	609a      	str	r2, [r3, #8]
    wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 8006fda:	4b12      	ldr	r3, [pc, #72]	; (8007024 <ADC_Enable+0x90>)
 8006fdc:	4912      	ldr	r1, [pc, #72]	; (8007028 <ADC_Enable+0x94>)
 8006fde:	6818      	ldr	r0, [r3, #0]
 8006fe0:	f7fe fce8 	bl	80059b4 <__udivsi3>
 8006fe4:	9001      	str	r0, [sp, #4]
    while(wait_loop_index != 0U)
 8006fe6:	9b01      	ldr	r3, [sp, #4]
 8006fe8:	2b00      	cmp	r3, #0
 8006fea:	d115      	bne.n	8007018 <ADC_Enable+0x84>
    tickstart = HAL_GetTick();
 8006fec:	f7ff ffbc 	bl	8006f68 <HAL_GetTick>
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
 8006ff0:	2501      	movs	r5, #1
    tickstart = HAL_GetTick();
 8006ff2:	0006      	movs	r6, r0
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
 8006ff4:	6823      	ldr	r3, [r4, #0]
 8006ff6:	681b      	ldr	r3, [r3, #0]
 8006ff8:	422b      	tst	r3, r5
 8006ffa:	d1d8      	bne.n	8006fae <ADC_Enable+0x1a>
      if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8006ffc:	f7ff ffb4 	bl	8006f68 <HAL_GetTick>
 8007000:	1b80      	subs	r0, r0, r6
 8007002:	2802      	cmp	r0, #2
 8007004:	d9f6      	bls.n	8006ff4 <ADC_Enable+0x60>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007006:	2310      	movs	r3, #16
 8007008:	6c62      	ldr	r2, [r4, #68]	; 0x44
        return HAL_ERROR;
 800700a:	2001      	movs	r0, #1
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800700c:	4313      	orrs	r3, r2
 800700e:	6463      	str	r3, [r4, #68]	; 0x44
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007010:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8007012:	432b      	orrs	r3, r5
 8007014:	64a3      	str	r3, [r4, #72]	; 0x48
        return HAL_ERROR;
 8007016:	e7cb      	b.n	8006fb0 <ADC_Enable+0x1c>
      wait_loop_index--;
 8007018:	9b01      	ldr	r3, [sp, #4]
 800701a:	3b01      	subs	r3, #1
 800701c:	9301      	str	r3, [sp, #4]
 800701e:	e7e2      	b.n	8006fe6 <ADC_Enable+0x52>
 8007020:	80000017 	.word	0x80000017
 8007024:	20000054 	.word	0x20000054
 8007028:	000f4240 	.word	0x000f4240

0800702c <HAL_ADC_Init>:
{
 800702c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800702e:	0004      	movs	r4, r0
    return HAL_ERROR;
 8007030:	2001      	movs	r0, #1
  if(hadc == NULL)
 8007032:	2c00      	cmp	r4, #0
 8007034:	d07d      	beq.n	8007132 <HAL_ADC_Init+0x106>
  if (hadc->State == HAL_ADC_STATE_RESET)
 8007036:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007038:	2b00      	cmp	r3, #0
 800703a:	d106      	bne.n	800704a <HAL_ADC_Init+0x1e>
    hadc->Lock = HAL_UNLOCKED;
 800703c:	0022      	movs	r2, r4
 800703e:	3240      	adds	r2, #64	; 0x40
    ADC_CLEAR_ERRORCODE(hadc);
 8007040:	64a3      	str	r3, [r4, #72]	; 0x48
    HAL_ADC_MspInit(hadc);
 8007042:	0020      	movs	r0, r4
    hadc->Lock = HAL_UNLOCKED;
 8007044:	7013      	strb	r3, [r2, #0]
    HAL_ADC_MspInit(hadc);
 8007046:	f7fe fef9 	bl	8005e3c <HAL_ADC_MspInit>
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
 800704a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800704c:	06db      	lsls	r3, r3, #27
 800704e:	d500      	bpl.n	8007052 <HAL_ADC_Init+0x26>
 8007050:	e084      	b.n	800715c <HAL_ADC_Init+0x130>
      (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)          )
 8007052:	2204      	movs	r2, #4
 8007054:	6823      	ldr	r3, [r4, #0]
 8007056:	6898      	ldr	r0, [r3, #8]
 8007058:	4010      	ands	r0, r2
      (tmp_hal_status == HAL_OK)                                &&
 800705a:	d000      	beq.n	800705e <HAL_ADC_Init+0x32>
 800705c:	e07e      	b.n	800715c <HAL_ADC_Init+0x130>
    ADC_STATE_CLR_SET(hadc->State,
 800705e:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8007060:	4941      	ldr	r1, [pc, #260]	; (8007168 <HAL_ADC_Init+0x13c>)
 8007062:	4011      	ands	r1, r2
 8007064:	2202      	movs	r2, #2
 8007066:	430a      	orrs	r2, r1
    if (ADC_IS_ENABLE(hadc) == RESET)
 8007068:	2103      	movs	r1, #3
    ADC_STATE_CLR_SET(hadc->State,
 800706a:	6462      	str	r2, [r4, #68]	; 0x44
    if (ADC_IS_ENABLE(hadc) == RESET)
 800706c:	689a      	ldr	r2, [r3, #8]
 800706e:	400a      	ands	r2, r1
 8007070:	2a01      	cmp	r2, #1
 8007072:	d105      	bne.n	8007080 <HAL_ADC_Init+0x54>
 8007074:	6819      	ldr	r1, [r3, #0]
 8007076:	4211      	tst	r1, r2
 8007078:	d10e      	bne.n	8007098 <HAL_ADC_Init+0x6c>
 800707a:	68da      	ldr	r2, [r3, #12]
 800707c:	0412      	lsls	r2, r2, #16
 800707e:	d40b      	bmi.n	8007098 <HAL_ADC_Init+0x6c>
      MODIFY_REG(hadc->Instance->CFGR1,
 8007080:	2118      	movs	r1, #24
 8007082:	68da      	ldr	r2, [r3, #12]
 8007084:	438a      	bics	r2, r1
 8007086:	68a1      	ldr	r1, [r4, #8]
 8007088:	430a      	orrs	r2, r1
 800708a:	60da      	str	r2, [r3, #12]
      MODIFY_REG(hadc->Instance->CFGR2    ,
 800708c:	6919      	ldr	r1, [r3, #16]
 800708e:	6862      	ldr	r2, [r4, #4]
 8007090:	0089      	lsls	r1, r1, #2
 8007092:	0889      	lsrs	r1, r1, #2
 8007094:	4311      	orrs	r1, r2
 8007096:	6119      	str	r1, [r3, #16]
    hadc->Instance->CFGR1 &= ~( ADC_CFGR1_DISCEN  |
 8007098:	68da      	ldr	r2, [r3, #12]
 800709a:	4934      	ldr	r1, [pc, #208]	; (800716c <HAL_ADC_Init+0x140>)
                 ADC_CFGR1_CONTINUOUS(hadc->Init.ContinuousConvMode)    |
 800709c:	6a25      	ldr	r5, [r4, #32]
    hadc->Instance->CFGR1 &= ~( ADC_CFGR1_DISCEN  |
 800709e:	400a      	ands	r2, r1
 80070a0:	60da      	str	r2, [r3, #12]
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
 80070a2:	69a2      	ldr	r2, [r4, #24]
                 ADC_CFGR1_CONTINUOUS(hadc->Init.ContinuousConvMode)    |
 80070a4:	036f      	lsls	r7, r5, #13
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
 80070a6:	0391      	lsls	r1, r2, #14
                 ADC_CFGR1_AUTOOFF(hadc->Init.LowPowerAutoPowerOff)     |
 80070a8:	69e2      	ldr	r2, [r4, #28]
 80070aa:	03d2      	lsls	r2, r2, #15
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
 80070ac:	4311      	orrs	r1, r2
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                  |
 80070ae:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80070b0:	3a01      	subs	r2, #1
 80070b2:	1e56      	subs	r6, r2, #1
 80070b4:	41b2      	sbcs	r2, r6
 80070b6:	0316      	lsls	r6, r2, #12
 80070b8:	68e2      	ldr	r2, [r4, #12]
 80070ba:	4311      	orrs	r1, r2
                 ADC_SCANDIR(hadc->Init.ScanConvMode)                   |
 80070bc:	6922      	ldr	r2, [r4, #16]
 80070be:	430f      	orrs	r7, r1
 80070c0:	2a02      	cmp	r2, #2
 80070c2:	d100      	bne.n	80070c6 <HAL_ADC_Init+0x9a>
 80070c4:	2004      	movs	r0, #4
                 ADC_CFGR1_DMACONTREQ(hadc->Init.DMAContinuousRequests)  );
 80070c6:	6b22      	ldr	r2, [r4, #48]	; 0x30
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 80070c8:	6a61      	ldr	r1, [r4, #36]	; 0x24
                 ADC_CFGR1_DMACONTREQ(hadc->Init.DMAContinuousRequests)  );
 80070ca:	0052      	lsls	r2, r2, #1
                 ADC_SCANDIR(hadc->Init.ScanConvMode)                   |
 80070cc:	433a      	orrs	r2, r7
 80070ce:	4332      	orrs	r2, r6
 80070d0:	4302      	orrs	r2, r0
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 80070d2:	2901      	cmp	r1, #1
 80070d4:	d104      	bne.n	80070e0 <HAL_ADC_Init+0xb4>
      if (hadc->Init.ContinuousConvMode == DISABLE)
 80070d6:	2d00      	cmp	r5, #0
 80070d8:	d12c      	bne.n	8007134 <HAL_ADC_Init+0x108>
        tmpCFGR1 |= ADC_CFGR1_DISCEN;
 80070da:	2180      	movs	r1, #128	; 0x80
 80070dc:	0249      	lsls	r1, r1, #9
 80070de:	430a      	orrs	r2, r1
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80070e0:	20c2      	movs	r0, #194	; 0xc2
 80070e2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80070e4:	30ff      	adds	r0, #255	; 0xff
 80070e6:	4281      	cmp	r1, r0
 80070e8:	d002      	beq.n	80070f0 <HAL_ADC_Init+0xc4>
      tmpCFGR1 |= ( hadc->Init.ExternalTrigConv    |
 80070ea:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80070ec:	4301      	orrs	r1, r0
 80070ee:	430a      	orrs	r2, r1
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80070f0:	2080      	movs	r0, #128	; 0x80
    hadc->Instance->CFGR1 |= tmpCFGR1;
 80070f2:	68d9      	ldr	r1, [r3, #12]
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80070f4:	0540      	lsls	r0, r0, #21
    hadc->Instance->CFGR1 |= tmpCFGR1;
 80070f6:	4311      	orrs	r1, r2
 80070f8:	60d9      	str	r1, [r3, #12]
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80070fa:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80070fc:	4281      	cmp	r1, r0
 80070fe:	d002      	beq.n	8007106 <HAL_ADC_Init+0xda>
 8007100:	1e48      	subs	r0, r1, #1
 8007102:	2806      	cmp	r0, #6
 8007104:	d807      	bhi.n	8007116 <HAL_ADC_Init+0xea>
      hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 8007106:	2507      	movs	r5, #7
 8007108:	6958      	ldr	r0, [r3, #20]
      hadc->Instance->SMPR |= ADC_SMPR_SET(hadc->Init.SamplingTimeCommon);
 800710a:	4029      	ands	r1, r5
      hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 800710c:	43a8      	bics	r0, r5
 800710e:	6158      	str	r0, [r3, #20]
      hadc->Instance->SMPR |= ADC_SMPR_SET(hadc->Init.SamplingTimeCommon);
 8007110:	6958      	ldr	r0, [r3, #20]
 8007112:	4301      	orrs	r1, r0
 8007114:	6159      	str	r1, [r3, #20]
    if ((hadc->Instance->CFGR1 & ~(ADC_CFGR1_AWDCH | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL | ADC_CFGR1_RES))
 8007116:	68db      	ldr	r3, [r3, #12]
 8007118:	4915      	ldr	r1, [pc, #84]	; (8007170 <HAL_ADC_Init+0x144>)
 800711a:	400b      	ands	r3, r1
 800711c:	4293      	cmp	r3, r2
 800711e:	d111      	bne.n	8007144 <HAL_ADC_Init+0x118>
      ADC_CLEAR_ERRORCODE(hadc);
 8007120:	2000      	movs	r0, #0
      ADC_STATE_CLR_SET(hadc->State,
 8007122:	2203      	movs	r2, #3
      ADC_CLEAR_ERRORCODE(hadc);
 8007124:	64a0      	str	r0, [r4, #72]	; 0x48
      ADC_STATE_CLR_SET(hadc->State,
 8007126:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007128:	4393      	bics	r3, r2
 800712a:	001a      	movs	r2, r3
 800712c:	2301      	movs	r3, #1
 800712e:	4313      	orrs	r3, r2
 8007130:	6463      	str	r3, [r4, #68]	; 0x44
}
 8007132:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8007134:	2020      	movs	r0, #32
 8007136:	6c65      	ldr	r5, [r4, #68]	; 0x44
 8007138:	4328      	orrs	r0, r5
 800713a:	6460      	str	r0, [r4, #68]	; 0x44
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800713c:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 800713e:	4301      	orrs	r1, r0
 8007140:	64a1      	str	r1, [r4, #72]	; 0x48
 8007142:	e7cd      	b.n	80070e0 <HAL_ADC_Init+0xb4>
      ADC_STATE_CLR_SET(hadc->State,
 8007144:	2212      	movs	r2, #18
 8007146:	6c63      	ldr	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007148:	2001      	movs	r0, #1
      ADC_STATE_CLR_SET(hadc->State,
 800714a:	4393      	bics	r3, r2
 800714c:	001a      	movs	r2, r3
 800714e:	2310      	movs	r3, #16
 8007150:	4313      	orrs	r3, r2
 8007152:	6463      	str	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007154:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8007156:	4303      	orrs	r3, r0
 8007158:	64a3      	str	r3, [r4, #72]	; 0x48
 800715a:	e7ea      	b.n	8007132 <HAL_ADC_Init+0x106>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800715c:	2310      	movs	r3, #16
 800715e:	6c62      	ldr	r2, [r4, #68]	; 0x44
    tmp_hal_status = HAL_ERROR;
 8007160:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007162:	4313      	orrs	r3, r2
 8007164:	6463      	str	r3, [r4, #68]	; 0x44
 8007166:	e7e4      	b.n	8007132 <HAL_ADC_Init+0x106>
 8007168:	fffffefd 	.word	0xfffffefd
 800716c:	fffe0219 	.word	0xfffe0219
 8007170:	833fffe7 	.word	0x833fffe7

08007174 <HAL_ADC_Start_DMA>:
{
 8007174:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8007176:	6803      	ldr	r3, [r0, #0]
{
 8007178:	0004      	movs	r4, r0
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 800717a:	689b      	ldr	r3, [r3, #8]
{
 800717c:	000f      	movs	r7, r1
 800717e:	9201      	str	r2, [sp, #4]
    tmp_hal_status = HAL_BUSY;
 8007180:	2002      	movs	r0, #2
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8007182:	075b      	lsls	r3, r3, #29
 8007184:	d430      	bmi.n	80071e8 <HAL_ADC_Start_DMA+0x74>
    __HAL_LOCK(hadc);
 8007186:	0026      	movs	r6, r4
 8007188:	3640      	adds	r6, #64	; 0x40
 800718a:	7833      	ldrb	r3, [r6, #0]
 800718c:	2b01      	cmp	r3, #1
 800718e:	d02b      	beq.n	80071e8 <HAL_ADC_Start_DMA+0x74>
 8007190:	2301      	movs	r3, #1
 8007192:	7033      	strb	r3, [r6, #0]
    if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
 8007194:	69e3      	ldr	r3, [r4, #28]
 8007196:	2b01      	cmp	r3, #1
 8007198:	d127      	bne.n	80071ea <HAL_ADC_Start_DMA+0x76>
      ADC_STATE_CLR_SET(hadc->State,
 800719a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800719c:	4a16      	ldr	r2, [pc, #88]	; (80071f8 <HAL_ADC_Start_DMA+0x84>)
      ADC_CLEAR_ERRORCODE(hadc);
 800719e:	2500      	movs	r5, #0
      ADC_STATE_CLR_SET(hadc->State,
 80071a0:	401a      	ands	r2, r3
 80071a2:	2380      	movs	r3, #128	; 0x80
 80071a4:	005b      	lsls	r3, r3, #1
 80071a6:	4313      	orrs	r3, r2
 80071a8:	6463      	str	r3, [r4, #68]	; 0x44
      hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 80071aa:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80071ac:	4b13      	ldr	r3, [pc, #76]	; (80071fc <HAL_ADC_Start_DMA+0x88>)
      ADC_CLEAR_ERRORCODE(hadc);
 80071ae:	64a5      	str	r5, [r4, #72]	; 0x48
      __HAL_UNLOCK(hadc);
 80071b0:	7035      	strb	r5, [r6, #0]
      hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 80071b2:	6283      	str	r3, [r0, #40]	; 0x28
      hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 80071b4:	4b12      	ldr	r3, [pc, #72]	; (8007200 <HAL_ADC_Start_DMA+0x8c>)
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 80071b6:	6821      	ldr	r1, [r4, #0]
      hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 80071b8:	62c3      	str	r3, [r0, #44]	; 0x2c
      hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 80071ba:	4b12      	ldr	r3, [pc, #72]	; (8007204 <HAL_ADC_Start_DMA+0x90>)
 80071bc:	6303      	str	r3, [r0, #48]	; 0x30
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 80071be:	231c      	movs	r3, #28
 80071c0:	600b      	str	r3, [r1, #0]
      __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 80071c2:	684a      	ldr	r2, [r1, #4]
 80071c4:	3b0c      	subs	r3, #12
 80071c6:	4313      	orrs	r3, r2
 80071c8:	604b      	str	r3, [r1, #4]
      hadc->Instance->CFGR1 |= ADC_CFGR1_DMAEN;
 80071ca:	2301      	movs	r3, #1
 80071cc:	68ca      	ldr	r2, [r1, #12]
 80071ce:	4313      	orrs	r3, r2
 80071d0:	60cb      	str	r3, [r1, #12]
      HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 80071d2:	003a      	movs	r2, r7
 80071d4:	3140      	adds	r1, #64	; 0x40
 80071d6:	9b01      	ldr	r3, [sp, #4]
 80071d8:	f000 fac0 	bl	800775c <HAL_DMA_Start_IT>
      hadc->Instance->CR |= ADC_CR_ADSTART;
 80071dc:	2304      	movs	r3, #4
 80071de:	0028      	movs	r0, r5
 80071e0:	6822      	ldr	r2, [r4, #0]
 80071e2:	6891      	ldr	r1, [r2, #8]
 80071e4:	430b      	orrs	r3, r1
 80071e6:	6093      	str	r3, [r2, #8]
}
 80071e8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      tmp_hal_status = ADC_Enable(hadc);
 80071ea:	0020      	movs	r0, r4
 80071ec:	f7ff fed2 	bl	8006f94 <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 80071f0:	2800      	cmp	r0, #0
 80071f2:	d0d2      	beq.n	800719a <HAL_ADC_Start_DMA+0x26>
 80071f4:	e7f8      	b.n	80071e8 <HAL_ADC_Start_DMA+0x74>
 80071f6:	46c0      	nop			; (mov r8, r8)
 80071f8:	fffff0fe 	.word	0xfffff0fe
 80071fc:	0800720d 	.word	0x0800720d
 8007200:	0800727f 	.word	0x0800727f
 8007204:	0800728b 	.word	0x0800728b

08007208 <HAL_ADC_ConvCpltCallback>:
 8007208:	4770      	bx	lr
	...

0800720c <ADC_DMAConvCplt>:
{
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Update state machine on conversion status if not in error state */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
 800720c:	2250      	movs	r2, #80	; 0x50
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800720e:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
 8007210:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
 8007212:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8007214:	4211      	tst	r1, r2
 8007216:	d12a      	bne.n	800726e <ADC_DMAConvCplt+0x62>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
 8007218:	6c59      	ldr	r1, [r3, #68]	; 0x44
 800721a:	32b1      	adds	r2, #177	; 0xb1
 800721c:	32ff      	adds	r2, #255	; 0xff
 800721e:	430a      	orrs	r2, r1
    
    /* Determine whether any further conversion upcoming on group regular     */
    /* by external trigger, continuous mode or scan sequence on going.        */
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 8007220:	21c0      	movs	r1, #192	; 0xc0
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
 8007222:	645a      	str	r2, [r3, #68]	; 0x44
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 8007224:	681a      	ldr	r2, [r3, #0]
 8007226:	0109      	lsls	r1, r1, #4
 8007228:	68d0      	ldr	r0, [r2, #12]
 800722a:	4208      	tst	r0, r1
 800722c:	d112      	bne.n	8007254 <ADC_DMAConvCplt+0x48>
 800722e:	6a19      	ldr	r1, [r3, #32]
 8007230:	2900      	cmp	r1, #0
 8007232:	d10f      	bne.n	8007254 <ADC_DMAConvCplt+0x48>
       (hadc->Init.ContinuousConvMode == DISABLE)   )
    {
      /* If End of Sequence is reached, disable interrupts */
      if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )
 8007234:	6811      	ldr	r1, [r2, #0]
 8007236:	0709      	lsls	r1, r1, #28
 8007238:	d50c      	bpl.n	8007254 <ADC_DMAConvCplt+0x48>
      {
        /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit           */
        /* ADSTART==0 (no conversion on going)                                */
        if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 800723a:	6891      	ldr	r1, [r2, #8]
 800723c:	0749      	lsls	r1, r1, #29
 800723e:	d40d      	bmi.n	800725c <ADC_DMAConvCplt+0x50>
        {
          /* Disable ADC end of single conversion interrupt on group regular */
          /* Note: Overrun interrupt was enabled with EOC interrupt in        */
          /* HAL_Start_IT(), but is not disabled here because can be used     */
          /* by overrun IRQ process below.                                    */
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 8007240:	200c      	movs	r0, #12
 8007242:	6851      	ldr	r1, [r2, #4]
 8007244:	4381      	bics	r1, r0
 8007246:	6051      	str	r1, [r2, #4]
          
          /* Set ADC state */
          ADC_STATE_CLR_SET(hadc->State,
 8007248:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800724a:	490b      	ldr	r1, [pc, #44]	; (8007278 <ADC_DMAConvCplt+0x6c>)
 800724c:	4011      	ands	r1, r2
 800724e:	2201      	movs	r2, #1
 8007250:	430a      	orrs	r2, r1
 8007252:	645a      	str	r2, [r3, #68]	; 0x44
        }
      }
    }

    /* Conversion complete callback */
    HAL_ADC_ConvCpltCallback(hadc); 
 8007254:	0018      	movs	r0, r3
 8007256:	f7ff ffd7 	bl	8007208 <HAL_ADC_ConvCpltCallback>
  {
    /* Call DMA error callback */
    hadc->DMA_Handle->XferErrorCallback(hdma);
  }

}
 800725a:	bd10      	pop	{r4, pc}
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800725c:	2220      	movs	r2, #32
 800725e:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8007260:	430a      	orrs	r2, r1
 8007262:	645a      	str	r2, [r3, #68]	; 0x44
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007264:	2201      	movs	r2, #1
 8007266:	6c99      	ldr	r1, [r3, #72]	; 0x48
 8007268:	430a      	orrs	r2, r1
 800726a:	649a      	str	r2, [r3, #72]	; 0x48
 800726c:	e7f2      	b.n	8007254 <ADC_DMAConvCplt+0x48>
    hadc->DMA_Handle->XferErrorCallback(hdma);
 800726e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007270:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007272:	4798      	blx	r3
}
 8007274:	e7f1      	b.n	800725a <ADC_DMAConvCplt+0x4e>
 8007276:	46c0      	nop			; (mov r8, r8)
 8007278:	fffffefe 	.word	0xfffffefe

0800727c <HAL_ADC_ConvHalfCpltCallback>:
 800727c:	4770      	bx	lr

0800727e <ADC_DMAHalfConvCplt>:
  * @brief  DMA half transfer complete callback. 
  * @param  hdma: pointer to DMA handle.
  * @retval None
  */
static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
{
 800727e:	b510      	push	{r4, lr}
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Half conversion callback */
  HAL_ADC_ConvHalfCpltCallback(hadc); 
 8007280:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8007282:	f7ff fffb 	bl	800727c <HAL_ADC_ConvHalfCpltCallback>
}
 8007286:	bd10      	pop	{r4, pc}

08007288 <HAL_ADC_ErrorCallback>:
 8007288:	4770      	bx	lr

0800728a <ADC_DMAError>:
{
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Set ADC state */
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 800728a:	2340      	movs	r3, #64	; 0x40
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 800728c:	6a40      	ldr	r0, [r0, #36]	; 0x24
{
 800728e:	b510      	push	{r4, lr}
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 8007290:	6c42      	ldr	r2, [r0, #68]	; 0x44
 8007292:	4313      	orrs	r3, r2
 8007294:	6443      	str	r3, [r0, #68]	; 0x44
  
  /* Set ADC error code to DMA error */
  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
 8007296:	2304      	movs	r3, #4
 8007298:	6c82      	ldr	r2, [r0, #72]	; 0x48
 800729a:	4313      	orrs	r3, r2
 800729c:	6483      	str	r3, [r0, #72]	; 0x48
  
  /* Error callback */
  HAL_ADC_ErrorCallback(hadc); 
 800729e:	f7ff fff3 	bl	8007288 <HAL_ADC_ErrorCallback>
}
 80072a2:	bd10      	pop	{r4, pc}

080072a4 <HAL_ADC_ConfigChannel>:
{
 80072a4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint32_t wait_loop_index = 0U;
 80072a6:	2200      	movs	r2, #0
  __HAL_LOCK(hadc);
 80072a8:	0004      	movs	r4, r0
  __IO uint32_t wait_loop_index = 0U;
 80072aa:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 80072ac:	3440      	adds	r4, #64	; 0x40
 80072ae:	7822      	ldrb	r2, [r4, #0]
{
 80072b0:	0003      	movs	r3, r0
  __HAL_LOCK(hadc);
 80072b2:	2002      	movs	r0, #2
 80072b4:	2a01      	cmp	r2, #1
 80072b6:	d02b      	beq.n	8007310 <HAL_ADC_ConfigChannel+0x6c>
 80072b8:	2201      	movs	r2, #1
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 80072ba:	681d      	ldr	r5, [r3, #0]
  if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80072bc:	6b9e      	ldr	r6, [r3, #56]	; 0x38
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 80072be:	68a8      	ldr	r0, [r5, #8]
  __HAL_LOCK(hadc);
 80072c0:	7022      	strb	r2, [r4, #0]
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 80072c2:	0740      	lsls	r0, r0, #29
 80072c4:	d45a      	bmi.n	800737c <HAL_ADC_ConfigChannel+0xd8>
 80072c6:	680b      	ldr	r3, [r1, #0]
    if (sConfig->Rank != ADC_RANK_NONE)
 80072c8:	482f      	ldr	r0, [pc, #188]	; (8007388 <HAL_ADC_ConfigChannel+0xe4>)
 80072ca:	001f      	movs	r7, r3
 80072cc:	4684      	mov	ip, r0
 80072ce:	6848      	ldr	r0, [r1, #4]
 80072d0:	409a      	lsls	r2, r3
 80072d2:	3f10      	subs	r7, #16
 80072d4:	4560      	cmp	r0, ip
 80072d6:	d03b      	beq.n	8007350 <HAL_ADC_ConfigChannel+0xac>
      hadc->Instance->CHSELR |= ADC_CHSELR_CHANNEL(sConfig->Channel);
 80072d8:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 80072da:	4310      	orrs	r0, r2
      if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80072dc:	2280      	movs	r2, #128	; 0x80
      hadc->Instance->CHSELR |= ADC_CHSELR_CHANNEL(sConfig->Channel);
 80072de:	62a8      	str	r0, [r5, #40]	; 0x28
      if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80072e0:	0552      	lsls	r2, r2, #21
 80072e2:	4296      	cmp	r6, r2
 80072e4:	d00f      	beq.n	8007306 <HAL_ADC_ConfigChannel+0x62>
 80072e6:	3e01      	subs	r6, #1
 80072e8:	2e06      	cmp	r6, #6
 80072ea:	d90c      	bls.n	8007306 <HAL_ADC_ConfigChannel+0x62>
        if (sConfig->SamplingTime != ADC_GET_SAMPLINGTIME(hadc))
 80072ec:	688a      	ldr	r2, [r1, #8]
 80072ee:	2107      	movs	r1, #7
 80072f0:	6968      	ldr	r0, [r5, #20]
 80072f2:	4008      	ands	r0, r1
 80072f4:	4282      	cmp	r2, r0
 80072f6:	d006      	beq.n	8007306 <HAL_ADC_ConfigChannel+0x62>
          hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 80072f8:	6968      	ldr	r0, [r5, #20]
          hadc->Instance->SMPR |= ADC_SMPR_SET(sConfig->SamplingTime);
 80072fa:	400a      	ands	r2, r1
          hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 80072fc:	4388      	bics	r0, r1
 80072fe:	6168      	str	r0, [r5, #20]
          hadc->Instance->SMPR |= ADC_SMPR_SET(sConfig->SamplingTime);
 8007300:	6968      	ldr	r0, [r5, #20]
 8007302:	4302      	orrs	r2, r0
 8007304:	616a      	str	r2, [r5, #20]
      if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8007306:	2f02      	cmp	r7, #2
 8007308:	d903      	bls.n	8007312 <HAL_ADC_ConfigChannel+0x6e>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800730a:	2000      	movs	r0, #0
  __HAL_UNLOCK(hadc);
 800730c:	2300      	movs	r3, #0
 800730e:	7023      	strb	r3, [r4, #0]
}
 8007310:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        ADC->CCR |= ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 8007312:	4a1e      	ldr	r2, [pc, #120]	; (800738c <HAL_ADC_ConfigChannel+0xe8>)
 8007314:	2080      	movs	r0, #128	; 0x80
 8007316:	6811      	ldr	r1, [r2, #0]
 8007318:	2b10      	cmp	r3, #16
 800731a:	d015      	beq.n	8007348 <HAL_ADC_ConfigChannel+0xa4>
 800731c:	2b11      	cmp	r3, #17
 800731e:	d115      	bne.n	800734c <HAL_ADC_ConfigChannel+0xa8>
 8007320:	03c0      	lsls	r0, r0, #15
 8007322:	4301      	orrs	r1, r0
 8007324:	6011      	str	r1, [r2, #0]
        if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 8007326:	2b10      	cmp	r3, #16
 8007328:	d1ef      	bne.n	800730a <HAL_ADC_ConfigChannel+0x66>
          wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 800732a:	4b19      	ldr	r3, [pc, #100]	; (8007390 <HAL_ADC_ConfigChannel+0xec>)
 800732c:	4919      	ldr	r1, [pc, #100]	; (8007394 <HAL_ADC_ConfigChannel+0xf0>)
 800732e:	6818      	ldr	r0, [r3, #0]
 8007330:	f7fe fb40 	bl	80059b4 <__udivsi3>
 8007334:	230a      	movs	r3, #10
 8007336:	4358      	muls	r0, r3
 8007338:	9001      	str	r0, [sp, #4]
          while(wait_loop_index != 0U)
 800733a:	9b01      	ldr	r3, [sp, #4]
 800733c:	2b00      	cmp	r3, #0
 800733e:	d0e4      	beq.n	800730a <HAL_ADC_ConfigChannel+0x66>
            wait_loop_index--;
 8007340:	9b01      	ldr	r3, [sp, #4]
 8007342:	3b01      	subs	r3, #1
 8007344:	9301      	str	r3, [sp, #4]
 8007346:	e7f8      	b.n	800733a <HAL_ADC_ConfigChannel+0x96>
        ADC->CCR |= ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 8007348:	0400      	lsls	r0, r0, #16
 800734a:	e7ea      	b.n	8007322 <HAL_ADC_ConfigChannel+0x7e>
 800734c:	0440      	lsls	r0, r0, #17
 800734e:	e7e8      	b.n	8007322 <HAL_ADC_ConfigChannel+0x7e>
      hadc->Instance->CHSELR &= ~ADC_CHSELR_CHANNEL(sConfig->Channel);
 8007350:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8007352:	4391      	bics	r1, r2
 8007354:	62a9      	str	r1, [r5, #40]	; 0x28
      if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8007356:	2f02      	cmp	r7, #2
 8007358:	d8d7      	bhi.n	800730a <HAL_ADC_ConfigChannel+0x66>
        ADC->CCR &= ~ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 800735a:	4a0c      	ldr	r2, [pc, #48]	; (800738c <HAL_ADC_ConfigChannel+0xe8>)
 800735c:	6811      	ldr	r1, [r2, #0]
 800735e:	2b10      	cmp	r3, #16
 8007360:	d00a      	beq.n	8007378 <HAL_ADC_ConfigChannel+0xd4>
 8007362:	3b11      	subs	r3, #17
 8007364:	1e58      	subs	r0, r3, #1
 8007366:	4183      	sbcs	r3, r0
 8007368:	480b      	ldr	r0, [pc, #44]	; (8007398 <HAL_ADC_ConfigChannel+0xf4>)
 800736a:	425b      	negs	r3, r3
 800736c:	4003      	ands	r3, r0
 800736e:	480b      	ldr	r0, [pc, #44]	; (800739c <HAL_ADC_ConfigChannel+0xf8>)
 8007370:	181b      	adds	r3, r3, r0
 8007372:	400b      	ands	r3, r1
 8007374:	6013      	str	r3, [r2, #0]
 8007376:	e7c8      	b.n	800730a <HAL_ADC_ConfigChannel+0x66>
 8007378:	4b09      	ldr	r3, [pc, #36]	; (80073a0 <HAL_ADC_ConfigChannel+0xfc>)
 800737a:	e7fa      	b.n	8007372 <HAL_ADC_ConfigChannel+0xce>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800737c:	2120      	movs	r1, #32
 800737e:	6c58      	ldr	r0, [r3, #68]	; 0x44
 8007380:	4301      	orrs	r1, r0
 8007382:	6459      	str	r1, [r3, #68]	; 0x44
    tmp_hal_status = HAL_ERROR;
 8007384:	0010      	movs	r0, r2
 8007386:	e7c1      	b.n	800730c <HAL_ADC_ConfigChannel+0x68>
 8007388:	00001001 	.word	0x00001001
 800738c:	40012708 	.word	0x40012708
 8007390:	20000054 	.word	0x20000054
 8007394:	000f4240 	.word	0x000f4240
 8007398:	ff400000 	.word	0xff400000
 800739c:	ffbfffff 	.word	0xffbfffff
 80073a0:	ff7fffff 	.word	0xff7fffff

080073a4 <HAL_ADCEx_Calibration_Start>:
  *         HAL_ADC_GetValue() (value on 7 bits: from DR[6;0]).
  * @param  hadc: ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef* hadc)
{
 80073a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Process locked */
  __HAL_LOCK(hadc);
 80073a6:	0006      	movs	r6, r0
 80073a8:	3640      	adds	r6, #64	; 0x40
 80073aa:	7833      	ldrb	r3, [r6, #0]
{
 80073ac:	0004      	movs	r4, r0
  __HAL_LOCK(hadc);
 80073ae:	2002      	movs	r0, #2
 80073b0:	2b01      	cmp	r3, #1
 80073b2:	d042      	beq.n	800743a <HAL_ADCEx_Calibration_Start+0x96>
 80073b4:	2301      	movs	r3, #1
  
  /* Calibration prerequisite: ADC must be disabled. */
  if (ADC_IS_ENABLE(hadc) == RESET)
 80073b6:	2103      	movs	r1, #3
  __HAL_LOCK(hadc);
 80073b8:	7033      	strb	r3, [r6, #0]
  if (ADC_IS_ENABLE(hadc) == RESET)
 80073ba:	6823      	ldr	r3, [r4, #0]
 80073bc:	689a      	ldr	r2, [r3, #8]
 80073be:	400a      	ands	r2, r1
 80073c0:	2a01      	cmp	r2, #1
 80073c2:	d105      	bne.n	80073d0 <HAL_ADCEx_Calibration_Start+0x2c>
 80073c4:	6819      	ldr	r1, [r3, #0]
 80073c6:	4211      	tst	r1, r2
 80073c8:	d138      	bne.n	800743c <HAL_ADCEx_Calibration_Start+0x98>
 80073ca:	68da      	ldr	r2, [r3, #12]
 80073cc:	0412      	lsls	r2, r2, #16
 80073ce:	d435      	bmi.n	800743c <HAL_ADCEx_Calibration_Start+0x98>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State, 
 80073d0:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80073d2:	491d      	ldr	r1, [pc, #116]	; (8007448 <HAL_ADCEx_Calibration_Start+0xa4>)
 80073d4:	4011      	ands	r1, r2
 80073d6:	2202      	movs	r2, #2
 80073d8:	430a      	orrs	r2, r1
    /*       available in data register and also transfered by DMA.           */
    /*       To not insert ADC calibration factor among ADC conversion data   */
    /*       in array variable, DMA transfer must be disabled during          */
    /*       calibration.                                                     */
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 80073da:	2103      	movs	r1, #3
    ADC_STATE_CLR_SET(hadc->State, 
 80073dc:	6462      	str	r2, [r4, #68]	; 0x44
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 80073de:	68dd      	ldr	r5, [r3, #12]
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 80073e0:	68da      	ldr	r2, [r3, #12]
 80073e2:	438a      	bics	r2, r1
 80073e4:	60da      	str	r2, [r3, #12]

    /* Start ADC calibration */
    hadc->Instance->CR |= ADC_CR_ADCAL;
 80073e6:	2280      	movs	r2, #128	; 0x80
 80073e8:	6899      	ldr	r1, [r3, #8]
 80073ea:	0612      	lsls	r2, r2, #24
 80073ec:	430a      	orrs	r2, r1
 80073ee:	609a      	str	r2, [r3, #8]

    tickstart = HAL_GetTick();  
 80073f0:	f7ff fdba 	bl	8006f68 <HAL_GetTick>
 80073f4:	0007      	movs	r7, r0

    /* Wait for calibration completion */
    while(HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADCAL))
 80073f6:	6823      	ldr	r3, [r4, #0]
 80073f8:	689a      	ldr	r2, [r3, #8]
 80073fa:	2a00      	cmp	r2, #0
 80073fc:	db0e      	blt.n	800741c <HAL_ADCEx_Calibration_Start+0x78>
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 80073fe:	2203      	movs	r2, #3
        return HAL_ERROR;
      }
    }
    
    /* Restore ADC DMA transfer request after calibration */
    SET_BIT(hadc->Instance->CFGR1, backup_setting_adc_dma_transfer);
 8007400:	68d9      	ldr	r1, [r3, #12]
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 8007402:	4015      	ands	r5, r2
    SET_BIT(hadc->Instance->CFGR1, backup_setting_adc_dma_transfer);
 8007404:	430d      	orrs	r5, r1
 8007406:	60dd      	str	r5, [r3, #12]

    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8007408:	6c63      	ldr	r3, [r4, #68]	; 0x44
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800740a:	2000      	movs	r0, #0
    ADC_STATE_CLR_SET(hadc->State,
 800740c:	4393      	bics	r3, r2
 800740e:	001a      	movs	r2, r3
 8007410:	2301      	movs	r3, #1
 8007412:	4313      	orrs	r3, r2
 8007414:	6463      	str	r3, [r4, #68]	; 0x44
    
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8007416:	2300      	movs	r3, #0
 8007418:	7033      	strb	r3, [r6, #0]
  
  /* Return function status */
  return tmp_hal_status;
 800741a:	e00e      	b.n	800743a <HAL_ADCEx_Calibration_Start+0x96>
      if((HAL_GetTick() - tickstart) > ADC_CALIBRATION_TIMEOUT)
 800741c:	f7ff fda4 	bl	8006f68 <HAL_GetTick>
 8007420:	1bc0      	subs	r0, r0, r7
 8007422:	2802      	cmp	r0, #2
 8007424:	d9e7      	bls.n	80073f6 <HAL_ADCEx_Calibration_Start+0x52>
        ADC_STATE_CLR_SET(hadc->State,
 8007426:	2212      	movs	r2, #18
 8007428:	6c63      	ldr	r3, [r4, #68]	; 0x44
        return HAL_ERROR;
 800742a:	2001      	movs	r0, #1
        ADC_STATE_CLR_SET(hadc->State,
 800742c:	4393      	bics	r3, r2
 800742e:	001a      	movs	r2, r3
 8007430:	2310      	movs	r3, #16
 8007432:	4313      	orrs	r3, r2
 8007434:	6463      	str	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hadc);
 8007436:	2300      	movs	r3, #0
 8007438:	7033      	strb	r3, [r6, #0]
}
 800743a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800743c:	2320      	movs	r3, #32
 800743e:	6c62      	ldr	r2, [r4, #68]	; 0x44
    tmp_hal_status = HAL_ERROR;
 8007440:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8007442:	4313      	orrs	r3, r2
 8007444:	6463      	str	r3, [r4, #68]	; 0x44
 8007446:	e7e6      	b.n	8007416 <HAL_ADCEx_Calibration_Start+0x72>
 8007448:	fffffefd 	.word	0xfffffefd

0800744c <HAL_NVIC_SetPriority>:
  *         with stm32f0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0 based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800744c:	b530      	push	{r4, r5, lr}
 800744e:	25ff      	movs	r5, #255	; 0xff
 8007450:	2403      	movs	r4, #3
 8007452:	002a      	movs	r2, r5
 8007454:	b2c3      	uxtb	r3, r0
 8007456:	401c      	ands	r4, r3
 8007458:	00e4      	lsls	r4, r4, #3
 800745a:	40a2      	lsls	r2, r4
 800745c:	0189      	lsls	r1, r1, #6
 800745e:	4029      	ands	r1, r5
 8007460:	43d2      	mvns	r2, r2
 8007462:	40a1      	lsls	r1, r4
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8007464:	2800      	cmp	r0, #0
 8007466:	da0b      	bge.n	8007480 <HAL_NVIC_SetPriority+0x34>
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8007468:	200f      	movs	r0, #15
 800746a:	4003      	ands	r3, r0
 800746c:	3b08      	subs	r3, #8
 800746e:	480a      	ldr	r0, [pc, #40]	; (8007498 <HAL_NVIC_SetPriority+0x4c>)
 8007470:	089b      	lsrs	r3, r3, #2
 8007472:	009b      	lsls	r3, r3, #2
 8007474:	181b      	adds	r3, r3, r0
 8007476:	69d8      	ldr	r0, [r3, #28]
 8007478:	4002      	ands	r2, r0
 800747a:	4311      	orrs	r1, r2
 800747c:	61d9      	str	r1, [r3, #28]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
}
 800747e:	bd30      	pop	{r4, r5, pc}
 8007480:	4b06      	ldr	r3, [pc, #24]	; (800749c <HAL_NVIC_SetPriority+0x50>)
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8007482:	0880      	lsrs	r0, r0, #2
 8007484:	0080      	lsls	r0, r0, #2
 8007486:	18c0      	adds	r0, r0, r3
 8007488:	23c0      	movs	r3, #192	; 0xc0
 800748a:	009b      	lsls	r3, r3, #2
 800748c:	58c4      	ldr	r4, [r0, r3]
 800748e:	4022      	ands	r2, r4
 8007490:	4311      	orrs	r1, r2
 8007492:	50c1      	str	r1, [r0, r3]
 8007494:	e7f3      	b.n	800747e <HAL_NVIC_SetPriority+0x32>
 8007496:	46c0      	nop			; (mov r8, r8)
 8007498:	e000ed00 	.word	0xe000ed00
 800749c:	e000e100 	.word	0xe000e100

080074a0 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80074a0:	231f      	movs	r3, #31
 80074a2:	4018      	ands	r0, r3
 80074a4:	3b1e      	subs	r3, #30
 80074a6:	4083      	lsls	r3, r0
 80074a8:	4a01      	ldr	r2, [pc, #4]	; (80074b0 <HAL_NVIC_EnableIRQ+0x10>)
 80074aa:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80074ac:	4770      	bx	lr
 80074ae:	46c0      	nop			; (mov r8, r8)
 80074b0:	e000e100 	.word	0xe000e100

080074b4 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80074b4:	4a09      	ldr	r2, [pc, #36]	; (80074dc <HAL_SYSTICK_Config+0x28>)
 80074b6:	1e43      	subs	r3, r0, #1
  {
    return (1UL);                                                   /* Reload value impossible */
 80074b8:	2001      	movs	r0, #1
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80074ba:	4293      	cmp	r3, r2
 80074bc:	d80d      	bhi.n	80074da <HAL_SYSTICK_Config+0x26>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80074be:	21c0      	movs	r1, #192	; 0xc0
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80074c0:	4a07      	ldr	r2, [pc, #28]	; (80074e0 <HAL_SYSTICK_Config+0x2c>)
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80074c2:	4808      	ldr	r0, [pc, #32]	; (80074e4 <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80074c4:	6053      	str	r3, [r2, #4]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80074c6:	6a03      	ldr	r3, [r0, #32]
 80074c8:	0609      	lsls	r1, r1, #24
 80074ca:	021b      	lsls	r3, r3, #8
 80074cc:	0a1b      	lsrs	r3, r3, #8
 80074ce:	430b      	orrs	r3, r1
 80074d0:	6203      	str	r3, [r0, #32]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80074d2:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80074d4:	2307      	movs	r3, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80074d6:	6090      	str	r0, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80074d8:	6013      	str	r3, [r2, #0]
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80074da:	4770      	bx	lr
 80074dc:	00ffffff 	.word	0x00ffffff
 80074e0:	e000e010 	.word	0xe000e010
 80074e4:	e000ed00 	.word	0xe000ed00

080074e8 <CRC_Handle_8>:
  * @param  pBuffer: pointer to the input data buffer
  * @param  BufferLength: input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 80074e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80074ea:	000e      	movs	r6, r1
  uint32_t i = 0U; /* input data buffer index */
  
   /* Processing time optimization: 4 bytes are entered in a row with a single word write,
    * last bytes must be carefully fed to the CRC calculator to ensure a correct type
    * handling by the IP */
   for(i = 0U; i < (BufferLength/4U); i++)
 80074ec:	0895      	lsrs	r5, r2, #2
 80074ee:	00ad      	lsls	r5, r5, #2
 80074f0:	186b      	adds	r3, r5, r1
 80074f2:	9301      	str	r3, [sp, #4]
 80074f4:	6803      	ldr	r3, [r0, #0]
 80074f6:	9c01      	ldr	r4, [sp, #4]
 80074f8:	42a6      	cmp	r6, r4
 80074fa:	d107      	bne.n	800750c <CRC_Handle_8+0x24>
   {
      hcrc->Instance->DR = ((uint32_t)pBuffer[4U*i]<<24U) | ((uint32_t)pBuffer[4U*i+1]<<16U) | ((uint32_t)pBuffer[4U*i+2]<<8U) | (uint32_t)pBuffer[4U*i+3];      
   }
   /* last bytes specific handling */
   if ((BufferLength%4U) != 0U)
 80074fc:	2403      	movs	r4, #3
 80074fe:	4022      	ands	r2, r4
 8007500:	d019      	beq.n	8007536 <CRC_Handle_8+0x4e>
   {
     if  (BufferLength%4U == 1U)
 8007502:	2a01      	cmp	r2, #1
 8007504:	d10f      	bne.n	8007526 <CRC_Handle_8+0x3e>
     {
       *(uint8_t volatile*) (&hcrc->Instance->DR) = pBuffer[4*i];
 8007506:	5d4a      	ldrb	r2, [r1, r5]
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
     }
     if  (BufferLength%4U == 3U)
     {
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
       *(uint8_t volatile*) (&hcrc->Instance->DR) = pBuffer[4*i+2];       
 8007508:	701a      	strb	r2, [r3, #0]
 800750a:	e014      	b.n	8007536 <CRC_Handle_8+0x4e>
      hcrc->Instance->DR = ((uint32_t)pBuffer[4U*i]<<24U) | ((uint32_t)pBuffer[4U*i+1]<<16U) | ((uint32_t)pBuffer[4U*i+2]<<8U) | (uint32_t)pBuffer[4U*i+3];      
 800750c:	7834      	ldrb	r4, [r6, #0]
 800750e:	7877      	ldrb	r7, [r6, #1]
 8007510:	0624      	lsls	r4, r4, #24
 8007512:	043f      	lsls	r7, r7, #16
 8007514:	433c      	orrs	r4, r7
 8007516:	78f7      	ldrb	r7, [r6, #3]
 8007518:	433c      	orrs	r4, r7
 800751a:	78b7      	ldrb	r7, [r6, #2]
 800751c:	3604      	adds	r6, #4
 800751e:	023f      	lsls	r7, r7, #8
 8007520:	433c      	orrs	r4, r7
 8007522:	601c      	str	r4, [r3, #0]
 8007524:	e7e7      	b.n	80074f6 <CRC_Handle_8+0xe>
 8007526:	186c      	adds	r4, r5, r1
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
 8007528:	5d49      	ldrb	r1, [r1, r5]
 800752a:	0209      	lsls	r1, r1, #8
     if  (BufferLength%4U == 2U)
 800752c:	2a02      	cmp	r2, #2
 800752e:	d105      	bne.n	800753c <CRC_Handle_8+0x54>
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
 8007530:	7862      	ldrb	r2, [r4, #1]
 8007532:	430a      	orrs	r2, r1
 8007534:	801a      	strh	r2, [r3, #0]
     }
   }
  
  /* Return the CRC computed value */ 
  return hcrc->Instance->DR;
 8007536:	6803      	ldr	r3, [r0, #0]
 8007538:	6818      	ldr	r0, [r3, #0]
}
 800753a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
 800753c:	7862      	ldrb	r2, [r4, #1]
 800753e:	430a      	orrs	r2, r1
 8007540:	801a      	strh	r2, [r3, #0]
       *(uint8_t volatile*) (&hcrc->Instance->DR) = pBuffer[4*i+2];       
 8007542:	78a2      	ldrb	r2, [r4, #2]
 8007544:	e7e0      	b.n	8007508 <CRC_Handle_8+0x20>

08007546 <CRC_Handle_16>:
  * @param  pBuffer: pointer to the input data buffer
  * @param  BufferLength: input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */  
static uint32_t CRC_Handle_16(CRC_HandleTypeDef *hcrc, uint16_t pBuffer[], uint32_t BufferLength)
{
 8007546:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007548:	000d      	movs	r5, r1
  uint32_t i = 0U;  /* input data buffer index */
  
  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure 
   * a correct type handling by the IP */
  for(i = 0U; i < (BufferLength/2U); i++)
 800754a:	2600      	movs	r6, #0
 800754c:	6800      	ldr	r0, [r0, #0]
 800754e:	0854      	lsrs	r4, r2, #1
 8007550:	42b4      	cmp	r4, r6
 8007552:	d106      	bne.n	8007562 <CRC_Handle_16+0x1c>
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U*i]<<16U) | (uint32_t)pBuffer[2U*i+1];     
  }
  if ((BufferLength%2U) != 0U)
 8007554:	07d3      	lsls	r3, r2, #31
 8007556:	d502      	bpl.n	800755e <CRC_Handle_16+0x18>
  {
       *(uint16_t volatile*) (&hcrc->Instance->DR) = pBuffer[2*i]; 
 8007558:	00a4      	lsls	r4, r4, #2
 800755a:	5a63      	ldrh	r3, [r4, r1]
 800755c:	8003      	strh	r3, [r0, #0]
  }
   
  /* Return the CRC computed value */ 
  return hcrc->Instance->DR;
 800755e:	6800      	ldr	r0, [r0, #0]
}
 8007560:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U*i]<<16U) | (uint32_t)pBuffer[2U*i+1];     
 8007562:	882b      	ldrh	r3, [r5, #0]
 8007564:	886f      	ldrh	r7, [r5, #2]
 8007566:	041b      	lsls	r3, r3, #16
 8007568:	433b      	orrs	r3, r7
 800756a:	6003      	str	r3, [r0, #0]
  for(i = 0U; i < (BufferLength/2U); i++)
 800756c:	3601      	adds	r6, #1
 800756e:	3504      	adds	r5, #4
 8007570:	e7ee      	b.n	8007550 <CRC_Handle_16+0xa>

08007572 <HAL_CRC_Init>:
{
 8007572:	b510      	push	{r4, lr}
 8007574:	1e04      	subs	r4, r0, #0
  if(hcrc == NULL)
 8007576:	d101      	bne.n	800757c <HAL_CRC_Init+0xa>
    return HAL_ERROR;
 8007578:	2001      	movs	r0, #1
}
 800757a:	bd10      	pop	{r4, pc}
  if(hcrc->State == HAL_CRC_STATE_RESET)
 800757c:	7f43      	ldrb	r3, [r0, #29]
 800757e:	b2db      	uxtb	r3, r3
 8007580:	2b00      	cmp	r3, #0
 8007582:	d102      	bne.n	800758a <HAL_CRC_Init+0x18>
    hcrc->Lock = HAL_UNLOCKED;
 8007584:	7703      	strb	r3, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 8007586:	f7fe fd21 	bl	8005fcc <HAL_CRC_MspInit>
  hcrc->State = HAL_CRC_STATE_BUSY; 
 800758a:	2302      	movs	r3, #2
  if (HAL_CRCEx_Init(hcrc) != HAL_OK)
 800758c:	0020      	movs	r0, r4
  hcrc->State = HAL_CRC_STATE_BUSY; 
 800758e:	7763      	strb	r3, [r4, #29]
  if (HAL_CRCEx_Init(hcrc) != HAL_OK)
 8007590:	f000 f870 	bl	8007674 <HAL_CRCEx_Init>
 8007594:	2800      	cmp	r0, #0
 8007596:	d1ef      	bne.n	8007578 <HAL_CRC_Init+0x6>
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 8007598:	7962      	ldrb	r2, [r4, #5]
 800759a:	6823      	ldr	r3, [r4, #0]
 800759c:	2a00      	cmp	r2, #0
 800759e:	d110      	bne.n	80075c2 <HAL_CRC_Init+0x50>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);  
 80075a0:	3a01      	subs	r2, #1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 80075a2:	2160      	movs	r1, #96	; 0x60
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 80075a4:	611a      	str	r2, [r3, #16]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 80075a6:	689a      	ldr	r2, [r3, #8]
 80075a8:	438a      	bics	r2, r1
 80075aa:	6961      	ldr	r1, [r4, #20]
 80075ac:	430a      	orrs	r2, r1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);  
 80075ae:	2180      	movs	r1, #128	; 0x80
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 80075b0:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);  
 80075b2:	689a      	ldr	r2, [r3, #8]
 80075b4:	438a      	bics	r2, r1
 80075b6:	69a1      	ldr	r1, [r4, #24]
 80075b8:	430a      	orrs	r2, r1
 80075ba:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 80075bc:	2301      	movs	r3, #1
 80075be:	7763      	strb	r3, [r4, #29]
  return HAL_OK;
 80075c0:	e7db      	b.n	800757a <HAL_CRC_Init+0x8>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 80075c2:	6922      	ldr	r2, [r4, #16]
 80075c4:	e7ed      	b.n	80075a2 <HAL_CRC_Init+0x30>

080075c6 <HAL_CRC_Calculate>:
{
 80075c6:	b570      	push	{r4, r5, r6, lr}
 80075c8:	2502      	movs	r5, #2
  __HAL_LOCK(hcrc); 
 80075ca:	7f03      	ldrb	r3, [r0, #28]
{
 80075cc:	0004      	movs	r4, r0
  __HAL_LOCK(hcrc); 
 80075ce:	0028      	movs	r0, r5
 80075d0:	2b01      	cmp	r3, #1
 80075d2:	d01b      	beq.n	800760c <HAL_CRC_Calculate+0x46>
 80075d4:	2301      	movs	r3, #1
  __HAL_CRC_DR_RESET(hcrc);
 80075d6:	6820      	ldr	r0, [r4, #0]
  hcrc->State = HAL_CRC_STATE_BUSY;
 80075d8:	7765      	strb	r5, [r4, #29]
  __HAL_CRC_DR_RESET(hcrc);
 80075da:	6885      	ldr	r5, [r0, #8]
  __HAL_LOCK(hcrc); 
 80075dc:	7723      	strb	r3, [r4, #28]
  __HAL_CRC_DR_RESET(hcrc);
 80075de:	432b      	orrs	r3, r5
 80075e0:	6083      	str	r3, [r0, #8]
  switch (hcrc->InputDataFormat)
 80075e2:	6a23      	ldr	r3, [r4, #32]
 80075e4:	2b02      	cmp	r3, #2
 80075e6:	d015      	beq.n	8007614 <HAL_CRC_Calculate+0x4e>
 80075e8:	2b03      	cmp	r3, #3
 80075ea:	d006      	beq.n	80075fa <HAL_CRC_Calculate+0x34>
  uint32_t temp = 0U;  /* CRC output (read from hcrc->Instance->DR register) */
 80075ec:	2000      	movs	r0, #0
  switch (hcrc->InputDataFormat)
 80075ee:	2b01      	cmp	r3, #1
 80075f0:	d108      	bne.n	8007604 <HAL_CRC_Calculate+0x3e>
      temp = CRC_Handle_8(hcrc, (uint8_t*)pBuffer, BufferLength);
 80075f2:	0020      	movs	r0, r4
 80075f4:	f7ff ff78 	bl	80074e8 <CRC_Handle_8>
      break;
 80075f8:	e004      	b.n	8007604 <HAL_CRC_Calculate+0x3e>
 80075fa:	0092      	lsls	r2, r2, #2
 80075fc:	188a      	adds	r2, r1, r2
      for(index = 0U; index < BufferLength; index++)
 80075fe:	4291      	cmp	r1, r2
 8007600:	d105      	bne.n	800760e <HAL_CRC_Calculate+0x48>
      temp = hcrc->Instance->DR;
 8007602:	6800      	ldr	r0, [r0, #0]
  hcrc->State = HAL_CRC_STATE_READY; 
 8007604:	2301      	movs	r3, #1
 8007606:	7763      	strb	r3, [r4, #29]
  __HAL_UNLOCK(hcrc);
 8007608:	2300      	movs	r3, #0
 800760a:	7723      	strb	r3, [r4, #28]
}
 800760c:	bd70      	pop	{r4, r5, r6, pc}
        hcrc->Instance->DR = pBuffer[index];
 800760e:	c908      	ldmia	r1!, {r3}
 8007610:	6003      	str	r3, [r0, #0]
 8007612:	e7f4      	b.n	80075fe <HAL_CRC_Calculate+0x38>
      temp = CRC_Handle_16(hcrc, (uint16_t*)pBuffer, BufferLength);
 8007614:	0020      	movs	r0, r4
 8007616:	f7ff ff96 	bl	8007546 <CRC_Handle_16>
      break;
 800761a:	e7f3      	b.n	8007604 <HAL_CRC_Calculate+0x3e>

0800761c <HAL_CRCEx_Polynomial_Set>:
  *          @arg CRC_POLYLENGTH_16B: 16-bit long CRC (generating polynomial of degree 16)
  *          @arg CRC_POLYLENGTH_32B: 32-bit long CRC (generating polynomial of degree 32)                
  * @retval HAL status
  */                                   
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
 800761c:	b530      	push	{r4, r5, lr}
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 800761e:	231f      	movs	r3, #31
{
 8007620:	0004      	movs	r4, r0
   * definition. HAL_ERROR is reported if Pol degree is 
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while (((Pol & (1U << msb)) == 0U) && (msb-- > 0U))
 8007622:	2001      	movs	r0, #1
 8007624:	0005      	movs	r5, r0
 8007626:	409d      	lsls	r5, r3
 8007628:	4229      	tst	r1, r5
 800762a:	d109      	bne.n	8007640 <HAL_CRCEx_Polynomial_Set+0x24>
 800762c:	3b01      	subs	r3, #1
 800762e:	d2f9      	bcs.n	8007624 <HAL_CRCEx_Polynomial_Set+0x8>
  {}

  switch (PolyLength)
 8007630:	2a10      	cmp	r2, #16
 8007632:	d003      	beq.n	800763c <HAL_CRCEx_Polynomial_Set+0x20>
 8007634:	2a18      	cmp	r2, #24
 8007636:	d001      	beq.n	800763c <HAL_CRCEx_Polynomial_Set+0x20>
 8007638:	2a08      	cmp	r2, #8
 800763a:	d112      	bne.n	8007662 <HAL_CRCEx_Polynomial_Set+0x46>
  {
    case CRC_POLYLENGTH_7B:
      if (msb >= HAL_CRC_LENGTH_7B)
      {
        return  HAL_ERROR;
 800763c:	2001      	movs	r0, #1
 800763e:	e00c      	b.n	800765a <HAL_CRCEx_Polynomial_Set+0x3e>
  switch (PolyLength)
 8007640:	2a10      	cmp	r2, #16
 8007642:	d00b      	beq.n	800765c <HAL_CRCEx_Polynomial_Set+0x40>
 8007644:	2a18      	cmp	r2, #24
 8007646:	d005      	beq.n	8007654 <HAL_CRCEx_Polynomial_Set+0x38>
 8007648:	2a08      	cmp	r2, #8
 800764a:	d10a      	bne.n	8007662 <HAL_CRCEx_Polynomial_Set+0x46>
        return  HAL_ERROR;
 800764c:	2001      	movs	r0, #1
      { 
        return  HAL_ERROR;
      }
      break;
    case CRC_POLYLENGTH_16B:
      if (msb >= HAL_CRC_LENGTH_16B)
 800764e:	2b0f      	cmp	r3, #15
 8007650:	d907      	bls.n	8007662 <HAL_CRCEx_Polynomial_Set+0x46>
 8007652:	e002      	b.n	800765a <HAL_CRCEx_Polynomial_Set+0x3e>
        return  HAL_ERROR;
 8007654:	2001      	movs	r0, #1
      if (msb >= HAL_CRC_LENGTH_7B)
 8007656:	2b06      	cmp	r3, #6
 8007658:	d903      	bls.n	8007662 <HAL_CRCEx_Polynomial_Set+0x46>
  /* set generating polynomial size */
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);  
  
  /* Return function status */
  return HAL_OK;
}
 800765a:	bd30      	pop	{r4, r5, pc}
        return  HAL_ERROR;
 800765c:	2001      	movs	r0, #1
      if (msb >= HAL_CRC_LENGTH_8B)
 800765e:	2b07      	cmp	r3, #7
 8007660:	d8fb      	bhi.n	800765a <HAL_CRCEx_Polynomial_Set+0x3e>
  WRITE_REG(hcrc->Instance->POL, Pol);
 8007662:	6820      	ldr	r0, [r4, #0]
 8007664:	6141      	str	r1, [r0, #20]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);  
 8007666:	2118      	movs	r1, #24
 8007668:	6883      	ldr	r3, [r0, #8]
 800766a:	438b      	bics	r3, r1
 800766c:	431a      	orrs	r2, r3
 800766e:	6082      	str	r2, [r0, #8]
 8007670:	2000      	movs	r0, #0
 8007672:	e7f2      	b.n	800765a <HAL_CRCEx_Polynomial_Set+0x3e>

08007674 <HAL_CRCEx_Init>:
{
 8007674:	b510      	push	{r4, lr}
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 8007676:	7903      	ldrb	r3, [r0, #4]
 8007678:	2b00      	cmp	r3, #0
 800767a:	d108      	bne.n	800768e <HAL_CRCEx_Init+0x1a>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);  
 800767c:	6802      	ldr	r2, [r0, #0]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 800767e:	2018      	movs	r0, #24
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);  
 8007680:	4907      	ldr	r1, [pc, #28]	; (80076a0 <HAL_CRCEx_Init+0x2c>)
 8007682:	6151      	str	r1, [r2, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 8007684:	6891      	ldr	r1, [r2, #8]
 8007686:	4381      	bics	r1, r0
   return HAL_OK;
 8007688:	0018      	movs	r0, r3
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 800768a:	6091      	str	r1, [r2, #8]
}
 800768c:	bd10      	pop	{r4, pc}
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 800768e:	68c2      	ldr	r2, [r0, #12]
 8007690:	6881      	ldr	r1, [r0, #8]
 8007692:	f7ff ffc3 	bl	800761c <HAL_CRCEx_Polynomial_Set>
 8007696:	1e43      	subs	r3, r0, #1
 8007698:	4198      	sbcs	r0, r3
      return HAL_ERROR;
 800769a:	b2c0      	uxtb	r0, r0
 800769c:	e7f6      	b.n	800768c <HAL_CRCEx_Init+0x18>
 800769e:	46c0      	nop			; (mov r8, r8)
 80076a0:	04c11db7 	.word	0x04c11db7

080076a4 <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
 80076a4:	b570      	push	{r4, r5, r6, lr}
 80076a6:	0004      	movs	r4, r0
  uint32_t tmp = 0U;
  
  /* Check the DMA handle allocation */
  if(NULL == hdma)
  {
    return HAL_ERROR;
 80076a8:	2501      	movs	r5, #1
  if(NULL == hdma)
 80076aa:	2800      	cmp	r0, #0
 80076ac:	d028      	beq.n	8007700 <HAL_DMA_Init+0x5c>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
  
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 80076ae:	2302      	movs	r3, #2
 80076b0:	1c86      	adds	r6, r0, #2

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 80076b2:	6800      	ldr	r0, [r0, #0]
  hdma->State = HAL_DMA_STATE_BUSY;
 80076b4:	77f3      	strb	r3, [r6, #31]
  tmp = hdma->Instance->CCR;
 80076b6:	6802      	ldr	r2, [r0, #0]
  
  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 80076b8:	4b12      	ldr	r3, [pc, #72]	; (8007704 <HAL_DMA_Init+0x60>)
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 80076ba:	68a1      	ldr	r1, [r4, #8]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 80076bc:	401a      	ands	r2, r3
  tmp |=  hdma->Init.Direction        |
 80076be:	6863      	ldr	r3, [r4, #4]
 80076c0:	430b      	orrs	r3, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 80076c2:	68e1      	ldr	r1, [r4, #12]
 80076c4:	430b      	orrs	r3, r1
 80076c6:	6921      	ldr	r1, [r4, #16]
 80076c8:	430b      	orrs	r3, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80076ca:	6961      	ldr	r1, [r4, #20]
 80076cc:	430b      	orrs	r3, r1
 80076ce:	69a1      	ldr	r1, [r4, #24]
 80076d0:	430b      	orrs	r3, r1
          hdma->Init.Mode                | hdma->Init.Priority;
 80076d2:	69e1      	ldr	r1, [r4, #28]
 80076d4:	430b      	orrs	r3, r1
  tmp |=  hdma->Init.Direction        |
 80076d6:	4313      	orrs	r3, r2

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;  
 80076d8:	6003      	str	r3, [r0, #0]
    hdma->DmaBaseAddress = DMA2;
  }
#else
  /* calculation of the channel index */
  /* DMA1 */
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80076da:	4b0b      	ldr	r3, [pc, #44]	; (8007708 <HAL_DMA_Init+0x64>)
 80076dc:	2114      	movs	r1, #20
 80076de:	18c0      	adds	r0, r0, r3
 80076e0:	f7fe f968 	bl	80059b4 <__udivsi3>
  hdma->DmaBaseAddress = DMA1;
 80076e4:	4b09      	ldr	r3, [pc, #36]	; (800770c <HAL_DMA_Init+0x68>)
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80076e6:	0080      	lsls	r0, r0, #2
  hdma->DmaBaseAddress = DMA1;
 80076e8:	63e3      	str	r3, [r4, #60]	; 0x3c
  hdma->XferCpltCallback = NULL;
 80076ea:	2300      	movs	r3, #0
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80076ec:	6420      	str	r0, [r4, #64]	; 0x40
  hdma->XferCpltCallback = NULL;
 80076ee:	62a3      	str	r3, [r4, #40]	; 0x28
  hdma->XferHalfCpltCallback = NULL;
 80076f0:	62e3      	str	r3, [r4, #44]	; 0x2c
  hdma->XferErrorCallback = NULL;
 80076f2:	6323      	str	r3, [r4, #48]	; 0x30
  hdma->XferAbortCallback = NULL;
 80076f4:	6363      	str	r3, [r4, #52]	; 0x34
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80076f6:	63a3      	str	r3, [r4, #56]	; 0x38
  hdma->State = HAL_DMA_STATE_READY;
 80076f8:	77f5      	strb	r5, [r6, #31]
  hdma->Lock = HAL_UNLOCKED;
 80076fa:	1964      	adds	r4, r4, r5
  return HAL_OK;
 80076fc:	001d      	movs	r5, r3
  hdma->Lock = HAL_UNLOCKED;
 80076fe:	77e3      	strb	r3, [r4, #31]
}  
 8007700:	0028      	movs	r0, r5
 8007702:	bd70      	pop	{r4, r5, r6, pc}
 8007704:	ffffc00f 	.word	0xffffc00f
 8007708:	bffdfff8 	.word	0xbffdfff8
 800770c:	40020000 	.word	0x40020000

08007710 <HAL_DMA_DeInit>:
{
 8007710:	b570      	push	{r4, r5, r6, lr}
 8007712:	0004      	movs	r4, r0
 8007714:	2601      	movs	r6, #1
  if(NULL == hdma)
 8007716:	2800      	cmp	r0, #0
 8007718:	d019      	beq.n	800774e <HAL_DMA_DeInit+0x3e>
  hdma->Instance->CCR  = 0U;
 800771a:	2500      	movs	r5, #0
  hdma->Instance->CCR &= ~DMA_CCR_EN;
 800771c:	6800      	ldr	r0, [r0, #0]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 800771e:	2114      	movs	r1, #20
  hdma->Instance->CCR &= ~DMA_CCR_EN;
 8007720:	6803      	ldr	r3, [r0, #0]
 8007722:	43b3      	bics	r3, r6
 8007724:	6003      	str	r3, [r0, #0]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 8007726:	4b0b      	ldr	r3, [pc, #44]	; (8007754 <HAL_DMA_DeInit+0x44>)
  hdma->Instance->CCR  = 0U;
 8007728:	6005      	str	r5, [r0, #0]
  hdma->Instance->CNDTR = 0U;
 800772a:	6045      	str	r5, [r0, #4]
  hdma->Instance->CPAR  = 0U;
 800772c:	6085      	str	r5, [r0, #8]
  hdma->Instance->CMAR = 0U;
 800772e:	60c5      	str	r5, [r0, #12]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 8007730:	18c0      	adds	r0, r0, r3
 8007732:	f7fe f93f 	bl	80059b4 <__udivsi3>
 8007736:	0080      	lsls	r0, r0, #2
  hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 8007738:	4086      	lsls	r6, r0
  hdma->DmaBaseAddress = DMA1;
 800773a:	4b07      	ldr	r3, [pc, #28]	; (8007758 <HAL_DMA_DeInit+0x48>)
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 800773c:	6420      	str	r0, [r4, #64]	; 0x40
  hdma->DmaBaseAddress = DMA1;
 800773e:	63e3      	str	r3, [r4, #60]	; 0x3c
  hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 8007740:	605e      	str	r6, [r3, #4]
  return HAL_OK;
 8007742:	002e      	movs	r6, r5
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8007744:	63a5      	str	r5, [r4, #56]	; 0x38
  hdma->State = HAL_DMA_STATE_RESET;
 8007746:	1ca3      	adds	r3, r4, #2
  __HAL_UNLOCK(hdma);
 8007748:	3401      	adds	r4, #1
  hdma->State = HAL_DMA_STATE_RESET;
 800774a:	77dd      	strb	r5, [r3, #31]
  __HAL_UNLOCK(hdma);
 800774c:	77e5      	strb	r5, [r4, #31]
}
 800774e:	0030      	movs	r0, r6
 8007750:	bd70      	pop	{r4, r5, r6, pc}
 8007752:	46c0      	nop			; (mov r8, r8)
 8007754:	bffdfff8 	.word	0xbffdfff8
 8007758:	40020000 	.word	0x40020000

0800775c <HAL_DMA_Start_IT>:
{
 800775c:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(hdma);
 800775e:	1c44      	adds	r4, r0, #1
 8007760:	7fe6      	ldrb	r6, [r4, #31]
{
 8007762:	0005      	movs	r5, r0
  __HAL_LOCK(hdma);
 8007764:	2002      	movs	r0, #2
 8007766:	2e01      	cmp	r6, #1
 8007768:	d027      	beq.n	80077ba <HAL_DMA_Start_IT+0x5e>
 800776a:	3801      	subs	r0, #1
 800776c:	77e0      	strb	r0, [r4, #31]
  if(HAL_DMA_STATE_READY == hdma->State)
 800776e:	1ca8      	adds	r0, r5, #2
 8007770:	7fc6      	ldrb	r6, [r0, #31]
 8007772:	4684      	mov	ip, r0
 8007774:	b2f6      	uxtb	r6, r6
 8007776:	2002      	movs	r0, #2
 8007778:	2700      	movs	r7, #0
 800777a:	2e01      	cmp	r6, #1
 800777c:	d128      	bne.n	80077d0 <HAL_DMA_Start_IT+0x74>
  	hdma->State = HAL_DMA_STATE_BUSY;
 800777e:	4664      	mov	r4, ip
 8007780:	77e0      	strb	r0, [r4, #31]
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8007782:	682c      	ldr	r4, [r5, #0]
  	hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8007784:	63af      	str	r7, [r5, #56]	; 0x38
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8007786:	6820      	ldr	r0, [r4, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8007788:	6c2f      	ldr	r7, [r5, #64]	; 0x40
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 800778a:	43b0      	bics	r0, r6
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 800778c:	40be      	lsls	r6, r7
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 800778e:	6020      	str	r0, [r4, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8007790:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 8007792:	6046      	str	r6, [r0, #4]
  hdma->Instance->CNDTR = DataLength;
 8007794:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8007796:	686b      	ldr	r3, [r5, #4]
 8007798:	6828      	ldr	r0, [r5, #0]
 800779a:	2b10      	cmp	r3, #16
 800779c:	d10e      	bne.n	80077bc <HAL_DMA_Start_IT+0x60>
    hdma->Instance->CPAR = DstAddress;
 800779e:	60a2      	str	r2, [r4, #8]
    hdma->Instance->CMAR = SrcAddress;
 80077a0:	60e1      	str	r1, [r4, #12]
    if(NULL != hdma->XferHalfCpltCallback )
 80077a2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
      hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 80077a4:	6822      	ldr	r2, [r4, #0]
    if(NULL != hdma->XferHalfCpltCallback )
 80077a6:	2b00      	cmp	r3, #0
 80077a8:	d00b      	beq.n	80077c2 <HAL_DMA_Start_IT+0x66>
      hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 80077aa:	230e      	movs	r3, #14
 80077ac:	4313      	orrs	r3, r2
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 80077ae:	6023      	str	r3, [r4, #0]
  	hdma->Instance->CCR |= DMA_CCR_EN;
 80077b0:	2301      	movs	r3, #1
 80077b2:	6802      	ldr	r2, [r0, #0]
 80077b4:	4313      	orrs	r3, r2
 80077b6:	6003      	str	r3, [r0, #0]
	HAL_StatusTypeDef status = HAL_OK;
 80077b8:	2000      	movs	r0, #0
} 
 80077ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hdma->Instance->CPAR = SrcAddress;
 80077bc:	60a1      	str	r1, [r4, #8]
    hdma->Instance->CMAR = DstAddress;
 80077be:	60e2      	str	r2, [r4, #12]
 80077c0:	e7ef      	b.n	80077a2 <HAL_DMA_Start_IT+0x46>
  		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
 80077c2:	230a      	movs	r3, #10
 80077c4:	4313      	orrs	r3, r2
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 80077c6:	2204      	movs	r2, #4
  		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
 80077c8:	6023      	str	r3, [r4, #0]
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 80077ca:	6823      	ldr	r3, [r4, #0]
 80077cc:	4393      	bics	r3, r2
 80077ce:	e7ee      	b.n	80077ae <HAL_DMA_Start_IT+0x52>
    __HAL_UNLOCK(hdma); 
 80077d0:	77e7      	strb	r7, [r4, #31]
 80077d2:	e7f2      	b.n	80077ba <HAL_DMA_Start_IT+0x5e>

080077d4 <HAL_DMA_Abort>:
	 hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 80077d4:	210e      	movs	r1, #14
 80077d6:	6803      	ldr	r3, [r0, #0]
{
 80077d8:	b510      	push	{r4, lr}
	 hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 80077da:	681a      	ldr	r2, [r3, #0]
	hdma->DmaBaseAddress->IFCR = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 80077dc:	6c04      	ldr	r4, [r0, #64]	; 0x40
	 hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 80077de:	438a      	bics	r2, r1
 80077e0:	601a      	str	r2, [r3, #0]
	hdma->Instance->CCR &= ~DMA_CCR_EN;
 80077e2:	2201      	movs	r2, #1
 80077e4:	6819      	ldr	r1, [r3, #0]
 80077e6:	4391      	bics	r1, r2
 80077e8:	6019      	str	r1, [r3, #0]
	hdma->DmaBaseAddress->IFCR = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 80077ea:	0011      	movs	r1, r2
 80077ec:	40a1      	lsls	r1, r4
 80077ee:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 80077f0:	6059      	str	r1, [r3, #4]
	hdma->State = HAL_DMA_STATE_READY; 
 80077f2:	1c83      	adds	r3, r0, #2
 80077f4:	77da      	strb	r2, [r3, #31]
	__HAL_UNLOCK(hdma);
 80077f6:	1883      	adds	r3, r0, r2
 80077f8:	2000      	movs	r0, #0
 80077fa:	77d8      	strb	r0, [r3, #31]
}
 80077fc:	bd10      	pop	{r4, pc}
	...

08007800 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{ 
 8007800:	b5f0      	push	{r4, r5, r6, r7, lr}
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
  
        temp = SYSCFG->EXTICR[position >> 2];
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8007802:	4a56      	ldr	r2, [pc, #344]	; (800795c <HAL_GPIO_Init+0x15c>)
  while (((GPIO_Init->Pin) >> position) != RESET)
 8007804:	680b      	ldr	r3, [r1, #0]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8007806:	1882      	adds	r2, r0, r2
 8007808:	1e54      	subs	r4, r2, #1
 800780a:	41a2      	sbcs	r2, r4
{ 
 800780c:	b089      	sub	sp, #36	; 0x24
  while (((GPIO_Init->Pin) >> position) != RESET)
 800780e:	9303      	str	r3, [sp, #12]
  uint32_t position = 0x00U;
 8007810:	2300      	movs	r3, #0
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8007812:	3204      	adds	r2, #4
 8007814:	9205      	str	r2, [sp, #20]
  while (((GPIO_Init->Pin) >> position) != RESET)
 8007816:	9a03      	ldr	r2, [sp, #12]
 8007818:	40da      	lsrs	r2, r3
 800781a:	d101      	bne.n	8007820 <HAL_GPIO_Init+0x20>
      }
    }
    
    position++;
  } 
}
 800781c:	b009      	add	sp, #36	; 0x24
 800781e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8007820:	2201      	movs	r2, #1
 8007822:	409a      	lsls	r2, r3
 8007824:	4694      	mov	ip, r2
 8007826:	4664      	mov	r4, ip
 8007828:	9a03      	ldr	r2, [sp, #12]
 800782a:	4022      	ands	r2, r4
 800782c:	9202      	str	r2, [sp, #8]
    if(iocurrent)
 800782e:	d100      	bne.n	8007832 <HAL_GPIO_Init+0x32>
 8007830:	e092      	b.n	8007958 <HAL_GPIO_Init+0x158>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
 8007832:	684a      	ldr	r2, [r1, #4]
 8007834:	9201      	str	r2, [sp, #4]
 8007836:	2210      	movs	r2, #16
 8007838:	9e01      	ldr	r6, [sp, #4]
 800783a:	4396      	bics	r6, r2
 800783c:	2e02      	cmp	r6, #2
 800783e:	d10d      	bne.n	800785c <HAL_GPIO_Init+0x5c>
        CLEAR_BIT(temp, 0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;      
 8007840:	2407      	movs	r4, #7
 8007842:	270f      	movs	r7, #15
 8007844:	401c      	ands	r4, r3
 8007846:	00a4      	lsls	r4, r4, #2
 8007848:	40a7      	lsls	r7, r4
        temp = GPIOx->AFR[position >> 3];
 800784a:	08da      	lsrs	r2, r3, #3
 800784c:	0092      	lsls	r2, r2, #2
 800784e:	1882      	adds	r2, r0, r2
 8007850:	6a15      	ldr	r5, [r2, #32]
        CLEAR_BIT(temp, 0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;      
 8007852:	43bd      	bics	r5, r7
        SET_BIT(temp, (uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));       
 8007854:	690f      	ldr	r7, [r1, #16]
 8007856:	40a7      	lsls	r7, r4
 8007858:	433d      	orrs	r5, r7
        GPIOx->AFR[position >> 3U] = temp;
 800785a:	6215      	str	r5, [r2, #32]
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
 800785c:	2203      	movs	r2, #3
 800785e:	0014      	movs	r4, r2
 8007860:	005d      	lsls	r5, r3, #1
 8007862:	40ac      	lsls	r4, r5
 8007864:	43e4      	mvns	r4, r4
      temp = GPIOx->MODER;
 8007866:	6807      	ldr	r7, [r0, #0]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8007868:	3e01      	subs	r6, #1
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
 800786a:	4027      	ands	r7, r4
 800786c:	9704      	str	r7, [sp, #16]
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800786e:	9f01      	ldr	r7, [sp, #4]
 8007870:	403a      	ands	r2, r7
 8007872:	40aa      	lsls	r2, r5
 8007874:	9f04      	ldr	r7, [sp, #16]
 8007876:	433a      	orrs	r2, r7
      GPIOx->MODER = temp;
 8007878:	6002      	str	r2, [r0, #0]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800787a:	2e01      	cmp	r6, #1
 800787c:	d80e      	bhi.n	800789c <HAL_GPIO_Init+0x9c>
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 800787e:	68ca      	ldr	r2, [r1, #12]
        temp = GPIOx->OSPEEDR; 
 8007880:	6886      	ldr	r6, [r0, #8]
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 8007882:	40aa      	lsls	r2, r5
        CLEAR_BIT(temp, GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8007884:	4026      	ands	r6, r4
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 8007886:	4332      	orrs	r2, r6
        GPIOx->OSPEEDR = temp;
 8007888:	6082      	str	r2, [r0, #8]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 800788a:	4662      	mov	r2, ip
        temp = GPIOx->OTYPER;
 800788c:	6846      	ldr	r6, [r0, #4]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 800788e:	4396      	bics	r6, r2
        SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8007890:	9a01      	ldr	r2, [sp, #4]
 8007892:	06d2      	lsls	r2, r2, #27
 8007894:	0fd2      	lsrs	r2, r2, #31
 8007896:	409a      	lsls	r2, r3
 8007898:	4332      	orrs	r2, r6
        GPIOx->OTYPER = temp;
 800789a:	6042      	str	r2, [r0, #4]
      temp = GPIOx->PUPDR;
 800789c:	68c2      	ldr	r2, [r0, #12]
      CLEAR_BIT(temp, GPIO_PUPDR_PUPDR0 << (position * 2U));
 800789e:	4014      	ands	r4, r2
      SET_BIT(temp, (GPIO_Init->Pull) << (position * 2U));
 80078a0:	688a      	ldr	r2, [r1, #8]
 80078a2:	40aa      	lsls	r2, r5
 80078a4:	4314      	orrs	r4, r2
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 80078a6:	9a01      	ldr	r2, [sp, #4]
      GPIOx->PUPDR = temp;
 80078a8:	60c4      	str	r4, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 80078aa:	00d2      	lsls	r2, r2, #3
 80078ac:	d554      	bpl.n	8007958 <HAL_GPIO_Init+0x158>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80078ae:	2601      	movs	r6, #1
 80078b0:	4a2b      	ldr	r2, [pc, #172]	; (8007960 <HAL_GPIO_Init+0x160>)
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 80078b2:	001d      	movs	r5, r3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80078b4:	6994      	ldr	r4, [r2, #24]
 80078b6:	4334      	orrs	r4, r6
 80078b8:	6194      	str	r4, [r2, #24]
 80078ba:	6992      	ldr	r2, [r2, #24]
        temp = SYSCFG->EXTICR[position >> 2];
 80078bc:	089c      	lsrs	r4, r3, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80078be:	4032      	ands	r2, r6
 80078c0:	9207      	str	r2, [sp, #28]
 80078c2:	9a07      	ldr	r2, [sp, #28]
 80078c4:	4a27      	ldr	r2, [pc, #156]	; (8007964 <HAL_GPIO_Init+0x164>)
 80078c6:	00a4      	lsls	r4, r4, #2
 80078c8:	18a4      	adds	r4, r4, r2
        temp = SYSCFG->EXTICR[position >> 2];
 80078ca:	68a2      	ldr	r2, [r4, #8]
 80078cc:	4694      	mov	ip, r2
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 80078ce:	2203      	movs	r2, #3
 80078d0:	4015      	ands	r5, r2
 80078d2:	00ad      	lsls	r5, r5, #2
 80078d4:	320c      	adds	r2, #12
 80078d6:	40aa      	lsls	r2, r5
 80078d8:	4667      	mov	r7, ip
 80078da:	4397      	bics	r7, r2
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80078dc:	2290      	movs	r2, #144	; 0x90
 80078de:	05d2      	lsls	r2, r2, #23
 80078e0:	4694      	mov	ip, r2
 80078e2:	2200      	movs	r2, #0
 80078e4:	4560      	cmp	r0, ip
 80078e6:	d00d      	beq.n	8007904 <HAL_GPIO_Init+0x104>
 80078e8:	4a1f      	ldr	r2, [pc, #124]	; (8007968 <HAL_GPIO_Init+0x168>)
 80078ea:	4694      	mov	ip, r2
 80078ec:	0032      	movs	r2, r6
 80078ee:	4560      	cmp	r0, ip
 80078f0:	d008      	beq.n	8007904 <HAL_GPIO_Init+0x104>
 80078f2:	4e1e      	ldr	r6, [pc, #120]	; (800796c <HAL_GPIO_Init+0x16c>)
 80078f4:	1892      	adds	r2, r2, r2
 80078f6:	42b0      	cmp	r0, r6
 80078f8:	d004      	beq.n	8007904 <HAL_GPIO_Init+0x104>
 80078fa:	4e1d      	ldr	r6, [pc, #116]	; (8007970 <HAL_GPIO_Init+0x170>)
 80078fc:	3201      	adds	r2, #1
 80078fe:	42b0      	cmp	r0, r6
 8007900:	d000      	beq.n	8007904 <HAL_GPIO_Init+0x104>
 8007902:	9a05      	ldr	r2, [sp, #20]
 8007904:	40aa      	lsls	r2, r5
 8007906:	433a      	orrs	r2, r7
        SYSCFG->EXTICR[position >> 2] = temp;
 8007908:	60a2      	str	r2, [r4, #8]
        temp = EXTI->IMR;
 800790a:	4a1a      	ldr	r2, [pc, #104]	; (8007974 <HAL_GPIO_Init+0x174>)
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 800790c:	9c02      	ldr	r4, [sp, #8]
        temp = EXTI->IMR;
 800790e:	6816      	ldr	r6, [r2, #0]
          SET_BIT(temp, iocurrent); 
 8007910:	9d02      	ldr	r5, [sp, #8]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8007912:	9f01      	ldr	r7, [sp, #4]
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 8007914:	43e4      	mvns	r4, r4
          SET_BIT(temp, iocurrent); 
 8007916:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8007918:	03ff      	lsls	r7, r7, #15
 800791a:	d401      	bmi.n	8007920 <HAL_GPIO_Init+0x120>
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 800791c:	0035      	movs	r5, r6
 800791e:	4025      	ands	r5, r4
        EXTI->IMR = temp;
 8007920:	6015      	str	r5, [r2, #0]
        temp = EXTI->EMR;
 8007922:	6856      	ldr	r6, [r2, #4]
          SET_BIT(temp, iocurrent); 
 8007924:	9d02      	ldr	r5, [sp, #8]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8007926:	9f01      	ldr	r7, [sp, #4]
          SET_BIT(temp, iocurrent); 
 8007928:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800792a:	03bf      	lsls	r7, r7, #14
 800792c:	d401      	bmi.n	8007932 <HAL_GPIO_Init+0x132>
        CLEAR_BIT(temp, (uint32_t)iocurrent);      
 800792e:	0035      	movs	r5, r6
 8007930:	4025      	ands	r5, r4
        EXTI->EMR = temp;
 8007932:	6055      	str	r5, [r2, #4]
        temp = EXTI->RTSR;
 8007934:	6896      	ldr	r6, [r2, #8]
          SET_BIT(temp, iocurrent); 
 8007936:	9d02      	ldr	r5, [sp, #8]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8007938:	9f01      	ldr	r7, [sp, #4]
          SET_BIT(temp, iocurrent); 
 800793a:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800793c:	02ff      	lsls	r7, r7, #11
 800793e:	d401      	bmi.n	8007944 <HAL_GPIO_Init+0x144>
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 8007940:	0035      	movs	r5, r6
 8007942:	4025      	ands	r5, r4
        EXTI->RTSR = temp;
 8007944:	6095      	str	r5, [r2, #8]
        temp = EXTI->FTSR;
 8007946:	68d5      	ldr	r5, [r2, #12]
          SET_BIT(temp, iocurrent); 
 8007948:	9e02      	ldr	r6, [sp, #8]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800794a:	9f01      	ldr	r7, [sp, #4]
          SET_BIT(temp, iocurrent); 
 800794c:	432e      	orrs	r6, r5
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800794e:	02bf      	lsls	r7, r7, #10
 8007950:	d401      	bmi.n	8007956 <HAL_GPIO_Init+0x156>
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 8007952:	4025      	ands	r5, r4
 8007954:	002e      	movs	r6, r5
        EXTI->FTSR = temp;
 8007956:	60d6      	str	r6, [r2, #12]
    position++;
 8007958:	3301      	adds	r3, #1
 800795a:	e75c      	b.n	8007816 <HAL_GPIO_Init+0x16>
 800795c:	b7fff000 	.word	0xb7fff000
 8007960:	40021000 	.word	0x40021000
 8007964:	40010000 	.word	0x40010000
 8007968:	48000400 	.word	0x48000400
 800796c:	48000800 	.word	0x48000800
 8007970:	48000c00 	.word	0x48000c00
 8007974:	40010400 	.word	0x40010400

08007978 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8007978:	6900      	ldr	r0, [r0, #16]
 800797a:	4008      	ands	r0, r1
 800797c:	1e41      	subs	r1, r0, #1
 800797e:	4188      	sbcs	r0, r1
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
 8007980:	b2c0      	uxtb	r0, r0
  }
 8007982:	4770      	bx	lr

08007984 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8007984:	2a00      	cmp	r2, #0
 8007986:	d001      	beq.n	800798c <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8007988:	6181      	str	r1, [r0, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 800798a:	4770      	bx	lr
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 800798c:	6281      	str	r1, [r0, #40]	; 0x28
}
 800798e:	e7fc      	b.n	800798a <HAL_GPIO_WritePin+0x6>

08007990 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8007990:	6943      	ldr	r3, [r0, #20]
 8007992:	4059      	eors	r1, r3
 8007994:	6141      	str	r1, [r0, #20]
}
 8007996:	4770      	bx	lr

08007998 <HAL_GPIO_EXTI_IRQHandler>:
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) 
 8007998:	4b04      	ldr	r3, [pc, #16]	; (80079ac <HAL_GPIO_EXTI_IRQHandler+0x14>)
{
 800799a:	b510      	push	{r4, lr}
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) 
 800799c:	695a      	ldr	r2, [r3, #20]
 800799e:	4210      	tst	r0, r2
 80079a0:	d002      	beq.n	80079a8 <HAL_GPIO_EXTI_IRQHandler+0x10>
  { 
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 80079a2:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 80079a4:	f7fe fe74 	bl	8006690 <HAL_GPIO_EXTI_Callback>
  }
}
 80079a8:	bd10      	pop	{r4, pc}
 80079aa:	46c0      	nop			; (mov r8, r8)
 80079ac:	40010400 	.word	0x40010400

080079b0 <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 80079b0:	6803      	ldr	r3, [r0, #0]
 80079b2:	699a      	ldr	r2, [r3, #24]
 80079b4:	0792      	lsls	r2, r2, #30
 80079b6:	d501      	bpl.n	80079bc <I2C_Flush_TXDR+0xc>
  {
     hi2c->Instance->TXDR = 0x00U;
 80079b8:	2200      	movs	r2, #0
 80079ba:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 80079bc:	2201      	movs	r2, #1
 80079be:	6999      	ldr	r1, [r3, #24]
 80079c0:	4211      	tst	r1, r2
 80079c2:	d102      	bne.n	80079ca <I2C_Flush_TXDR+0x1a>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 80079c4:	6999      	ldr	r1, [r3, #24]
 80079c6:	430a      	orrs	r2, r1
 80079c8:	619a      	str	r2, [r3, #24]
  }
}
 80079ca:	4770      	bx	lr

080079cc <I2C_TransferConfig>:
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 80079cc:	6800      	ldr	r0, [r0, #0]
{
 80079ce:	b530      	push	{r4, r5, lr}
  tmpreg = hi2c->Instance->CR2;
 80079d0:	6845      	ldr	r5, [r0, #4]

  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80079d2:	4c06      	ldr	r4, [pc, #24]	; (80079ec <I2C_TransferConfig+0x20>)

  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80079d4:	0412      	lsls	r2, r2, #16
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 80079d6:	402c      	ands	r4, r5
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 80079d8:	9d03      	ldr	r5, [sp, #12]
 80079da:	0589      	lsls	r1, r1, #22
 80079dc:	432b      	orrs	r3, r5
 80079de:	431a      	orrs	r2, r3
 80079e0:	0d89      	lsrs	r1, r1, #22
 80079e2:	430a      	orrs	r2, r1
 80079e4:	4322      	orrs	r2, r4
            (uint32_t)Mode | (uint32_t)Request);

  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;
 80079e6:	6042      	str	r2, [r0, #4]
}
 80079e8:	bd30      	pop	{r4, r5, pc}
 80079ea:	46c0      	nop			; (mov r8, r8)
 80079ec:	fc009800 	.word	0xfc009800

080079f0 <I2C_WaitOnFlagUntilTimeout>:
{
 80079f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80079f2:	0004      	movs	r4, r0
 80079f4:	000e      	movs	r6, r1
 80079f6:	0017      	movs	r7, r2
 80079f8:	001d      	movs	r5, r3
  while(__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80079fa:	6822      	ldr	r2, [r4, #0]
 80079fc:	6993      	ldr	r3, [r2, #24]
 80079fe:	4033      	ands	r3, r6
 8007a00:	1b9b      	subs	r3, r3, r6
 8007a02:	4259      	negs	r1, r3
 8007a04:	414b      	adcs	r3, r1
 8007a06:	42bb      	cmp	r3, r7
 8007a08:	d001      	beq.n	8007a0e <I2C_WaitOnFlagUntilTimeout+0x1e>
  return HAL_OK;
 8007a0a:	2000      	movs	r0, #0
 8007a0c:	e00e      	b.n	8007a2c <I2C_WaitOnFlagUntilTimeout+0x3c>
    if(Timeout != HAL_MAX_DELAY)
 8007a0e:	1c6b      	adds	r3, r5, #1
 8007a10:	d0f4      	beq.n	80079fc <I2C_WaitOnFlagUntilTimeout+0xc>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8007a12:	2d00      	cmp	r5, #0
 8007a14:	d10b      	bne.n	8007a2e <I2C_WaitOnFlagUntilTimeout+0x3e>
        hi2c->State= HAL_I2C_STATE_READY;
 8007a16:	0023      	movs	r3, r4
 8007a18:	2220      	movs	r2, #32
 8007a1a:	3341      	adds	r3, #65	; 0x41
 8007a1c:	701a      	strb	r2, [r3, #0]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007a1e:	0022      	movs	r2, r4
 8007a20:	2300      	movs	r3, #0
        return HAL_TIMEOUT;
 8007a22:	2003      	movs	r0, #3
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007a24:	3242      	adds	r2, #66	; 0x42
        __HAL_UNLOCK(hi2c);
 8007a26:	3440      	adds	r4, #64	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007a28:	7013      	strb	r3, [r2, #0]
        __HAL_UNLOCK(hi2c);
 8007a2a:	7023      	strb	r3, [r4, #0]
}
 8007a2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8007a2e:	f7ff fa9b 	bl	8006f68 <HAL_GetTick>
 8007a32:	9b06      	ldr	r3, [sp, #24]
 8007a34:	1ac0      	subs	r0, r0, r3
 8007a36:	42a8      	cmp	r0, r5
 8007a38:	d9df      	bls.n	80079fa <I2C_WaitOnFlagUntilTimeout+0xa>
 8007a3a:	e7ec      	b.n	8007a16 <I2C_WaitOnFlagUntilTimeout+0x26>

08007a3c <I2C_IsAcknowledgeFailed>:
{
 8007a3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007a3e:	6803      	ldr	r3, [r0, #0]
{
 8007a40:	0004      	movs	r4, r0
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007a42:	6998      	ldr	r0, [r3, #24]
 8007a44:	2310      	movs	r3, #16
{
 8007a46:	000e      	movs	r6, r1
 8007a48:	0017      	movs	r7, r2
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007a4a:	4018      	ands	r0, r3
    while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007a4c:	2520      	movs	r5, #32
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007a4e:	2800      	cmp	r0, #0
 8007a50:	d115      	bne.n	8007a7e <I2C_IsAcknowledgeFailed+0x42>
}
 8007a52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(Timeout != HAL_MAX_DELAY)
 8007a54:	1c72      	adds	r2, r6, #1
 8007a56:	d013      	beq.n	8007a80 <I2C_IsAcknowledgeFailed+0x44>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007a58:	2e00      	cmp	r6, #0
 8007a5a:	d004      	beq.n	8007a66 <I2C_IsAcknowledgeFailed+0x2a>
 8007a5c:	f7ff fa84 	bl	8006f68 <HAL_GetTick>
 8007a60:	1bc0      	subs	r0, r0, r7
 8007a62:	4286      	cmp	r6, r0
 8007a64:	d20b      	bcs.n	8007a7e <I2C_IsAcknowledgeFailed+0x42>
          hi2c->State= HAL_I2C_STATE_READY;
 8007a66:	0023      	movs	r3, r4
 8007a68:	2220      	movs	r2, #32
 8007a6a:	3341      	adds	r3, #65	; 0x41
 8007a6c:	701a      	strb	r2, [r3, #0]
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8007a6e:	0022      	movs	r2, r4
 8007a70:	2300      	movs	r3, #0
 8007a72:	3242      	adds	r2, #66	; 0x42
          __HAL_UNLOCK(hi2c);
 8007a74:	3440      	adds	r4, #64	; 0x40
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8007a76:	7013      	strb	r3, [r2, #0]
          return HAL_TIMEOUT;
 8007a78:	2003      	movs	r0, #3
          __HAL_UNLOCK(hi2c);
 8007a7a:	7023      	strb	r3, [r4, #0]
 8007a7c:	e7e9      	b.n	8007a52 <I2C_IsAcknowledgeFailed+0x16>
    while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007a7e:	6823      	ldr	r3, [r4, #0]
 8007a80:	699a      	ldr	r2, [r3, #24]
 8007a82:	422a      	tst	r2, r5
 8007a84:	d0e6      	beq.n	8007a54 <I2C_IsAcknowledgeFailed+0x18>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007a86:	2210      	movs	r2, #16
    I2C_Flush_TXDR(hi2c);
 8007a88:	0020      	movs	r0, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007a8a:	61da      	str	r2, [r3, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007a8c:	61dd      	str	r5, [r3, #28]
    I2C_Flush_TXDR(hi2c);
 8007a8e:	f7ff ff8f 	bl	80079b0 <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
 8007a92:	6822      	ldr	r2, [r4, #0]
 8007a94:	4908      	ldr	r1, [pc, #32]	; (8007ab8 <I2C_IsAcknowledgeFailed+0x7c>)
 8007a96:	6853      	ldr	r3, [r2, #4]
    return HAL_ERROR;
 8007a98:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
 8007a9a:	400b      	ands	r3, r1
 8007a9c:	6053      	str	r3, [r2, #4]
    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8007a9e:	2304      	movs	r3, #4
 8007aa0:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State= HAL_I2C_STATE_READY;
 8007aa2:	0023      	movs	r3, r4
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8007aa4:	0022      	movs	r2, r4
    hi2c->State= HAL_I2C_STATE_READY;
 8007aa6:	3341      	adds	r3, #65	; 0x41
 8007aa8:	701d      	strb	r5, [r3, #0]
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8007aaa:	2300      	movs	r3, #0
 8007aac:	3242      	adds	r2, #66	; 0x42
    __HAL_UNLOCK(hi2c);
 8007aae:	3440      	adds	r4, #64	; 0x40
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8007ab0:	7013      	strb	r3, [r2, #0]
    __HAL_UNLOCK(hi2c);
 8007ab2:	7023      	strb	r3, [r4, #0]
 8007ab4:	e7cd      	b.n	8007a52 <I2C_IsAcknowledgeFailed+0x16>
 8007ab6:	46c0      	nop			; (mov r8, r8)
 8007ab8:	fe00e800 	.word	0xfe00e800

08007abc <I2C_WaitOnTXISFlagUntilTimeout>:
{
 8007abc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007abe:	0004      	movs	r4, r0
 8007ac0:	000d      	movs	r5, r1
 8007ac2:	0016      	movs	r6, r2
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8007ac4:	2702      	movs	r7, #2
 8007ac6:	6823      	ldr	r3, [r4, #0]
 8007ac8:	699b      	ldr	r3, [r3, #24]
 8007aca:	423b      	tst	r3, r7
 8007acc:	d001      	beq.n	8007ad2 <I2C_WaitOnTXISFlagUntilTimeout+0x16>
  return HAL_OK;
 8007ace:	2000      	movs	r0, #0
 8007ad0:	e018      	b.n	8007b04 <I2C_WaitOnTXISFlagUntilTimeout+0x48>
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8007ad2:	0032      	movs	r2, r6
 8007ad4:	0029      	movs	r1, r5
 8007ad6:	0020      	movs	r0, r4
 8007ad8:	f7ff ffb0 	bl	8007a3c <I2C_IsAcknowledgeFailed>
 8007adc:	2800      	cmp	r0, #0
 8007ade:	d118      	bne.n	8007b12 <I2C_WaitOnTXISFlagUntilTimeout+0x56>
    if(Timeout != HAL_MAX_DELAY)
 8007ae0:	1c6b      	adds	r3, r5, #1
 8007ae2:	d0f0      	beq.n	8007ac6 <I2C_WaitOnTXISFlagUntilTimeout+0xa>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007ae4:	2d00      	cmp	r5, #0
 8007ae6:	d10e      	bne.n	8007b06 <I2C_WaitOnTXISFlagUntilTimeout+0x4a>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007ae8:	2220      	movs	r2, #32
 8007aea:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8007aec:	2003      	movs	r0, #3
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007aee:	4313      	orrs	r3, r2
 8007af0:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State= HAL_I2C_STATE_READY;
 8007af2:	0023      	movs	r3, r4
 8007af4:	3341      	adds	r3, #65	; 0x41
 8007af6:	701a      	strb	r2, [r3, #0]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007af8:	0022      	movs	r2, r4
 8007afa:	2300      	movs	r3, #0
 8007afc:	3242      	adds	r2, #66	; 0x42
        __HAL_UNLOCK(hi2c);
 8007afe:	3440      	adds	r4, #64	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007b00:	7013      	strb	r3, [r2, #0]
        __HAL_UNLOCK(hi2c);
 8007b02:	7023      	strb	r3, [r4, #0]
}
 8007b04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007b06:	f7ff fa2f 	bl	8006f68 <HAL_GetTick>
 8007b0a:	1b80      	subs	r0, r0, r6
 8007b0c:	42a8      	cmp	r0, r5
 8007b0e:	d9da      	bls.n	8007ac6 <I2C_WaitOnTXISFlagUntilTimeout+0xa>
 8007b10:	e7ea      	b.n	8007ae8 <I2C_WaitOnTXISFlagUntilTimeout+0x2c>
      return HAL_ERROR;
 8007b12:	2001      	movs	r0, #1
 8007b14:	e7f6      	b.n	8007b04 <I2C_WaitOnTXISFlagUntilTimeout+0x48>

08007b16 <I2C_RequestMemoryWrite>:
{
 8007b16:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8007b18:	0015      	movs	r5, r2
 8007b1a:	001e      	movs	r6, r3
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8007b1c:	b2da      	uxtb	r2, r3
 8007b1e:	2380      	movs	r3, #128	; 0x80
 8007b20:	019b      	lsls	r3, r3, #6
 8007b22:	9300      	str	r3, [sp, #0]
 8007b24:	2380      	movs	r3, #128	; 0x80
{
 8007b26:	0004      	movs	r4, r0
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8007b28:	045b      	lsls	r3, r3, #17
 8007b2a:	f7ff ff4f 	bl	80079cc <I2C_TransferConfig>
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007b2e:	9a07      	ldr	r2, [sp, #28]
 8007b30:	9906      	ldr	r1, [sp, #24]
 8007b32:	0020      	movs	r0, r4
 8007b34:	f7ff ffc2 	bl	8007abc <I2C_WaitOnTXISFlagUntilTimeout>
 8007b38:	2800      	cmp	r0, #0
 8007b3a:	d005      	beq.n	8007b48 <I2C_RequestMemoryWrite+0x32>
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007b3c:	6c63      	ldr	r3, [r4, #68]	; 0x44
      return HAL_ERROR;
 8007b3e:	2001      	movs	r0, #1
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007b40:	2b04      	cmp	r3, #4
 8007b42:	d000      	beq.n	8007b46 <I2C_RequestMemoryWrite+0x30>
      return HAL_TIMEOUT;
 8007b44:	2003      	movs	r0, #3
}
 8007b46:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 8007b48:	6823      	ldr	r3, [r4, #0]
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8007b4a:	2e01      	cmp	r6, #1
 8007b4c:	d10c      	bne.n	8007b68 <I2C_RequestMemoryWrite+0x52>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007b4e:	b2ed      	uxtb	r5, r5
 8007b50:	629d      	str	r5, [r3, #40]	; 0x28
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 8007b52:	9b07      	ldr	r3, [sp, #28]
 8007b54:	2200      	movs	r2, #0
 8007b56:	9300      	str	r3, [sp, #0]
 8007b58:	2180      	movs	r1, #128	; 0x80
 8007b5a:	9b06      	ldr	r3, [sp, #24]
 8007b5c:	0020      	movs	r0, r4
 8007b5e:	f7ff ff47 	bl	80079f0 <I2C_WaitOnFlagUntilTimeout>
 8007b62:	2800      	cmp	r0, #0
 8007b64:	d0ef      	beq.n	8007b46 <I2C_RequestMemoryWrite+0x30>
 8007b66:	e7ed      	b.n	8007b44 <I2C_RequestMemoryWrite+0x2e>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8007b68:	0a2a      	lsrs	r2, r5, #8
 8007b6a:	629a      	str	r2, [r3, #40]	; 0x28
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007b6c:	9906      	ldr	r1, [sp, #24]
 8007b6e:	9a07      	ldr	r2, [sp, #28]
 8007b70:	0020      	movs	r0, r4
 8007b72:	f7ff ffa3 	bl	8007abc <I2C_WaitOnTXISFlagUntilTimeout>
 8007b76:	2800      	cmp	r0, #0
 8007b78:	d1e0      	bne.n	8007b3c <I2C_RequestMemoryWrite+0x26>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007b7a:	6823      	ldr	r3, [r4, #0]
 8007b7c:	e7e7      	b.n	8007b4e <I2C_RequestMemoryWrite+0x38>

08007b7e <I2C_RequestMemoryRead>:
{
 8007b7e:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8007b80:	0015      	movs	r5, r2
 8007b82:	001e      	movs	r6, r3
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8007b84:	b2da      	uxtb	r2, r3
 8007b86:	2380      	movs	r3, #128	; 0x80
{
 8007b88:	0004      	movs	r4, r0
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8007b8a:	019b      	lsls	r3, r3, #6
 8007b8c:	9300      	str	r3, [sp, #0]
 8007b8e:	2300      	movs	r3, #0
 8007b90:	f7ff ff1c 	bl	80079cc <I2C_TransferConfig>
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007b94:	9a07      	ldr	r2, [sp, #28]
 8007b96:	9906      	ldr	r1, [sp, #24]
 8007b98:	0020      	movs	r0, r4
 8007b9a:	f7ff ff8f 	bl	8007abc <I2C_WaitOnTXISFlagUntilTimeout>
 8007b9e:	2800      	cmp	r0, #0
 8007ba0:	d005      	beq.n	8007bae <I2C_RequestMemoryRead+0x30>
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007ba2:	6c63      	ldr	r3, [r4, #68]	; 0x44
      return HAL_ERROR;
 8007ba4:	2001      	movs	r0, #1
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007ba6:	2b04      	cmp	r3, #4
 8007ba8:	d000      	beq.n	8007bac <I2C_RequestMemoryRead+0x2e>
      return HAL_TIMEOUT;
 8007baa:	2003      	movs	r0, #3
}
 8007bac:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 8007bae:	6823      	ldr	r3, [r4, #0]
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8007bb0:	2e01      	cmp	r6, #1
 8007bb2:	d10c      	bne.n	8007bce <I2C_RequestMemoryRead+0x50>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007bb4:	b2ed      	uxtb	r5, r5
 8007bb6:	629d      	str	r5, [r3, #40]	; 0x28
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 8007bb8:	9b07      	ldr	r3, [sp, #28]
 8007bba:	2200      	movs	r2, #0
 8007bbc:	9300      	str	r3, [sp, #0]
 8007bbe:	2140      	movs	r1, #64	; 0x40
 8007bc0:	9b06      	ldr	r3, [sp, #24]
 8007bc2:	0020      	movs	r0, r4
 8007bc4:	f7ff ff14 	bl	80079f0 <I2C_WaitOnFlagUntilTimeout>
 8007bc8:	2800      	cmp	r0, #0
 8007bca:	d0ef      	beq.n	8007bac <I2C_RequestMemoryRead+0x2e>
 8007bcc:	e7ed      	b.n	8007baa <I2C_RequestMemoryRead+0x2c>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8007bce:	0a2a      	lsrs	r2, r5, #8
 8007bd0:	629a      	str	r2, [r3, #40]	; 0x28
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007bd2:	9906      	ldr	r1, [sp, #24]
 8007bd4:	9a07      	ldr	r2, [sp, #28]
 8007bd6:	0020      	movs	r0, r4
 8007bd8:	f7ff ff70 	bl	8007abc <I2C_WaitOnTXISFlagUntilTimeout>
 8007bdc:	2800      	cmp	r0, #0
 8007bde:	d1e0      	bne.n	8007ba2 <I2C_RequestMemoryRead+0x24>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007be0:	6823      	ldr	r3, [r4, #0]
 8007be2:	e7e7      	b.n	8007bb4 <I2C_RequestMemoryRead+0x36>

08007be4 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 8007be4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007be6:	0004      	movs	r4, r0
 8007be8:	000d      	movs	r5, r1
 8007bea:	0016      	movs	r6, r2
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007bec:	2720      	movs	r7, #32
 8007bee:	6823      	ldr	r3, [r4, #0]
 8007bf0:	699b      	ldr	r3, [r3, #24]
 8007bf2:	423b      	tst	r3, r7
 8007bf4:	d001      	beq.n	8007bfa <I2C_WaitOnSTOPFlagUntilTimeout+0x16>
  return HAL_OK;
 8007bf6:	2000      	movs	r0, #0
 8007bf8:	e016      	b.n	8007c28 <I2C_WaitOnSTOPFlagUntilTimeout+0x44>
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8007bfa:	0032      	movs	r2, r6
 8007bfc:	0029      	movs	r1, r5
 8007bfe:	0020      	movs	r0, r4
 8007c00:	f7ff ff1c 	bl	8007a3c <I2C_IsAcknowledgeFailed>
 8007c04:	2800      	cmp	r0, #0
 8007c06:	d116      	bne.n	8007c36 <I2C_WaitOnSTOPFlagUntilTimeout+0x52>
    if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007c08:	2d00      	cmp	r5, #0
 8007c0a:	d10e      	bne.n	8007c2a <I2C_WaitOnSTOPFlagUntilTimeout+0x46>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007c0c:	2220      	movs	r2, #32
 8007c0e:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8007c10:	2003      	movs	r0, #3
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007c12:	4313      	orrs	r3, r2
 8007c14:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State= HAL_I2C_STATE_READY;
 8007c16:	0023      	movs	r3, r4
 8007c18:	3341      	adds	r3, #65	; 0x41
 8007c1a:	701a      	strb	r2, [r3, #0]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c1c:	0022      	movs	r2, r4
 8007c1e:	2300      	movs	r3, #0
 8007c20:	3242      	adds	r2, #66	; 0x42
        __HAL_UNLOCK(hi2c);
 8007c22:	3440      	adds	r4, #64	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c24:	7013      	strb	r3, [r2, #0]
        __HAL_UNLOCK(hi2c);
 8007c26:	7023      	strb	r3, [r4, #0]
}
 8007c28:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007c2a:	f7ff f99d 	bl	8006f68 <HAL_GetTick>
 8007c2e:	1b80      	subs	r0, r0, r6
 8007c30:	42a8      	cmp	r0, r5
 8007c32:	d9dc      	bls.n	8007bee <I2C_WaitOnSTOPFlagUntilTimeout+0xa>
 8007c34:	e7ea      	b.n	8007c0c <I2C_WaitOnSTOPFlagUntilTimeout+0x28>
      return HAL_ERROR;
 8007c36:	2001      	movs	r0, #1
 8007c38:	e7f6      	b.n	8007c28 <I2C_WaitOnSTOPFlagUntilTimeout+0x44>
	...

08007c3c <HAL_I2C_Init>:
{
 8007c3c:	b570      	push	{r4, r5, r6, lr}
 8007c3e:	0004      	movs	r4, r0
    return HAL_ERROR;
 8007c40:	2001      	movs	r0, #1
  if(hi2c == NULL)
 8007c42:	2c00      	cmp	r4, #0
 8007c44:	d03f      	beq.n	8007cc6 <HAL_I2C_Init+0x8a>
  if(hi2c->State == HAL_I2C_STATE_RESET)
 8007c46:	0025      	movs	r5, r4
 8007c48:	3541      	adds	r5, #65	; 0x41
 8007c4a:	782b      	ldrb	r3, [r5, #0]
 8007c4c:	b2db      	uxtb	r3, r3
 8007c4e:	2b00      	cmp	r3, #0
 8007c50:	d105      	bne.n	8007c5e <HAL_I2C_Init+0x22>
    hi2c->Lock = HAL_UNLOCKED;
 8007c52:	0022      	movs	r2, r4
 8007c54:	3240      	adds	r2, #64	; 0x40
 8007c56:	7013      	strb	r3, [r2, #0]
    HAL_I2C_MspInit(hi2c);
 8007c58:	0020      	movs	r0, r4
 8007c5a:	f7fe f985 	bl	8005f68 <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8007c5e:	2324      	movs	r3, #36	; 0x24
  __HAL_I2C_DISABLE(hi2c);
 8007c60:	2101      	movs	r1, #1
  hi2c->State = HAL_I2C_STATE_BUSY;
 8007c62:	702b      	strb	r3, [r5, #0]
  __HAL_I2C_DISABLE(hi2c);
 8007c64:	6823      	ldr	r3, [r4, #0]
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8007c66:	68e0      	ldr	r0, [r4, #12]
  __HAL_I2C_DISABLE(hi2c);
 8007c68:	681a      	ldr	r2, [r3, #0]
 8007c6a:	68a6      	ldr	r6, [r4, #8]
 8007c6c:	438a      	bics	r2, r1
 8007c6e:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8007c70:	6861      	ldr	r1, [r4, #4]
 8007c72:	4a1a      	ldr	r2, [pc, #104]	; (8007cdc <HAL_I2C_Init+0xa0>)
 8007c74:	400a      	ands	r2, r1
 8007c76:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8007c78:	6899      	ldr	r1, [r3, #8]
 8007c7a:	4a19      	ldr	r2, [pc, #100]	; (8007ce0 <HAL_I2C_Init+0xa4>)
 8007c7c:	4011      	ands	r1, r2
 8007c7e:	6099      	str	r1, [r3, #8]
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8007c80:	2801      	cmp	r0, #1
 8007c82:	d121      	bne.n	8007cc8 <HAL_I2C_Init+0x8c>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8007c84:	2180      	movs	r1, #128	; 0x80
 8007c86:	0209      	lsls	r1, r1, #8
 8007c88:	4331      	orrs	r1, r6
 8007c8a:	6099      	str	r1, [r3, #8]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8007c8c:	6858      	ldr	r0, [r3, #4]
 8007c8e:	4915      	ldr	r1, [pc, #84]	; (8007ce4 <HAL_I2C_Init+0xa8>)
 8007c90:	4301      	orrs	r1, r0
 8007c92:	6059      	str	r1, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8007c94:	68d9      	ldr	r1, [r3, #12]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007c96:	2000      	movs	r0, #0
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8007c98:	400a      	ands	r2, r1
 8007c9a:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8007c9c:	6961      	ldr	r1, [r4, #20]
 8007c9e:	6922      	ldr	r2, [r4, #16]
 8007ca0:	430a      	orrs	r2, r1
 8007ca2:	69a1      	ldr	r1, [r4, #24]
 8007ca4:	0209      	lsls	r1, r1, #8
 8007ca6:	430a      	orrs	r2, r1
 8007ca8:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8007caa:	6a21      	ldr	r1, [r4, #32]
 8007cac:	69e2      	ldr	r2, [r4, #28]
 8007cae:	430a      	orrs	r2, r1
 8007cb0:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 8007cb2:	2201      	movs	r2, #1
 8007cb4:	6819      	ldr	r1, [r3, #0]
 8007cb6:	430a      	orrs	r2, r1
 8007cb8:	601a      	str	r2, [r3, #0]
  hi2c->State = HAL_I2C_STATE_READY;
 8007cba:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007cbc:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8007cbe:	702b      	strb	r3, [r5, #0]
  hi2c->PreviousState = I2C_STATE_NONE;
 8007cc0:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007cc2:	3442      	adds	r4, #66	; 0x42
 8007cc4:	7020      	strb	r0, [r4, #0]
}
 8007cc6:	bd70      	pop	{r4, r5, r6, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8007cc8:	2184      	movs	r1, #132	; 0x84
 8007cca:	0209      	lsls	r1, r1, #8
 8007ccc:	4331      	orrs	r1, r6
 8007cce:	6099      	str	r1, [r3, #8]
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8007cd0:	2802      	cmp	r0, #2
 8007cd2:	d1db      	bne.n	8007c8c <HAL_I2C_Init+0x50>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8007cd4:	2180      	movs	r1, #128	; 0x80
 8007cd6:	0109      	lsls	r1, r1, #4
 8007cd8:	6059      	str	r1, [r3, #4]
 8007cda:	e7d7      	b.n	8007c8c <HAL_I2C_Init+0x50>
 8007cdc:	f0ffffff 	.word	0xf0ffffff
 8007ce0:	ffff7fff 	.word	0xffff7fff
 8007ce4:	02008000 	.word	0x02008000

08007ce8 <HAL_I2C_Mem_Write>:
{
 8007ce8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007cea:	b089      	sub	sp, #36	; 0x24
 8007cec:	9307      	str	r3, [sp, #28]
 8007cee:	ab0e      	add	r3, sp, #56	; 0x38
 8007cf0:	9206      	str	r2, [sp, #24]
 8007cf2:	cb04      	ldmia	r3!, {r2}
 8007cf4:	0004      	movs	r4, r0
 8007cf6:	881b      	ldrh	r3, [r3, #0]
 8007cf8:	9203      	str	r2, [sp, #12]
 8007cfa:	9304      	str	r3, [sp, #16]
  if(hi2c->State == HAL_I2C_STATE_READY)
 8007cfc:	0003      	movs	r3, r0
 8007cfe:	3341      	adds	r3, #65	; 0x41
 8007d00:	9305      	str	r3, [sp, #20]
 8007d02:	781b      	ldrb	r3, [r3, #0]
{
 8007d04:	000d      	movs	r5, r1
    return HAL_BUSY;
 8007d06:	2002      	movs	r0, #2
  if(hi2c->State == HAL_I2C_STATE_READY)
 8007d08:	2b20      	cmp	r3, #32
 8007d0a:	d102      	bne.n	8007d12 <HAL_I2C_Mem_Write+0x2a>
    if((pData == NULL) || (Size == 0U))
 8007d0c:	2a00      	cmp	r2, #0
 8007d0e:	d102      	bne.n	8007d16 <HAL_I2C_Mem_Write+0x2e>
        return HAL_ERROR;
 8007d10:	2001      	movs	r0, #1
}
 8007d12:	b009      	add	sp, #36	; 0x24
 8007d14:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((pData == NULL) || (Size == 0U))
 8007d16:	9b04      	ldr	r3, [sp, #16]
 8007d18:	2b00      	cmp	r3, #0
 8007d1a:	d0f9      	beq.n	8007d10 <HAL_I2C_Mem_Write+0x28>
    __HAL_LOCK(hi2c);
 8007d1c:	0027      	movs	r7, r4
 8007d1e:	3740      	adds	r7, #64	; 0x40
 8007d20:	783b      	ldrb	r3, [r7, #0]
 8007d22:	2b01      	cmp	r3, #1
 8007d24:	d0f5      	beq.n	8007d12 <HAL_I2C_Mem_Write+0x2a>
 8007d26:	2301      	movs	r3, #1
 8007d28:	703b      	strb	r3, [r7, #0]
    tickstart = HAL_GetTick();
 8007d2a:	f7ff f91d 	bl	8006f68 <HAL_GetTick>
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8007d2e:	2180      	movs	r1, #128	; 0x80
    tickstart = HAL_GetTick();
 8007d30:	9002      	str	r0, [sp, #8]
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8007d32:	9000      	str	r0, [sp, #0]
 8007d34:	2319      	movs	r3, #25
 8007d36:	2201      	movs	r2, #1
 8007d38:	0209      	lsls	r1, r1, #8
 8007d3a:	0020      	movs	r0, r4
 8007d3c:	f7ff fe58 	bl	80079f0 <I2C_WaitOnFlagUntilTimeout>
 8007d40:	1e06      	subs	r6, r0, #0
 8007d42:	d11e      	bne.n	8007d82 <HAL_I2C_Mem_Write+0x9a>
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8007d44:	2321      	movs	r3, #33	; 0x21
 8007d46:	9a05      	ldr	r2, [sp, #20]
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8007d48:	0029      	movs	r1, r5
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8007d4a:	7013      	strb	r3, [r2, #0]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8007d4c:	0023      	movs	r3, r4
 8007d4e:	3342      	adds	r3, #66	; 0x42
 8007d50:	9305      	str	r3, [sp, #20]
 8007d52:	2340      	movs	r3, #64	; 0x40
 8007d54:	9a05      	ldr	r2, [sp, #20]
 8007d56:	7013      	strb	r3, [r2, #0]
    hi2c->pBuffPtr  = pData;
 8007d58:	9b03      	ldr	r3, [sp, #12]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007d5a:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->pBuffPtr  = pData;
 8007d5c:	6263      	str	r3, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
 8007d5e:	9b04      	ldr	r3, [sp, #16]
    hi2c->XferISR   = NULL;
 8007d60:	6360      	str	r0, [r4, #52]	; 0x34
    hi2c->XferCount = Size;
 8007d62:	8563      	strh	r3, [r4, #42]	; 0x2a
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8007d64:	9b02      	ldr	r3, [sp, #8]
 8007d66:	9a06      	ldr	r2, [sp, #24]
 8007d68:	9301      	str	r3, [sp, #4]
 8007d6a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007d6c:	0020      	movs	r0, r4
 8007d6e:	9300      	str	r3, [sp, #0]
 8007d70:	9b07      	ldr	r3, [sp, #28]
 8007d72:	f7ff fed0 	bl	8007b16 <I2C_RequestMemoryWrite>
 8007d76:	2800      	cmp	r0, #0
 8007d78:	d005      	beq.n	8007d86 <HAL_I2C_Mem_Write+0x9e>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007d7a:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8007d7c:	703e      	strb	r6, [r7, #0]
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007d7e:	2b04      	cmp	r3, #4
 8007d80:	d0c6      	beq.n	8007d10 <HAL_I2C_Mem_Write+0x28>
          return HAL_TIMEOUT;
 8007d82:	2003      	movs	r0, #3
 8007d84:	e7c5      	b.n	8007d12 <HAL_I2C_Mem_Write+0x2a>
    if(hi2c->XferCount > MAX_NBYTE_SIZE)
 8007d86:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007d88:	2bff      	cmp	r3, #255	; 0xff
 8007d8a:	d914      	bls.n	8007db6 <HAL_I2C_Mem_Write+0xce>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8007d8c:	22ff      	movs	r2, #255	; 0xff
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007d8e:	2380      	movs	r3, #128	; 0x80
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8007d90:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007d92:	045b      	lsls	r3, r3, #17
 8007d94:	9000      	str	r0, [sp, #0]
 8007d96:	0029      	movs	r1, r5
 8007d98:	0020      	movs	r0, r4
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007d9a:	2680      	movs	r6, #128	; 0x80
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007d9c:	f7ff fe16 	bl	80079cc <I2C_TransferConfig>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8007da0:	27ff      	movs	r7, #255	; 0xff
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007da2:	04b6      	lsls	r6, r6, #18
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8007da4:	9a02      	ldr	r2, [sp, #8]
 8007da6:	9910      	ldr	r1, [sp, #64]	; 0x40
 8007da8:	0020      	movs	r0, r4
 8007daa:	f7ff fe87 	bl	8007abc <I2C_WaitOnTXISFlagUntilTimeout>
 8007dae:	2800      	cmp	r0, #0
 8007db0:	d009      	beq.n	8007dc6 <HAL_I2C_Mem_Write+0xde>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007db2:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007db4:	e7e3      	b.n	8007d7e <HAL_I2C_Mem_Write+0x96>
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007db6:	2380      	movs	r3, #128	; 0x80
      hi2c->XferSize = hi2c->XferCount;
 8007db8:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007dba:	049b      	lsls	r3, r3, #18
      hi2c->XferSize = hi2c->XferCount;
 8007dbc:	b292      	uxth	r2, r2
 8007dbe:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007dc0:	b2d2      	uxtb	r2, r2
 8007dc2:	9000      	str	r0, [sp, #0]
 8007dc4:	e7e7      	b.n	8007d96 <HAL_I2C_Mem_Write+0xae>
      hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
 8007dc6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007dc8:	1c5a      	adds	r2, r3, #1
 8007dca:	6262      	str	r2, [r4, #36]	; 0x24
 8007dcc:	781b      	ldrb	r3, [r3, #0]
 8007dce:	6822      	ldr	r2, [r4, #0]
 8007dd0:	6293      	str	r3, [r2, #40]	; 0x28
      hi2c->XferCount--;
 8007dd2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007dd4:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007dd6:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 8007dd8:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 8007dda:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8007ddc:	b292      	uxth	r2, r2
      hi2c->XferCount--;
 8007dde:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007de0:	8522      	strh	r2, [r4, #40]	; 0x28
      if((hi2c->XferSize == 0U) && (hi2c->XferCount!=0U))
 8007de2:	2a00      	cmp	r2, #0
 8007de4:	d117      	bne.n	8007e16 <HAL_I2C_Mem_Write+0x12e>
 8007de6:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007de8:	2b00      	cmp	r3, #0
 8007dea:	d014      	beq.n	8007e16 <HAL_I2C_Mem_Write+0x12e>
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8007dec:	9b02      	ldr	r3, [sp, #8]
 8007dee:	2180      	movs	r1, #128	; 0x80
 8007df0:	9300      	str	r3, [sp, #0]
 8007df2:	0020      	movs	r0, r4
 8007df4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007df6:	f7ff fdfb 	bl	80079f0 <I2C_WaitOnFlagUntilTimeout>
 8007dfa:	2800      	cmp	r0, #0
 8007dfc:	d1c1      	bne.n	8007d82 <HAL_I2C_Mem_Write+0x9a>
        if(hi2c->XferCount > MAX_NBYTE_SIZE)
 8007dfe:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007e00:	2bff      	cmp	r3, #255	; 0xff
 8007e02:	d921      	bls.n	8007e48 <HAL_I2C_Mem_Write+0x160>
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007e04:	2380      	movs	r3, #128	; 0x80
 8007e06:	22ff      	movs	r2, #255	; 0xff
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8007e08:	8527      	strh	r7, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007e0a:	045b      	lsls	r3, r3, #17
 8007e0c:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007e0e:	0029      	movs	r1, r5
 8007e10:	0020      	movs	r0, r4
 8007e12:	f7ff fddb 	bl	80079cc <I2C_TransferConfig>
    }while(hi2c->XferCount > 0U);
 8007e16:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007e18:	2b00      	cmp	r3, #0
 8007e1a:	d1c3      	bne.n	8007da4 <HAL_I2C_Mem_Write+0xbc>
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8007e1c:	9a02      	ldr	r2, [sp, #8]
 8007e1e:	9910      	ldr	r1, [sp, #64]	; 0x40
 8007e20:	0020      	movs	r0, r4
 8007e22:	f7ff fedf 	bl	8007be4 <I2C_WaitOnSTOPFlagUntilTimeout>
 8007e26:	2800      	cmp	r0, #0
 8007e28:	d1c3      	bne.n	8007db2 <HAL_I2C_Mem_Write+0xca>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007e2a:	2120      	movs	r1, #32
 8007e2c:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
 8007e2e:	4d0a      	ldr	r5, [pc, #40]	; (8007e58 <HAL_I2C_Mem_Write+0x170>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007e30:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8007e32:	685a      	ldr	r2, [r3, #4]
 8007e34:	402a      	ands	r2, r5
 8007e36:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8007e38:	0023      	movs	r3, r4
 8007e3a:	3341      	adds	r3, #65	; 0x41
 8007e3c:	7019      	strb	r1, [r3, #0]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8007e3e:	9b05      	ldr	r3, [sp, #20]
    __HAL_UNLOCK(hi2c);
 8007e40:	3440      	adds	r4, #64	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8007e42:	7018      	strb	r0, [r3, #0]
    __HAL_UNLOCK(hi2c);
 8007e44:	7020      	strb	r0, [r4, #0]
    return HAL_OK;
 8007e46:	e764      	b.n	8007d12 <HAL_I2C_Mem_Write+0x2a>
          hi2c->XferSize = hi2c->XferCount;
 8007e48:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007e4a:	0033      	movs	r3, r6
          hi2c->XferSize = hi2c->XferCount;
 8007e4c:	b292      	uxth	r2, r2
 8007e4e:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007e50:	b2d2      	uxtb	r2, r2
 8007e52:	9000      	str	r0, [sp, #0]
 8007e54:	e7db      	b.n	8007e0e <HAL_I2C_Mem_Write+0x126>
 8007e56:	46c0      	nop			; (mov r8, r8)
 8007e58:	fe00e800 	.word	0xfe00e800

08007e5c <HAL_I2C_Mem_Read>:
{
 8007e5c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007e5e:	b089      	sub	sp, #36	; 0x24
 8007e60:	9307      	str	r3, [sp, #28]
 8007e62:	ab0e      	add	r3, sp, #56	; 0x38
 8007e64:	9206      	str	r2, [sp, #24]
 8007e66:	cb04      	ldmia	r3!, {r2}
 8007e68:	0004      	movs	r4, r0
 8007e6a:	881b      	ldrh	r3, [r3, #0]
 8007e6c:	9203      	str	r2, [sp, #12]
 8007e6e:	9304      	str	r3, [sp, #16]
  if(hi2c->State == HAL_I2C_STATE_READY)
 8007e70:	0003      	movs	r3, r0
 8007e72:	3341      	adds	r3, #65	; 0x41
 8007e74:	9305      	str	r3, [sp, #20]
 8007e76:	781b      	ldrb	r3, [r3, #0]
{
 8007e78:	000d      	movs	r5, r1
    return HAL_BUSY;
 8007e7a:	2002      	movs	r0, #2
  if(hi2c->State == HAL_I2C_STATE_READY)
 8007e7c:	2b20      	cmp	r3, #32
 8007e7e:	d102      	bne.n	8007e86 <HAL_I2C_Mem_Read+0x2a>
    if((pData == NULL) || (Size == 0U))
 8007e80:	2a00      	cmp	r2, #0
 8007e82:	d102      	bne.n	8007e8a <HAL_I2C_Mem_Read+0x2e>
        return HAL_ERROR;
 8007e84:	2001      	movs	r0, #1
}
 8007e86:	b009      	add	sp, #36	; 0x24
 8007e88:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((pData == NULL) || (Size == 0U))
 8007e8a:	9b04      	ldr	r3, [sp, #16]
 8007e8c:	2b00      	cmp	r3, #0
 8007e8e:	d0f9      	beq.n	8007e84 <HAL_I2C_Mem_Read+0x28>
    __HAL_LOCK(hi2c);
 8007e90:	0027      	movs	r7, r4
 8007e92:	3740      	adds	r7, #64	; 0x40
 8007e94:	783b      	ldrb	r3, [r7, #0]
 8007e96:	2b01      	cmp	r3, #1
 8007e98:	d0f5      	beq.n	8007e86 <HAL_I2C_Mem_Read+0x2a>
 8007e9a:	2301      	movs	r3, #1
 8007e9c:	703b      	strb	r3, [r7, #0]
    tickstart = HAL_GetTick();
 8007e9e:	f7ff f863 	bl	8006f68 <HAL_GetTick>
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8007ea2:	2180      	movs	r1, #128	; 0x80
    tickstart = HAL_GetTick();
 8007ea4:	9002      	str	r0, [sp, #8]
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8007ea6:	9000      	str	r0, [sp, #0]
 8007ea8:	2319      	movs	r3, #25
 8007eaa:	2201      	movs	r2, #1
 8007eac:	0209      	lsls	r1, r1, #8
 8007eae:	0020      	movs	r0, r4
 8007eb0:	f7ff fd9e 	bl	80079f0 <I2C_WaitOnFlagUntilTimeout>
 8007eb4:	1e06      	subs	r6, r0, #0
 8007eb6:	d11e      	bne.n	8007ef6 <HAL_I2C_Mem_Read+0x9a>
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8007eb8:	2322      	movs	r3, #34	; 0x22
 8007eba:	9a05      	ldr	r2, [sp, #20]
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8007ebc:	0029      	movs	r1, r5
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8007ebe:	7013      	strb	r3, [r2, #0]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8007ec0:	0023      	movs	r3, r4
 8007ec2:	3342      	adds	r3, #66	; 0x42
 8007ec4:	9305      	str	r3, [sp, #20]
 8007ec6:	2340      	movs	r3, #64	; 0x40
 8007ec8:	9a05      	ldr	r2, [sp, #20]
 8007eca:	7013      	strb	r3, [r2, #0]
    hi2c->pBuffPtr  = pData;
 8007ecc:	9b03      	ldr	r3, [sp, #12]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007ece:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->pBuffPtr  = pData;
 8007ed0:	6263      	str	r3, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
 8007ed2:	9b04      	ldr	r3, [sp, #16]
    hi2c->XferISR   = NULL;
 8007ed4:	6360      	str	r0, [r4, #52]	; 0x34
    hi2c->XferCount = Size;
 8007ed6:	8563      	strh	r3, [r4, #42]	; 0x2a
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8007ed8:	9b02      	ldr	r3, [sp, #8]
 8007eda:	9a06      	ldr	r2, [sp, #24]
 8007edc:	9301      	str	r3, [sp, #4]
 8007ede:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007ee0:	0020      	movs	r0, r4
 8007ee2:	9300      	str	r3, [sp, #0]
 8007ee4:	9b07      	ldr	r3, [sp, #28]
 8007ee6:	f7ff fe4a 	bl	8007b7e <I2C_RequestMemoryRead>
 8007eea:	2800      	cmp	r0, #0
 8007eec:	d005      	beq.n	8007efa <HAL_I2C_Mem_Read+0x9e>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007eee:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8007ef0:	703e      	strb	r6, [r7, #0]
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007ef2:	2b04      	cmp	r3, #4
 8007ef4:	d0c6      	beq.n	8007e84 <HAL_I2C_Mem_Read+0x28>
        return HAL_TIMEOUT;
 8007ef6:	2003      	movs	r0, #3
 8007ef8:	e7c5      	b.n	8007e86 <HAL_I2C_Mem_Read+0x2a>
 8007efa:	2390      	movs	r3, #144	; 0x90
    if(hi2c->XferCount > MAX_NBYTE_SIZE)
 8007efc:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8007efe:	019b      	lsls	r3, r3, #6
 8007f00:	2aff      	cmp	r2, #255	; 0xff
 8007f02:	d949      	bls.n	8007f98 <HAL_I2C_Mem_Read+0x13c>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8007f04:	22ff      	movs	r2, #255	; 0xff
 8007f06:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 8007f08:	9300      	str	r3, [sp, #0]
 8007f0a:	2380      	movs	r3, #128	; 0x80
 8007f0c:	045b      	lsls	r3, r3, #17
 8007f0e:	0029      	movs	r1, r5
 8007f10:	0020      	movs	r0, r4
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f12:	2680      	movs	r6, #128	; 0x80
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 8007f14:	f7ff fd5a 	bl	80079cc <I2C_TransferConfig>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8007f18:	27ff      	movs	r7, #255	; 0xff
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f1a:	04b6      	lsls	r6, r6, #18
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 8007f1c:	9b02      	ldr	r3, [sp, #8]
 8007f1e:	2200      	movs	r2, #0
 8007f20:	9300      	str	r3, [sp, #0]
 8007f22:	2104      	movs	r1, #4
 8007f24:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007f26:	0020      	movs	r0, r4
 8007f28:	f7ff fd62 	bl	80079f0 <I2C_WaitOnFlagUntilTimeout>
 8007f2c:	2800      	cmp	r0, #0
 8007f2e:	d1e2      	bne.n	8007ef6 <HAL_I2C_Mem_Read+0x9a>
      (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
 8007f30:	6823      	ldr	r3, [r4, #0]
 8007f32:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8007f34:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007f36:	1c59      	adds	r1, r3, #1
 8007f38:	6261      	str	r1, [r4, #36]	; 0x24
 8007f3a:	701a      	strb	r2, [r3, #0]
      hi2c->XferSize--;
 8007f3c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007f3e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007f40:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 8007f42:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 8007f44:	b292      	uxth	r2, r2
      hi2c->XferCount--;
 8007f46:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8007f48:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007f4a:	8563      	strh	r3, [r4, #42]	; 0x2a
      if((hi2c->XferSize == 0U) && (hi2c->XferCount != 0U))
 8007f4c:	2a00      	cmp	r2, #0
 8007f4e:	d117      	bne.n	8007f80 <HAL_I2C_Mem_Read+0x124>
 8007f50:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007f52:	2b00      	cmp	r3, #0
 8007f54:	d014      	beq.n	8007f80 <HAL_I2C_Mem_Read+0x124>
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8007f56:	9b02      	ldr	r3, [sp, #8]
 8007f58:	2180      	movs	r1, #128	; 0x80
 8007f5a:	9300      	str	r3, [sp, #0]
 8007f5c:	0020      	movs	r0, r4
 8007f5e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007f60:	f7ff fd46 	bl	80079f0 <I2C_WaitOnFlagUntilTimeout>
 8007f64:	2800      	cmp	r0, #0
 8007f66:	d1c6      	bne.n	8007ef6 <HAL_I2C_Mem_Read+0x9a>
        if(hi2c->XferCount > MAX_NBYTE_SIZE)
 8007f68:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007f6a:	2bff      	cmp	r3, #255	; 0xff
 8007f6c:	d91c      	bls.n	8007fa8 <HAL_I2C_Mem_Read+0x14c>
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007f6e:	2380      	movs	r3, #128	; 0x80
 8007f70:	22ff      	movs	r2, #255	; 0xff
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8007f72:	8527      	strh	r7, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007f74:	045b      	lsls	r3, r3, #17
 8007f76:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f78:	0029      	movs	r1, r5
 8007f7a:	0020      	movs	r0, r4
 8007f7c:	f7ff fd26 	bl	80079cc <I2C_TransferConfig>
    }while(hi2c->XferCount > 0U);
 8007f80:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007f82:	2b00      	cmp	r3, #0
 8007f84:	d1ca      	bne.n	8007f1c <HAL_I2C_Mem_Read+0xc0>
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8007f86:	9a02      	ldr	r2, [sp, #8]
 8007f88:	9910      	ldr	r1, [sp, #64]	; 0x40
 8007f8a:	0020      	movs	r0, r4
 8007f8c:	f7ff fe2a 	bl	8007be4 <I2C_WaitOnSTOPFlagUntilTimeout>
 8007f90:	2800      	cmp	r0, #0
 8007f92:	d010      	beq.n	8007fb6 <HAL_I2C_Mem_Read+0x15a>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007f94:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007f96:	e7ac      	b.n	8007ef2 <HAL_I2C_Mem_Read+0x96>
      hi2c->XferSize = hi2c->XferCount;
 8007f98:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8007f9a:	b292      	uxth	r2, r2
 8007f9c:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 8007f9e:	9300      	str	r3, [sp, #0]
 8007fa0:	2380      	movs	r3, #128	; 0x80
 8007fa2:	b2d2      	uxtb	r2, r2
 8007fa4:	049b      	lsls	r3, r3, #18
 8007fa6:	e7b2      	b.n	8007f0e <HAL_I2C_Mem_Read+0xb2>
          hi2c->XferSize = hi2c->XferCount;
 8007fa8:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007faa:	0033      	movs	r3, r6
          hi2c->XferSize = hi2c->XferCount;
 8007fac:	b292      	uxth	r2, r2
 8007fae:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007fb0:	b2d2      	uxtb	r2, r2
 8007fb2:	9000      	str	r0, [sp, #0]
 8007fb4:	e7e0      	b.n	8007f78 <HAL_I2C_Mem_Read+0x11c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007fb6:	2120      	movs	r1, #32
 8007fb8:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
 8007fba:	4d06      	ldr	r5, [pc, #24]	; (8007fd4 <HAL_I2C_Mem_Read+0x178>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007fbc:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8007fbe:	685a      	ldr	r2, [r3, #4]
 8007fc0:	402a      	ands	r2, r5
 8007fc2:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8007fc4:	0023      	movs	r3, r4
 8007fc6:	3341      	adds	r3, #65	; 0x41
 8007fc8:	7019      	strb	r1, [r3, #0]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8007fca:	9b05      	ldr	r3, [sp, #20]
    __HAL_UNLOCK(hi2c);
 8007fcc:	3440      	adds	r4, #64	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8007fce:	7018      	strb	r0, [r3, #0]
    __HAL_UNLOCK(hi2c);
 8007fd0:	7020      	strb	r0, [r4, #0]
    return HAL_OK;
 8007fd2:	e758      	b.n	8007e86 <HAL_I2C_Mem_Read+0x2a>
 8007fd4:	fe00e800 	.word	0xfe00e800

08007fd8 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 8007fd8:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if(hi2c->State == HAL_I2C_STATE_READY)
 8007fda:	0004      	movs	r4, r0
 8007fdc:	3441      	adds	r4, #65	; 0x41
 8007fde:	7822      	ldrb	r2, [r4, #0]
{
 8007fe0:	0003      	movs	r3, r0
  if(hi2c->State == HAL_I2C_STATE_READY)
 8007fe2:	b2d2      	uxtb	r2, r2

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8007fe4:	2002      	movs	r0, #2
  if(hi2c->State == HAL_I2C_STATE_READY)
 8007fe6:	2a20      	cmp	r2, #32
 8007fe8:	d118      	bne.n	800801c <HAL_I2CEx_ConfigAnalogFilter+0x44>
    __HAL_LOCK(hi2c);
 8007fea:	001d      	movs	r5, r3
 8007fec:	3540      	adds	r5, #64	; 0x40
 8007fee:	782e      	ldrb	r6, [r5, #0]
 8007ff0:	2e01      	cmp	r6, #1
 8007ff2:	d013      	beq.n	800801c <HAL_I2CEx_ConfigAnalogFilter+0x44>
    __HAL_I2C_DISABLE(hi2c);
 8007ff4:	681b      	ldr	r3, [r3, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 8007ff6:	3022      	adds	r0, #34	; 0x22
 8007ff8:	7020      	strb	r0, [r4, #0]
    __HAL_I2C_DISABLE(hi2c);
 8007ffa:	681e      	ldr	r6, [r3, #0]
 8007ffc:	3823      	subs	r0, #35	; 0x23
 8007ffe:	4386      	bics	r6, r0
 8008000:	601e      	str	r6, [r3, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 8008002:	681e      	ldr	r6, [r3, #0]
 8008004:	4f06      	ldr	r7, [pc, #24]	; (8008020 <HAL_I2CEx_ConfigAnalogFilter+0x48>)
 8008006:	403e      	ands	r6, r7
 8008008:	601e      	str	r6, [r3, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
 800800a:	681e      	ldr	r6, [r3, #0]
 800800c:	4331      	orrs	r1, r6
 800800e:	6019      	str	r1, [r3, #0]
    __HAL_I2C_ENABLE(hi2c);
 8008010:	6819      	ldr	r1, [r3, #0]
 8008012:	4308      	orrs	r0, r1
 8008014:	6018      	str	r0, [r3, #0]
    __HAL_UNLOCK(hi2c);
 8008016:	2000      	movs	r0, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8008018:	7022      	strb	r2, [r4, #0]
    __HAL_UNLOCK(hi2c);
 800801a:	7028      	strb	r0, [r5, #0]
  }
}
 800801c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800801e:	46c0      	nop			; (mov r8, r8)
 8008020:	ffffefff 	.word	0xffffefff

08008024 <HAL_RCC_GetHCLKFreq>:
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
 8008024:	4b01      	ldr	r3, [pc, #4]	; (800802c <HAL_RCC_GetHCLKFreq+0x8>)
 8008026:	6818      	ldr	r0, [r3, #0]
}
 8008028:	4770      	bx	lr
 800802a:	46c0      	nop			; (mov r8, r8)
 800802c:	20000054 	.word	0x20000054

08008030 <SPI_WaitFifoStateUntilTimeout.part.1>:
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8008030:	21e0      	movs	r1, #224	; 0xe0
 8008032:	6803      	ldr	r3, [r0, #0]
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State,
 8008034:	b510      	push	{r4, lr}
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8008036:	685a      	ldr	r2, [r3, #4]
 8008038:	438a      	bics	r2, r1
 800803a:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800803c:	2282      	movs	r2, #130	; 0x82
 800803e:	6841      	ldr	r1, [r0, #4]
 8008040:	0052      	lsls	r2, r2, #1
 8008042:	4291      	cmp	r1, r2
 8008044:	d10c      	bne.n	8008060 <SPI_WaitFifoStateUntilTimeout.part.1+0x30>
 8008046:	2180      	movs	r1, #128	; 0x80
 8008048:	6882      	ldr	r2, [r0, #8]
 800804a:	0209      	lsls	r1, r1, #8
 800804c:	428a      	cmp	r2, r1
 800804e:	d003      	beq.n	8008058 <SPI_WaitFifoStateUntilTimeout.part.1+0x28>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8008050:	2180      	movs	r1, #128	; 0x80
 8008052:	00c9      	lsls	r1, r1, #3
 8008054:	428a      	cmp	r2, r1
 8008056:	d103      	bne.n	8008060 <SPI_WaitFifoStateUntilTimeout.part.1+0x30>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 8008058:	2140      	movs	r1, #64	; 0x40
 800805a:	681a      	ldr	r2, [r3, #0]
 800805c:	438a      	bics	r2, r1
 800805e:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008060:	2180      	movs	r1, #128	; 0x80
 8008062:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8008064:	0189      	lsls	r1, r1, #6
 8008066:	428a      	cmp	r2, r1
 8008068:	d106      	bne.n	8008078 <SPI_WaitFifoStateUntilTimeout.part.1+0x48>
        {
          SPI_RESET_CRC(hspi);
 800806a:	6819      	ldr	r1, [r3, #0]
 800806c:	4c07      	ldr	r4, [pc, #28]	; (800808c <SPI_WaitFifoStateUntilTimeout.part.1+0x5c>)
 800806e:	4021      	ands	r1, r4
 8008070:	6019      	str	r1, [r3, #0]
 8008072:	6819      	ldr	r1, [r3, #0]
 8008074:	430a      	orrs	r2, r1
 8008076:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 8008078:	0003      	movs	r3, r0
 800807a:	2201      	movs	r2, #1
 800807c:	335d      	adds	r3, #93	; 0x5d
 800807e:	701a      	strb	r2, [r3, #0]

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8008080:	2300      	movs	r3, #0
 8008082:	305c      	adds	r0, #92	; 0x5c
 8008084:	7003      	strb	r3, [r0, #0]
      }
    }
  }

  return HAL_OK;
}
 8008086:	2003      	movs	r0, #3
 8008088:	bd10      	pop	{r4, pc}
 800808a:	46c0      	nop			; (mov r8, r8)
 800808c:	ffffdfff 	.word	0xffffdfff

08008090 <SPI_WaitFlagStateUntilTimeout>:
{
 8008090:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008092:	0006      	movs	r6, r0
 8008094:	000d      	movs	r5, r1
 8008096:	0017      	movs	r7, r2
 8008098:	001c      	movs	r4, r3
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 800809a:	6832      	ldr	r2, [r6, #0]
 800809c:	6893      	ldr	r3, [r2, #8]
 800809e:	402b      	ands	r3, r5
 80080a0:	1b5b      	subs	r3, r3, r5
 80080a2:	4259      	negs	r1, r3
 80080a4:	414b      	adcs	r3, r1
 80080a6:	429f      	cmp	r7, r3
 80080a8:	d101      	bne.n	80080ae <SPI_WaitFlagStateUntilTimeout+0x1e>
  return HAL_OK;
 80080aa:	2000      	movs	r0, #0
 80080ac:	e006      	b.n	80080bc <SPI_WaitFlagStateUntilTimeout+0x2c>
    if (Timeout != HAL_MAX_DELAY)
 80080ae:	1c63      	adds	r3, r4, #1
 80080b0:	d0f4      	beq.n	800809c <SPI_WaitFlagStateUntilTimeout+0xc>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 80080b2:	2c00      	cmp	r4, #0
 80080b4:	d103      	bne.n	80080be <SPI_WaitFlagStateUntilTimeout+0x2e>
 80080b6:	0030      	movs	r0, r6
 80080b8:	f7ff ffba 	bl	8008030 <SPI_WaitFifoStateUntilTimeout.part.1>
}
 80080bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 80080be:	f7fe ff53 	bl	8006f68 <HAL_GetTick>
 80080c2:	9b06      	ldr	r3, [sp, #24]
 80080c4:	1ac0      	subs	r0, r0, r3
 80080c6:	42a0      	cmp	r0, r4
 80080c8:	d3e7      	bcc.n	800809a <SPI_WaitFlagStateUntilTimeout+0xa>
 80080ca:	e7f4      	b.n	80080b6 <SPI_WaitFlagStateUntilTimeout+0x26>

080080cc <SPI_WaitFifoStateUntilTimeout>:
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 80080cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80080ce:	0007      	movs	r7, r0
 80080d0:	000e      	movs	r6, r1
 80080d2:	0015      	movs	r5, r2
 80080d4:	001c      	movs	r4, r3

  while ((hspi->Instance->SR & Fifo) != State)
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
    {
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 80080d6:	466b      	mov	r3, sp
  while ((hspi->Instance->SR & Fifo) != State)
 80080d8:	6839      	ldr	r1, [r7, #0]
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 80080da:	1dda      	adds	r2, r3, #7
  while ((hspi->Instance->SR & Fifo) != State)
 80080dc:	688b      	ldr	r3, [r1, #8]
 80080de:	4033      	ands	r3, r6
 80080e0:	42ab      	cmp	r3, r5
 80080e2:	d101      	bne.n	80080e8 <SPI_WaitFifoStateUntilTimeout+0x1c>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 80080e4:	2000      	movs	r0, #0
 80080e6:	e010      	b.n	800810a <SPI_WaitFifoStateUntilTimeout+0x3e>
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 80080e8:	23c0      	movs	r3, #192	; 0xc0
 80080ea:	00db      	lsls	r3, r3, #3
 80080ec:	429e      	cmp	r6, r3
 80080ee:	d105      	bne.n	80080fc <SPI_WaitFifoStateUntilTimeout+0x30>
 80080f0:	2d00      	cmp	r5, #0
 80080f2:	d103      	bne.n	80080fc <SPI_WaitFifoStateUntilTimeout+0x30>
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 80080f4:	7b0b      	ldrb	r3, [r1, #12]
 80080f6:	b2db      	uxtb	r3, r3
 80080f8:	7013      	strb	r3, [r2, #0]
      UNUSED(tmpreg);
 80080fa:	7813      	ldrb	r3, [r2, #0]
    if (Timeout != HAL_MAX_DELAY)
 80080fc:	1c63      	adds	r3, r4, #1
 80080fe:	d0ed      	beq.n	80080dc <SPI_WaitFifoStateUntilTimeout+0x10>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 8008100:	2c00      	cmp	r4, #0
 8008102:	d103      	bne.n	800810c <SPI_WaitFifoStateUntilTimeout+0x40>
 8008104:	0038      	movs	r0, r7
 8008106:	f7ff ff93 	bl	8008030 <SPI_WaitFifoStateUntilTimeout.part.1>
}
 800810a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 800810c:	f7fe ff2c 	bl	8006f68 <HAL_GetTick>
 8008110:	9b08      	ldr	r3, [sp, #32]
 8008112:	1ac0      	subs	r0, r0, r3
 8008114:	42a0      	cmp	r0, r4
 8008116:	d3de      	bcc.n	80080d6 <SPI_WaitFifoStateUntilTimeout+0xa>
 8008118:	e7f4      	b.n	8008104 <SPI_WaitFifoStateUntilTimeout+0x38>

0800811a <SPI_EndRxTransaction>:
  * @param  Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
{
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800811a:	2382      	movs	r3, #130	; 0x82
{
 800811c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800811e:	0017      	movs	r7, r2
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8008120:	6842      	ldr	r2, [r0, #4]
{
 8008122:	0004      	movs	r4, r0
 8008124:	000e      	movs	r6, r1
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8008126:	005b      	lsls	r3, r3, #1
 8008128:	429a      	cmp	r2, r3
 800812a:	d10d      	bne.n	8008148 <SPI_EndRxTransaction+0x2e>
 800812c:	2280      	movs	r2, #128	; 0x80
 800812e:	6883      	ldr	r3, [r0, #8]
 8008130:	0212      	lsls	r2, r2, #8
 8008132:	4293      	cmp	r3, r2
 8008134:	d003      	beq.n	800813e <SPI_EndRxTransaction+0x24>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8008136:	2280      	movs	r2, #128	; 0x80
 8008138:	00d2      	lsls	r2, r2, #3
 800813a:	4293      	cmp	r3, r2
 800813c:	d104      	bne.n	8008148 <SPI_EndRxTransaction+0x2e>
  {
    /* Disable SPI peripheral */
    __HAL_SPI_DISABLE(hspi);
 800813e:	2140      	movs	r1, #64	; 0x40
 8008140:	6822      	ldr	r2, [r4, #0]
 8008142:	6813      	ldr	r3, [r2, #0]
 8008144:	438b      	bics	r3, r1
 8008146:	6013      	str	r3, [r2, #0]
  }

  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8008148:	9700      	str	r7, [sp, #0]
 800814a:	0033      	movs	r3, r6
 800814c:	2200      	movs	r2, #0
 800814e:	2180      	movs	r1, #128	; 0x80
 8008150:	0020      	movs	r0, r4
 8008152:	f7ff ff9d 	bl	8008090 <SPI_WaitFlagStateUntilTimeout>
 8008156:	1e05      	subs	r5, r0, #0
 8008158:	d005      	beq.n	8008166 <SPI_EndRxTransaction+0x4c>
  }

  /* Control if the RX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800815a:	2320      	movs	r3, #32
 800815c:	6e22      	ldr	r2, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 800815e:	2503      	movs	r5, #3
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8008160:	4313      	orrs	r3, r2
 8008162:	6623      	str	r3, [r4, #96]	; 0x60
 8008164:	e017      	b.n	8008196 <SPI_EndRxTransaction+0x7c>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8008166:	2382      	movs	r3, #130	; 0x82
 8008168:	6862      	ldr	r2, [r4, #4]
 800816a:	005b      	lsls	r3, r3, #1
 800816c:	429a      	cmp	r2, r3
 800816e:	d112      	bne.n	8008196 <SPI_EndRxTransaction+0x7c>
 8008170:	2280      	movs	r2, #128	; 0x80
 8008172:	68a3      	ldr	r3, [r4, #8]
 8008174:	0212      	lsls	r2, r2, #8
 8008176:	4293      	cmp	r3, r2
 8008178:	d003      	beq.n	8008182 <SPI_EndRxTransaction+0x68>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800817a:	2280      	movs	r2, #128	; 0x80
 800817c:	00d2      	lsls	r2, r2, #3
 800817e:	4293      	cmp	r3, r2
 8008180:	d109      	bne.n	8008196 <SPI_EndRxTransaction+0x7c>
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8008182:	21c0      	movs	r1, #192	; 0xc0
 8008184:	9700      	str	r7, [sp, #0]
 8008186:	0033      	movs	r3, r6
 8008188:	2200      	movs	r2, #0
 800818a:	00c9      	lsls	r1, r1, #3
 800818c:	0020      	movs	r0, r4
 800818e:	f7ff ff9d 	bl	80080cc <SPI_WaitFifoStateUntilTimeout>
 8008192:	2800      	cmp	r0, #0
 8008194:	d1e1      	bne.n	800815a <SPI_EndRxTransaction+0x40>
}
 8008196:	0028      	movs	r0, r5
 8008198:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0800819a <SPI_EndRxTxTransaction>:
{
 800819a:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 800819c:	000b      	movs	r3, r1
{
 800819e:	000d      	movs	r5, r1
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80081a0:	21c0      	movs	r1, #192	; 0xc0
 80081a2:	9200      	str	r2, [sp, #0]
{
 80081a4:	0016      	movs	r6, r2
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80081a6:	0149      	lsls	r1, r1, #5
 80081a8:	2200      	movs	r2, #0
{
 80081aa:	0004      	movs	r4, r0
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80081ac:	f7ff ff8e 	bl	80080cc <SPI_WaitFifoStateUntilTimeout>
 80081b0:	1e02      	subs	r2, r0, #0
 80081b2:	d005      	beq.n	80081c0 <SPI_EndRxTxTransaction+0x26>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80081b4:	2320      	movs	r3, #32
 80081b6:	6e22      	ldr	r2, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 80081b8:	2003      	movs	r0, #3
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80081ba:	4313      	orrs	r3, r2
 80081bc:	6623      	str	r3, [r4, #96]	; 0x60
 80081be:	e010      	b.n	80081e2 <SPI_EndRxTxTransaction+0x48>
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 80081c0:	9600      	str	r6, [sp, #0]
 80081c2:	002b      	movs	r3, r5
 80081c4:	2180      	movs	r1, #128	; 0x80
 80081c6:	0020      	movs	r0, r4
 80081c8:	f7ff ff62 	bl	8008090 <SPI_WaitFlagStateUntilTimeout>
 80081cc:	1e02      	subs	r2, r0, #0
 80081ce:	d1f1      	bne.n	80081b4 <SPI_EndRxTxTransaction+0x1a>
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80081d0:	21c0      	movs	r1, #192	; 0xc0
 80081d2:	9600      	str	r6, [sp, #0]
 80081d4:	002b      	movs	r3, r5
 80081d6:	00c9      	lsls	r1, r1, #3
 80081d8:	0020      	movs	r0, r4
 80081da:	f7ff ff77 	bl	80080cc <SPI_WaitFifoStateUntilTimeout>
 80081de:	2800      	cmp	r0, #0
 80081e0:	d1e8      	bne.n	80081b4 <SPI_EndRxTxTransaction+0x1a>
  }
  return HAL_OK;
}
 80081e2:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

080081e4 <HAL_SPI_Init>:
{
 80081e4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80081e6:	0004      	movs	r4, r0
    return HAL_ERROR;
 80081e8:	2001      	movs	r0, #1
  if (hspi == NULL)
 80081ea:	2c00      	cmp	r4, #0
 80081ec:	d05f      	beq.n	80082ae <HAL_SPI_Init+0xca>
  if (hspi->State == HAL_SPI_STATE_RESET)
 80081ee:	0025      	movs	r5, r4
 80081f0:	355d      	adds	r5, #93	; 0x5d
 80081f2:	782b      	ldrb	r3, [r5, #0]
 80081f4:	b2db      	uxtb	r3, r3
 80081f6:	2b00      	cmp	r3, #0
 80081f8:	d105      	bne.n	8008206 <HAL_SPI_Init+0x22>
    hspi->Lock = HAL_UNLOCKED;
 80081fa:	0022      	movs	r2, r4
 80081fc:	325c      	adds	r2, #92	; 0x5c
 80081fe:	7013      	strb	r3, [r2, #0]
    HAL_SPI_MspInit(hspi);
 8008200:	0020      	movs	r0, r4
 8008202:	f7fd fe35 	bl	8005e70 <HAL_SPI_MspInit>
  hspi->State = HAL_SPI_STATE_BUSY;
 8008206:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);
 8008208:	2140      	movs	r1, #64	; 0x40
 800820a:	6822      	ldr	r2, [r4, #0]
  hspi->State = HAL_SPI_STATE_BUSY;
 800820c:	702b      	strb	r3, [r5, #0]
  __HAL_SPI_DISABLE(hspi);
 800820e:	6813      	ldr	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008210:	68e0      	ldr	r0, [r4, #12]
  __HAL_SPI_DISABLE(hspi);
 8008212:	438b      	bics	r3, r1
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008214:	21e0      	movs	r1, #224	; 0xe0
  __HAL_SPI_DISABLE(hspi);
 8008216:	6013      	str	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008218:	00c9      	lsls	r1, r1, #3
 800821a:	2300      	movs	r3, #0
 800821c:	4288      	cmp	r0, r1
 800821e:	d847      	bhi.n	80082b0 <HAL_SPI_Init+0xcc>
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 8008220:	2680      	movs	r6, #128	; 0x80
 8008222:	0176      	lsls	r6, r6, #5
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8008224:	4288      	cmp	r0, r1
 8008226:	d101      	bne.n	800822c <HAL_SPI_Init+0x48>
 8008228:	e001      	b.n	800822e <HAL_SPI_Init+0x4a>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 800822a:	001e      	movs	r6, r3
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800822c:	62a3      	str	r3, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 800822e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8008230:	2b00      	cmp	r3, #0
 8008232:	d104      	bne.n	800823e <HAL_SPI_Init+0x5a>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 8008234:	3302      	adds	r3, #2
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008236:	4288      	cmp	r0, r1
 8008238:	d800      	bhi.n	800823c <HAL_SPI_Init+0x58>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 800823a:	2301      	movs	r3, #1
 800823c:	6323      	str	r3, [r4, #48]	; 0x30
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 800823e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8008240:	68a7      	ldr	r7, [r4, #8]
 8008242:	9301      	str	r3, [sp, #4]
 8008244:	6863      	ldr	r3, [r4, #4]
 8008246:	69a1      	ldr	r1, [r4, #24]
 8008248:	433b      	orrs	r3, r7
 800824a:	6927      	ldr	r7, [r4, #16]
 800824c:	433b      	orrs	r3, r7
 800824e:	6967      	ldr	r7, [r4, #20]
 8008250:	433b      	orrs	r3, r7
 8008252:	69e7      	ldr	r7, [r4, #28]
 8008254:	433b      	orrs	r3, r7
 8008256:	6a27      	ldr	r7, [r4, #32]
 8008258:	433b      	orrs	r3, r7
 800825a:	9f01      	ldr	r7, [sp, #4]
 800825c:	433b      	orrs	r3, r7
 800825e:	2780      	movs	r7, #128	; 0x80
 8008260:	00bf      	lsls	r7, r7, #2
 8008262:	400f      	ands	r7, r1
 8008264:	433b      	orrs	r3, r7
 8008266:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8008268:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800826a:	2b02      	cmp	r3, #2
 800826c:	d106      	bne.n	800827c <HAL_SPI_Init+0x98>
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
 800826e:	6813      	ldr	r3, [r2, #0]
 8008270:	469c      	mov	ip, r3
 8008272:	2380      	movs	r3, #128	; 0x80
 8008274:	4667      	mov	r7, ip
 8008276:	011b      	lsls	r3, r3, #4
 8008278:	433b      	orrs	r3, r7
 800827a:	6013      	str	r3, [r2, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 800827c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800827e:	0c09      	lsrs	r1, r1, #16
 8008280:	4318      	orrs	r0, r3
 8008282:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8008284:	4318      	orrs	r0, r3
 8008286:	2304      	movs	r3, #4
 8008288:	4019      	ands	r1, r3
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800828a:	2380      	movs	r3, #128	; 0x80
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 800828c:	4301      	orrs	r1, r0
 800828e:	430e      	orrs	r6, r1
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008290:	9901      	ldr	r1, [sp, #4]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8008292:	6056      	str	r6, [r2, #4]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008294:	019b      	lsls	r3, r3, #6
 8008296:	4299      	cmp	r1, r3
 8008298:	d101      	bne.n	800829e <HAL_SPI_Init+0xba>
    WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
 800829a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800829c:	6113      	str	r3, [r2, #16]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 800829e:	69d3      	ldr	r3, [r2, #28]
 80082a0:	4906      	ldr	r1, [pc, #24]	; (80082bc <HAL_SPI_Init+0xd8>)
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80082a2:	2000      	movs	r0, #0
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80082a4:	400b      	ands	r3, r1
 80082a6:	61d3      	str	r3, [r2, #28]
  hspi->State     = HAL_SPI_STATE_READY;
 80082a8:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80082aa:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 80082ac:	702b      	strb	r3, [r5, #0]
}
 80082ae:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 80082b0:	26f0      	movs	r6, #240	; 0xf0
 80082b2:	0136      	lsls	r6, r6, #4
 80082b4:	42b0      	cmp	r0, r6
 80082b6:	d1b8      	bne.n	800822a <HAL_SPI_Init+0x46>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 80082b8:	001e      	movs	r6, r3
 80082ba:	e7b8      	b.n	800822e <HAL_SPI_Init+0x4a>
 80082bc:	fffff7ff 	.word	0xfffff7ff

080082c0 <HAL_SPI_Transmit_DMA>:
{
 80082c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hspi);
 80082c2:	0005      	movs	r5, r0
 80082c4:	355c      	adds	r5, #92	; 0x5c
 80082c6:	782b      	ldrb	r3, [r5, #0]
{
 80082c8:	0004      	movs	r4, r0
  __HAL_LOCK(hspi);
 80082ca:	2002      	movs	r0, #2
 80082cc:	2b01      	cmp	r3, #1
 80082ce:	d069      	beq.n	80083a4 <HAL_SPI_Transmit_DMA+0xe4>
 80082d0:	2301      	movs	r3, #1
  if (hspi->State != HAL_SPI_STATE_READY)
 80082d2:	0026      	movs	r6, r4
  __HAL_LOCK(hspi);
 80082d4:	702b      	strb	r3, [r5, #0]
  if (hspi->State != HAL_SPI_STATE_READY)
 80082d6:	365d      	adds	r6, #93	; 0x5d
 80082d8:	7833      	ldrb	r3, [r6, #0]
 80082da:	b2db      	uxtb	r3, r3
 80082dc:	2b01      	cmp	r3, #1
 80082de:	d15f      	bne.n	80083a0 <HAL_SPI_Transmit_DMA+0xe0>
    errorcode = HAL_ERROR;
 80082e0:	0018      	movs	r0, r3
  if ((pData == NULL) || (Size == 0U))
 80082e2:	2900      	cmp	r1, #0
 80082e4:	d05c      	beq.n	80083a0 <HAL_SPI_Transmit_DMA+0xe0>
 80082e6:	2a00      	cmp	r2, #0
 80082e8:	d05a      	beq.n	80083a0 <HAL_SPI_Transmit_DMA+0xe0>
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 80082ea:	3302      	adds	r3, #2
 80082ec:	7033      	strb	r3, [r6, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80082ee:	2300      	movs	r3, #0
  hspi->TxXferSize  = Size;
 80082f0:	87a2      	strh	r2, [r4, #60]	; 0x3c
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80082f2:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->TxXferCount = Size;
 80082f4:	87e2      	strh	r2, [r4, #62]	; 0x3e
  hspi->RxXferSize  = 0U;
 80082f6:	1da2      	adds	r2, r4, #6
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 80082f8:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->TxISR       = NULL;
 80082fa:	6523      	str	r3, [r4, #80]	; 0x50
  hspi->RxISR       = NULL;
 80082fc:	64e3      	str	r3, [r4, #76]	; 0x4c
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 80082fe:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->RxXferCount = 0U;
 8008300:	3202      	adds	r2, #2
  hspi->RxXferSize  = 0U;
 8008302:	8793      	strh	r3, [r2, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 8008304:	87d3      	strh	r3, [r2, #62]	; 0x3e
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8008306:	2380      	movs	r3, #128	; 0x80
 8008308:	68a0      	ldr	r0, [r4, #8]
 800830a:	6822      	ldr	r2, [r4, #0]
 800830c:	021b      	lsls	r3, r3, #8
 800830e:	4298      	cmp	r0, r3
 8008310:	d104      	bne.n	800831c <HAL_SPI_Transmit_DMA+0x5c>
    SPI_1LINE_TX(hspi);
 8008312:	2380      	movs	r3, #128	; 0x80
 8008314:	6810      	ldr	r0, [r2, #0]
 8008316:	01db      	lsls	r3, r3, #7
 8008318:	4303      	orrs	r3, r0
 800831a:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800831c:	2080      	movs	r0, #128	; 0x80
 800831e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8008320:	0180      	lsls	r0, r0, #6
 8008322:	4283      	cmp	r3, r0
 8008324:	d106      	bne.n	8008334 <HAL_SPI_Transmit_DMA+0x74>
    SPI_RESET_CRC(hspi);
 8008326:	6810      	ldr	r0, [r2, #0]
 8008328:	4e23      	ldr	r6, [pc, #140]	; (80083b8 <HAL_SPI_Transmit_DMA+0xf8>)
 800832a:	4030      	ands	r0, r6
 800832c:	6010      	str	r0, [r2, #0]
 800832e:	6810      	ldr	r0, [r2, #0]
 8008330:	4303      	orrs	r3, r0
 8008332:	6013      	str	r3, [r2, #0]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 8008334:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8008336:	4b21      	ldr	r3, [pc, #132]	; (80083bc <HAL_SPI_Transmit_DMA+0xfc>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8008338:	6856      	ldr	r6, [r2, #4]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 800833a:	62c3      	str	r3, [r0, #44]	; 0x2c
  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
 800833c:	4b20      	ldr	r3, [pc, #128]	; (80083c0 <HAL_SPI_Transmit_DMA+0x100>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 800833e:	4f21      	ldr	r7, [pc, #132]	; (80083c4 <HAL_SPI_Transmit_DMA+0x104>)
  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
 8008340:	6283      	str	r3, [r0, #40]	; 0x28
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 8008342:	4b21      	ldr	r3, [pc, #132]	; (80083c8 <HAL_SPI_Transmit_DMA+0x108>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8008344:	403e      	ands	r6, r7
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 8008346:	6303      	str	r3, [r0, #48]	; 0x30
  hspi->hdmatx->XferAbortCallback = NULL;
 8008348:	2300      	movs	r3, #0
 800834a:	6343      	str	r3, [r0, #52]	; 0x34
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 800834c:	23e0      	movs	r3, #224	; 0xe0
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 800834e:	6056      	str	r6, [r2, #4]
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 8008350:	68e6      	ldr	r6, [r4, #12]
 8008352:	00db      	lsls	r3, r3, #3
 8008354:	429e      	cmp	r6, r3
 8008356:	d80d      	bhi.n	8008374 <HAL_SPI_Transmit_DMA+0xb4>
 8008358:	2380      	movs	r3, #128	; 0x80
 800835a:	6946      	ldr	r6, [r0, #20]
 800835c:	00db      	lsls	r3, r3, #3
 800835e:	429e      	cmp	r6, r3
 8008360:	d108      	bne.n	8008374 <HAL_SPI_Transmit_DMA+0xb4>
    if ((hspi->TxXferCount & 0x1U) == 0U)
 8008362:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8008364:	07db      	lsls	r3, r3, #31
 8008366:	d41e      	bmi.n	80083a6 <HAL_SPI_Transmit_DMA+0xe6>
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8008368:	6853      	ldr	r3, [r2, #4]
 800836a:	403b      	ands	r3, r7
 800836c:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U);
 800836e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8008370:	085b      	lsrs	r3, r3, #1
      hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 8008372:	87e3      	strh	r3, [r4, #62]	; 0x3e
  HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
 8008374:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8008376:	320c      	adds	r2, #12
 8008378:	b29b      	uxth	r3, r3
 800837a:	f7ff f9ef 	bl	800775c <HAL_DMA_Start_IT>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800837e:	2240      	movs	r2, #64	; 0x40
 8008380:	6823      	ldr	r3, [r4, #0]
 8008382:	6819      	ldr	r1, [r3, #0]
 8008384:	4211      	tst	r1, r2
 8008386:	d102      	bne.n	800838e <HAL_SPI_Transmit_DMA+0xce>
    __HAL_SPI_ENABLE(hspi);
 8008388:	6819      	ldr	r1, [r3, #0]
 800838a:	430a      	orrs	r2, r1
 800838c:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 800838e:	2220      	movs	r2, #32
 8008390:	6859      	ldr	r1, [r3, #4]
  HAL_StatusTypeDef errorcode = HAL_OK;
 8008392:	2000      	movs	r0, #0
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 8008394:	430a      	orrs	r2, r1
 8008396:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8008398:	2202      	movs	r2, #2
 800839a:	6859      	ldr	r1, [r3, #4]
 800839c:	430a      	orrs	r2, r1
 800839e:	605a      	str	r2, [r3, #4]
  __HAL_UNLOCK(hspi);
 80083a0:	2300      	movs	r3, #0
 80083a2:	702b      	strb	r3, [r5, #0]
}
 80083a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80083a6:	2380      	movs	r3, #128	; 0x80
 80083a8:	6856      	ldr	r6, [r2, #4]
 80083aa:	01db      	lsls	r3, r3, #7
 80083ac:	4333      	orrs	r3, r6
 80083ae:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 80083b0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80083b2:	085b      	lsrs	r3, r3, #1
 80083b4:	3301      	adds	r3, #1
 80083b6:	e7dc      	b.n	8008372 <HAL_SPI_Transmit_DMA+0xb2>
 80083b8:	ffffdfff 	.word	0xffffdfff
 80083bc:	08008719 	.word	0x08008719
 80083c0:	08008761 	.word	0x08008761
 80083c4:	ffffbfff 	.word	0xffffbfff
 80083c8:	0800873d 	.word	0x0800873d

080083cc <HAL_SPI_TransmitReceive_DMA>:
{
 80083cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __HAL_LOCK(hspi);
 80083ce:	0006      	movs	r6, r0
 80083d0:	365c      	adds	r6, #92	; 0x5c
 80083d2:	9601      	str	r6, [sp, #4]
 80083d4:	7835      	ldrb	r5, [r6, #0]
{
 80083d6:	0004      	movs	r4, r0
  __HAL_LOCK(hspi);
 80083d8:	2002      	movs	r0, #2
 80083da:	2d01      	cmp	r5, #1
 80083dc:	d07d      	beq.n	80084da <HAL_SPI_TransmitReceive_DMA+0x10e>
 80083de:	0035      	movs	r5, r6
 80083e0:	3801      	subs	r0, #1
 80083e2:	7030      	strb	r0, [r6, #0]
  tmp  = hspi->State;
 80083e4:	3501      	adds	r5, #1
 80083e6:	782f      	ldrb	r7, [r5, #0]
 80083e8:	b2ff      	uxtb	r7, r7
  if (!((tmp == HAL_SPI_STATE_READY) ||
 80083ea:	4287      	cmp	r7, r0
 80083ec:	d00c      	beq.n	8008408 <HAL_SPI_TransmitReceive_DMA+0x3c>
 80083ee:	3004      	adds	r0, #4
 80083f0:	30ff      	adds	r0, #255	; 0xff
 80083f2:	4684      	mov	ip, r0
 80083f4:	6866      	ldr	r6, [r4, #4]
    errorcode = HAL_BUSY;
 80083f6:	3803      	subs	r0, #3
 80083f8:	38ff      	subs	r0, #255	; 0xff
  if (!((tmp == HAL_SPI_STATE_READY) ||
 80083fa:	4566      	cmp	r6, ip
 80083fc:	d16a      	bne.n	80084d4 <HAL_SPI_TransmitReceive_DMA+0x108>
        ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
 80083fe:	68a6      	ldr	r6, [r4, #8]
 8008400:	2e00      	cmp	r6, #0
 8008402:	d167      	bne.n	80084d4 <HAL_SPI_TransmitReceive_DMA+0x108>
 8008404:	2f04      	cmp	r7, #4
 8008406:	d165      	bne.n	80084d4 <HAL_SPI_TransmitReceive_DMA+0x108>
    errorcode = HAL_ERROR;
 8008408:	2001      	movs	r0, #1
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 800840a:	2900      	cmp	r1, #0
 800840c:	d062      	beq.n	80084d4 <HAL_SPI_TransmitReceive_DMA+0x108>
 800840e:	2a00      	cmp	r2, #0
 8008410:	d060      	beq.n	80084d4 <HAL_SPI_TransmitReceive_DMA+0x108>
 8008412:	2b00      	cmp	r3, #0
 8008414:	d05e      	beq.n	80084d4 <HAL_SPI_TransmitReceive_DMA+0x108>
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8008416:	7828      	ldrb	r0, [r5, #0]
 8008418:	2804      	cmp	r0, #4
 800841a:	d001      	beq.n	8008420 <HAL_SPI_TransmitReceive_DMA+0x54>
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 800841c:	2005      	movs	r0, #5
 800841e:	7028      	strb	r0, [r5, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8008420:	2000      	movs	r0, #0
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008422:	2780      	movs	r7, #128	; 0x80
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8008424:	6422      	str	r2, [r4, #64]	; 0x40
  hspi->RxXferSize  = Size;
 8008426:	1da2      	adds	r2, r4, #6
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8008428:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 800842a:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->TxXferSize  = Size;
 800842c:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
 800842e:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->RxXferCount = Size;
 8008430:	3202      	adds	r2, #2
  hspi->RxXferSize  = Size;
 8008432:	8793      	strh	r3, [r2, #60]	; 0x3c
  hspi->RxXferCount = Size;
 8008434:	87d3      	strh	r3, [r2, #62]	; 0x3e
  hspi->RxISR       = NULL;
 8008436:	64e0      	str	r0, [r4, #76]	; 0x4c
  hspi->TxISR       = NULL;
 8008438:	6520      	str	r0, [r4, #80]	; 0x50
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800843a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800843c:	6821      	ldr	r1, [r4, #0]
 800843e:	01bf      	lsls	r7, r7, #6
 8008440:	42b8      	cmp	r0, r7
 8008442:	d106      	bne.n	8008452 <HAL_SPI_TransmitReceive_DMA+0x86>
    SPI_RESET_CRC(hspi);
 8008444:	680f      	ldr	r7, [r1, #0]
 8008446:	4e45      	ldr	r6, [pc, #276]	; (800855c <HAL_SPI_TransmitReceive_DMA+0x190>)
 8008448:	4037      	ands	r7, r6
 800844a:	600f      	str	r7, [r1, #0]
 800844c:	680f      	ldr	r7, [r1, #0]
 800844e:	4338      	orrs	r0, r7
 8008450:	6008      	str	r0, [r1, #0]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
 8008452:	6848      	ldr	r0, [r1, #4]
 8008454:	4f42      	ldr	r7, [pc, #264]	; (8008560 <HAL_SPI_TransmitReceive_DMA+0x194>)
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008456:	68e6      	ldr	r6, [r4, #12]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
 8008458:	4038      	ands	r0, r7
 800845a:	6048      	str	r0, [r1, #4]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800845c:	20e0      	movs	r0, #224	; 0xe0
 800845e:	00c0      	lsls	r0, r0, #3
 8008460:	4286      	cmp	r6, r0
 8008462:	d93b      	bls.n	80084dc <HAL_SPI_TransmitReceive_DMA+0x110>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8008464:	684b      	ldr	r3, [r1, #4]
 8008466:	483f      	ldr	r0, [pc, #252]	; (8008564 <HAL_SPI_TransmitReceive_DMA+0x198>)
 8008468:	4003      	ands	r3, r0
 800846a:	604b      	str	r3, [r1, #4]
  if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 800846c:	782b      	ldrb	r3, [r5, #0]
 800846e:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8008470:	2b04      	cmp	r3, #4
 8008472:	d000      	beq.n	8008476 <HAL_SPI_TransmitReceive_DMA+0xaa>
 8008474:	e06d      	b.n	8008552 <HAL_SPI_TransmitReceive_DMA+0x186>
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 8008476:	4b3c      	ldr	r3, [pc, #240]	; (8008568 <HAL_SPI_TransmitReceive_DMA+0x19c>)
 8008478:	62c3      	str	r3, [r0, #44]	; 0x2c
    hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
 800847a:	4b3c      	ldr	r3, [pc, #240]	; (800856c <HAL_SPI_TransmitReceive_DMA+0x1a0>)
  hspi->hdmarx->XferAbortCallback = NULL;
 800847c:	2500      	movs	r5, #0
    hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
 800847e:	6283      	str	r3, [r0, #40]	; 0x28
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 8008480:	4b3b      	ldr	r3, [pc, #236]	; (8008570 <HAL_SPI_TransmitReceive_DMA+0x1a4>)
  hspi->hdmarx->XferAbortCallback = NULL;
 8008482:	6345      	str	r5, [r0, #52]	; 0x34
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 8008484:	6303      	str	r3, [r0, #48]	; 0x30
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 8008486:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 8008488:	310c      	adds	r1, #12
 800848a:	b29b      	uxth	r3, r3
 800848c:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800848e:	f7ff f965 	bl	800775c <HAL_DMA_Start_IT>
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 8008492:	2301      	movs	r3, #1
 8008494:	6822      	ldr	r2, [r4, #0]
  hspi->hdmatx->XferHalfCpltCallback = NULL;
 8008496:	6d60      	ldr	r0, [r4, #84]	; 0x54
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 8008498:	6851      	ldr	r1, [r2, #4]
 800849a:	430b      	orrs	r3, r1
 800849c:	6053      	str	r3, [r2, #4]
  hspi->hdmatx->XferHalfCpltCallback = NULL;
 800849e:	62c5      	str	r5, [r0, #44]	; 0x2c
  hspi->hdmatx->XferCpltCallback     = NULL;
 80084a0:	6285      	str	r5, [r0, #40]	; 0x28
  hspi->hdmatx->XferErrorCallback    = NULL;
 80084a2:	6305      	str	r5, [r0, #48]	; 0x30
  hspi->hdmatx->XferAbortCallback    = NULL;
 80084a4:	6345      	str	r5, [r0, #52]	; 0x34
  HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
 80084a6:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80084a8:	320c      	adds	r2, #12
 80084aa:	b29b      	uxth	r3, r3
 80084ac:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80084ae:	f7ff f955 	bl	800775c <HAL_DMA_Start_IT>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80084b2:	2240      	movs	r2, #64	; 0x40
 80084b4:	6823      	ldr	r3, [r4, #0]
 80084b6:	6819      	ldr	r1, [r3, #0]
 80084b8:	4211      	tst	r1, r2
 80084ba:	d102      	bne.n	80084c2 <HAL_SPI_TransmitReceive_DMA+0xf6>
    __HAL_SPI_ENABLE(hspi);
 80084bc:	6819      	ldr	r1, [r3, #0]
 80084be:	430a      	orrs	r2, r1
 80084c0:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 80084c2:	2220      	movs	r2, #32
 80084c4:	6859      	ldr	r1, [r3, #4]
  HAL_StatusTypeDef errorcode = HAL_OK;
 80084c6:	2000      	movs	r0, #0
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 80084c8:	430a      	orrs	r2, r1
 80084ca:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 80084cc:	2202      	movs	r2, #2
 80084ce:	6859      	ldr	r1, [r3, #4]
 80084d0:	430a      	orrs	r2, r1
 80084d2:	605a      	str	r2, [r3, #4]
  __HAL_UNLOCK(hspi);
 80084d4:	2300      	movs	r3, #0
 80084d6:	9a01      	ldr	r2, [sp, #4]
 80084d8:	7013      	strb	r3, [r2, #0]
}
 80084da:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80084dc:	2080      	movs	r0, #128	; 0x80
 80084de:	684f      	ldr	r7, [r1, #4]
 80084e0:	0140      	lsls	r0, r0, #5
 80084e2:	4338      	orrs	r0, r7
 80084e4:	6048      	str	r0, [r1, #4]
    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 80084e6:	2080      	movs	r0, #128	; 0x80
 80084e8:	6d67      	ldr	r7, [r4, #84]	; 0x54
 80084ea:	00c0      	lsls	r0, r0, #3
 80084ec:	697f      	ldr	r7, [r7, #20]
 80084ee:	4287      	cmp	r7, r0
 80084f0:	d108      	bne.n	8008504 <HAL_SPI_TransmitReceive_DMA+0x138>
      if ((hspi->TxXferSize & 0x1U) == 0x0U)
 80084f2:	07db      	lsls	r3, r3, #31
 80084f4:	d41b      	bmi.n	800852e <HAL_SPI_TransmitReceive_DMA+0x162>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80084f6:	684b      	ldr	r3, [r1, #4]
 80084f8:	481e      	ldr	r0, [pc, #120]	; (8008574 <HAL_SPI_TransmitReceive_DMA+0x1a8>)
 80084fa:	4003      	ands	r3, r0
 80084fc:	604b      	str	r3, [r1, #4]
        hspi->TxXferCount = hspi->TxXferCount >> 1U;
 80084fe:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8008500:	085b      	lsrs	r3, r3, #1
        hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 8008502:	87e3      	strh	r3, [r4, #62]	; 0x3e
    if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8008504:	2380      	movs	r3, #128	; 0x80
 8008506:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8008508:	00db      	lsls	r3, r3, #3
 800850a:	6940      	ldr	r0, [r0, #20]
 800850c:	4298      	cmp	r0, r3
 800850e:	d1ad      	bne.n	800846c <HAL_SPI_TransmitReceive_DMA+0xa0>
      CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8008510:	684b      	ldr	r3, [r1, #4]
 8008512:	4814      	ldr	r0, [pc, #80]	; (8008564 <HAL_SPI_TransmitReceive_DMA+0x198>)
 8008514:	4003      	ands	r3, r0
 8008516:	604b      	str	r3, [r1, #4]
      if ((hspi->RxXferCount & 0x1U) == 0x0U)
 8008518:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 800851a:	07db      	lsls	r3, r3, #31
 800851c:	d410      	bmi.n	8008540 <HAL_SPI_TransmitReceive_DMA+0x174>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 800851e:	684b      	ldr	r3, [r1, #4]
 8008520:	480e      	ldr	r0, [pc, #56]	; (800855c <HAL_SPI_TransmitReceive_DMA+0x190>)
 8008522:	4003      	ands	r3, r0
 8008524:	604b      	str	r3, [r1, #4]
        hspi->RxXferCount = hspi->RxXferCount >> 1U;
 8008526:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 8008528:	085b      	lsrs	r3, r3, #1
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 800852a:	87d3      	strh	r3, [r2, #62]	; 0x3e
 800852c:	e79e      	b.n	800846c <HAL_SPI_TransmitReceive_DMA+0xa0>
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 800852e:	2380      	movs	r3, #128	; 0x80
 8008530:	6848      	ldr	r0, [r1, #4]
 8008532:	01db      	lsls	r3, r3, #7
 8008534:	4303      	orrs	r3, r0
 8008536:	604b      	str	r3, [r1, #4]
        hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 8008538:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800853a:	085b      	lsrs	r3, r3, #1
 800853c:	3301      	adds	r3, #1
 800853e:	e7e0      	b.n	8008502 <HAL_SPI_TransmitReceive_DMA+0x136>
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 8008540:	2380      	movs	r3, #128	; 0x80
 8008542:	6848      	ldr	r0, [r1, #4]
 8008544:	019b      	lsls	r3, r3, #6
 8008546:	4303      	orrs	r3, r0
 8008548:	604b      	str	r3, [r1, #4]
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 800854a:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 800854c:	085b      	lsrs	r3, r3, #1
 800854e:	3301      	adds	r3, #1
 8008550:	e7eb      	b.n	800852a <HAL_SPI_TransmitReceive_DMA+0x15e>
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
 8008552:	4b09      	ldr	r3, [pc, #36]	; (8008578 <HAL_SPI_TransmitReceive_DMA+0x1ac>)
 8008554:	62c3      	str	r3, [r0, #44]	; 0x2c
    hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
 8008556:	4b09      	ldr	r3, [pc, #36]	; (800857c <HAL_SPI_TransmitReceive_DMA+0x1b0>)
 8008558:	e790      	b.n	800847c <HAL_SPI_TransmitReceive_DMA+0xb0>
 800855a:	46c0      	nop			; (mov r8, r8)
 800855c:	ffffdfff 	.word	0xffffdfff
 8008560:	ffff9fff 	.word	0xffff9fff
 8008564:	ffffefff 	.word	0xffffefff
 8008568:	08008725 	.word	0x08008725
 800856c:	080087d1 	.word	0x080087d1
 8008570:	0800873d 	.word	0x0800873d
 8008574:	ffffbfff 	.word	0xffffbfff
 8008578:	08008731 	.word	0x08008731
 800857c:	080088b5 	.word	0x080088b5

08008580 <HAL_SPI_Receive_DMA>:
  if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 8008580:	6883      	ldr	r3, [r0, #8]
{
 8008582:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8008584:	0005      	movs	r5, r0
  if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 8008586:	2b00      	cmp	r3, #0
 8008588:	d10f      	bne.n	80085aa <HAL_SPI_Receive_DMA+0x2a>
 800858a:	2082      	movs	r0, #130	; 0x82
 800858c:	686c      	ldr	r4, [r5, #4]
 800858e:	0040      	lsls	r0, r0, #1
 8008590:	4284      	cmp	r4, r0
 8008592:	d10a      	bne.n	80085aa <HAL_SPI_Receive_DMA+0x2a>
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 8008594:	002b      	movs	r3, r5
 8008596:	3801      	subs	r0, #1
 8008598:	335d      	adds	r3, #93	; 0x5d
 800859a:	38ff      	subs	r0, #255	; 0xff
 800859c:	7018      	strb	r0, [r3, #0]
    return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
 800859e:	0013      	movs	r3, r2
 80085a0:	0028      	movs	r0, r5
 80085a2:	000a      	movs	r2, r1
 80085a4:	f7ff ff12 	bl	80083cc <HAL_SPI_TransmitReceive_DMA>
}
 80085a8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(hspi);
 80085aa:	002e      	movs	r6, r5
 80085ac:	365c      	adds	r6, #92	; 0x5c
 80085ae:	7834      	ldrb	r4, [r6, #0]
 80085b0:	2002      	movs	r0, #2
 80085b2:	2c01      	cmp	r4, #1
 80085b4:	d0f8      	beq.n	80085a8 <HAL_SPI_Receive_DMA+0x28>
  if (hspi->State != HAL_SPI_STATE_READY)
 80085b6:	002f      	movs	r7, r5
  __HAL_LOCK(hspi);
 80085b8:	3801      	subs	r0, #1
 80085ba:	7030      	strb	r0, [r6, #0]
  if (hspi->State != HAL_SPI_STATE_READY)
 80085bc:	375d      	adds	r7, #93	; 0x5d
 80085be:	783c      	ldrb	r4, [r7, #0]
    errorcode = HAL_BUSY;
 80085c0:	3001      	adds	r0, #1
  if (hspi->State != HAL_SPI_STATE_READY)
 80085c2:	b2e4      	uxtb	r4, r4
 80085c4:	2c01      	cmp	r4, #1
 80085c6:	d156      	bne.n	8008676 <HAL_SPI_Receive_DMA+0xf6>
    errorcode = HAL_ERROR;
 80085c8:	0020      	movs	r0, r4
  if ((pData == NULL) || (Size == 0U))
 80085ca:	2900      	cmp	r1, #0
 80085cc:	d053      	beq.n	8008676 <HAL_SPI_Receive_DMA+0xf6>
 80085ce:	2a00      	cmp	r2, #0
 80085d0:	d051      	beq.n	8008676 <HAL_SPI_Receive_DMA+0xf6>
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 80085d2:	3003      	adds	r0, #3
 80085d4:	7038      	strb	r0, [r7, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80085d6:	2000      	movs	r0, #0
  hspi->RxXferCount = Size;
 80085d8:	3f55      	subs	r7, #85	; 0x55
  hspi->RxXferSize  = Size;
 80085da:	1dac      	adds	r4, r5, #6
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80085dc:	6628      	str	r0, [r5, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 80085de:	6429      	str	r1, [r5, #64]	; 0x40
  hspi->RxXferSize  = Size;
 80085e0:	87e2      	strh	r2, [r4, #62]	; 0x3e
  hspi->RxXferCount = Size;
 80085e2:	87fa      	strh	r2, [r7, #62]	; 0x3e
  hspi->RxISR       = NULL;
 80085e4:	64e8      	str	r0, [r5, #76]	; 0x4c
  hspi->TxISR       = NULL;
 80085e6:	6528      	str	r0, [r5, #80]	; 0x50
  hspi->TxXferSize  = 0U;
 80085e8:	87a8      	strh	r0, [r5, #60]	; 0x3c
  hspi->TxXferCount = 0U;
 80085ea:	87e8      	strh	r0, [r5, #62]	; 0x3e
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80085ec:	2080      	movs	r0, #128	; 0x80
  hspi->RxXferCount = Size;
 80085ee:	9701      	str	r7, [sp, #4]
 80085f0:	682a      	ldr	r2, [r5, #0]
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80085f2:	0200      	lsls	r0, r0, #8
 80085f4:	4283      	cmp	r3, r0
 80085f6:	d103      	bne.n	8008600 <HAL_SPI_Receive_DMA+0x80>
    SPI_1LINE_RX(hspi);
 80085f8:	6813      	ldr	r3, [r2, #0]
 80085fa:	4834      	ldr	r0, [pc, #208]	; (80086cc <HAL_SPI_Receive_DMA+0x14c>)
 80085fc:	4003      	ands	r3, r0
 80085fe:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008600:	2080      	movs	r0, #128	; 0x80
 8008602:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8008604:	0180      	lsls	r0, r0, #6
 8008606:	4c32      	ldr	r4, [pc, #200]	; (80086d0 <HAL_SPI_Receive_DMA+0x150>)
 8008608:	4283      	cmp	r3, r0
 800860a:	d105      	bne.n	8008618 <HAL_SPI_Receive_DMA+0x98>
    SPI_RESET_CRC(hspi);
 800860c:	6810      	ldr	r0, [r2, #0]
 800860e:	4020      	ands	r0, r4
 8008610:	6010      	str	r0, [r2, #0]
 8008612:	6810      	ldr	r0, [r2, #0]
 8008614:	4303      	orrs	r3, r0
 8008616:	6013      	str	r3, [r2, #0]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 8008618:	6853      	ldr	r3, [r2, #4]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800861a:	68ef      	ldr	r7, [r5, #12]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 800861c:	4023      	ands	r3, r4
 800861e:	6053      	str	r3, [r2, #4]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008620:	23e0      	movs	r3, #224	; 0xe0
 8008622:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8008624:	00db      	lsls	r3, r3, #3
 8008626:	429f      	cmp	r7, r3
 8008628:	d928      	bls.n	800867c <HAL_SPI_Receive_DMA+0xfc>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800862a:	6853      	ldr	r3, [r2, #4]
 800862c:	4c29      	ldr	r4, [pc, #164]	; (80086d4 <HAL_SPI_Receive_DMA+0x154>)
 800862e:	4023      	ands	r3, r4
 8008630:	6053      	str	r3, [r2, #4]
  hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 8008632:	4b29      	ldr	r3, [pc, #164]	; (80086d8 <HAL_SPI_Receive_DMA+0x158>)
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 8008634:	320c      	adds	r2, #12
  hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 8008636:	62c3      	str	r3, [r0, #44]	; 0x2c
  hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
 8008638:	4b28      	ldr	r3, [pc, #160]	; (80086dc <HAL_SPI_Receive_DMA+0x15c>)
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 800863a:	0014      	movs	r4, r2
  hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
 800863c:	6283      	str	r3, [r0, #40]	; 0x28
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 800863e:	4b28      	ldr	r3, [pc, #160]	; (80086e0 <HAL_SPI_Receive_DMA+0x160>)
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 8008640:	000a      	movs	r2, r1
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 8008642:	6303      	str	r3, [r0, #48]	; 0x30
  hspi->hdmarx->XferAbortCallback = NULL;
 8008644:	2300      	movs	r3, #0
 8008646:	6343      	str	r3, [r0, #52]	; 0x34
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 8008648:	9b01      	ldr	r3, [sp, #4]
 800864a:	0021      	movs	r1, r4
 800864c:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800864e:	b29b      	uxth	r3, r3
 8008650:	f7ff f884 	bl	800775c <HAL_DMA_Start_IT>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8008654:	2240      	movs	r2, #64	; 0x40
 8008656:	682b      	ldr	r3, [r5, #0]
 8008658:	6819      	ldr	r1, [r3, #0]
 800865a:	4211      	tst	r1, r2
 800865c:	d102      	bne.n	8008664 <HAL_SPI_Receive_DMA+0xe4>
    __HAL_SPI_ENABLE(hspi);
 800865e:	6819      	ldr	r1, [r3, #0]
 8008660:	430a      	orrs	r2, r1
 8008662:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 8008664:	2220      	movs	r2, #32
 8008666:	6859      	ldr	r1, [r3, #4]
  HAL_StatusTypeDef errorcode = HAL_OK;
 8008668:	2000      	movs	r0, #0
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 800866a:	430a      	orrs	r2, r1
 800866c:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 800866e:	2201      	movs	r2, #1
 8008670:	6859      	ldr	r1, [r3, #4]
 8008672:	430a      	orrs	r2, r1
 8008674:	605a      	str	r2, [r3, #4]
  __HAL_UNLOCK(hspi);
 8008676:	2300      	movs	r3, #0
 8008678:	7033      	strb	r3, [r6, #0]
  return errorcode;
 800867a:	e795      	b.n	80085a8 <HAL_SPI_Receive_DMA+0x28>
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800867c:	6853      	ldr	r3, [r2, #4]
 800867e:	469c      	mov	ip, r3
 8008680:	2380      	movs	r3, #128	; 0x80
 8008682:	4667      	mov	r7, ip
 8008684:	015b      	lsls	r3, r3, #5
 8008686:	433b      	orrs	r3, r7
 8008688:	6053      	str	r3, [r2, #4]
    if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 800868a:	2380      	movs	r3, #128	; 0x80
 800868c:	6947      	ldr	r7, [r0, #20]
 800868e:	00db      	lsls	r3, r3, #3
 8008690:	429f      	cmp	r7, r3
 8008692:	d1ce      	bne.n	8008632 <HAL_SPI_Receive_DMA+0xb2>
      CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8008694:	6853      	ldr	r3, [r2, #4]
 8008696:	4f0f      	ldr	r7, [pc, #60]	; (80086d4 <HAL_SPI_Receive_DMA+0x154>)
 8008698:	403b      	ands	r3, r7
 800869a:	6053      	str	r3, [r2, #4]
      if ((hspi->RxXferCount & 0x1U) == 0x0U)
 800869c:	002b      	movs	r3, r5
 800869e:	3308      	adds	r3, #8
 80086a0:	8fdf      	ldrh	r7, [r3, #62]	; 0x3e
 80086a2:	07ff      	lsls	r7, r7, #31
 80086a4:	d406      	bmi.n	80086b4 <HAL_SPI_Receive_DMA+0x134>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 80086a6:	6857      	ldr	r7, [r2, #4]
 80086a8:	403c      	ands	r4, r7
 80086aa:	6054      	str	r4, [r2, #4]
        hspi->RxXferCount = hspi->RxXferCount >> 1U;
 80086ac:	8fdc      	ldrh	r4, [r3, #62]	; 0x3e
 80086ae:	0864      	lsrs	r4, r4, #1
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 80086b0:	87dc      	strh	r4, [r3, #62]	; 0x3e
 80086b2:	e7be      	b.n	8008632 <HAL_SPI_Receive_DMA+0xb2>
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 80086b4:	6854      	ldr	r4, [r2, #4]
 80086b6:	46a4      	mov	ip, r4
 80086b8:	2480      	movs	r4, #128	; 0x80
 80086ba:	4667      	mov	r7, ip
 80086bc:	01a4      	lsls	r4, r4, #6
 80086be:	433c      	orrs	r4, r7
 80086c0:	6054      	str	r4, [r2, #4]
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 80086c2:	8fdc      	ldrh	r4, [r3, #62]	; 0x3e
 80086c4:	0864      	lsrs	r4, r4, #1
 80086c6:	3401      	adds	r4, #1
 80086c8:	e7f2      	b.n	80086b0 <HAL_SPI_Receive_DMA+0x130>
 80086ca:	46c0      	nop			; (mov r8, r8)
 80086cc:	ffffbfff 	.word	0xffffbfff
 80086d0:	ffffdfff 	.word	0xffffdfff
 80086d4:	ffffefff 	.word	0xffffefff
 80086d8:	08008725 	.word	0x08008725
 80086dc:	080087d1 	.word	0x080087d1
 80086e0:	0800873d 	.word	0x0800873d

080086e4 <HAL_SPI_DMAStop>:
{
 80086e4:	b510      	push	{r4, lr}
 80086e6:	0004      	movs	r4, r0
  if (hspi->hdmatx != NULL)
 80086e8:	6d40      	ldr	r0, [r0, #84]	; 0x54
 80086ea:	2800      	cmp	r0, #0
 80086ec:	d001      	beq.n	80086f2 <HAL_SPI_DMAStop+0xe>
    HAL_DMA_Abort(hspi->hdmatx);
 80086ee:	f7ff f871 	bl	80077d4 <HAL_DMA_Abort>
  if (hspi->hdmarx != NULL)
 80086f2:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80086f4:	2800      	cmp	r0, #0
 80086f6:	d001      	beq.n	80086fc <HAL_SPI_DMAStop+0x18>
    HAL_DMA_Abort(hspi->hdmarx);
 80086f8:	f7ff f86c 	bl	80077d4 <HAL_DMA_Abort>
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 80086fc:	2103      	movs	r1, #3
 80086fe:	6822      	ldr	r2, [r4, #0]
  hspi->State = HAL_SPI_STATE_READY;
 8008700:	345d      	adds	r4, #93	; 0x5d
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008702:	6853      	ldr	r3, [r2, #4]
}
 8008704:	2000      	movs	r0, #0
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008706:	438b      	bics	r3, r1
 8008708:	6053      	str	r3, [r2, #4]
  hspi->State = HAL_SPI_STATE_READY;
 800870a:	2301      	movs	r3, #1
 800870c:	7023      	strb	r3, [r4, #0]
}
 800870e:	bd10      	pop	{r4, pc}

08008710 <HAL_SPI_TxCpltCallback>:
 8008710:	4770      	bx	lr

08008712 <HAL_SPI_RxCpltCallback>:
 8008712:	4770      	bx	lr

08008714 <HAL_SPI_TxRxCpltCallback>:
 8008714:	4770      	bx	lr

08008716 <HAL_SPI_TxHalfCpltCallback>:
 8008716:	4770      	bx	lr

08008718 <SPI_DMAHalfTransmitCplt>:
{
 8008718:	b510      	push	{r4, lr}
  HAL_SPI_TxHalfCpltCallback(hspi);
 800871a:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800871c:	f7ff fffb 	bl	8008716 <HAL_SPI_TxHalfCpltCallback>
}
 8008720:	bd10      	pop	{r4, pc}

08008722 <HAL_SPI_RxHalfCpltCallback>:
 8008722:	4770      	bx	lr

08008724 <SPI_DMAHalfReceiveCplt>:
{
 8008724:	b510      	push	{r4, lr}
  HAL_SPI_RxHalfCpltCallback(hspi);
 8008726:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8008728:	f7ff fffb 	bl	8008722 <HAL_SPI_RxHalfCpltCallback>
}
 800872c:	bd10      	pop	{r4, pc}

0800872e <HAL_SPI_TxRxHalfCpltCallback>:
 800872e:	4770      	bx	lr

08008730 <SPI_DMAHalfTransmitReceiveCplt>:
{
 8008730:	b510      	push	{r4, lr}
  HAL_SPI_TxRxHalfCpltCallback(hspi);
 8008732:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8008734:	f7ff fffb 	bl	800872e <HAL_SPI_TxRxHalfCpltCallback>
}
 8008738:	bd10      	pop	{r4, pc}

0800873a <HAL_SPI_ErrorCallback>:
 800873a:	4770      	bx	lr

0800873c <SPI_DMAError>:
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800873c:	2103      	movs	r1, #3
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800873e:	6a40      	ldr	r0, [r0, #36]	; 0x24
{
 8008740:	b510      	push	{r4, lr}
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008742:	6802      	ldr	r2, [r0, #0]
 8008744:	6853      	ldr	r3, [r2, #4]
 8008746:	438b      	bics	r3, r1
 8008748:	6053      	str	r3, [r2, #4]
  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 800874a:	2310      	movs	r3, #16
 800874c:	6e02      	ldr	r2, [r0, #96]	; 0x60
 800874e:	4313      	orrs	r3, r2
 8008750:	6603      	str	r3, [r0, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_READY;
 8008752:	0003      	movs	r3, r0
 8008754:	2201      	movs	r2, #1
 8008756:	335d      	adds	r3, #93	; 0x5d
 8008758:	701a      	strb	r2, [r3, #0]
  HAL_SPI_ErrorCallback(hspi);
 800875a:	f7ff ffee 	bl	800873a <HAL_SPI_ErrorCallback>
}
 800875e:	bd10      	pop	{r4, pc}

08008760 <SPI_DMATransmitCplt>:
{
 8008760:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8008762:	0005      	movs	r5, r0
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008764:	6a44      	ldr	r4, [r0, #36]	; 0x24
  tickstart = HAL_GetTick();
 8008766:	f7fe fbff 	bl	8006f68 <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 800876a:	682b      	ldr	r3, [r5, #0]
 800876c:	2520      	movs	r5, #32
 800876e:	681b      	ldr	r3, [r3, #0]
  tickstart = HAL_GetTick();
 8008770:	0002      	movs	r2, r0
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8008772:	422b      	tst	r3, r5
 8008774:	d127      	bne.n	80087c6 <SPI_DMATransmitCplt+0x66>
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8008776:	2002      	movs	r0, #2
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 8008778:	6823      	ldr	r3, [r4, #0]
 800877a:	6859      	ldr	r1, [r3, #4]
 800877c:	43a9      	bics	r1, r5
 800877e:	6059      	str	r1, [r3, #4]
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8008780:	6859      	ldr	r1, [r3, #4]
 8008782:	4381      	bics	r1, r0
 8008784:	6059      	str	r1, [r3, #4]
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008786:	0020      	movs	r0, r4
 8008788:	2164      	movs	r1, #100	; 0x64
 800878a:	f7ff fd06 	bl	800819a <SPI_EndRxTxTransaction>
 800878e:	2800      	cmp	r0, #0
 8008790:	d002      	beq.n	8008798 <SPI_DMATransmitCplt+0x38>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8008792:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8008794:	431d      	orrs	r5, r3
 8008796:	6625      	str	r5, [r4, #96]	; 0x60
    if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8008798:	68a3      	ldr	r3, [r4, #8]
 800879a:	2b00      	cmp	r3, #0
 800879c:	d106      	bne.n	80087ac <SPI_DMATransmitCplt+0x4c>
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800879e:	9301      	str	r3, [sp, #4]
 80087a0:	6823      	ldr	r3, [r4, #0]
 80087a2:	68da      	ldr	r2, [r3, #12]
 80087a4:	9201      	str	r2, [sp, #4]
 80087a6:	689b      	ldr	r3, [r3, #8]
 80087a8:	9301      	str	r3, [sp, #4]
 80087aa:	9b01      	ldr	r3, [sp, #4]
    hspi->TxXferCount = 0U;
 80087ac:	2300      	movs	r3, #0
 80087ae:	87e3      	strh	r3, [r4, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 80087b0:	0023      	movs	r3, r4
 80087b2:	2201      	movs	r2, #1
 80087b4:	335d      	adds	r3, #93	; 0x5d
 80087b6:	701a      	strb	r2, [r3, #0]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80087b8:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80087ba:	2b00      	cmp	r3, #0
 80087bc:	d003      	beq.n	80087c6 <SPI_DMATransmitCplt+0x66>
      HAL_SPI_ErrorCallback(hspi);
 80087be:	0020      	movs	r0, r4
 80087c0:	f7ff ffbb 	bl	800873a <HAL_SPI_ErrorCallback>
}
 80087c4:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
  HAL_SPI_TxCpltCallback(hspi);
 80087c6:	0020      	movs	r0, r4
 80087c8:	f7ff ffa2 	bl	8008710 <HAL_SPI_TxCpltCallback>
 80087cc:	e7fa      	b.n	80087c4 <SPI_DMATransmitCplt+0x64>
	...

080087d0 <SPI_DMAReceiveCplt>:
{
 80087d0:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO uint16_t tmpreg = 0U;
 80087d2:	250e      	movs	r5, #14
 80087d4:	2300      	movs	r3, #0
{
 80087d6:	0006      	movs	r6, r0
 80087d8:	b085      	sub	sp, #20
  __IO uint16_t tmpreg = 0U;
 80087da:	446d      	add	r5, sp
 80087dc:	802b      	strh	r3, [r5, #0]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80087de:	6a44      	ldr	r4, [r0, #36]	; 0x24
  tickstart = HAL_GetTick();
 80087e0:	f7fe fbc2 	bl	8006f68 <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 80087e4:	2120      	movs	r1, #32
 80087e6:	6833      	ldr	r3, [r6, #0]
  tickstart = HAL_GetTick();
 80087e8:	0007      	movs	r7, r0
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 80087ea:	681b      	ldr	r3, [r3, #0]
 80087ec:	420b      	tst	r3, r1
 80087ee:	d15b      	bne.n	80088a8 <SPI_DMAReceiveCplt+0xd8>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 80087f0:	6822      	ldr	r2, [r4, #0]
 80087f2:	6853      	ldr	r3, [r2, #4]
 80087f4:	438b      	bics	r3, r1
 80087f6:	6053      	str	r3, [r2, #4]
    if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80087f8:	2380      	movs	r3, #128	; 0x80
 80087fa:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80087fc:	019b      	lsls	r3, r3, #6
 80087fe:	429a      	cmp	r2, r3
 8008800:	d116      	bne.n	8008830 <SPI_DMAReceiveCplt+0x60>
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008802:	2201      	movs	r2, #1
 8008804:	9000      	str	r0, [sp, #0]
 8008806:	2364      	movs	r3, #100	; 0x64
 8008808:	0011      	movs	r1, r2
 800880a:	0020      	movs	r0, r4
 800880c:	f7ff fc40 	bl	8008090 <SPI_WaitFlagStateUntilTimeout>
 8008810:	2800      	cmp	r0, #0
 8008812:	d003      	beq.n	800881c <SPI_DMAReceiveCplt+0x4c>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008814:	2302      	movs	r3, #2
 8008816:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8008818:	4313      	orrs	r3, r2
 800881a:	6623      	str	r3, [r4, #96]	; 0x60
      if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800881c:	22e0      	movs	r2, #224	; 0xe0
 800881e:	68e1      	ldr	r1, [r4, #12]
 8008820:	6823      	ldr	r3, [r4, #0]
 8008822:	00d2      	lsls	r2, r2, #3
 8008824:	4291      	cmp	r1, r2
 8008826:	d92a      	bls.n	800887e <SPI_DMAReceiveCplt+0xae>
        tmpreg = hspi->Instance->DR;
 8008828:	68db      	ldr	r3, [r3, #12]
 800882a:	b29b      	uxth	r3, r3
          tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 800882c:	802b      	strh	r3, [r5, #0]
          UNUSED(tmpreg);
 800882e:	882b      	ldrh	r3, [r5, #0]
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008830:	2103      	movs	r1, #3
 8008832:	6822      	ldr	r2, [r4, #0]
    if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008834:	0020      	movs	r0, r4
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008836:	6853      	ldr	r3, [r2, #4]
 8008838:	438b      	bics	r3, r1
 800883a:	6053      	str	r3, [r2, #4]
    if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 800883c:	3161      	adds	r1, #97	; 0x61
 800883e:	003a      	movs	r2, r7
 8008840:	f7ff fc6b 	bl	800811a <SPI_EndRxTransaction>
 8008844:	2800      	cmp	r0, #0
 8008846:	d001      	beq.n	800884c <SPI_DMAReceiveCplt+0x7c>
      hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8008848:	2320      	movs	r3, #32
 800884a:	6623      	str	r3, [r4, #96]	; 0x60
    hspi->RxXferCount = 0U;
 800884c:	0023      	movs	r3, r4
 800884e:	2200      	movs	r2, #0
 8008850:	3308      	adds	r3, #8
 8008852:	87da      	strh	r2, [r3, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 8008854:	3201      	adds	r2, #1
 8008856:	3355      	adds	r3, #85	; 0x55
 8008858:	701a      	strb	r2, [r3, #0]
    if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 800885a:	6822      	ldr	r2, [r4, #0]
 800885c:	6893      	ldr	r3, [r2, #8]
 800885e:	06db      	lsls	r3, r3, #27
 8008860:	d505      	bpl.n	800886e <SPI_DMAReceiveCplt+0x9e>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008862:	2302      	movs	r3, #2
 8008864:	6e21      	ldr	r1, [r4, #96]	; 0x60
 8008866:	430b      	orrs	r3, r1
 8008868:	6623      	str	r3, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 800886a:	4b11      	ldr	r3, [pc, #68]	; (80088b0 <SPI_DMAReceiveCplt+0xe0>)
 800886c:	6093      	str	r3, [r2, #8]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800886e:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8008870:	2b00      	cmp	r3, #0
 8008872:	d019      	beq.n	80088a8 <SPI_DMAReceiveCplt+0xd8>
      HAL_SPI_ErrorCallback(hspi);
 8008874:	0020      	movs	r0, r4
 8008876:	f7ff ff60 	bl	800873a <HAL_SPI_ErrorCallback>
}
 800887a:	b005      	add	sp, #20
 800887c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 800887e:	7b1b      	ldrb	r3, [r3, #12]
        if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8008880:	6b26      	ldr	r6, [r4, #48]	; 0x30
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8008882:	802b      	strh	r3, [r5, #0]
        UNUSED(tmpreg);
 8008884:	882b      	ldrh	r3, [r5, #0]
        if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8008886:	2e02      	cmp	r6, #2
 8008888:	d1d2      	bne.n	8008830 <SPI_DMAReceiveCplt+0x60>
          if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 800888a:	2201      	movs	r2, #1
 800888c:	9700      	str	r7, [sp, #0]
 800888e:	2364      	movs	r3, #100	; 0x64
 8008890:	0011      	movs	r1, r2
 8008892:	0020      	movs	r0, r4
 8008894:	f7ff fbfc 	bl	8008090 <SPI_WaitFlagStateUntilTimeout>
 8008898:	2800      	cmp	r0, #0
 800889a:	d002      	beq.n	80088a2 <SPI_DMAReceiveCplt+0xd2>
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 800889c:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800889e:	431e      	orrs	r6, r3
 80088a0:	6626      	str	r6, [r4, #96]	; 0x60
          tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 80088a2:	6823      	ldr	r3, [r4, #0]
 80088a4:	7b1b      	ldrb	r3, [r3, #12]
 80088a6:	e7c1      	b.n	800882c <SPI_DMAReceiveCplt+0x5c>
  HAL_SPI_RxCpltCallback(hspi);
 80088a8:	0020      	movs	r0, r4
 80088aa:	f7ff ff32 	bl	8008712 <HAL_SPI_RxCpltCallback>
 80088ae:	e7e4      	b.n	800887a <SPI_DMAReceiveCplt+0xaa>
 80088b0:	0000ffef 	.word	0x0000ffef

080088b4 <SPI_DMATransmitReceiveCplt>:
{
 80088b4:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO int16_t tmpreg = 0U;
 80088b6:	250e      	movs	r5, #14
 80088b8:	2300      	movs	r3, #0
{
 80088ba:	0007      	movs	r7, r0
 80088bc:	b085      	sub	sp, #20
  __IO int16_t tmpreg = 0U;
 80088be:	446d      	add	r5, sp
 80088c0:	802b      	strh	r3, [r5, #0]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80088c2:	6a44      	ldr	r4, [r0, #36]	; 0x24
  tickstart = HAL_GetTick();
 80088c4:	f7fe fb50 	bl	8006f68 <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 80088c8:	2120      	movs	r1, #32
 80088ca:	683b      	ldr	r3, [r7, #0]
  tickstart = HAL_GetTick();
 80088cc:	0006      	movs	r6, r0
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 80088ce:	681b      	ldr	r3, [r3, #0]
 80088d0:	420b      	tst	r3, r1
 80088d2:	d160      	bne.n	8008996 <SPI_DMATransmitReceiveCplt+0xe2>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 80088d4:	6822      	ldr	r2, [r4, #0]
 80088d6:	6853      	ldr	r3, [r2, #4]
 80088d8:	438b      	bics	r3, r1
 80088da:	6053      	str	r3, [r2, #4]
    if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80088dc:	2380      	movs	r3, #128	; 0x80
 80088de:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80088e0:	019b      	lsls	r3, r3, #6
 80088e2:	429a      	cmp	r2, r3
 80088e4:	d11a      	bne.n	800891c <SPI_DMATransmitReceiveCplt+0x68>
      if ((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_8BIT))
 80088e6:	23e0      	movs	r3, #224	; 0xe0
 80088e8:	68e2      	ldr	r2, [r4, #12]
 80088ea:	00db      	lsls	r3, r3, #3
 80088ec:	429a      	cmp	r2, r3
 80088ee:	d13f      	bne.n	8008970 <SPI_DMATransmitReceiveCplt+0xbc>
 80088f0:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80088f2:	2b01      	cmp	r3, #1
 80088f4:	d13c      	bne.n	8008970 <SPI_DMATransmitReceiveCplt+0xbc>
        if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_QUARTER_FULL, SPI_DEFAULT_TIMEOUT,
 80088f6:	2280      	movs	r2, #128	; 0x80
 80088f8:	21c0      	movs	r1, #192	; 0xc0
 80088fa:	9000      	str	r0, [sp, #0]
 80088fc:	3363      	adds	r3, #99	; 0x63
 80088fe:	0092      	lsls	r2, r2, #2
 8008900:	00c9      	lsls	r1, r1, #3
 8008902:	0020      	movs	r0, r4
 8008904:	f7ff fbe2 	bl	80080cc <SPI_WaitFifoStateUntilTimeout>
 8008908:	2800      	cmp	r0, #0
 800890a:	d003      	beq.n	8008914 <SPI_DMATransmitReceiveCplt+0x60>
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 800890c:	2302      	movs	r3, #2
 800890e:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8008910:	4313      	orrs	r3, r2
 8008912:	6623      	str	r3, [r4, #96]	; 0x60
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8008914:	6823      	ldr	r3, [r4, #0]
 8008916:	7b1b      	ldrb	r3, [r3, #12]
        tmpreg = hspi->Instance->DR;
 8008918:	802b      	strh	r3, [r5, #0]
        UNUSED(tmpreg);
 800891a:	882b      	ldrh	r3, [r5, #0]
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 800891c:	0032      	movs	r2, r6
 800891e:	2164      	movs	r1, #100	; 0x64
 8008920:	0020      	movs	r0, r4
 8008922:	f7ff fc3a 	bl	800819a <SPI_EndRxTxTransaction>
 8008926:	2800      	cmp	r0, #0
 8008928:	d003      	beq.n	8008932 <SPI_DMATransmitReceiveCplt+0x7e>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800892a:	2320      	movs	r3, #32
 800892c:	6e22      	ldr	r2, [r4, #96]	; 0x60
 800892e:	4313      	orrs	r3, r2
 8008930:	6623      	str	r3, [r4, #96]	; 0x60
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008932:	2103      	movs	r1, #3
 8008934:	6823      	ldr	r3, [r4, #0]
 8008936:	685a      	ldr	r2, [r3, #4]
 8008938:	438a      	bics	r2, r1
    hspi->RxXferCount = 0U;
 800893a:	0021      	movs	r1, r4
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800893c:	605a      	str	r2, [r3, #4]
    hspi->TxXferCount = 0U;
 800893e:	2200      	movs	r2, #0
    hspi->RxXferCount = 0U;
 8008940:	3108      	adds	r1, #8
    hspi->TxXferCount = 0U;
 8008942:	87e2      	strh	r2, [r4, #62]	; 0x3e
    hspi->RxXferCount = 0U;
 8008944:	87ca      	strh	r2, [r1, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 8008946:	0022      	movs	r2, r4
 8008948:	2101      	movs	r1, #1
 800894a:	325d      	adds	r2, #93	; 0x5d
 800894c:	7011      	strb	r1, [r2, #0]
    if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 800894e:	689a      	ldr	r2, [r3, #8]
 8008950:	06d2      	lsls	r2, r2, #27
 8008952:	d505      	bpl.n	8008960 <SPI_DMATransmitReceiveCplt+0xac>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008954:	2202      	movs	r2, #2
 8008956:	6e21      	ldr	r1, [r4, #96]	; 0x60
 8008958:	430a      	orrs	r2, r1
 800895a:	6622      	str	r2, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 800895c:	4a10      	ldr	r2, [pc, #64]	; (80089a0 <SPI_DMATransmitReceiveCplt+0xec>)
 800895e:	609a      	str	r2, [r3, #8]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8008960:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8008962:	2b00      	cmp	r3, #0
 8008964:	d017      	beq.n	8008996 <SPI_DMATransmitReceiveCplt+0xe2>
      HAL_SPI_ErrorCallback(hspi);
 8008966:	0020      	movs	r0, r4
 8008968:	f7ff fee7 	bl	800873a <HAL_SPI_ErrorCallback>
}
 800896c:	b005      	add	sp, #20
 800896e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_HALF_FULL, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008970:	2280      	movs	r2, #128	; 0x80
 8008972:	21c0      	movs	r1, #192	; 0xc0
 8008974:	9600      	str	r6, [sp, #0]
 8008976:	2364      	movs	r3, #100	; 0x64
 8008978:	00d2      	lsls	r2, r2, #3
 800897a:	00c9      	lsls	r1, r1, #3
 800897c:	0020      	movs	r0, r4
 800897e:	f7ff fba5 	bl	80080cc <SPI_WaitFifoStateUntilTimeout>
 8008982:	2800      	cmp	r0, #0
 8008984:	d003      	beq.n	800898e <SPI_DMATransmitReceiveCplt+0xda>
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008986:	2302      	movs	r3, #2
 8008988:	6e22      	ldr	r2, [r4, #96]	; 0x60
 800898a:	4313      	orrs	r3, r2
 800898c:	6623      	str	r3, [r4, #96]	; 0x60
        tmpreg = hspi->Instance->DR;
 800898e:	6823      	ldr	r3, [r4, #0]
 8008990:	68db      	ldr	r3, [r3, #12]
 8008992:	b21b      	sxth	r3, r3
 8008994:	e7c0      	b.n	8008918 <SPI_DMATransmitReceiveCplt+0x64>
  HAL_SPI_TxRxCpltCallback(hspi);
 8008996:	0020      	movs	r0, r4
 8008998:	f7ff febc 	bl	8008714 <HAL_SPI_TxRxCpltCallback>
 800899c:	e7e6      	b.n	800896c <SPI_DMATransmitReceiveCplt+0xb8>
 800899e:	46c0      	nop			; (mov r8, r8)
 80089a0:	0000ffef 	.word	0x0000ffef

080089a4 <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx = 0U;
  uint32_t tmpccer = 0U;
  uint32_t tmpcr2 = 0U;

   /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80089a4:	2201      	movs	r2, #1
 80089a6:	6a03      	ldr	r3, [r0, #32]
{
 80089a8:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80089aa:	4393      	bics	r3, r2
 80089ac:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80089ae:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80089b0:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 80089b2:	6985      	ldr	r5, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 80089b4:	3272      	adds	r2, #114	; 0x72
 80089b6:	4395      	bics	r5, r2
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80089b8:	680a      	ldr	r2, [r1, #0]
 80089ba:	4315      	orrs	r5, r2

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 80089bc:	2202      	movs	r2, #2
 80089be:	4393      	bics	r3, r2
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 80089c0:	688a      	ldr	r2, [r1, #8]
 80089c2:	4313      	orrs	r3, r2

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 80089c4:	4a14      	ldr	r2, [pc, #80]	; (8008a18 <TIM_OC1_SetConfig+0x74>)
 80089c6:	4290      	cmp	r0, r2
 80089c8:	d008      	beq.n	80089dc <TIM_OC1_SetConfig+0x38>
 80089ca:	4e14      	ldr	r6, [pc, #80]	; (8008a1c <TIM_OC1_SetConfig+0x78>)
 80089cc:	42b0      	cmp	r0, r6
 80089ce:	d005      	beq.n	80089dc <TIM_OC1_SetConfig+0x38>
 80089d0:	4e13      	ldr	r6, [pc, #76]	; (8008a20 <TIM_OC1_SetConfig+0x7c>)
 80089d2:	42b0      	cmp	r0, r6
 80089d4:	d002      	beq.n	80089dc <TIM_OC1_SetConfig+0x38>
 80089d6:	4e13      	ldr	r6, [pc, #76]	; (8008a24 <TIM_OC1_SetConfig+0x80>)
 80089d8:	42b0      	cmp	r0, r6
 80089da:	d116      	bne.n	8008a0a <TIM_OC1_SetConfig+0x66>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 80089dc:	2608      	movs	r6, #8
 80089de:	43b3      	bics	r3, r6
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 80089e0:	68ce      	ldr	r6, [r1, #12]
 80089e2:	4333      	orrs	r3, r6
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 80089e4:	2604      	movs	r6, #4
 80089e6:	43b3      	bics	r3, r6
  }

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 80089e8:	4290      	cmp	r0, r2
 80089ea:	d008      	beq.n	80089fe <TIM_OC1_SetConfig+0x5a>
 80089ec:	4a0b      	ldr	r2, [pc, #44]	; (8008a1c <TIM_OC1_SetConfig+0x78>)
 80089ee:	4290      	cmp	r0, r2
 80089f0:	d005      	beq.n	80089fe <TIM_OC1_SetConfig+0x5a>
 80089f2:	4a0b      	ldr	r2, [pc, #44]	; (8008a20 <TIM_OC1_SetConfig+0x7c>)
 80089f4:	4290      	cmp	r0, r2
 80089f6:	d002      	beq.n	80089fe <TIM_OC1_SetConfig+0x5a>
 80089f8:	4a0a      	ldr	r2, [pc, #40]	; (8008a24 <TIM_OC1_SetConfig+0x80>)
 80089fa:	4290      	cmp	r0, r2
 80089fc:	d105      	bne.n	8008a0a <TIM_OC1_SetConfig+0x66>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
 80089fe:	4a0a      	ldr	r2, [pc, #40]	; (8008a28 <TIM_OC1_SetConfig+0x84>)
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8008a00:	698e      	ldr	r6, [r1, #24]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8008a02:	4022      	ands	r2, r4
    tmpcr2 |= OC_Config->OCNIdleState;
 8008a04:	694c      	ldr	r4, [r1, #20]
 8008a06:	4334      	orrs	r4, r6
 8008a08:	4314      	orrs	r4, r2

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8008a0a:	684a      	ldr	r2, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8008a0c:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 8008a0e:	6185      	str	r5, [r0, #24]
  TIMx->CCR1 = OC_Config->Pulse;
 8008a10:	6342      	str	r2, [r0, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8008a12:	6203      	str	r3, [r0, #32]
}
 8008a14:	bd70      	pop	{r4, r5, r6, pc}
 8008a16:	46c0      	nop			; (mov r8, r8)
 8008a18:	40012c00 	.word	0x40012c00
 8008a1c:	40014000 	.word	0x40014000
 8008a20:	40014400 	.word	0x40014400
 8008a24:	40014800 	.word	0x40014800
 8008a28:	fffffcff 	.word	0xfffffcff

08008a2c <TIM_OC3_SetConfig>:
  * @param  TIMx  to select the TIM peripheral
  * @param  OC_Config : The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8008a2c:	b570      	push	{r4, r5, r6, lr}
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8008a2e:	2573      	movs	r5, #115	; 0x73
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8008a30:	6a03      	ldr	r3, [r0, #32]
 8008a32:	4a17      	ldr	r2, [pc, #92]	; (8008a90 <TIM_OC3_SetConfig+0x64>)
 8008a34:	4013      	ands	r3, r2
 8008a36:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8008a38:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 8008a3a:	6842      	ldr	r2, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
 8008a3c:	69c4      	ldr	r4, [r0, #28]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8008a3e:	43ac      	bics	r4, r5
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8008a40:	680d      	ldr	r5, [r1, #0]
 8008a42:	432c      	orrs	r4, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8008a44:	4d13      	ldr	r5, [pc, #76]	; (8008a94 <TIM_OC3_SetConfig+0x68>)
 8008a46:	402b      	ands	r3, r5
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8008a48:	688d      	ldr	r5, [r1, #8]
 8008a4a:	022d      	lsls	r5, r5, #8
 8008a4c:	432b      	orrs	r3, r5

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8008a4e:	4d12      	ldr	r5, [pc, #72]	; (8008a98 <TIM_OC3_SetConfig+0x6c>)
 8008a50:	42a8      	cmp	r0, r5
 8008a52:	d10e      	bne.n	8008a72 <TIM_OC3_SetConfig+0x46>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 8008a54:	4d11      	ldr	r5, [pc, #68]	; (8008a9c <TIM_OC3_SetConfig+0x70>)
 8008a56:	401d      	ands	r5, r3
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8008a58:	68cb      	ldr	r3, [r1, #12]
 8008a5a:	021b      	lsls	r3, r3, #8
 8008a5c:	432b      	orrs	r3, r5
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 8008a5e:	4d10      	ldr	r5, [pc, #64]	; (8008aa0 <TIM_OC3_SetConfig+0x74>)
 8008a60:	402b      	ands	r3, r5
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8008a62:	4d10      	ldr	r5, [pc, #64]	; (8008aa4 <TIM_OC3_SetConfig+0x78>)
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8008a64:	694e      	ldr	r6, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8008a66:	4015      	ands	r5, r2
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8008a68:	698a      	ldr	r2, [r1, #24]
 8008a6a:	4332      	orrs	r2, r6
 8008a6c:	0112      	lsls	r2, r2, #4
 8008a6e:	432a      	orrs	r2, r5
 8008a70:	e008      	b.n	8008a84 <TIM_OC3_SetConfig+0x58>
  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8008a72:	4d0d      	ldr	r5, [pc, #52]	; (8008aa8 <TIM_OC3_SetConfig+0x7c>)
 8008a74:	42a8      	cmp	r0, r5
 8008a76:	d0f4      	beq.n	8008a62 <TIM_OC3_SetConfig+0x36>
 8008a78:	4d0c      	ldr	r5, [pc, #48]	; (8008aac <TIM_OC3_SetConfig+0x80>)
 8008a7a:	42a8      	cmp	r0, r5
 8008a7c:	d0f1      	beq.n	8008a62 <TIM_OC3_SetConfig+0x36>
 8008a7e:	4d0c      	ldr	r5, [pc, #48]	; (8008ab0 <TIM_OC3_SetConfig+0x84>)
 8008a80:	42a8      	cmp	r0, r5
 8008a82:	d0ee      	beq.n	8008a62 <TIM_OC3_SetConfig+0x36>
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8008a84:	6042      	str	r2, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8008a86:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 8008a88:	61c4      	str	r4, [r0, #28]
  TIMx->CCR3 = OC_Config->Pulse;
 8008a8a:	63c2      	str	r2, [r0, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8008a8c:	6203      	str	r3, [r0, #32]
}
 8008a8e:	bd70      	pop	{r4, r5, r6, pc}
 8008a90:	fffffeff 	.word	0xfffffeff
 8008a94:	fffffdff 	.word	0xfffffdff
 8008a98:	40012c00 	.word	0x40012c00
 8008a9c:	fffff7ff 	.word	0xfffff7ff
 8008aa0:	fffffbff 	.word	0xfffffbff
 8008aa4:	ffffcfff 	.word	0xffffcfff
 8008aa8:	40014000 	.word	0x40014000
 8008aac:	40014400 	.word	0x40014400
 8008ab0:	40014800 	.word	0x40014800

08008ab4 <TIM_OC4_SetConfig>:
  uint32_t tmpccmrx = 0U;
  uint32_t tmpccer = 0U;
  uint32_t tmpcr2 = 0U;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8008ab4:	6a03      	ldr	r3, [r0, #32]
 8008ab6:	4a14      	ldr	r2, [pc, #80]	; (8008b08 <TIM_OC4_SetConfig+0x54>)
{
 8008ab8:	b530      	push	{r4, r5, lr}
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8008aba:	4013      	ands	r3, r2
 8008abc:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8008abe:	6a02      	ldr	r2, [r0, #32]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8008ac0:	4c12      	ldr	r4, [pc, #72]	; (8008b0c <TIM_OC4_SetConfig+0x58>)
  tmpcr2 =  TIMx->CR2;
 8008ac2:	6843      	ldr	r3, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
 8008ac4:	69c5      	ldr	r5, [r0, #28]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8008ac6:	4025      	ands	r5, r4

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8008ac8:	680c      	ldr	r4, [r1, #0]
 8008aca:	0224      	lsls	r4, r4, #8
 8008acc:	4325      	orrs	r5, r4

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8008ace:	4c10      	ldr	r4, [pc, #64]	; (8008b10 <TIM_OC4_SetConfig+0x5c>)
 8008ad0:	4022      	ands	r2, r4
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8008ad2:	688c      	ldr	r4, [r1, #8]
 8008ad4:	0324      	lsls	r4, r4, #12
 8008ad6:	4322      	orrs	r2, r4

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8008ad8:	4c0e      	ldr	r4, [pc, #56]	; (8008b14 <TIM_OC4_SetConfig+0x60>)
 8008ada:	42a0      	cmp	r0, r4
 8008adc:	d008      	beq.n	8008af0 <TIM_OC4_SetConfig+0x3c>
 8008ade:	4c0e      	ldr	r4, [pc, #56]	; (8008b18 <TIM_OC4_SetConfig+0x64>)
 8008ae0:	42a0      	cmp	r0, r4
 8008ae2:	d005      	beq.n	8008af0 <TIM_OC4_SetConfig+0x3c>
 8008ae4:	4c0d      	ldr	r4, [pc, #52]	; (8008b1c <TIM_OC4_SetConfig+0x68>)
 8008ae6:	42a0      	cmp	r0, r4
 8008ae8:	d002      	beq.n	8008af0 <TIM_OC4_SetConfig+0x3c>
 8008aea:	4c0d      	ldr	r4, [pc, #52]	; (8008b20 <TIM_OC4_SetConfig+0x6c>)
 8008aec:	42a0      	cmp	r0, r4
 8008aee:	d104      	bne.n	8008afa <TIM_OC4_SetConfig+0x46>
  {
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

   /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 8008af0:	4c0c      	ldr	r4, [pc, #48]	; (8008b24 <TIM_OC4_SetConfig+0x70>)
 8008af2:	4023      	ands	r3, r4
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8008af4:	694c      	ldr	r4, [r1, #20]
 8008af6:	01a4      	lsls	r4, r4, #6
 8008af8:	4323      	orrs	r3, r4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8008afa:	6043      	str	r3, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8008afc:	684b      	ldr	r3, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 8008afe:	61c5      	str	r5, [r0, #28]
  TIMx->CCR4 = OC_Config->Pulse;
 8008b00:	6403      	str	r3, [r0, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8008b02:	6202      	str	r2, [r0, #32]
}
 8008b04:	bd30      	pop	{r4, r5, pc}
 8008b06:	46c0      	nop			; (mov r8, r8)
 8008b08:	ffffefff 	.word	0xffffefff
 8008b0c:	ffff8cff 	.word	0xffff8cff
 8008b10:	ffffdfff 	.word	0xffffdfff
 8008b14:	40012c00 	.word	0x40012c00
 8008b18:	40014000 	.word	0x40014000
 8008b1c:	40014400 	.word	0x40014400
 8008b20:	40014800 	.word	0x40014800
 8008b24:	ffffbfff 	.word	0xffffbfff

08008b28 <HAL_TIM_Base_Stop_IT>:
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 8008b28:	2101      	movs	r1, #1
 8008b2a:	6803      	ldr	r3, [r0, #0]
 8008b2c:	68da      	ldr	r2, [r3, #12]
 8008b2e:	438a      	bics	r2, r1
 8008b30:	60da      	str	r2, [r3, #12]
  __HAL_TIM_DISABLE(htim);
 8008b32:	6a18      	ldr	r0, [r3, #32]
 8008b34:	4a05      	ldr	r2, [pc, #20]	; (8008b4c <HAL_TIM_Base_Stop_IT+0x24>)
 8008b36:	4210      	tst	r0, r2
 8008b38:	d106      	bne.n	8008b48 <HAL_TIM_Base_Stop_IT+0x20>
 8008b3a:	6a18      	ldr	r0, [r3, #32]
 8008b3c:	4a04      	ldr	r2, [pc, #16]	; (8008b50 <HAL_TIM_Base_Stop_IT+0x28>)
 8008b3e:	4210      	tst	r0, r2
 8008b40:	d102      	bne.n	8008b48 <HAL_TIM_Base_Stop_IT+0x20>
 8008b42:	681a      	ldr	r2, [r3, #0]
 8008b44:	438a      	bics	r2, r1
 8008b46:	601a      	str	r2, [r3, #0]
}
 8008b48:	2000      	movs	r0, #0
 8008b4a:	4770      	bx	lr
 8008b4c:	00001111 	.word	0x00001111
 8008b50:	00000444 	.word	0x00000444

08008b54 <HAL_TIM_OC_MspInit>:
 8008b54:	4770      	bx	lr
	...

08008b58 <TIM_Base_SetConfig>:
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8008b58:	4a20      	ldr	r2, [pc, #128]	; (8008bdc <TIM_Base_SetConfig+0x84>)
{
 8008b5a:	b510      	push	{r4, lr}
  tmpcr1 = TIMx->CR1;
 8008b5c:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8008b5e:	4290      	cmp	r0, r2
 8008b60:	d006      	beq.n	8008b70 <TIM_Base_SetConfig+0x18>
 8008b62:	2480      	movs	r4, #128	; 0x80
 8008b64:	05e4      	lsls	r4, r4, #23
 8008b66:	42a0      	cmp	r0, r4
 8008b68:	d002      	beq.n	8008b70 <TIM_Base_SetConfig+0x18>
 8008b6a:	4c1d      	ldr	r4, [pc, #116]	; (8008be0 <TIM_Base_SetConfig+0x88>)
 8008b6c:	42a0      	cmp	r0, r4
 8008b6e:	d10c      	bne.n	8008b8a <TIM_Base_SetConfig+0x32>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8008b70:	2470      	movs	r4, #112	; 0x70
 8008b72:	43a3      	bics	r3, r4
    tmpcr1 |= Structure->CounterMode;
 8008b74:	684c      	ldr	r4, [r1, #4]
 8008b76:	4323      	orrs	r3, r4
  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8008b78:	4290      	cmp	r0, r2
 8008b7a:	d012      	beq.n	8008ba2 <TIM_Base_SetConfig+0x4a>
 8008b7c:	2480      	movs	r4, #128	; 0x80
 8008b7e:	05e4      	lsls	r4, r4, #23
 8008b80:	42a0      	cmp	r0, r4
 8008b82:	d00e      	beq.n	8008ba2 <TIM_Base_SetConfig+0x4a>
 8008b84:	4c16      	ldr	r4, [pc, #88]	; (8008be0 <TIM_Base_SetConfig+0x88>)
 8008b86:	42a0      	cmp	r0, r4
 8008b88:	d00b      	beq.n	8008ba2 <TIM_Base_SetConfig+0x4a>
 8008b8a:	4c16      	ldr	r4, [pc, #88]	; (8008be4 <TIM_Base_SetConfig+0x8c>)
 8008b8c:	42a0      	cmp	r0, r4
 8008b8e:	d008      	beq.n	8008ba2 <TIM_Base_SetConfig+0x4a>
 8008b90:	4c15      	ldr	r4, [pc, #84]	; (8008be8 <TIM_Base_SetConfig+0x90>)
 8008b92:	42a0      	cmp	r0, r4
 8008b94:	d005      	beq.n	8008ba2 <TIM_Base_SetConfig+0x4a>
 8008b96:	4c15      	ldr	r4, [pc, #84]	; (8008bec <TIM_Base_SetConfig+0x94>)
 8008b98:	42a0      	cmp	r0, r4
 8008b9a:	d002      	beq.n	8008ba2 <TIM_Base_SetConfig+0x4a>
 8008b9c:	4c14      	ldr	r4, [pc, #80]	; (8008bf0 <TIM_Base_SetConfig+0x98>)
 8008b9e:	42a0      	cmp	r0, r4
 8008ba0:	d103      	bne.n	8008baa <TIM_Base_SetConfig+0x52>
    tmpcr1 &= ~TIM_CR1_CKD;
 8008ba2:	4c14      	ldr	r4, [pc, #80]	; (8008bf4 <TIM_Base_SetConfig+0x9c>)
 8008ba4:	4023      	ands	r3, r4
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8008ba6:	68cc      	ldr	r4, [r1, #12]
 8008ba8:	4323      	orrs	r3, r4
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8008baa:	2480      	movs	r4, #128	; 0x80
 8008bac:	43a3      	bics	r3, r4
 8008bae:	694c      	ldr	r4, [r1, #20]
 8008bb0:	4323      	orrs	r3, r4
  TIMx->CR1 = tmpcr1;
 8008bb2:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8008bb4:	688b      	ldr	r3, [r1, #8]
 8008bb6:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8008bb8:	680b      	ldr	r3, [r1, #0]
 8008bba:	6283      	str	r3, [r0, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8008bbc:	4290      	cmp	r0, r2
 8008bbe:	d008      	beq.n	8008bd2 <TIM_Base_SetConfig+0x7a>
 8008bc0:	4b09      	ldr	r3, [pc, #36]	; (8008be8 <TIM_Base_SetConfig+0x90>)
 8008bc2:	4298      	cmp	r0, r3
 8008bc4:	d005      	beq.n	8008bd2 <TIM_Base_SetConfig+0x7a>
 8008bc6:	4b09      	ldr	r3, [pc, #36]	; (8008bec <TIM_Base_SetConfig+0x94>)
 8008bc8:	4298      	cmp	r0, r3
 8008bca:	d002      	beq.n	8008bd2 <TIM_Base_SetConfig+0x7a>
 8008bcc:	4b08      	ldr	r3, [pc, #32]	; (8008bf0 <TIM_Base_SetConfig+0x98>)
 8008bce:	4298      	cmp	r0, r3
 8008bd0:	d101      	bne.n	8008bd6 <TIM_Base_SetConfig+0x7e>
    TIMx->RCR = Structure->RepetitionCounter;
 8008bd2:	690b      	ldr	r3, [r1, #16]
 8008bd4:	6303      	str	r3, [r0, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 8008bd6:	2301      	movs	r3, #1
 8008bd8:	6143      	str	r3, [r0, #20]
}
 8008bda:	bd10      	pop	{r4, pc}
 8008bdc:	40012c00 	.word	0x40012c00
 8008be0:	40000400 	.word	0x40000400
 8008be4:	40002000 	.word	0x40002000
 8008be8:	40014000 	.word	0x40014000
 8008bec:	40014400 	.word	0x40014400
 8008bf0:	40014800 	.word	0x40014800
 8008bf4:	fffffcff 	.word	0xfffffcff

08008bf8 <HAL_TIM_Base_Init>:
{
 8008bf8:	b570      	push	{r4, r5, r6, lr}
 8008bfa:	0004      	movs	r4, r0
    return HAL_ERROR;
 8008bfc:	2001      	movs	r0, #1
  if(htim == NULL)
 8008bfe:	2c00      	cmp	r4, #0
 8008c00:	d014      	beq.n	8008c2c <HAL_TIM_Base_Init+0x34>
  if(htim->State == HAL_TIM_STATE_RESET)
 8008c02:	0025      	movs	r5, r4
 8008c04:	353d      	adds	r5, #61	; 0x3d
 8008c06:	782b      	ldrb	r3, [r5, #0]
 8008c08:	b2db      	uxtb	r3, r3
 8008c0a:	2b00      	cmp	r3, #0
 8008c0c:	d105      	bne.n	8008c1a <HAL_TIM_Base_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 8008c0e:	0022      	movs	r2, r4
 8008c10:	323c      	adds	r2, #60	; 0x3c
 8008c12:	7013      	strb	r3, [r2, #0]
    HAL_TIM_Base_MspInit(htim);
 8008c14:	0020      	movs	r0, r4
 8008c16:	f7fd f9e7 	bl	8005fe8 <HAL_TIM_Base_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 8008c1a:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8008c1c:	6820      	ldr	r0, [r4, #0]
  htim->State= HAL_TIM_STATE_BUSY;
 8008c1e:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8008c20:	1d21      	adds	r1, r4, #4
 8008c22:	f7ff ff99 	bl	8008b58 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8008c26:	2301      	movs	r3, #1
  return HAL_OK;
 8008c28:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 8008c2a:	702b      	strb	r3, [r5, #0]
}
 8008c2c:	bd70      	pop	{r4, r5, r6, pc}

08008c2e <HAL_TIM_OC_Init>:
{
 8008c2e:	b570      	push	{r4, r5, r6, lr}
 8008c30:	0004      	movs	r4, r0
    return HAL_ERROR;
 8008c32:	2001      	movs	r0, #1
  if(htim == NULL)
 8008c34:	2c00      	cmp	r4, #0
 8008c36:	d014      	beq.n	8008c62 <HAL_TIM_OC_Init+0x34>
  if(htim->State == HAL_TIM_STATE_RESET)
 8008c38:	0025      	movs	r5, r4
 8008c3a:	353d      	adds	r5, #61	; 0x3d
 8008c3c:	782b      	ldrb	r3, [r5, #0]
 8008c3e:	b2db      	uxtb	r3, r3
 8008c40:	2b00      	cmp	r3, #0
 8008c42:	d105      	bne.n	8008c50 <HAL_TIM_OC_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 8008c44:	0022      	movs	r2, r4
 8008c46:	323c      	adds	r2, #60	; 0x3c
 8008c48:	7013      	strb	r3, [r2, #0]
    HAL_TIM_OC_MspInit(htim);
 8008c4a:	0020      	movs	r0, r4
 8008c4c:	f7ff ff82 	bl	8008b54 <HAL_TIM_OC_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 8008c50:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 8008c52:	6820      	ldr	r0, [r4, #0]
  htim->State= HAL_TIM_STATE_BUSY;
 8008c54:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 8008c56:	1d21      	adds	r1, r4, #4
 8008c58:	f7ff ff7e 	bl	8008b58 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8008c5c:	2301      	movs	r3, #1
  return HAL_OK;
 8008c5e:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 8008c60:	702b      	strb	r3, [r5, #0]
}
 8008c62:	bd70      	pop	{r4, r5, r6, pc}

08008c64 <TIM_OC2_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8008c64:	2210      	movs	r2, #16
 8008c66:	6a03      	ldr	r3, [r0, #32]
{
 8008c68:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8008c6a:	4393      	bics	r3, r2
 8008c6c:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8008c6e:	6a02      	ldr	r2, [r0, #32]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8008c70:	4d16      	ldr	r5, [pc, #88]	; (8008ccc <TIM_OC2_SetConfig+0x68>)
  tmpcr2 =  TIMx->CR2;
 8008c72:	6843      	ldr	r3, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 8008c74:	6984      	ldr	r4, [r0, #24]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8008c76:	402c      	ands	r4, r5
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8008c78:	680d      	ldr	r5, [r1, #0]
 8008c7a:	022d      	lsls	r5, r5, #8
 8008c7c:	432c      	orrs	r4, r5
  tmpccer &= ~TIM_CCER_CC2P;
 8008c7e:	2520      	movs	r5, #32
 8008c80:	43aa      	bics	r2, r5
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8008c82:	688d      	ldr	r5, [r1, #8]
 8008c84:	012d      	lsls	r5, r5, #4
 8008c86:	432a      	orrs	r2, r5
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8008c88:	4d11      	ldr	r5, [pc, #68]	; (8008cd0 <TIM_OC2_SetConfig+0x6c>)
 8008c8a:	42a8      	cmp	r0, r5
 8008c8c:	d10f      	bne.n	8008cae <TIM_OC2_SetConfig+0x4a>
    tmpccer &= ~TIM_CCER_CC2NP;
 8008c8e:	2580      	movs	r5, #128	; 0x80
 8008c90:	43aa      	bics	r2, r5
 8008c92:	0015      	movs	r5, r2
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8008c94:	68ca      	ldr	r2, [r1, #12]
 8008c96:	0112      	lsls	r2, r2, #4
 8008c98:	432a      	orrs	r2, r5
    tmpccer &= ~TIM_CCER_CC2NE;
 8008c9a:	2540      	movs	r5, #64	; 0x40
 8008c9c:	43aa      	bics	r2, r5
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8008c9e:	4d0d      	ldr	r5, [pc, #52]	; (8008cd4 <TIM_OC2_SetConfig+0x70>)
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8008ca0:	694e      	ldr	r6, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8008ca2:	401d      	ands	r5, r3
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8008ca4:	698b      	ldr	r3, [r1, #24]
 8008ca6:	4333      	orrs	r3, r6
 8008ca8:	009b      	lsls	r3, r3, #2
 8008caa:	432b      	orrs	r3, r5
 8008cac:	e008      	b.n	8008cc0 <TIM_OC2_SetConfig+0x5c>
  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8008cae:	4d0a      	ldr	r5, [pc, #40]	; (8008cd8 <TIM_OC2_SetConfig+0x74>)
 8008cb0:	42a8      	cmp	r0, r5
 8008cb2:	d0f4      	beq.n	8008c9e <TIM_OC2_SetConfig+0x3a>
 8008cb4:	4d09      	ldr	r5, [pc, #36]	; (8008cdc <TIM_OC2_SetConfig+0x78>)
 8008cb6:	42a8      	cmp	r0, r5
 8008cb8:	d0f1      	beq.n	8008c9e <TIM_OC2_SetConfig+0x3a>
 8008cba:	4d09      	ldr	r5, [pc, #36]	; (8008ce0 <TIM_OC2_SetConfig+0x7c>)
 8008cbc:	42a8      	cmp	r0, r5
 8008cbe:	d0ee      	beq.n	8008c9e <TIM_OC2_SetConfig+0x3a>
  TIMx->CR2 = tmpcr2;
 8008cc0:	6043      	str	r3, [r0, #4]
  TIMx->CCR2 = OC_Config->Pulse;
 8008cc2:	684b      	ldr	r3, [r1, #4]
  TIMx->CCMR1 = tmpccmrx;
 8008cc4:	6184      	str	r4, [r0, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8008cc6:	6383      	str	r3, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
 8008cc8:	6202      	str	r2, [r0, #32]
}
 8008cca:	bd70      	pop	{r4, r5, r6, pc}
 8008ccc:	ffff8cff 	.word	0xffff8cff
 8008cd0:	40012c00 	.word	0x40012c00
 8008cd4:	fffff3ff 	.word	0xfffff3ff
 8008cd8:	40014000 	.word	0x40014000
 8008cdc:	40014400 	.word	0x40014400
 8008ce0:	40014800 	.word	0x40014800

08008ce4 <HAL_TIM_OC_ConfigChannel>:
{
 8008ce4:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(htim);
 8008ce6:	0004      	movs	r4, r0
 8008ce8:	2602      	movs	r6, #2
 8008cea:	343c      	adds	r4, #60	; 0x3c
 8008cec:	7825      	ldrb	r5, [r4, #0]
{
 8008cee:	0003      	movs	r3, r0
  __HAL_LOCK(htim);
 8008cf0:	0030      	movs	r0, r6
 8008cf2:	2d01      	cmp	r5, #1
 8008cf4:	d017      	beq.n	8008d26 <HAL_TIM_OC_ConfigChannel+0x42>
  htim->State = HAL_TIM_STATE_BUSY;
 8008cf6:	001d      	movs	r5, r3
  __HAL_LOCK(htim);
 8008cf8:	3801      	subs	r0, #1
  htim->State = HAL_TIM_STATE_BUSY;
 8008cfa:	353d      	adds	r5, #61	; 0x3d
  __HAL_LOCK(htim);
 8008cfc:	7020      	strb	r0, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8008cfe:	702e      	strb	r6, [r5, #0]
  switch (Channel)
 8008d00:	2a0c      	cmp	r2, #12
 8008d02:	d80c      	bhi.n	8008d1e <HAL_TIM_OC_ConfigChannel+0x3a>
 8008d04:	0010      	movs	r0, r2
 8008d06:	f7fc fe4b 	bl	80059a0 <__gnu_thumb1_case_uqi>
 8008d0a:	0a07      	.short	0x0a07
 8008d0c:	0a0f0a0a 	.word	0x0a0f0a0a
 8008d10:	0a130a0a 	.word	0x0a130a0a
 8008d14:	0a0a      	.short	0x0a0a
 8008d16:	17          	.byte	0x17
 8008d17:	00          	.byte	0x00
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8008d18:	6818      	ldr	r0, [r3, #0]
 8008d1a:	f7ff fe43 	bl	80089a4 <TIM_OC1_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
 8008d1e:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
 8008d20:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8008d22:	702b      	strb	r3, [r5, #0]
  __HAL_UNLOCK(htim);
 8008d24:	7020      	strb	r0, [r4, #0]
}
 8008d26:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8008d28:	6818      	ldr	r0, [r3, #0]
 8008d2a:	f7ff ff9b 	bl	8008c64 <TIM_OC2_SetConfig>
    break;
 8008d2e:	e7f6      	b.n	8008d1e <HAL_TIM_OC_ConfigChannel+0x3a>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8008d30:	6818      	ldr	r0, [r3, #0]
 8008d32:	f7ff fe7b 	bl	8008a2c <TIM_OC3_SetConfig>
    break;
 8008d36:	e7f2      	b.n	8008d1e <HAL_TIM_OC_ConfigChannel+0x3a>
       TIM_OC4_SetConfig(htim->Instance, sConfig);
 8008d38:	6818      	ldr	r0, [r3, #0]
 8008d3a:	f7ff febb 	bl	8008ab4 <TIM_OC4_SetConfig>
    break;
 8008d3e:	e7ee      	b.n	8008d1e <HAL_TIM_OC_ConfigChannel+0x3a>

08008d40 <TIM_CCxChannelCmd>:
  * @param  ChannelState : specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
{
 8008d40:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << Channel;
 8008d42:	2401      	movs	r4, #1
 8008d44:	408c      	lsls	r4, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;

  /* Set or reset the CCxE Bit */
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 8008d46:	408a      	lsls	r2, r1
  TIMx->CCER &= ~tmp;
 8008d48:	6a03      	ldr	r3, [r0, #32]
 8008d4a:	43a3      	bics	r3, r4
 8008d4c:	6203      	str	r3, [r0, #32]
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 8008d4e:	6a03      	ldr	r3, [r0, #32]
 8008d50:	431a      	orrs	r2, r3
 8008d52:	6202      	str	r2, [r0, #32]
}
 8008d54:	bd10      	pop	{r4, pc}
	...

08008d58 <HAL_TIM_OC_Start_IT>:
{
 8008d58:	b510      	push	{r4, lr}
 8008d5a:	6803      	ldr	r3, [r0, #0]
 8008d5c:	0004      	movs	r4, r0
  switch (Channel)
 8008d5e:	290c      	cmp	r1, #12
 8008d60:	d80d      	bhi.n	8008d7e <HAL_TIM_OC_Start_IT+0x26>
 8008d62:	0008      	movs	r0, r1
 8008d64:	f7fc fe1c 	bl	80059a0 <__gnu_thumb1_case_uqi>
 8008d68:	0b0b0b07 	.word	0x0b0b0b07
 8008d6c:	0b0b0b27 	.word	0x0b0b0b27
 8008d70:	0b0b0b2a 	.word	0x0b0b0b2a
 8008d74:	2d          	.byte	0x2d
 8008d75:	00          	.byte	0x00
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 8008d76:	2202      	movs	r2, #2
 8008d78:	68d8      	ldr	r0, [r3, #12]
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 8008d7a:	4302      	orrs	r2, r0
 8008d7c:	60da      	str	r2, [r3, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8008d7e:	2201      	movs	r2, #1
 8008d80:	0018      	movs	r0, r3
 8008d82:	f7ff ffdd 	bl	8008d40 <TIM_CCxChannelCmd>
  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8008d86:	6823      	ldr	r3, [r4, #0]
 8008d88:	4a0f      	ldr	r2, [pc, #60]	; (8008dc8 <HAL_TIM_OC_Start_IT+0x70>)
 8008d8a:	4293      	cmp	r3, r2
 8008d8c:	d008      	beq.n	8008da0 <HAL_TIM_OC_Start_IT+0x48>
 8008d8e:	4a0f      	ldr	r2, [pc, #60]	; (8008dcc <HAL_TIM_OC_Start_IT+0x74>)
 8008d90:	4293      	cmp	r3, r2
 8008d92:	d005      	beq.n	8008da0 <HAL_TIM_OC_Start_IT+0x48>
 8008d94:	4a0e      	ldr	r2, [pc, #56]	; (8008dd0 <HAL_TIM_OC_Start_IT+0x78>)
 8008d96:	4293      	cmp	r3, r2
 8008d98:	d002      	beq.n	8008da0 <HAL_TIM_OC_Start_IT+0x48>
 8008d9a:	4a0e      	ldr	r2, [pc, #56]	; (8008dd4 <HAL_TIM_OC_Start_IT+0x7c>)
 8008d9c:	4293      	cmp	r3, r2
 8008d9e:	d104      	bne.n	8008daa <HAL_TIM_OC_Start_IT+0x52>
    __HAL_TIM_MOE_ENABLE(htim);
 8008da0:	2280      	movs	r2, #128	; 0x80
 8008da2:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8008da4:	0212      	lsls	r2, r2, #8
 8008da6:	430a      	orrs	r2, r1
 8008da8:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_ENABLE(htim);
 8008daa:	2201      	movs	r2, #1
 8008dac:	6819      	ldr	r1, [r3, #0]
}
 8008dae:	2000      	movs	r0, #0
  __HAL_TIM_ENABLE(htim);
 8008db0:	430a      	orrs	r2, r1
 8008db2:	601a      	str	r2, [r3, #0]
}
 8008db4:	bd10      	pop	{r4, pc}
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 8008db6:	68d8      	ldr	r0, [r3, #12]
 8008db8:	2204      	movs	r2, #4
 8008dba:	e7de      	b.n	8008d7a <HAL_TIM_OC_Start_IT+0x22>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 8008dbc:	68d8      	ldr	r0, [r3, #12]
 8008dbe:	2208      	movs	r2, #8
 8008dc0:	e7db      	b.n	8008d7a <HAL_TIM_OC_Start_IT+0x22>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 8008dc2:	68d8      	ldr	r0, [r3, #12]
 8008dc4:	2210      	movs	r2, #16
 8008dc6:	e7d8      	b.n	8008d7a <HAL_TIM_OC_Start_IT+0x22>
 8008dc8:	40012c00 	.word	0x40012c00
 8008dcc:	40014000 	.word	0x40014000
 8008dd0:	40014400 	.word	0x40014400
 8008dd4:	40014800 	.word	0x40014800

08008dd8 <HAL_TIM_OC_Stop_IT>:
{
 8008dd8:	b510      	push	{r4, lr}
 8008dda:	6803      	ldr	r3, [r0, #0]
 8008ddc:	0004      	movs	r4, r0
  switch (Channel)
 8008dde:	290c      	cmp	r1, #12
 8008de0:	d80d      	bhi.n	8008dfe <HAL_TIM_OC_Stop_IT+0x26>
 8008de2:	0008      	movs	r0, r1
 8008de4:	f7fc fddc 	bl	80059a0 <__gnu_thumb1_case_uqi>
 8008de8:	0b0b0b07 	.word	0x0b0b0b07
 8008dec:	0b0b0b35 	.word	0x0b0b0b35
 8008df0:	0b0b0b38 	.word	0x0b0b0b38
 8008df4:	3b          	.byte	0x3b
 8008df5:	00          	.byte	0x00
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 8008df6:	2002      	movs	r0, #2
 8008df8:	68da      	ldr	r2, [r3, #12]
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 8008dfa:	4382      	bics	r2, r0
 8008dfc:	60da      	str	r2, [r3, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 8008dfe:	2200      	movs	r2, #0
 8008e00:	0018      	movs	r0, r3
 8008e02:	f7ff ff9d 	bl	8008d40 <TIM_CCxChannelCmd>
  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8008e06:	6823      	ldr	r3, [r4, #0]
 8008e08:	4a16      	ldr	r2, [pc, #88]	; (8008e64 <HAL_TIM_OC_Stop_IT+0x8c>)
 8008e0a:	4917      	ldr	r1, [pc, #92]	; (8008e68 <HAL_TIM_OC_Stop_IT+0x90>)
 8008e0c:	4293      	cmp	r3, r2
 8008e0e:	d008      	beq.n	8008e22 <HAL_TIM_OC_Stop_IT+0x4a>
 8008e10:	4a16      	ldr	r2, [pc, #88]	; (8008e6c <HAL_TIM_OC_Stop_IT+0x94>)
 8008e12:	4293      	cmp	r3, r2
 8008e14:	d005      	beq.n	8008e22 <HAL_TIM_OC_Stop_IT+0x4a>
 8008e16:	4a16      	ldr	r2, [pc, #88]	; (8008e70 <HAL_TIM_OC_Stop_IT+0x98>)
 8008e18:	4293      	cmp	r3, r2
 8008e1a:	d002      	beq.n	8008e22 <HAL_TIM_OC_Stop_IT+0x4a>
 8008e1c:	4a15      	ldr	r2, [pc, #84]	; (8008e74 <HAL_TIM_OC_Stop_IT+0x9c>)
 8008e1e:	4293      	cmp	r3, r2
 8008e20:	d10a      	bne.n	8008e38 <HAL_TIM_OC_Stop_IT+0x60>
    __HAL_TIM_MOE_DISABLE(htim);
 8008e22:	6a1a      	ldr	r2, [r3, #32]
 8008e24:	420a      	tst	r2, r1
 8008e26:	d107      	bne.n	8008e38 <HAL_TIM_OC_Stop_IT+0x60>
 8008e28:	6a18      	ldr	r0, [r3, #32]
 8008e2a:	4a13      	ldr	r2, [pc, #76]	; (8008e78 <HAL_TIM_OC_Stop_IT+0xa0>)
 8008e2c:	4210      	tst	r0, r2
 8008e2e:	d103      	bne.n	8008e38 <HAL_TIM_OC_Stop_IT+0x60>
 8008e30:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8008e32:	4812      	ldr	r0, [pc, #72]	; (8008e7c <HAL_TIM_OC_Stop_IT+0xa4>)
 8008e34:	4002      	ands	r2, r0
 8008e36:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_DISABLE(htim);
 8008e38:	6a1a      	ldr	r2, [r3, #32]
 8008e3a:	420a      	tst	r2, r1
 8008e3c:	d107      	bne.n	8008e4e <HAL_TIM_OC_Stop_IT+0x76>
 8008e3e:	6a19      	ldr	r1, [r3, #32]
 8008e40:	4a0d      	ldr	r2, [pc, #52]	; (8008e78 <HAL_TIM_OC_Stop_IT+0xa0>)
 8008e42:	4211      	tst	r1, r2
 8008e44:	d103      	bne.n	8008e4e <HAL_TIM_OC_Stop_IT+0x76>
 8008e46:	2101      	movs	r1, #1
 8008e48:	681a      	ldr	r2, [r3, #0]
 8008e4a:	438a      	bics	r2, r1
 8008e4c:	601a      	str	r2, [r3, #0]
}
 8008e4e:	2000      	movs	r0, #0
 8008e50:	bd10      	pop	{r4, pc}
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 8008e52:	68da      	ldr	r2, [r3, #12]
 8008e54:	2004      	movs	r0, #4
 8008e56:	e7d0      	b.n	8008dfa <HAL_TIM_OC_Stop_IT+0x22>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
 8008e58:	68da      	ldr	r2, [r3, #12]
 8008e5a:	2008      	movs	r0, #8
 8008e5c:	e7cd      	b.n	8008dfa <HAL_TIM_OC_Stop_IT+0x22>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 8008e5e:	68da      	ldr	r2, [r3, #12]
 8008e60:	2010      	movs	r0, #16
 8008e62:	e7ca      	b.n	8008dfa <HAL_TIM_OC_Stop_IT+0x22>
 8008e64:	40012c00 	.word	0x40012c00
 8008e68:	00001111 	.word	0x00001111
 8008e6c:	40014000 	.word	0x40014000
 8008e70:	40014400 	.word	0x40014400
 8008e74:	40014800 	.word	0x40014800
 8008e78:	00000444 	.word	0x00000444
 8008e7c:	ffff7fff 	.word	0xffff7fff

08008e80 <HAL_TIMEx_ConfigBreakDeadTime>:
  *         contains the BDTR Register configuration  information for the TIM peripheral.
  * @retval HAL status
  */    
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
                                                TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
{
 8008e80:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));

  /* Process Locked */
  __HAL_LOCK(htim);
 8008e82:	0004      	movs	r4, r0
 8008e84:	2302      	movs	r3, #2
 8008e86:	343c      	adds	r4, #60	; 0x3c
 8008e88:	7825      	ldrb	r5, [r4, #0]
{
 8008e8a:	0002      	movs	r2, r0
  __HAL_LOCK(htim);
 8008e8c:	0018      	movs	r0, r3
 8008e8e:	2d01      	cmp	r5, #1
 8008e90:	d024      	beq.n	8008edc <HAL_TIMEx_ConfigBreakDeadTime+0x5c>

  htim->State = HAL_TIM_STATE_BUSY;
 8008e92:	0010      	movs	r0, r2
 8008e94:	303d      	adds	r0, #61	; 0x3d
  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  
  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8008e96:	68cd      	ldr	r5, [r1, #12]
  htim->State = HAL_TIM_STATE_BUSY;
 8008e98:	7003      	strb	r3, [r0, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8008e9a:	4b11      	ldr	r3, [pc, #68]	; (8008ee0 <HAL_TIMEx_ConfigBreakDeadTime+0x60>)
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
  
  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
 8008e9c:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8008e9e:	402b      	ands	r3, r5
 8008ea0:	688d      	ldr	r5, [r1, #8]
 8008ea2:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 8008ea4:	4d0f      	ldr	r5, [pc, #60]	; (8008ee4 <HAL_TIMEx_ConfigBreakDeadTime+0x64>)
 8008ea6:	402b      	ands	r3, r5
 8008ea8:	684d      	ldr	r5, [r1, #4]
 8008eaa:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8008eac:	4d0e      	ldr	r5, [pc, #56]	; (8008ee8 <HAL_TIMEx_ConfigBreakDeadTime+0x68>)
 8008eae:	402b      	ands	r3, r5
 8008eb0:	680d      	ldr	r5, [r1, #0]
 8008eb2:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8008eb4:	4d0d      	ldr	r5, [pc, #52]	; (8008eec <HAL_TIMEx_ConfigBreakDeadTime+0x6c>)
 8008eb6:	402b      	ands	r3, r5
 8008eb8:	690d      	ldr	r5, [r1, #16]
 8008eba:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8008ebc:	4d0c      	ldr	r5, [pc, #48]	; (8008ef0 <HAL_TIMEx_ConfigBreakDeadTime+0x70>)
 8008ebe:	402b      	ands	r3, r5
 8008ec0:	694d      	ldr	r5, [r1, #20]
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8008ec2:	6989      	ldr	r1, [r1, #24]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8008ec4:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8008ec6:	4d0b      	ldr	r5, [pc, #44]	; (8008ef4 <HAL_TIMEx_ConfigBreakDeadTime+0x74>)
 8008ec8:	402b      	ands	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
 8008eca:	4d0b      	ldr	r5, [pc, #44]	; (8008ef8 <HAL_TIMEx_ConfigBreakDeadTime+0x78>)
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8008ecc:	430b      	orrs	r3, r1
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
 8008ece:	402b      	ands	r3, r5
 8008ed0:	430b      	orrs	r3, r1
  htim->Instance->BDTR = tmpbdtr;
 8008ed2:	6453      	str	r3, [r2, #68]	; 0x44
  
  htim->State = HAL_TIM_STATE_READY;
 8008ed4:	2301      	movs	r3, #1
 8008ed6:	7003      	strb	r3, [r0, #0]

  __HAL_UNLOCK(htim);
 8008ed8:	2000      	movs	r0, #0
 8008eda:	7020      	strb	r0, [r4, #0]

  return HAL_OK;
}
 8008edc:	bd30      	pop	{r4, r5, pc}
 8008ede:	46c0      	nop			; (mov r8, r8)
 8008ee0:	fffffcff 	.word	0xfffffcff
 8008ee4:	fffffbff 	.word	0xfffffbff
 8008ee8:	fffff7ff 	.word	0xfffff7ff
 8008eec:	ffffefff 	.word	0xffffefff
 8008ef0:	ffffdfff 	.word	0xffffdfff
 8008ef4:	ffffbfff 	.word	0xffffbfff
 8008ef8:	ffff7fff 	.word	0xffff7fff

08008efc <LL_EXTI_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: EXTI registers are initialized
  *          - ERROR: not applicable
  */
uint32_t LL_EXTI_Init(LL_EXTI_InitTypeDef *EXTI_InitStruct)
{
 8008efc:	b510      	push	{r4, lr}
  assert_param(IS_LL_EXTI_LINE_0_31(EXTI_InitStruct->Line_0_31));
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->LineCommand));
  assert_param(IS_LL_EXTI_MODE(EXTI_InitStruct->Mode));

  /* ENABLE LineCommand */
  if (EXTI_InitStruct->LineCommand != DISABLE)
 8008efe:	7902      	ldrb	r2, [r0, #4]
 8008f00:	6803      	ldr	r3, [r0, #0]
 8008f02:	2a00      	cmp	r2, #0
 8008f04:	d03c      	beq.n	8008f80 <LL_EXTI_Init+0x84>
  ErrorStatus status = SUCCESS;
 8008f06:	2201      	movs	r2, #1
  {
    assert_param(IS_LL_EXTI_TRIGGER(EXTI_InitStruct->Trigger));

    /* Configure EXTI Lines in range from 0 to 31 */
    if (EXTI_InitStruct->Line_0_31 != LL_EXTI_LINE_NONE)
 8008f08:	2b00      	cmp	r3, #0
 8008f0a:	d01f      	beq.n	8008f4c <LL_EXTI_Init+0x50>
    {
      switch (EXTI_InitStruct->Mode)
 8008f0c:	7941      	ldrb	r1, [r0, #5]
 8008f0e:	4291      	cmp	r1, r2
 8008f10:	d01e      	beq.n	8008f50 <LL_EXTI_Init+0x54>
 8008f12:	2900      	cmp	r1, #0
 8008f14:	d003      	beq.n	8008f1e <LL_EXTI_Init+0x22>
 8008f16:	2902      	cmp	r1, #2
 8008f18:	d022      	beq.n	8008f60 <LL_EXTI_Init+0x64>
          /* Directly Enable IT & Event on provided Lines */
          LL_EXTI_EnableIT_0_31(EXTI_InitStruct->Line_0_31);
          LL_EXTI_EnableEvent_0_31(EXTI_InitStruct->Line_0_31);
          break;
        default:
          status = ERROR;
 8008f1a:	2200      	movs	r2, #0
 8008f1c:	e006      	b.n	8008f2c <LL_EXTI_Init+0x30>
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableEvent_0_31(uint32_t ExtiLine)
{
  CLEAR_BIT(EXTI->EMR, ExtiLine);
 8008f1e:	491e      	ldr	r1, [pc, #120]	; (8008f98 <LL_EXTI_Init+0x9c>)
 8008f20:	684c      	ldr	r4, [r1, #4]
 8008f22:	439c      	bics	r4, r3
 8008f24:	604c      	str	r4, [r1, #4]
  SET_BIT(EXTI->IMR, ExtiLine);
 8008f26:	680c      	ldr	r4, [r1, #0]
 8008f28:	431c      	orrs	r4, r3
 8008f2a:	600c      	str	r4, [r1, #0]
          break;
      }
      if (EXTI_InitStruct->Trigger != LL_EXTI_TRIGGER_NONE)
 8008f2c:	7981      	ldrb	r1, [r0, #6]
 8008f2e:	2900      	cmp	r1, #0
 8008f30:	d00c      	beq.n	8008f4c <LL_EXTI_Init+0x50>
      {
        switch (EXTI_InitStruct->Trigger)
 8008f32:	2902      	cmp	r1, #2
 8008f34:	d018      	beq.n	8008f68 <LL_EXTI_Init+0x6c>
 8008f36:	2903      	cmp	r1, #3
 8008f38:	d01e      	beq.n	8008f78 <LL_EXTI_Init+0x7c>
 8008f3a:	2901      	cmp	r1, #1
 8008f3c:	d12a      	bne.n	8008f94 <LL_EXTI_Init+0x98>
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableFallingTrig_0_31(uint32_t ExtiLine)
{
  CLEAR_BIT(EXTI->FTSR, ExtiLine);
 8008f3e:	4916      	ldr	r1, [pc, #88]	; (8008f98 <LL_EXTI_Init+0x9c>)
 8008f40:	68c8      	ldr	r0, [r1, #12]
 8008f42:	4398      	bics	r0, r3
 8008f44:	60c8      	str	r0, [r1, #12]
  SET_BIT(EXTI->RTSR, ExtiLine);
 8008f46:	6888      	ldr	r0, [r1, #8]
 8008f48:	4303      	orrs	r3, r0
 8008f4a:	608b      	str	r3, [r1, #8]
    /* De-configure EXTI Lines in range from 0 to 31 */
    LL_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);
    LL_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);
  }
  return status;
}
 8008f4c:	0010      	movs	r0, r2
 8008f4e:	bd10      	pop	{r4, pc}
  CLEAR_BIT(EXTI->IMR, ExtiLine);
 8008f50:	4911      	ldr	r1, [pc, #68]	; (8008f98 <LL_EXTI_Init+0x9c>)
 8008f52:	680c      	ldr	r4, [r1, #0]
 8008f54:	439c      	bics	r4, r3
  SET_BIT(EXTI->IMR, ExtiLine);
 8008f56:	600c      	str	r4, [r1, #0]
  SET_BIT(EXTI->EMR, ExtiLine);
 8008f58:	684c      	ldr	r4, [r1, #4]
 8008f5a:	431c      	orrs	r4, r3
 8008f5c:	604c      	str	r4, [r1, #4]
 8008f5e:	e7e5      	b.n	8008f2c <LL_EXTI_Init+0x30>
  SET_BIT(EXTI->IMR, ExtiLine);
 8008f60:	490d      	ldr	r1, [pc, #52]	; (8008f98 <LL_EXTI_Init+0x9c>)
 8008f62:	680c      	ldr	r4, [r1, #0]
 8008f64:	431c      	orrs	r4, r3
 8008f66:	e7f6      	b.n	8008f56 <LL_EXTI_Init+0x5a>
  CLEAR_BIT(EXTI->RTSR, ExtiLine);
 8008f68:	490b      	ldr	r1, [pc, #44]	; (8008f98 <LL_EXTI_Init+0x9c>)
 8008f6a:	6888      	ldr	r0, [r1, #8]
 8008f6c:	4398      	bics	r0, r3
  SET_BIT(EXTI->RTSR, ExtiLine);
 8008f6e:	6088      	str	r0, [r1, #8]
  SET_BIT(EXTI->FTSR, ExtiLine);
 8008f70:	68c8      	ldr	r0, [r1, #12]
 8008f72:	4303      	orrs	r3, r0
 8008f74:	60cb      	str	r3, [r1, #12]
 8008f76:	e7e9      	b.n	8008f4c <LL_EXTI_Init+0x50>
  SET_BIT(EXTI->RTSR, ExtiLine);
 8008f78:	4907      	ldr	r1, [pc, #28]	; (8008f98 <LL_EXTI_Init+0x9c>)
 8008f7a:	6888      	ldr	r0, [r1, #8]
 8008f7c:	4318      	orrs	r0, r3
 8008f7e:	e7f6      	b.n	8008f6e <LL_EXTI_Init+0x72>
  CLEAR_BIT(EXTI->IMR, ExtiLine);
 8008f80:	43db      	mvns	r3, r3
 8008f82:	4a05      	ldr	r2, [pc, #20]	; (8008f98 <LL_EXTI_Init+0x9c>)
 8008f84:	6811      	ldr	r1, [r2, #0]
 8008f86:	4019      	ands	r1, r3
 8008f88:	6011      	str	r1, [r2, #0]
  CLEAR_BIT(EXTI->EMR, ExtiLine);
 8008f8a:	6851      	ldr	r1, [r2, #4]
 8008f8c:	400b      	ands	r3, r1
 8008f8e:	6053      	str	r3, [r2, #4]
  ErrorStatus status = SUCCESS;
 8008f90:	2201      	movs	r2, #1
 8008f92:	e7db      	b.n	8008f4c <LL_EXTI_Init+0x50>
            status = ERROR;
 8008f94:	2200      	movs	r2, #0
 8008f96:	e7d9      	b.n	8008f4c <LL_EXTI_Init+0x50>
 8008f98:	40010400 	.word	0x40010400

08008f9c <LL_Init1msTick>:
  * @retval None
  */
__STATIC_INLINE void LL_InitTick(uint32_t HCLKFrequency, uint32_t Ticks)
{
  /* Configure the SysTick to have interrupt in 1ms time base */
  SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
 8008f9c:	21fa      	movs	r1, #250	; 0xfa
  * @param  HCLKFrequency HCLK frequency in Hz
  * @note   HCLK frequency can be calculated thanks to RCC helper macro or function @ref LL_RCC_GetSystemClocksFreq
  * @retval None
  */
void LL_Init1msTick(uint32_t HCLKFrequency)
{
 8008f9e:	b510      	push	{r4, lr}
 8008fa0:	0089      	lsls	r1, r1, #2
 8008fa2:	f7fc fd07 	bl	80059b4 <__udivsi3>
  SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
 8008fa6:	2200      	movs	r2, #0
  SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
 8008fa8:	4b03      	ldr	r3, [pc, #12]	; (8008fb8 <LL_Init1msTick+0x1c>)
 8008faa:	3801      	subs	r0, #1
 8008fac:	6058      	str	r0, [r3, #4]
  SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
 8008fae:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8008fb0:	3205      	adds	r2, #5
 8008fb2:	601a      	str	r2, [r3, #0]
  /* Use frequency provided in argument */
  LL_InitTick(HCLKFrequency, 1000U);
}
 8008fb4:	bd10      	pop	{r4, pc}
 8008fb6:	46c0      	nop			; (mov r8, r8)
 8008fb8:	e000e010 	.word	0xe000e010

08008fbc <LL_SetSystemCoreClock>:
  * @retval None
  */
void LL_SetSystemCoreClock(uint32_t HCLKFrequency)
{
  /* HCLK clock frequency */
  SystemCoreClock = HCLKFrequency;
 8008fbc:	4b01      	ldr	r3, [pc, #4]	; (8008fc4 <LL_SetSystemCoreClock+0x8>)
 8008fbe:	6018      	str	r0, [r3, #0]
}
 8008fc0:	4770      	bx	lr
 8008fc2:	46c0      	nop			; (mov r8, r8)
 8008fc4:	20000054 	.word	0x20000054

08008fc8 <USBPD_PE_TaskWakeUp>:
  * @retval None
  */
static void USBPD_PE_TaskWakeUp(uint8_t PortNum)
{
#ifdef _RTOS
  osMessagePut(PEQueueId[PortNum], 0xFFFF, osWaitForever);
 8008fc8:	2201      	movs	r2, #1
{
 8008fca:	b510      	push	{r4, lr}
  osMessagePut(PEQueueId[PortNum], 0xFFFF, osWaitForever);
 8008fcc:	4b03      	ldr	r3, [pc, #12]	; (8008fdc <USBPD_PE_TaskWakeUp+0x14>)
 8008fce:	0080      	lsls	r0, r0, #2
 8008fd0:	4252      	negs	r2, r2
 8008fd2:	4903      	ldr	r1, [pc, #12]	; (8008fe0 <USBPD_PE_TaskWakeUp+0x18>)
 8008fd4:	58c0      	ldr	r0, [r0, r3]
 8008fd6:	f002 f9d3 	bl	800b380 <osMessagePut>
#endif
}
 8008fda:	bd10      	pop	{r4, pc}
 8008fdc:	20000370 	.word	0x20000370
 8008fe0:	0000ffff 	.word	0x0000ffff

08008fe4 <USBPD_DPM_CADTaskWakeUp>:
  * @retval None
  */
static void USBPD_DPM_CADTaskWakeUp(void)
{
#ifdef _RTOS
  osMessagePut(CADQueueId, 0xFFFF, osWaitForever);
 8008fe4:	2201      	movs	r2, #1
{
 8008fe6:	b510      	push	{r4, lr}
  osMessagePut(CADQueueId, 0xFFFF, osWaitForever);
 8008fe8:	4b03      	ldr	r3, [pc, #12]	; (8008ff8 <USBPD_DPM_CADTaskWakeUp+0x14>)
 8008fea:	4252      	negs	r2, r2
 8008fec:	4903      	ldr	r1, [pc, #12]	; (8008ffc <USBPD_DPM_CADTaskWakeUp+0x18>)
 8008fee:	6858      	ldr	r0, [r3, #4]
 8008ff0:	f002 f9c6 	bl	800b380 <osMessagePut>
#endif
}
 8008ff4:	bd10      	pop	{r4, pc}
 8008ff6:	46c0      	nop			; (mov r8, r8)
 8008ff8:	20000370 	.word	0x20000370
 8008ffc:	0000ffff 	.word	0x0000ffff

08009000 <USBPD_PE_Task>:
  * @brief  Main task for PE layer
  * @param  argument Not used
  * @retval None
  */
void USBPD_PE_Task(void const *argument)
{
 8009000:	b530      	push	{r4, r5, lr}
#elif defined(_SRC)
    USBPD_PE_StateMachine_SRC(_port);
#elif defined(_SNK)
    USBPD_PE_StateMachine_SNK(_port);
#endif
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 8009002:	b2c4      	uxtb	r4, r0
{
 8009004:	b085      	sub	sp, #20
  uint8_t _port = (uint32_t)argument;
 8009006:	b2c5      	uxtb	r5, r0
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 8009008:	00a4      	lsls	r4, r4, #2
    USBPD_PE_StateMachine_SRC(_port);
 800900a:	0028      	movs	r0, r5
 800900c:	f7f7 fa7e 	bl	800050c <USBPD_PE_StateMachine_SRC>
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 8009010:	4b03      	ldr	r3, [pc, #12]	; (8009020 <USBPD_PE_Task+0x20>)
    USBPD_PE_StateMachine_SRC(_port);
 8009012:	0002      	movs	r2, r0
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 8009014:	58e1      	ldr	r1, [r4, r3]
 8009016:	4668      	mov	r0, sp
 8009018:	f002 f9d8 	bl	800b3cc <osMessageGet>
 800901c:	e7f5      	b.n	800900a <USBPD_PE_Task+0xa>
 800901e:	46c0      	nop			; (mov r8, r8)
 8009020:	20000370 	.word	0x20000370

08009024 <USBPD_CAD_Task>:
  * @brief  Main task for CAD layer
  * @param  argument Not used
  * @retval None
  */
void USBPD_CAD_Task(void const *argument)
{
 8009024:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  for(;;)
  {
    DPM_Sleep_time[USBPD_THREAD_CAD] = USBPD_CAD_Process();
 8009026:	f7f7 f8b1 	bl	800018c <USBPD_CAD_Process>
    osMessageGet(CADQueueId, DPM_Sleep_time[USBPD_THREAD_CAD]);
 800902a:	4b03      	ldr	r3, [pc, #12]	; (8009038 <USBPD_CAD_Task+0x14>)
    DPM_Sleep_time[USBPD_THREAD_CAD] = USBPD_CAD_Process();
 800902c:	0002      	movs	r2, r0
    osMessageGet(CADQueueId, DPM_Sleep_time[USBPD_THREAD_CAD]);
 800902e:	6859      	ldr	r1, [r3, #4]
 8009030:	4668      	mov	r0, sp
 8009032:	f002 f9cb 	bl	800b3cc <osMessageGet>
 8009036:	e7f6      	b.n	8009026 <USBPD_CAD_Task+0x2>
 8009038:	20000370 	.word	0x20000370

0800903c <USBPD_DPM_CADCallback>:
  * @param  State     CAD state
  * @param  Cc        The Communication Channel for the USBPD communication
  * @retval None
  */
void USBPD_DPM_CADCallback(uint8_t PortNum, USBPD_CAD_EVENT State, CCxPin_TypeDef Cc)
{
 800903c:	b570      	push	{r4, r5, r6, lr}
 800903e:	0004      	movs	r4, r0
#ifdef _TRACE
  USBPD_TRACE_Add(USBPD_TRACE_CADEVENT, PortNum, State, NULL, 0);
#endif /* _TRACE */

  switch(State)
 8009040:	1e48      	subs	r0, r1, #1
{
 8009042:	000d      	movs	r5, r1
  switch(State)
 8009044:	2806      	cmp	r0, #6
 8009046:	d827      	bhi.n	8009098 <USBPD_DPM_CADCallback+0x5c>
 8009048:	f7fc fcaa 	bl	80059a0 <__gnu_thumb1_case_uqi>
 800904c:	04280428 	.word	0x04280428
 8009050:	2626      	.short	0x2626
 8009052:	42          	.byte	0x42
 8009053:	00          	.byte	0x00
  case USBPD_CAD_EVENT_ATTACHED :
#ifdef _VCONN_SUPPORT
    if(CC1 == Cc) DPM_Params[PortNum].VconnCCIs = CC2;
    if(CC2 == Cc) DPM_Params[PortNum].VconnCCIs = CC1;
#endif /* _VCONN_SUPPORT */
    DPM_Params[PortNum].ActiveCCIs = Cc;
 8009054:	2003      	movs	r0, #3
 8009056:	4928      	ldr	r1, [pc, #160]	; (80090f8 <USBPD_DPM_CADCallback+0xbc>)
 8009058:	00e3      	lsls	r3, r4, #3
 800905a:	18c9      	adds	r1, r1, r3
 800905c:	784b      	ldrb	r3, [r1, #1]
 800905e:	4002      	ands	r2, r0
 8009060:	4383      	bics	r3, r0
 8009062:	431a      	orrs	r2, r3
 8009064:	704a      	strb	r2, [r1, #1]
    USBPD_PE_IsCableConnected(PortNum, 1);
 8009066:	0020      	movs	r0, r4
 8009068:	2101      	movs	r1, #1
 800906a:	f7f7 fa26 	bl	80004ba <USBPD_PE_IsCableConnected>

    USBPD_DPM_UserCableDetection(PortNum, State);
 800906e:	0029      	movs	r1, r5
 8009070:	0020      	movs	r0, r4
 8009072:	f7fd f875 	bl	8006160 <USBPD_DPM_UserCableDetection>
    USBPD_DPM_WaitForTime(6);
#endif /* USBPD_TCPM_MODULE_ENABLED */

#ifdef _RTOS
    /* Create PE task */
    if (DPM_Thread_Table[PortNum] == NULL)
 8009076:	4d21      	ldr	r5, [pc, #132]	; (80090fc <USBPD_DPM_CADCallback+0xc0>)
 8009078:	00a6      	lsls	r6, r4, #2
 800907a:	19ab      	adds	r3, r5, r6
 800907c:	689b      	ldr	r3, [r3, #8]
 800907e:	2b00      	cmp	r3, #0
 8009080:	d10a      	bne.n	8009098 <USBPD_DPM_CADCallback+0x5c>
 8009082:	481f      	ldr	r0, [pc, #124]	; (8009100 <USBPD_DPM_CADCallback+0xc4>)
    {
      DPM_Thread_Table[PortNum] = osThreadCreate(OSTHREAD_PE(PortNum), (void *)((uint32_t)PortNum));
 8009084:	2c00      	cmp	r4, #0
 8009086:	d000      	beq.n	800908a <USBPD_DPM_CADCallback+0x4e>
 8009088:	3014      	adds	r0, #20
 800908a:	0021      	movs	r1, r4
 800908c:	f002 f94b 	bl	800b326 <osThreadCreate>
      if (DPM_Thread_Table[PortNum] == NULL)
 8009090:	2800      	cmp	r0, #0
 8009092:	d002      	beq.n	800909a <USBPD_DPM_CADCallback+0x5e>
      DPM_Thread_Table[PortNum] = osThreadCreate(OSTHREAD_PE(PortNum), (void *)((uint32_t)PortNum));
 8009094:	19ad      	adds	r5, r5, r6
 8009096:	60a8      	str	r0, [r5, #8]
    break;
  default :
    /* nothing to do */
    break;
  }
}
 8009098:	bd70      	pop	{r4, r5, r6, pc}
 800909a:	e7fe      	b.n	800909a <USBPD_DPM_CADCallback+0x5e>
    USBPD_PE_IsCableConnected(PortNum, 0);
 800909c:	2100      	movs	r1, #0
 800909e:	0020      	movs	r0, r4
 80090a0:	f7f7 fa0b 	bl	80004ba <USBPD_PE_IsCableConnected>
    if (DPM_Thread_Table[PortNum] != NULL)
 80090a4:	4e15      	ldr	r6, [pc, #84]	; (80090fc <USBPD_DPM_CADCallback+0xc0>)
 80090a6:	00a3      	lsls	r3, r4, #2
 80090a8:	18f6      	adds	r6, r6, r3
 80090aa:	68b0      	ldr	r0, [r6, #8]
 80090ac:	2800      	cmp	r0, #0
 80090ae:	d003      	beq.n	80090b8 <USBPD_DPM_CADCallback+0x7c>
      osThreadTerminate(DPM_Thread_Table[PortNum]);
 80090b0:	f002 f952 	bl	800b358 <osThreadTerminate>
      DPM_Thread_Table[PortNum] = NULL;
 80090b4:	2300      	movs	r3, #0
 80090b6:	60b3      	str	r3, [r6, #8]
    USBPD_DPM_UserCableDetection(PortNum, State);
 80090b8:	0020      	movs	r0, r4
 80090ba:	0029      	movs	r1, r5
 80090bc:	f7fd f850 	bl	8006160 <USBPD_DPM_UserCableDetection>
    DPM_Params[PortNum].PE_Power   = USBPD_POWER_NO;
 80090c0:	228c      	movs	r2, #140	; 0x8c
    DPM_Params[PortNum].ActiveCCIs = CCNONE;
 80090c2:	4b0d      	ldr	r3, [pc, #52]	; (80090f8 <USBPD_DPM_CADCallback+0xbc>)
 80090c4:	00e4      	lsls	r4, r4, #3
 80090c6:	191c      	adds	r4, r3, r4
 80090c8:	7863      	ldrb	r3, [r4, #1]
    DPM_Params[PortNum].PE_Power   = USBPD_POWER_NO;
 80090ca:	4013      	ands	r3, r2
 80090cc:	7063      	strb	r3, [r4, #1]
    break;
 80090ce:	e7e3      	b.n	8009098 <USBPD_DPM_CADCallback+0x5c>
    DPM_Params[PortNum].ActiveCCIs  = Cc;
 80090d0:	4909      	ldr	r1, [pc, #36]	; (80090f8 <USBPD_DPM_CADCallback+0xbc>)
 80090d2:	00e3      	lsls	r3, r4, #3
 80090d4:	18c9      	adds	r1, r1, r3
 80090d6:	2003      	movs	r0, #3
 80090d8:	0013      	movs	r3, r2
 80090da:	784a      	ldrb	r2, [r1, #1]
 80090dc:	4003      	ands	r3, r0
 80090de:	4382      	bics	r2, r0
    DPM_Params[PortNum].PE_Power    = USBPD_POWER_DEFAULT5V;
 80090e0:	431a      	orrs	r2, r3
 80090e2:	2370      	movs	r3, #112	; 0x70
 80090e4:	439a      	bics	r2, r3
 80090e6:	3b60      	subs	r3, #96	; 0x60
 80090e8:	431a      	orrs	r2, r3
 80090ea:	704a      	strb	r2, [r1, #1]
    USBPD_DPM_UserCableDetection(PortNum, State);
 80090ec:	0020      	movs	r0, r4
 80090ee:	2107      	movs	r1, #7
 80090f0:	f7fd f836 	bl	8006160 <USBPD_DPM_UserCableDetection>
}
 80090f4:	e7d0      	b.n	8009098 <USBPD_DPM_CADCallback+0x5c>
 80090f6:	46c0      	nop			; (mov r8, r8)
 80090f8:	20001bc0 	.word	0x20001bc0
 80090fc:	20000370 	.word	0x20000370
 8009100:	0800c664 	.word	0x0800c664

08009104 <USBPD_DPM_Init>:
{
 8009104:	b5f0      	push	{r4, r5, r6, r7, lr}
  if( USBPD_TRUE != USBPD_PE_CheckLIB(_LIB_ID))
 8009106:	482e      	ldr	r0, [pc, #184]	; (80091c0 <USBPD_DPM_Init+0xbc>)
{
 8009108:	b089      	sub	sp, #36	; 0x24
  if( USBPD_TRUE != USBPD_PE_CheckLIB(_LIB_ID))
 800910a:	f7f7 f945 	bl	8000398 <USBPD_PE_CheckLIB>
 800910e:	9001      	str	r0, [sp, #4]
 8009110:	2801      	cmp	r0, #1
 8009112:	d003      	beq.n	800911c <USBPD_DPM_Init+0x18>
    return USBPD_ERROR;
 8009114:	2602      	movs	r6, #2
}
 8009116:	0030      	movs	r0, r6
 8009118:	b009      	add	sp, #36	; 0x24
 800911a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  stack_dynamemsize = USBPD_PE_GetMemoryConsumption();
 800911c:	f7f7 f943 	bl	80003a6 <USBPD_PE_GetMemoryConsumption>
  DPM_Params[USBPD_PORT_0].PE_SpecRevision  = DPM_Settings[USBPD_PORT_0].PE_SpecRevision;
 8009120:	2203      	movs	r2, #3
  DPM_Params[USBPD_PORT_0].PE_PowerRole     = DPM_Settings[USBPD_PORT_0].PE_DefaultRole;
 8009122:	2302      	movs	r3, #2
  DPM_Params[USBPD_PORT_0].DPM_Initialized = USBPD_FALSE;
 8009124:	4c27      	ldr	r4, [pc, #156]	; (80091c4 <USBPD_DPM_Init+0xc0>)
 8009126:	2504      	movs	r5, #4
  DPM_Params[USBPD_PORT_0].PE_SpecRevision  = DPM_Settings[USBPD_PORT_0].PE_SpecRevision;
 8009128:	7820      	ldrb	r0, [r4, #0]
  DPM_Params[USBPD_PORT_0].DPM_Initialized = USBPD_FALSE;
 800912a:	7861      	ldrb	r1, [r4, #1]
  DPM_Params[USBPD_PORT_0].PE_SpecRevision  = DPM_Settings[USBPD_PORT_0].PE_SpecRevision;
 800912c:	4390      	bics	r0, r2
  DPM_Params[USBPD_PORT_0].PE_PowerRole     = DPM_Settings[USBPD_PORT_0].PE_DefaultRole;
 800912e:	4303      	orrs	r3, r0
  DPM_Params[USBPD_PORT_0].PE_SwapOngoing   = 0;
 8009130:	2010      	movs	r0, #16
 8009132:	432b      	orrs	r3, r5
 8009134:	4383      	bics	r3, r0
 8009136:	7023      	strb	r3, [r4, #0]
  DPM_Params[USBPD_PORT_0].ActiveCCIs       = CCNONE;
 8009138:	000b      	movs	r3, r1
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 800913a:	4e23      	ldr	r6, [pc, #140]	; (80091c8 <USBPD_DPM_Init+0xc4>)
  DPM_Params[USBPD_PORT_0].ActiveCCIs       = CCNONE;
 800913c:	43ab      	bics	r3, r5
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 800913e:	0037      	movs	r7, r6
 8009140:	0031      	movs	r1, r6
  DPM_Params[USBPD_PORT_0].ActiveCCIs       = CCNONE;
 8009142:	4393      	bics	r3, r2
 8009144:	7063      	strb	r3, [r4, #1]
  DPM_Params[USBPD_PORT_0].VconnCCIs        = CCNONE;
 8009146:	78a3      	ldrb	r3, [r4, #2]
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 8009148:	3728      	adds	r7, #40	; 0x28
  DPM_Params[USBPD_PORT_0].VconnStatus      = USBPD_FALSE;
 800914a:	4393      	bics	r3, r2
 800914c:	43ab      	bics	r3, r5
 800914e:	70a3      	strb	r3, [r4, #2]
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 8009150:	3134      	adds	r1, #52	; 0x34
 8009152:	0023      	movs	r3, r4
 8009154:	003a      	movs	r2, r7
 8009156:	2000      	movs	r0, #0
 8009158:	f7f6 ffd6 	bl	8000108 <USBPD_CAD_Init>
 800915c:	2800      	cmp	r0, #0
 800915e:	d1d9      	bne.n	8009114 <USBPD_DPM_Init+0x10>
  CHECK_PE_FUNCTION_CALL(USBPD_PE_Init(USBPD_PORT_0, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0], &dpmCallbacks));
 8009160:	0033      	movs	r3, r6
 8009162:	0022      	movs	r2, r4
 8009164:	333c      	adds	r3, #60	; 0x3c
 8009166:	0039      	movs	r1, r7
 8009168:	f7f7 f87e 	bl	8000268 <USBPD_PE_Init>
 800916c:	1e06      	subs	r6, r0, #0
 800916e:	d1d1      	bne.n	8009114 <USBPD_DPM_Init+0x10>
  DPM_Params[USBPD_PORT_0].DPM_Initialized = USBPD_TRUE;
 8009170:	7863      	ldrb	r3, [r4, #1]
 8009172:	431d      	orrs	r5, r3
 8009174:	7065      	strb	r5, [r4, #1]
  USBPD_DPM_UserInit();
 8009176:	f7fc ffa9 	bl	80060cc <USBPD_DPM_UserInit>
  USBPD_CAD_PortEnable(USBPD_PORT_0, USBPD_CAD_ENABLE);
 800917a:	9901      	ldr	r1, [sp, #4]
 800917c:	0030      	movs	r0, r6
 800917e:	f7f6 fffd 	bl	800017c <USBPD_CAD_PortEnable>
  osThreadDef(CAD, USBPD_CAD_Task, osPriorityNormal, 0, 150);
 8009182:	4c12      	ldr	r4, [pc, #72]	; (80091cc <USBPD_DPM_Init+0xc8>)
 8009184:	a803      	add	r0, sp, #12
 8009186:	0003      	movs	r3, r0
 8009188:	0022      	movs	r2, r4
 800918a:	caa2      	ldmia	r2!, {r1, r5, r7}
 800918c:	c3a2      	stmia	r3!, {r1, r5, r7}
 800918e:	ca22      	ldmia	r2!, {r1, r5}
 8009190:	c322      	stmia	r3!, {r1, r5}
  if((DPM_Thread_Table[USBPD_THREAD_CAD] = osThreadCreate(osThread(CAD), NULL)) == NULL)
 8009192:	0031      	movs	r1, r6
 8009194:	f002 f8c7 	bl	800b326 <osThreadCreate>
 8009198:	4d0d      	ldr	r5, [pc, #52]	; (80091d0 <USBPD_DPM_Init+0xcc>)
 800919a:	60e8      	str	r0, [r5, #12]
 800919c:	2800      	cmp	r0, #0
 800919e:	d0b9      	beq.n	8009114 <USBPD_DPM_Init+0x10>
  CADQueueId = osMessageCreate(osMessageQ(queueCAD), NULL);
 80091a0:	0020      	movs	r0, r4
 80091a2:	0031      	movs	r1, r6
 80091a4:	3014      	adds	r0, #20
 80091a6:	f002 f8e4 	bl	800b372 <osMessageCreate>
 80091aa:	6068      	str	r0, [r5, #4]
  PEQueueId[0] = osMessageCreate(osMessageQ(queuePE), NULL);
 80091ac:	0020      	movs	r0, r4
 80091ae:	0031      	movs	r1, r6
 80091b0:	301c      	adds	r0, #28
 80091b2:	f002 f8de 	bl	800b372 <osMessageCreate>
  DPM_Thread_Table[USBPD_THREAD_PORT_0] = NULL;
 80091b6:	60ae      	str	r6, [r5, #8]
  PEQueueId[0] = osMessageCreate(osMessageQ(queuePE), NULL);
 80091b8:	6028      	str	r0, [r5, #0]
  osKernelStart();
 80091ba:	f002 f8af 	bl	800b31c <osKernelStart>
  return USBPD_OK;
 80091be:	e7aa      	b.n	8009116 <USBPD_DPM_Init+0x12>
 80091c0:	30210001 	.word	0x30210001
 80091c4:	20001bc0 	.word	0x20001bc0
 80091c8:	0800c664 	.word	0x0800c664
 80091cc:	0800c6e4 	.word	0x0800c6e4
 80091d0:	20000370 	.word	0x20000370

080091d4 <USBPD_DPM_TimerCounter>:
  if (USBPD_TRUE == DPM_Params[USBPD_PORT_0].DPM_Initialized)
 80091d4:	4b0a      	ldr	r3, [pc, #40]	; (8009200 <USBPD_DPM_TimerCounter+0x2c>)
{
 80091d6:	b510      	push	{r4, lr}
  if (USBPD_TRUE == DPM_Params[USBPD_PORT_0].DPM_Initialized)
 80091d8:	785b      	ldrb	r3, [r3, #1]
 80091da:	075b      	lsls	r3, r3, #29
 80091dc:	d508      	bpl.n	80091f0 <USBPD_DPM_TimerCounter+0x1c>
    USBPD_DPM_UserTimerCounter(USBPD_PORT_0);
 80091de:	2000      	movs	r0, #0
 80091e0:	f7fc ffae 	bl	8006140 <USBPD_DPM_UserTimerCounter>
    USBPD_PE_TimerCounter(USBPD_PORT_0);
 80091e4:	2000      	movs	r0, #0
 80091e6:	f7f7 f8e9 	bl	80003bc <USBPD_PE_TimerCounter>
    USBPD_PRL_TimerCounter(USBPD_PORT_0);
 80091ea:	2000      	movs	r0, #0
 80091ec:	f7fb fe16 	bl	8004e1c <USBPD_PRL_TimerCounter>
  if (uxTaskGetNumberOfTasks() != 0)
 80091f0:	f002 fd2a 	bl	800bc48 <uxTaskGetNumberOfTasks>
 80091f4:	2800      	cmp	r0, #0
 80091f6:	d001      	beq.n	80091fc <USBPD_DPM_TimerCounter+0x28>
    osSystickHandler();
 80091f8:	f002 f922 	bl	800b440 <osSystickHandler>
}
 80091fc:	bd10      	pop	{r4, pc}
 80091fe:	46c0      	nop			; (mov r8, r8)
 8009200:	20001bc0 	.word	0x20001bc0

08009204 <CAD_Init>:
void CAD_Init(uint8_t PortNum, USBPD_SettingsTypeDef *Settings, USBPD_ParamsTypeDef *Params,  void (*WakeUp)(void))
{
  CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
  
  /* store the settings and parameters */
  _handle->params = Params;
 8009204:	2318      	movs	r3, #24
 8009206:	4343      	muls	r3, r0
{
 8009208:	b570      	push	{r4, r5, r6, lr}
  _handle->params = Params;
 800920a:	4d0e      	ldr	r5, [pc, #56]	; (8009244 <CAD_Init+0x40>)
{
 800920c:	0004      	movs	r4, r0
  _handle->settings = Settings;
 800920e:	5159      	str	r1, [r3, r5]
  _handle->params = Params;
 8009210:	18e8      	adds	r0, r5, r3
  _handle->state = USBPD_CAD_STATE_RESET;
  _handle->cc = CCNONE;
 8009212:	25c0      	movs	r5, #192	; 0xc0
  _handle->state = USBPD_CAD_STATE_RESET;
 8009214:	7c01      	ldrb	r1, [r0, #16]
  _handle->params = Params;
 8009216:	6042      	str	r2, [r0, #4]
  _handle->cc = CCNONE;
 8009218:	4029      	ands	r1, r5
 800921a:	7401      	strb	r1, [r0, #16]
  _handle->CurrentHWcondition = _handle->OldHWCondtion = HW_Detachment;
 800921c:	490a      	ldr	r1, [pc, #40]	; (8009248 <CAD_Init+0x44>)
  _handle->SNK_Source_Current_Adv = vRd_Undefined;
  
  if(_handle->params->PE_PowerRole == USBPD_PORTPOWERROLE_SRC)
  {
    USBPDM1_DeAssertRd(PortNum);
 800921e:	0020      	movs	r0, r4
  _handle->CurrentHWcondition = _handle->OldHWCondtion = HW_Detachment;
 8009220:	185b      	adds	r3, r3, r1
 8009222:	2100      	movs	r1, #0
 8009224:	7059      	strb	r1, [r3, #1]
  if(_handle->params->PE_PowerRole == USBPD_PORTPOWERROLE_SRC)
 8009226:	7813      	ldrb	r3, [r2, #0]
 8009228:	075b      	lsls	r3, r3, #29
 800922a:	d505      	bpl.n	8009238 <CAD_Init+0x34>
    USBPDM1_DeAssertRd(PortNum);
 800922c:	f001 f84b 	bl	800a2c6 <USBPDM1_DeAssertRd>
    USBPDM1_AssertRp(PortNum);
 8009230:	0020      	movs	r0, r4
 8009232:	f001 f845 	bl	800a2c0 <USBPDM1_AssertRp>
  else
  {
    USBPDM1_DeAssertRp(PortNum);
    USBPDM1_AssertRd(PortNum);
  }
}
 8009236:	bd70      	pop	{r4, r5, r6, pc}
    USBPDM1_DeAssertRp(PortNum);
 8009238:	f001 f843 	bl	800a2c2 <USBPDM1_DeAssertRp>
    USBPDM1_AssertRd(PortNum);
 800923c:	0020      	movs	r0, r4
 800923e:	f001 f841 	bl	800a2c4 <USBPDM1_AssertRd>
}
 8009242:	e7f8      	b.n	8009236 <CAD_Init+0x32>
 8009244:	20001bc8 	.word	0x20001bc8
 8009248:	20001bd8 	.word	0x20001bd8

0800924c <CAD_Enter_ErrorRecovery>:
  * @brief  CAD enters in error recovery mode 
  * @param  PortNum  Number of the port
  * @retval None
  */ 
void CAD_Enter_ErrorRecovery(uint8_t PortNum)
{
 800924c:	b510      	push	{r4, lr}
  /* remove resistor terminaison 
     switch CAD_StateMachine to Error Recovery state
     wakeup CAD task */
  USBPD_HW_IF_ErrorRecovery(PortNum);
 800924e:	f001 f8c1 	bl	800a3d4 <USBPD_HW_IF_ErrorRecovery>
}
 8009252:	bd10      	pop	{r4, pc}

08009254 <USBPD_HW_IF_EXTI_Callback>:
  * @arg     ALERT_GPIO_PIN(1)    ** Defined in usbpd_porthandle.h **
  * @arg     SPI_NSS_PIN(1)       ** Defined in usbpd_porthandle.h **
  * @retval None
  */
void USBPD_HW_IF_EXTI_Callback(uint16_t GPIO_Pin)
{
 8009254:	b570      	push	{r4, r5, r6, lr}
 8009256:	0001      	movs	r1, r0
  uint8_t PortNum=0;
  GPIO_PinState NSSCurrentState;
  switch (GPIO_Pin)
 8009258:	2802      	cmp	r0, #2
 800925a:	d005      	beq.n	8009268 <USBPD_HW_IF_EXTI_Callback+0x14>
 800925c:	2380      	movs	r3, #128	; 0x80
 800925e:	015b      	lsls	r3, r3, #5
 8009260:	4298      	cmp	r0, r3
 8009262:	d005      	beq.n	8009270 <USBPD_HW_IF_EXTI_Callback+0x1c>
 8009264:	46c0      	nop			; (mov r8, r8)
    
  default:
    __NOP();
    break;
  }
}
 8009266:	e002      	b.n	800926e <USBPD_HW_IF_EXTI_Callback+0x1a>
    STUSB16xx_HW_IF_Alert_Check(ALERT_PORT_INDEX(0));
 8009268:	2000      	movs	r0, #0
 800926a:	f001 fd7d 	bl	800ad68 <STUSB16xx_HW_IF_Alert_Check>
}
 800926e:	bd70      	pop	{r4, r5, r6, pc}
    NSSCurrentState = HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum));
 8009270:	4809      	ldr	r0, [pc, #36]	; (8009298 <USBPD_HW_IF_EXTI_Callback+0x44>)
 8009272:	f7fe fb81 	bl	8007978 <HAL_GPIO_ReadPin>
 8009276:	4d09      	ldr	r5, [pc, #36]	; (800929c <USBPD_HW_IF_EXTI_Callback+0x48>)
 8009278:	0004      	movs	r4, r0
    if( NSSCurrentState == GPIO_PIN_SET || RxNSSStatus[PortNum] == GPIO_PIN_RESET) 
 800927a:	2801      	cmp	r0, #1
 800927c:	d002      	beq.n	8009284 <USBPD_HW_IF_EXTI_Callback+0x30>
 800927e:	782b      	ldrb	r3, [r5, #0]
 8009280:	2b00      	cmp	r3, #0
 8009282:	d102      	bne.n	800928a <USBPD_HW_IF_EXTI_Callback+0x36>
      PHY_HW_IF_RX_Stop(PortNum);
 8009284:	2000      	movs	r0, #0
 8009286:	f000 fc0f 	bl	8009aa8 <PHY_HW_IF_RX_Stop>
    if( NSSCurrentState == GPIO_PIN_RESET )
 800928a:	2c00      	cmp	r4, #0
 800928c:	d102      	bne.n	8009294 <USBPD_HW_IF_EXTI_Callback+0x40>
      PHY_HW_IF_RX_Start(PortNum);
 800928e:	0020      	movs	r0, r4
 8009290:	f000 fec8 	bl	800a024 <PHY_HW_IF_RX_Start>
    RxNSSStatus[PortNum] = NSSCurrentState;
 8009294:	702c      	strb	r4, [r5, #0]
    break;    
 8009296:	e7ea      	b.n	800926e <USBPD_HW_IF_EXTI_Callback+0x1a>
 8009298:	48000400 	.word	0x48000400
 800929c:	20000058 	.word	0x20000058

080092a0 <USBPD_DMA_PORT0_IRQHandler>:
/**
  * @brief   This function handles DMA interrupts on channels 4, 5, 6 and 7
  * @retval  None
  */
void USBPD_DMA_PORT0_IRQHandler(void)
{
 80092a0:	b570      	push	{r4, r5, r6, lr}
  uint8_t *end;
  
  /* Handler DMA TX PORT 0  */
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmatx)) != RESET)
 80092a2:	4d39      	ldr	r5, [pc, #228]	; (8009388 <USBPD_DMA_PORT0_IRQHandler+0xe8>)
 80092a4:	4c39      	ldr	r4, [pc, #228]	; (800938c <USBPD_DMA_PORT0_IRQHandler+0xec>)
 80092a6:	002b      	movs	r3, r5
 80092a8:	33a4      	adds	r3, #164	; 0xa4
 80092aa:	681a      	ldr	r2, [r3, #0]
 80092ac:	4838      	ldr	r0, [pc, #224]	; (8009390 <USBPD_DMA_PORT0_IRQHandler+0xf0>)
 80092ae:	6821      	ldr	r1, [r4, #0]
 80092b0:	2302      	movs	r3, #2
 80092b2:	4282      	cmp	r2, r0
 80092b4:	d016      	beq.n	80092e4 <USBPD_DMA_PORT0_IRQHandler+0x44>
 80092b6:	4e37      	ldr	r6, [pc, #220]	; (8009394 <USBPD_DMA_PORT0_IRQHandler+0xf4>)
 80092b8:	331e      	adds	r3, #30
 80092ba:	42b2      	cmp	r2, r6
 80092bc:	d012      	beq.n	80092e4 <USBPD_DMA_PORT0_IRQHandler+0x44>
 80092be:	4b36      	ldr	r3, [pc, #216]	; (8009398 <USBPD_DMA_PORT0_IRQHandler+0xf8>)
 80092c0:	429a      	cmp	r2, r3
 80092c2:	d01a      	beq.n	80092fa <USBPD_DMA_PORT0_IRQHandler+0x5a>
 80092c4:	4b35      	ldr	r3, [pc, #212]	; (800939c <USBPD_DMA_PORT0_IRQHandler+0xfc>)
 80092c6:	429a      	cmp	r2, r3
 80092c8:	d01a      	beq.n	8009300 <USBPD_DMA_PORT0_IRQHandler+0x60>
 80092ca:	4b35      	ldr	r3, [pc, #212]	; (80093a0 <USBPD_DMA_PORT0_IRQHandler+0x100>)
 80092cc:	429a      	cmp	r2, r3
 80092ce:	d01a      	beq.n	8009306 <USBPD_DMA_PORT0_IRQHandler+0x66>
 80092d0:	4b34      	ldr	r3, [pc, #208]	; (80093a4 <USBPD_DMA_PORT0_IRQHandler+0x104>)
 80092d2:	18d2      	adds	r2, r2, r3
 80092d4:	4253      	negs	r3, r2
 80092d6:	4153      	adcs	r3, r2
 80092d8:	4a33      	ldr	r2, [pc, #204]	; (80093a8 <USBPD_DMA_PORT0_IRQHandler+0x108>)
 80092da:	425b      	negs	r3, r3
 80092dc:	4013      	ands	r3, r2
 80092de:	2280      	movs	r2, #128	; 0x80
 80092e0:	0492      	lsls	r2, r2, #18
 80092e2:	189b      	adds	r3, r3, r2
 80092e4:	420b      	tst	r3, r1
 80092e6:	d025      	beq.n	8009334 <USBPD_DMA_PORT0_IRQHandler+0x94>
  {
    /* Transfer complete interrupt is used to end the transmission */
    if (Ports[0].State!=HAL_USBPD_PORT_STATE_BIST)
 80092e8:	7e6b      	ldrb	r3, [r5, #25]
 80092ea:	2b08      	cmp	r3, #8
 80092ec:	d00e      	beq.n	800930c <USBPD_DMA_PORT0_IRQHandler+0x6c>
    {
      PHY_HW_IF_TX_Done(0);
 80092ee:	2000      	movs	r0, #0
 80092f0:	f000 fd4e 	bl	8009d90 <PHY_HW_IF_TX_Done>
  else if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmarx)) != RESET)
  {
    __NOP();
  }
  
  __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 80092f4:	4b2d      	ldr	r3, [pc, #180]	; (80093ac <USBPD_DMA_PORT0_IRQHandler+0x10c>)
 80092f6:	6063      	str	r3, [r4, #4]
}
 80092f8:	bd70      	pop	{r4, r5, r6, pc}
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmatx)) != RESET)
 80092fa:	2380      	movs	r3, #128	; 0x80
 80092fc:	009b      	lsls	r3, r3, #2
 80092fe:	e7f1      	b.n	80092e4 <USBPD_DMA_PORT0_IRQHandler+0x44>
 8009300:	2380      	movs	r3, #128	; 0x80
 8009302:	019b      	lsls	r3, r3, #6
 8009304:	e7ee      	b.n	80092e4 <USBPD_DMA_PORT0_IRQHandler+0x44>
 8009306:	2380      	movs	r3, #128	; 0x80
 8009308:	029b      	lsls	r3, r3, #10
 800930a:	e7eb      	b.n	80092e4 <USBPD_DMA_PORT0_IRQHandler+0x44>
      Ports[0].BIST_index+=1;
 800930c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800930e:	3301      	adds	r3, #1
 8009310:	626b      	str	r3, [r5, #36]	; 0x24
      if(Ports[0].BIST_index == BIST_MAX_LENGTH) 
 8009312:	2b1e      	cmp	r3, #30
 8009314:	d105      	bne.n	8009322 <USBPD_DMA_PORT0_IRQHandler+0x82>
        end[(TX_BUFFER_LEN)*2 - 1] = 0;
 8009316:	2000      	movs	r0, #0
 8009318:	686b      	ldr	r3, [r5, #4]
 800931a:	3337      	adds	r3, #55	; 0x37
 800931c:	7018      	strb	r0, [r3, #0]
        STUSB16xx_HW_IF_Set_DMA_Normal_Mode(0); 
 800931e:	f001 fc4d 	bl	800abbc <STUSB16xx_HW_IF_Set_DMA_Normal_Mode>
      if(Ports[0].BIST_index > BIST_MAX_LENGTH) 
 8009322:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8009324:	2b1e      	cmp	r3, #30
 8009326:	d9e5      	bls.n	80092f4 <USBPD_DMA_PORT0_IRQHandler+0x54>
        PHY_HW_IF_TX_Done(0);
 8009328:	2000      	movs	r0, #0
 800932a:	f000 fd31 	bl	8009d90 <PHY_HW_IF_TX_Done>
        Ports[0].BIST_index=0;
 800932e:	2300      	movs	r3, #0
 8009330:	626b      	str	r3, [r5, #36]	; 0x24
 8009332:	e7df      	b.n	80092f4 <USBPD_DMA_PORT0_IRQHandler+0x54>
  else if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmarx)) != RESET)
 8009334:	35e8      	adds	r5, #232	; 0xe8
 8009336:	682a      	ldr	r2, [r5, #0]
 8009338:	6821      	ldr	r1, [r4, #0]
 800933a:	2302      	movs	r3, #2
 800933c:	4282      	cmp	r2, r0
 800933e:	d016      	beq.n	800936e <USBPD_DMA_PORT0_IRQHandler+0xce>
 8009340:	4814      	ldr	r0, [pc, #80]	; (8009394 <USBPD_DMA_PORT0_IRQHandler+0xf4>)
 8009342:	331e      	adds	r3, #30
 8009344:	4282      	cmp	r2, r0
 8009346:	d012      	beq.n	800936e <USBPD_DMA_PORT0_IRQHandler+0xce>
 8009348:	4b13      	ldr	r3, [pc, #76]	; (8009398 <USBPD_DMA_PORT0_IRQHandler+0xf8>)
 800934a:	429a      	cmp	r2, r3
 800934c:	d013      	beq.n	8009376 <USBPD_DMA_PORT0_IRQHandler+0xd6>
 800934e:	4b13      	ldr	r3, [pc, #76]	; (800939c <USBPD_DMA_PORT0_IRQHandler+0xfc>)
 8009350:	429a      	cmp	r2, r3
 8009352:	d013      	beq.n	800937c <USBPD_DMA_PORT0_IRQHandler+0xdc>
 8009354:	4b12      	ldr	r3, [pc, #72]	; (80093a0 <USBPD_DMA_PORT0_IRQHandler+0x100>)
 8009356:	429a      	cmp	r2, r3
 8009358:	d013      	beq.n	8009382 <USBPD_DMA_PORT0_IRQHandler+0xe2>
 800935a:	4b12      	ldr	r3, [pc, #72]	; (80093a4 <USBPD_DMA_PORT0_IRQHandler+0x104>)
 800935c:	18d2      	adds	r2, r2, r3
 800935e:	4253      	negs	r3, r2
 8009360:	4153      	adcs	r3, r2
 8009362:	4a11      	ldr	r2, [pc, #68]	; (80093a8 <USBPD_DMA_PORT0_IRQHandler+0x108>)
 8009364:	425b      	negs	r3, r3
 8009366:	4013      	ands	r3, r2
 8009368:	2280      	movs	r2, #128	; 0x80
 800936a:	0492      	lsls	r2, r2, #18
 800936c:	189b      	adds	r3, r3, r2
 800936e:	420b      	tst	r3, r1
 8009370:	d0c0      	beq.n	80092f4 <USBPD_DMA_PORT0_IRQHandler+0x54>
 8009372:	46c0      	nop			; (mov r8, r8)
 8009374:	e7be      	b.n	80092f4 <USBPD_DMA_PORT0_IRQHandler+0x54>
 8009376:	2380      	movs	r3, #128	; 0x80
 8009378:	009b      	lsls	r3, r3, #2
 800937a:	e7f8      	b.n	800936e <USBPD_DMA_PORT0_IRQHandler+0xce>
 800937c:	2380      	movs	r3, #128	; 0x80
 800937e:	019b      	lsls	r3, r3, #6
 8009380:	e7f5      	b.n	800936e <USBPD_DMA_PORT0_IRQHandler+0xce>
 8009382:	2380      	movs	r3, #128	; 0x80
 8009384:	029b      	lsls	r3, r3, #10
 8009386:	e7f2      	b.n	800936e <USBPD_DMA_PORT0_IRQHandler+0xce>
 8009388:	2000007c 	.word	0x2000007c
 800938c:	40020000 	.word	0x40020000
 8009390:	40020008 	.word	0x40020008
 8009394:	4002001c 	.word	0x4002001c
 8009398:	40020030 	.word	0x40020030
 800939c:	40020044 	.word	0x40020044
 80093a0:	40020058 	.word	0x40020058
 80093a4:	bffdff94 	.word	0xbffdff94
 80093a8:	fe200000 	.word	0xfe200000
 80093ac:	0fffffff 	.word	0x0fffffff

080093b0 <USBPD_RX_PORT0_COUNTTIM_IRQHandler>:
  * @brief   This function handles interrupts of RX timer associated to port 0
  * @details This timer is used to trigger the data decoding procedure on port 0
  * @retval  None
  */
void USBPD_RX_PORT0_COUNTTIM_IRQHandler(void)
{
 80093b0:	b570      	push	{r4, r5, r6, lr}
  * @retval None
  */
static inline void SINGLE_TIM_IRQHandler(TIM_HandleTypeDef *htim, uint32_t Flag, uint32_t Timit)
{
  /* Capture compare event */
  if(__HAL_TIM_GET_FLAG(htim, Flag) != RESET)
 80093b2:	4c0b      	ldr	r4, [pc, #44]	; (80093e0 <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x30>)
 80093b4:	2202      	movs	r2, #2
 80093b6:	0023      	movs	r3, r4
 80093b8:	33fc      	adds	r3, #252	; 0xfc
 80093ba:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80093bc:	6919      	ldr	r1, [r3, #16]
 80093be:	4211      	tst	r1, r2
 80093c0:	d00d      	beq.n	80093de <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x2e>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, Timit) != RESET)
 80093c2:	68d9      	ldr	r1, [r3, #12]
 80093c4:	4211      	tst	r1, r2
 80093c6:	d00a      	beq.n	80093de <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x2e>
    {
        __HAL_TIM_CLEAR_IT(htim, Timit);
 80093c8:	3a05      	subs	r2, #5
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80093ca:	25ca      	movs	r5, #202	; 0xca
        __HAL_TIM_CLEAR_IT(htim, Timit);
 80093cc:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80093ce:	2301      	movs	r3, #1
 80093d0:	006d      	lsls	r5, r5, #1
 80093d2:	5563      	strb	r3, [r4, r5]
        /* Output compare event */
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80093d4:	4803      	ldr	r0, [pc, #12]	; (80093e4 <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x34>)
 80093d6:	f000 fc0b 	bl	8009bf0 <HAL_TIM_OC_DelayElapsedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80093da:	2300      	movs	r3, #0
 80093dc:	5563      	strb	r3, [r4, r5]
}
 80093de:	bd70      	pop	{r4, r5, r6, pc}
 80093e0:	2000007c 	.word	0x2000007c
 80093e4:	200001f4 	.word	0x200001f4

080093e8 <PHY_BistCompleted>:
 * @param  bistmode  Modality of the BIST
 * @retval none.
 */
void PHY_BistCompleted(uint8_t PortNum, USBPD_BISTMsg_TypeDef bistmode)
{
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_BistCompleted)
 80093e8:	237c      	movs	r3, #124	; 0x7c
 80093ea:	4343      	muls	r3, r0
 80093ec:	4a03      	ldr	r2, [pc, #12]	; (80093fc <PHY_BistCompleted+0x14>)
{
 80093ee:	b510      	push	{r4, lr}
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_BistCompleted)
 80093f0:	589b      	ldr	r3, [r3, r2]
 80093f2:	691b      	ldr	r3, [r3, #16]
 80093f4:	2b00      	cmp	r3, #0
 80093f6:	d000      	beq.n	80093fa <PHY_BistCompleted+0x12>
  {
    PHY_Ports[PortNum].cbs->USBPD_PHY_BistCompleted(PortNum,bistmode);
 80093f8:	4798      	blx	r3
  }
}
 80093fa:	bd10      	pop	{r4, pc}
 80093fc:	20000380 	.word	0x20000380

08009400 <PHY_TxCompleted>:
 * @param  PortNum  Number of the port.
 * @retval none.
 */
void PHY_TxCompleted(uint8_t PortNum)
{
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009400:	237c      	movs	r3, #124	; 0x7c
{
 8009402:	b510      	push	{r4, lr}
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009404:	2400      	movs	r4, #0
 8009406:	4343      	muls	r3, r0
 8009408:	4a04      	ldr	r2, [pc, #16]	; (800941c <PHY_TxCompleted+0x1c>)
 800940a:	18d1      	adds	r1, r2, r3
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_TxCompleted)
 800940c:	589b      	ldr	r3, [r3, r2]
  PHY_Ports[PortNum].State = PHY_StateNone;
 800940e:	720c      	strb	r4, [r1, #8]
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_TxCompleted)
 8009410:	695b      	ldr	r3, [r3, #20]
 8009412:	42a3      	cmp	r3, r4
 8009414:	d000      	beq.n	8009418 <PHY_TxCompleted+0x18>
  {
    PHY_Ports[PortNum].cbs->USBPD_PHY_TxCompleted(PortNum);
 8009416:	4798      	blx	r3
  }
}
 8009418:	bd10      	pop	{r4, pc}
 800941a:	46c0      	nop			; (mov r8, r8)
 800941c:	20000380 	.word	0x20000380

08009420 <PHY_Rx_Reset>:
{
  /* Get the pointer to the decoding structure */
  PHY_RxDecodingTypeDef *pRxData = (PHY_RxDecodingTypeDef *)&PHY_Ports[PortNum].RxDec;

  /* reset the status of the RX process */
  pRxData->Status = USBPD_PHY_RX_STATUS_NONE;
 8009420:	237c      	movs	r3, #124	; 0x7c
 8009422:	4358      	muls	r0, r3
 8009424:	4a0a      	ldr	r2, [pc, #40]	; (8009450 <PHY_Rx_Reset+0x30>)
{
 8009426:	b570      	push	{r4, r5, r6, lr}
  pRxData->Status = USBPD_PHY_RX_STATUS_NONE;
 8009428:	1814      	adds	r4, r2, r0
 800942a:	0026      	movs	r6, r4
 800942c:	2500      	movs	r5, #0
 800942e:	3640      	adds	r6, #64	; 0x40

  /* reset the variable of count and memory */
  pRxData->DataCount = 0;
  memset(pRxData->Data, 0, __RX_DATA_LEN);
 8009430:	3049      	adds	r0, #73	; 0x49
  pRxData->Status = USBPD_PHY_RX_STATUS_NONE;
 8009432:	7035      	strb	r5, [r6, #0]
  pRxData->DataCount = 0;
 8009434:	6765      	str	r5, [r4, #116]	; 0x74
  memset(pRxData->Data, 0, __RX_DATA_LEN);
 8009436:	0029      	movs	r1, r5
 8009438:	1810      	adds	r0, r2, r0
 800943a:	2228      	movs	r2, #40	; 0x28
 800943c:	f003 f85f 	bl	800c4fe <memset>

  /* reset the type of SOP */
  pRxData->MsgType = USBPD_SOPTYPE_INVALID;
 8009440:	0023      	movs	r3, r4
 8009442:	22ff      	movs	r2, #255	; 0xff
 8009444:	3348      	adds	r3, #72	; 0x48

  /* reset the type of OrderSet received */
  pRxData->OrderSet = 0x00;
 8009446:	6465      	str	r5, [r4, #68]	; 0x44
  pRxData->MsgType = USBPD_SOPTYPE_INVALID;
 8009448:	701a      	strb	r2, [r3, #0]

  return pRxData->Status;
 800944a:	7830      	ldrb	r0, [r6, #0]
}
 800944c:	bd70      	pop	{r4, r5, r6, pc}
 800944e:	46c0      	nop			; (mov r8, r8)
 8009450:	20000380 	.word	0x20000380

08009454 <PHY_Rx_Completed>:
  * @brief  Callback to notify the end of the current reception
  * @param  PortNum  Number of the port
  * @retval Status of current reception
  */
USBPD_PHY_RX_Status_TypeDef PHY_Rx_Completed(uint8_t PortNum)
{
 8009454:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t crc_read,crc_calc;
  PHY_RxDecodingTypeDef * pRxData = (PHY_RxDecodingTypeDef *)&PHY_Ports[PortNum].RxDec;
  if (pRxData->Status != USBPD_PHY_RX_STATUS_MESSAGE_READY)
 8009456:	257c      	movs	r5, #124	; 0x7c
 8009458:	4345      	muls	r5, r0
 800945a:	4e2b      	ldr	r6, [pc, #172]	; (8009508 <PHY_Rx_Completed+0xb4>)
{
 800945c:	0007      	movs	r7, r0
  if (pRxData->Status != USBPD_PHY_RX_STATUS_MESSAGE_READY)
 800945e:	1974      	adds	r4, r6, r5
 8009460:	0023      	movs	r3, r4
 8009462:	3340      	adds	r3, #64	; 0x40
 8009464:	7818      	ldrb	r0, [r3, #0]
{
 8009466:	b085      	sub	sp, #20
  if (pRxData->Status != USBPD_PHY_RX_STATUS_MESSAGE_READY)
 8009468:	9301      	str	r3, [sp, #4]
 800946a:	2804      	cmp	r0, #4
 800946c:	d111      	bne.n	8009492 <PHY_Rx_Completed+0x3e>
  {
    return pRxData->Status;
  }

  if (pRxData->MsgType == USBPD_SOPTYPE_HARD_RESET || pRxData->MsgType == USBPD_SOPTYPE_CABLE_RESET)
 800946e:	3308      	adds	r3, #8
 8009470:	7819      	ldrb	r1, [r3, #0]
 8009472:	9302      	str	r3, [sp, #8]
 8009474:	1f4b      	subs	r3, r1, #5
 8009476:	2b01      	cmp	r3, #1
 8009478:	d80d      	bhi.n	8009496 <PHY_Rx_Completed+0x42>
  {
    /* received a hard reset, call the callback, no other checks */
    if (PHY_Ports[PortNum].cbs->USBPD_PHY_ResetIndication != NULL)
 800947a:	59ab      	ldr	r3, [r5, r6]
 800947c:	685b      	ldr	r3, [r3, #4]
 800947e:	2b00      	cmp	r3, #0
 8009480:	d001      	beq.n	8009486 <PHY_Rx_Completed+0x32>
    {
      PHY_Ports[PortNum].cbs->USBPD_PHY_ResetIndication(PortNum, pRxData->MsgType);
 8009482:	0038      	movs	r0, r7
 8009484:	4798      	blx	r3
    }
    return pRxData->Status = USBPD_PHY_RX_STATUS_OK;
 8009486:	237c      	movs	r3, #124	; 0x7c
 8009488:	2001      	movs	r0, #1
 800948a:	435f      	muls	r7, r3
 800948c:	19f6      	adds	r6, r6, r7
 800948e:	3640      	adds	r6, #64	; 0x40
 8009490:	7030      	strb	r0, [r6, #0]
  {
    PHY_Ports[PortNum].cbs->USBPD_PHY_MessageReceived(PortNum, pRxData->MsgType);
  }

  return pRxData->Status = USBPD_PHY_RX_STATUS_OK;
}
 8009492:	b005      	add	sp, #20
 8009494:	bdf0      	pop	{r4, r5, r6, r7, pc}
  uint8_t *pRxBuffer = PHY_Ports[PortNum].pRxBuffer;
 8009496:	6863      	ldr	r3, [r4, #4]
 8009498:	9303      	str	r3, [sp, #12]
  crc_calc = USBPD_HW_IF_CRC_Calculate(pRxData->Data, pRxData->DataCount - 4);
 800949a:	002b      	movs	r3, r5
 800949c:	3349      	adds	r3, #73	; 0x49
 800949e:	18f3      	adds	r3, r6, r3
 80094a0:	9300      	str	r3, [sp, #0]
 80094a2:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80094a4:	9800      	ldr	r0, [sp, #0]
 80094a6:	1f19      	subs	r1, r3, #4
 80094a8:	b2c9      	uxtb	r1, r1
 80094aa:	f000 fa3d 	bl	8009928 <USBPD_HW_IF_CRC_Calculate>
 80094ae:	4684      	mov	ip, r0
  uint8_t *pCrcField = &pRxData->Data[pRxData->DataCount - 4];
 80094b0:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80094b2:	1f1a      	subs	r2, r3, #4
 80094b4:	1951      	adds	r1, r2, r5
 80094b6:	3149      	adds	r1, #73	; 0x49
 80094b8:	1871      	adds	r1, r6, r1
  crc_read = *pCrcField;
 80094ba:	18a4      	adds	r4, r4, r2
  crc_read |= ((*pCrcField) << 8);
 80094bc:	784b      	ldrb	r3, [r1, #1]
  crc_read |= ((*pCrcField) << 16);
 80094be:	7888      	ldrb	r0, [r1, #2]
  crc_read = *pCrcField;
 80094c0:	3449      	adds	r4, #73	; 0x49
 80094c2:	7824      	ldrb	r4, [r4, #0]
  crc_read |= ((*pCrcField) << 8);
 80094c4:	021b      	lsls	r3, r3, #8
  crc_read |= ((*pCrcField) << 16);
 80094c6:	0400      	lsls	r0, r0, #16
 80094c8:	4303      	orrs	r3, r0
 80094ca:	4323      	orrs	r3, r4
  crc_read |= ((*pCrcField) << 24);
 80094cc:	78cc      	ldrb	r4, [r1, #3]
 80094ce:	0624      	lsls	r4, r4, #24
 80094d0:	431c      	orrs	r4, r3
  if (crc_read != crc_calc)
 80094d2:	45a4      	cmp	ip, r4
 80094d4:	d003      	beq.n	80094de <PHY_Rx_Completed+0x8a>
    return pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_CRC_FAILED;
 80094d6:	200a      	movs	r0, #10
 80094d8:	9b01      	ldr	r3, [sp, #4]
 80094da:	7018      	strb	r0, [r3, #0]
 80094dc:	e7d9      	b.n	8009492 <PHY_Rx_Completed+0x3e>
  memcpy(pRxBuffer, pRxData->Data, pRxData->DataCount - 4);
 80094de:	9900      	ldr	r1, [sp, #0]
 80094e0:	9803      	ldr	r0, [sp, #12]
 80094e2:	f003 f803 	bl	800c4ec <memcpy>
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_MessageReceived != NULL)
 80094e6:	59ab      	ldr	r3, [r5, r6]
 80094e8:	681b      	ldr	r3, [r3, #0]
 80094ea:	2b00      	cmp	r3, #0
 80094ec:	d003      	beq.n	80094f6 <PHY_Rx_Completed+0xa2>
    PHY_Ports[PortNum].cbs->USBPD_PHY_MessageReceived(PortNum, pRxData->MsgType);
 80094ee:	9a02      	ldr	r2, [sp, #8]
 80094f0:	0038      	movs	r0, r7
 80094f2:	7811      	ldrb	r1, [r2, #0]
 80094f4:	4798      	blx	r3
  return pRxData->Status = USBPD_PHY_RX_STATUS_OK;
 80094f6:	267c      	movs	r6, #124	; 0x7c
 80094f8:	2001      	movs	r0, #1
 80094fa:	437e      	muls	r6, r7
 80094fc:	4f02      	ldr	r7, [pc, #8]	; (8009508 <PHY_Rx_Completed+0xb4>)
 80094fe:	19bf      	adds	r7, r7, r6
 8009500:	3740      	adds	r7, #64	; 0x40
 8009502:	7038      	strb	r0, [r7, #0]
 8009504:	e7c5      	b.n	8009492 <PHY_Rx_Completed+0x3e>
 8009506:	46c0      	nop			; (mov r8, r8)
 8009508:	20000380 	.word	0x20000380

0800950c <PHY_Encode5b_Short>:
{
 800950c:	b510      	push	{r4, lr}
  return coding4b5b[val & 0x0F] | (coding4b5b[(val >> 4) & 0x0F] << 5);
 800950e:	240f      	movs	r4, #15
 8009510:	4908      	ldr	r1, [pc, #32]	; (8009534 <PHY_Encode5b_Short+0x28>)
  return PHY_Encode5b_Byte(val & 0x00FF) | (PHY_Encode5b_Byte((val >> 8) & 0x00FF) << 10);
 8009512:	b2c2      	uxtb	r2, r0
 8009514:	0a00      	lsrs	r0, r0, #8
  return coding4b5b[val & 0x0F] | (coding4b5b[(val >> 4) & 0x0F] << 5);
 8009516:	0903      	lsrs	r3, r0, #4
 8009518:	5ccb      	ldrb	r3, [r1, r3]
 800951a:	4020      	ands	r0, r4
 800951c:	5c08      	ldrb	r0, [r1, r0]
 800951e:	015b      	lsls	r3, r3, #5
 8009520:	4303      	orrs	r3, r0
 8009522:	0910      	lsrs	r0, r2, #4
 8009524:	5c08      	ldrb	r0, [r1, r0]
 8009526:	4022      	ands	r2, r4
 8009528:	5c8a      	ldrb	r2, [r1, r2]
 800952a:	0140      	lsls	r0, r0, #5
  return PHY_Encode5b_Byte(val & 0x00FF) | (PHY_Encode5b_Byte((val >> 8) & 0x00FF) << 10);
 800952c:	029b      	lsls	r3, r3, #10
  return coding4b5b[val & 0x0F] | (coding4b5b[(val >> 4) & 0x0F] << 5);
 800952e:	4310      	orrs	r0, r2
  return PHY_Encode5b_Byte(val & 0x00FF) | (PHY_Encode5b_Byte((val >> 8) & 0x00FF) << 10);
 8009530:	4318      	orrs	r0, r3
}
 8009532:	bd10      	pop	{r4, pc}
 8009534:	0800c740 	.word	0x0800c740

08009538 <USBPD_PHY_GetRetryTimerValue>:
  return 920u;
 8009538:	20e6      	movs	r0, #230	; 0xe6
}
 800953a:	0080      	lsls	r0, r0, #2
 800953c:	4770      	bx	lr
	...

08009540 <USBPD_PHY_Send_BIST_Pattern>:
  PHY_Ports[PortNum].State = PHY_StateBusyBIST_Tx;
 8009540:	237c      	movs	r3, #124	; 0x7c
 8009542:	4343      	muls	r3, r0
{
 8009544:	b510      	push	{r4, lr}
  PHY_Ports[PortNum].State = PHY_StateBusyBIST_Tx;
 8009546:	4c04      	ldr	r4, [pc, #16]	; (8009558 <USBPD_PHY_Send_BIST_Pattern+0x18>)
 8009548:	18e4      	adds	r4, r4, r3
 800954a:	2305      	movs	r3, #5
 800954c:	7223      	strb	r3, [r4, #8]
  USBPD_HW_IF_Send_BIST_Pattern(PortNum);
 800954e:	f000 fa2b 	bl	80099a8 <USBPD_HW_IF_Send_BIST_Pattern>
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009552:	2000      	movs	r0, #0
 8009554:	7220      	strb	r0, [r4, #8]
}
 8009556:	bd10      	pop	{r4, pc}
 8009558:	20000380 	.word	0x20000380

0800955c <USBPD_PHY_ExitTransmit>:
}
 800955c:	2000      	movs	r0, #0
 800955e:	4770      	bx	lr

08009560 <USBPD_PHY_SetResistor_SinkTxNG>:
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_1_5_A);
 8009560:	1e43      	subs	r3, r0, #1
 8009562:	4198      	sbcs	r0, r3
{
 8009564:	b510      	push	{r4, lr}
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_1_5_A);
 8009566:	3028      	adds	r0, #40	; 0x28
 8009568:	2101      	movs	r1, #1
 800956a:	f7fd f9fd 	bl	8006968 <STUSB1602_Current_Advertised_Set>
}
 800956e:	bd10      	pop	{r4, pc}

08009570 <USBPD_PHY_SetResistor_SinkTxOK>:
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 8009570:	1e43      	subs	r3, r0, #1
 8009572:	4198      	sbcs	r0, r3
{
 8009574:	b510      	push	{r4, lr}
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 8009576:	3028      	adds	r0, #40	; 0x28
 8009578:	2102      	movs	r1, #2
 800957a:	f7fd f9f5 	bl	8006968 <STUSB1602_Current_Advertised_Set>
}
 800957e:	bd10      	pop	{r4, pc}

08009580 <USBPD_PHY_SOPSupported>:
}
 8009580:	4770      	bx	lr

08009582 <USBPD_PHY_IsResistor_SinkTxOk>:
{
 8009582:	b510      	push	{r4, lr}
  return USBPD_16xx_IsResistor_SinkTxOk(PortNum);
 8009584:	f001 fe0c 	bl	800b1a0 <USBPD_16xx_IsResistor_SinkTxOk>
}
 8009588:	bd10      	pop	{r4, pc}

0800958a <USBPD_PHY_FastRoleSwapSignalling>:
 800958a:	4770      	bx	lr

0800958c <PHY_TxBuffer_Reset>:
{
 800958c:	b570      	push	{r4, r5, r6, lr}
  memset((void *)PHY_Ports[PortNum].TxBuffer, 0, __TX_BUFF_SIZE);
 800958e:	257c      	movs	r5, #124	; 0x7c
 8009590:	4345      	muls	r5, r0
 8009592:	0028      	movs	r0, r5
 8009594:	4c05      	ldr	r4, [pc, #20]	; (80095ac <PHY_TxBuffer_Reset+0x20>)
 8009596:	300c      	adds	r0, #12
 8009598:	1820      	adds	r0, r4, r0
 800959a:	2230      	movs	r2, #48	; 0x30
 800959c:	2100      	movs	r1, #0
 800959e:	f002 ffae 	bl	800c4fe <memset>
  PHY_Ports[PortNum].TxDatabitLen = 0;
 80095a2:	2300      	movs	r3, #0
 80095a4:	1964      	adds	r4, r4, r5
 80095a6:	63e3      	str	r3, [r4, #60]	; 0x3c
}
 80095a8:	bd70      	pop	{r4, r5, r6, pc}
 80095aa:	46c0      	nop			; (mov r8, r8)
 80095ac:	20000380 	.word	0x20000380

080095b0 <USBPD_PHY_Reset>:
{
 80095b0:	b510      	push	{r4, lr}
  PHY_TxBuffer_Reset(PortNum);
 80095b2:	f7ff ffeb 	bl	800958c <PHY_TxBuffer_Reset>
}
 80095b6:	bd10      	pop	{r4, pc}

080095b8 <USBPD_PHY_Init>:
{
 80095b8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80095ba:	0016      	movs	r6, r2
  hwif_cbs.USBPD_HW_IF_RX_Reset       = PHY_Rx_Reset;
 80095bc:	4a11      	ldr	r2, [pc, #68]	; (8009604 <USBPD_PHY_Init+0x4c>)
{
 80095be:	b08b      	sub	sp, #44	; 0x2c
  hwif_cbs.USBPD_HW_IF_RX_Reset       = PHY_Rx_Reset;
 80095c0:	9207      	str	r2, [sp, #28]
  hwif_cbs.USBPD_HW_IF_RX_Accumulate  = PHY_Rx_Accumulate;
 80095c2:	4a11      	ldr	r2, [pc, #68]	; (8009608 <USBPD_PHY_Init+0x50>)
{
 80095c4:	0004      	movs	r4, r0
  hwif_cbs.USBPD_HW_IF_RX_Accumulate  = PHY_Rx_Accumulate;
 80095c6:	9208      	str	r2, [sp, #32]
  hwif_cbs.USBPD_HW_IF_RX_Completed   = PHY_Rx_Completed;
 80095c8:	4a10      	ldr	r2, [pc, #64]	; (800960c <USBPD_PHY_Init+0x54>)
  USBPD_HW_IF_PortHwInit(PortNum, hwif_cbs, PowerRole);
 80095ca:	9303      	str	r3, [sp, #12]
  hwif_cbs.USBPD_HW_IF_RX_Completed   = PHY_Rx_Completed;
 80095cc:	9209      	str	r2, [sp, #36]	; 0x24
  USBPD_HW_IF_PortHwInit(PortNum, hwif_cbs, PowerRole);
 80095ce:	466a      	mov	r2, sp
 80095d0:	ab07      	add	r3, sp, #28
{
 80095d2:	000d      	movs	r5, r1
  USBPD_HW_IF_PortHwInit(PortNum, hwif_cbs, PowerRole);
 80095d4:	cb83      	ldmia	r3!, {r0, r1, r7}
 80095d6:	c283      	stmia	r2!, {r0, r1, r7}
 80095d8:	4a0d      	ldr	r2, [pc, #52]	; (8009610 <USBPD_PHY_Init+0x58>)
 80095da:	9904      	ldr	r1, [sp, #16]
 80095dc:	4b0d      	ldr	r3, [pc, #52]	; (8009614 <USBPD_PHY_Init+0x5c>)
 80095de:	0020      	movs	r0, r4
 80095e0:	f001 fb56 	bl	800ac90 <USBPD_HW_IF_PortHwInit>
  PHY_Ports[PortNum].pRxBuffer    = pRxBuffer;
 80095e4:	237c      	movs	r3, #124	; 0x7c
 80095e6:	4363      	muls	r3, r4
 80095e8:	4a0b      	ldr	r2, [pc, #44]	; (8009618 <USBPD_PHY_Init+0x60>)
  PHY_Ports[PortNum].SupportedSOP = SupportedSOP;
 80095ea:	9910      	ldr	r1, [sp, #64]	; 0x40
  PHY_Ports[PortNum].pRxBuffer    = pRxBuffer;
 80095ec:	18d7      	adds	r7, r2, r3
  PHY_TxBuffer_Reset(PortNum);
 80095ee:	0020      	movs	r0, r4
  PHY_Ports[PortNum].pRxBuffer    = pRxBuffer;
 80095f0:	607e      	str	r6, [r7, #4]
  PHY_Ports[PortNum].SupportedSOP = SupportedSOP;
 80095f2:	67b9      	str	r1, [r7, #120]	; 0x78
  PHY_Ports[PortNum].cbs = pCallback;
 80095f4:	509d      	str	r5, [r3, r2]
  PHY_TxBuffer_Reset(PortNum);
 80095f6:	f7ff ffc9 	bl	800958c <PHY_TxBuffer_Reset>
  PHY_Ports[PortNum].State = PHY_StateNone;
 80095fa:	2000      	movs	r0, #0
 80095fc:	7238      	strb	r0, [r7, #8]
}
 80095fe:	b00b      	add	sp, #44	; 0x2c
 8009600:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009602:	46c0      	nop			; (mov r8, r8)
 8009604:	08009421 	.word	0x08009421
 8009608:	0800984d 	.word	0x0800984d
 800960c:	08009455 	.word	0x08009455
 8009610:	08009401 	.word	0x08009401
 8009614:	080093e9 	.word	0x080093e9
 8009618:	20000380 	.word	0x20000380

0800961c <PHY_TxBuffer_Append>:
{
 800961c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 800961e:	247c      	movs	r4, #124	; 0x7c
  uint32_t map = __BITMASK(nbit);
 8009620:	2601      	movs	r6, #1
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009622:	4344      	muls	r4, r0
  uint32_t bit = *pOffset % __SIZEBIT;
 8009624:	271f      	movs	r7, #31
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009626:	0023      	movs	r3, r4
  uint32_t map = __BITMASK(nbit);
 8009628:	4096      	lsls	r6, r2
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 800962a:	4d16      	ldr	r5, [pc, #88]	; (8009684 <PHY_TxBuffer_Append+0x68>)
 800962c:	330c      	adds	r3, #12
  uint32_t pos = *pOffset / __SIZEBIT;
 800962e:	192c      	adds	r4, r5, r4
 8009630:	6be4      	ldr	r4, [r4, #60]	; 0x3c
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009632:	18eb      	adds	r3, r5, r3
  uint32_t bit = *pOffset % __SIZEBIT;
 8009634:	4027      	ands	r7, r4
  uint32_t pos = *pOffset / __SIZEBIT;
 8009636:	0964      	lsrs	r4, r4, #5
  uint32_t map = __BITMASK(nbit);
 8009638:	3e01      	subs	r6, #1
  pBuffer[pos] |= (value << bit);
 800963a:	00a4      	lsls	r4, r4, #2
  uint32_t value = val & map;
 800963c:	4031      	ands	r1, r6
  pBuffer[pos] |= (value << bit);
 800963e:	191e      	adds	r6, r3, r4
 8009640:	46b4      	mov	ip, r6
 8009642:	000e      	movs	r6, r1
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009644:	9301      	str	r3, [sp, #4]
  pBuffer[pos] |= (value << bit);
 8009646:	4663      	mov	r3, ip
 8009648:	40be      	lsls	r6, r7
 800964a:	681b      	ldr	r3, [r3, #0]
 800964c:	431e      	orrs	r6, r3
 800964e:	4663      	mov	r3, ip
 8009650:	601e      	str	r6, [r3, #0]
  if (bit > (__SIZEBIT - MIN(nbit, __SIZEBIT)))
 8009652:	1c16      	adds	r6, r2, #0
 8009654:	2a20      	cmp	r2, #32
 8009656:	d900      	bls.n	800965a <PHY_TxBuffer_Append+0x3e>
 8009658:	2620      	movs	r6, #32
 800965a:	b2f3      	uxtb	r3, r6
 800965c:	2620      	movs	r6, #32
 800965e:	1af3      	subs	r3, r6, r3
 8009660:	42bb      	cmp	r3, r7
 8009662:	d207      	bcs.n	8009674 <PHY_TxBuffer_Append+0x58>
    pBuffer[pos + 1] |= (value >> (__SIZEBIT - bit));
 8009664:	1bf7      	subs	r7, r6, r7
 8009666:	40f9      	lsrs	r1, r7
 8009668:	9b01      	ldr	r3, [sp, #4]
 800966a:	3404      	adds	r4, #4
 800966c:	191b      	adds	r3, r3, r4
 800966e:	681c      	ldr	r4, [r3, #0]
 8009670:	4321      	orrs	r1, r4
 8009672:	6019      	str	r1, [r3, #0]
  *pOffset += nbit;
 8009674:	237c      	movs	r3, #124	; 0x7c
 8009676:	4358      	muls	r0, r3
 8009678:	182d      	adds	r5, r5, r0
 800967a:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 800967c:	189a      	adds	r2, r3, r2
 800967e:	63ea      	str	r2, [r5, #60]	; 0x3c
}
 8009680:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8009682:	46c0      	nop			; (mov r8, r8)
 8009684:	20000380 	.word	0x20000380

08009688 <PHY_PreparePacket>:
{
 8009688:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint8_t resetRequired = Type == USBPD_SOPTYPE_HARD_RESET || Type == USBPD_SOPTYPE_CABLE_RESET;
 800968a:	1f4c      	subs	r4, r1, #5
 800968c:	b2e4      	uxtb	r4, r4
{
 800968e:	000f      	movs	r7, r1
 8009690:	0015      	movs	r5, r2
 8009692:	001e      	movs	r6, r3
  if (!resetRequired  && ((Size < 2) || (Size > 30) || (( (Size - 2) % __SIZE) != 0))) 
 8009694:	2c01      	cmp	r4, #1
 8009696:	d95f      	bls.n	8009758 <PHY_PreparePacket+0xd0>
 8009698:	3b02      	subs	r3, #2
 800969a:	b2da      	uxtb	r2, r3
 800969c:	2a1c      	cmp	r2, #28
 800969e:	d801      	bhi.n	80096a4 <PHY_PreparePacket+0x1c>
 80096a0:	079b      	lsls	r3, r3, #30
 80096a2:	d00e      	beq.n	80096c2 <PHY_PreparePacket+0x3a>
  return FRAME_5B_BitSizeIsValid(*pOffset) ? USBPD_OK : USBPD_ERROR;
 80096a4:	2002      	movs	r0, #2
 80096a6:	e056      	b.n	8009756 <PHY_PreparePacket+0xce>
      val16 = pBuffer[i] | (pBuffer[i + 1] << 8);
 80096a8:	7863      	ldrb	r3, [r4, #1]
 80096aa:	7820      	ldrb	r0, [r4, #0]
 80096ac:	021b      	lsls	r3, r3, #8
      value = PHY_Encode5b_Short(val16);
 80096ae:	4318      	orrs	r0, r3
 80096b0:	f7ff ff2c 	bl	800950c <PHY_Encode5b_Short>
      PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 80096b4:	2214      	movs	r2, #20
      value = PHY_Encode5b_Short(val16);
 80096b6:	0001      	movs	r1, r0
      PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 80096b8:	2000      	movs	r0, #0
 80096ba:	f7ff ffaf 	bl	800961c <PHY_TxBuffer_Append>
 80096be:	3402      	adds	r4, #2
 80096c0:	e016      	b.n	80096f0 <PHY_PreparePacket+0x68>
  if (!USBPD_PORT_IsValid(PortNum) || (!resetRequired && pBuffer == NULL))
 80096c2:	2800      	cmp	r0, #0
 80096c4:	d1ee      	bne.n	80096a4 <PHY_PreparePacket+0x1c>
 80096c6:	2d00      	cmp	r5, #0
 80096c8:	d0ec      	beq.n	80096a4 <PHY_PreparePacket+0x1c>
  PHY_TxBuffer_Reset(PortNum);
 80096ca:	2000      	movs	r0, #0
 80096cc:	f7ff ff5e 	bl	800958c <PHY_TxBuffer_Reset>
  PHY_TxBuffer_Append(PortNum, OrderSets[(uint8_t)Type], OS_BITSIZE);
 80096d0:	4b23      	ldr	r3, [pc, #140]	; (8009760 <PHY_PreparePacket+0xd8>)
 80096d2:	00bf      	lsls	r7, r7, #2
 80096d4:	19df      	adds	r7, r3, r7
 80096d6:	2214      	movs	r2, #20
 80096d8:	6939      	ldr	r1, [r7, #16]
 80096da:	2000      	movs	r0, #0
 80096dc:	f7ff ff9e 	bl	800961c <PHY_TxBuffer_Append>
  if (!resetRequired)
 80096e0:	2c01      	cmp	r4, #1
 80096e2:	d91d      	bls.n	8009720 <PHY_PreparePacket+0x98>
    crc_value = USBPD_HW_IF_CRC_Calculate(pBuffer, Size);
 80096e4:	0031      	movs	r1, r6
 80096e6:	0028      	movs	r0, r5
 80096e8:	f000 f91e 	bl	8009928 <USBPD_HW_IF_CRC_Calculate>
    for (i = 0; i < Size; i += 2)
 80096ec:	002c      	movs	r4, r5
    crc_value = USBPD_HW_IF_CRC_Calculate(pBuffer, Size);
 80096ee:	0007      	movs	r7, r0
    for (i = 0; i < Size; i += 2)
 80096f0:	1b63      	subs	r3, r4, r5
 80096f2:	429e      	cmp	r6, r3
 80096f4:	d8d8      	bhi.n	80096a8 <PHY_PreparePacket+0x20>
    value = PHY_Encode5b_Short(crc_value & 0x0000FFFF);
 80096f6:	b2b8      	uxth	r0, r7
 80096f8:	f7ff ff08 	bl	800950c <PHY_Encode5b_Short>
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 80096fc:	2214      	movs	r2, #20
    value = PHY_Encode5b_Short(crc_value & 0x0000FFFF);
 80096fe:	0001      	movs	r1, r0
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 8009700:	2000      	movs	r0, #0
 8009702:	f7ff ff8b 	bl	800961c <PHY_TxBuffer_Append>
    value = PHY_Encode5b_Short((crc_value >> 16) & 0x0000FFFF);
 8009706:	0c38      	lsrs	r0, r7, #16
 8009708:	f7ff ff00 	bl	800950c <PHY_Encode5b_Short>
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 800970c:	2214      	movs	r2, #20
    value = PHY_Encode5b_Short((crc_value >> 16) & 0x0000FFFF);
 800970e:	0001      	movs	r1, r0
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 8009710:	2000      	movs	r0, #0
 8009712:	f7ff ff83 	bl	800961c <PHY_TxBuffer_Append>
    PHY_TxBuffer_Append(PortNum, KC_S_EOP, CODE_5B_ITEM1_BITSIZE);
 8009716:	2205      	movs	r2, #5
 8009718:	210d      	movs	r1, #13
 800971a:	2000      	movs	r0, #0
 800971c:	f7ff ff7e 	bl	800961c <PHY_TxBuffer_Append>
  return FRAME_5B_BitSizeIsValid(*pOffset) ? USBPD_OK : USBPD_ERROR;
 8009720:	4b10      	ldr	r3, [pc, #64]	; (8009764 <PHY_PreparePacket+0xdc>)
 8009722:	2000      	movs	r0, #0
 8009724:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009726:	2b14      	cmp	r3, #20
 8009728:	d015      	beq.n	8009756 <PHY_PreparePacket+0xce>
 800972a:	2b55      	cmp	r3, #85	; 0x55
 800972c:	d013      	beq.n	8009756 <PHY_PreparePacket+0xce>
 800972e:	2b7d      	cmp	r3, #125	; 0x7d
 8009730:	d011      	beq.n	8009756 <PHY_PreparePacket+0xce>
 8009732:	2ba5      	cmp	r3, #165	; 0xa5
 8009734:	d00f      	beq.n	8009756 <PHY_PreparePacket+0xce>
 8009736:	2bcd      	cmp	r3, #205	; 0xcd
 8009738:	d00d      	beq.n	8009756 <PHY_PreparePacket+0xce>
 800973a:	2bf5      	cmp	r3, #245	; 0xf5
 800973c:	d00b      	beq.n	8009756 <PHY_PreparePacket+0xce>
 800973e:	221e      	movs	r2, #30
 8009740:	32ff      	adds	r2, #255	; 0xff
 8009742:	4293      	cmp	r3, r2
 8009744:	d007      	beq.n	8009756 <PHY_PreparePacket+0xce>
 8009746:	2246      	movs	r2, #70	; 0x46
 8009748:	32ff      	adds	r2, #255	; 0xff
 800974a:	4293      	cmp	r3, r2
 800974c:	d003      	beq.n	8009756 <PHY_PreparePacket+0xce>
 800974e:	226e      	movs	r2, #110	; 0x6e
 8009750:	32ff      	adds	r2, #255	; 0xff
 8009752:	4293      	cmp	r3, r2
 8009754:	d1a6      	bne.n	80096a4 <PHY_PreparePacket+0x1c>
}
 8009756:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (!USBPD_PORT_IsValid(PortNum) || (!resetRequired && pBuffer == NULL))
 8009758:	2800      	cmp	r0, #0
 800975a:	d1a3      	bne.n	80096a4 <PHY_PreparePacket+0x1c>
 800975c:	e7b5      	b.n	80096ca <PHY_PreparePacket+0x42>
 800975e:	46c0      	nop			; (mov r8, r8)
 8009760:	0800c740 	.word	0x0800c740
 8009764:	20000380 	.word	0x20000380

08009768 <USBPD_PHY_SendMessage>:
{
 8009768:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (PHY_Ports[PortNum].State != PHY_StateNone)
 800976a:	247c      	movs	r4, #124	; 0x7c
 800976c:	4344      	muls	r4, r0
{
 800976e:	0006      	movs	r6, r0
  if (PHY_Ports[PortNum].State != PHY_StateNone)
 8009770:	480c      	ldr	r0, [pc, #48]	; (80097a4 <USBPD_PHY_SendMessage+0x3c>)
 8009772:	1905      	adds	r5, r0, r4
 8009774:	7a2f      	ldrb	r7, [r5, #8]
    return USBPD_BUSY;
 8009776:	2003      	movs	r0, #3
  if (PHY_Ports[PortNum].State != PHY_StateNone)
 8009778:	2f00      	cmp	r7, #0
 800977a:	d112      	bne.n	80097a2 <USBPD_PHY_SendMessage+0x3a>
  res = PHY_PreparePacket(PortNum, Type, pBuffer, Size);
 800977c:	b2db      	uxtb	r3, r3
 800977e:	0030      	movs	r0, r6
 8009780:	f7ff ff82 	bl	8009688 <PHY_PreparePacket>
 8009784:	0007      	movs	r7, r0
    return USBPD_ERROR;
 8009786:	2002      	movs	r0, #2
  if (res == USBPD_OK)
 8009788:	2f00      	cmp	r7, #0
 800978a:	d10a      	bne.n	80097a2 <USBPD_PHY_SendMessage+0x3a>
    PHY_Ports[PortNum].State = PHY_StateBusyTxStart;
 800978c:	2303      	movs	r3, #3
    res = USBPD_HW_IF_SendBuffer(PortNum, (uint8_t *)PHY_Ports[PortNum].TxBuffer,  PHY_Ports[PortNum].TxDatabitLen);
 800978e:	0021      	movs	r1, r4
    PHY_Ports[PortNum].State = PHY_StateBusyTxStart;
 8009790:	722b      	strb	r3, [r5, #8]
    res = USBPD_HW_IF_SendBuffer(PortNum, (uint8_t *)PHY_Ports[PortNum].TxBuffer,  PHY_Ports[PortNum].TxDatabitLen);
 8009792:	4b04      	ldr	r3, [pc, #16]	; (80097a4 <USBPD_PHY_SendMessage+0x3c>)
 8009794:	310c      	adds	r1, #12
 8009796:	1859      	adds	r1, r3, r1
 8009798:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 800979a:	0030      	movs	r0, r6
 800979c:	f000 f8ce 	bl	800993c <USBPD_HW_IF_SendBuffer>
  PHY_Ports[PortNum].State = PHY_StateNone;
 80097a0:	722f      	strb	r7, [r5, #8]
}
 80097a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80097a4:	20000380 	.word	0x20000380

080097a8 <USBPD_PHY_ResetRequest>:
  if (USBPD_PHY_SendMessage(PortNum, Type, NULL, 0) != USBPD_OK)
 80097a8:	2300      	movs	r3, #0
{
 80097aa:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (USBPD_PHY_SendMessage(PortNum, Type, NULL, 0) != USBPD_OK)
 80097ac:	001a      	movs	r2, r3
{
 80097ae:	0004      	movs	r4, r0
 80097b0:	9101      	str	r1, [sp, #4]
  if (USBPD_PHY_SendMessage(PortNum, Type, NULL, 0) != USBPD_OK)
 80097b2:	f7ff ffd9 	bl	8009768 <USBPD_PHY_SendMessage>
 80097b6:	1e06      	subs	r6, r0, #0
 80097b8:	d116      	bne.n	80097e8 <USBPD_PHY_ResetRequest+0x40>
  PHY_Ports[PortNum].State = PHY_StateBusy;
 80097ba:	257c      	movs	r5, #124	; 0x7c
 80097bc:	2202      	movs	r2, #2
 80097be:	4365      	muls	r5, r4
 80097c0:	4f0a      	ldr	r7, [pc, #40]	; (80097ec <USBPD_PHY_ResetRequest+0x44>)
  PHY_TxBuffer_Reset(PortNum);
 80097c2:	0020      	movs	r0, r4
  PHY_Ports[PortNum].State = PHY_StateBusy;
 80097c4:	197b      	adds	r3, r7, r5
 80097c6:	721a      	strb	r2, [r3, #8]
  PHY_TxBuffer_Reset(PortNum);
 80097c8:	f7ff fee0 	bl	800958c <PHY_TxBuffer_Reset>
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_ResetCompleted != NULL)
 80097cc:	59eb      	ldr	r3, [r5, r7]
 80097ce:	689b      	ldr	r3, [r3, #8]
 80097d0:	2b00      	cmp	r3, #0
 80097d2:	d002      	beq.n	80097da <USBPD_PHY_ResetRequest+0x32>
    PHY_Ports[PortNum].cbs->USBPD_PHY_ResetCompleted(PortNum, Type);
 80097d4:	9901      	ldr	r1, [sp, #4]
 80097d6:	0020      	movs	r0, r4
 80097d8:	4798      	blx	r3
  PHY_Ports[PortNum].State = PHY_StateNone;
 80097da:	237c      	movs	r3, #124	; 0x7c
 80097dc:	435c      	muls	r4, r3
 80097de:	2300      	movs	r3, #0
 80097e0:	193c      	adds	r4, r7, r4
 80097e2:	7223      	strb	r3, [r4, #8]
}
 80097e4:	0030      	movs	r0, r6
 80097e6:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    return USBPD_ERROR;
 80097e8:	2602      	movs	r6, #2
 80097ea:	e7fb      	b.n	80097e4 <USBPD_PHY_ResetRequest+0x3c>
 80097ec:	20000380 	.word	0x20000380

080097f0 <PHY_SopDetect>:
    temp = OrderSets[index] ^ OrderSet;
 80097f0:	4b15      	ldr	r3, [pc, #84]	; (8009848 <PHY_SopDetect+0x58>)
{
 80097f2:	b5f0      	push	{r4, r5, r6, r7, lr}
    temp = OrderSets[index] ^ OrderSet;
 80097f4:	3310      	adds	r3, #16
      if (temp & 0x00007C00)
 80097f6:	26f8      	movs	r6, #248	; 0xf8
      if (temp & 0x000003E0)
 80097f8:	27f8      	movs	r7, #248	; 0xf8
  for (index = 0; index < OS_NUM; index++)
 80097fa:	2000      	movs	r0, #0
    temp = OrderSets[index] ^ OrderSet;
 80097fc:	469c      	mov	ip, r3
      if (temp & 0x00007C00)
 80097fe:	01f6      	lsls	r6, r6, #7
      if (temp & 0x000003E0)
 8009800:	00bf      	lsls	r7, r7, #2
    temp = OrderSets[index] ^ OrderSet;
 8009802:	4662      	mov	r2, ip
 8009804:	0083      	lsls	r3, r0, #2
 8009806:	589b      	ldr	r3, [r3, r2]
 8009808:	001a      	movs	r2, r3
 800980a:	404a      	eors	r2, r1
    if (temp)
 800980c:	428b      	cmp	r3, r1
 800980e:	d014      	beq.n	800983a <PHY_SopDetect+0x4a>
      if (temp & 0x000F8000)
 8009810:	23f8      	movs	r3, #248	; 0xf8
 8009812:	0014      	movs	r4, r2
 8009814:	031b      	lsls	r3, r3, #12
 8009816:	401c      	ands	r4, r3
    count = 0;
 8009818:	0023      	movs	r3, r4
 800981a:	1e5d      	subs	r5, r3, #1
 800981c:	41ab      	sbcs	r3, r5
      if (temp & 0x00007C00)
 800981e:	4232      	tst	r2, r6
 8009820:	d002      	beq.n	8009828 <PHY_SopDetect+0x38>
      if (count > 1)
 8009822:	2c00      	cmp	r4, #0
 8009824:	d10b      	bne.n	800983e <PHY_SopDetect+0x4e>
 8009826:	2301      	movs	r3, #1
      if (temp & 0x000003E0)
 8009828:	423a      	tst	r2, r7
 800982a:	d002      	beq.n	8009832 <PHY_SopDetect+0x42>
      if (count > 1)
 800982c:	2b01      	cmp	r3, #1
 800982e:	d006      	beq.n	800983e <PHY_SopDetect+0x4e>
 8009830:	2301      	movs	r3, #1
      if (temp & 0x0000001F)
 8009832:	06d2      	lsls	r2, r2, #27
 8009834:	d001      	beq.n	800983a <PHY_SopDetect+0x4a>
      if (count > 1)
 8009836:	2b01      	cmp	r3, #1
 8009838:	d001      	beq.n	800983e <PHY_SopDetect+0x4e>
    type = (USBPD_SOPType_TypeDef)index;
 800983a:	b2c0      	uxtb	r0, r0
}
 800983c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (index = 0; index < OS_NUM; index++)
 800983e:	3001      	adds	r0, #1
 8009840:	2807      	cmp	r0, #7
 8009842:	d1de      	bne.n	8009802 <PHY_SopDetect+0x12>
  USBPD_SOPType_TypeDef type = USBPD_SOPTYPE_INVALID;
 8009844:	30f8      	adds	r0, #248	; 0xf8
 8009846:	e7f9      	b.n	800983c <PHY_SopDetect+0x4c>
 8009848:	0800c740 	.word	0x0800c740

0800984c <PHY_Rx_Accumulate>:
{
 800984c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800984e:	0006      	movs	r6, r0
  switch (pRxData->Status)
 8009850:	207c      	movs	r0, #124	; 0x7c
 8009852:	4370      	muls	r0, r6
 8009854:	4c32      	ldr	r4, [pc, #200]	; (8009920 <PHY_Rx_Accumulate+0xd4>)
 8009856:	1825      	adds	r5, r4, r0
 8009858:	002f      	movs	r7, r5
 800985a:	3740      	adds	r7, #64	; 0x40
 800985c:	783b      	ldrb	r3, [r7, #0]
 800985e:	2b02      	cmp	r3, #2
 8009860:	d00c      	beq.n	800987c <PHY_Rx_Accumulate+0x30>
 8009862:	2b03      	cmp	r3, #3
 8009864:	d034      	beq.n	80098d0 <PHY_Rx_Accumulate+0x84>
 8009866:	2b00      	cmp	r3, #0
 8009868:	d151      	bne.n	800990e <PHY_Rx_Accumulate+0xc2>
    pRxData->OrderSet = data;
 800986a:	6469      	str	r1, [r5, #68]	; 0x44
    pRxData->Status = USBPD_PHY_RX_STATUS_SOP_DETECTING;
 800986c:	3302      	adds	r3, #2
      pRxData->Status = USBPD_PHY_RX_STATUS_MESSAGE_READY;
 800986e:	703b      	strb	r3, [r7, #0]
  return pRxData->Status;
 8009870:	237c      	movs	r3, #124	; 0x7c
 8009872:	435e      	muls	r6, r3
 8009874:	19a4      	adds	r4, r4, r6
 8009876:	3440      	adds	r4, #64	; 0x40
 8009878:	7820      	ldrb	r0, [r4, #0]
}
 800987a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pRxData->OrderSet |= data<<10;
 800987c:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 800987e:	0289      	lsls	r1, r1, #10
 8009880:	4319      	orrs	r1, r3
 8009882:	6469      	str	r1, [r5, #68]	; 0x44
    pRxData->MsgType = PHY_SopDetect(PortNum, pRxData->OrderSet);
 8009884:	0030      	movs	r0, r6
 8009886:	f7ff ffb3 	bl	80097f0 <PHY_SopDetect>
 800988a:	3548      	adds	r5, #72	; 0x48
 800988c:	7028      	strb	r0, [r5, #0]
    switch(pRxData->MsgType)
 800988e:	2806      	cmp	r0, #6
 8009890:	d81c      	bhi.n	80098cc <PHY_Rx_Accumulate+0x80>
 8009892:	237c      	movs	r3, #124	; 0x7c
      if(PHY_Ports[PortNum].SupportedSOP & 0x1E)
 8009894:	4373      	muls	r3, r6
 8009896:	18e3      	adds	r3, r4, r3
    switch(pRxData->MsgType)
 8009898:	f7fc f882 	bl	80059a0 <__gnu_thumb1_case_uqi>
 800989c:	0f0f0f0f 	.word	0x0f0f0f0f
 80098a0:	040f      	.short	0x040f
 80098a2:	08          	.byte	0x08
 80098a3:	00          	.byte	0x00
      pRxData->Status = USBPD_PHY_RX_STATUS_MESSAGE_READY;
 80098a4:	3340      	adds	r3, #64	; 0x40
 80098a6:	2204      	movs	r2, #4
        pRxData->Data[pRxData->DataCount++] = data4b_temp;
 80098a8:	701a      	strb	r2, [r3, #0]
 80098aa:	e7e1      	b.n	8009870 <PHY_Rx_Accumulate+0x24>
      if(PHY_Ports[PortNum].SupportedSOP & 0x1E)
 80098ac:	221e      	movs	r2, #30
 80098ae:	6f99      	ldr	r1, [r3, #120]	; 0x78
 80098b0:	3340      	adds	r3, #64	; 0x40
 80098b2:	4211      	tst	r1, r2
 80098b4:	d1f7      	bne.n	80098a6 <PHY_Rx_Accumulate+0x5a>
        pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_UNSUPPORTED_SOP;
 80098b6:	2206      	movs	r2, #6
 80098b8:	e7f6      	b.n	80098a8 <PHY_Rx_Accumulate+0x5c>
      if(PHY_Ports[PortNum].SupportedSOP & (0x1 << pRxData->MsgType))
 80098ba:	2101      	movs	r1, #1
 80098bc:	4081      	lsls	r1, r0
 80098be:	000a      	movs	r2, r1
 80098c0:	6f99      	ldr	r1, [r3, #120]	; 0x78
 80098c2:	3340      	adds	r3, #64	; 0x40
 80098c4:	4211      	tst	r1, r2
 80098c6:	d0f6      	beq.n	80098b6 <PHY_Rx_Accumulate+0x6a>
        pRxData->Status = USBPD_PHY_RX_STATUS_DATA;
 80098c8:	2203      	movs	r2, #3
 80098ca:	e7ed      	b.n	80098a8 <PHY_Rx_Accumulate+0x5c>
      pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_INVALID_SOP;
 80098cc:	2307      	movs	r3, #7
 80098ce:	e7ce      	b.n	800986e <PHY_Rx_Accumulate+0x22>
    if ((data & CODE_5B_ITEM1_MASK) == KC_S_EOP)
 80098d0:	201f      	movs	r0, #31
 80098d2:	000a      	movs	r2, r1
 80098d4:	4002      	ands	r2, r0
 80098d6:	2a0d      	cmp	r2, #13
 80098d8:	d101      	bne.n	80098de <PHY_Rx_Accumulate+0x92>
      pRxData->Status = USBPD_PHY_RX_STATUS_MESSAGE_READY;
 80098da:	2304      	movs	r3, #4
 80098dc:	e7c7      	b.n	800986e <PHY_Rx_Accumulate+0x22>
  v0 = decoding5b4b[(value >>  0) & 0x1F]; /* decoding first nibble */
 80098de:	4b11      	ldr	r3, [pc, #68]	; (8009924 <PHY_Rx_Accumulate+0xd8>)
  v1 = decoding5b4b[(value >>  5) & 0x1F]; /* decoding second nibble */
 80098e0:	0949      	lsrs	r1, r1, #5
  v0 = decoding5b4b[(value >>  0) & 0x1F]; /* decoding first nibble */
 80098e2:	332c      	adds	r3, #44	; 0x2c
 80098e4:	5c9a      	ldrb	r2, [r3, r2]
  v1 = decoding5b4b[(value >>  5) & 0x1F]; /* decoding second nibble */
 80098e6:	4001      	ands	r1, r0
 80098e8:	5c59      	ldrb	r1, [r3, r1]
  if (v0 == CODE_5B_INVALID || v1 == CODE_5B_INVALID) 
 80098ea:	2aff      	cmp	r2, #255	; 0xff
 80098ec:	d009      	beq.n	8009902 <PHY_Rx_Accumulate+0xb6>
 80098ee:	29ff      	cmp	r1, #255	; 0xff
 80098f0:	d007      	beq.n	8009902 <PHY_Rx_Accumulate+0xb6>
        pRxData->Data[pRxData->DataCount++] = data4b_temp;
 80098f2:	6f6b      	ldr	r3, [r5, #116]	; 0x74
  return v0 | (v1<<4);
 80098f4:	0109      	lsls	r1, r1, #4
        pRxData->Data[pRxData->DataCount++] = data4b_temp;
 80098f6:	1c58      	adds	r0, r3, #1
 80098f8:	18eb      	adds	r3, r5, r3
 80098fa:	6768      	str	r0, [r5, #116]	; 0x74
 80098fc:	3349      	adds	r3, #73	; 0x49
  return v0 | (v1<<4);
 80098fe:	430a      	orrs	r2, r1
 8009900:	e7d2      	b.n	80098a8 <PHY_Rx_Accumulate+0x5c>
        pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_INVALID_SYMBOL;
 8009902:	237c      	movs	r3, #124	; 0x7c
 8009904:	4373      	muls	r3, r6
 8009906:	18e3      	adds	r3, r4, r3
 8009908:	3340      	adds	r3, #64	; 0x40
 800990a:	2208      	movs	r2, #8
 800990c:	e7cc      	b.n	80098a8 <PHY_Rx_Accumulate+0x5c>
    pRxData->DataCount = 0;
 800990e:	2100      	movs	r1, #0
    memset(pRxData->Data, 0, __RX_DATA_LEN);
 8009910:	3049      	adds	r0, #73	; 0x49
    pRxData->DataCount = 0;
 8009912:	6769      	str	r1, [r5, #116]	; 0x74
    memset(pRxData->Data, 0, __RX_DATA_LEN);
 8009914:	1820      	adds	r0, r4, r0
 8009916:	2228      	movs	r2, #40	; 0x28
 8009918:	f002 fdf1 	bl	800c4fe <memset>
    break;
 800991c:	e7a8      	b.n	8009870 <PHY_Rx_Accumulate+0x24>
 800991e:	46c0      	nop			; (mov r8, r8)
 8009920:	20000380 	.word	0x20000380
 8009924:	0800c740 	.word	0x0800c740

08009928 <USBPD_HW_IF_CRC_Calculate>:
  * @param  *pBuffer    Pointer to the input data buffer
  * @param  len         Input data buffer length
  * @retval uint32_t    CRC value
  */
uint32_t USBPD_HW_IF_CRC_Calculate(uint8_t *pBuffer, uint8_t len)
{
 8009928:	b510      	push	{r4, lr}
 800992a:	000a      	movs	r2, r1
  uint32_t crc;

  crc = HAL_CRC_Calculate(&hcrc, (uint32_t *)pBuffer, len);
 800992c:	0001      	movs	r1, r0
 800992e:	4802      	ldr	r0, [pc, #8]	; (8009938 <USBPD_HW_IF_CRC_Calculate+0x10>)
 8009930:	f7fd fe49 	bl	80075c6 <HAL_CRC_Calculate>
  crc ^= 0xFFFFFFFF;
 8009934:	43c0      	mvns	r0, r0
  return crc;
}
 8009936:	bd10      	pop	{r4, pc}
 8009938:	20001c3c 	.word	0x20001c3c

0800993c <USBPD_HW_IF_SendBuffer>:
* @param  *pBuffer      Pointer to the TX data buffer
* @param  Bitsize:      Amount of bits to be transmitted
* @retval USBPD status
*/
USBPD_StatusTypeDef USBPD_HW_IF_SendBuffer(uint8_t PortNum, uint8_t *pBuffer, uint32_t Bitsize)
{
 800993c:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check if the port is still receiving */
  if (Ports[PortNum].State == HAL_USBPD_PORT_STATE_BUSY_RX)
 800993e:	24f0      	movs	r4, #240	; 0xf0
 8009940:	0064      	lsls	r4, r4, #1
 8009942:	4344      	muls	r4, r0
 8009944:	4b17      	ldr	r3, [pc, #92]	; (80099a4 <USBPD_HW_IF_SendBuffer+0x68>)
{
 8009946:	b085      	sub	sp, #20
  if (Ports[PortNum].State == HAL_USBPD_PORT_STATE_BUSY_RX)
 8009948:	191c      	adds	r4, r3, r4
 800994a:	7e63      	ldrb	r3, [r4, #25]
{
 800994c:	0006      	movs	r6, r0
 800994e:	9103      	str	r1, [sp, #12]
 8009950:	9202      	str	r2, [sp, #8]
    return USBPD_BUSY;
 8009952:	2003      	movs	r0, #3
  if (Ports[PortNum].State == HAL_USBPD_PORT_STATE_BUSY_RX)
 8009954:	2b04      	cmp	r3, #4
 8009956:	d022      	beq.n	800999e <USBPD_HW_IF_SendBuffer+0x62>

  uint8_t *pTxBuffer = (uint8_t *)Ports[PortNum].pTxBuffPtr;
  uint16_t size = DIV_ROUND_UP(Bitsize, 8)+TX_PREAMBLE_SIZE;
 8009958:	0013      	movs	r3, r2
  uint8_t *pTxBuffer = (uint8_t *)Ports[PortNum].pTxBuffPtr;
 800995a:	6865      	ldr	r5, [r4, #4]
  uint16_t size = DIV_ROUND_UP(Bitsize, 8)+TX_PREAMBLE_SIZE;
 800995c:	3307      	adds	r3, #7
 800995e:	40c3      	lsrs	r3, r0
 8009960:	002f      	movs	r7, r5
 8009962:	3308      	adds	r3, #8
 8009964:	3708      	adds	r7, #8
 8009966:	b29b      	uxth	r3, r3

  memset((uint8_t *)pTxBuffer, 0x00, TX_BUFFER_SIZE);
 8009968:	2230      	movs	r2, #48	; 0x30
 800996a:	2100      	movs	r1, #0
 800996c:	0038      	movs	r0, r7
  uint16_t size = DIV_ROUND_UP(Bitsize, 8)+TX_PREAMBLE_SIZE;
 800996e:	9301      	str	r3, [sp, #4]
  memset((uint8_t *)pTxBuffer, 0x00, TX_BUFFER_SIZE);
 8009970:	f002 fdc5 	bl	800c4fe <memset>
  memset((uint8_t *)pTxBuffer, TX_PREAMBLE, TX_PREAMBLE_SIZE);                          /* preamble is added */
 8009974:	2208      	movs	r2, #8
 8009976:	21aa      	movs	r1, #170	; 0xaa
 8009978:	0028      	movs	r0, r5
 800997a:	f002 fdc0 	bl	800c4fe <memset>
  memcpy((uint8_t *)(pTxBuffer+TX_PREAMBLE_SIZE), pBuffer, (size-TX_PREAMBLE_SIZE));    /* data are added */
 800997e:	9a01      	ldr	r2, [sp, #4]
 8009980:	9903      	ldr	r1, [sp, #12]
 8009982:	3a08      	subs	r2, #8
 8009984:	0038      	movs	r0, r7
 8009986:	f002 fdb1 	bl	800c4ec <memcpy>

  /* Spare clock cycles at the end of transmission are calculated */
  Ports[PortNum].TxSpareBits = (Bitsize % 8);
 800998a:	2307      	movs	r3, #7
 800998c:	9a02      	ldr	r2, [sp, #8]
 800998e:	342a      	adds	r4, #42	; 0x2a
 8009990:	4013      	ands	r3, r2
 8009992:	7023      	strb	r3, [r4, #0]

  /* Packet is ready to be sent to SPI */
  USBPD_StatusTypeDef ret = USBPD_OK;
  ret = STUSB16xx_HW_IF_Send_Packet(PortNum, pTxBuffer, size);
 8009994:	9a01      	ldr	r2, [sp, #4]
 8009996:	0029      	movs	r1, r5
 8009998:	0030      	movs	r0, r6
 800999a:	f001 fbb5 	bl	800b108 <STUSB16xx_HW_IF_Send_Packet>
  return ret;
}
 800999e:	b005      	add	sp, #20
 80099a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80099a2:	46c0      	nop			; (mov r8, r8)
 80099a4:	2000007c 	.word	0x2000007c

080099a8 <USBPD_HW_IF_Send_BIST_Pattern>:
* @brief  It sends BIST pattern  
* @param  PortNum       The port index
* @retval USBPD status
*/
USBPD_StatusTypeDef USBPD_HW_IF_Send_BIST_Pattern(uint8_t PortNum)
{
 80099a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USBPD_StatusTypeDef ret = USBPD_ERROR;
  
  /* BIST Carrier mode flag set */
  Ports[PortNum].State=HAL_USBPD_PORT_STATE_BIST;
 80099aa:	24f0      	movs	r4, #240	; 0xf0
 80099ac:	0064      	lsls	r4, r4, #1
 80099ae:	4344      	muls	r4, r0
 80099b0:	4b15      	ldr	r3, [pc, #84]	; (8009a08 <USBPD_HW_IF_Send_BIST_Pattern+0x60>)
{
 80099b2:	0005      	movs	r5, r0
  Ports[PortNum].State=HAL_USBPD_PORT_STATE_BIST;
 80099b4:	191f      	adds	r7, r3, r4
 80099b6:	2308      	movs	r3, #8
  STUSB16xx_HW_IF_Set_DMA_Circular_Mode(PortNum);
  
  /* Set the SPI in TX mode */
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
  
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 80099b8:	0026      	movs	r6, r4
  Ports[PortNum].State=HAL_USBPD_PORT_STATE_BIST;
 80099ba:	767b      	strb	r3, [r7, #25]
  memset(Ports[PortNum].pTxBuffPtr, 0xAA, TX_BUFFER_LEN*2);
 80099bc:	2238      	movs	r2, #56	; 0x38
 80099be:	21aa      	movs	r1, #170	; 0xaa
 80099c0:	6878      	ldr	r0, [r7, #4]
 80099c2:	f002 fd9c 	bl	800c4fe <memset>
  STUSB16xx_HW_IF_Set_DMA_Circular_Mode(PortNum);
 80099c6:	0028      	movs	r0, r5
 80099c8:	f001 f912 	bl	800abf0 <STUSB16xx_HW_IF_Set_DMA_Circular_Mode>
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 80099cc:	2100      	movs	r1, #0
 80099ce:	0028      	movs	r0, r5
 80099d0:	f001 f932 	bl	800ac38 <STUSB16xx_HW_IF_Switch_Mode>
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 80099d4:	4b0c      	ldr	r3, [pc, #48]	; (8009a08 <USBPD_HW_IF_Send_BIST_Pattern+0x60>)
 80099d6:	3640      	adds	r6, #64	; 0x40
 80099d8:	18f6      	adds	r6, r6, r3
 80099da:	0030      	movs	r0, r6
 80099dc:	f7fe fe82 	bl	80086e4 <HAL_SPI_DMAStop>
  HAL_DMA_Abort(&Ports[PortNum].hdmarx);
 80099e0:	0020      	movs	r0, r4
 80099e2:	4b09      	ldr	r3, [pc, #36]	; (8009a08 <USBPD_HW_IF_Send_BIST_Pattern+0x60>)
 80099e4:	30e8      	adds	r0, #232	; 0xe8
 80099e6:	18c0      	adds	r0, r0, r3
 80099e8:	f7fd fef4 	bl	80077d4 <HAL_DMA_Abort>
  __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 80099ec:	4b07      	ldr	r3, [pc, #28]	; (8009a0c <USBPD_HW_IF_Send_BIST_Pattern+0x64>)
 80099ee:	4a08      	ldr	r2, [pc, #32]	; (8009a10 <USBPD_HW_IF_Send_BIST_Pattern+0x68>)
  
  /* Send TX Buffer by SPI DMA */
  HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, (uint8_t*)(Ports[PortNum].pTxBuffPtr), TX_BUFFER_LEN*2);
 80099f0:	6879      	ldr	r1, [r7, #4]
  __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 80099f2:	605a      	str	r2, [r3, #4]
  HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, (uint8_t*)(Ports[PortNum].pTxBuffPtr), TX_BUFFER_LEN*2);
 80099f4:	0030      	movs	r0, r6
 80099f6:	2238      	movs	r2, #56	; 0x38
 80099f8:	f7fe fc62 	bl	80082c0 <HAL_SPI_Transmit_DMA>
  
  /* Start transmission */
  STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_SET);
 80099fc:	0028      	movs	r0, r5
 80099fe:	2101      	movs	r1, #1
 8009a00:	f001 f928 	bl	800ac54 <STUSB16xx_HW_IF_TX_EN_Status>
  
  ret = USBPD_OK;
  return ret;
}
 8009a04:	2000      	movs	r0, #0
 8009a06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009a08:	2000007c 	.word	0x2000007c
 8009a0c:	40020000 	.word	0x40020000
 8009a10:	0fffffff 	.word	0x0fffffff

08009a14 <USBPD_HW_IF_GPIO_Off>:
 * @brief   It resets the state of GPIO pin
 * @param   gpio The GPIO structure
 * @retval  None
 */
void USBPD_HW_IF_GPIO_Off(USBPD_BSP_GPIOPins_TypeDef gpio)
{
 8009a14:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  HAL_GPIO_WritePin(gpio.GPIOx, gpio.GPIO_Pin, PinState);
 8009a16:	b289      	uxth	r1, r1
 8009a18:	2200      	movs	r2, #0
 8009a1a:	f7fd ffb3 	bl	8007984 <HAL_GPIO_WritePin>
  /* Resets the pin */
  USBPD_HW_IF_GPIO_Set(gpio, GPIO_PIN_RESET);
}
 8009a1e:	b005      	add	sp, #20
 8009a20:	bd00      	pop	{pc}
	...

08009a24 <PHY_HW_IF_ADCAnalogGPIO_Init>:
{
  GPIO_InitTypeDef      GPIO_InitStruct;
  uint8_t ch = 0;

  /* Configure all GPIO port pins in Analog mode */
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009a24:	2303      	movs	r3, #3
{
 8009a26:	b510      	push	{r4, lr}
 8009a28:	b086      	sub	sp, #24
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009a2a:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009a2c:	2300      	movs	r3, #0

  for(ch=0;ch<USBPD_ADCn;ch++)
  {
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009a2e:	4c0b      	ldr	r4, [pc, #44]	; (8009a5c <PHY_HW_IF_ADCAnalogGPIO_Init+0x38>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009a30:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009a32:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 8009a34:	3310      	adds	r3, #16
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009a36:	0020      	movs	r0, r4
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 8009a38:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009a3a:	f7fd fee1 	bl	8007800 <HAL_GPIO_Init>
 8009a3e:	2090      	movs	r0, #144	; 0x90
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 8009a40:	2380      	movs	r3, #128	; 0x80
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009a42:	a901      	add	r1, sp, #4
 8009a44:	05c0      	lsls	r0, r0, #23
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 8009a46:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009a48:	f7fd feda 	bl	8007800 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 8009a4c:	2301      	movs	r3, #1
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009a4e:	a901      	add	r1, sp, #4
 8009a50:	0020      	movs	r0, r4
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 8009a52:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009a54:	f7fd fed4 	bl	8007800 <HAL_GPIO_Init>
  }
}
 8009a58:	b006      	add	sp, #24
 8009a5a:	bd10      	pop	{r4, pc}
 8009a5c:	48000800 	.word	0x48000800

08009a60 <PHY_HW_IF_ADCDMA_Init>:
/**
  * @brief  Initialization of the ADC DMA
  * @retval None
  */
void PHY_HW_IF_ADCDMA_Init(void)
{
 8009a60:	b510      	push	{r4, lr}
  /* Configuration of DMA parameters */
  DmaHandle.Instance = ADCx_DMA;
 8009a62:	4b0e      	ldr	r3, [pc, #56]	; (8009a9c <PHY_HW_IF_ADCDMA_Init+0x3c>)
 8009a64:	4c0e      	ldr	r4, [pc, #56]	; (8009aa0 <PHY_HW_IF_ADCDMA_Init+0x40>)
 8009a66:	6023      	str	r3, [r4, #0]

  DmaHandle.Init.Direction           = DMA_PERIPH_TO_MEMORY;
 8009a68:	2300      	movs	r3, #0
 8009a6a:	6063      	str	r3, [r4, #4]
  DmaHandle.Init.PeriphInc           = DMA_PINC_DISABLE;
 8009a6c:	60a3      	str	r3, [r4, #8]
  DmaHandle.Init.MemInc              = DMA_MINC_ENABLE;
 8009a6e:	3380      	adds	r3, #128	; 0x80
 8009a70:	60e3      	str	r3, [r4, #12]
  DmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;   /* Transfer from ADC by half-word to match with ADC configuration: ADC resolution 10 or 12 bits */
 8009a72:	3380      	adds	r3, #128	; 0x80
 8009a74:	6123      	str	r3, [r4, #16]
  DmaHandle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;       /* Transfer to memory by half-word to match with buffer variable type: half-word */
 8009a76:	2380      	movs	r3, #128	; 0x80
 8009a78:	011b      	lsls	r3, r3, #4
 8009a7a:	6163      	str	r3, [r4, #20]
  DmaHandle.Init.Mode                = DMA_CIRCULAR;              /* DMA in circular mode to match with ADC configuration: DMA continuous requests */
 8009a7c:	2320      	movs	r3, #32
 8009a7e:	61a3      	str	r3, [r4, #24]
  DmaHandle.Init.Priority            = DMA_PRIORITY_HIGH;
 8009a80:	2380      	movs	r3, #128	; 0x80

  /* Initialization of the DMA associated to the peripheral */
  HAL_DMA_DeInit(&DmaHandle);
 8009a82:	0020      	movs	r0, r4
  DmaHandle.Init.Priority            = DMA_PRIORITY_HIGH;
 8009a84:	019b      	lsls	r3, r3, #6
 8009a86:	61e3      	str	r3, [r4, #28]
  HAL_DMA_DeInit(&DmaHandle);
 8009a88:	f7fd fe42 	bl	8007710 <HAL_DMA_DeInit>
  HAL_DMA_Init(&DmaHandle);
 8009a8c:	0020      	movs	r0, r4
 8009a8e:	f7fd fe09 	bl	80076a4 <HAL_DMA_Init>

  /* Association of the initialized DMA handle to the ADC handle */
  __HAL_LINKDMA(&usbpdm1_hadc, DMA_Handle, DmaHandle);
 8009a92:	4b04      	ldr	r3, [pc, #16]	; (8009aa4 <PHY_HW_IF_ADCDMA_Init+0x44>)
 8009a94:	63dc      	str	r4, [r3, #60]	; 0x3c
 8009a96:	6263      	str	r3, [r4, #36]	; 0x24
}
 8009a98:	bd10      	pop	{r4, pc}
 8009a9a:	46c0      	nop			; (mov r8, r8)
 8009a9c:	40020008 	.word	0x40020008
 8009aa0:	20001c9c 	.word	0x20001c9c
 8009aa4:	20001be4 	.word	0x20001be4

08009aa8 <PHY_HW_IF_RX_Stop>:
  * @brief  PHY accomplishes the data receiving phase
  * @param  PortNum The port index
  * @retval None
  */
void PHY_HW_IF_RX_Stop(uint8_t PortNum)
{
 8009aa8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009aaa:	0005      	movs	r5, r0
   * 3 - PHY_HW_IF_RX_Stop function is ongoing
   */

  UnwrapData_TypeDef* ud = &(Ports[PortNum].unwrapdata);
  
  if (ud->exed_flag == 3)
 8009aac:	20f0      	movs	r0, #240	; 0xf0
 8009aae:	0040      	lsls	r0, r0, #1
 8009ab0:	4368      	muls	r0, r5
 8009ab2:	4c49      	ldr	r4, [pc, #292]	; (8009bd8 <PHY_HW_IF_RX_Stop+0x130>)
 8009ab4:	0002      	movs	r2, r0
 8009ab6:	1826      	adds	r6, r4, r0
 8009ab8:	0033      	movs	r3, r6
 8009aba:	3279      	adds	r2, #121	; 0x79
 8009abc:	332c      	adds	r3, #44	; 0x2c
 8009abe:	32ff      	adds	r2, #255	; 0xff
 8009ac0:	781f      	ldrb	r7, [r3, #0]
{
 8009ac2:	b089      	sub	sp, #36	; 0x24
 8009ac4:	1912      	adds	r2, r2, r4
  if (ud->exed_flag == 3)
 8009ac6:	9001      	str	r0, [sp, #4]
 8009ac8:	9202      	str	r2, [sp, #8]
 8009aca:	2f03      	cmp	r7, #3
 8009acc:	d105      	bne.n	8009ada <PHY_HW_IF_RX_Stop+0x32>
  {
    HAL_TIM_OC_Stop_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 8009ace:	2100      	movs	r1, #0
 8009ad0:	0010      	movs	r0, r2
 8009ad2:	f7ff f981 	bl	8008dd8 <HAL_TIM_OC_Stop_IT>
  /* Callback core phy completed */
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed != NULL)
  {
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed(PortNum);
  }
}
 8009ad6:	b009      	add	sp, #36	; 0x24
 8009ad8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  ud->exed_flag = 3;
 8009ada:	2203      	movs	r2, #3
{
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Disable the TIM Capture/Compare 1 interrupt */
  __HAL_TIM_DISABLE_IT(htim, tim_it);
 8009adc:	36fc      	adds	r6, #252	; 0xfc
 8009ade:	6ff0      	ldr	r0, [r6, #124]	; 0x7c
  ud->exed_flag = 3;
 8009ae0:	701a      	strb	r2, [r3, #0]
  __HAL_TIM_DISABLE_IT(htim, tim_it);
 8009ae2:	68c3      	ldr	r3, [r0, #12]
 8009ae4:	3a01      	subs	r2, #1
 8009ae6:	4393      	bics	r3, r2

  /* Disable the Output compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 8009ae8:	2200      	movs	r2, #0
  __HAL_TIM_DISABLE_IT(htim, tim_it);
 8009aea:	60c3      	str	r3, [r0, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 8009aec:	0011      	movs	r1, r2
 8009aee:	f7ff f927 	bl	8008d40 <TIM_CCxChannelCmd>

  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8009af2:	6ff3      	ldr	r3, [r6, #124]	; 0x7c
 8009af4:	4a39      	ldr	r2, [pc, #228]	; (8009bdc <PHY_HW_IF_RX_Stop+0x134>)
 8009af6:	483a      	ldr	r0, [pc, #232]	; (8009be0 <PHY_HW_IF_RX_Stop+0x138>)
 8009af8:	4293      	cmp	r3, r2
 8009afa:	d008      	beq.n	8009b0e <PHY_HW_IF_RX_Stop+0x66>
 8009afc:	4a39      	ldr	r2, [pc, #228]	; (8009be4 <PHY_HW_IF_RX_Stop+0x13c>)
 8009afe:	4293      	cmp	r3, r2
 8009b00:	d005      	beq.n	8009b0e <PHY_HW_IF_RX_Stop+0x66>
 8009b02:	4a39      	ldr	r2, [pc, #228]	; (8009be8 <PHY_HW_IF_RX_Stop+0x140>)
 8009b04:	4293      	cmp	r3, r2
 8009b06:	d002      	beq.n	8009b0e <PHY_HW_IF_RX_Stop+0x66>
 8009b08:	4a38      	ldr	r2, [pc, #224]	; (8009bec <PHY_HW_IF_RX_Stop+0x144>)
 8009b0a:	4293      	cmp	r3, r2
 8009b0c:	d102      	bne.n	8009b14 <PHY_HW_IF_RX_Stop+0x6c>
  {
    /* Disable the Main Ouput */
    htim->Instance->BDTR &= ~(TIM_BDTR_MOE);
 8009b0e:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8009b10:	4001      	ands	r1, r0
 8009b12:	6459      	str	r1, [r3, #68]	; 0x44
  }
  /* Disable the Peripheral */
  htim->Instance->BDTR &= ~(TIM_BDTR_MOE);
 8009b14:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8009b16:	4002      	ands	r2, r0
 8009b18:	645a      	str	r2, [r3, #68]	; 0x44
  if (ud_ef == 0)
 8009b1a:	2f00      	cmp	r7, #0
 8009b1c:	d13f      	bne.n	8009b9e <PHY_HW_IF_RX_Stop+0xf6>
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 8009b1e:	23f0      	movs	r3, #240	; 0xf0
 8009b20:	005b      	lsls	r3, r3, #1
 8009b22:	436b      	muls	r3, r5
 8009b24:	18e4      	adds	r4, r4, r3
 8009b26:	68e2      	ldr	r2, [r4, #12]
  uint32_t temp_data = 0;
 8009b28:	9707      	str	r7, [sp, #28]
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 8009b2a:	9203      	str	r2, [sp, #12]
  uint16_t lastindex = (RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR);
 8009b2c:	0022      	movs	r2, r4
 8009b2e:	32e8      	adds	r2, #232	; 0xe8
 8009b30:	6812      	ldr	r2, [r2, #0]
 8009b32:	6852      	ldr	r2, [r2, #4]
 8009b34:	9204      	str	r2, [sp, #16]
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate == NULL)
 8009b36:	0022      	movs	r2, r4
 8009b38:	32c9      	adds	r2, #201	; 0xc9
 8009b3a:	32ff      	adds	r2, #255	; 0xff
 8009b3c:	6812      	ldr	r2, [r2, #0]
 8009b3e:	2a00      	cmp	r2, #0
 8009b40:	d02c      	beq.n	8009b9c <PHY_HW_IF_RX_Stop+0xf4>
  while(ud->index <= lastindex)
 8009b42:	9305      	str	r3, [sp, #20]
  uint16_t lastindex = (RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR);
 8009b44:	233c      	movs	r3, #60	; 0x3c
 8009b46:	9a04      	ldr	r2, [sp, #16]
  while(ud->index <= lastindex)
 8009b48:	6ba6      	ldr	r6, [r4, #56]	; 0x38
  uint16_t lastindex = (RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR);
 8009b4a:	1a9b      	subs	r3, r3, r2
  while(ud->index <= lastindex)
 8009b4c:	b29b      	uxth	r3, r3
 8009b4e:	429e      	cmp	r6, r3
 8009b50:	d825      	bhi.n	8009b9e <PHY_HW_IF_RX_Stop+0xf6>
    memcpy(&temp_data, &pbuff_in[ud->index], 3);
 8009b52:	9b03      	ldr	r3, [sp, #12]
 8009b54:	2203      	movs	r2, #3
 8009b56:	1999      	adds	r1, r3, r6
 8009b58:	a807      	add	r0, sp, #28
 8009b5a:	f002 fcc7 	bl	800c4ec <memcpy>
    ud->index += ud->offset <= 5 ? 1 : 2;
 8009b5e:	2305      	movs	r3, #5
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009b60:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8009b62:	9f07      	ldr	r7, [sp, #28]
    ud->index += ud->offset <= 5 ? 1 : 2;
 8009b64:	4293      	cmp	r3, r2
 8009b66:	419b      	sbcs	r3, r3
 8009b68:	425b      	negs	r3, r3
 8009b6a:	3301      	adds	r3, #1
 8009b6c:	469c      	mov	ip, r3
 8009b6e:	481a      	ldr	r0, [pc, #104]	; (8009bd8 <PHY_HW_IF_RX_Stop+0x130>)
 8009b70:	9b05      	ldr	r3, [sp, #20]
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009b72:	40d7      	lsrs	r7, r2
    ud->index += ud->offset <= 5 ? 1 : 2;
 8009b74:	18c0      	adds	r0, r0, r3
    ud->offset = (ud->offset + 2) & 7;
 8009b76:	2307      	movs	r3, #7
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009b78:	05b9      	lsls	r1, r7, #22
    ud->offset = (ud->offset + 2) & 7;
 8009b7a:	3202      	adds	r2, #2
 8009b7c:	401a      	ands	r2, r3
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009b7e:	0d89      	lsrs	r1, r1, #22
    ud->index += ud->offset <= 5 ? 1 : 2;
 8009b80:	4466      	add	r6, ip
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009b82:	9107      	str	r1, [sp, #28]
    ud->index += ud->offset <= 5 ? 1 : 2;
 8009b84:	6386      	str	r6, [r0, #56]	; 0x38
    ud->offset = (ud->offset + 2) & 7;
 8009b86:	63c2      	str	r2, [r0, #60]	; 0x3c
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate(PortNum, temp_data);
 8009b88:	30c9      	adds	r0, #201	; 0xc9
 8009b8a:	30ff      	adds	r0, #255	; 0xff
 8009b8c:	6803      	ldr	r3, [r0, #0]
 8009b8e:	0028      	movs	r0, r5
 8009b90:	4798      	blx	r3
    if ((temp_data & 0x1F) == 0x0D)
 8009b92:	231f      	movs	r3, #31
 8009b94:	401f      	ands	r7, r3
 8009b96:	2f0d      	cmp	r7, #13
 8009b98:	d1d4      	bne.n	8009b44 <PHY_HW_IF_RX_Stop+0x9c>
 8009b9a:	e000      	b.n	8009b9e <PHY_HW_IF_RX_Stop+0xf6>
 8009b9c:	46c0      	nop			; (mov r8, r8)
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 8009b9e:	24f0      	movs	r4, #240	; 0xf0
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 8009ba0:	9801      	ldr	r0, [sp, #4]
 8009ba2:	4e0d      	ldr	r6, [pc, #52]	; (8009bd8 <PHY_HW_IF_RX_Stop+0x130>)
 8009ba4:	3040      	adds	r0, #64	; 0x40
 8009ba6:	1980      	adds	r0, r0, r6
 8009ba8:	f7fe fd9c 	bl	80086e4 <HAL_SPI_DMAStop>
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 8009bac:	2301      	movs	r3, #1
 8009bae:	0064      	lsls	r4, r4, #1
 8009bb0:	436c      	muls	r4, r5
 8009bb2:	1934      	adds	r4, r6, r4
 8009bb4:	7663      	strb	r3, [r4, #25]
  HAL_TIM_Base_Stop_IT(&(Ports[PortNum].htimcountrx));
 8009bb6:	9802      	ldr	r0, [sp, #8]
 8009bb8:	f7fe ffb6 	bl	8008b28 <HAL_TIM_Base_Stop_IT>
  Ports[PortNum].htimcountrx.Instance->CNT = 0;
 8009bbc:	0023      	movs	r3, r4
 8009bbe:	2200      	movs	r2, #0
 8009bc0:	33fc      	adds	r3, #252	; 0xfc
 8009bc2:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed != NULL)
 8009bc4:	34cd      	adds	r4, #205	; 0xcd
 8009bc6:	34ff      	adds	r4, #255	; 0xff
  Ports[PortNum].htimcountrx.Instance->CNT = 0;
 8009bc8:	625a      	str	r2, [r3, #36]	; 0x24
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed != NULL)
 8009bca:	6823      	ldr	r3, [r4, #0]
 8009bcc:	4293      	cmp	r3, r2
 8009bce:	d100      	bne.n	8009bd2 <PHY_HW_IF_RX_Stop+0x12a>
 8009bd0:	e781      	b.n	8009ad6 <PHY_HW_IF_RX_Stop+0x2e>
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed(PortNum);
 8009bd2:	0028      	movs	r0, r5
 8009bd4:	4798      	blx	r3
 8009bd6:	e77e      	b.n	8009ad6 <PHY_HW_IF_RX_Stop+0x2e>
 8009bd8:	2000007c 	.word	0x2000007c
 8009bdc:	40012c00 	.word	0x40012c00
 8009be0:	ffff7fff 	.word	0xffff7fff
 8009be4:	40014000 	.word	0x40014000
 8009be8:	40014400 	.word	0x40014400
 8009bec:	40014800 	.word	0x40014800

08009bf0 <HAL_TIM_OC_DelayElapsedCallback>:
  uint32_t temp_data = 0;
 8009bf0:	2300      	movs	r3, #0
{
 8009bf2:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 8009bf4:	4c62      	ldr	r4, [pc, #392]	; (8009d80 <HAL_TIM_OC_DelayElapsedCallback+0x190>)
{
 8009bf6:	b085      	sub	sp, #20
  uint32_t temp_data = 0;
 8009bf8:	9303      	str	r3, [sp, #12]
  uint32_t tim_count = Ports[PortNum].htimcountrx.Instance->CNT;
 8009bfa:	0023      	movs	r3, r4
 8009bfc:	33fc      	adds	r3, #252	; 0xfc
 8009bfe:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 8009c00:	68e6      	ldr	r6, [r4, #12]
  uint32_t tim_count = Ports[PortNum].htimcountrx.Instance->CNT;
 8009c02:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009c04:	9301      	str	r3, [sp, #4]
         (ud->exed_flag == 0) &&
 8009c06:	0022      	movs	r2, r4
 8009c08:	322c      	adds	r2, #44	; 0x2c
  while (
 8009c0a:	7812      	ldrb	r2, [r2, #0]
 8009c0c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009c0e:	2a00      	cmp	r2, #0
 8009c10:	d100      	bne.n	8009c14 <HAL_TIM_OC_DelayElapsedCallback+0x24>
 8009c12:	e084      	b.n	8009d1e <HAL_TIM_OC_DelayElapsedCallback+0x12e>
  Ports[PortNum].ud_index_current[Ports[PortNum].modulo] = ud->index ;
 8009c14:	27ee      	movs	r7, #238	; 0xee
 8009c16:	007f      	lsls	r7, r7, #1
 8009c18:	5de0      	ldrb	r0, [r4, r7]
 8009c1a:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 8009c1c:	1823      	adds	r3, r4, r0
 8009c1e:	33da      	adds	r3, #218	; 0xda
 8009c20:	33ff      	adds	r3, #255	; 0xff
  Ports[PortNum].modulo++;
 8009c22:	3001      	adds	r0, #1
  Ports[PortNum].ud_index_current[Ports[PortNum].modulo] = ud->index ;
 8009c24:	701e      	strb	r6, [r3, #0]
  Ports[PortNum].modulo = Ports[PortNum].modulo%3;
 8009c26:	b2c0      	uxtb	r0, r0
 8009c28:	2103      	movs	r1, #3
 8009c2a:	f7fb ff49 	bl	8005ac0 <__aeabi_uidivmod>
 8009c2e:	b2cd      	uxtb	r5, r1
      (Ports[PortNum].ud_index_current[Ports[PortNum].modulo] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3]) &&
 8009c30:	1963      	adds	r3, r4, r5
 8009c32:	33da      	adds	r3, #218	; 0xda
  Ports[PortNum].modulo = Ports[PortNum].modulo%3;
 8009c34:	55e5      	strb	r5, [r4, r7]
      (Ports[PortNum].ud_index_current[Ports[PortNum].modulo] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3]) &&
 8009c36:	33ff      	adds	r3, #255	; 0xff
 8009c38:	781b      	ldrb	r3, [r3, #0]
 8009c3a:	1c68      	adds	r0, r5, #1
 8009c3c:	2103      	movs	r1, #3
 8009c3e:	9301      	str	r3, [sp, #4]
 8009c40:	f7fc f828 	bl	8005c94 <__aeabi_idivmod>
 8009c44:	1861      	adds	r1, r4, r1
 8009c46:	31da      	adds	r1, #218	; 0xda
 8009c48:	31ff      	adds	r1, #255	; 0xff
  if (
 8009c4a:	780f      	ldrb	r7, [r1, #0]
 8009c4c:	9b01      	ldr	r3, [sp, #4]
 8009c4e:	429f      	cmp	r7, r3
 8009c50:	d10f      	bne.n	8009c72 <HAL_TIM_OC_DelayElapsedCallback+0x82>
        (Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+2)%3]) &&
 8009c52:	1ca8      	adds	r0, r5, #2
 8009c54:	2103      	movs	r1, #3
 8009c56:	f7fc f81d 	bl	8005c94 <__aeabi_idivmod>
 8009c5a:	1861      	adds	r1, r4, r1
 8009c5c:	31da      	adds	r1, #218	; 0xda
 8009c5e:	31ff      	adds	r1, #255	; 0xff
      (Ports[PortNum].ud_index_current[Ports[PortNum].modulo] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3]) &&
 8009c60:	780b      	ldrb	r3, [r1, #0]
 8009c62:	42bb      	cmp	r3, r7
 8009c64:	d105      	bne.n	8009c72 <HAL_TIM_OC_DelayElapsedCallback+0x82>
        (Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+2)%3]) &&
 8009c66:	2e05      	cmp	r6, #5
 8009c68:	d903      	bls.n	8009c72 <HAL_TIM_OC_DelayElapsedCallback+0x82>
    ud->exed_flag = 3;
 8009c6a:	0023      	movs	r3, r4
 8009c6c:	2203      	movs	r2, #3
 8009c6e:	332c      	adds	r3, #44	; 0x2c
 8009c70:	701a      	strb	r2, [r3, #0]
  if (ud->exed_flag == 2)
 8009c72:	342c      	adds	r4, #44	; 0x2c
 8009c74:	7823      	ldrb	r3, [r4, #0]
 8009c76:	2b02      	cmp	r3, #2
 8009c78:	d102      	bne.n	8009c80 <HAL_TIM_OC_DelayElapsedCallback+0x90>
    PHY_HW_IF_RX_Stop(PortNum);
 8009c7a:	2000      	movs	r0, #0
 8009c7c:	f7ff ff14 	bl	8009aa8 <PHY_HW_IF_RX_Stop>
}
 8009c80:	b005      	add	sp, #20
 8009c82:	bdf0      	pop	{r4, r5, r6, r7, pc}
          curr_bit = (pbuff_in[ud->index]>>ud->offset) & 0x01;
 8009c84:	2701      	movs	r7, #1
        prev_bit = (pbuff_in[ud->index-1]>>7) & 0x01;
 8009c86:	3a01      	subs	r2, #1
 8009c88:	5cb0      	ldrb	r0, [r6, r2]
 8009c8a:	09c0      	lsrs	r0, r0, #7
        while (ud->offset < 8)
 8009c8c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8009c8e:	2b07      	cmp	r3, #7
 8009c90:	d8b9      	bhi.n	8009c06 <HAL_TIM_OC_DelayElapsedCallback+0x16>
          curr_bit = (pbuff_in[ud->index]>>ud->offset) & 0x01;
 8009c92:	7829      	ldrb	r1, [r5, #0]
 8009c94:	4119      	asrs	r1, r3
 8009c96:	4039      	ands	r1, r7
          if (prev_bit == curr_bit)
 8009c98:	4288      	cmp	r0, r1
 8009c9a:	d114      	bne.n	8009cc6 <HAL_TIM_OC_DelayElapsedCallback+0xd6>
            if (curr_bit == 0)
 8009c9c:	2800      	cmp	r0, #0
 8009c9e:	d104      	bne.n	8009caa <HAL_TIM_OC_DelayElapsedCallback+0xba>
              if (ud->offset == 0)
 8009ca0:	2b00      	cmp	r3, #0
 8009ca2:	d10d      	bne.n	8009cc0 <HAL_TIM_OC_DelayElapsedCallback+0xd0>
                ud->offset = 7;
 8009ca4:	3307      	adds	r3, #7
 8009ca6:	63e3      	str	r3, [r4, #60]	; 0x3c
                ud->index--;
 8009ca8:	63a2      	str	r2, [r4, #56]	; 0x38
            ud->preamble = 1;
 8009caa:	0023      	movs	r3, r4
 8009cac:	2201      	movs	r2, #1
 8009cae:	332d      	adds	r3, #45	; 0x2d
 8009cb0:	701a      	strb	r2, [r3, #0]
            preamble_offset = ud->offset;
 8009cb2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8009cb4:	4b33      	ldr	r3, [pc, #204]	; (8009d84 <HAL_TIM_OC_DelayElapsedCallback+0x194>)
 8009cb6:	701a      	strb	r2, [r3, #0]
            preamble_index = ud->index;
 8009cb8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8009cba:	4b33      	ldr	r3, [pc, #204]	; (8009d88 <HAL_TIM_OC_DelayElapsedCallback+0x198>)
        ud->exed_flag = 2;
 8009cbc:	701a      	strb	r2, [r3, #0]
 8009cbe:	e7a2      	b.n	8009c06 <HAL_TIM_OC_DelayElapsedCallback+0x16>
                ud->offset--;
 8009cc0:	3b01      	subs	r3, #1
 8009cc2:	63e3      	str	r3, [r4, #60]	; 0x3c
 8009cc4:	e7f1      	b.n	8009caa <HAL_TIM_OC_DelayElapsedCallback+0xba>
          ud->offset++;
 8009cc6:	3301      	adds	r3, #1
 8009cc8:	63e3      	str	r3, [r4, #60]	; 0x3c
 8009cca:	0008      	movs	r0, r1
 8009ccc:	e7de      	b.n	8009c8c <HAL_TIM_OC_DelayElapsedCallback+0x9c>
 8009cce:	46c0      	nop			; (mov r8, r8)
      memcpy(&temp_data, &pbuff_in[ud->index], 3);
 8009cd0:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 8009cd2:	2203      	movs	r2, #3
 8009cd4:	19f1      	adds	r1, r6, r7
 8009cd6:	a803      	add	r0, sp, #12
 8009cd8:	f002 fc08 	bl	800c4ec <memcpy>
      ud->index += ud->offset <= 5 ? 1 : 2;
 8009cdc:	2205      	movs	r2, #5
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009cde:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8009ce0:	9d03      	ldr	r5, [sp, #12]
      ud->index += ud->offset <= 5 ? 1 : 2;
 8009ce2:	429a      	cmp	r2, r3
 8009ce4:	4192      	sbcs	r2, r2
 8009ce6:	4252      	negs	r2, r2
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009ce8:	40dd      	lsrs	r5, r3
      ud->index += ud->offset <= 5 ? 1 : 2;
 8009cea:	3201      	adds	r2, #1
 8009cec:	18bf      	adds	r7, r7, r2
      ud->offset = (ud->offset + 2) & 7;
 8009cee:	2207      	movs	r2, #7
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009cf0:	05a9      	lsls	r1, r5, #22
      ud->offset = (ud->offset + 2) & 7;
 8009cf2:	3302      	adds	r3, #2
 8009cf4:	4013      	ands	r3, r2
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009cf6:	0d89      	lsrs	r1, r1, #22
 8009cf8:	9103      	str	r1, [sp, #12]
      ud->offset = (ud->offset + 2) & 7;
 8009cfa:	63e3      	str	r3, [r4, #60]	; 0x3c
      if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate != NULL)
 8009cfc:	23e4      	movs	r3, #228	; 0xe4
 8009cfe:	005b      	lsls	r3, r3, #1
 8009d00:	58e3      	ldr	r3, [r4, r3]
      ud->index += ud->offset <= 5 ? 1 : 2;
 8009d02:	63a7      	str	r7, [r4, #56]	; 0x38
      if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate != NULL)
 8009d04:	2b00      	cmp	r3, #0
 8009d06:	d001      	beq.n	8009d0c <HAL_TIM_OC_DelayElapsedCallback+0x11c>
        Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate(PortNum, temp_data);
 8009d08:	2000      	movs	r0, #0
 8009d0a:	4798      	blx	r3
      if ((temp_data & 0x1F) == 0x0D) /* EOP */
 8009d0c:	231f      	movs	r3, #31
 8009d0e:	401d      	ands	r5, r3
 8009d10:	2d0d      	cmp	r5, #13
 8009d12:	d000      	beq.n	8009d16 <HAL_TIM_OC_DelayElapsedCallback+0x126>
 8009d14:	e777      	b.n	8009c06 <HAL_TIM_OC_DelayElapsedCallback+0x16>
        ud->exed_flag = 2;
 8009d16:	0023      	movs	r3, r4
 8009d18:	2202      	movs	r2, #2
 8009d1a:	332c      	adds	r3, #44	; 0x2c
 8009d1c:	e7ce      	b.n	8009cbc <HAL_TIM_OC_DelayElapsedCallback+0xcc>
           ((RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR)>(ud->index + 2)) &&                /* checking if in the buffer the are enough data */
 8009d1e:	0022      	movs	r2, r4
 8009d20:	213c      	movs	r1, #60	; 0x3c
 8009d22:	32e8      	adds	r2, #232	; 0xe8
 8009d24:	6812      	ldr	r2, [r2, #0]
 8009d26:	3302      	adds	r3, #2
 8009d28:	6852      	ldr	r2, [r2, #4]
 8009d2a:	1a8a      	subs	r2, r1, r2
         (ud->exed_flag == 0) &&
 8009d2c:	429a      	cmp	r2, r3
 8009d2e:	d800      	bhi.n	8009d32 <HAL_TIM_OC_DelayElapsedCallback+0x142>
 8009d30:	e770      	b.n	8009c14 <HAL_TIM_OC_DelayElapsedCallback+0x24>
             (Ports[PortNum].htimcountrx.Instance->CNT < tim_count + DMA_TIME_TASK) &&
 8009d32:	0023      	movs	r3, r4
 8009d34:	33fc      	adds	r3, #252	; 0xfc
 8009d36:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009d38:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009d3a:	9b01      	ldr	r3, [sp, #4]
 8009d3c:	3314      	adds	r3, #20
           ((RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR)>(ud->index + 2)) &&                /* checking if in the buffer the are enough data */
 8009d3e:	429a      	cmp	r2, r3
 8009d40:	d300      	bcc.n	8009d44 <HAL_TIM_OC_DelayElapsedCallback+0x154>
 8009d42:	e767      	b.n	8009c14 <HAL_TIM_OC_DelayElapsedCallback+0x24>
               (HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET)        /* stopping the decoding in case of NSS is high */
 8009d44:	2180      	movs	r1, #128	; 0x80
 8009d46:	4811      	ldr	r0, [pc, #68]	; (8009d8c <HAL_TIM_OC_DelayElapsedCallback+0x19c>)
 8009d48:	0149      	lsls	r1, r1, #5
 8009d4a:	f7fd fe15 	bl	8007978 <HAL_GPIO_ReadPin>
             (Ports[PortNum].htimcountrx.Instance->CNT < tim_count + DMA_TIME_TASK) &&
 8009d4e:	2800      	cmp	r0, #0
 8009d50:	d000      	beq.n	8009d54 <HAL_TIM_OC_DelayElapsedCallback+0x164>
 8009d52:	e75f      	b.n	8009c14 <HAL_TIM_OC_DelayElapsedCallback+0x24>
    if (pbuff_in[ud->index]==0xFF)
 8009d54:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009d56:	5cf3      	ldrb	r3, [r6, r3]
 8009d58:	2bff      	cmp	r3, #255	; 0xff
 8009d5a:	d100      	bne.n	8009d5e <HAL_TIM_OC_DelayElapsedCallback+0x16e>
 8009d5c:	46c0      	nop			; (mov r8, r8)
    if (!ud->preamble)                  /* The end of preamble hasn't identified yet */ 
 8009d5e:	0023      	movs	r3, r4
 8009d60:	332d      	adds	r3, #45	; 0x2d
 8009d62:	781b      	ldrb	r3, [r3, #0]
 8009d64:	2b00      	cmp	r3, #0
 8009d66:	d1b2      	bne.n	8009cce <HAL_TIM_OC_DelayElapsedCallback+0xde>
      r = pbuff_in[ud->index]^0xAA;
 8009d68:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8009d6a:	3b56      	subs	r3, #86	; 0x56
 8009d6c:	18b5      	adds	r5, r6, r2
 8009d6e:	7829      	ldrb	r1, [r5, #0]
 8009d70:	404b      	eors	r3, r1
      if (r == 0x00 || r == 0xFF)       /* The end of preamble is not part of the received data */ 
 8009d72:	3b01      	subs	r3, #1
 8009d74:	b2db      	uxtb	r3, r3
 8009d76:	2bfd      	cmp	r3, #253	; 0xfd
 8009d78:	d984      	bls.n	8009c84 <HAL_TIM_OC_DelayElapsedCallback+0x94>
        ud->index++;
 8009d7a:	3201      	adds	r2, #1
 8009d7c:	63a2      	str	r2, [r4, #56]	; 0x38
 8009d7e:	e742      	b.n	8009c06 <HAL_TIM_OC_DelayElapsedCallback+0x16>
 8009d80:	2000007c 	.word	0x2000007c
 8009d84:	20001be0 	.word	0x20001be0
 8009d88:	20001ce0 	.word	0x20001ce0
 8009d8c:	48000400 	.word	0x48000400

08009d90 <PHY_HW_IF_TX_Done>:
  if (Ports[PortNum].TxSpareBits == 0)
 8009d90:	23f0      	movs	r3, #240	; 0xf0
 8009d92:	005b      	lsls	r3, r3, #1
 8009d94:	4343      	muls	r3, r0
{
 8009d96:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (Ports[PortNum].TxSpareBits == 0)
 8009d98:	4d5e      	ldr	r5, [pc, #376]	; (8009f14 <PHY_HW_IF_TX_Done+0x184>)
{
 8009d9a:	0004      	movs	r4, r0
  if (Ports[PortNum].TxSpareBits == 0)
 8009d9c:	18eb      	adds	r3, r5, r3
 8009d9e:	001a      	movs	r2, r3
 8009da0:	322a      	adds	r2, #42	; 0x2a
 8009da2:	7812      	ldrb	r2, [r2, #0]
    while (((((Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL)) >> SPI_SR_FTLVL_Pos) & 0x03) > 1)
 8009da4:	2103      	movs	r1, #3
  if (Ports[PortNum].TxSpareBits == 0)
 8009da6:	2a00      	cmp	r2, #0
 8009da8:	d143      	bne.n	8009e32 <PHY_HW_IF_TX_Done+0xa2>
 8009daa:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    if (Ports[PortNum].Device_cut == Cut_1)
 8009dac:	33d9      	adds	r3, #217	; 0xd9
 8009dae:	33ff      	adds	r3, #255	; 0xff
 8009db0:	7819      	ldrb	r1, [r3, #0]
 8009db2:	2903      	cmp	r1, #3
 8009db4:	d005      	beq.n	8009dc2 <PHY_HW_IF_TX_Done+0x32>
      while ( (Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL) != 0);  /* != 0x0800 */
 8009db6:	23c0      	movs	r3, #192	; 0xc0
 8009db8:	015b      	lsls	r3, r3, #5
 8009dba:	6891      	ldr	r1, [r2, #8]
 8009dbc:	4219      	tst	r1, r3
 8009dbe:	d1fc      	bne.n	8009dba <PHY_HW_IF_TX_Done+0x2a>
 8009dc0:	e004      	b.n	8009dcc <PHY_HW_IF_TX_Done+0x3c>
      while (((((Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL)) >> SPI_SR_FTLVL_Pos) & 0x03) > 1);
 8009dc2:	6893      	ldr	r3, [r2, #8]
 8009dc4:	0adb      	lsrs	r3, r3, #11
 8009dc6:	400b      	ands	r3, r1
 8009dc8:	2b01      	cmp	r3, #1
 8009dca:	d8fa      	bhi.n	8009dc2 <PHY_HW_IF_TX_Done+0x32>
  while ( (Ports[PortNum].hspi.Instance->SR & SPI_SR_BSY) > 0);
 8009dcc:	23f0      	movs	r3, #240	; 0xf0
 8009dce:	005b      	lsls	r3, r3, #1
 8009dd0:	001a      	movs	r2, r3
 8009dd2:	4362      	muls	r2, r4
 8009dd4:	18aa      	adds	r2, r5, r2
 8009dd6:	6c10      	ldr	r0, [r2, #64]	; 0x40
 8009dd8:	2280      	movs	r2, #128	; 0x80
 8009dda:	6881      	ldr	r1, [r0, #8]
 8009ddc:	4211      	tst	r1, r2
 8009dde:	d1fc      	bne.n	8009dda <PHY_HW_IF_TX_Done+0x4a>
  if (Ports[PortNum].Device_cut == Cut_1)
 8009de0:	4363      	muls	r3, r4
 8009de2:	18eb      	adds	r3, r5, r3
 8009de4:	001a      	movs	r2, r3
 8009de6:	32d9      	adds	r2, #217	; 0xd9
 8009de8:	32ff      	adds	r2, #255	; 0xff
 8009dea:	7812      	ldrb	r2, [r2, #0]
 8009dec:	2a03      	cmp	r2, #3
 8009dee:	d027      	beq.n	8009e40 <PHY_HW_IF_TX_Done+0xb0>
 8009df0:	2708      	movs	r7, #8
 8009df2:	2c00      	cmp	r4, #0
 8009df4:	d101      	bne.n	8009dfa <PHY_HW_IF_TX_Done+0x6a>
 8009df6:	4b48      	ldr	r3, [pc, #288]	; (8009f18 <PHY_HW_IF_TX_Done+0x188>)
 8009df8:	881f      	ldrh	r7, [r3, #0]
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 8009dfa:	23f0      	movs	r3, #240	; 0xf0
 8009dfc:	2600      	movs	r6, #0
 8009dfe:	005b      	lsls	r3, r3, #1
 8009e00:	4363      	muls	r3, r4
 8009e02:	18eb      	adds	r3, r5, r3
 8009e04:	332a      	adds	r3, #42	; 0x2a
 8009e06:	b2bf      	uxth	r7, r7
 8009e08:	9301      	str	r3, [sp, #4]
 8009e0a:	9b01      	ldr	r3, [sp, #4]
 8009e0c:	781b      	ldrb	r3, [r3, #0]
 8009e0e:	42b3      	cmp	r3, r6
 8009e10:	d933      	bls.n	8009e7a <PHY_HW_IF_TX_Done+0xea>
      while (!HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 8009e12:	0039      	movs	r1, r7
 8009e14:	4841      	ldr	r0, [pc, #260]	; (8009f1c <PHY_HW_IF_TX_Done+0x18c>)
 8009e16:	f7fd fdaf 	bl	8007978 <HAL_GPIO_ReadPin>
 8009e1a:	2800      	cmp	r0, #0
 8009e1c:	d0f9      	beq.n	8009e12 <PHY_HW_IF_TX_Done+0x82>
      while (HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 8009e1e:	0039      	movs	r1, r7
 8009e20:	483e      	ldr	r0, [pc, #248]	; (8009f1c <PHY_HW_IF_TX_Done+0x18c>)
 8009e22:	f7fd fda9 	bl	8007978 <HAL_GPIO_ReadPin>
 8009e26:	2800      	cmp	r0, #0
 8009e28:	d1f9      	bne.n	8009e1e <PHY_HW_IF_TX_Done+0x8e>
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 8009e2a:	3601      	adds	r6, #1
 8009e2c:	b2f6      	uxtb	r6, r6
 8009e2e:	e7ec      	b.n	8009e0a <PHY_HW_IF_TX_Done+0x7a>
 8009e30:	46c0      	nop			; (mov r8, r8)
    while (((((Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL)) >> SPI_SR_FTLVL_Pos) & 0x03) > 1)
 8009e32:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8009e34:	6892      	ldr	r2, [r2, #8]
 8009e36:	0ad2      	lsrs	r2, r2, #11
 8009e38:	400a      	ands	r2, r1
 8009e3a:	2a01      	cmp	r2, #1
 8009e3c:	d8f8      	bhi.n	8009e30 <PHY_HW_IF_TX_Done+0xa0>
 8009e3e:	e7c5      	b.n	8009dcc <PHY_HW_IF_TX_Done+0x3c>
 8009e40:	332a      	adds	r3, #42	; 0x2a
 8009e42:	781a      	ldrb	r2, [r3, #0]
    if (Ports[PortNum].TxSpareBits == 0)
 8009e44:	2a00      	cmp	r2, #0
 8009e46:	d14f      	bne.n	8009ee8 <PHY_HW_IF_TX_Done+0x158>
      Ports[PortNum].TxSpareBits = 7;
 8009e48:	3207      	adds	r2, #7
      Ports[PortNum].TxSpareBits = (Ports[PortNum].TxSpareBits - 1);
 8009e4a:	701a      	strb	r2, [r3, #0]
 8009e4c:	2608      	movs	r6, #8
 8009e4e:	2c00      	cmp	r4, #0
 8009e50:	d101      	bne.n	8009e56 <PHY_HW_IF_TX_Done+0xc6>
 8009e52:	4b31      	ldr	r3, [pc, #196]	; (8009f18 <PHY_HW_IF_TX_Done+0x188>)
 8009e54:	881e      	ldrh	r6, [r3, #0]
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 8009e56:	23f0      	movs	r3, #240	; 0xf0
{
 8009e58:	2700      	movs	r7, #0
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 8009e5a:	005b      	lsls	r3, r3, #1
 8009e5c:	4363      	muls	r3, r4
 8009e5e:	18eb      	adds	r3, r5, r3
 8009e60:	332a      	adds	r3, #42	; 0x2a
 8009e62:	b2b6      	uxth	r6, r6
 8009e64:	9301      	str	r3, [sp, #4]
 8009e66:	9b01      	ldr	r3, [sp, #4]
 8009e68:	781b      	ldrb	r3, [r3, #0]
 8009e6a:	42bb      	cmp	r3, r7
 8009e6c:	d83e      	bhi.n	8009eec <PHY_HW_IF_TX_Done+0x15c>
    while (HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 8009e6e:	0031      	movs	r1, r6
 8009e70:	482a      	ldr	r0, [pc, #168]	; (8009f1c <PHY_HW_IF_TX_Done+0x18c>)
 8009e72:	f7fd fd81 	bl	8007978 <HAL_GPIO_ReadPin>
 8009e76:	2800      	cmp	r0, #0
 8009e78:	d1f9      	bne.n	8009e6e <PHY_HW_IF_TX_Done+0xde>
  STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_RESET);
 8009e7a:	2100      	movs	r1, #0
 8009e7c:	0020      	movs	r0, r4
 8009e7e:	f000 fee9 	bl	800ac54 <STUSB16xx_HW_IF_TX_EN_Status>
  __HAL_SPI_DISABLE(&Ports[PortNum].hspi);
 8009e82:	23f0      	movs	r3, #240	; 0xf0
 8009e84:	005b      	lsls	r3, r3, #1
 8009e86:	001a      	movs	r2, r3
 8009e88:	2040      	movs	r0, #64	; 0x40
 8009e8a:	4362      	muls	r2, r4
 8009e8c:	18aa      	adds	r2, r5, r2
 8009e8e:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8009e90:	6811      	ldr	r1, [r2, #0]
 8009e92:	4381      	bics	r1, r0
 8009e94:	6011      	str	r1, [r2, #0]
  while ((Ports[PortNum].hspi.Instance->SR & SPI_SR_FRLVL) != 0)
 8009e96:	21c0      	movs	r1, #192	; 0xc0
 8009e98:	00c9      	lsls	r1, r1, #3
 8009e9a:	6896      	ldr	r6, [r2, #8]
 8009e9c:	400e      	ands	r6, r1
 8009e9e:	d134      	bne.n	8009f0a <PHY_HW_IF_TX_Done+0x17a>
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 8009ea0:	4363      	muls	r3, r4
 8009ea2:	0018      	movs	r0, r3
 8009ea4:	001f      	movs	r7, r3
 8009ea6:	3040      	adds	r0, #64	; 0x40
 8009ea8:	1828      	adds	r0, r5, r0
  if(Ports[PortNum].State==HAL_USBPD_PORT_STATE_BIST)
 8009eaa:	19ef      	adds	r7, r5, r7
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 8009eac:	f7fe fc1a 	bl	80086e4 <HAL_SPI_DMAStop>
  if(Ports[PortNum].State==HAL_USBPD_PORT_STATE_BIST)
 8009eb0:	7e7a      	ldrb	r2, [r7, #25]
 8009eb2:	2a08      	cmp	r2, #8
 8009eb4:	d12b      	bne.n	8009f0e <PHY_HW_IF_TX_Done+0x17e>
    Ports[PortNum].State=HAL_USBPD_PORT_STATE_RESET;
 8009eb6:	767e      	strb	r6, [r7, #25]
    if ((Ports[PortNum].cbs.USBPD_HW_IF_BistCompleted != NULL) )
 8009eb8:	37c1      	adds	r7, #193	; 0xc1
 8009eba:	37ff      	adds	r7, #255	; 0xff
 8009ebc:	683b      	ldr	r3, [r7, #0]
 8009ebe:	2b00      	cmp	r3, #0
 8009ec0:	d002      	beq.n	8009ec8 <PHY_HW_IF_TX_Done+0x138>
      Ports[PortNum].cbs.USBPD_HW_IF_BistCompleted(PortNum,USBPD_BIST_CARRIER_MODE2);
 8009ec2:	2105      	movs	r1, #5
 8009ec4:	0020      	movs	r0, r4
 8009ec6:	4798      	blx	r3
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_RX);
 8009ec8:	2101      	movs	r1, #1
 8009eca:	0020      	movs	r0, r4
 8009ecc:	f000 feb4 	bl	800ac38 <STUSB16xx_HW_IF_Switch_Mode>
  if (Ports[PortNum].cbs.USBPD_HW_IF_TxCompleted != NULL)
 8009ed0:	23f0      	movs	r3, #240	; 0xf0
 8009ed2:	005b      	lsls	r3, r3, #1
 8009ed4:	4363      	muls	r3, r4
 8009ed6:	18ed      	adds	r5, r5, r3
 8009ed8:	35bd      	adds	r5, #189	; 0xbd
 8009eda:	35ff      	adds	r5, #255	; 0xff
 8009edc:	682b      	ldr	r3, [r5, #0]
 8009ede:	2b00      	cmp	r3, #0
 8009ee0:	d001      	beq.n	8009ee6 <PHY_HW_IF_TX_Done+0x156>
    Ports[PortNum].cbs.USBPD_HW_IF_TxCompleted(PortNum);
 8009ee2:	0020      	movs	r0, r4
 8009ee4:	4798      	blx	r3
}
 8009ee6:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
      Ports[PortNum].TxSpareBits = (Ports[PortNum].TxSpareBits - 1);
 8009ee8:	3a01      	subs	r2, #1
 8009eea:	e7ae      	b.n	8009e4a <PHY_HW_IF_TX_Done+0xba>
      while (HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 8009eec:	0031      	movs	r1, r6
 8009eee:	480b      	ldr	r0, [pc, #44]	; (8009f1c <PHY_HW_IF_TX_Done+0x18c>)
 8009ef0:	f7fd fd42 	bl	8007978 <HAL_GPIO_ReadPin>
 8009ef4:	2800      	cmp	r0, #0
 8009ef6:	d1f9      	bne.n	8009eec <PHY_HW_IF_TX_Done+0x15c>
      while (!HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 8009ef8:	0031      	movs	r1, r6
 8009efa:	4808      	ldr	r0, [pc, #32]	; (8009f1c <PHY_HW_IF_TX_Done+0x18c>)
 8009efc:	f7fd fd3c 	bl	8007978 <HAL_GPIO_ReadPin>
 8009f00:	2800      	cmp	r0, #0
 8009f02:	d0f9      	beq.n	8009ef8 <PHY_HW_IF_TX_Done+0x168>
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 8009f04:	3701      	adds	r7, #1
 8009f06:	b2ff      	uxtb	r7, r7
 8009f08:	e7ad      	b.n	8009e66 <PHY_HW_IF_TX_Done+0xd6>
    dummyDR= *(__IO uint8_t *)&Ports[PortNum].hspi.Instance->DR;
 8009f0a:	7b10      	ldrb	r0, [r2, #12]
 8009f0c:	e7c5      	b.n	8009e9a <PHY_HW_IF_TX_Done+0x10a>
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_WAITING;
 8009f0e:	2205      	movs	r2, #5
 8009f10:	767a      	strb	r2, [r7, #25]
 8009f12:	e7d9      	b.n	8009ec8 <PHY_HW_IF_TX_Done+0x138>
 8009f14:	2000007c 	.word	0x2000007c
 8009f18:	0800c7e4 	.word	0x0800c7e4
 8009f1c:	48000400 	.word	0x48000400

08009f20 <HW_IF_CRC_Init>:
  hcrc.Instance = CRC;
 8009f20:	4807      	ldr	r0, [pc, #28]	; (8009f40 <HW_IF_CRC_Init+0x20>)
 8009f22:	4b08      	ldr	r3, [pc, #32]	; (8009f44 <HW_IF_CRC_Init+0x24>)
{
 8009f24:	b510      	push	{r4, lr}
  hcrc.Instance = CRC;
 8009f26:	6003      	str	r3, [r0, #0]
 8009f28:	2300      	movs	r3, #0
 8009f2a:	8083      	strh	r3, [r0, #4]
  hcrc.Init.InputDataInversionMode =   CRC_INPUTDATA_INVERSION_BYTE;           /* The input data are inverted by WORD */
 8009f2c:	3320      	adds	r3, #32
 8009f2e:	6143      	str	r3, [r0, #20]
  hcrc.Init.OutputDataInversionMode =   CRC_OUTPUTDATA_INVERSION_ENABLE;        /* The output data are Bit-reversed format */
 8009f30:	3360      	adds	r3, #96	; 0x60
 8009f32:	6183      	str	r3, [r0, #24]
  hcrc.InputDataFormat =           CRC_INPUTDATA_FORMAT_BYTES;             /* The input data are 32 bits lenght */
 8009f34:	3b7f      	subs	r3, #127	; 0x7f
 8009f36:	6203      	str	r3, [r0, #32]
  HAL_CRC_Init(&hcrc);
 8009f38:	f7fd fb1b 	bl	8007572 <HAL_CRC_Init>
}
 8009f3c:	bd10      	pop	{r4, pc}
 8009f3e:	46c0      	nop			; (mov r8, r8)
 8009f40:	20001c3c 	.word	0x20001c3c
 8009f44:	40023000 	.word	0x40023000

08009f48 <HW_IF_ADC_Init>:
{
 8009f48:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  usbpdm1_hadc.Instance = HW_IF_ADC;
 8009f4a:	4c17      	ldr	r4, [pc, #92]	; (8009fa8 <HW_IF_ADC_Init+0x60>)
 8009f4c:	4b17      	ldr	r3, [pc, #92]	; (8009fac <HW_IF_ADC_Init+0x64>)
  usbpdm1_hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 8009f4e:	2201      	movs	r2, #1
  usbpdm1_hadc.Instance = HW_IF_ADC;
 8009f50:	6023      	str	r3, [r4, #0]
  usbpdm1_hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8009f52:	2104      	movs	r1, #4
  usbpdm1_hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 8009f54:	2300      	movs	r3, #0
  HAL_ADC_Init(&usbpdm1_hadc);
 8009f56:	0020      	movs	r0, r4
  usbpdm1_hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 8009f58:	6122      	str	r2, [r4, #16]
  usbpdm1_hadc.Init.ContinuousConvMode = ENABLE;
 8009f5a:	6222      	str	r2, [r4, #32]
  usbpdm1_hadc.Init.DMAContinuousRequests = ENABLE;
 8009f5c:	6322      	str	r2, [r4, #48]	; 0x30
  usbpdm1_hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8009f5e:	6362      	str	r2, [r4, #52]	; 0x34
  usbpdm1_hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 8009f60:	6063      	str	r3, [r4, #4]
  usbpdm1_hadc.Init.Resolution = ADC_RESOLUTION_12B;
 8009f62:	60a3      	str	r3, [r4, #8]
  usbpdm1_hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8009f64:	60e3      	str	r3, [r4, #12]
  usbpdm1_hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8009f66:	6161      	str	r1, [r4, #20]
  usbpdm1_hadc.Init.LowPowerAutoWait = DISABLE;
 8009f68:	61a3      	str	r3, [r4, #24]
  usbpdm1_hadc.Init.LowPowerAutoPowerOff = DISABLE;
 8009f6a:	61e3      	str	r3, [r4, #28]
  usbpdm1_hadc.Init.DiscontinuousConvMode = DISABLE;
 8009f6c:	6263      	str	r3, [r4, #36]	; 0x24
  usbpdm1_hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8009f6e:	62e3      	str	r3, [r4, #44]	; 0x2c
  HAL_ADC_Init(&usbpdm1_hadc);
 8009f70:	f7fd f85c 	bl	800702c <HAL_ADC_Init>
  sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 8009f74:	2380      	movs	r3, #128	; 0x80
 8009f76:	015b      	lsls	r3, r3, #5
 8009f78:	9302      	str	r3, [sp, #8]
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 8009f7a:	2380      	movs	r3, #128	; 0x80
 8009f7c:	055b      	lsls	r3, r3, #21
 8009f7e:	9303      	str	r3, [sp, #12]
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 8009f80:	230e      	movs	r3, #14
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 8009f82:	a901      	add	r1, sp, #4
 8009f84:	0020      	movs	r0, r4
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 8009f86:	9301      	str	r3, [sp, #4]
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 8009f88:	f7fd f98c 	bl	80072a4 <HAL_ADC_ConfigChannel>
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 8009f8c:	2307      	movs	r3, #7
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 8009f8e:	a901      	add	r1, sp, #4
 8009f90:	0020      	movs	r0, r4
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 8009f92:	9301      	str	r3, [sp, #4]
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 8009f94:	f7fd f986 	bl	80072a4 <HAL_ADC_ConfigChannel>
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 8009f98:	230a      	movs	r3, #10
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 8009f9a:	a901      	add	r1, sp, #4
 8009f9c:	0020      	movs	r0, r4
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 8009f9e:	9301      	str	r3, [sp, #4]
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 8009fa0:	f7fd f980 	bl	80072a4 <HAL_ADC_ConfigChannel>
}
 8009fa4:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 8009fa6:	46c0      	nop			; (mov r8, r8)
 8009fa8:	20001be4 	.word	0x20001be4
 8009fac:	40012400 	.word	0x40012400

08009fb0 <USBPD_HW_IF_GlobalHwInit>:
{
 8009fb0:	b510      	push	{r4, lr}
  HW_IF_ADC_Init();
 8009fb2:	f7ff ffc9 	bl	8009f48 <HW_IF_ADC_Init>
  HAL_ADCEx_Calibration_Start(&usbpdm1_hadc);
 8009fb6:	4c08      	ldr	r4, [pc, #32]	; (8009fd8 <USBPD_HW_IF_GlobalHwInit+0x28>)
 8009fb8:	0020      	movs	r0, r4
 8009fba:	f7fd f9f3 	bl	80073a4 <HAL_ADCEx_Calibration_Start>
  HAL_ADC_Start_DMA(&usbpdm1_hadc, ADCxConvertedValues, ADCCONVERTEDVALUES_BUFFER_SIZE);
 8009fbe:	2203      	movs	r2, #3
 8009fc0:	4906      	ldr	r1, [pc, #24]	; (8009fdc <USBPD_HW_IF_GlobalHwInit+0x2c>)
 8009fc2:	0020      	movs	r0, r4
 8009fc4:	f7fd f8d6 	bl	8007174 <HAL_ADC_Start_DMA>
  HW_IF_CRC_Init();
 8009fc8:	f7ff ffaa 	bl	8009f20 <HW_IF_CRC_Init>
  HW_IF_PWR_DigitalGPIO_Init();
 8009fcc:	f000 f87a 	bl	800a0c4 <HW_IF_PWR_DigitalGPIO_Init>
  USBPD_TIM_Init();
 8009fd0:	f001 f8fe 	bl	800b1d0 <USBPD_TIM_Init>
}
 8009fd4:	bd10      	pop	{r4, pc}
 8009fd6:	46c0      	nop			; (mov r8, r8)
 8009fd8:	20001be4 	.word	0x20001be4
 8009fdc:	20001c30 	.word	0x20001c30

08009fe0 <HW_IF_UnwrapData_Init>:
  ud->exed_flag =       0;
 8009fe0:	22f0      	movs	r2, #240	; 0xf0
 8009fe2:	0052      	lsls	r2, r2, #1
 8009fe4:	4342      	muls	r2, r0
 8009fe6:	490a      	ldr	r1, [pc, #40]	; (800a010 <HW_IF_UnwrapData_Init+0x30>)
  ud->dataindex =       0;
 8009fe8:	480a      	ldr	r0, [pc, #40]	; (800a014 <HW_IF_UnwrapData_Init+0x34>)
  ud->exed_flag =       0;
 8009fea:	2300      	movs	r3, #0
  ud->dataindex =       0;
 8009fec:	1880      	adds	r0, r0, r2
  ud->exed_flag =       0;
 8009fee:	1851      	adds	r1, r2, r1
  ud->index =           2;      /* It discards first two bytes */
 8009ff0:	2202      	movs	r2, #2
  ud->exed_flag =       0;
 8009ff2:	808b      	strh	r3, [r1, #4]
  ud->index =           2;      /* It discards first two bytes */
 8009ff4:	6382      	str	r2, [r0, #56]	; 0x38
  preamble_offset = 0;
 8009ff6:	4a08      	ldr	r2, [pc, #32]	; (800a018 <HW_IF_UnwrapData_Init+0x38>)
  ud->dataindex =       0;
 8009ff8:	6303      	str	r3, [r0, #48]	; 0x30
  ud->dataoffset =      0;
 8009ffa:	6343      	str	r3, [r0, #52]	; 0x34
  ud->offset =          0;
 8009ffc:	63c3      	str	r3, [r0, #60]	; 0x3c
  preamble_offset = 0;
 8009ffe:	7013      	strb	r3, [r2, #0]
  preamble_index = 0;
 800a000:	4a06      	ldr	r2, [pc, #24]	; (800a01c <HW_IF_UnwrapData_Init+0x3c>)
 800a002:	7013      	strb	r3, [r2, #0]
  preamble_counter++;
 800a004:	4a06      	ldr	r2, [pc, #24]	; (800a020 <HW_IF_UnwrapData_Init+0x40>)
 800a006:	6813      	ldr	r3, [r2, #0]
 800a008:	3301      	adds	r3, #1
 800a00a:	6013      	str	r3, [r2, #0]
}
 800a00c:	4770      	bx	lr
 800a00e:	46c0      	nop			; (mov r8, r8)
 800a010:	200000a4 	.word	0x200000a4
 800a014:	2000007c 	.word	0x2000007c
 800a018:	20001be0 	.word	0x20001be0
 800a01c:	20001ce0 	.word	0x20001ce0
 800a020:	200003fc 	.word	0x200003fc

0800a024 <PHY_HW_IF_RX_Start>:
{
 800a024:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset != NULL)
 800a026:	25f0      	movs	r5, #240	; 0xf0
 800a028:	006d      	lsls	r5, r5, #1
 800a02a:	002b      	movs	r3, r5
 800a02c:	4343      	muls	r3, r0
 800a02e:	4e24      	ldr	r6, [pc, #144]	; (800a0c0 <PHY_HW_IF_RX_Start+0x9c>)
{
 800a030:	b085      	sub	sp, #20
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset != NULL)
 800a032:	18f3      	adds	r3, r6, r3
 800a034:	33c5      	adds	r3, #197	; 0xc5
 800a036:	33ff      	adds	r3, #255	; 0xff
 800a038:	681b      	ldr	r3, [r3, #0]
{
 800a03a:	0004      	movs	r4, r0
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset != NULL)
 800a03c:	2b00      	cmp	r3, #0
 800a03e:	d000      	beq.n	800a042 <PHY_HW_IF_RX_Start+0x1e>
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset(PortNum);
 800a040:	4798      	blx	r3
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_RX;
 800a042:	2304      	movs	r3, #4
 800a044:	4365      	muls	r5, r4
 800a046:	9501      	str	r5, [sp, #4]
 800a048:	1975      	adds	r5, r6, r5
 800a04a:	766b      	strb	r3, [r5, #25]
  HW_IF_UnwrapData_Init(PortNum);
 800a04c:	0020      	movs	r0, r4
 800a04e:	f7ff ffc7 	bl	8009fe0 <HW_IF_UnwrapData_Init>
    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a052:	9f01      	ldr	r7, [sp, #4]
 800a054:	3740      	adds	r7, #64	; 0x40
 800a056:	19f7      	adds	r7, r6, r7
 800a058:	0038      	movs	r0, r7
 800a05a:	f7fe fb43 	bl	80086e4 <HAL_SPI_DMAStop>
  __IO uint32_t a = 0x0;
 800a05e:	2300      	movs	r3, #0
 800a060:	9303      	str	r3, [sp, #12]
  while(local_hspi->Instance->SR & 0x01)
 800a062:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800a064:	2201      	movs	r2, #1
 800a066:	689d      	ldr	r5, [r3, #8]
 800a068:	4015      	ands	r5, r2
 800a06a:	d125      	bne.n	800a0b8 <PHY_HW_IF_RX_Start+0x94>
  memset(Ports[PortNum].pRxBuffPtr, 0x00, RX_BUFFER_SIZE);
 800a06c:	23f0      	movs	r3, #240	; 0xf0
 800a06e:	005b      	lsls	r3, r3, #1
 800a070:	435c      	muls	r4, r3
 800a072:	1934      	adds	r4, r6, r4
 800a074:	0029      	movs	r1, r5
 800a076:	323b      	adds	r2, #59	; 0x3b
 800a078:	68e0      	ldr	r0, [r4, #12]
 800a07a:	f002 fa40 	bl	800c4fe <memset>
  HAL_SPI_Receive_DMA(&Ports[PortNum].hspi, (uint8_t*)Ports[PortNum].pRxBuffPtr, RX_BUFFER_SIZE);
 800a07e:	68e1      	ldr	r1, [r4, #12]
 800a080:	223c      	movs	r2, #60	; 0x3c
 800a082:	0038      	movs	r0, r7
 800a084:	f7fe fa7c 	bl	8008580 <HAL_SPI_Receive_DMA>
  Ports[PortNum].modulo = 0;
 800a088:	0023      	movs	r3, r4
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a08a:	2101      	movs	r1, #1
  Ports[PortNum].modulo = 0;
 800a08c:	33dd      	adds	r3, #221	; 0xdd
 800a08e:	33ff      	adds	r3, #255	; 0xff
 800a090:	701d      	strb	r5, [r3, #0]
  Ports[PortNum].ud_index_current[0]=0;
 800a092:	3b03      	subs	r3, #3
 800a094:	701d      	strb	r5, [r3, #0]
  Ports[PortNum].ud_index_current[1]=0;
 800a096:	705d      	strb	r5, [r3, #1]
  Ports[PortNum].ud_index_current[2]=0;
 800a098:	709d      	strb	r5, [r3, #2]
  (Ports[PortNum].htimcountrx).Instance->CNT = 0;
 800a09a:	34fc      	adds	r4, #252	; 0xfc
 800a09c:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a09e:	9801      	ldr	r0, [sp, #4]
  (Ports[PortNum].htimcountrx).Instance->CNT = 0;
 800a0a0:	6255      	str	r5, [r2, #36]	; 0x24
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a0a2:	6953      	ldr	r3, [r2, #20]
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a0a4:	3079      	adds	r0, #121	; 0x79
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a0a6:	430b      	orrs	r3, r1
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a0a8:	30ff      	adds	r0, #255	; 0xff
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a0aa:	6153      	str	r3, [r2, #20]
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a0ac:	1830      	adds	r0, r6, r0
 800a0ae:	0029      	movs	r1, r5
 800a0b0:	f7fe fe52 	bl	8008d58 <HAL_TIM_OC_Start_IT>
}
 800a0b4:	b005      	add	sp, #20
 800a0b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a = local_hspi->Instance->DR;
 800a0b8:	68da      	ldr	r2, [r3, #12]
 800a0ba:	9203      	str	r2, [sp, #12]
    UNUSED(a);
 800a0bc:	9a03      	ldr	r2, [sp, #12]
 800a0be:	e7d1      	b.n	800a064 <PHY_HW_IF_RX_Start+0x40>
 800a0c0:	2000007c 	.word	0x2000007c

0800a0c4 <HW_IF_PWR_DigitalGPIO_Init>:
/**
  * @brief  Inititialization of the Power Pins.
  * @retval HAL Status
  */
HAL_StatusTypeDef HW_IF_PWR_DigitalGPIO_Init()
{
 800a0c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a0c6:	2500      	movs	r5, #0
 800a0c8:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef  GPIO_InitStruct;
  uint8_t index = 0;
  for(index=0;index<USBPD_POWSELn;index++)
  {
    USBPD_BSP_GPIOPins_TypeDef gpio = USBPD_POWSELs[index];
 800a0ca:	ac02      	add	r4, sp, #8
 800a0cc:	0021      	movs	r1, r4
 800a0ce:	4b10      	ldr	r3, [pc, #64]	; (800a110 <HW_IF_PWR_DigitalGPIO_Init+0x4c>)
 800a0d0:	195a      	adds	r2, r3, r5
 800a0d2:	cac1      	ldmia	r2!, {r0, r6, r7}
 800a0d4:	c1c1      	stmia	r1!, {r0, r6, r7}
 800a0d6:	58ee      	ldr	r6, [r5, r3]
 800a0d8:	195b      	adds	r3, r3, r5
 800a0da:	889b      	ldrh	r3, [r3, #4]

    /* Configure the powsels pin */
    GPIO_InitStruct.Pin = gpio.GPIO_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a0dc:	2700      	movs	r7, #0
    USBPD_BSP_GPIOPins_TypeDef gpio = USBPD_POWSELs[index];
 800a0de:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pin = gpio.GPIO_Pin;
 800a0e0:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a0e2:	2301      	movs	r3, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;

    HAL_GPIO_Init(gpio.GPIOx, &GPIO_InitStruct);
 800a0e4:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a0e6:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(gpio.GPIOx, &GPIO_InitStruct);
 800a0e8:	0030      	movs	r0, r6
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800a0ea:	3302      	adds	r3, #2
 800a0ec:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a0ee:	9707      	str	r7, [sp, #28]
    HAL_GPIO_Init(gpio.GPIOx, &GPIO_InitStruct);
 800a0f0:	f7fd fb86 	bl	8007800 <HAL_GPIO_Init>

    /* Turn the pin off */
    USBPD_HW_IF_GPIO_Off(gpio);
 800a0f4:	9b01      	ldr	r3, [sp, #4]
 800a0f6:	0030      	movs	r0, r6
 800a0f8:	80a3      	strh	r3, [r4, #4]
 800a0fa:	6861      	ldr	r1, [r4, #4]
 800a0fc:	68a2      	ldr	r2, [r4, #8]
 800a0fe:	350c      	adds	r5, #12
 800a100:	9602      	str	r6, [sp, #8]
 800a102:	f7ff fc87 	bl	8009a14 <USBPD_HW_IF_GPIO_Off>
  for(index=0;index<USBPD_POWSELn;index++)
 800a106:	2d30      	cmp	r5, #48	; 0x30
 800a108:	d1df      	bne.n	800a0ca <HW_IF_PWR_DigitalGPIO_Init+0x6>
  }

  return HAL_OK;
}
 800a10a:	0038      	movs	r0, r7
 800a10c:	b00b      	add	sp, #44	; 0x2c
 800a10e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a110:	0800c78c 	.word	0x0800c78c

0800a114 <HW_IF_PWR_SetVoltage>:
   * |  0   |  1   |  0   |  0   | 15V  |
   * |  1   |  0   |  0   |  0   | 20V  |
   * +------+------+------+------+------+
   */

 switch (voltage)
 800a114:	4b2e      	ldr	r3, [pc, #184]	; (800a1d0 <HW_IF_PWR_SetVoltage+0xbc>)
{
 800a116:	b510      	push	{r4, lr}
 switch (voltage)
 800a118:	4299      	cmp	r1, r3
 800a11a:	d03f      	beq.n	800a19c <HW_IF_PWR_SetVoltage+0x88>
 800a11c:	d821      	bhi.n	800a162 <HW_IF_PWR_SetVoltage+0x4e>
 800a11e:	4b2d      	ldr	r3, [pc, #180]	; (800a1d4 <HW_IF_PWR_SetVoltage+0xc0>)
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 0);
       break;
   case 9000:
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  1);
 800a120:	2201      	movs	r2, #1
 switch (voltage)
 800a122:	4299      	cmp	r1, r3
 800a124:	d000      	beq.n	800a128 <HW_IF_PWR_SetVoltage+0x14>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a126:	2200      	movs	r2, #0
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  1);
 800a128:	2180      	movs	r1, #128	; 0x80
 800a12a:	2090      	movs	r0, #144	; 0x90
 800a12c:	0049      	lsls	r1, r1, #1
 800a12e:	05c0      	lsls	r0, r0, #23
 800a130:	f7fd fc28 	bl	8007984 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
 800a134:	2200      	movs	r2, #0
 800a136:	2180      	movs	r1, #128	; 0x80
 800a138:	2090      	movs	r0, #144	; 0x90
 800a13a:	0089      	lsls	r1, r1, #2
 800a13c:	05c0      	lsls	r0, r0, #23
 800a13e:	f7fd fc21 	bl	8007984 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
 800a142:	2200      	movs	r2, #0
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 0);
       break;
   case 15000:
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 1);
 800a144:	2180      	movs	r1, #128	; 0x80
 800a146:	2090      	movs	r0, #144	; 0x90
 800a148:	00c9      	lsls	r1, r1, #3
 800a14a:	05c0      	lsls	r0, r0, #23
 800a14c:	f7fd fc1a 	bl	8007984 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 0);
 800a150:	2200      	movs	r2, #0
       break;
   case 20000:
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 1);
 800a152:	2180      	movs	r1, #128	; 0x80
 800a154:	2090      	movs	r0, #144	; 0x90
 800a156:	0109      	lsls	r1, r1, #4
 800a158:	05c0      	lsls	r0, r0, #23
 800a15a:	f7fd fc13 	bl	8007984 <HAL_GPIO_WritePin>

  ret=(USBPD_StatusTypeDef)STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum),voltage);

#endif
  return ret;
}
 800a15e:	2000      	movs	r0, #0
 800a160:	bd10      	pop	{r4, pc}
 switch (voltage)
 800a162:	4b1d      	ldr	r3, [pc, #116]	; (800a1d8 <HW_IF_PWR_SetVoltage+0xc4>)
 800a164:	4299      	cmp	r1, r3
 800a166:	d022      	beq.n	800a1ae <HW_IF_PWR_SetVoltage+0x9a>
 800a168:	4b1c      	ldr	r3, [pc, #112]	; (800a1dc <HW_IF_PWR_SetVoltage+0xc8>)
 800a16a:	4299      	cmp	r1, r3
 800a16c:	d1db      	bne.n	800a126 <HW_IF_PWR_SetVoltage+0x12>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a16e:	2180      	movs	r1, #128	; 0x80
 800a170:	2090      	movs	r0, #144	; 0x90
 800a172:	2200      	movs	r2, #0
 800a174:	0049      	lsls	r1, r1, #1
 800a176:	05c0      	lsls	r0, r0, #23
 800a178:	f7fd fc04 	bl	8007984 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
 800a17c:	2180      	movs	r1, #128	; 0x80
 800a17e:	2090      	movs	r0, #144	; 0x90
 800a180:	2200      	movs	r2, #0
 800a182:	0089      	lsls	r1, r1, #2
 800a184:	05c0      	lsls	r0, r0, #23
 800a186:	f7fd fbfd 	bl	8007984 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
 800a18a:	2180      	movs	r1, #128	; 0x80
 800a18c:	2090      	movs	r0, #144	; 0x90
 800a18e:	2200      	movs	r2, #0
 800a190:	00c9      	lsls	r1, r1, #3
 800a192:	05c0      	lsls	r0, r0, #23
 800a194:	f7fd fbf6 	bl	8007984 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 1);
 800a198:	2201      	movs	r2, #1
 800a19a:	e7da      	b.n	800a152 <HW_IF_PWR_SetVoltage+0x3e>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a19c:	2180      	movs	r1, #128	; 0x80
 800a19e:	2090      	movs	r0, #144	; 0x90
 800a1a0:	2200      	movs	r2, #0
 800a1a2:	0049      	lsls	r1, r1, #1
 800a1a4:	05c0      	lsls	r0, r0, #23
 800a1a6:	f7fd fbed 	bl	8007984 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  1);
 800a1aa:	2201      	movs	r2, #1
 800a1ac:	e7c3      	b.n	800a136 <HW_IF_PWR_SetVoltage+0x22>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a1ae:	2180      	movs	r1, #128	; 0x80
 800a1b0:	2090      	movs	r0, #144	; 0x90
 800a1b2:	2200      	movs	r2, #0
 800a1b4:	0049      	lsls	r1, r1, #1
 800a1b6:	05c0      	lsls	r0, r0, #23
 800a1b8:	f7fd fbe4 	bl	8007984 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
 800a1bc:	2180      	movs	r1, #128	; 0x80
 800a1be:	2090      	movs	r0, #144	; 0x90
 800a1c0:	2200      	movs	r2, #0
 800a1c2:	0089      	lsls	r1, r1, #2
 800a1c4:	05c0      	lsls	r0, r0, #23
 800a1c6:	f7fd fbdd 	bl	8007984 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 1);
 800a1ca:	2201      	movs	r2, #1
 800a1cc:	e7ba      	b.n	800a144 <HW_IF_PWR_SetVoltage+0x30>
 800a1ce:	46c0      	nop			; (mov r8, r8)
 800a1d0:	00002ee0 	.word	0x00002ee0
 800a1d4:	00002328 	.word	0x00002328
 800a1d8:	00003a98 	.word	0x00003a98
 800a1dc:	00004e20 	.word	0x00004e20

0800a1e0 <HW_IF_PWR_GetVoltage>:
uint16_t HW_IF_PWR_GetVoltage(uint8_t PortNum)
{
#ifdef __VVAR
   return (uint16_t)MVOLT(ADCxConvertedValues[VBUS_INDEX(PortNum)]);
#else
  return (uint16_t)(STUSB1602_VBUS_Select_Status_Get(STUSB1602_I2C_Add(PortNum)));
 800a1e0:	1e43      	subs	r3, r0, #1
 800a1e2:	4198      	sbcs	r0, r3
{
 800a1e4:	b510      	push	{r4, lr}
  return (uint16_t)(STUSB1602_VBUS_Select_Status_Get(STUSB1602_I2C_Add(PortNum)));
 800a1e6:	3028      	adds	r0, #40	; 0x28
 800a1e8:	f7fc fca8 	bl	8006b3c <STUSB1602_VBUS_Select_Status_Get>
#endif
}
 800a1ec:	bd10      	pop	{r4, pc}
	...

0800a1f0 <HW_IF_PWR_Enable>:
  * @param  VconnState VCONN state
  * @param  role       Power role
  * @retval USBPD status
  */
HAL_StatusTypeDef HW_IF_PWR_Enable(uint8_t PortNum, USBPD_FunctionalState state, CCxPin_TypeDef Cc, uint32_t VconnState, USBPD_PortPowerRole_TypeDef role)
{
 800a1f0:	b570      	push	{r4, r5, r6, lr}
  HAL_StatusTypeDef ret = HAL_ERROR;
#if defined(CONF_NORMAL) || defined(CONF_DEMO_FPGA)
  uint32_t offset_port = (PortNum == 0) ? 0 : 2;
 800a1f2:	0004      	movs	r4, r0
    ret = HAL_OK; /* To allow compatibility with other type-c controllers */
  }

#ifdef CONF_NORMAL
  /* both pin are set off */
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a1f4:	260c      	movs	r6, #12
  uint32_t offset_port = (PortNum == 0) ? 0 : 2;
 800a1f6:	1e60      	subs	r0, r4, #1
 800a1f8:	4184      	sbcs	r4, r0
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a1fa:	0033      	movs	r3, r6
  uint32_t offset_port = (PortNum == 0) ? 0 : 2;
 800a1fc:	0064      	lsls	r4, r4, #1
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a1fe:	4363      	muls	r3, r4
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
 800a200:	3401      	adds	r4, #1
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a202:	4d08      	ldr	r5, [pc, #32]	; (800a224 <HW_IF_PWR_Enable+0x34>)
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
 800a204:	4366      	muls	r6, r4
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a206:	5958      	ldr	r0, [r3, r5]
 800a208:	18eb      	adds	r3, r5, r3
 800a20a:	6859      	ldr	r1, [r3, #4]
 800a20c:	689a      	ldr	r2, [r3, #8]
 800a20e:	f7ff fc01 	bl	8009a14 <USBPD_HW_IF_GPIO_Off>
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
 800a212:	5970      	ldr	r0, [r6, r5]
 800a214:	19ad      	adds	r5, r5, r6
 800a216:	6869      	ldr	r1, [r5, #4]
 800a218:	68aa      	ldr	r2, [r5, #8]
 800a21a:	f7ff fbfb 	bl	8009a14 <USBPD_HW_IF_GPIO_Off>
  /* set SEL1 according to the selected voltage and the table STCH2 Voltage Output */
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
#endif

  return ret;
}
 800a21e:	2000      	movs	r0, #0
 800a220:	bd70      	pop	{r4, r5, r6, pc}
 800a222:	46c0      	nop			; (mov r8, r8)
 800a224:	0800c78c 	.word	0x0800c78c

0800a228 <LL_SYSCFG_SetEXTISource>:
{
 800a228:	b510      	push	{r4, lr}
  MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], SYSCFG_EXTICR1_EXTI0 << (Line >> 16), Port << (Line >> 16));
 800a22a:	240f      	movs	r4, #15
 800a22c:	b2cb      	uxtb	r3, r1
 800a22e:	0c09      	lsrs	r1, r1, #16
 800a230:	408c      	lsls	r4, r1
 800a232:	4088      	lsls	r0, r1
 800a234:	4a03      	ldr	r2, [pc, #12]	; (800a244 <LL_SYSCFG_SetEXTISource+0x1c>)
 800a236:	009b      	lsls	r3, r3, #2
 800a238:	189b      	adds	r3, r3, r2
 800a23a:	689a      	ldr	r2, [r3, #8]
 800a23c:	43a2      	bics	r2, r4
 800a23e:	4310      	orrs	r0, r2
 800a240:	6098      	str	r0, [r3, #8]
}
 800a242:	bd10      	pop	{r4, pc}
 800a244:	40010000 	.word	0x40010000

0800a248 <HW_IF_COMM_WAIT>:
{
  USBPD_StatusTypeDef ret = USBPD_ERROR;
  int16_t timeout = Timeout;
  while (1)
  {
    if (Ports[PortNum].CommLock == 0)
 800a248:	23f0      	movs	r3, #240	; 0xf0
 800a24a:	005b      	lsls	r3, r3, #1
 800a24c:	001a      	movs	r2, r3
 800a24e:	4342      	muls	r2, r0
{
 800a250:	b510      	push	{r4, lr}
    if (Ports[PortNum].CommLock == 0)
 800a252:	4c0b      	ldr	r4, [pc, #44]	; (800a280 <HW_IF_COMM_WAIT+0x38>)
 800a254:	18a2      	adds	r2, r4, r2
 800a256:	32d2      	adds	r2, #210	; 0xd2
 800a258:	32ff      	adds	r2, #255	; 0xff
 800a25a:	7812      	ldrb	r2, [r2, #0]
 800a25c:	2a00      	cmp	r2, #0
 800a25e:	d107      	bne.n	800a270 <HW_IF_COMM_WAIT+0x28>
    {
      /* the resource is free */
      Ports[PortNum].CommLock = 1;
 800a260:	2101      	movs	r1, #1
 800a262:	4343      	muls	r3, r0
      ret = USBPD_OK;
 800a264:	0010      	movs	r0, r2
      Ports[PortNum].CommLock = 1;
 800a266:	18e3      	adds	r3, r4, r3
 800a268:	33d2      	adds	r3, #210	; 0xd2
 800a26a:	33ff      	adds	r3, #255	; 0xff
 800a26c:	7019      	strb	r1, [r3, #0]
    {
      timeout--;
    }
  }
  return ret;
}
 800a26e:	bd10      	pop	{r4, pc}
    if (timeout == 0)
 800a270:	2900      	cmp	r1, #0
 800a272:	d002      	beq.n	800a27a <HW_IF_COMM_WAIT+0x32>
 800a274:	3901      	subs	r1, #1
 800a276:	b209      	sxth	r1, r1
 800a278:	e7f0      	b.n	800a25c <HW_IF_COMM_WAIT+0x14>
      ret = USBPD_TIMEOUT;
 800a27a:	2004      	movs	r0, #4
 800a27c:	e7f7      	b.n	800a26e <HW_IF_COMM_WAIT+0x26>
 800a27e:	46c0      	nop			; (mov r8, r8)
 800a280:	2000007c 	.word	0x2000007c

0800a284 <HW_IF_COMM_RELEASE>:
  * @param   PortNum The port index
  * @retval  USBPD status 
*/
static USBPD_StatusTypeDef HW_IF_COMM_RELEASE(uint8_t PortNum)
{
  if (Ports[PortNum].CommLock == 0)
 800a284:	23f0      	movs	r3, #240	; 0xf0
 800a286:	005b      	lsls	r3, r3, #1
 800a288:	4358      	muls	r0, r3
 800a28a:	4b05      	ldr	r3, [pc, #20]	; (800a2a0 <HW_IF_COMM_RELEASE+0x1c>)
 800a28c:	181b      	adds	r3, r3, r0
 800a28e:	33d2      	adds	r3, #210	; 0xd2
 800a290:	33ff      	adds	r3, #255	; 0xff
 800a292:	781a      	ldrb	r2, [r3, #0]
  {
    /* no change, the resource is already free */
    return USBPD_ERROR;
 800a294:	2002      	movs	r0, #2
  if (Ports[PortNum].CommLock == 0)
 800a296:	2a00      	cmp	r2, #0
 800a298:	d001      	beq.n	800a29e <HW_IF_COMM_RELEASE+0x1a>
  }

  /* release the resource */
  Ports[PortNum].CommLock = 0;
 800a29a:	2000      	movs	r0, #0
 800a29c:	7018      	strb	r0, [r3, #0]
  return USBPD_OK;
}
 800a29e:	4770      	bx	lr
 800a2a0:	2000007c 	.word	0x2000007c

0800a2a4 <LL_APB1_GRP2_EnableClock.constprop.7>:
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP2_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 800a2a4:	2001      	movs	r0, #1
 800a2a6:	4a05      	ldr	r2, [pc, #20]	; (800a2bc <LL_APB1_GRP2_EnableClock.constprop.7+0x18>)
__STATIC_INLINE void LL_APB1_GRP2_EnableClock(uint32_t Periphs)
 800a2a8:	b082      	sub	sp, #8
  SET_BIT(RCC->APB2ENR, Periphs);
 800a2aa:	6991      	ldr	r1, [r2, #24]
 800a2ac:	4301      	orrs	r1, r0
 800a2ae:	6191      	str	r1, [r2, #24]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 800a2b0:	6993      	ldr	r3, [r2, #24]
 800a2b2:	4003      	ands	r3, r0
 800a2b4:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 800a2b6:	9b01      	ldr	r3, [sp, #4]
}
 800a2b8:	b002      	add	sp, #8
 800a2ba:	4770      	bx	lr
 800a2bc:	40021000 	.word	0x40021000

0800a2c0 <USBPDM1_AssertRp>:
}
 800a2c0:	4770      	bx	lr

0800a2c2 <USBPDM1_DeAssertRp>:
 800a2c2:	4770      	bx	lr

0800a2c4 <USBPDM1_AssertRd>:
 800a2c4:	4770      	bx	lr

0800a2c6 <USBPDM1_DeAssertRd>:
 800a2c6:	4770      	bx	lr

0800a2c8 <USBPD_HW_IF_HR_Start>:
{
 800a2c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800a2ca:	2164      	movs	r1, #100	; 0x64
{
 800a2cc:	0006      	movs	r6, r0
 800a2ce:	0017      	movs	r7, r2
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800a2d0:	f7ff ffba 	bl	800a248 <HW_IF_COMM_WAIT>
 800a2d4:	1e05      	subs	r5, r0, #0
  if (ret != USBPD_OK)
 800a2d6:	d144      	bne.n	800a362 <USBPD_HW_IF_HR_Start+0x9a>
  if (Ports[PortNum].Device_cut == Cut_1)
 800a2d8:	22f0      	movs	r2, #240	; 0xf0
 800a2da:	0052      	lsls	r2, r2, #1
 800a2dc:	4372      	muls	r2, r6
 800a2de:	4b22      	ldr	r3, [pc, #136]	; (800a368 <USBPD_HW_IF_HR_Start+0xa0>)
 800a2e0:	189b      	adds	r3, r3, r2
 800a2e2:	33d9      	adds	r3, #217	; 0xd9
 800a2e4:	33ff      	adds	r3, #255	; 0xff
 800a2e6:	781b      	ldrb	r3, [r3, #0]
 800a2e8:	2b03      	cmp	r3, #3
 800a2ea:	d106      	bne.n	800a2fa <USBPD_HW_IF_HR_Start+0x32>
    STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Disable);
 800a2ec:	0030      	movs	r0, r6
 800a2ee:	1e43      	subs	r3, r0, #1
 800a2f0:	4198      	sbcs	r0, r3
 800a2f2:	2101      	movs	r1, #1
 800a2f4:	3028      	adds	r0, #40	; 0x28
 800a2f6:	f7fc fd3d 	bl	8006d74 <STUSB1602_VBUS_Range_State_Set>
  STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000);
 800a2fa:	0034      	movs	r4, r6
 800a2fc:	1e63      	subs	r3, r4, #1
 800a2fe:	419c      	sbcs	r4, r3
 800a300:	3428      	adds	r4, #40	; 0x28
 800a302:	491a      	ldr	r1, [pc, #104]	; (800a36c <USBPD_HW_IF_HR_Start+0xa4>)
 800a304:	0020      	movs	r0, r4
 800a306:	f7fc fc27 	bl	8006b58 <STUSB1602_VBUS_Select_Status_Set>
  ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), Mode == ACKNOWLEDGE ? PD_HARD_RESET_RECEIVED_REQ : PD_HARD_RESET_SEND_REQ);
 800a30a:	0039      	movs	r1, r7
 800a30c:	1e4b      	subs	r3, r1, #1
 800a30e:	4199      	sbcs	r1, r3
 800a310:	0020      	movs	r0, r4
 800a312:	310e      	adds	r1, #14
 800a314:	f7fc fd75 	bl	8006e02 <STUSB1602_Type_C_Command>
 800a318:	0005      	movs	r5, r0
  if (Mode == ACKNOWLEDGE)
 800a31a:	2f00      	cmp	r7, #0
 800a31c:	d105      	bne.n	800a32a <USBPD_HW_IF_HR_Start+0x62>
 800a31e:	23c8      	movs	r3, #200	; 0xc8
 800a320:	46c0      	nop			; (mov r8, r8)
 800a322:	3b01      	subs	r3, #1
 800a324:	b29b      	uxth	r3, r3
    for(uint16_t i=0;i<200;i++)
 800a326:	2b00      	cmp	r3, #0
 800a328:	d1fa      	bne.n	800a320 <USBPD_HW_IF_HR_Start+0x58>
  if (ret == USBPD_OK)
 800a32a:	2800      	cmp	r0, #0
 800a32c:	d116      	bne.n	800a35c <USBPD_HW_IF_HR_Start+0x94>
  STUSB1602_CC_DETECTION_STATUS_Value = STUSB1602_CC_Detection_Status_Get(STUSB1602_I2C_Add(PortNum));
 800a32e:	0020      	movs	r0, r4
 800a330:	f7fc fac0 	bl	80068b4 <STUSB1602_CC_Detection_Status_Get>
  if (STUSB1602_CC_DETECTION_STATUS_Value.b.CC_VCONN_SUPPLY_STATE == VCONN_supplied_on_unused_CC_pin)
 800a334:	2102      	movs	r1, #2
 800a336:	b2c7      	uxtb	r7, r0
 800a338:	420f      	tst	r7, r1
 800a33a:	d003      	beq.n	800a344 <USBPD_HW_IF_HR_Start+0x7c>
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_TURN_OFF_VCONN_REQ);
 800a33c:	0020      	movs	r0, r4
 800a33e:	f7fc fd60 	bl	8006e02 <STUSB1602_Type_C_Command>
 800a342:	0005      	movs	r5, r0
      (((Power_Role_TypeDef)STUSB1602_CC_DETECTION_STATUS_Value.b.CC_POWER_ROLE == Source) &&
 800a344:	210c      	movs	r1, #12
 800a346:	4039      	ands	r1, r7
  if (
 800a348:	2908      	cmp	r1, #8
 800a34a:	d105      	bne.n	800a358 <USBPD_HW_IF_HR_Start+0x90>
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_PORT_CHANGE_2_DFP_REQ);
 800a34c:	3905      	subs	r1, #5
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_PORT_CHANGE_2_UFP_REQ);
 800a34e:	0020      	movs	r0, r4
 800a350:	f7fc fd57 	bl	8006e02 <STUSB1602_Type_C_Command>
 800a354:	0005      	movs	r5, r0
 800a356:	e001      	b.n	800a35c <USBPD_HW_IF_HR_Start+0x94>
  if (
 800a358:	2904      	cmp	r1, #4
 800a35a:	d0f8      	beq.n	800a34e <USBPD_HW_IF_HR_Start+0x86>
  HW_IF_COMM_RELEASE(PortNum);
 800a35c:	0030      	movs	r0, r6
 800a35e:	f7ff ff91 	bl	800a284 <HW_IF_COMM_RELEASE>
}
 800a362:	0028      	movs	r0, r5
 800a364:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a366:	46c0      	nop			; (mov r8, r8)
 800a368:	2000007c 	.word	0x2000007c
 800a36c:	00001388 	.word	0x00001388

0800a370 <USBPD_HW_IF_HR_CheckVbusVSafe0V>:
{
 800a370:	b510      	push	{r4, lr}
  if (CurrentRole == USBPD_PORTPOWERROLE_SRC)
 800a372:	2901      	cmp	r1, #1
 800a374:	d102      	bne.n	800a37c <USBPD_HW_IF_HR_CheckVbusVSafe0V+0xc>
    return USBPD_OK;
 800a376:	2300      	movs	r3, #0
}
 800a378:	0018      	movs	r0, r3
 800a37a:	bd10      	pop	{r4, pc}
  return USBPD_ERROR;
 800a37c:	2302      	movs	r3, #2
  if (CurrentRole == USBPD_PORTPOWERROLE_SNK)
 800a37e:	2900      	cmp	r1, #0
 800a380:	d1fa      	bne.n	800a378 <USBPD_HW_IF_HR_CheckVbusVSafe0V+0x8>
    return STUSB1602_VBUS_Presence_Get(STUSB1602_I2C_Add(PortNum)) == VBUS_below_UVLO_threshold ? USBPD_OK : USBPD_BUSY;
 800a382:	1e43      	subs	r3, r0, #1
 800a384:	4198      	sbcs	r0, r3
 800a386:	3028      	adds	r0, #40	; 0x28
 800a388:	f7fc fac0 	bl	800690c <STUSB1602_VBUS_Presence_Get>
 800a38c:	2800      	cmp	r0, #0
 800a38e:	d0f2      	beq.n	800a376 <USBPD_HW_IF_HR_CheckVbusVSafe0V+0x6>
 800a390:	2303      	movs	r3, #3
 800a392:	e7f1      	b.n	800a378 <USBPD_HW_IF_HR_CheckVbusVSafe0V+0x8>

0800a394 <USBPD_HW_IF_HR_End>:
{
 800a394:	b570      	push	{r4, r5, r6, lr}
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800a396:	2164      	movs	r1, #100	; 0x64
{
 800a398:	0006      	movs	r6, r0
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800a39a:	f7ff ff55 	bl	800a248 <HW_IF_COMM_WAIT>
 800a39e:	1e05      	subs	r5, r0, #0
  if (ret != USBPD_OK)
 800a3a0:	d113      	bne.n	800a3ca <USBPD_HW_IF_HR_End+0x36>
  ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_COMPLETE_REQ);    
 800a3a2:	0034      	movs	r4, r6
 800a3a4:	1e63      	subs	r3, r4, #1
 800a3a6:	419c      	sbcs	r4, r3
 800a3a8:	3428      	adds	r4, #40	; 0x28
 800a3aa:	2101      	movs	r1, #1
 800a3ac:	0020      	movs	r0, r4
 800a3ae:	f7fc fd28 	bl	8006e02 <STUSB1602_Type_C_Command>
  ret = (USBPD_StatusTypeDef)STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000);
 800a3b2:	4907      	ldr	r1, [pc, #28]	; (800a3d0 <USBPD_HW_IF_HR_End+0x3c>)
 800a3b4:	0020      	movs	r0, r4
 800a3b6:	f7fc fbcf 	bl	8006b58 <STUSB1602_VBUS_Select_Status_Set>
  STUSB1602_CC_Detect_Alrt_Int_Mask_Set(STUSB1602_I2C_Add(PortNum), CC_Detect_Int_UNMASKED);
 800a3ba:	2100      	movs	r1, #0
  ret = (USBPD_StatusTypeDef)STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000);
 800a3bc:	0005      	movs	r5, r0
  STUSB1602_CC_Detect_Alrt_Int_Mask_Set(STUSB1602_I2C_Add(PortNum), CC_Detect_Int_UNMASKED);
 800a3be:	0020      	movs	r0, r4
 800a3c0:	f7fc fa54 	bl	800686c <STUSB1602_CC_Detect_Alrt_Int_Mask_Set>
  HW_IF_COMM_RELEASE(PortNum);
 800a3c4:	0030      	movs	r0, r6
 800a3c6:	f7ff ff5d 	bl	800a284 <HW_IF_COMM_RELEASE>
}
 800a3ca:	0028      	movs	r0, r5
 800a3cc:	bd70      	pop	{r4, r5, r6, pc}
 800a3ce:	46c0      	nop			; (mov r8, r8)
 800a3d0:	00001388 	.word	0x00001388

0800a3d4 <USBPD_HW_IF_ErrorRecovery>:
{
 800a3d4:	b510      	push	{r4, lr}
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), SW_RST);
 800a3d6:	1e44      	subs	r4, r0, #1
 800a3d8:	41a0      	sbcs	r0, r4
 800a3da:	3028      	adds	r0, #40	; 0x28
 800a3dc:	0004      	movs	r4, r0
 800a3de:	2101      	movs	r1, #1
 800a3e0:	f7fc fc07 	bl	8006bf2 <STUSB1602_SW_RESET_Set>
  HAL_Delay(27); // need to be 25ms min
 800a3e4:	201b      	movs	r0, #27
 800a3e6:	f7fc fdc5 	bl	8006f74 <HAL_Delay>
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), No_SW_RST);
 800a3ea:	2100      	movs	r1, #0
 800a3ec:	0020      	movs	r0, r4
 800a3ee:	f7fc fc00 	bl	8006bf2 <STUSB1602_SW_RESET_Set>
}
 800a3f2:	2000      	movs	r0, #0
 800a3f4:	bd10      	pop	{r4, pc}
	...

0800a3f8 <HW_IF_SPI_Init>:
  * @retval None
  */ 
void HW_IF_SPI_Init(uint8_t PortNum)
{
  /* Get the peripheral handler variable */
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800a3f8:	21f0      	movs	r1, #240	; 0xf0
 800a3fa:	0049      	lsls	r1, r1, #1
 800a3fc:	4341      	muls	r1, r0
{
 800a3fe:	0002      	movs	r2, r0
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800a400:	0008      	movs	r0, r1
 800a402:	4b11      	ldr	r3, [pc, #68]	; (800a448 <HW_IF_SPI_Init+0x50>)
{
 800a404:	b510      	push	{r4, lr}
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800a406:	3040      	adds	r0, #64	; 0x40
  
  phspi->Instance =           SPI_Instance(PortNum);
 800a408:	4254      	negs	r4, r2
 800a40a:	4162      	adcs	r2, r4
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800a40c:	18c0      	adds	r0, r0, r3
  phspi->Instance =           SPI_Instance(PortNum);
 800a40e:	185b      	adds	r3, r3, r1
  phspi->Init.Mode =           SPI_MODE_SLAVE;
  phspi->Init.Direction =  SPI_DIRECTION_2LINES;
  phspi->Init.DataSize =   SPI_DATASIZE_8BIT;
 800a410:	21e0      	movs	r1, #224	; 0xe0
  phspi->Instance =           SPI_Instance(PortNum);
 800a412:	4c0e      	ldr	r4, [pc, #56]	; (800a44c <HW_IF_SPI_Init+0x54>)
 800a414:	4252      	negs	r2, r2
 800a416:	4022      	ands	r2, r4
  phspi->Init.DataSize =   SPI_DATASIZE_8BIT;
 800a418:	00c9      	lsls	r1, r1, #3
  phspi->Instance =           SPI_Instance(PortNum);
 800a41a:	4c0d      	ldr	r4, [pc, #52]	; (800a450 <HW_IF_SPI_Init+0x58>)
  phspi->Init.DataSize =   SPI_DATASIZE_8BIT;
 800a41c:	64d9      	str	r1, [r3, #76]	; 0x4c
  phspi->Init.CLKPolarity =     SPI_POLARITY_HIGH;
 800a41e:	2102      	movs	r1, #2
  phspi->Instance =           SPI_Instance(PortNum);
 800a420:	1912      	adds	r2, r2, r4
 800a422:	641a      	str	r2, [r3, #64]	; 0x40
  phspi->Init.Mode =           SPI_MODE_SLAVE;
 800a424:	2200      	movs	r2, #0
  phspi->Init.CLKPolarity =     SPI_POLARITY_HIGH;
 800a426:	6519      	str	r1, [r3, #80]	; 0x50
  phspi->Init.CLKPhase =   SPI_PHASE_1EDGE;
  phspi->Init.NSS =     SPI_NSS_HARD_INPUT;
  phspi->Init.FirstBit =   SPI_FIRSTBIT_LSB;
 800a428:	317e      	adds	r1, #126	; 0x7e
 800a42a:	6619      	str	r1, [r3, #96]	; 0x60
  phspi->Init.TIMode =     SPI_TIMODE_DISABLE;
  phspi->Init.CRCCalculation =  SPI_CRCCALCULATION_DISABLE;
  phspi->Init.CRCPolynomial =   7;
 800a42c:	3979      	subs	r1, #121	; 0x79
  phspi->Init.Mode =           SPI_MODE_SLAVE;
 800a42e:	645a      	str	r2, [r3, #68]	; 0x44
  phspi->Init.Direction =  SPI_DIRECTION_2LINES;
 800a430:	649a      	str	r2, [r3, #72]	; 0x48
  phspi->Init.CLKPhase =   SPI_PHASE_1EDGE;
 800a432:	655a      	str	r2, [r3, #84]	; 0x54
  phspi->Init.NSS =     SPI_NSS_HARD_INPUT;
 800a434:	659a      	str	r2, [r3, #88]	; 0x58
  phspi->Init.TIMode =     SPI_TIMODE_DISABLE;
 800a436:	665a      	str	r2, [r3, #100]	; 0x64
  phspi->Init.CRCCalculation =  SPI_CRCCALCULATION_DISABLE;
 800a438:	669a      	str	r2, [r3, #104]	; 0x68
  phspi->Init.CRCPolynomial =   7;
 800a43a:	66d9      	str	r1, [r3, #108]	; 0x6c
  phspi->Init.CRCLength =   SPI_CRC_LENGTH_DATASIZE;
 800a43c:	671a      	str	r2, [r3, #112]	; 0x70
  phspi->Init.NSSPMode =   SPI_NSS_PULSE_DISABLE;
 800a43e:	675a      	str	r2, [r3, #116]	; 0x74
  
  HAL_SPI_Init(phspi);
 800a440:	f7fd fed0 	bl	80081e4 <HAL_SPI_Init>
}
 800a444:	bd10      	pop	{r4, pc}
 800a446:	46c0      	nop			; (mov r8, r8)
 800a448:	2000007c 	.word	0x2000007c
 800a44c:	ffff0800 	.word	0xffff0800
 800a450:	40013000 	.word	0x40013000

0800a454 <HW_IF_SPI_Mode>:
  * @param  PortNum The port index
  * @param  mode Two allowed values: STUSB16xx_SPI_Mode_TX or STUSB16xx_SPI_Mode_RX
  * @retval None
  */ 
void HW_IF_SPI_Mode(uint8_t PortNum, STUSB1602_SPI_Mode_TypeDef mode)
{
 800a454:	b570      	push	{r4, r5, r6, lr}
  /* Stop the SPI DMA before changing SPI mode */
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a456:	25f0      	movs	r5, #240	; 0xf0
 800a458:	006d      	lsls	r5, r5, #1
 800a45a:	4345      	muls	r5, r0
 800a45c:	0028      	movs	r0, r5
 800a45e:	4e1d      	ldr	r6, [pc, #116]	; (800a4d4 <HW_IF_SPI_Mode+0x80>)
 800a460:	3040      	adds	r0, #64	; 0x40
 800a462:	1980      	adds	r0, r0, r6
{
 800a464:	000c      	movs	r4, r1
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a466:	f7fe f93d 	bl	80086e4 <HAL_SPI_DMAStop>
  
  /* Disable SPI peripheral */
  __HAL_SPI_DISABLE(&Ports[PortNum].hspi);
 800a46a:	2140      	movs	r1, #64	; 0x40
 800a46c:	1970      	adds	r0, r6, r5
 800a46e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800a470:	681a      	ldr	r2, [r3, #0]
 800a472:	438a      	bics	r2, r1
 800a474:	601a      	str	r2, [r3, #0]
  
  CR1Value = phspi->Instance->CR1;
  
  /* If cut 1.2 is used, SPI is configured to sample data
     on rising edge on TX phase as well as on falling edge on RX phase */
  if (Ports[PortNum].Device_cut== Cut_1)
 800a476:	0002      	movs	r2, r0
 800a478:	32d9      	adds	r2, #217	; 0xd9
 800a47a:	32ff      	adds	r2, #255	; 0xff
 800a47c:	7812      	ldrb	r2, [r2, #0]
  CR1Value = phspi->Instance->CR1;
 800a47e:	6819      	ldr	r1, [r3, #0]
  if (Ports[PortNum].Device_cut== Cut_1)
 800a480:	2a03      	cmp	r2, #3
 800a482:	d110      	bne.n	800a4a6 <HW_IF_SPI_Mode+0x52>
  {  
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^mode)&1;
 800a484:	2501      	movs	r5, #1
 800a486:	0849      	lsrs	r1, r1, #1
    phspi->Instance->CR1 &= ~1;
 800a488:	681a      	ldr	r2, [r3, #0]
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^mode)&1;
 800a48a:	4029      	ands	r1, r5
 800a48c:	4061      	eors	r1, r4
    phspi->Instance->CR1 &= ~1;
 800a48e:	43aa      	bics	r2, r5
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^mode)&1;
 800a490:	4029      	ands	r1, r5
 800a492:	6541      	str	r1, [r0, #84]	; 0x54
    phspi->Instance->CR1 &= ~1;
 800a494:	601a      	str	r2, [r3, #0]
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^mode)&1;
 800a496:	681a      	ldr	r2, [r3, #0]
    phspi->Instance->CR1 &= ~1;
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^1)&1;

    /* SPI NSS software or hardware according to the mode value */
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800a498:	4311      	orrs	r1, r2
 800a49a:	6019      	str	r1, [r3, #0]
  }
  
  /* Enable SPI peripheral */
  __HAL_SPI_ENABLE(&Ports[PortNum].hspi);
 800a49c:	2240      	movs	r2, #64	; 0x40
 800a49e:	6819      	ldr	r1, [r3, #0]
 800a4a0:	430a      	orrs	r2, r1
 800a4a2:	601a      	str	r2, [r3, #0]
}
 800a4a4:	bd70      	pop	{r4, r5, r6, pc}
  if (Ports[PortNum].Device_cut == Cut_1_A)
 800a4a6:	2a04      	cmp	r2, #4
 800a4a8:	d1f8      	bne.n	800a49c <HW_IF_SPI_Mode+0x48>
 800a4aa:	2501      	movs	r5, #1
 800a4ac:	002e      	movs	r6, r5
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^1)&1;
 800a4ae:	0849      	lsrs	r1, r1, #1
 800a4b0:	438e      	bics	r6, r1
    phspi->Instance->CR1 &= ~1;
 800a4b2:	6819      	ldr	r1, [r3, #0]
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^1)&1;
 800a4b4:	6546      	str	r6, [r0, #84]	; 0x54
    phspi->Instance->CR1 &= ~1;
 800a4b6:	43a9      	bics	r1, r5
 800a4b8:	6019      	str	r1, [r3, #0]
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^1)&1;
 800a4ba:	681a      	ldr	r2, [r3, #0]
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800a4bc:	4906      	ldr	r1, [pc, #24]	; (800a4d8 <HW_IF_SPI_Mode+0x84>)
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^1)&1;
 800a4be:	4332      	orrs	r2, r6
 800a4c0:	601a      	str	r2, [r3, #0]
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800a4c2:	681a      	ldr	r2, [r3, #0]
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800a4c4:	402c      	ands	r4, r5
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800a4c6:	400a      	ands	r2, r1
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800a4c8:	4261      	negs	r1, r4
 800a4ca:	4161      	adcs	r1, r4
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800a4cc:	601a      	str	r2, [r3, #0]
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800a4ce:	681a      	ldr	r2, [r3, #0]
 800a4d0:	0249      	lsls	r1, r1, #9
 800a4d2:	e7e1      	b.n	800a498 <HW_IF_SPI_Mode+0x44>
 800a4d4:	2000007c 	.word	0x2000007c
 800a4d8:	fffffdff 	.word	0xfffffdff

0800a4dc <HW_IF_DMA_Init>:
  * @brief  DMA init function
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_DMA_Init(uint8_t PortNum)
{
 800a4dc:	b507      	push	{r0, r1, r2, lr}
 800a4de:	2201      	movs	r2, #1
 800a4e0:	4b09      	ldr	r3, [pc, #36]	; (800a508 <HW_IF_DMA_Init+0x2c>)
  /* DMA controller clock enable */
  DMA_CLK_ENABLE(PortNum);
 800a4e2:	6959      	ldr	r1, [r3, #20]
 800a4e4:	4311      	orrs	r1, r2
 800a4e6:	6159      	str	r1, [r3, #20]
 800a4e8:	695b      	ldr	r3, [r3, #20]
 800a4ea:	401a      	ands	r2, r3
 800a4ec:	2800      	cmp	r0, #0
 800a4ee:	d107      	bne.n	800a500 <HW_IF_DMA_Init+0x24>
 800a4f0:	9200      	str	r2, [sp, #0]
 800a4f2:	9b00      	ldr	r3, [sp, #0]

  /* NVIC configuration for DMA */
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800a4f4:	300b      	adds	r0, #11
 800a4f6:	2200      	movs	r2, #0
 800a4f8:	0011      	movs	r1, r2
 800a4fa:	f7fc ffa7 	bl	800744c <HAL_NVIC_SetPriority>
}
 800a4fe:	bd07      	pop	{r0, r1, r2, pc}
  DMA_CLK_ENABLE(PortNum);
 800a500:	9201      	str	r2, [sp, #4]
 800a502:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800a504:	200a      	movs	r0, #10
 800a506:	e7f6      	b.n	800a4f6 <HW_IF_DMA_Init+0x1a>
 800a508:	40021000 	.word	0x40021000

0800a50c <HW_IF_STUSB16xx_I2C_Init>:
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_STUSB16xx_I2C_Init(uint8_t PortNum)
{
  I2C_HandleTypeDef*           phi2c = &(Ports[PortNum].hi2c);
 800a50c:	23f0      	movs	r3, #240	; 0xf0
 800a50e:	005b      	lsls	r3, r3, #1
 800a510:	4358      	muls	r0, r3
{
 800a512:	b570      	push	{r4, r5, r6, lr}
  I2C_HandleTypeDef*           phi2c = &(Ports[PortNum].hi2c);
 800a514:	0004      	movs	r4, r0
 800a516:	4b0d      	ldr	r3, [pc, #52]	; (800a54c <HW_IF_STUSB16xx_I2C_Init+0x40>)
 800a518:	342d      	adds	r4, #45	; 0x2d
 800a51a:	34ff      	adds	r4, #255	; 0xff
 800a51c:	18e4      	adds	r4, r4, r3
  
  phi2c->Instance = I2C_INSTANCE(PortNum);
 800a51e:	1818      	adds	r0, r3, r0
 800a520:	4b0b      	ldr	r3, [pc, #44]	; (800a550 <HW_IF_STUSB16xx_I2C_Init+0x44>)
 800a522:	30fc      	adds	r0, #252	; 0xfc
 800a524:	6303      	str	r3, [r0, #48]	; 0x30
  phi2c->Init.Timing =  I2C_TIMING(PortNum); 
 800a526:	4b0b      	ldr	r3, [pc, #44]	; (800a554 <HW_IF_STUSB16xx_I2C_Init+0x48>)
  phi2c->Init.OwnAddress1 = 0;
 800a528:	2500      	movs	r5, #0
  phi2c->Init.Timing =  I2C_TIMING(PortNum); 
 800a52a:	6343      	str	r3, [r0, #52]	; 0x34
  phi2c->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800a52c:	2301      	movs	r3, #1
  phi2c->Init.OwnAddress1 = 0;
 800a52e:	6385      	str	r5, [r0, #56]	; 0x38
  phi2c->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800a530:	63c3      	str	r3, [r0, #60]	; 0x3c
  phi2c->Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 800a532:	6405      	str	r5, [r0, #64]	; 0x40
  phi2c->Init.OwnAddress2 = 0;
 800a534:	6445      	str	r5, [r0, #68]	; 0x44
  phi2c->Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 800a536:	6485      	str	r5, [r0, #72]	; 0x48
  phi2c->Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 800a538:	64c5      	str	r5, [r0, #76]	; 0x4c
  phi2c->Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 800a53a:	6505      	str	r5, [r0, #80]	; 0x50

  HAL_I2C_Init(phi2c);
 800a53c:	0020      	movs	r0, r4
 800a53e:	f7fd fb7d 	bl	8007c3c <HAL_I2C_Init>
  
  HAL_I2CEx_ConfigAnalogFilter(phi2c, I2C_ANALOGFILTER_ENABLE);
 800a542:	0029      	movs	r1, r5
 800a544:	0020      	movs	r0, r4
 800a546:	f7fd fd47 	bl	8007fd8 <HAL_I2CEx_ConfigAnalogFilter>
}
 800a54a:	bd70      	pop	{r4, r5, r6, pc}
 800a54c:	2000007c 	.word	0x2000007c
 800a550:	40005800 	.word	0x40005800
 800a554:	20100917 	.word	0x20100917

0800a558 <HW_IF_STUSB1602_IO_Init>:
  * @brief  Configuration of STUSB1602 GPIO pins
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_STUSB1602_IO_Init(uint8_t PortNum)
{
 800a558:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct;

  /* Configure GPIO pin : ALERT */
  GPIO_InitStruct.Pin = ALERT_GPIO_PIN(PortNum);
 800a55a:	2302      	movs	r3, #2
{
 800a55c:	b087      	sub	sp, #28
 800a55e:	1e04      	subs	r4, r0, #0
  GPIO_InitStruct.Pin = ALERT_GPIO_PIN(PortNum);
 800a560:	d000      	beq.n	800a564 <HW_IF_STUSB1602_IO_Init+0xc>
 800a562:	18db      	adds	r3, r3, r3
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(ALERT_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800a564:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a566:	2500      	movs	r5, #0
  GPIO_InitStruct.Pin = ALERT_GPIO_PIN(PortNum);
 800a568:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800a56a:	4b31      	ldr	r3, [pc, #196]	; (800a630 <HW_IF_STUSB1602_IO_Init+0xd8>)
  HAL_GPIO_Init(ALERT_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800a56c:	a901      	add	r1, sp, #4
 800a56e:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800a570:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a572:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(ALERT_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800a574:	f7fd f944 	bl	8007800 <HAL_GPIO_Init>
  
  /* Configure GPIO pin : A_B_SIDE */
  GPIO_InitStruct.Pin = A_B_Side_GPIO_PIN(PortNum);
 800a578:	2301      	movs	r3, #1
 800a57a:	42ac      	cmp	r4, r5
 800a57c:	d000      	beq.n	800a580 <HW_IF_STUSB1602_IO_Init+0x28>
 800a57e:	3307      	adds	r3, #7
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(A_B_Side_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800a580:	2090      	movs	r0, #144	; 0x90
 800a582:	a901      	add	r1, sp, #4
 800a584:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = A_B_Side_GPIO_PIN(PortNum);
 800a586:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800a588:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a58a:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(A_B_Side_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800a58c:	f7fd f938 	bl	8007800 <HAL_GPIO_Init>

  /* Configure GPIO pin : TX_EN */
  GPIO_InitStruct.Pin = TX_EN_GPIO_PIN(PortNum);
 800a590:	2304      	movs	r3, #4
 800a592:	2c00      	cmp	r4, #0
 800a594:	d000      	beq.n	800a598 <HW_IF_STUSB1602_IO_Init+0x40>
 800a596:	18db      	adds	r3, r3, r3
 800a598:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a59a:	2501      	movs	r5, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a59c:	2300      	movs	r3, #0
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(TX_EN_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800a59e:	a901      	add	r1, sp, #4
 800a5a0:	4824      	ldr	r0, [pc, #144]	; (800a634 <HW_IF_STUSB1602_IO_Init+0xdc>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a5a2:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800a5a4:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a5a6:	9502      	str	r5, [sp, #8]
  HAL_GPIO_Init(TX_EN_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800a5a8:	f7fd f92a 	bl	8007800 <HAL_GPIO_Init>
  
  /* Configure GPIO pins : RESET */
  GPIO_InitStruct.Pin = RESET_GPIO_PIN(PortNum);
 800a5ac:	2340      	movs	r3, #64	; 0x40
 800a5ae:	2c00      	cmp	r4, #0
 800a5b0:	d000      	beq.n	800a5b4 <HW_IF_STUSB1602_IO_Init+0x5c>
 800a5b2:	18db      	adds	r3, r3, r3
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(RESET_GPIO_PORT(PortNum), &GPIO_InitStruct);

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(ALERT_GPIO_IRQHANDLER(PortNum), ALERT_GPIO_IRQPRIORITY(PortNum), 0);
 800a5b4:	0026      	movs	r6, r4
  GPIO_InitStruct.Pin = RESET_GPIO_PIN(PortNum);
 800a5b6:	9301      	str	r3, [sp, #4]
  HAL_NVIC_SetPriority(ALERT_GPIO_IRQHANDLER(PortNum), ALERT_GPIO_IRQPRIORITY(PortNum), 0);
 800a5b8:	1e73      	subs	r3, r6, #1
 800a5ba:	419e      	sbcs	r6, r3
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a5bc:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a5be:	2500      	movs	r5, #0
  HAL_NVIC_SetPriority(ALERT_GPIO_IRQHANDLER(PortNum), ALERT_GPIO_IRQPRIORITY(PortNum), 0);
 800a5c0:	3605      	adds	r6, #5
  HAL_GPIO_Init(RESET_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800a5c2:	a901      	add	r1, sp, #4
 800a5c4:	481b      	ldr	r0, [pc, #108]	; (800a634 <HW_IF_STUSB1602_IO_Init+0xdc>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a5c6:	9503      	str	r5, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800a5c8:	9504      	str	r5, [sp, #16]
  HAL_GPIO_Init(RESET_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800a5ca:	f7fd f919 	bl	8007800 <HAL_GPIO_Init>
  HAL_NVIC_SetPriority(ALERT_GPIO_IRQHANDLER(PortNum), ALERT_GPIO_IRQPRIORITY(PortNum), 0);
 800a5ce:	002a      	movs	r2, r5
 800a5d0:	2101      	movs	r1, #1
 800a5d2:	0030      	movs	r0, r6
 800a5d4:	f7fc ff3a 	bl	800744c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(ALERT_GPIO_IRQHANDLER(PortNum));
 800a5d8:	0030      	movs	r0, r6
 800a5da:	f7fc ff61 	bl	80074a0 <HAL_NVIC_EnableIRQ>
 
  /* pin for ADC*/
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_4;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a5de:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_4;
 800a5e0:	2390      	movs	r3, #144	; 0x90
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800a5e2:	2603      	movs	r6, #3
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a5e4:	a901      	add	r1, sp, #4
 800a5e6:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_4;
 800a5e8:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800a5ea:	9602      	str	r6, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a5ec:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a5ee:	f7fd f907 	bl	8007800 <HAL_GPIO_Init>
  
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
 800a5f2:	2311      	movs	r3, #17
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  
  GPIO_InitStruct.Pin = GPIO_PIN_0;
 800a5f4:	2701      	movs	r7, #1
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800a5f6:	a901      	add	r1, sp, #4
 800a5f8:	480e      	ldr	r0, [pc, #56]	; (800a634 <HW_IF_STUSB1602_IO_Init+0xdc>)
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
 800a5fa:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800a5fc:	9602      	str	r6, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a5fe:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800a600:	f7fd f8fe 	bl	8007800 <HAL_GPIO_Init>
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800a604:	a901      	add	r1, sp, #4
 800a606:	480c      	ldr	r0, [pc, #48]	; (800a638 <HW_IF_STUSB1602_IO_Init+0xe0>)
  GPIO_InitStruct.Pin = GPIO_PIN_0;
 800a608:	9701      	str	r7, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800a60a:	9602      	str	r6, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a60c:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800a60e:	f7fd f8f7 	bl	8007800 <HAL_GPIO_Init>
  
  
  /* GPIO for test purposes */
  if (PortNum == 0)
 800a612:	42ac      	cmp	r4, r5
 800a614:	d10a      	bne.n	800a62c <HW_IF_STUSB1602_IO_Init+0xd4>
  {
    GPIO_InitStruct.Pin = GPIO_PIN_10 | GPIO_PIN_11;
 800a616:	23c0      	movs	r3, #192	; 0xc0
 800a618:	011b      	lsls	r3, r3, #4
 800a61a:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 800a61c:	2302      	movs	r3, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800a61e:	a901      	add	r1, sp, #4
 800a620:	4804      	ldr	r0, [pc, #16]	; (800a634 <HW_IF_STUSB1602_IO_Init+0xdc>)
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a622:	9702      	str	r7, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 800a624:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800a626:	9404      	str	r4, [sp, #16]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800a628:	f7fd f8ea 	bl	8007800 <HAL_GPIO_Init>
  }
}
 800a62c:	b007      	add	sp, #28
 800a62e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a630:	10210000 	.word	0x10210000
 800a634:	48000800 	.word	0x48000800
 800a638:	48000400 	.word	0x48000400

0800a63c <HW_IF_RESET_CTRL>:
  * @brief  STUSB16xx software reset
  * @param  PortNum The port index
  * @retval None
*/ 
void HW_IF_RESET_CTRL(uint8_t PortNum)
{
 800a63c:	b510      	push	{r4, lr}
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), SW_RST);
 800a63e:	1e44      	subs	r4, r0, #1
 800a640:	41a0      	sbcs	r0, r4
 800a642:	2101      	movs	r1, #1
 800a644:	3028      	adds	r0, #40	; 0x28
 800a646:	0004      	movs	r4, r0
 800a648:	f7fc fad3 	bl	8006bf2 <STUSB1602_SW_RESET_Set>
 800a64c:	2164      	movs	r1, #100	; 0x64
 800a64e:	46c0      	nop			; (mov r8, r8)
 800a650:	3901      	subs	r1, #1
 800a652:	b289      	uxth	r1, r1
  for(uint16_t i=0; i<100; i++)
 800a654:	2900      	cmp	r1, #0
 800a656:	d1fa      	bne.n	800a64e <HW_IF_RESET_CTRL+0x12>
  {
    __NOP();
  }  
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), No_SW_RST);
 800a658:	0020      	movs	r0, r4
 800a65a:	f7fc faca 	bl	8006bf2 <STUSB1602_SW_RESET_Set>
}
 800a65e:	bd10      	pop	{r4, pc}

0800a660 <HW_IF_RESET_Assert>:
  * @brief  Assert STUSB16xx hardware reset
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_RESET_Assert(uint8_t PortNum)
{
 800a660:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(RESET_GPIO_PORT(PortNum), RESET_GPIO_PIN(PortNum), GPIO_PIN_SET);
 800a662:	2140      	movs	r1, #64	; 0x40
 800a664:	2800      	cmp	r0, #0
 800a666:	d000      	beq.n	800a66a <HW_IF_RESET_Assert+0xa>
 800a668:	1849      	adds	r1, r1, r1
 800a66a:	2201      	movs	r2, #1
 800a66c:	4801      	ldr	r0, [pc, #4]	; (800a674 <HW_IF_RESET_Assert+0x14>)
 800a66e:	f7fd f989 	bl	8007984 <HAL_GPIO_WritePin>
}
 800a672:	bd10      	pop	{r4, pc}
 800a674:	48000800 	.word	0x48000800

0800a678 <HW_IF_RESET_Deassert>:
  * @brief  Desert STUSB16xx hardware reset
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_RESET_Deassert(uint8_t PortNum)
{
 800a678:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(RESET_GPIO_PORT(PortNum), RESET_GPIO_PIN(PortNum), GPIO_PIN_RESET);
 800a67a:	2140      	movs	r1, #64	; 0x40
 800a67c:	2800      	cmp	r0, #0
 800a67e:	d000      	beq.n	800a682 <HW_IF_RESET_Deassert+0xa>
 800a680:	1849      	adds	r1, r1, r1
 800a682:	2200      	movs	r2, #0
 800a684:	4801      	ldr	r0, [pc, #4]	; (800a68c <HW_IF_RESET_Deassert+0x14>)
 800a686:	f7fd f97d 	bl	8007984 <HAL_GPIO_WritePin>
}
 800a68a:	bd10      	pop	{r4, pc}
 800a68c:	48000800 	.word	0x48000800

0800a690 <HW_IF_RX_Enable>:
  * @retval None
  */
void HW_IF_RX_Enable(uint8_t PortNum)
{
  /* Set the port state to waiting */
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_WAITING;
 800a690:	23f0      	movs	r3, #240	; 0xf0
 800a692:	005b      	lsls	r3, r3, #1
 800a694:	4343      	muls	r3, r0
 800a696:	4805      	ldr	r0, [pc, #20]	; (800a6ac <HW_IF_RX_Enable+0x1c>)
 800a698:	18c0      	adds	r0, r0, r3
 800a69a:	2305      	movs	r3, #5
 800a69c:	7643      	strb	r3, [r0, #25]

  if (Ports[PortNum].cbs.USBPD_HW_IF_ReceiveMessage != NULL)
 800a69e:	30b9      	adds	r0, #185	; 0xb9
 800a6a0:	30ff      	adds	r0, #255	; 0xff
 800a6a2:	6803      	ldr	r3, [r0, #0]
 800a6a4:	2b00      	cmp	r3, #0
 800a6a6:	d000      	beq.n	800a6aa <HW_IF_RX_Enable+0x1a>
 800a6a8:	46c0      	nop			; (mov r8, r8)
  {
    __NOP();
  }
}
 800a6aa:	4770      	bx	lr
 800a6ac:	2000007c 	.word	0x2000007c

0800a6b0 <HW_IF_RX_Disable>:
  * @retval None
  */
void HW_IF_RX_Disable(uint8_t PortNum)
{
  /* The port is ready to transmit */
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800a6b0:	23f0      	movs	r3, #240	; 0xf0
 800a6b2:	005b      	lsls	r3, r3, #1
 800a6b4:	4343      	muls	r3, r0
 800a6b6:	4805      	ldr	r0, [pc, #20]	; (800a6cc <HW_IF_RX_Disable+0x1c>)
 800a6b8:	18c0      	adds	r0, r0, r3
 800a6ba:	2301      	movs	r3, #1
 800a6bc:	7643      	strb	r3, [r0, #25]
  
  if (Ports[PortNum].cbs.USBPD_HW_IF_ReceiveMessage != NULL)
 800a6be:	30b9      	adds	r0, #185	; 0xb9
 800a6c0:	30ff      	adds	r0, #255	; 0xff
 800a6c2:	6803      	ldr	r3, [r0, #0]
 800a6c4:	2b00      	cmp	r3, #0
 800a6c6:	d000      	beq.n	800a6ca <HW_IF_RX_Disable+0x1a>
 800a6c8:	46c0      	nop			; (mov r8, r8)
  {
    __NOP();
  }
}
 800a6ca:	4770      	bx	lr
 800a6cc:	2000007c 	.word	0x2000007c

0800a6d0 <HW_IF_Port_SetInitialRole>:
  * @param  PortNum The port index
  * @param  role
  * @retval None
  */ 
void HW_IF_Port_SetInitialRole(uint8_t PortNum,USBPD_PortPowerRole_TypeDef role)
{
 800a6d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
  
  if (USBPD_TRUE == _handle->settings->CAD_RoleToggle)
 800a6d2:	2318      	movs	r3, #24
 800a6d4:	2601      	movs	r6, #1
 800a6d6:	4343      	muls	r3, r0
 800a6d8:	4a98      	ldr	r2, [pc, #608]	; (800a93c <HW_IF_Port_SetInitialRole+0x26c>)
{
 800a6da:	000f      	movs	r7, r1
  if (USBPD_TRUE == _handle->settings->CAD_RoleToggle)
 800a6dc:	589b      	ldr	r3, [r3, r2]
 800a6de:	7a9d      	ldrb	r5, [r3, #10]
 800a6e0:	4035      	ands	r5, r6
 800a6e2:	d04a      	beq.n	800a77a <HW_IF_Port_SetInitialRole+0xaa>
    /* Dual Role */
    /*0x18*/  
#if defined(CONF_DEMO)
    STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_1_5_A);
#else
    STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 800a6e4:	1e44      	subs	r4, r0, #1
 800a6e6:	41a0      	sbcs	r0, r4
 800a6e8:	3028      	adds	r0, #40	; 0x28
 800a6ea:	0004      	movs	r4, r0
 800a6ec:	2102      	movs	r1, #2
 800a6ee:	f7fc f93b 	bl	8006968 <STUSB1602_Current_Advertised_Set>
#endif
    STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800a6f2:	0031      	movs	r1, r6
 800a6f4:	0020      	movs	r0, r4
 800a6f6:	f7fc f966 	bl	80069c6 <STUSB1602_VCONN_Discharge_Status_Set>
#ifdef _APPLI_VCONN_SUPPORT
    STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Enable_on_CC_pin);    
#else
    STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800a6fa:	2100      	movs	r1, #0
 800a6fc:	0020      	movs	r0, r4
 800a6fe:	f7fc f9aa 	bl	8006a56 <STUSB1602_VCONN_Supply_Status_Set>
#endif
    STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);    
 800a702:	2100      	movs	r1, #0
 800a704:	0020      	movs	r0, r4
 800a706:	f7fc f976 	bl	80069f6 <STUSB1602_Data_Role_Swap_Status_Set>
    STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);    
 800a70a:	2100      	movs	r1, #0
 800a70c:	0020      	movs	r0, r4
 800a70e:	f7fc f98a 	bl	8006a26 <STUSB1602_Power_Role_Swap_Status_Set>

    /*0x1E*/
    STUSB1602_VCONN_Switch_Current_Limit_Set(STUSB1602_I2C_Add(PortNum), ILIM_350_ma);
 800a712:	2100      	movs	r1, #0
 800a714:	0020      	movs	r0, r4
 800a716:	f7fc f9b4 	bl	8006a82 <STUSB1602_VCONN_Switch_Current_Limit_Set>

    /*0x1F*/
    STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), DRP_w_accessory_supp);  
 800a71a:	2103      	movs	r1, #3
 800a71c:	0020      	movs	r0, r4
 800a71e:	f7fc fae2 	bl	8006ce6 <STUSB1602_Power_Mode_Set>

    /*0x20*/
    STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800a722:	2100      	movs	r1, #0
 800a724:	0020      	movs	r0, r4
 800a726:	f7fc f9da 	bl	8006ade <STUSB1602_VCONN_Monitor_Status_Set>
    STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800a72a:	2100      	movs	r1, #0
 800a72c:	0020      	movs	r0, r4
 800a72e:	f7fc f9ed 	bl	8006b0c <STUSB1602_VCONN_UVLO_Thresh_Status_Set>

    /*0x21*/
    STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800a732:	4983      	ldr	r1, [pc, #524]	; (800a940 <HW_IF_Port_SetInitialRole+0x270>)
 800a734:	0020      	movs	r0, r4
 800a736:	f7fc fa0f 	bl	8006b58 <STUSB1602_VBUS_Select_Status_Set>

    /*0x22*/
    STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20); 
 800a73a:	2114      	movs	r1, #20
 800a73c:	0020      	movs	r0, r4
 800a73e:	f7fc fa25 	bl	8006b8c <STUSB1602_VBUS_VShift_High_Set>
    STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800a742:	2114      	movs	r1, #20
 800a744:	0020      	movs	r0, r4
 800a746:	4249      	negs	r1, r1
 800a748:	f7fc fa38 	bl	8006bbc <STUSB1602_VBUS_VShift_Low_Set>

    /*0x25*/
    STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800a74c:	2193      	movs	r1, #147	; 0x93
 800a74e:	0020      	movs	r0, r4
 800a750:	0089      	lsls	r1, r1, #2
 800a752:	f7fc fa7a 	bl	8006c4a <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
    STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800a756:	21c8      	movs	r1, #200	; 0xc8
 800a758:	0020      	movs	r0, r4
 800a75a:	f7fc fa91 	bl	8006c80 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>

    /*0x2E*/
    STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
 800a75e:	2100      	movs	r1, #0
 800a760:	0020      	movs	r0, r4
 800a762:	f7fc faef 	bl	8006d44 <STUSB1602_VDD_OVLO_Threshold_Set>

#if defined(CONF_DEMO)
    STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Disable);
#else
 //   STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
    STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Disable);
 800a766:	0031      	movs	r1, r6
 800a768:	0020      	movs	r0, r4
 800a76a:	f7fc fb03 	bl	8006d74 <STUSB1602_VBUS_Range_State_Set>
#endif

    STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V); /* default value is VBUS_vSafe0V_Thr_0_6V, VBUS_vSafe0V_Thr_1_8V */
 800a76e:	2100      	movs	r1, #0

      /*0x2E*/
      STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);

      STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V); /* default value is VBUS_vSafe0V_Thr_0_6V, VBUS_vSafe0V_Thr_1_8V */
 800a770:	0020      	movs	r0, r4
 800a772:	f7fc fb17 	bl	8006da4 <STUSB1602_VBUS_VSAFE0V_Threshold_Set>
      STUSB1602_VDD_UVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_UVLO_Disable);
 800a776:	0031      	movs	r1, r6
 800a778:	e0db      	b.n	800a932 <HW_IF_Port_SetInitialRole+0x262>
    switch (role)
 800a77a:	2900      	cmp	r1, #0
 800a77c:	d04d      	beq.n	800a81a <HW_IF_Port_SetInitialRole+0x14a>
 800a77e:	2901      	cmp	r1, #1
 800a780:	d100      	bne.n	800a784 <HW_IF_Port_SetInitialRole+0xb4>
 800a782:	e088      	b.n	800a896 <HW_IF_Port_SetInitialRole+0x1c6>
      STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 800a784:	1e44      	subs	r4, r0, #1
 800a786:	41a0      	sbcs	r0, r4
 800a788:	3028      	adds	r0, #40	; 0x28
 800a78a:	0004      	movs	r4, r0
 800a78c:	2102      	movs	r1, #2
 800a78e:	f7fc f8eb 	bl	8006968 <STUSB1602_Current_Advertised_Set>
      STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800a792:	0031      	movs	r1, r6
 800a794:	0020      	movs	r0, r4
 800a796:	f7fc f916 	bl	80069c6 <STUSB1602_VCONN_Discharge_Status_Set>
      STUSB1602_SNK_Disconnect_Mode_Status_Set(STUSB1602_I2C_Add(PortNum), VBUS_or_SRC_removed);
 800a79a:	0029      	movs	r1, r5
 800a79c:	0020      	movs	r0, r4
 800a79e:	f7fc f8fa 	bl	8006996 <STUSB1602_SNK_Disconnect_Mode_Status_Set>
      STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800a7a2:	0029      	movs	r1, r5
 800a7a4:	0020      	movs	r0, r4
 800a7a6:	f7fc f956 	bl	8006a56 <STUSB1602_VCONN_Supply_Status_Set>
      STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);
 800a7aa:	0029      	movs	r1, r5
 800a7ac:	0020      	movs	r0, r4
 800a7ae:	f7fc f922 	bl	80069f6 <STUSB1602_Data_Role_Swap_Status_Set>
      STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);
 800a7b2:	0029      	movs	r1, r5
 800a7b4:	0020      	movs	r0, r4
 800a7b6:	f7fc f936 	bl	8006a26 <STUSB1602_Power_Role_Swap_Status_Set>
      STUSB1602_VCONN_Switch_Current_Limit_Set(STUSB1602_I2C_Add(PortNum), ILIM_350_ma);
 800a7ba:	0029      	movs	r1, r5
 800a7bc:	0020      	movs	r0, r4
 800a7be:	f7fc f960 	bl	8006a82 <STUSB1602_VCONN_Switch_Current_Limit_Set>
      STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), DRP_w_accessory_supp);  
 800a7c2:	2103      	movs	r1, #3
 800a7c4:	0020      	movs	r0, r4
 800a7c6:	f7fc fa8e 	bl	8006ce6 <STUSB1602_Power_Mode_Set>
      STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800a7ca:	0029      	movs	r1, r5
 800a7cc:	0020      	movs	r0, r4
 800a7ce:	f7fc f986 	bl	8006ade <STUSB1602_VCONN_Monitor_Status_Set>
      STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800a7d2:	0029      	movs	r1, r5
 800a7d4:	0020      	movs	r0, r4
 800a7d6:	f7fc f999 	bl	8006b0c <STUSB1602_VCONN_UVLO_Thresh_Status_Set>
      STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800a7da:	4959      	ldr	r1, [pc, #356]	; (800a940 <HW_IF_Port_SetInitialRole+0x270>)
 800a7dc:	0020      	movs	r0, r4
 800a7de:	f7fc f9bb 	bl	8006b58 <STUSB1602_VBUS_Select_Status_Set>
      STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20); 
 800a7e2:	2114      	movs	r1, #20
 800a7e4:	0020      	movs	r0, r4
 800a7e6:	f7fc f9d1 	bl	8006b8c <STUSB1602_VBUS_VShift_High_Set>
      STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800a7ea:	2114      	movs	r1, #20
 800a7ec:	0020      	movs	r0, r4
 800a7ee:	4249      	negs	r1, r1
 800a7f0:	f7fc f9e4 	bl	8006bbc <STUSB1602_VBUS_VShift_Low_Set>
      STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800a7f4:	2193      	movs	r1, #147	; 0x93
 800a7f6:	0020      	movs	r0, r4
 800a7f8:	0089      	lsls	r1, r1, #2
 800a7fa:	f7fc fa26 	bl	8006c4a <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
      STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800a7fe:	21c8      	movs	r1, #200	; 0xc8
 800a800:	0020      	movs	r0, r4
 800a802:	f7fc fa3d 	bl	8006c80 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>
      STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
 800a806:	0029      	movs	r1, r5
 800a808:	0020      	movs	r0, r4
 800a80a:	f7fc fa9b 	bl	8006d44 <STUSB1602_VDD_OVLO_Threshold_Set>
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
 800a80e:	0029      	movs	r1, r5
 800a810:	0020      	movs	r0, r4
 800a812:	f7fc faaf 	bl	8006d74 <STUSB1602_VBUS_Range_State_Set>
      STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V); /* default value is VBUS_vSafe0V_Thr_0_6V, VBUS_vSafe0V_Thr_1_8V */
 800a816:	0029      	movs	r1, r5
 800a818:	e7aa      	b.n	800a770 <HW_IF_Port_SetInitialRole+0xa0>
      STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);
 800a81a:	1e44      	subs	r4, r0, #1
 800a81c:	41a0      	sbcs	r0, r4
 800a81e:	3028      	adds	r0, #40	; 0x28
 800a820:	0004      	movs	r4, r0
 800a822:	f7fc f8e8 	bl	80069f6 <STUSB1602_Data_Role_Swap_Status_Set>
      STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);
 800a826:	0039      	movs	r1, r7
 800a828:	0020      	movs	r0, r4
 800a82a:	f7fc f8fc 	bl	8006a26 <STUSB1602_Power_Role_Swap_Status_Set>
      STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800a82e:	0031      	movs	r1, r6
 800a830:	0020      	movs	r0, r4
 800a832:	f7fc f8c8 	bl	80069c6 <STUSB1602_VCONN_Discharge_Status_Set>
      STUSB1602_SNK_Disconnect_Mode_Status_Set(STUSB1602_I2C_Add(PortNum), VBUS_or_SRC_removed);
 800a836:	0039      	movs	r1, r7
 800a838:	0020      	movs	r0, r4
 800a83a:	f7fc f8ac 	bl	8006996 <STUSB1602_SNK_Disconnect_Mode_Status_Set>
      STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800a83e:	0039      	movs	r1, r7
 800a840:	0020      	movs	r0, r4
 800a842:	f7fc f908 	bl	8006a56 <STUSB1602_VCONN_Supply_Status_Set>
      STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), SNK_without_accessory_supp);  
 800a846:	2102      	movs	r1, #2
 800a848:	0020      	movs	r0, r4
 800a84a:	f7fc fa4c 	bl	8006ce6 <STUSB1602_Power_Mode_Set>
      STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800a84e:	0039      	movs	r1, r7
 800a850:	0020      	movs	r0, r4
 800a852:	f7fc f944 	bl	8006ade <STUSB1602_VCONN_Monitor_Status_Set>
      STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800a856:	0039      	movs	r1, r7
 800a858:	0020      	movs	r0, r4
 800a85a:	f7fc f957 	bl	8006b0c <STUSB1602_VCONN_UVLO_Thresh_Status_Set>
      STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800a85e:	4938      	ldr	r1, [pc, #224]	; (800a940 <HW_IF_Port_SetInitialRole+0x270>)
 800a860:	0020      	movs	r0, r4
 800a862:	f7fc f979 	bl	8006b58 <STUSB1602_VBUS_Select_Status_Set>
      STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20); 
 800a866:	2114      	movs	r1, #20
 800a868:	0020      	movs	r0, r4
 800a86a:	f7fc f98f 	bl	8006b8c <STUSB1602_VBUS_VShift_High_Set>
      STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800a86e:	2114      	movs	r1, #20
 800a870:	0020      	movs	r0, r4
 800a872:	4249      	negs	r1, r1
 800a874:	f7fc f9a2 	bl	8006bbc <STUSB1602_VBUS_VShift_Low_Set>
      STUSB1602_Pwr_Acc_Detect_Set(STUSB1602_I2C_Add(PortNum), Pwr_Acc_Detect_Disable); 
 800a878:	0039      	movs	r1, r7
 800a87a:	0020      	movs	r0, r4
 800a87c:	f7fc f9cf 	bl	8006c1e <STUSB1602_Pwr_Acc_Detect_Set>
      STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800a880:	2193      	movs	r1, #147	; 0x93
 800a882:	0020      	movs	r0, r4
 800a884:	0089      	lsls	r1, r1, #2
 800a886:	f7fc f9e0 	bl	8006c4a <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
      STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800a88a:	21c8      	movs	r1, #200	; 0xc8
 800a88c:	0020      	movs	r0, r4
 800a88e:	f7fc f9f7 	bl	8006c80 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
 800a892:	0039      	movs	r1, r7
 800a894:	e768      	b.n	800a768 <HW_IF_Port_SetInitialRole+0x98>
      STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A); /* USB_C_Current_3_A */
 800a896:	1e44      	subs	r4, r0, #1
 800a898:	41a0      	sbcs	r0, r4
 800a89a:	3028      	adds	r0, #40	; 0x28
 800a89c:	0004      	movs	r4, r0
 800a89e:	2102      	movs	r1, #2
 800a8a0:	f7fc f862 	bl	8006968 <STUSB1602_Current_Advertised_Set>
      STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800a8a4:	0039      	movs	r1, r7
 800a8a6:	0020      	movs	r0, r4
 800a8a8:	f7fc f88d 	bl	80069c6 <STUSB1602_VCONN_Discharge_Status_Set>
      STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800a8ac:	0029      	movs	r1, r5
 800a8ae:	0020      	movs	r0, r4
 800a8b0:	f7fc f8d1 	bl	8006a56 <STUSB1602_VCONN_Supply_Status_Set>
      STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);
 800a8b4:	0029      	movs	r1, r5
 800a8b6:	0020      	movs	r0, r4
 800a8b8:	f7fc f89d 	bl	80069f6 <STUSB1602_Data_Role_Swap_Status_Set>
      STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);
 800a8bc:	0029      	movs	r1, r5
 800a8be:	0020      	movs	r0, r4
 800a8c0:	f7fc f8b1 	bl	8006a26 <STUSB1602_Power_Role_Swap_Status_Set>
      STUSB1602_VCONN_Switch_Current_Limit_Set(STUSB1602_I2C_Add(PortNum), ILIM_350_ma);
 800a8c4:	0029      	movs	r1, r5
 800a8c6:	0020      	movs	r0, r4
 800a8c8:	f7fc f8db 	bl	8006a82 <STUSB1602_VCONN_Switch_Current_Limit_Set>
      STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), SRC_with_accessory_supp);  
 800a8cc:	0029      	movs	r1, r5
 800a8ce:	0020      	movs	r0, r4
 800a8d0:	f7fc fa09 	bl	8006ce6 <STUSB1602_Power_Mode_Set>
      STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800a8d4:	0029      	movs	r1, r5
 800a8d6:	0020      	movs	r0, r4
 800a8d8:	f7fc f901 	bl	8006ade <STUSB1602_VCONN_Monitor_Status_Set>
      STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800a8dc:	0029      	movs	r1, r5
 800a8de:	0020      	movs	r0, r4
 800a8e0:	f7fc f914 	bl	8006b0c <STUSB1602_VCONN_UVLO_Thresh_Status_Set>
      STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800a8e4:	4916      	ldr	r1, [pc, #88]	; (800a940 <HW_IF_Port_SetInitialRole+0x270>)
 800a8e6:	0020      	movs	r0, r4
 800a8e8:	f7fc f936 	bl	8006b58 <STUSB1602_VBUS_Select_Status_Set>
      STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20);
 800a8ec:	2114      	movs	r1, #20
 800a8ee:	0020      	movs	r0, r4
 800a8f0:	f7fc f94c 	bl	8006b8c <STUSB1602_VBUS_VShift_High_Set>
      STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800a8f4:	2114      	movs	r1, #20
 800a8f6:	0020      	movs	r0, r4
 800a8f8:	4249      	negs	r1, r1
 800a8fa:	f7fc f95f 	bl	8006bbc <STUSB1602_VBUS_VShift_Low_Set>
      STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800a8fe:	2193      	movs	r1, #147	; 0x93
 800a900:	0020      	movs	r0, r4
 800a902:	0089      	lsls	r1, r1, #2
 800a904:	f7fc f9a1 	bl	8006c4a <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
      STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800a908:	21c8      	movs	r1, #200	; 0xc8
 800a90a:	0020      	movs	r0, r4
 800a90c:	f7fc f9b8 	bl	8006c80 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>
      STUSB1602_VBUS_Discharge_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Discharge_Path_Enable); 
 800a910:	0039      	movs	r1, r7
 800a912:	0020      	movs	r0, r4
 800a914:	f7fc f9d0 	bl	8006cb8 <STUSB1602_VBUS_Discharge_State_Set>
      STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
 800a918:	0029      	movs	r1, r5
 800a91a:	0020      	movs	r0, r4
 800a91c:	f7fc fa12 	bl	8006d44 <STUSB1602_VDD_OVLO_Threshold_Set>
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
 800a920:	0029      	movs	r1, r5
 800a922:	0020      	movs	r0, r4
 800a924:	f7fc fa26 	bl	8006d74 <STUSB1602_VBUS_Range_State_Set>
      STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V);
 800a928:	0029      	movs	r1, r5
 800a92a:	0020      	movs	r0, r4
 800a92c:	f7fc fa3a 	bl	8006da4 <STUSB1602_VBUS_VSAFE0V_Threshold_Set>
      STUSB1602_VDD_UVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_UVLO_Disable);
 800a930:	0039      	movs	r1, r7
      STUSB1602_VDD_UVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_UVLO_Disable);
 800a932:	0020      	movs	r0, r4
 800a934:	f7fc fa4f 	bl	8006dd6 <STUSB1602_VDD_UVLO_Threshold_Set>
    break;
    }
  }
}
 800a938:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a93a:	46c0      	nop			; (mov r8, r8)
 800a93c:	20001bc8 	.word	0x20001bc8
 800a940:	00001388 	.word	0x00001388

0800a944 <HW_IF_check_bus_idle>:
  * @param  PortNum The port index
  * @retval USBPD_StatusTypeDef
  */
USBPD_StatusTypeDef HW_IF_check_bus_idle(uint8_t PortNum)
{
  return (((Ports[PortNum].CCx == CCNONE) || ((HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET))) ? USBPD_BUSY : USBPD_OK);
 800a944:	22f0      	movs	r2, #240	; 0xf0
 800a946:	0052      	lsls	r2, r2, #1
 800a948:	4342      	muls	r2, r0
 800a94a:	4b0c      	ldr	r3, [pc, #48]	; (800a97c <HW_IF_check_bus_idle+0x38>)
{
 800a94c:	b510      	push	{r4, lr}
  return (((Ports[PortNum].CCx == CCNONE) || ((HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET))) ? USBPD_BUSY : USBPD_OK);
 800a94e:	189b      	adds	r3, r3, r2
 800a950:	7d9b      	ldrb	r3, [r3, #22]
 800a952:	2b00      	cmp	r3, #0
 800a954:	d00a      	beq.n	800a96c <HW_IF_check_bus_idle+0x28>
 800a956:	2800      	cmp	r0, #0
 800a958:	d00b      	beq.n	800a972 <HW_IF_check_bus_idle+0x2e>
 800a95a:	2090      	movs	r0, #144	; 0x90
 800a95c:	2180      	movs	r1, #128	; 0x80
 800a95e:	05c0      	lsls	r0, r0, #23
 800a960:	0209      	lsls	r1, r1, #8
 800a962:	f7fd f809 	bl	8007978 <HAL_GPIO_ReadPin>
 800a966:	2300      	movs	r3, #0
 800a968:	4298      	cmp	r0, r3
 800a96a:	d100      	bne.n	800a96e <HW_IF_check_bus_idle+0x2a>
 800a96c:	2303      	movs	r3, #3
}
 800a96e:	0018      	movs	r0, r3
 800a970:	bd10      	pop	{r4, pc}
  return (((Ports[PortNum].CCx == CCNONE) || ((HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET))) ? USBPD_BUSY : USBPD_OK);
 800a972:	2180      	movs	r1, #128	; 0x80
 800a974:	4802      	ldr	r0, [pc, #8]	; (800a980 <HW_IF_check_bus_idle+0x3c>)
 800a976:	0149      	lsls	r1, r1, #5
 800a978:	e7f3      	b.n	800a962 <HW_IF_check_bus_idle+0x1e>
 800a97a:	46c0      	nop			; (mov r8, r8)
 800a97c:	2000007c 	.word	0x2000007c
 800a980:	48000400 	.word	0x48000400

0800a984 <HW_IF_NSS_RisingFalling_Interrupt>:
  * @param  PortNum The port index
  * @param  status Two allowed values: ENABLE or DISABLE
  * @retval None
  */ 
void HW_IF_NSS_RisingFalling_Interrupt (uint8_t PortNum ,FunctionalState status)
{
 800a984:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800a986:	0004      	movs	r4, r0
 800a988:	000d      	movs	r5, r1
  LL_EXTI_InitTypeDef EXTI_InitStruct;

  if (status == ENABLE)
 800a98a:	2901      	cmp	r1, #1
 800a98c:	d12a      	bne.n	800a9e4 <HW_IF_NSS_RisingFalling_Interrupt+0x60>
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800a98e:	2380      	movs	r3, #128	; 0x80
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800a990:	20c1      	movs	r0, #193	; 0xc1
 800a992:	2180      	movs	r1, #128	; 0x80
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800a994:	4a20      	ldr	r2, [pc, #128]	; (800aa18 <HW_IF_NSS_RisingFalling_Interrupt+0x94>)
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800a996:	0080      	lsls	r0, r0, #2
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800a998:	6013      	str	r3, [r2, #0]
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800a99a:	5813      	ldr	r3, [r2, r0]
 800a99c:	0609      	lsls	r1, r1, #24
 800a99e:	021b      	lsls	r3, r3, #8
 800a9a0:	0a1b      	lsrs	r3, r3, #8
 800a9a2:	430b      	orrs	r3, r1
 800a9a4:	5013      	str	r3, [r2, r0]
    /* NVIC configuration*/
    NVIC_EnableIRQ(SPI_NSS_LL_IRQHANDLER(PortNum));
    NVIC_SetPriority(SPI_NSS_LL_IRQHANDLER(PortNum),SPI_NSS_LL_IRQPRIORITY(PortNum));

    /* External Line initialization */
    LL_APB1_GRP2_EnableClock(SPI_NSS_LL_APB(PortNum));
 800a9a6:	f7ff fc7d 	bl	800a2a4 <LL_APB1_GRP2_EnableClock.constprop.7>
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800a9aa:	2c00      	cmp	r4, #0
 800a9ac:	d117      	bne.n	800a9de <HW_IF_NSS_RisingFalling_Interrupt+0x5a>
 800a9ae:	0028      	movs	r0, r5
 800a9b0:	2103      	movs	r1, #3

    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800a9b2:	4263      	negs	r3, r4
 800a9b4:	415c      	adcs	r4, r3
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800a9b6:	f7ff fc37 	bl	800a228 <LL_SYSCFG_SetEXTISource>
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800a9ba:	4b18      	ldr	r3, [pc, #96]	; (800aa1c <HW_IF_NSS_RisingFalling_Interrupt+0x98>)
 800a9bc:	4264      	negs	r4, r4
 800a9be:	401c      	ands	r4, r3
 800a9c0:	2380      	movs	r3, #128	; 0x80
 800a9c2:	021b      	lsls	r3, r3, #8
 800a9c4:	18e4      	adds	r4, r4, r3
    EXTI_InitStruct.LineCommand = ENABLE;
 800a9c6:	466a      	mov	r2, sp
 800a9c8:	2301      	movs	r3, #1
 800a9ca:	7113      	strb	r3, [r2, #4]
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 800a9cc:	2300      	movs	r3, #0
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800a9ce:	9400      	str	r4, [sp, #0]
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 800a9d0:	7153      	strb	r3, [r2, #5]
    EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_RISING_FALLING;
 800a9d2:	3303      	adds	r3, #3
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));

    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
    EXTI_InitStruct.LineCommand = DISABLE;
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
    EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_NONE;
 800a9d4:	7193      	strb	r3, [r2, #6]
    LL_EXTI_Init(&EXTI_InitStruct);
 800a9d6:	4668      	mov	r0, sp
 800a9d8:	f7fe fa90 	bl	8008efc <LL_EXTI_Init>
  }  
}
 800a9dc:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800a9de:	2000      	movs	r0, #0
 800a9e0:	490f      	ldr	r1, [pc, #60]	; (800aa20 <HW_IF_NSS_RisingFalling_Interrupt+0x9c>)
 800a9e2:	e7e6      	b.n	800a9b2 <HW_IF_NSS_RisingFalling_Interrupt+0x2e>
  *         (*) value not defined in all devices.
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP2_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB2ENR, Periphs);
 800a9e4:	2001      	movs	r0, #1
 800a9e6:	4a0f      	ldr	r2, [pc, #60]	; (800aa24 <HW_IF_NSS_RisingFalling_Interrupt+0xa0>)
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800a9e8:	2103      	movs	r1, #3
 800a9ea:	6993      	ldr	r3, [r2, #24]
 800a9ec:	4383      	bics	r3, r0
 800a9ee:	6193      	str	r3, [r2, #24]
 800a9f0:	2c00      	cmp	r4, #0
 800a9f2:	d001      	beq.n	800a9f8 <HW_IF_NSS_RisingFalling_Interrupt+0x74>
 800a9f4:	2000      	movs	r0, #0
 800a9f6:	490a      	ldr	r1, [pc, #40]	; (800aa20 <HW_IF_NSS_RisingFalling_Interrupt+0x9c>)
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800a9f8:	4263      	negs	r3, r4
 800a9fa:	415c      	adcs	r4, r3
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800a9fc:	f7ff fc14 	bl	800a228 <LL_SYSCFG_SetEXTISource>
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800aa00:	4b06      	ldr	r3, [pc, #24]	; (800aa1c <HW_IF_NSS_RisingFalling_Interrupt+0x98>)
 800aa02:	4264      	negs	r4, r4
 800aa04:	401c      	ands	r4, r3
 800aa06:	2380      	movs	r3, #128	; 0x80
 800aa08:	021b      	lsls	r3, r3, #8
 800aa0a:	18e4      	adds	r4, r4, r3
    EXTI_InitStruct.LineCommand = DISABLE;
 800aa0c:	466a      	mov	r2, sp
 800aa0e:	2300      	movs	r3, #0
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800aa10:	9400      	str	r4, [sp, #0]
    EXTI_InitStruct.LineCommand = DISABLE;
 800aa12:	7113      	strb	r3, [r2, #4]
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 800aa14:	7153      	strb	r3, [r2, #5]
 800aa16:	e7dd      	b.n	800a9d4 <HW_IF_NSS_RisingFalling_Interrupt+0x50>
 800aa18:	e000e100 	.word	0xe000e100
 800aa1c:	ffff9000 	.word	0xffff9000
 800aa20:	000c0003 	.word	0x000c0003
 800aa24:	40021000 	.word	0x40021000

0800aa28 <HW_IF_COUNTER_TIM_Init>:
  * @brief  Initialization of counter
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_COUNTER_TIM_Init(uint8_t PortNum)
{
 800aa28:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Get the peripheral handler variable */
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800aa2a:	25f0      	movs	r5, #240	; 0xf0
 800aa2c:	006d      	lsls	r5, r5, #1
 800aa2e:	4345      	muls	r5, r0
 800aa30:	4b25      	ldr	r3, [pc, #148]	; (800aac8 <HW_IF_COUNTER_TIM_Init+0xa0>)
  
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig;
  TIM_OC_InitTypeDef sConfigOC;
  
  htimcountrx->Instance =                       RX_COUNTTIM(PortNum);
 800aa32:	4242      	negs	r2, r0
 800aa34:	4150      	adcs	r0, r2
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800aa36:	002e      	movs	r6, r5
  htimcountrx->Instance =                       RX_COUNTTIM(PortNum);
 800aa38:	195d      	adds	r5, r3, r5
 800aa3a:	002f      	movs	r7, r5
 800aa3c:	4a23      	ldr	r2, [pc, #140]	; (800aacc <HW_IF_COUNTER_TIM_Init+0xa4>)
 800aa3e:	4240      	negs	r0, r0
 800aa40:	0280      	lsls	r0, r0, #10
 800aa42:	1880      	adds	r0, r0, r2
 800aa44:	37fc      	adds	r7, #252	; 0xfc
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800aa46:	3679      	adds	r6, #121	; 0x79
{
 800aa48:	b08f      	sub	sp, #60	; 0x3c
  htimcountrx->Instance =                       RX_COUNTTIM(PortNum);
 800aa4a:	67f8      	str	r0, [r7, #124]	; 0x7c
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800aa4c:	36ff      	adds	r6, #255	; 0xff
 800aa4e:	18f6      	adds	r6, r6, r3
  htimcountrx->Init.Prescaler =                 ( HAL_RCC_GetHCLKFreq() / 1000000 ) - 1; // 1us Resolution
 800aa50:	002c      	movs	r4, r5
 800aa52:	f7fd fae7 	bl	8008024 <HAL_RCC_GetHCLKFreq>
 800aa56:	491e      	ldr	r1, [pc, #120]	; (800aad0 <HW_IF_COUNTER_TIM_Init+0xa8>)
 800aa58:	f7fa ffac 	bl	80059b4 <__udivsi3>
 800aa5c:	347d      	adds	r4, #125	; 0x7d
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800aa5e:	002b      	movs	r3, r5
  htimcountrx->Init.Prescaler =                 ( HAL_RCC_GetHCLKFreq() / 1000000 ) - 1; // 1us Resolution
 800aa60:	34ff      	adds	r4, #255	; 0xff
 800aa62:	3801      	subs	r0, #1
  htimcountrx->Init.Period =                    DMA_TIME_ELAPSED;
 800aa64:	223c      	movs	r2, #60	; 0x3c
  htimcountrx->Init.Prescaler =                 ( HAL_RCC_GetHCLKFreq() / 1000000 ) - 1; // 1us Resolution
 800aa66:	6020      	str	r0, [r4, #0]
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800aa68:	2400      	movs	r4, #0
 800aa6a:	3381      	adds	r3, #129	; 0x81
  htimcountrx->Init.ClockDivision =             TIM_CLOCKDIVISION_DIV1;
  htimcountrx->Init.RepetitionCounter =         0;
 800aa6c:	358d      	adds	r5, #141	; 0x8d
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800aa6e:	33ff      	adds	r3, #255	; 0xff
  htimcountrx->Init.RepetitionCounter =         0;
 800aa70:	35ff      	adds	r5, #255	; 0xff
  htimcountrx->Init.Period =                    DMA_TIME_ELAPSED;
 800aa72:	605a      	str	r2, [r3, #4]
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800aa74:	601c      	str	r4, [r3, #0]
  htimcountrx->Init.ClockDivision =             TIM_CLOCKDIVISION_DIV1;
 800aa76:	609c      	str	r4, [r3, #8]
  htimcountrx->Init.RepetitionCounter =         0;
 800aa78:	602c      	str	r4, [r5, #0]
  HAL_TIM_Base_Init(htimcountrx);
 800aa7a:	0030      	movs	r0, r6
 800aa7c:	f7fe f8bc 	bl	8008bf8 <HAL_TIM_Base_Init>
  
  HAL_TIM_OC_Init(htimcountrx);
 800aa80:	0030      	movs	r0, r6
 800aa82:	f7fe f8d4 	bl	8008c2e <HAL_TIM_OC_Init>
  sBreakDeadTimeConfig.OffStateRunMode =        TIM_OSSR_DISABLE;
  sBreakDeadTimeConfig.OffStateIDLEMode =       TIM_OSSI_DISABLE;
  sBreakDeadTimeConfig.LockLevel =              TIM_LOCKLEVEL_OFF;
  sBreakDeadTimeConfig.DeadTime =               0;
  sBreakDeadTimeConfig.BreakState =             TIM_BREAK_DISABLE;
  sBreakDeadTimeConfig.BreakPolarity =          TIM_BREAKPOLARITY_HIGH;
 800aa86:	2380      	movs	r3, #128	; 0x80
  sBreakDeadTimeConfig.AutomaticOutput =        TIM_AUTOMATICOUTPUT_DISABLE;
  HAL_TIMEx_ConfigBreakDeadTime(htimcountrx, &sBreakDeadTimeConfig);
 800aa88:	4669      	mov	r1, sp
  sBreakDeadTimeConfig.BreakPolarity =          TIM_BREAKPOLARITY_HIGH;
 800aa8a:	019b      	lsls	r3, r3, #6
  HAL_TIMEx_ConfigBreakDeadTime(htimcountrx, &sBreakDeadTimeConfig);
 800aa8c:	0030      	movs	r0, r6
  sBreakDeadTimeConfig.BreakPolarity =          TIM_BREAKPOLARITY_HIGH;
 800aa8e:	9305      	str	r3, [sp, #20]
  sBreakDeadTimeConfig.OffStateRunMode =        TIM_OSSR_DISABLE;
 800aa90:	9400      	str	r4, [sp, #0]
  sBreakDeadTimeConfig.OffStateIDLEMode =       TIM_OSSI_DISABLE;
 800aa92:	9401      	str	r4, [sp, #4]
  sBreakDeadTimeConfig.LockLevel =              TIM_LOCKLEVEL_OFF;
 800aa94:	9402      	str	r4, [sp, #8]
  sBreakDeadTimeConfig.DeadTime =               0;
 800aa96:	9403      	str	r4, [sp, #12]
  sBreakDeadTimeConfig.BreakState =             TIM_BREAK_DISABLE;
 800aa98:	9404      	str	r4, [sp, #16]
  sBreakDeadTimeConfig.AutomaticOutput =        TIM_AUTOMATICOUTPUT_DISABLE;
 800aa9a:	9406      	str	r4, [sp, #24]
  HAL_TIMEx_ConfigBreakDeadTime(htimcountrx, &sBreakDeadTimeConfig);
 800aa9c:	f7fe f9f0 	bl	8008e80 <HAL_TIMEx_ConfigBreakDeadTime>
  
  sConfigOC.OCMode =                            TIM_OCMODE_TIMING;
  sConfigOC.Pulse =                             DMA_TIME_COUNT_COMPARE;
 800aaa0:	230a      	movs	r3, #10
  sConfigOC.OCPolarity =                        TIM_OCPOLARITY_HIGH;
  sConfigOC.OCNPolarity =                       TIM_OCNPOLARITY_HIGH;
  sConfigOC.OCFastMode =                        TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState =                       TIM_OCIDLESTATE_RESET;
  sConfigOC.OCNIdleState =                      TIM_OCNIDLESTATE_RESET;
  HAL_TIM_OC_ConfigChannel(htimcountrx, &sConfigOC, RX_COUNTTIMCH(PortNum));
 800aaa2:	0022      	movs	r2, r4
 800aaa4:	a907      	add	r1, sp, #28
 800aaa6:	0030      	movs	r0, r6
  sConfigOC.Pulse =                             DMA_TIME_COUNT_COMPARE;
 800aaa8:	9308      	str	r3, [sp, #32]
  sConfigOC.OCMode =                            TIM_OCMODE_TIMING;
 800aaaa:	9407      	str	r4, [sp, #28]
  sConfigOC.OCPolarity =                        TIM_OCPOLARITY_HIGH;
 800aaac:	9409      	str	r4, [sp, #36]	; 0x24
  sConfigOC.OCNPolarity =                       TIM_OCNPOLARITY_HIGH;
 800aaae:	940a      	str	r4, [sp, #40]	; 0x28
  sConfigOC.OCFastMode =                        TIM_OCFAST_DISABLE;
 800aab0:	940b      	str	r4, [sp, #44]	; 0x2c
  sConfigOC.OCIdleState =                       TIM_OCIDLESTATE_RESET;
 800aab2:	940c      	str	r4, [sp, #48]	; 0x30
  sConfigOC.OCNIdleState =                      TIM_OCNIDLESTATE_RESET;
 800aab4:	940d      	str	r4, [sp, #52]	; 0x34
  HAL_TIM_OC_ConfigChannel(htimcountrx, &sConfigOC, RX_COUNTTIMCH(PortNum));
 800aab6:	f7fe f915 	bl	8008ce4 <HAL_TIM_OC_ConfigChannel>
  
  __HAL_TIM_CLEAR_IT(htimcountrx, TIM_IT_UPDATE);
 800aaba:	2202      	movs	r2, #2
 800aabc:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800aabe:	4252      	negs	r2, r2
 800aac0:	611a      	str	r2, [r3, #16]
}
 800aac2:	b00f      	add	sp, #60	; 0x3c
 800aac4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800aac6:	46c0      	nop			; (mov r8, r8)
 800aac8:	2000007c 	.word	0x2000007c
 800aacc:	40014800 	.word	0x40014800
 800aad0:	000f4240 	.word	0x000f4240

0800aad4 <STUSB16xx_HW_IF_TX_DMA_Init>:
  * @brief  Initialization of DMA for transmission
  * @param  PortNum The port index
  * @retval None
  */ 
void STUSB16xx_HW_IF_TX_DMA_Init(uint8_t PortNum)
{
 800aad4:	23f0      	movs	r3, #240	; 0xf0
 800aad6:	005b      	lsls	r3, r3, #1
 800aad8:	4343      	muls	r3, r0
 800aada:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800aadc:	001e      	movs	r6, r3
 800aade:	9301      	str	r3, [sp, #4]
  
  /* Set the DMA handler of the peripheral handler */
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800aae0:	9a01      	ldr	r2, [sp, #4]
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800aae2:	4b18      	ldr	r3, [pc, #96]	; (800ab44 <STUSB16xx_HW_IF_TX_DMA_Init+0x70>)
 800aae4:	36a4      	adds	r6, #164	; 0xa4
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800aae6:	189c      	adds	r4, r3, r2
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800aae8:	18f6      	adds	r6, r6, r3
  
  /* Peripheral DMA init*/
  hdma_tx_spi->Instance =                   TX_DMACH(PortNum);
 800aaea:	0003      	movs	r3, r0
 800aaec:	1e5a      	subs	r2, r3, #1
 800aaee:	4193      	sbcs	r3, r2
 800aaf0:	2227      	movs	r2, #39	; 0x27
 800aaf2:	425b      	negs	r3, r3
 800aaf4:	4393      	bics	r3, r2
 800aaf6:	4a14      	ldr	r2, [pc, #80]	; (800ab48 <STUSB16xx_HW_IF_TX_DMA_Init+0x74>)
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800aaf8:	0027      	movs	r7, r4
  hdma_tx_spi->Instance =                   TX_DMACH(PortNum);
 800aafa:	189b      	adds	r3, r3, r2
 800aafc:	0022      	movs	r2, r4
 800aafe:	32a4      	adds	r2, #164	; 0xa4
 800ab00:	6013      	str	r3, [r2, #0]
  hdma_tx_spi->Init.Direction =             DMA_MEMORY_TO_PERIPH;
 800ab02:	0023      	movs	r3, r4
 800ab04:	2210      	movs	r2, #16
 800ab06:	33a8      	adds	r3, #168	; 0xa8
 800ab08:	601a      	str	r2, [r3, #0]
  hdma_tx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800ab0a:	0022      	movs	r2, r4
 800ab0c:	2300      	movs	r3, #0
  hdma_tx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800ab0e:	2180      	movs	r1, #128	; 0x80
{
 800ab10:	0005      	movs	r5, r0
  hdma_tx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800ab12:	32ac      	adds	r2, #172	; 0xac
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800ab14:	3794      	adds	r7, #148	; 0x94
 800ab16:	603e      	str	r6, [r7, #0]
  hdma_tx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800ab18:	6051      	str	r1, [r2, #4]
  hdma_tx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800ab1a:	6013      	str	r3, [r2, #0]
  hdma_tx_spi->Init.PeriphDataAlignment =   DMA_PDATAALIGN_BYTE;
 800ab1c:	6093      	str	r3, [r2, #8]
  hdma_tx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800ab1e:	60d3      	str	r3, [r2, #12]
  hdma_tx_spi->Init.Mode =                  DMA_NORMAL;
 800ab20:	6113      	str	r3, [r2, #16]
  hdma_tx_spi->Init.Priority =              DMACHIRQ_PRIO(PortNum);
 800ab22:	6153      	str	r3, [r2, #20]
  HAL_DMA_Init(hdma_tx_spi);
 800ab24:	0030      	movs	r0, r6
 800ab26:	f7fc fdbd 	bl	80076a4 <HAL_DMA_Init>
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
  
  /* Enable IRQ DMA */
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800ab2a:	4268      	negs	r0, r5
 800ab2c:	4168      	adcs	r0, r5
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800ab2e:	9b01      	ldr	r3, [sp, #4]
 800ab30:	4a04      	ldr	r2, [pc, #16]	; (800ab44 <STUSB16xx_HW_IF_TX_DMA_Init+0x70>)
 800ab32:	3340      	adds	r3, #64	; 0x40
 800ab34:	18d3      	adds	r3, r2, r3
 800ab36:	34c8      	adds	r4, #200	; 0xc8
 800ab38:	603e      	str	r6, [r7, #0]
 800ab3a:	6023      	str	r3, [r4, #0]
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800ab3c:	300a      	adds	r0, #10
 800ab3e:	f7fc fcaf 	bl	80074a0 <HAL_NVIC_EnableIRQ>
}
 800ab42:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800ab44:	2000007c 	.word	0x2000007c
 800ab48:	40020058 	.word	0x40020058

0800ab4c <STUSB16xx_HW_IF_RX_DMA_Init>:
  * @brief  Initialization DMA for reception
  * @param  PortNum The port index
  * @retval None
  */ 
void STUSB16xx_HW_IF_RX_DMA_Init(uint8_t PortNum)
{
 800ab4c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800ab4e:	26f0      	movs	r6, #240	; 0xf0
 800ab50:	0076      	lsls	r6, r6, #1
 800ab52:	4346      	muls	r6, r0
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_rx_spi = &(Ports[PortNum].hdmarx);
 800ab54:	0033      	movs	r3, r6
 800ab56:	4a17      	ldr	r2, [pc, #92]	; (800abb4 <STUSB16xx_HW_IF_RX_DMA_Init+0x68>)
 800ab58:	33e8      	adds	r3, #232	; 0xe8
 800ab5a:	189b      	adds	r3, r3, r2
 800ab5c:	9301      	str	r3, [sp, #4]
 
  /* Peripheral DMA init*/
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800ab5e:	0003      	movs	r3, r0
 800ab60:	1e5a      	subs	r2, r3, #1
 800ab62:	4193      	sbcs	r3, r2
 800ab64:	2227      	movs	r2, #39	; 0x27
 800ab66:	425b      	negs	r3, r3
 800ab68:	4393      	bics	r3, r2
 800ab6a:	4a13      	ldr	r2, [pc, #76]	; (800abb8 <STUSB16xx_HW_IF_RX_DMA_Init+0x6c>)
  hdma_rx_spi->Init.Direction =             DMA_PERIPH_TO_MEMORY;
  hdma_rx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
  hdma_rx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800ab6c:	2180      	movs	r1, #128	; 0x80
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800ab6e:	189b      	adds	r3, r3, r2
 800ab70:	4a10      	ldr	r2, [pc, #64]	; (800abb4 <STUSB16xx_HW_IF_RX_DMA_Init+0x68>)
{
 800ab72:	0005      	movs	r5, r0
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800ab74:	1994      	adds	r4, r2, r6
 800ab76:	0022      	movs	r2, r4
  hdma_rx_spi->Init.PeriphDataAlignment =   DMA_PDATAALIGN_BYTE;
  hdma_rx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800ab78:	0027      	movs	r7, r4
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800ab7a:	32e8      	adds	r2, #232	; 0xe8
 800ab7c:	6013      	str	r3, [r2, #0]
  hdma_rx_spi->Init.Direction =             DMA_PERIPH_TO_MEMORY;
 800ab7e:	2300      	movs	r3, #0
  hdma_rx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800ab80:	37fc      	adds	r7, #252	; 0xfc
  hdma_rx_spi->Init.Direction =             DMA_PERIPH_TO_MEMORY;
 800ab82:	6053      	str	r3, [r2, #4]
  hdma_rx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800ab84:	6093      	str	r3, [r2, #8]
  hdma_rx_spi->Init.PeriphDataAlignment =   DMA_PDATAALIGN_BYTE;
 800ab86:	6113      	str	r3, [r2, #16]
  hdma_rx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800ab88:	603b      	str	r3, [r7, #0]
  hdma_rx_spi->Init.Mode =                  DMA_NORMAL;
 800ab8a:	607b      	str	r3, [r7, #4]
  hdma_rx_spi->Init.Priority =              DMA_PRIORITY_VERY_HIGH;
 800ab8c:	23c0      	movs	r3, #192	; 0xc0
 800ab8e:	019b      	lsls	r3, r3, #6
 800ab90:	60bb      	str	r3, [r7, #8]
  hdma_rx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800ab92:	60d1      	str	r1, [r2, #12]
  HAL_DMA_Init(hdma_rx_spi);
 800ab94:	9801      	ldr	r0, [sp, #4]
 800ab96:	f7fc fd85 	bl	80076a4 <HAL_DMA_Init>
  Ports[PortNum].hspi.hdmarx = hdma_rx_spi; 
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmarx,(*hdma_rx_spi));

  /* Enable IRQ DMA */
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800ab9a:	4268      	negs	r0, r5
 800ab9c:	4168      	adcs	r0, r5
  Ports[PortNum].hspi.hdmarx = hdma_rx_spi; 
 800ab9e:	9b01      	ldr	r3, [sp, #4]
 800aba0:	3498      	adds	r4, #152	; 0x98
 800aba2:	6023      	str	r3, [r4, #0]
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmarx,(*hdma_rx_spi));
 800aba4:	4b03      	ldr	r3, [pc, #12]	; (800abb4 <STUSB16xx_HW_IF_RX_DMA_Init+0x68>)
 800aba6:	3640      	adds	r6, #64	; 0x40
 800aba8:	199e      	adds	r6, r3, r6
 800abaa:	613e      	str	r6, [r7, #16]
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800abac:	300a      	adds	r0, #10
 800abae:	f7fc fc77 	bl	80074a0 <HAL_NVIC_EnableIRQ>
  
}
 800abb2:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800abb4:	2000007c 	.word	0x2000007c
 800abb8:	40020044 	.word	0x40020044

0800abbc <STUSB16xx_HW_IF_Set_DMA_Normal_Mode>:
  * @brief  It switches SPI DMA in normal mode
  * @param  PortNum The port index
  * @retval None
  */
void STUSB16xx_HW_IF_Set_DMA_Normal_Mode(uint8_t PortNum)
{
 800abbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800abbe:	24f0      	movs	r4, #240	; 0xf0
 800abc0:	0064      	lsls	r4, r4, #1
 800abc2:	4344      	muls	r4, r0
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800abc4:	4e09      	ldr	r6, [pc, #36]	; (800abec <STUSB16xx_HW_IF_Set_DMA_Normal_Mode+0x30>)
 800abc6:	0027      	movs	r7, r4
  
  hdma_tx_spi->Init.Mode =                  DMA_NORMAL;
 800abc8:	1935      	adds	r5, r6, r4
 800abca:	002b      	movs	r3, r5
 800abcc:	2200      	movs	r2, #0
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800abce:	37a4      	adds	r7, #164	; 0xa4
 800abd0:	19bf      	adds	r7, r7, r6
  hdma_tx_spi->Init.Mode =                  DMA_NORMAL;
 800abd2:	33bc      	adds	r3, #188	; 0xbc
 800abd4:	601a      	str	r2, [r3, #0]
  HAL_DMA_Init(hdma_tx_spi);
 800abd6:	0038      	movs	r0, r7
 800abd8:	f7fc fd64 	bl	80076a4 <HAL_DMA_Init>
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800abdc:	002b      	movs	r3, r5
 800abde:	3440      	adds	r4, #64	; 0x40
 800abe0:	35c8      	adds	r5, #200	; 0xc8
 800abe2:	19a4      	adds	r4, r4, r6
 800abe4:	3394      	adds	r3, #148	; 0x94
 800abe6:	601f      	str	r7, [r3, #0]
 800abe8:	602c      	str	r4, [r5, #0]
}
 800abea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800abec:	2000007c 	.word	0x2000007c

0800abf0 <STUSB16xx_HW_IF_Set_DMA_Circular_Mode>:
  * @brief  It switches SPI DMA in circular mode
  * @param  PortNum The port index
  * @retval None
  */
void STUSB16xx_HW_IF_Set_DMA_Circular_Mode(uint8_t PortNum)
{
 800abf0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800abf2:	24f0      	movs	r4, #240	; 0xf0
 800abf4:	0064      	lsls	r4, r4, #1
 800abf6:	4344      	muls	r4, r0
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800abf8:	0023      	movs	r3, r4
 800abfa:	4f0e      	ldr	r7, [pc, #56]	; (800ac34 <STUSB16xx_HW_IF_Set_DMA_Circular_Mode+0x44>)
 800abfc:	33a4      	adds	r3, #164	; 0xa4
  
  hdma_tx_spi->Init.Mode =                  DMA_CIRCULAR;
 800abfe:	193e      	adds	r6, r7, r4
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800ac00:	19db      	adds	r3, r3, r7
 800ac02:	9301      	str	r3, [sp, #4]
  hdma_tx_spi->Init.Mode =                  DMA_CIRCULAR;
 800ac04:	0033      	movs	r3, r6
 800ac06:	2220      	movs	r2, #32
 800ac08:	33bc      	adds	r3, #188	; 0xbc
{
 800ac0a:	0005      	movs	r5, r0
  hdma_tx_spi->Init.Mode =                  DMA_CIRCULAR;
 800ac0c:	601a      	str	r2, [r3, #0]
  HAL_DMA_Init(hdma_tx_spi);
 800ac0e:	9801      	ldr	r0, [sp, #4]
 800ac10:	f7fc fd48 	bl	80076a4 <HAL_DMA_Init>
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800ac14:	0033      	movs	r3, r6
 800ac16:	9a01      	ldr	r2, [sp, #4]
 800ac18:	3394      	adds	r3, #148	; 0x94
 800ac1a:	601a      	str	r2, [r3, #0]
  
  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800ac1c:	4268      	negs	r0, r5
 800ac1e:	4168      	adcs	r0, r5
 800ac20:	2200      	movs	r2, #0
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800ac22:	3440      	adds	r4, #64	; 0x40
 800ac24:	36c8      	adds	r6, #200	; 0xc8
 800ac26:	19e7      	adds	r7, r4, r7
 800ac28:	6037      	str	r7, [r6, #0]
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800ac2a:	300a      	adds	r0, #10
 800ac2c:	0011      	movs	r1, r2
 800ac2e:	f7fc fc0d 	bl	800744c <HAL_NVIC_SetPriority>
}
 800ac32:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800ac34:	2000007c 	.word	0x2000007c

0800ac38 <STUSB16xx_HW_IF_Switch_Mode>:
  * @param  PortNum The port index
  * @param  mode Two allowed values:  STUSB16xx_SPI_Mode_TX or STUSB16xx_SPI_Mode_RX
  * @retval None
  */ 
void STUSB16xx_HW_IF_Switch_Mode(uint8_t PortNum, STUSB1602_SPI_Mode_TypeDef mode)
{
 800ac38:	b570      	push	{r4, r5, r6, lr}
 800ac3a:	000c      	movs	r4, r1

  /* Set the data sampling edge according to mode */
  HW_IF_SPI_Mode(PortNum, mode);  
  
  /* Enable/Disable RX NSS EXT Interrupt */
  HW_IF_NSS_RisingFalling_Interrupt (PortNum, mode == STUSB16xx_SPI_Mode_RX ? ENABLE : DISABLE);
 800ac3c:	3c01      	subs	r4, #1
{
 800ac3e:	0005      	movs	r5, r0
  HW_IF_SPI_Mode(PortNum, mode);  
 800ac40:	f7ff fc08 	bl	800a454 <HW_IF_SPI_Mode>
  HW_IF_NSS_RisingFalling_Interrupt (PortNum, mode == STUSB16xx_SPI_Mode_RX ? ENABLE : DISABLE);
 800ac44:	4261      	negs	r1, r4
 800ac46:	4161      	adcs	r1, r4
 800ac48:	0028      	movs	r0, r5
 800ac4a:	b2c9      	uxtb	r1, r1
 800ac4c:	f7ff fe9a 	bl	800a984 <HW_IF_NSS_RisingFalling_Interrupt>
}
 800ac50:	bd70      	pop	{r4, r5, r6, pc}
	...

0800ac54 <STUSB16xx_HW_IF_TX_EN_Status>:
  * @param  PortNum The port index
  * @param  status Two allowed values: GPIO_PIN_SET or GPIO_PIN_RESET
  * @retval None
  */ 
void STUSB16xx_HW_IF_TX_EN_Status(uint8_t PortNum, GPIO_PinState status)
{
 800ac54:	000a      	movs	r2, r1
 800ac56:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(TX_EN_GPIO_PORT(PortNum), TX_EN_GPIO_PIN(PortNum), status);
 800ac58:	2104      	movs	r1, #4
 800ac5a:	2800      	cmp	r0, #0
 800ac5c:	d000      	beq.n	800ac60 <STUSB16xx_HW_IF_TX_EN_Status+0xc>
 800ac5e:	1849      	adds	r1, r1, r1
 800ac60:	4801      	ldr	r0, [pc, #4]	; (800ac68 <STUSB16xx_HW_IF_TX_EN_Status+0x14>)
 800ac62:	f7fc fe8f 	bl	8007984 <HAL_GPIO_WritePin>
}
 800ac66:	bd10      	pop	{r4, pc}
 800ac68:	48000800 	.word	0x48000800

0800ac6c <HW_IF_STUSB16xx_Reset>:
{
 800ac6c:	b570      	push	{r4, r5, r6, lr}
 800ac6e:	0005      	movs	r5, r0
  HW_IF_RESET_Assert(PortNum);
 800ac70:	2478      	movs	r4, #120	; 0x78
 800ac72:	f7ff fcf5 	bl	800a660 <HW_IF_RESET_Assert>
 800ac76:	46c0      	nop			; (mov r8, r8)
 800ac78:	3c01      	subs	r4, #1
 800ac7a:	b2a4      	uxth	r4, r4
  for(uint16_t i=0;i<120;i++) 
 800ac7c:	2c00      	cmp	r4, #0
 800ac7e:	d1fa      	bne.n	800ac76 <HW_IF_STUSB16xx_Reset+0xa>
  HW_IF_RESET_Deassert(PortNum);
 800ac80:	0028      	movs	r0, r5
 800ac82:	f7ff fcf9 	bl	800a678 <HW_IF_RESET_Deassert>
  STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_RESET);
 800ac86:	0028      	movs	r0, r5
 800ac88:	0021      	movs	r1, r4
 800ac8a:	f7ff ffe3 	bl	800ac54 <STUSB16xx_HW_IF_TX_EN_Status>
}
 800ac8e:	bd70      	pop	{r4, r5, r6, pc}

0800ac90 <USBPD_HW_IF_PortHwInit>:
{
 800ac90:	b084      	sub	sp, #16
 800ac92:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ac94:	b093      	sub	sp, #76	; 0x4c
 800ac96:	ac19      	add	r4, sp, #100	; 0x64
 800ac98:	60a3      	str	r3, [r4, #8]
 800ac9a:	ab1f      	add	r3, sp, #124	; 0x7c
 800ac9c:	781b      	ldrb	r3, [r3, #0]
 800ac9e:	0005      	movs	r5, r0
 800aca0:	9311      	str	r3, [sp, #68]	; 0x44
  nvm_read = 0;
 800aca2:	2300      	movs	r3, #0
 800aca4:	4f2e      	ldr	r7, [pc, #184]	; (800ad60 <USBPD_HW_IF_PortHwInit+0xd0>)
{
 800aca6:	9119      	str	r1, [sp, #100]	; 0x64
 800aca8:	6062      	str	r2, [r4, #4]
  nvm_read = 0;
 800acaa:	703b      	strb	r3, [r7, #0]
  HW_IF_STUSB1602_IO_Init(PortNum);
 800acac:	f7ff fc54 	bl	800a558 <HW_IF_STUSB1602_IO_Init>
  HW_IF_STUSB16xx_Reset(PortNum);
 800acb0:	0028      	movs	r0, r5
 800acb2:	f7ff ffdb 	bl	800ac6c <HW_IF_STUSB16xx_Reset>
  HW_IF_STUSB16xx_I2C_Init(PortNum);
 800acb6:	0028      	movs	r0, r5
 800acb8:	f7ff fc28 	bl	800a50c <HW_IF_STUSB16xx_I2C_Init>
  STUSB1602_Driver_Init(PortNum, Ports[PortNum].hi2c);
 800acbc:	21f0      	movs	r1, #240	; 0xf0
 800acbe:	0049      	lsls	r1, r1, #1
 800acc0:	4369      	muls	r1, r5
 800acc2:	4b28      	ldr	r3, [pc, #160]	; (800ad64 <USBPD_HW_IF_PortHwInit+0xd4>)
 800acc4:	2240      	movs	r2, #64	; 0x40
 800acc6:	1859      	adds	r1, r3, r1
 800acc8:	000e      	movs	r6, r1
 800acca:	3629      	adds	r6, #41	; 0x29
 800accc:	36ff      	adds	r6, #255	; 0xff
 800acce:	3139      	adds	r1, #57	; 0x39
 800acd0:	31ff      	adds	r1, #255	; 0xff
 800acd2:	4668      	mov	r0, sp
 800acd4:	3604      	adds	r6, #4
 800acd6:	f001 fc09 	bl	800c4ec <memcpy>
 800acda:	ce0e      	ldmia	r6!, {r1, r2, r3}
  nvm_read = STUSB1602_NVM_OK_Get(STUSB1602_I2C_Add(PortNum));
 800acdc:	002e      	movs	r6, r5
  STUSB1602_Driver_Init(PortNum, Ports[PortNum].hi2c);
 800acde:	0028      	movs	r0, r5
 800ace0:	f7fb fd80 	bl	80067e4 <STUSB1602_Driver_Init>
  nvm_read = STUSB1602_NVM_OK_Get(STUSB1602_I2C_Add(PortNum));
 800ace4:	1e73      	subs	r3, r6, #1
 800ace6:	419e      	sbcs	r6, r3
 800ace8:	3628      	adds	r6, #40	; 0x28
    nvm_read = STUSB1602_NVM_OK_Get(STUSB1602_I2C_Add(PortNum));
 800acea:	0030      	movs	r0, r6
 800acec:	f7fc f812 	bl	8006d14 <STUSB1602_NVM_OK_Get>
 800acf0:	7038      	strb	r0, [r7, #0]
  while (nvm_read != 2)
 800acf2:	783b      	ldrb	r3, [r7, #0]
 800acf4:	2b02      	cmp	r3, #2
 800acf6:	d1f8      	bne.n	800acea <USBPD_HW_IF_PortHwInit+0x5a>
  Ports[PortNum].Device_cut = STUSB1602_DEVICE_CUT_Get(STUSB1602_I2C_Add(PortNum));
 800acf8:	27f0      	movs	r7, #240	; 0xf0
 800acfa:	007f      	lsls	r7, r7, #1
 800acfc:	436f      	muls	r7, r5
 800acfe:	0030      	movs	r0, r6
 800ad00:	f7fc f814 	bl	8006d2c <STUSB1602_DEVICE_CUT_Get>
 800ad04:	4b17      	ldr	r3, [pc, #92]	; (800ad64 <USBPD_HW_IF_PortHwInit+0xd4>)
 800ad06:	19df      	adds	r7, r3, r7
 800ad08:	003b      	movs	r3, r7
 800ad0a:	33d9      	adds	r3, #217	; 0xd9
 800ad0c:	33ff      	adds	r3, #255	; 0xff
 800ad0e:	7018      	strb	r0, [r3, #0]
  HW_IF_DMA_Init(PortNum);
 800ad10:	0028      	movs	r0, r5
 800ad12:	f7ff fbe3 	bl	800a4dc <HW_IF_DMA_Init>
  HW_IF_SPI_Init(PortNum);
 800ad16:	0028      	movs	r0, r5
 800ad18:	f7ff fb6e 	bl	800a3f8 <HW_IF_SPI_Init>
  HW_IF_COUNTER_TIM_Init(PortNum);
 800ad1c:	0028      	movs	r0, r5
 800ad1e:	f7ff fe83 	bl	800aa28 <HW_IF_COUNTER_TIM_Init>
  HW_IF_Port_SetInitialRole(PortNum,role);
 800ad22:	9911      	ldr	r1, [sp, #68]	; 0x44
 800ad24:	0028      	movs	r0, r5
 800ad26:	f7ff fcd3 	bl	800a6d0 <HW_IF_Port_SetInitialRole>
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_RX);
 800ad2a:	0028      	movs	r0, r5
 800ad2c:	2101      	movs	r1, #1
 800ad2e:	f7ff ff83 	bl	800ac38 <STUSB16xx_HW_IF_Switch_Mode>
    STUSB1602_CC_Detect_Alrt_Int_Mask_Set(STUSB1602_I2C_Add(PortNum), CC_Detect_Int_UNMASKED);
 800ad32:	2100      	movs	r1, #0
 800ad34:	0030      	movs	r0, r6
 800ad36:	f7fb fd99 	bl	800686c <STUSB1602_CC_Detect_Alrt_Int_Mask_Set>
  Ports[PortNum].cbs = cbs;
 800ad3a:	003a      	movs	r2, r7
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800ad3c:	2301      	movs	r3, #1
  Ports[PortNum].cbs = cbs;
 800ad3e:	32b9      	adds	r2, #185	; 0xb9
 800ad40:	32ff      	adds	r2, #255	; 0xff
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800ad42:	767b      	strb	r3, [r7, #25]
  Ports[PortNum].cbs = cbs;
 800ad44:	0013      	movs	r3, r2
 800ad46:	cc07      	ldmia	r4!, {r0, r1, r2}
 800ad48:	c307      	stmia	r3!, {r0, r1, r2}
 800ad4a:	cc07      	ldmia	r4!, {r0, r1, r2}
 800ad4c:	c307      	stmia	r3!, {r0, r1, r2}
}
 800ad4e:	2000      	movs	r0, #0
  Ports[PortNum].role = role;
 800ad50:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800ad52:	3701      	adds	r7, #1
 800ad54:	77fb      	strb	r3, [r7, #31]
}
 800ad56:	b013      	add	sp, #76	; 0x4c
 800ad58:	bcf0      	pop	{r4, r5, r6, r7}
 800ad5a:	bc08      	pop	{r3}
 800ad5c:	b004      	add	sp, #16
 800ad5e:	4718      	bx	r3
 800ad60:	20000404 	.word	0x20000404
 800ad64:	2000007c 	.word	0x2000007c

0800ad68 <STUSB16xx_HW_IF_Alert_Check>:
  * @param  PortNum The port index
  * @retval None
  */ 
void STUSB16xx_HW_IF_Alert_Check(uint8_t PortNum)
{
  Ports[PortNum].AlertEventCount++;
 800ad68:	23f0      	movs	r3, #240	; 0xf0
 800ad6a:	005b      	lsls	r3, r3, #1
 800ad6c:	4343      	muls	r3, r0
 800ad6e:	4804      	ldr	r0, [pc, #16]	; (800ad80 <STUSB16xx_HW_IF_Alert_Check+0x18>)
 800ad70:	18c0      	adds	r0, r0, r3
 800ad72:	30d1      	adds	r0, #209	; 0xd1
 800ad74:	30ff      	adds	r0, #255	; 0xff
 800ad76:	7803      	ldrb	r3, [r0, #0]
 800ad78:	3301      	adds	r3, #1
 800ad7a:	7003      	strb	r3, [r0, #0]
}
 800ad7c:	4770      	bx	lr
 800ad7e:	46c0      	nop			; (mov r8, r8)
 800ad80:	2000007c 	.word	0x2000007c

0800ad84 <STUSB16xx_HW_IF_Alert_Manager>:
  * @brief  It manages registers related to STUSB1602 ALERT interrupts
  * @param  PortNum The port index
  * @retval USBPD_StatusTypeDef
  */ 
USBPD_StatusTypeDef STUSB16xx_HW_IF_Alert_Manager(uint8_t PortNum)
{
 800ad84:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ad86:	0004      	movs	r4, r0
 800ad88:	26c8      	movs	r6, #200	; 0xc8
 800ad8a:	b085      	sub	sp, #20
 800ad8c:	46c0      	nop			; (mov r8, r8)
 800ad8e:	3e01      	subs	r6, #1
  uint8_t AlertAttempts;
  uint8_t AlertAccomplished;
  uint32_t i;

  /* Delay of few us in order to be sure that registers are updated*/
  for(i=0; i<200; i++)
 800ad90:	2e00      	cmp	r6, #0
 800ad92:	d1fb      	bne.n	800ad8c <STUSB16xx_HW_IF_Alert_Manager+0x8>
  AlertAttempts = 10;
  
  while(1)
  {
    /* Registers from 0x0B to 0x12 are read */
    STUSB1602_AlertMonitoring_Value = STUSB1602_Alert_Monitoring_Get(STUSB1602_I2C_Add(PortNum));
 800ad94:	0025      	movs	r5, r4
 800ad96:	1e6b      	subs	r3, r5, #1
 800ad98:	419d      	sbcs	r5, r3
 800ad9a:	3528      	adds	r5, #40	; 0x28
 800ad9c:	0029      	movs	r1, r5
 800ad9e:	a802      	add	r0, sp, #8
 800ada0:	f7fb fd56 	bl	8006850 <STUSB1602_Alert_Monitoring_Get>
    
    /* Check ALERT due to a change occurred on CC */
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.CC_DETECTION_STATUS_AL) && \
 800ada4:	2240      	movs	r2, #64	; 0x40
 800ada6:	ab02      	add	r3, sp, #8
 800ada8:	781b      	ldrb	r3, [r3, #0]
 800adaa:	9301      	str	r3, [sp, #4]
 800adac:	9901      	ldr	r1, [sp, #4]
  AlertAccomplished = 0;
 800adae:	0033      	movs	r3, r6
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.CC_DETECTION_STATUS_AL) && \
 800adb0:	4211      	tst	r1, r2
 800adb2:	d03e      	beq.n	800ae32 <STUSB16xx_HW_IF_Alert_Manager+0xae>
        (!STUSB1602_AlertMonitoring_Value.reg_0C.b.CC_DETECTION_STATUS_AL_MASK) && \
 800adb4:	ab02      	add	r3, sp, #8
 800adb6:	7859      	ldrb	r1, [r3, #1]
  AlertAccomplished = 0;
 800adb8:	0033      	movs	r3, r6
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.CC_DETECTION_STATUS_AL) && \
 800adba:	4211      	tst	r1, r2
 800adbc:	d139      	bne.n	800ae32 <STUSB16xx_HW_IF_Alert_Manager+0xae>
        (!STUSB1602_AlertMonitoring_Value.reg_0C.b.CC_DETECTION_STATUS_AL_MASK) && \
 800adbe:	2701      	movs	r7, #1
 800adc0:	ab02      	add	r3, sp, #8
 800adc2:	789a      	ldrb	r2, [r3, #2]
  AlertAccomplished = 0;
 800adc4:	0033      	movs	r3, r6
        (!STUSB1602_AlertMonitoring_Value.reg_0C.b.CC_DETECTION_STATUS_AL_MASK) && \
 800adc6:	423a      	tst	r2, r7
 800adc8:	d033      	beq.n	800ae32 <STUSB16xx_HW_IF_Alert_Manager+0xae>
        (STUSB1602_AlertMonitoring_Value.reg_0D.b.ATTACH_STATE_TRANS))
    {
      if (STUSB1602_AlertMonitoring_Value.reg_0E.b.CC_ATTACH_STATE)     /* CC line is ATTACHED */
 800adca:	ab02      	add	r3, sp, #8
 800adcc:	78d8      	ldrb	r0, [r3, #3]
 800adce:	4972      	ldr	r1, [pc, #456]	; (800af98 <STUSB16xx_HW_IF_Alert_Manager+0x214>)
 800add0:	4238      	tst	r0, r7
 800add2:	d100      	bne.n	800add6 <STUSB16xx_HW_IF_Alert_Manager+0x52>
 800add4:	e094      	b.n	800af00 <STUSB16xx_HW_IF_Alert_Manager+0x17c>
      {
        /* Check the CC attach mode */
        switch (STUSB1602_AlertMonitoring_Value.reg_0E.b.CC_ATTACH_MODE)
 800add6:	0940      	lsrs	r0, r0, #5
 800add8:	3801      	subs	r0, #1
 800adda:	2318      	movs	r3, #24
 800addc:	2804      	cmp	r0, #4
 800adde:	d900      	bls.n	800ade2 <STUSB16xx_HW_IF_Alert_Manager+0x5e>
 800ade0:	e086      	b.n	800aef0 <STUSB16xx_HW_IF_Alert_Manager+0x16c>
 800ade2:	f7fa fddd 	bl	80059a0 <__gnu_thumb1_case_uqi>
 800ade6:	6d03      	.short	0x6d03
 800ade8:	757d      	.short	0x757d
 800adea:	0c          	.byte	0x0c
 800adeb:	00          	.byte	0x00
        {
        case Sink_Attached:
          /* USBPD_CAD_STATE_ATTACHED */
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_SWITCH_TO_SRC;
 800adec:	4363      	muls	r3, r4
 800adee:	18cb      	adds	r3, r1, r3
 800adf0:	210f      	movs	r1, #15
 800adf2:	7c1a      	ldrb	r2, [r3, #16]
 800adf4:	438a      	bics	r2, r1
 800adf6:	0011      	movs	r1, r2
 800adf8:	2209      	movs	r2, #9
          /*  */
          break;

        default:
          /* USPPD_CAD_STATE_UNKNOWN */
          CAD_HW_Handles[PortNum].state = USPPD_CAD_STATE_UNKNOW;
 800adfa:	430a      	orrs	r2, r1
 800adfc:	741a      	strb	r2, [r3, #16]
          break;
        }

        /* CAD handle is updated */
        CAD_HW_Handles[PortNum].cc = CCXHANDLE(STUSB1602_AlertMonitoring_Value.reg_11.b.CC_ATTACHED);
 800adfe:	2118      	movs	r1, #24
 800ae00:	2630      	movs	r6, #48	; 0x30
 800ae02:	4361      	muls	r1, r4
 800ae04:	4a64      	ldr	r2, [pc, #400]	; (800af98 <STUSB16xx_HW_IF_Alert_Manager+0x214>)
 800ae06:	ab02      	add	r3, sp, #8
 800ae08:	799b      	ldrb	r3, [r3, #6]
 800ae0a:	1851      	adds	r1, r2, r1
 800ae0c:	7c0a      	ldrb	r2, [r1, #16]
 800ae0e:	09db      	lsrs	r3, r3, #7
 800ae10:	3301      	adds	r3, #1
 800ae12:	0118      	lsls	r0, r3, #4
 800ae14:	43b2      	bics	r2, r6
 800ae16:	4302      	orrs	r2, r0
 800ae18:	740a      	strb	r2, [r1, #16]
  Ports[PortNum].CCx = cc;
 800ae1a:	21f0      	movs	r1, #240	; 0xf0
 800ae1c:	0049      	lsls	r1, r1, #1
 800ae1e:	4361      	muls	r1, r4
 800ae20:	4a5e      	ldr	r2, [pc, #376]	; (800af9c <STUSB16xx_HW_IF_Alert_Manager+0x218>)
  Ports[PortNum].CCxChange = SET;
 800ae22:	3e2f      	subs	r6, #47	; 0x2f
  Ports[PortNum].CCx = cc;
 800ae24:	1852      	adds	r2, r2, r1
 800ae26:	7593      	strb	r3, [r2, #22]
  Ports[PortNum].CCxChange = SET;
 800ae28:	75d6      	strb	r6, [r2, #23]

        /* Port handle is updated */
        HW_IF_Port_Set_CC(PortNum, CAD_HW_Handles[PortNum].cc);

        /* RX mode is enabled */
        HW_IF_RX_Enable(PortNum);
 800ae2a:	0020      	movs	r0, r4
 800ae2c:	f7ff fc30 	bl	800a690 <HW_IF_RX_Enable>
        /* TX mode is enabled */
        HW_IF_RX_Disable(PortNum);
      }

      /* Exit from the alert check procedure */
      AlertAccomplished = 1;
 800ae30:	0033      	movs	r3, r6
    }

    /* Check if a MONITORING STATUS ALERT detected */
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.MONITORING_STATUS_AL) && \
 800ae32:	2220      	movs	r2, #32
 800ae34:	9901      	ldr	r1, [sp, #4]
 800ae36:	4211      	tst	r1, r2
 800ae38:	d00b      	beq.n	800ae52 <STUSB16xx_HW_IF_Alert_Manager+0xce>
      (!STUSB1602_AlertMonitoring_Value.reg_0C.b.MONITORING_STATUS_AL_MASK)) 
 800ae3a:	a902      	add	r1, sp, #8
 800ae3c:	7849      	ldrb	r1, [r1, #1]
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.MONITORING_STATUS_AL) && \
 800ae3e:	4211      	tst	r1, r2
 800ae40:	d107      	bne.n	800ae52 <STUSB16xx_HW_IF_Alert_Manager+0xce>
    {
      /* Check changes occurred in MONITORING STATUS register and restore the ALERT pin */
      STUSB1602_Monitoring_Status_Trans_Value = STUSB1602_Monitoring_Status_Trans_Reg_Get(STUSB1602_I2C_Add(PortNum));
 800ae42:	0028      	movs	r0, r5
 800ae44:	f7fb fd40 	bl	80068c8 <STUSB1602_Monitoring_Status_Trans_Reg_Get>

      /* Exit from the alert check procedure */
      AlertAccomplished = 1;

      /* If the alert due to a monitoring event is unmasked remove the if statement and put your code */
      if (STUSB1602_Monitoring_Status_Trans_Value.d8 >0)
 800ae48:	b2c0      	uxtb	r0, r0
      AlertAccomplished = 1;
 800ae4a:	2301      	movs	r3, #1
      if (STUSB1602_Monitoring_Status_Trans_Value.d8 >0)
 800ae4c:	2800      	cmp	r0, #0
 800ae4e:	d000      	beq.n	800ae52 <STUSB16xx_HW_IF_Alert_Manager+0xce>
 800ae50:	46c0      	nop			; (mov r8, r8)
        __NOP();
      }
    }

    /* Check if a HW FAULT STATUS ALERT detected */
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.HW_FAULT_STATUS_AL) && \
 800ae52:	aa02      	add	r2, sp, #8
 800ae54:	7811      	ldrb	r1, [r2, #0]
 800ae56:	2210      	movs	r2, #16
 800ae58:	4211      	tst	r1, r2
 800ae5a:	d067      	beq.n	800af2c <STUSB16xx_HW_IF_Alert_Manager+0x1a8>
      (!STUSB1602_AlertMonitoring_Value.reg_0C.b.HW_FAULT_STATUS_AL_MASK)) 
 800ae5c:	a902      	add	r1, sp, #8
 800ae5e:	7849      	ldrb	r1, [r1, #1]
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.HW_FAULT_STATUS_AL) && \
 800ae60:	4211      	tst	r1, r2
 800ae62:	d163      	bne.n	800af2c <STUSB16xx_HW_IF_Alert_Manager+0x1a8>
    {
      /* Check changes occurred in HW FAULT STATUS register and restore the ALERT pin */
      STUSB1602_HW_Fault_Status_Trans_Value = STUSB1602_Hard_Fault_Trans_Status_Get(STUSB1602_I2C_Add(PortNum));
 800ae64:	0028      	movs	r0, r5
 800ae66:	f7fb fd75 	bl	8006954 <STUSB1602_Hard_Fault_Trans_Status_Get>

      /* Exit from the alert check procedure */
      AlertAccomplished = 1;

      /* If the alert due to a hardware fault event is unmasked remove then if statement and put your code*/
      if (STUSB1602_HW_Fault_Status_Trans_Value.d8 >0)
 800ae6a:	b2c0      	uxtb	r0, r0
 800ae6c:	2800      	cmp	r0, #0
 800ae6e:	d000      	beq.n	800ae72 <STUSB16xx_HW_IF_Alert_Manager+0xee>
 800ae70:	46c0      	nop			; (mov r8, r8)
 800ae72:	2604      	movs	r6, #4
 800ae74:	2c00      	cmp	r4, #0
 800ae76:	d100      	bne.n	800ae7a <STUSB16xx_HW_IF_Alert_Manager+0xf6>
 800ae78:	2602      	movs	r6, #2
 800ae7a:	270a      	movs	r7, #10
 800ae7c:	b2b6      	uxth	r6, r6
  /* reset alert signal */
  uint8_t count = 10;
  uint8_t cleared_alert_flag = 0;
  while (1)
  {
    cleared_alert_flag = (HAL_GPIO_ReadPin(ALERT_GPIO_PORT(PortNum), ALERT_GPIO_PIN(PortNum)) != GPIO_PIN_RESET);
 800ae7e:	2090      	movs	r0, #144	; 0x90
 800ae80:	0031      	movs	r1, r6
 800ae82:	05c0      	lsls	r0, r0, #23
 800ae84:	f7fc fd78 	bl	8007978 <HAL_GPIO_ReadPin>
 800ae88:	9001      	str	r0, [sp, #4]
    /* check if the alert pin is reset */
    if (cleared_alert_flag || count == 0) 
 800ae8a:	2800      	cmp	r0, #0
 800ae8c:	d158      	bne.n	800af40 <STUSB16xx_HW_IF_Alert_Manager+0x1bc>
 800ae8e:	2f00      	cmp	r7, #0
 800ae90:	d056      	beq.n	800af40 <STUSB16xx_HW_IF_Alert_Manager+0x1bc>
    {
      break;
    }
    if (STUSB16xx_I2CxHandle.Lock != HAL_LOCKED)
 800ae92:	4b43      	ldr	r3, [pc, #268]	; (800afa0 <STUSB16xx_HW_IF_Alert_Manager+0x21c>)
 800ae94:	3340      	adds	r3, #64	; 0x40
 800ae96:	781b      	ldrb	r3, [r3, #0]
 800ae98:	2b01      	cmp	r3, #1
 800ae9a:	d0f0      	beq.n	800ae7e <STUSB16xx_HW_IF_Alert_Manager+0xfa>
    {
      /* Restore the CC_DETECTION_STATUS_TRANS register*/
      STUSB1602_Attach_State_Trans_Get(STUSB1602_I2C_Add(PortNum));
 800ae9c:	0028      	movs	r0, r5
 800ae9e:	f7fb fcfd 	bl	800689c <STUSB1602_Attach_State_Trans_Get>

      /* Restore the MONITORING_STATUS_TRANS register */
      STUSB1602_Monitoring_Status_Trans_Reg_Get(STUSB1602_I2C_Add(PortNum));
 800aea2:	0028      	movs	r0, r5
 800aea4:	f7fb fd10 	bl	80068c8 <STUSB1602_Monitoring_Status_Trans_Reg_Get>

      /* Restore the HARD_FAULT_TRANS register */
      STUSB1602_Hard_Fault_Trans_Status_Get(STUSB1602_I2C_Add(PortNum));
 800aea8:	0028      	movs	r0, r5
 800aeaa:	f7fb fd53 	bl	8006954 <STUSB1602_Hard_Fault_Trans_Status_Get>

      /* Decrement the counter to implement a TO */
      count--;
 800aeae:	23fa      	movs	r3, #250	; 0xfa
 800aeb0:	3f01      	subs	r7, #1
 800aeb2:	b2ff      	uxtb	r7, r7
 800aeb4:	009b      	lsls	r3, r3, #2
 800aeb6:	46c0      	nop			; (mov r8, r8)
 800aeb8:	3b01      	subs	r3, #1

      /* wait a bit time */
      for(i=0; i<1000; i++)
 800aeba:	2b00      	cmp	r3, #0
 800aebc:	d1fb      	bne.n	800aeb6 <STUSB16xx_HW_IF_Alert_Manager+0x132>
 800aebe:	e7de      	b.n	800ae7e <STUSB16xx_HW_IF_Alert_Manager+0xfa>
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_SWITCH_TO_SNK;
 800aec0:	4363      	muls	r3, r4
 800aec2:	18cb      	adds	r3, r1, r3
 800aec4:	210f      	movs	r1, #15
 800aec6:	7c1a      	ldrb	r2, [r3, #16]
 800aec8:	438a      	bics	r2, r1
 800aeca:	0011      	movs	r1, r2
 800aecc:	220a      	movs	r2, #10
 800aece:	e794      	b.n	800adfa <STUSB16xx_HW_IF_Alert_Manager+0x76>
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_ACCESSORY;
 800aed0:	4363      	muls	r3, r4
 800aed2:	18cb      	adds	r3, r1, r3
 800aed4:	210f      	movs	r1, #15
 800aed6:	7c1a      	ldrb	r2, [r3, #16]
 800aed8:	438a      	bics	r2, r1
 800aeda:	0011      	movs	r1, r2
 800aedc:	2207      	movs	r2, #7
 800aede:	e78c      	b.n	800adfa <STUSB16xx_HW_IF_Alert_Manager+0x76>
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_DEBUG;
 800aee0:	4363      	muls	r3, r4
 800aee2:	18cb      	adds	r3, r1, r3
 800aee4:	210f      	movs	r1, #15
 800aee6:	7c1a      	ldrb	r2, [r3, #16]
 800aee8:	438a      	bics	r2, r1
 800aeea:	0011      	movs	r1, r2
 800aeec:	2208      	movs	r2, #8
 800aeee:	e784      	b.n	800adfa <STUSB16xx_HW_IF_Alert_Manager+0x76>
          CAD_HW_Handles[PortNum].state = USPPD_CAD_STATE_UNKNOW;
 800aef0:	4363      	muls	r3, r4
 800aef2:	18cb      	adds	r3, r1, r3
 800aef4:	210f      	movs	r1, #15
 800aef6:	7c1a      	ldrb	r2, [r3, #16]
 800aef8:	438a      	bics	r2, r1
 800aefa:	0011      	movs	r1, r2
 800aefc:	220c      	movs	r2, #12
 800aefe:	e77c      	b.n	800adfa <STUSB16xx_HW_IF_Alert_Manager+0x76>
        CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_DETACHED;
 800af00:	2318      	movs	r3, #24
 800af02:	4363      	muls	r3, r4
 800af04:	18cb      	adds	r3, r1, r3
 800af06:	210f      	movs	r1, #15
 800af08:	7c1a      	ldrb	r2, [r3, #16]
        HW_IF_RX_Disable(PortNum);
 800af0a:	0020      	movs	r0, r4
        CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_DETACHED;
 800af0c:	438a      	bics	r2, r1
        CAD_HW_Handles[PortNum].cc = CCNONE;
 800af0e:	433a      	orrs	r2, r7
 800af10:	3121      	adds	r1, #33	; 0x21
 800af12:	438a      	bics	r2, r1
 800af14:	741a      	strb	r2, [r3, #16]
  Ports[PortNum].CCx = cc;
 800af16:	22f0      	movs	r2, #240	; 0xf0
 800af18:	0052      	lsls	r2, r2, #1
 800af1a:	4362      	muls	r2, r4
 800af1c:	4b1f      	ldr	r3, [pc, #124]	; (800af9c <STUSB16xx_HW_IF_Alert_Manager+0x218>)
 800af1e:	189b      	adds	r3, r3, r2
 800af20:	759e      	strb	r6, [r3, #22]
  Ports[PortNum].CCxChange = SET;
 800af22:	75df      	strb	r7, [r3, #23]
        HW_IF_RX_Disable(PortNum);
 800af24:	f7ff fbc4 	bl	800a6b0 <HW_IF_RX_Disable>
      AlertAccomplished = 1;
 800af28:	003b      	movs	r3, r7
 800af2a:	e782      	b.n	800ae32 <STUSB16xx_HW_IF_Alert_Manager+0xae>
    if (AlertAttempts == 0 || AlertAccomplished)
 800af2c:	2b00      	cmp	r3, #0
 800af2e:	d1a0      	bne.n	800ae72 <STUSB16xx_HW_IF_Alert_Manager+0xee>
 800af30:	330a      	adds	r3, #10
 800af32:	46c0      	nop			; (mov r8, r8)
 800af34:	3b01      	subs	r3, #1
    for(i=0; i<10; i++)
 800af36:	2b00      	cmp	r3, #0
 800af38:	d1fb      	bne.n	800af32 <STUSB16xx_HW_IF_Alert_Manager+0x1ae>
      for(i=0; i<400000; i++) __NOP();
    }

  }
  return USBPD_OK;
} 
 800af3a:	2000      	movs	r0, #0
 800af3c:	b005      	add	sp, #20
 800af3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cleared_alert_flag |= (HAL_GPIO_ReadPin(ALERT_GPIO_PORT(PortNum), ALERT_GPIO_PIN(PortNum)) != GPIO_PIN_RESET);
 800af40:	2090      	movs	r0, #144	; 0x90
 800af42:	0031      	movs	r1, r6
 800af44:	05c0      	lsls	r0, r0, #23
 800af46:	f7fc fd17 	bl	8007978 <HAL_GPIO_ReadPin>
  if (!cleared_alert_flag) {
 800af4a:	9b01      	ldr	r3, [sp, #4]
 800af4c:	4303      	orrs	r3, r0
 800af4e:	b2d8      	uxtb	r0, r3
 800af50:	2800      	cmp	r0, #0
 800af52:	d1f2      	bne.n	800af3a <STUSB16xx_HW_IF_Alert_Manager+0x1b6>
    USBPD_BSP_LED_Off(GREEN_USER_LED);
 800af54:	f7fb ff78 	bl	8006e48 <USBPD_BSP_LED_Off>
    USBPD_BSP_LED_Off(LED_PORT0_CC);
 800af58:	2003      	movs	r0, #3
 800af5a:	f7fb ff75 	bl	8006e48 <USBPD_BSP_LED_Off>
    USBPD_BSP_LED_Off(LED_PORT0_VBUS);
 800af5e:	2002      	movs	r0, #2
 800af60:	f7fb ff72 	bl	8006e48 <USBPD_BSP_LED_Off>
    USBPD_BSP_LED_Off(LED_PORT0_ROLE);
 800af64:	2001      	movs	r0, #1
 800af66:	f7fb ff6f 	bl	8006e48 <USBPD_BSP_LED_Off>
    USBPD_BSP_LED_Off(LED_PORT1_CC);
 800af6a:	2006      	movs	r0, #6
 800af6c:	f7fb ff6c 	bl	8006e48 <USBPD_BSP_LED_Off>
    USBPD_BSP_LED_Off(LED_PORT1_VBUS);
 800af70:	2005      	movs	r0, #5
 800af72:	f7fb ff69 	bl	8006e48 <USBPD_BSP_LED_Off>
    USBPD_BSP_LED_Off(LED_PORT1_ROLE);
 800af76:	2004      	movs	r0, #4
 800af78:	f7fb ff66 	bl	8006e48 <USBPD_BSP_LED_Off>
 800af7c:	2006      	movs	r0, #6
 800af7e:	2c00      	cmp	r4, #0
 800af80:	d100      	bne.n	800af84 <STUSB16xx_HW_IF_Alert_Manager+0x200>
 800af82:	2003      	movs	r0, #3
 800af84:	b244      	sxtb	r4, r0
      USBPD_BSP_LED_Toggle(PortNum == 0 ? LED_PORT0_CC : LED_PORT1_CC);
 800af86:	0020      	movs	r0, r4
 800af88:	f7fb ff88 	bl	8006e9c <USBPD_BSP_LED_Toggle>
 800af8c:	4b05      	ldr	r3, [pc, #20]	; (800afa4 <STUSB16xx_HW_IF_Alert_Manager+0x220>)
 800af8e:	46c0      	nop			; (mov r8, r8)
 800af90:	3b01      	subs	r3, #1
      for(i=0; i<400000; i++) __NOP();
 800af92:	2b00      	cmp	r3, #0
 800af94:	d1fb      	bne.n	800af8e <STUSB16xx_HW_IF_Alert_Manager+0x20a>
 800af96:	e7f6      	b.n	800af86 <STUSB16xx_HW_IF_Alert_Manager+0x202>
 800af98:	20001bc8 	.word	0x20001bc8
 800af9c:	2000007c 	.word	0x2000007c
 800afa0:	20001a20 	.word	0x20001a20
 800afa4:	00061a80 	.word	0x00061a80

0800afa8 <CAD_StateMachine>:
{
 800afa8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (hhw_handle->AlertEventCount > 0)
 800afaa:	27f0      	movs	r7, #240	; 0xf0
{
 800afac:	000d      	movs	r5, r1
  *Event = USBPD_CAD_EVENT_NONE;
 800afae:	2100      	movs	r1, #0
  if (hhw_handle->AlertEventCount > 0)
 800afb0:	007f      	lsls	r7, r7, #1
 800afb2:	4347      	muls	r7, r0
 800afb4:	4e51      	ldr	r6, [pc, #324]	; (800b0fc <CAD_StateMachine+0x154>)
{
 800afb6:	0004      	movs	r4, r0
  if (hhw_handle->AlertEventCount > 0)
 800afb8:	19f7      	adds	r7, r6, r7
 800afba:	37d1      	adds	r7, #209	; 0xd1
 800afbc:	37ff      	adds	r7, #255	; 0xff
 800afbe:	783b      	ldrb	r3, [r7, #0]
{
 800afc0:	9201      	str	r2, [sp, #4]
  *Event = USBPD_CAD_EVENT_NONE;
 800afc2:	7029      	strb	r1, [r5, #0]
  if (hhw_handle->AlertEventCount > 0)
 800afc4:	428b      	cmp	r3, r1
 800afc6:	d00c      	beq.n	800afe2 <CAD_StateMachine+0x3a>
    ret = HW_IF_COMM_WAIT(PortNum, 0);
 800afc8:	f7ff f93e 	bl	800a248 <HW_IF_COMM_WAIT>
    if (ret == USBPD_OK)
 800afcc:	2800      	cmp	r0, #0
 800afce:	d108      	bne.n	800afe2 <CAD_StateMachine+0x3a>
      if (STUSB16xx_HW_IF_Alert_Manager(PortNum) == USBPD_OK)
 800afd0:	0020      	movs	r0, r4
 800afd2:	f7ff fed7 	bl	800ad84 <STUSB16xx_HW_IF_Alert_Manager>
 800afd6:	2800      	cmp	r0, #0
 800afd8:	d100      	bne.n	800afdc <CAD_StateMachine+0x34>
        hhw_handle->AlertEventCount = 0;
 800afda:	7038      	strb	r0, [r7, #0]
      HW_IF_COMM_RELEASE(PortNum);
 800afdc:	0020      	movs	r0, r4
 800afde:	f7ff f951 	bl	800a284 <HW_IF_COMM_RELEASE>
  switch(_handle->state)
 800afe2:	2218      	movs	r2, #24
 800afe4:	0013      	movs	r3, r2
 800afe6:	4363      	muls	r3, r4
 800afe8:	4945      	ldr	r1, [pc, #276]	; (800b100 <CAD_StateMachine+0x158>)
 800afea:	18cb      	adds	r3, r1, r3
 800afec:	7c18      	ldrb	r0, [r3, #16]
 800afee:	23f0      	movs	r3, #240	; 0xf0
 800aff0:	0700      	lsls	r0, r0, #28
 800aff2:	0f00      	lsrs	r0, r0, #28
 800aff4:	005b      	lsls	r3, r3, #1
 800aff6:	280a      	cmp	r0, #10
 800aff8:	d900      	bls.n	800affc <CAD_StateMachine+0x54>
 800affa:	e06b      	b.n	800b0d4 <CAD_StateMachine+0x12c>
 800affc:	f7fa fcd0 	bl	80059a0 <__gnu_thumb1_case_uqi>
 800b000:	6a6a0619 	.word	0x6a6a0619
 800b004:	6a6a6a6a 	.word	0x6a6a6a6a
 800b008:	566a      	.short	0x566a
 800b00a:	71          	.byte	0x71
 800b00b:	00          	.byte	0x00
    if (Ports[PortNum].NbDetach == 0)
 800b00c:	4363      	muls	r3, r4
 800b00e:	18f3      	adds	r3, r6, r3
 800b010:	33d3      	adds	r3, #211	; 0xd3
 800b012:	33ff      	adds	r3, #255	; 0xff
 800b014:	9300      	str	r3, [sp, #0]
 800b016:	781b      	ldrb	r3, [r3, #0]
 800b018:	2b00      	cmp	r3, #0
 800b01a:	d10a      	bne.n	800b032 <CAD_StateMachine+0x8a>
      if ((STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum))) == VBUS_below_VSAFE0V_threshold)
 800b01c:	0027      	movs	r7, r4
 800b01e:	1e7b      	subs	r3, r7, #1
 800b020:	419f      	sbcs	r7, r3
 800b022:	3728      	adds	r7, #40	; 0x28
 800b024:	0038      	movs	r0, r7
 800b026:	f7fb fc65 	bl	80068f4 <STUSB1602_VBUS_VSAFE0V_Get>
 800b02a:	2801      	cmp	r0, #1
 800b02c:	d126      	bne.n	800b07c <CAD_StateMachine+0xd4>
        Ports[PortNum].NbDetach = 1;
 800b02e:	9b00      	ldr	r3, [sp, #0]
 800b030:	7018      	strb	r0, [r3, #0]
    *Event = USBPD_CAD_EVENT_DETACHED;
 800b032:	2301      	movs	r3, #1
 800b034:	702b      	strb	r3, [r5, #0]
  if ((hhw_handle->CCxChange == SET) && (_handle->state != USBPD_CAD_STATE_SWITCH_TO_SRC) && (_handle->state != USBPD_CAD_STATE_SWITCH_TO_SNK))
 800b036:	23f0      	movs	r3, #240	; 0xf0
 800b038:	005b      	lsls	r3, r3, #1
 800b03a:	4363      	muls	r3, r4
 800b03c:	18f6      	adds	r6, r6, r3
 800b03e:	7df3      	ldrb	r3, [r6, #23]
 800b040:	2b01      	cmp	r3, #1
 800b042:	d10f      	bne.n	800b064 <CAD_StateMachine+0xbc>
 800b044:	3317      	adds	r3, #23
 800b046:	4363      	muls	r3, r4
 800b048:	4a2d      	ldr	r2, [pc, #180]	; (800b100 <CAD_StateMachine+0x158>)
 800b04a:	18d3      	adds	r3, r2, r3
 800b04c:	220f      	movs	r2, #15
 800b04e:	7c1b      	ldrb	r3, [r3, #16]
 800b050:	401a      	ands	r2, r3
 800b052:	3a09      	subs	r2, #9
 800b054:	2a01      	cmp	r2, #1
 800b056:	d905      	bls.n	800b064 <CAD_StateMachine+0xbc>
    *CCXX  = _handle->cc;
 800b058:	069b      	lsls	r3, r3, #26
 800b05a:	9a01      	ldr	r2, [sp, #4]
 800b05c:	0f9b      	lsrs	r3, r3, #30
 800b05e:	7013      	strb	r3, [r2, #0]
    hhw_handle->CCxChange = RESET;
 800b060:	2300      	movs	r3, #0
 800b062:	75f3      	strb	r3, [r6, #23]
  if ((*Event != USBPD_CAD_EVENT_DETACHED) || (previous_event[PortNum] != USBPD_CAD_EVENT_DETACHED))
 800b064:	782a      	ldrb	r2, [r5, #0]
 800b066:	4b27      	ldr	r3, [pc, #156]	; (800b104 <CAD_StateMachine+0x15c>)
 800b068:	2a01      	cmp	r2, #1
 800b06a:	d103      	bne.n	800b074 <CAD_StateMachine+0xcc>
 800b06c:	1919      	adds	r1, r3, r4
 800b06e:	7849      	ldrb	r1, [r1, #1]
 800b070:	2901      	cmp	r1, #1
 800b072:	d03f      	beq.n	800b0f4 <CAD_StateMachine+0x14c>
    previous_event[PortNum] = *Event;
 800b074:	191c      	adds	r4, r3, r4
 800b076:	7062      	strb	r2, [r4, #1]
}
 800b078:	2002      	movs	r0, #2
 800b07a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        if  (STUSB1602_TypeC_FSM_State_Get(STUSB1602_I2C_Add(PortNum)) == Unattached_SNK)
 800b07c:	0038      	movs	r0, r7
 800b07e:	f7fb fc5d 	bl	800693c <STUSB1602_TypeC_FSM_State_Get>
 800b082:	2800      	cmp	r0, #0
 800b084:	d1d5      	bne.n	800b032 <CAD_StateMachine+0x8a>
          if ((STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum))) != VBUS_below_VSAFE0V_threshold)
 800b086:	0038      	movs	r0, r7
 800b088:	f7fb fc34 	bl	80068f4 <STUSB1602_VBUS_VSAFE0V_Get>
 800b08c:	2801      	cmp	r0, #1
 800b08e:	d0d0      	beq.n	800b032 <CAD_StateMachine+0x8a>
            if ((STUSB1602_TypeC_FSM_State_Get(STUSB1602_I2C_Add(PortNum)) == AttachWait_SRC) && 
 800b090:	0038      	movs	r0, r7
 800b092:	f7fb fc53 	bl	800693c <STUSB1602_TypeC_FSM_State_Get>
 800b096:	2809      	cmp	r0, #9
 800b098:	d1cb      	bne.n	800b032 <CAD_StateMachine+0x8a>
                (STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_below_VSAFE0V_threshold))
 800b09a:	0038      	movs	r0, r7
 800b09c:	f7fb fc2a 	bl	80068f4 <STUSB1602_VBUS_VSAFE0V_Get>
            if ((STUSB1602_TypeC_FSM_State_Get(STUSB1602_I2C_Add(PortNum)) == AttachWait_SRC) && 
 800b0a0:	2801      	cmp	r0, #1
 800b0a2:	d0c6      	beq.n	800b032 <CAD_StateMachine+0x8a>
              HW_IF_RESET_CTRL(PortNum);
 800b0a4:	0020      	movs	r0, r4
 800b0a6:	f7ff fac9 	bl	800a63c <HW_IF_RESET_CTRL>
 800b0aa:	e7c2      	b.n	800b032 <CAD_StateMachine+0x8a>
    _handle->params->PE_PowerRole = USBPD_PORTPOWERROLE_SRC;
 800b0ac:	0013      	movs	r3, r2
 800b0ae:	4363      	muls	r3, r4
 800b0b0:	4a13      	ldr	r2, [pc, #76]	; (800b100 <CAD_StateMachine+0x158>)
 800b0b2:	18d3      	adds	r3, r2, r3
 800b0b4:	2204      	movs	r2, #4
 800b0b6:	6859      	ldr	r1, [r3, #4]
 800b0b8:	7808      	ldrb	r0, [r1, #0]
 800b0ba:	4302      	orrs	r2, r0
    _handle->params->PE_PowerRole = USBPD_PORTPOWERROLE_SNK;
 800b0bc:	700a      	strb	r2, [r1, #0]
    _handle->state = USBPD_CAD_STATE_ATTACHED;
 800b0be:	210f      	movs	r1, #15
 800b0c0:	7c1a      	ldrb	r2, [r3, #16]
 800b0c2:	438a      	bics	r2, r1
 800b0c4:	0011      	movs	r1, r2
 800b0c6:	2203      	movs	r2, #3
 800b0c8:	430a      	orrs	r2, r1
 800b0ca:	741a      	strb	r2, [r3, #16]
    *Event = USBPD_CAD_EVENT_ATTACHED;
 800b0cc:	2302      	movs	r3, #2
 800b0ce:	702b      	strb	r3, [r5, #0]
    Ports[PortNum].NbDetach =0;
 800b0d0:	33df      	adds	r3, #223	; 0xdf
 800b0d2:	33ff      	adds	r3, #255	; 0xff
    Ports[PortNum].NbDetach =0;
 800b0d4:	2200      	movs	r2, #0
 800b0d6:	4363      	muls	r3, r4
 800b0d8:	18f3      	adds	r3, r6, r3
 800b0da:	33d3      	adds	r3, #211	; 0xd3
 800b0dc:	33ff      	adds	r3, #255	; 0xff
 800b0de:	701a      	strb	r2, [r3, #0]
    break;
 800b0e0:	e7a9      	b.n	800b036 <CAD_StateMachine+0x8e>
    _handle->params->PE_PowerRole = USBPD_PORTPOWERROLE_SNK;
 800b0e2:	0013      	movs	r3, r2
 800b0e4:	2004      	movs	r0, #4
 800b0e6:	4363      	muls	r3, r4
 800b0e8:	4a05      	ldr	r2, [pc, #20]	; (800b100 <CAD_StateMachine+0x158>)
 800b0ea:	18d3      	adds	r3, r2, r3
 800b0ec:	6859      	ldr	r1, [r3, #4]
 800b0ee:	780a      	ldrb	r2, [r1, #0]
 800b0f0:	4382      	bics	r2, r0
 800b0f2:	e7e3      	b.n	800b0bc <CAD_StateMachine+0x114>
    *Event = USBPD_CAD_EVENT_NONE;
 800b0f4:	2300      	movs	r3, #0
 800b0f6:	702b      	strb	r3, [r5, #0]
 800b0f8:	e7be      	b.n	800b078 <CAD_StateMachine+0xd0>
 800b0fa:	46c0      	nop			; (mov r8, r8)
 800b0fc:	2000007c 	.word	0x2000007c
 800b100:	20001bc8 	.word	0x20001bc8
 800b104:	20000404 	.word	0x20000404

0800b108 <STUSB16xx_HW_IF_Send_Packet>:
  * @param  pData The pointer to data buffer
  * @param  Size The amount of data to be sent
  * @retval USBPD status
  */
USBPD_StatusTypeDef STUSB16xx_HW_IF_Send_Packet(uint8_t PortNum, uint8_t *pData, uint16_t Size)
{
 800b108:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800b10a:	0005      	movs	r5, r0
 800b10c:	9100      	str	r1, [sp, #0]
 800b10e:	9201      	str	r2, [sp, #4]
  USBPD_StatusTypeDef ret = USBPD_ERROR;
  
  /* Check if the bus is idle */
  ret = HW_IF_check_bus_idle(PortNum);
 800b110:	f7ff fc18 	bl	800a944 <HW_IF_check_bus_idle>
 800b114:	1e06      	subs	r6, r0, #0
  if (ret == USBPD_OK && 1 /* tx ready */)
 800b116:	d11d      	bne.n	800b154 <STUSB16xx_HW_IF_Send_Packet+0x4c>
  {
    /* Set the state to busy*/
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_TX;
 800b118:	24f0      	movs	r4, #240	; 0xf0
 800b11a:	2203      	movs	r2, #3
 800b11c:	0064      	lsls	r4, r4, #1
 800b11e:	436c      	muls	r4, r5
 800b120:	4f0d      	ldr	r7, [pc, #52]	; (800b158 <STUSB16xx_HW_IF_Send_Packet+0x50>)

    /* Set the SPI in TX mode */
    STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 800b122:	0001      	movs	r1, r0
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_TX;
 800b124:	193b      	adds	r3, r7, r4

    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800b126:	3440      	adds	r4, #64	; 0x40
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_TX;
 800b128:	765a      	strb	r2, [r3, #25]
    STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 800b12a:	0028      	movs	r0, r5
    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800b12c:	19e4      	adds	r4, r4, r7
    STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 800b12e:	f7ff fd83 	bl	800ac38 <STUSB16xx_HW_IF_Switch_Mode>
    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800b132:	0020      	movs	r0, r4
 800b134:	f7fd fad6 	bl	80086e4 <HAL_SPI_DMAStop>
    __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 800b138:	4b08      	ldr	r3, [pc, #32]	; (800b15c <STUSB16xx_HW_IF_Send_Packet+0x54>)
 800b13a:	4a09      	ldr	r2, [pc, #36]	; (800b160 <STUSB16xx_HW_IF_Send_Packet+0x58>)

    /* Send TX Buffer by SPI DMA */
    HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, pData, Size);
 800b13c:	9900      	ldr	r1, [sp, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 800b13e:	605a      	str	r2, [r3, #4]
    HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, pData, Size);
 800b140:	0020      	movs	r0, r4
 800b142:	9a01      	ldr	r2, [sp, #4]
 800b144:	f7fd f8bc 	bl	80082c0 <HAL_SPI_Transmit_DMA>

    /* Set TX_EN GPIO */
    STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_SET);
 800b148:	2101      	movs	r1, #1
 800b14a:	0028      	movs	r0, r5
 800b14c:	f7ff fd82 	bl	800ac54 <STUSB16xx_HW_IF_TX_EN_Status>
  else
  {
    __NOP();
  }
  return ret;
}
 800b150:	0030      	movs	r0, r6
 800b152:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800b154:	46c0      	nop			; (mov r8, r8)
 800b156:	e7fb      	b.n	800b150 <STUSB16xx_HW_IF_Send_Packet+0x48>
 800b158:	2000007c 	.word	0x2000007c
 800b15c:	40020000 	.word	0x40020000
 800b160:	0fffffff 	.word	0x0fffffff

0800b164 <STUSB16xx_HW_IF_DataRoleSwap>:
USBPD_StatusTypeDef STUSB16xx_HW_IF_DataRoleSwap(uint8_t PortNum)
{
  uint32_t STUSB16xx_ACK_timeout = 0xFFFF;
  USBPD_StatusTypeDef ret = USBPD_ERROR;

  if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_DFP)
 800b164:	21f0      	movs	r1, #240	; 0xf0
 800b166:	0049      	lsls	r1, r1, #1
 800b168:	4341      	muls	r1, r0
 800b16a:	4a0c      	ldr	r2, [pc, #48]	; (800b19c <STUSB16xx_HW_IF_DataRoleSwap+0x38>)
{
 800b16c:	b510      	push	{r4, lr}
  if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_DFP)
 800b16e:	1852      	adds	r2, r2, r1
 800b170:	3229      	adds	r2, #41	; 0x29
 800b172:	7812      	ldrb	r2, [r2, #0]
{
 800b174:	0003      	movs	r3, r0
  if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_DFP)
 800b176:	2a01      	cmp	r2, #1
 800b178:	d107      	bne.n	800b18a <STUSB16xx_HW_IF_DataRoleSwap+0x26>
  {
    /* i2c_dr_swap_port_change_2_ufp_req command */
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Control_Set(STUSB1602_I2C_Add(PortNum), PD_DR_SWAP_PORT_CHANGE_2_UFP_REQ);    
 800b17a:	1e58      	subs	r0, r3, #1
 800b17c:	4183      	sbcs	r3, r0
 800b17e:	3328      	adds	r3, #40	; 0x28
 800b180:	0018      	movs	r0, r3
 800b182:	210a      	movs	r1, #10
//    }
  }
  else if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_UFP)
  {
    /* i2c_dr_swap_port_change_2_dfp_req command */
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Control_Set(STUSB1602_I2C_Add(PortNum), PD_DR_SWAP_PORT_CHANGE_2_DFP_REQ);    
 800b184:	f7fb fc94 	bl	8006ab0 <STUSB1602_Type_C_Control_Set>

  if (STUSB16xx_ACK_timeout == 0)
    ret = USBPD_ERROR;

  return ret;
}
 800b188:	bd10      	pop	{r4, pc}
    ret = USBPD_ERROR;
 800b18a:	2002      	movs	r0, #2
  else if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_UFP)
 800b18c:	2a00      	cmp	r2, #0
 800b18e:	d1fb      	bne.n	800b188 <STUSB16xx_HW_IF_DataRoleSwap+0x24>
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Control_Set(STUSB1602_I2C_Add(PortNum), PD_DR_SWAP_PORT_CHANGE_2_DFP_REQ);    
 800b190:	1e58      	subs	r0, r3, #1
 800b192:	4183      	sbcs	r3, r0
 800b194:	3328      	adds	r3, #40	; 0x28
 800b196:	0018      	movs	r0, r3
 800b198:	2109      	movs	r1, #9
 800b19a:	e7f3      	b.n	800b184 <STUSB16xx_HW_IF_DataRoleSwap+0x20>
 800b19c:	2000007c 	.word	0x2000007c

0800b1a0 <USBPD_16xx_IsResistor_SinkTxOk>:
  * @brief  Get Sink Resistors State
  * @param  PortNum The port index
  * @retval USBPD_FALSE of USBPD_TRUE
  */
uint8_t USBPD_16xx_IsResistor_SinkTxOk(uint8_t PortNum)
{
 800b1a0:	b570      	push	{r4, r5, r6, lr}
  uint8_t TX_OK;

  USBPD_StatusTypeDef ret = USBPD_ERROR;
  /* try to acquire the communication resource to avoid the conflict */
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800b1a2:	2164      	movs	r1, #100	; 0x64
{
 800b1a4:	0005      	movs	r5, r0
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800b1a6:	f7ff f84f 	bl	800a248 <HW_IF_COMM_WAIT>
  if (ret != USBPD_OK)
  {
    return USBPD_FALSE;
 800b1aa:	2300      	movs	r3, #0
  if (ret != USBPD_OK)
 800b1ac:	4298      	cmp	r0, r3
 800b1ae:	d10d      	bne.n	800b1cc <USBPD_16xx_IsResistor_SinkTxOk+0x2c>
  }
  TX_OK = STUSB1602_Sink_Power_State_Get(STUSB1602_I2C_Add(PortNum));
 800b1b0:	0028      	movs	r0, r5
 800b1b2:	1e43      	subs	r3, r0, #1
 800b1b4:	4198      	sbcs	r0, r3
 800b1b6:	3028      	adds	r0, #40	; 0x28
 800b1b8:	f7fb fbb4 	bl	8006924 <STUSB1602_Sink_Power_State_Get>
 800b1bc:	0004      	movs	r4, r0
  HW_IF_COMM_RELEASE(PortNum);
 800b1be:	0028      	movs	r0, r5

  if ( TX_OK == Pwr_3_0_SNK)
 800b1c0:	3c02      	subs	r4, #2
  HW_IF_COMM_RELEASE(PortNum);
 800b1c2:	f7ff f85f 	bl	800a284 <HW_IF_COMM_RELEASE>
  if ( TX_OK == Pwr_3_0_SNK)
 800b1c6:	4263      	negs	r3, r4
 800b1c8:	4163      	adcs	r3, r4
    return USBPD_FALSE;
 800b1ca:	b2db      	uxtb	r3, r3
  }
  else
  {
    return USBPD_FALSE;
  }
}
 800b1cc:	0018      	movs	r0, r3
 800b1ce:	bd70      	pop	{r4, r5, r6, pc}

0800b1d0 <USBPD_TIM_Init>:
/**
  * @brief  Initialization of TIMERSERVER, used for CRC and RETRY operations
  * @retval None
  */
void USBPD_TIM_Init(void)
{
 800b1d0:	b537      	push	{r0, r1, r2, r4, r5, lr}
  TIMx_CLK_ENABLE;
 800b1d2:	2001      	movs	r0, #1
 800b1d4:	4a26      	ldr	r2, [pc, #152]	; (800b270 <USBPD_TIM_Init+0xa0>)
  *         @arg @ref LL_TIM_COUNTERMODE_CENTER_UP_DOWN
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetCounterMode(TIM_TypeDef *TIMx, uint32_t CounterMode)
{
  MODIFY_REG(TIMx->CR1, TIM_CR1_DIR | TIM_CR1_CMS, CounterMode);
 800b1d6:	2480      	movs	r4, #128	; 0x80
 800b1d8:	69d1      	ldr	r1, [r2, #28]
 800b1da:	05e4      	lsls	r4, r4, #23
 800b1dc:	4301      	orrs	r1, r0
 800b1de:	61d1      	str	r1, [r2, #28]
 800b1e0:	69d3      	ldr	r3, [r2, #28]
 800b1e2:	2270      	movs	r2, #112	; 0x70
 800b1e4:	4003      	ands	r3, r0
 800b1e6:	9301      	str	r3, [sp, #4]
 800b1e8:	9b01      	ldr	r3, [sp, #4]
 800b1ea:	6823      	ldr	r3, [r4, #0]

  /* Counter mode: select up-counting mode */
  LL_TIM_SetCounterMode(TIMx, LL_TIM_COUNTERMODE_UP);

  /* Set the pre-scaler value to have TIMx counter clock equal to 1 MHz */
  LL_TIM_SetPrescaler(TIMx, __LL_TIM_CALC_PSC(SystemCoreClock, 1000000));
 800b1ec:	2000      	movs	r0, #0
 800b1ee:	4393      	bics	r3, r2
 800b1f0:	6023      	str	r3, [r4, #0]
 800b1f2:	4b20      	ldr	r3, [pc, #128]	; (800b274 <USBPD_TIM_Init+0xa4>)
 800b1f4:	681d      	ldr	r5, [r3, #0]
 800b1f6:	4b20      	ldr	r3, [pc, #128]	; (800b278 <USBPD_TIM_Init+0xa8>)
 800b1f8:	429d      	cmp	r5, r3
 800b1fa:	d904      	bls.n	800b206 <USBPD_TIM_Init+0x36>
 800b1fc:	491f      	ldr	r1, [pc, #124]	; (800b27c <USBPD_TIM_Init+0xac>)
 800b1fe:	0028      	movs	r0, r5
 800b200:	f7fa fbd8 	bl	80059b4 <__udivsi3>
 800b204:	3801      	subs	r0, #1
  * @param  Prescaler between Min_Data=0 and Max_Data=65535
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
{
  WRITE_REG(TIMx->PSC, Prescaler);
 800b206:	62a0      	str	r0, [r4, #40]	; 0x28
  * @param  TIMx Timer instance
  * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
  */
__STATIC_INLINE uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
{
  return (uint32_t)(READ_REG(TIMx->PSC));
 800b208:	6aa1      	ldr	r1, [r4, #40]	; 0x28

  /* Set the auto-reload value to have a counter frequency of 250Hz */
  LL_TIM_SetAutoReload(TIMx, __LL_TIM_CALC_ARR(SystemCoreClock, LL_TIM_GetPrescaler(TIMx), 250));
 800b20a:	0028      	movs	r0, r5
 800b20c:	3101      	adds	r1, #1
 800b20e:	f7fa fbd1 	bl	80059b4 <__udivsi3>
 800b212:	2200      	movs	r2, #0
 800b214:	28f9      	cmp	r0, #249	; 0xf9
 800b216:	d907      	bls.n	800b228 <USBPD_TIM_Init+0x58>
 800b218:	21fa      	movs	r1, #250	; 0xfa
 800b21a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800b21c:	0028      	movs	r0, r5
 800b21e:	3301      	adds	r3, #1
 800b220:	4359      	muls	r1, r3
 800b222:	f7fa fbc7 	bl	80059b4 <__udivsi3>
 800b226:	1e42      	subs	r2, r0, #1
  * @param  AutoReload between Min_Data=0 and Max_Data=65535
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
{
  WRITE_REG(TIMx->ARR, AutoReload);
 800b228:	2380      	movs	r3, #128	; 0x80
 800b22a:	05db      	lsls	r3, r3, #23
 800b22c:	62da      	str	r2, [r3, #44]	; 0x2c
  */
__STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
{
  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
 800b22e:	4c14      	ldr	r4, [pc, #80]	; (800b280 <USBPD_TIM_Init+0xb0>)
 800b230:	699a      	ldr	r2, [r3, #24]
 800b232:	4914      	ldr	r1, [pc, #80]	; (800b284 <USBPD_TIM_Init+0xb4>)
 800b234:	4022      	ands	r2, r4
 800b236:	430a      	orrs	r2, r1
  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
 800b238:	4813      	ldr	r0, [pc, #76]	; (800b288 <USBPD_TIM_Init+0xb8>)
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
 800b23a:	619a      	str	r2, [r3, #24]
 800b23c:	6842      	ldr	r2, [r0, #4]
 800b23e:	4014      	ands	r4, r2
 800b240:	4321      	orrs	r1, r4
 800b242:	6041      	str	r1, [r0, #4]
  * @retval None
  */
__STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
{
  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
  MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
 800b244:	2102      	movs	r1, #2
 800b246:	6a1a      	ldr	r2, [r3, #32]
 800b248:	438a      	bics	r2, r1
 800b24a:	621a      	str	r2, [r3, #32]
 800b24c:	6a1a      	ldr	r2, [r3, #32]
 800b24e:	311e      	adds	r1, #30
 800b250:	438a      	bics	r2, r1
 800b252:	621a      	str	r2, [r3, #32]
 800b254:	6a1a      	ldr	r2, [r3, #32]
 800b256:	490d      	ldr	r1, [pc, #52]	; (800b28c <USBPD_TIM_Init+0xbc>)
 800b258:	400a      	ands	r2, r1
 800b25a:	621a      	str	r2, [r3, #32]
 800b25c:	6a1a      	ldr	r2, [r3, #32]
 800b25e:	490c      	ldr	r1, [pc, #48]	; (800b290 <USBPD_TIM_Init+0xc0>)
 800b260:	400a      	ands	r2, r1
 800b262:	621a      	str	r2, [r3, #32]
  SET_BIT(TIMx->CR1, TIM_CR1_CEN);
 800b264:	2201      	movs	r2, #1
 800b266:	6819      	ldr	r1, [r3, #0]
 800b268:	430a      	orrs	r2, r1
 800b26a:	601a      	str	r2, [r3, #0]
  LL_TIM_OC_SetPolarity(TIMx, LL_TIM_CHANNEL_CH3, LL_TIM_OCPOLARITY_HIGH);
  LL_TIM_OC_SetPolarity(TIMx, LL_TIM_CHANNEL_CH4, LL_TIM_OCPOLARITY_HIGH);

  /* Enable counter */
  LL_TIM_EnableCounter(TIMx);
}
 800b26c:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
 800b26e:	46c0      	nop			; (mov r8, r8)
 800b270:	40021000 	.word	0x40021000
 800b274:	20000054 	.word	0x20000054
 800b278:	000f423f 	.word	0x000f423f
 800b27c:	000f4240 	.word	0x000f4240
 800b280:	ffff8c8c 	.word	0xffff8c8c
 800b284:	00003030 	.word	0x00003030
 800b288:	40000018 	.word	0x40000018
 800b28c:	fffffdff 	.word	0xfffffdff
 800b290:	ffffdfff 	.word	0xffffdfff

0800b294 <USBPD_TIM_Start>:
  * @param  id Timer Operation Identifier
  * @param  us_time time in micro-seconds
  * @retval None
  */
void USBPD_TIM_Start(TIM_identifier id, uint16_t us_time)
{
 800b294:	b510      	push	{r4, lr}
  switch (id)
 800b296:	2803      	cmp	r0, #3
 800b298:	d80f      	bhi.n	800b2ba <USBPD_TIM_Start+0x26>
 800b29a:	2480      	movs	r4, #128	; 0x80
 800b29c:	05e4      	lsls	r4, r4, #23
 800b29e:	f7fa fb7f 	bl	80059a0 <__gnu_thumb1_case_uqi>
 800b2a2:	0d02      	.short	0x0d02
 800b2a4:	1f16      	.short	0x1f16
  {
    case TIM_PORT0_CRC:
      LL_TIM_OC_SetCompareCH1(TIMx, (us_time + TIMx->CNT) % 4000);
 800b2a6:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b2a8:	1808      	adds	r0, r1, r0
 800b2aa:	21fa      	movs	r1, #250	; 0xfa
 800b2ac:	0109      	lsls	r1, r1, #4
 800b2ae:	f7fa fc07 	bl	8005ac0 <__aeabi_uidivmod>
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx)
{
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
 800b2b2:	2303      	movs	r3, #3
  WRITE_REG(TIMx->CCR1, CompareValue);
 800b2b4:	6361      	str	r1, [r4, #52]	; 0x34
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx)
{
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
 800b2b6:	425b      	negs	r3, r3
 800b2b8:	6123      	str	r3, [r4, #16]
      LL_TIM_ClearFlag_CC4(TIMx);
      break;
    default:
      break;
  }
}
 800b2ba:	bd10      	pop	{r4, pc}
      LL_TIM_OC_SetCompareCH2(TIMx, (us_time + TIMx->CNT) % 4000);
 800b2bc:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b2be:	1808      	adds	r0, r1, r0
 800b2c0:	21fa      	movs	r1, #250	; 0xfa
 800b2c2:	0109      	lsls	r1, r1, #4
 800b2c4:	f7fa fbfc 	bl	8005ac0 <__aeabi_uidivmod>
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC2IF));
 800b2c8:	2305      	movs	r3, #5
  WRITE_REG(TIMx->CCR2, CompareValue);
 800b2ca:	63a1      	str	r1, [r4, #56]	; 0x38
 800b2cc:	e7f3      	b.n	800b2b6 <USBPD_TIM_Start+0x22>
      LL_TIM_OC_SetCompareCH3(TIMx, (us_time + TIMx->CNT) % 4000);
 800b2ce:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b2d0:	1808      	adds	r0, r1, r0
 800b2d2:	21fa      	movs	r1, #250	; 0xfa
 800b2d4:	0109      	lsls	r1, r1, #4
 800b2d6:	f7fa fbf3 	bl	8005ac0 <__aeabi_uidivmod>
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC3IF));
 800b2da:	2309      	movs	r3, #9
  WRITE_REG(TIMx->CCR3, CompareValue);
 800b2dc:	63e1      	str	r1, [r4, #60]	; 0x3c
 800b2de:	e7ea      	b.n	800b2b6 <USBPD_TIM_Start+0x22>
      LL_TIM_OC_SetCompareCH4(TIMx, (us_time + TIMx->CNT) % 4000);
 800b2e0:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b2e2:	1808      	adds	r0, r1, r0
 800b2e4:	21fa      	movs	r1, #250	; 0xfa
 800b2e6:	0109      	lsls	r1, r1, #4
 800b2e8:	f7fa fbea 	bl	8005ac0 <__aeabi_uidivmod>
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
 800b2ec:	2311      	movs	r3, #17
  WRITE_REG(TIMx->CCR4, CompareValue);
 800b2ee:	6421      	str	r1, [r4, #64]	; 0x40
 800b2f0:	e7e1      	b.n	800b2b6 <USBPD_TIM_Start+0x22>

0800b2f2 <USBPD_TIM_IsExpired>:
  * @brief  Retrieve the TIMERSERVER status for a specified id
  * @param  id Timer Operation Identifier
  * @retval State of bit (1 or 0).
  */
uint8_t USBPD_TIM_IsExpired(TIM_identifier id)
{
 800b2f2:	b500      	push	{lr}
    case TIM_PORT1_RETRY:
      return LL_TIM_IsActiveFlag_CC4(TIMx);
    default:
      break;
  }
  return 1;
 800b2f4:	2301      	movs	r3, #1
  switch (id)
 800b2f6:	2803      	cmp	r0, #3
 800b2f8:	d808      	bhi.n	800b30c <USBPD_TIM_IsExpired+0x1a>
 800b2fa:	2280      	movs	r2, #128	; 0x80
 800b2fc:	05d2      	lsls	r2, r2, #23
  * @param  TIMx Timer instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx)
{
  return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
 800b2fe:	6912      	ldr	r2, [r2, #16]
 800b300:	f7fa fb4e 	bl	80059a0 <__gnu_thumb1_case_uqi>
 800b304:	0a080602 	.word	0x0a080602
  return (READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF));
 800b308:	0852      	lsrs	r2, r2, #1
      return LL_TIM_IsActiveFlag_CC4(TIMx);
 800b30a:	4013      	ands	r3, r2
}
 800b30c:	0018      	movs	r0, r3
 800b30e:	bd00      	pop	{pc}
  return (READ_BIT(TIMx->SR, TIM_SR_CC2IF) == (TIM_SR_CC2IF));
 800b310:	0892      	lsrs	r2, r2, #2
 800b312:	e7fa      	b.n	800b30a <USBPD_TIM_IsExpired+0x18>
  return (READ_BIT(TIMx->SR, TIM_SR_CC3IF) == (TIM_SR_CC3IF));
 800b314:	08d2      	lsrs	r2, r2, #3
 800b316:	e7f8      	b.n	800b30a <USBPD_TIM_IsExpired+0x18>
  return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
 800b318:	0912      	lsrs	r2, r2, #4
 800b31a:	e7f6      	b.n	800b30a <USBPD_TIM_IsExpired+0x18>

0800b31c <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 800b31c:	b510      	push	{r4, lr}
  vTaskStartScheduler();
 800b31e:	f000 fc67 	bl	800bbf0 <vTaskStartScheduler>
  
  return osOK;
}
 800b322:	2000      	movs	r0, #0
 800b324:	bd10      	pop	{r4, pc}

0800b326 <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 800b326:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b328:	6902      	ldr	r2, [r0, #16]
{
 800b32a:	000b      	movs	r3, r1
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b32c:	6846      	ldr	r6, [r0, #4]
 800b32e:	6801      	ldr	r1, [r0, #0]
 800b330:	2508      	movs	r5, #8
 800b332:	5f45      	ldrsh	r5, [r0, r5]
 800b334:	b292      	uxth	r2, r2
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 800b336:	2400      	movs	r4, #0
  if (priority != osPriorityError) {
 800b338:	2d84      	cmp	r5, #132	; 0x84
 800b33a:	d000      	beq.n	800b33e <osThreadCreate+0x18>
    fpriority += (priority - osPriorityIdle);
 800b33c:	1cec      	adds	r4, r5, #3
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b33e:	a803      	add	r0, sp, #12
 800b340:	9001      	str	r0, [sp, #4]
 800b342:	9400      	str	r4, [sp, #0]
 800b344:	0030      	movs	r0, r6
 800b346:	f000 fb63 	bl	800ba10 <xTaskCreate>
                   thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
                   &handle) != pdPASS)  {
    return NULL;
 800b34a:	2300      	movs	r3, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b34c:	2801      	cmp	r0, #1
 800b34e:	d100      	bne.n	800b352 <osThreadCreate+0x2c>
  }     
#endif
  
  return handle;
 800b350:	9b03      	ldr	r3, [sp, #12]
}
 800b352:	0018      	movs	r0, r3
 800b354:	b004      	add	sp, #16
 800b356:	bd70      	pop	{r4, r5, r6, pc}

0800b358 <osThreadTerminate>:
* @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osThreadTerminate shall be consistent in every CMSIS-RTOS.
*/
osStatus osThreadTerminate (osThreadId thread_id)
{
 800b358:	b510      	push	{r4, lr}
#if (INCLUDE_vTaskDelete == 1)
  vTaskDelete(thread_id);
 800b35a:	f000 fc07 	bl	800bb6c <vTaskDelete>
  return osOK;
#else
  return osErrorOS;
#endif
}
 800b35e:	2000      	movs	r0, #0
 800b360:	bd10      	pop	{r4, pc}

0800b362 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 800b362:	b510      	push	{r4, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 800b364:	2800      	cmp	r0, #0
 800b366:	d100      	bne.n	800b36a <osDelay+0x8>
 800b368:	3001      	adds	r0, #1
 800b36a:	f000 fd31 	bl	800bdd0 <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 800b36e:	2000      	movs	r0, #0
 800b370:	bd10      	pop	{r4, pc}

0800b372 <osMessageCreate>:
* @param  thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval  message queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS.
*/
osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
{
 800b372:	b510      	push	{r4, lr}
    return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
  }
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
#else  
  return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
 800b374:	6841      	ldr	r1, [r0, #4]
 800b376:	2200      	movs	r2, #0
 800b378:	6800      	ldr	r0, [r0, #0]
 800b37a:	f000 f94f 	bl	800b61c <xQueueGenericCreate>
#endif
}
 800b37e:	bd10      	pop	{r4, pc}

0800b380 <osMessagePut>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
*/
osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
 800b380:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  portBASE_TYPE taskWoken = pdFALSE;
 800b382:	2300      	movs	r3, #0
{
 800b384:	9101      	str	r1, [sp, #4]
  portBASE_TYPE taskWoken = pdFALSE;
 800b386:	9303      	str	r3, [sp, #12]
  TickType_t ticks;
  
  ticks = millisec / portTICK_PERIOD_MS;
  if (ticks == 0) {
 800b388:	429a      	cmp	r2, r3
 800b38a:	d100      	bne.n	800b38e <osMessagePut+0xe>
    ticks = 1;
 800b38c:	2201      	movs	r2, #1
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b38e:	f3ef 8305 	mrs	r3, IPSR
  }
  
  if (inHandlerMode()) {
 800b392:	2b00      	cmp	r3, #0
 800b394:	d012      	beq.n	800b3bc <osMessagePut+0x3c>
    if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
 800b396:	2300      	movs	r3, #0
 800b398:	aa03      	add	r2, sp, #12
 800b39a:	a901      	add	r1, sp, #4
 800b39c:	f000 f9e3 	bl	800b766 <xQueueGenericSendFromISR>
 800b3a0:	2801      	cmp	r0, #1
 800b3a2:	d002      	beq.n	800b3aa <osMessagePut+0x2a>
      return osErrorOS;
 800b3a4:	20ff      	movs	r0, #255	; 0xff
      return osErrorOS;
    }
  }
  
  return osOK;
}
 800b3a6:	b005      	add	sp, #20
 800b3a8:	bd00      	pop	{pc}
    portEND_SWITCHING_ISR(taskWoken);
 800b3aa:	9b03      	ldr	r3, [sp, #12]
 800b3ac:	2b00      	cmp	r3, #0
 800b3ae:	d003      	beq.n	800b3b8 <osMessagePut+0x38>
 800b3b0:	2280      	movs	r2, #128	; 0x80
 800b3b2:	4b05      	ldr	r3, [pc, #20]	; (800b3c8 <osMessagePut+0x48>)
 800b3b4:	0552      	lsls	r2, r2, #21
 800b3b6:	601a      	str	r2, [r3, #0]
  return osOK;
 800b3b8:	2000      	movs	r0, #0
 800b3ba:	e7f4      	b.n	800b3a6 <osMessagePut+0x26>
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
 800b3bc:	a901      	add	r1, sp, #4
 800b3be:	f000 f94a 	bl	800b656 <xQueueGenericSend>
 800b3c2:	2801      	cmp	r0, #1
 800b3c4:	d0f8      	beq.n	800b3b8 <osMessagePut+0x38>
 800b3c6:	e7ed      	b.n	800b3a4 <osMessagePut+0x24>
 800b3c8:	e000ed04 	.word	0xe000ed04

0800b3cc <osMessageGet>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval event information that includes status code.
* @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
*/
osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
{
 800b3cc:	b5f0      	push	{r4, r5, r6, r7, lr}
  portBASE_TYPE taskWoken;
  TickType_t ticks;
  osEvent event;
  
  event.def.message_id = queue_id;
  event.value.v = 0;
 800b3ce:	2700      	movs	r7, #0
{
 800b3d0:	b085      	sub	sp, #20
  event.def.message_id = queue_id;
 800b3d2:	ac01      	add	r4, sp, #4
{
 800b3d4:	0005      	movs	r5, r0
 800b3d6:	0016      	movs	r6, r2
 800b3d8:	0008      	movs	r0, r1
  event.def.message_id = queue_id;
 800b3da:	60a1      	str	r1, [r4, #8]
  event.value.v = 0;
 800b3dc:	6067      	str	r7, [r4, #4]
  
  if (queue_id == NULL) {
 800b3de:	42b9      	cmp	r1, r7
 800b3e0:	d107      	bne.n	800b3f2 <osMessageGet+0x26>
    event.status = osErrorParameter;
 800b3e2:	2380      	movs	r3, #128	; 0x80
 800b3e4:	9301      	str	r3, [sp, #4]
    else {
      event.status = (ticks == 0) ? osOK : osEventTimeout;
    }
  }
  
  return event;
 800b3e6:	002b      	movs	r3, r5
 800b3e8:	cc07      	ldmia	r4!, {r0, r1, r2}
 800b3ea:	c307      	stmia	r3!, {r0, r1, r2}
}
 800b3ec:	0028      	movs	r0, r5
 800b3ee:	b005      	add	sp, #20
 800b3f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  taskWoken = pdFALSE;
 800b3f2:	9700      	str	r7, [sp, #0]
 800b3f4:	f3ef 8305 	mrs	r3, IPSR
  if (inHandlerMode()) {
 800b3f8:	2b00      	cmp	r3, #0
 800b3fa:	d011      	beq.n	800b420 <osMessageGet+0x54>
    if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
 800b3fc:	466a      	mov	r2, sp
 800b3fe:	a902      	add	r1, sp, #8
 800b400:	f000 fa8a 	bl	800b918 <xQueueReceiveFromISR>
 800b404:	2801      	cmp	r0, #1
 800b406:	d109      	bne.n	800b41c <osMessageGet+0x50>
      event.status = osEventMessage;
 800b408:	2310      	movs	r3, #16
 800b40a:	6023      	str	r3, [r4, #0]
    portEND_SWITCHING_ISR(taskWoken);
 800b40c:	9b00      	ldr	r3, [sp, #0]
 800b40e:	2b00      	cmp	r3, #0
 800b410:	d0e9      	beq.n	800b3e6 <osMessageGet+0x1a>
 800b412:	2280      	movs	r2, #128	; 0x80
 800b414:	4b09      	ldr	r3, [pc, #36]	; (800b43c <osMessageGet+0x70>)
 800b416:	0552      	lsls	r2, r2, #21
 800b418:	601a      	str	r2, [r3, #0]
 800b41a:	e7e4      	b.n	800b3e6 <osMessageGet+0x1a>
      event.status = osOK;
 800b41c:	6027      	str	r7, [r4, #0]
 800b41e:	e7f5      	b.n	800b40c <osMessageGet+0x40>
    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
 800b420:	a902      	add	r1, sp, #8
 800b422:	f000 f9e9 	bl	800b7f8 <xQueueGenericReceive>
 800b426:	2801      	cmp	r0, #1
 800b428:	d102      	bne.n	800b430 <osMessageGet+0x64>
      event.status = osEventMessage;
 800b42a:	2310      	movs	r3, #16
 800b42c:	6023      	str	r3, [r4, #0]
 800b42e:	e7da      	b.n	800b3e6 <osMessageGet+0x1a>
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 800b430:	1e73      	subs	r3, r6, #1
 800b432:	419e      	sbcs	r6, r3
 800b434:	01b6      	lsls	r6, r6, #6
 800b436:	9601      	str	r6, [sp, #4]
 800b438:	e7d5      	b.n	800b3e6 <osMessageGet+0x1a>
 800b43a:	46c0      	nop			; (mov r8, r8)
 800b43c:	e000ed04 	.word	0xe000ed04

0800b440 <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 800b440:	b510      	push	{r4, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
  {
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
 800b442:	f000 ff0f 	bl	800c264 <xPortSysTickHandler>
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 800b446:	bd10      	pop	{r4, pc}

0800b448 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800b448:	0003      	movs	r3, r0

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800b44a:	2201      	movs	r2, #1
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800b44c:	3308      	adds	r3, #8
 800b44e:	6043      	str	r3, [r0, #4]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800b450:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800b452:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800b454:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800b456:	4252      	negs	r2, r2
 800b458:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800b45a:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800b45c:	4770      	bx	lr

0800b45e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 800b45e:	2300      	movs	r3, #0
 800b460:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 800b462:	4770      	bx	lr

0800b464 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 800b464:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800b466:	689a      	ldr	r2, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 800b468:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800b46a:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800b46c:	689a      	ldr	r2, [r3, #8]
 800b46e:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800b470:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800b472:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800b474:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800b476:	3301      	adds	r3, #1
 800b478:	6003      	str	r3, [r0, #0]
}
 800b47a:	4770      	bx	lr

0800b47c <vListInsert>:
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800b47c:	0003      	movs	r3, r0
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800b47e:	680a      	ldr	r2, [r1, #0]
{
 800b480:	b530      	push	{r4, r5, lr}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800b482:	3308      	adds	r3, #8
	if( xValueOfInsertion == portMAX_DELAY )
 800b484:	1c54      	adds	r4, r2, #1
 800b486:	d10b      	bne.n	800b4a0 <vListInsert+0x24>
		pxIterator = pxList->xListEnd.pxPrevious;
 800b488:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800b48a:	685a      	ldr	r2, [r3, #4]
 800b48c:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 800b48e:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 800b490:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 800b492:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800b494:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800b496:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800b498:	3301      	adds	r3, #1
 800b49a:	6003      	str	r3, [r0, #0]
}
 800b49c:	bd30      	pop	{r4, r5, pc}
 800b49e:	0023      	movs	r3, r4
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800b4a0:	685c      	ldr	r4, [r3, #4]
 800b4a2:	6825      	ldr	r5, [r4, #0]
 800b4a4:	4295      	cmp	r5, r2
 800b4a6:	d9fa      	bls.n	800b49e <vListInsert+0x22>
 800b4a8:	e7ef      	b.n	800b48a <vListInsert+0xe>

0800b4aa <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800b4aa:	6841      	ldr	r1, [r0, #4]
 800b4ac:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 800b4ae:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800b4b0:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800b4b2:	6882      	ldr	r2, [r0, #8]
 800b4b4:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800b4b6:	6859      	ldr	r1, [r3, #4]
 800b4b8:	4281      	cmp	r1, r0
 800b4ba:	d100      	bne.n	800b4be <uxListRemove+0x14>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800b4bc:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 800b4be:	2200      	movs	r2, #0
 800b4c0:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 800b4c2:	681a      	ldr	r2, [r3, #0]
 800b4c4:	1e50      	subs	r0, r2, #1
 800b4c6:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 800b4c8:	4770      	bx	lr

0800b4ca <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 800b4ca:	b570      	push	{r4, r5, r6, lr}
 800b4cc:	0016      	movs	r6, r2

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800b4ce:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
 800b4d0:	0004      	movs	r4, r0
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800b4d2:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800b4d4:	2a00      	cmp	r2, #0
 800b4d6:	d00d      	beq.n	800b4f4 <prvCopyDataToQueue+0x2a>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 800b4d8:	2e00      	cmp	r6, #0
 800b4da:	d10f      	bne.n	800b4fc <prvCopyDataToQueue+0x32>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 800b4dc:	6880      	ldr	r0, [r0, #8]
 800b4de:	f001 f805 	bl	800c4ec <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800b4e2:	68a3      	ldr	r3, [r4, #8]
 800b4e4:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800b4e6:	189b      	adds	r3, r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800b4e8:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800b4ea:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800b4ec:	4293      	cmp	r3, r2
 800b4ee:	d301      	bcc.n	800b4f4 <prvCopyDataToQueue+0x2a>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800b4f0:	6823      	ldr	r3, [r4, #0]
 800b4f2:	60a3      	str	r3, [r4, #8]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 800b4f4:	3501      	adds	r5, #1
 800b4f6:	63a5      	str	r5, [r4, #56]	; 0x38

	return xReturn;
}
 800b4f8:	2000      	movs	r0, #0
 800b4fa:	bd70      	pop	{r4, r5, r6, pc}
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800b4fc:	68c0      	ldr	r0, [r0, #12]
 800b4fe:	f000 fff5 	bl	800c4ec <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800b502:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800b504:	68e2      	ldr	r2, [r4, #12]
 800b506:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800b508:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800b50a:	18d2      	adds	r2, r2, r3
 800b50c:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800b50e:	428a      	cmp	r2, r1
 800b510:	d202      	bcs.n	800b518 <prvCopyDataToQueue+0x4e>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 800b512:	6862      	ldr	r2, [r4, #4]
 800b514:	18d3      	adds	r3, r2, r3
 800b516:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 800b518:	2e02      	cmp	r6, #2
 800b51a:	d1eb      	bne.n	800b4f4 <prvCopyDataToQueue+0x2a>
				--uxMessagesWaiting;
 800b51c:	002b      	movs	r3, r5
 800b51e:	1e5a      	subs	r2, r3, #1
 800b520:	4193      	sbcs	r3, r2
 800b522:	1aed      	subs	r5, r5, r3
 800b524:	e7e6      	b.n	800b4f4 <prvCopyDataToQueue+0x2a>

0800b526 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 800b526:	0003      	movs	r3, r0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800b528:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
 800b52a:	b510      	push	{r4, lr}
 800b52c:	0008      	movs	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800b52e:	2a00      	cmp	r2, #0
 800b530:	d00a      	beq.n	800b548 <prvCopyDataFromQueue+0x22>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800b532:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800b534:	685c      	ldr	r4, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800b536:	1889      	adds	r1, r1, r2
 800b538:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800b53a:	42a1      	cmp	r1, r4
 800b53c:	d301      	bcc.n	800b542 <prvCopyDataFromQueue+0x1c>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 800b53e:	6819      	ldr	r1, [r3, #0]
 800b540:	60d9      	str	r1, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 800b542:	68d9      	ldr	r1, [r3, #12]
 800b544:	f000 ffd2 	bl	800c4ec <memcpy>
	}
}
 800b548:	bd10      	pop	{r4, pc}

0800b54a <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 800b54a:	b570      	push	{r4, r5, r6, lr}
 800b54c:	0005      	movs	r5, r0
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;
 800b54e:	002e      	movs	r6, r5
 800b550:	3645      	adds	r6, #69	; 0x45
	taskENTER_CRITICAL();
 800b552:	f000 fe3d 	bl	800c1d0 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 800b556:	7834      	ldrb	r4, [r6, #0]
 800b558:	b264      	sxtb	r4, r4

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800b55a:	2c00      	cmp	r4, #0
 800b55c:	dc10      	bgt.n	800b580 <prvUnlockQueue+0x36>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 800b55e:	23ff      	movs	r3, #255	; 0xff
 800b560:	7033      	strb	r3, [r6, #0]
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;
 800b562:	002e      	movs	r6, r5
 800b564:	3644      	adds	r6, #68	; 0x44
	taskEXIT_CRITICAL();
 800b566:	f000 fe3f 	bl	800c1e8 <vPortExitCritical>
	taskENTER_CRITICAL();
 800b56a:	f000 fe31 	bl	800c1d0 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 800b56e:	7834      	ldrb	r4, [r6, #0]
 800b570:	b264      	sxtb	r4, r4

		while( cRxLock > queueLOCKED_UNMODIFIED )
 800b572:	2c00      	cmp	r4, #0
 800b574:	dc11      	bgt.n	800b59a <prvUnlockQueue+0x50>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 800b576:	23ff      	movs	r3, #255	; 0xff
 800b578:	7033      	strb	r3, [r6, #0]
	}
	taskEXIT_CRITICAL();
 800b57a:	f000 fe35 	bl	800c1e8 <vPortExitCritical>
}
 800b57e:	bd70      	pop	{r4, r5, r6, pc}
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800b580:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800b582:	2b00      	cmp	r3, #0
 800b584:	d0eb      	beq.n	800b55e <prvUnlockQueue+0x14>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800b586:	0028      	movs	r0, r5
 800b588:	3024      	adds	r0, #36	; 0x24
 800b58a:	f000 fcad 	bl	800bee8 <xTaskRemoveFromEventList>
 800b58e:	2800      	cmp	r0, #0
 800b590:	d001      	beq.n	800b596 <prvUnlockQueue+0x4c>
						vTaskMissedYield();
 800b592:	f000 fd1d 	bl	800bfd0 <vTaskMissedYield>
 800b596:	3c01      	subs	r4, #1
 800b598:	e7de      	b.n	800b558 <prvUnlockQueue+0xe>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800b59a:	692b      	ldr	r3, [r5, #16]
 800b59c:	2b00      	cmp	r3, #0
 800b59e:	d0ea      	beq.n	800b576 <prvUnlockQueue+0x2c>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800b5a0:	0028      	movs	r0, r5
 800b5a2:	3010      	adds	r0, #16
 800b5a4:	f000 fca0 	bl	800bee8 <xTaskRemoveFromEventList>
 800b5a8:	2800      	cmp	r0, #0
 800b5aa:	d001      	beq.n	800b5b0 <prvUnlockQueue+0x66>
					vTaskMissedYield();
 800b5ac:	f000 fd10 	bl	800bfd0 <vTaskMissedYield>
 800b5b0:	3c01      	subs	r4, #1
 800b5b2:	e7dd      	b.n	800b570 <prvUnlockQueue+0x26>

0800b5b4 <xQueueGenericReset>:
{
 800b5b4:	b570      	push	{r4, r5, r6, lr}
 800b5b6:	0004      	movs	r4, r0
 800b5b8:	000d      	movs	r5, r1
	configASSERT( pxQueue );
 800b5ba:	2800      	cmp	r0, #0
 800b5bc:	d101      	bne.n	800b5c2 <xQueueGenericReset+0xe>
 800b5be:	b672      	cpsid	i
 800b5c0:	e7fe      	b.n	800b5c0 <xQueueGenericReset+0xc>
	taskENTER_CRITICAL();
 800b5c2:	f000 fe05 	bl	800c1d0 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800b5c6:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800b5c8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b5ca:	6822      	ldr	r2, [r4, #0]
 800b5cc:	434b      	muls	r3, r1
 800b5ce:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 800b5d0:	1a5b      	subs	r3, r3, r1
 800b5d2:	18d3      	adds	r3, r2, r3
 800b5d4:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 800b5d6:	0023      	movs	r3, r4
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800b5d8:	6060      	str	r0, [r4, #4]
		pxQueue->pcWriteTo = pxQueue->pcHead;
 800b5da:	60a2      	str	r2, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800b5dc:	2000      	movs	r0, #0
		pxQueue->cRxLock = queueUNLOCKED;
 800b5de:	22ff      	movs	r2, #255	; 0xff
 800b5e0:	3344      	adds	r3, #68	; 0x44
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800b5e2:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 800b5e4:	701a      	strb	r2, [r3, #0]
		pxQueue->cTxLock = queueUNLOCKED;
 800b5e6:	705a      	strb	r2, [r3, #1]
		if( xNewQueue == pdFALSE )
 800b5e8:	4285      	cmp	r5, r0
 800b5ea:	d10e      	bne.n	800b60a <xQueueGenericReset+0x56>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800b5ec:	6923      	ldr	r3, [r4, #16]
 800b5ee:	4283      	cmp	r3, r0
 800b5f0:	d007      	beq.n	800b602 <xQueueGenericReset+0x4e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800b5f2:	0020      	movs	r0, r4
 800b5f4:	3010      	adds	r0, #16
 800b5f6:	f000 fc77 	bl	800bee8 <xTaskRemoveFromEventList>
 800b5fa:	2800      	cmp	r0, #0
 800b5fc:	d001      	beq.n	800b602 <xQueueGenericReset+0x4e>
					queueYIELD_IF_USING_PREEMPTION();
 800b5fe:	f000 fddb 	bl	800c1b8 <vPortYield>
	taskEXIT_CRITICAL();
 800b602:	f000 fdf1 	bl	800c1e8 <vPortExitCritical>
}
 800b606:	2001      	movs	r0, #1
 800b608:	bd70      	pop	{r4, r5, r6, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800b60a:	0020      	movs	r0, r4
 800b60c:	3010      	adds	r0, #16
 800b60e:	f7ff ff1b 	bl	800b448 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 800b612:	0020      	movs	r0, r4
 800b614:	3024      	adds	r0, #36	; 0x24
 800b616:	f7ff ff17 	bl	800b448 <vListInitialise>
 800b61a:	e7f2      	b.n	800b602 <xQueueGenericReset+0x4e>

0800b61c <xQueueGenericCreate>:
	{
 800b61c:	b570      	push	{r4, r5, r6, lr}
 800b61e:	0006      	movs	r6, r0
 800b620:	000d      	movs	r5, r1
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 800b622:	2800      	cmp	r0, #0
 800b624:	d101      	bne.n	800b62a <xQueueGenericCreate+0xe>
 800b626:	b672      	cpsid	i
 800b628:	e7fe      	b.n	800b628 <xQueueGenericCreate+0xc>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800b62a:	0008      	movs	r0, r1
 800b62c:	4370      	muls	r0, r6
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 800b62e:	3048      	adds	r0, #72	; 0x48
 800b630:	f000 fcf6 	bl	800c020 <pvPortMalloc>
 800b634:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
 800b636:	d008      	beq.n	800b64a <xQueueGenericCreate+0x2e>
	if( uxItemSize == ( UBaseType_t ) 0 )
 800b638:	2d00      	cmp	r5, #0
 800b63a:	d108      	bne.n	800b64e <xQueueGenericCreate+0x32>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800b63c:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 800b63e:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 800b640:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800b642:	2101      	movs	r1, #1
 800b644:	0020      	movs	r0, r4
 800b646:	f7ff ffb5 	bl	800b5b4 <xQueueGenericReset>
	}
 800b64a:	0020      	movs	r0, r4
 800b64c:	bd70      	pop	{r4, r5, r6, pc}
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 800b64e:	0003      	movs	r3, r0
 800b650:	3348      	adds	r3, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 800b652:	6003      	str	r3, [r0, #0]
 800b654:	e7f3      	b.n	800b63e <xQueueGenericCreate+0x22>

0800b656 <xQueueGenericSend>:
{
 800b656:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b658:	b085      	sub	sp, #20
 800b65a:	0004      	movs	r4, r0
 800b65c:	000f      	movs	r7, r1
 800b65e:	9201      	str	r2, [sp, #4]
 800b660:	001e      	movs	r6, r3
	configASSERT( pxQueue );
 800b662:	2800      	cmp	r0, #0
 800b664:	d101      	bne.n	800b66a <xQueueGenericSend+0x14>
 800b666:	b672      	cpsid	i
 800b668:	e7fe      	b.n	800b668 <xQueueGenericSend+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800b66a:	2900      	cmp	r1, #0
 800b66c:	d104      	bne.n	800b678 <xQueueGenericSend+0x22>
 800b66e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800b670:	2b00      	cmp	r3, #0
 800b672:	d001      	beq.n	800b678 <xQueueGenericSend+0x22>
 800b674:	b672      	cpsid	i
 800b676:	e7fe      	b.n	800b676 <xQueueGenericSend+0x20>
 800b678:	2300      	movs	r3, #0
 800b67a:	9300      	str	r3, [sp, #0]
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800b67c:	2e02      	cmp	r6, #2
 800b67e:	d14f      	bne.n	800b720 <xQueueGenericSend+0xca>
 800b680:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b682:	2b01      	cmp	r3, #1
 800b684:	d04c      	beq.n	800b720 <xQueueGenericSend+0xca>
 800b686:	b672      	cpsid	i
 800b688:	e7fe      	b.n	800b688 <xQueueGenericSend+0x32>
				if( xTicksToWait == ( TickType_t ) 0 )
 800b68a:	9d01      	ldr	r5, [sp, #4]
 800b68c:	2d00      	cmp	r5, #0
 800b68e:	d103      	bne.n	800b698 <xQueueGenericSend+0x42>
					taskEXIT_CRITICAL();
 800b690:	f000 fdaa 	bl	800c1e8 <vPortExitCritical>
			return errQUEUE_FULL;
 800b694:	2000      	movs	r0, #0
 800b696:	e05e      	b.n	800b756 <xQueueGenericSend+0x100>
				else if( xEntryTimeSet == pdFALSE )
 800b698:	9b00      	ldr	r3, [sp, #0]
 800b69a:	2b00      	cmp	r3, #0
 800b69c:	d102      	bne.n	800b6a4 <xQueueGenericSend+0x4e>
					vTaskSetTimeOutState( &xTimeOut );
 800b69e:	a802      	add	r0, sp, #8
 800b6a0:	f000 fc56 	bl	800bf50 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 800b6a4:	f000 fda0 	bl	800c1e8 <vPortExitCritical>
		vTaskSuspendAll();
 800b6a8:	f000 fac6 	bl	800bc38 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800b6ac:	f000 fd90 	bl	800c1d0 <vPortEnterCritical>
 800b6b0:	0022      	movs	r2, r4
 800b6b2:	3244      	adds	r2, #68	; 0x44
 800b6b4:	7813      	ldrb	r3, [r2, #0]
 800b6b6:	b25b      	sxtb	r3, r3
 800b6b8:	3301      	adds	r3, #1
 800b6ba:	d101      	bne.n	800b6c0 <xQueueGenericSend+0x6a>
 800b6bc:	2300      	movs	r3, #0
 800b6be:	7013      	strb	r3, [r2, #0]
 800b6c0:	0022      	movs	r2, r4
 800b6c2:	3245      	adds	r2, #69	; 0x45
 800b6c4:	7813      	ldrb	r3, [r2, #0]
 800b6c6:	b25b      	sxtb	r3, r3
 800b6c8:	3301      	adds	r3, #1
 800b6ca:	d101      	bne.n	800b6d0 <xQueueGenericSend+0x7a>
 800b6cc:	2300      	movs	r3, #0
 800b6ce:	7013      	strb	r3, [r2, #0]
 800b6d0:	f000 fd8a 	bl	800c1e8 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800b6d4:	a901      	add	r1, sp, #4
 800b6d6:	a802      	add	r0, sp, #8
 800b6d8:	f000 fc4a 	bl	800bf70 <xTaskCheckForTimeOut>
 800b6dc:	2800      	cmp	r0, #0
 800b6de:	d13c      	bne.n	800b75a <xQueueGenericSend+0x104>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 800b6e0:	f000 fd76 	bl	800c1d0 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800b6e4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b6e6:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800b6e8:	4293      	cmp	r3, r2
 800b6ea:	d110      	bne.n	800b70e <xQueueGenericSend+0xb8>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800b6ec:	f000 fd7c 	bl	800c1e8 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800b6f0:	0020      	movs	r0, r4
 800b6f2:	9901      	ldr	r1, [sp, #4]
 800b6f4:	3010      	adds	r0, #16
 800b6f6:	f000 fbe5 	bl	800bec4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800b6fa:	0020      	movs	r0, r4
 800b6fc:	f7ff ff25 	bl	800b54a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800b700:	f000 fb0e 	bl	800bd20 <xTaskResumeAll>
 800b704:	2800      	cmp	r0, #0
 800b706:	d109      	bne.n	800b71c <xQueueGenericSend+0xc6>
					portYIELD_WITHIN_API();
 800b708:	f000 fd56 	bl	800c1b8 <vPortYield>
 800b70c:	e006      	b.n	800b71c <xQueueGenericSend+0xc6>
	taskEXIT_CRITICAL();
 800b70e:	f000 fd6b 	bl	800c1e8 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 800b712:	0020      	movs	r0, r4
 800b714:	f7ff ff19 	bl	800b54a <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800b718:	f000 fb02 	bl	800bd20 <xTaskResumeAll>
 800b71c:	2301      	movs	r3, #1
 800b71e:	9300      	str	r3, [sp, #0]
		taskENTER_CRITICAL();
 800b720:	f000 fd56 	bl	800c1d0 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800b724:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b726:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800b728:	4293      	cmp	r3, r2
 800b72a:	d301      	bcc.n	800b730 <xQueueGenericSend+0xda>
 800b72c:	2e02      	cmp	r6, #2
 800b72e:	d1ac      	bne.n	800b68a <xQueueGenericSend+0x34>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800b730:	0032      	movs	r2, r6
 800b732:	0039      	movs	r1, r7
 800b734:	0020      	movs	r0, r4
 800b736:	f7ff fec8 	bl	800b4ca <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800b73a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800b73c:	2b00      	cmp	r3, #0
 800b73e:	d003      	beq.n	800b748 <xQueueGenericSend+0xf2>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800b740:	0020      	movs	r0, r4
 800b742:	3024      	adds	r0, #36	; 0x24
 800b744:	f000 fbd0 	bl	800bee8 <xTaskRemoveFromEventList>
 800b748:	2800      	cmp	r0, #0
 800b74a:	d001      	beq.n	800b750 <xQueueGenericSend+0xfa>
							queueYIELD_IF_USING_PREEMPTION();
 800b74c:	f000 fd34 	bl	800c1b8 <vPortYield>
				taskEXIT_CRITICAL();
 800b750:	f000 fd4a 	bl	800c1e8 <vPortExitCritical>
				return pdPASS;
 800b754:	2001      	movs	r0, #1
}
 800b756:	b005      	add	sp, #20
 800b758:	bdf0      	pop	{r4, r5, r6, r7, pc}
			prvUnlockQueue( pxQueue );
 800b75a:	0020      	movs	r0, r4
 800b75c:	f7ff fef5 	bl	800b54a <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800b760:	f000 fade 	bl	800bd20 <xTaskResumeAll>
 800b764:	e796      	b.n	800b694 <xQueueGenericSend+0x3e>

0800b766 <xQueueGenericSendFromISR>:
{
 800b766:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b768:	b085      	sub	sp, #20
 800b76a:	0004      	movs	r4, r0
 800b76c:	9101      	str	r1, [sp, #4]
 800b76e:	0017      	movs	r7, r2
 800b770:	001e      	movs	r6, r3
	configASSERT( pxQueue );
 800b772:	2800      	cmp	r0, #0
 800b774:	d101      	bne.n	800b77a <xQueueGenericSendFromISR+0x14>
 800b776:	b672      	cpsid	i
 800b778:	e7fe      	b.n	800b778 <xQueueGenericSendFromISR+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800b77a:	9b01      	ldr	r3, [sp, #4]
 800b77c:	2b00      	cmp	r3, #0
 800b77e:	d104      	bne.n	800b78a <xQueueGenericSendFromISR+0x24>
 800b780:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800b782:	2b00      	cmp	r3, #0
 800b784:	d001      	beq.n	800b78a <xQueueGenericSendFromISR+0x24>
 800b786:	b672      	cpsid	i
 800b788:	e7fe      	b.n	800b788 <xQueueGenericSendFromISR+0x22>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800b78a:	2e02      	cmp	r6, #2
 800b78c:	d104      	bne.n	800b798 <xQueueGenericSendFromISR+0x32>
 800b78e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b790:	2b01      	cmp	r3, #1
 800b792:	d001      	beq.n	800b798 <xQueueGenericSendFromISR+0x32>
 800b794:	b672      	cpsid	i
 800b796:	e7fe      	b.n	800b796 <xQueueGenericSendFromISR+0x30>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800b798:	f000 fd34 	bl	800c204 <ulSetInterruptMaskFromISR>
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800b79c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b79e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800b7a0:	9003      	str	r0, [sp, #12]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800b7a2:	4293      	cmp	r3, r2
 800b7a4:	d302      	bcc.n	800b7ac <xQueueGenericSendFromISR+0x46>
			xReturn = errQUEUE_FULL;
 800b7a6:	2500      	movs	r5, #0
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800b7a8:	2e02      	cmp	r6, #2
 800b7aa:	d11a      	bne.n	800b7e2 <xQueueGenericSendFromISR+0x7c>
			const int8_t cTxLock = pxQueue->cTxLock;
 800b7ac:	0023      	movs	r3, r4
 800b7ae:	3345      	adds	r3, #69	; 0x45
 800b7b0:	9302      	str	r3, [sp, #8]
 800b7b2:	781d      	ldrb	r5, [r3, #0]
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800b7b4:	0032      	movs	r2, r6
			const int8_t cTxLock = pxQueue->cTxLock;
 800b7b6:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800b7b8:	9901      	ldr	r1, [sp, #4]
 800b7ba:	0020      	movs	r0, r4
 800b7bc:	f7ff fe85 	bl	800b4ca <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 800b7c0:	1c6b      	adds	r3, r5, #1
 800b7c2:	d114      	bne.n	800b7ee <xQueueGenericSendFromISR+0x88>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800b7c4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800b7c6:	2b00      	cmp	r3, #0
 800b7c8:	d101      	bne.n	800b7ce <xQueueGenericSendFromISR+0x68>
			xReturn = pdPASS;
 800b7ca:	2501      	movs	r5, #1
 800b7cc:	e009      	b.n	800b7e2 <xQueueGenericSendFromISR+0x7c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800b7ce:	0020      	movs	r0, r4
 800b7d0:	3024      	adds	r0, #36	; 0x24
 800b7d2:	f000 fb89 	bl	800bee8 <xTaskRemoveFromEventList>
 800b7d6:	2800      	cmp	r0, #0
 800b7d8:	d0f7      	beq.n	800b7ca <xQueueGenericSendFromISR+0x64>
							if( pxHigherPriorityTaskWoken != NULL )
 800b7da:	2f00      	cmp	r7, #0
 800b7dc:	d0f5      	beq.n	800b7ca <xQueueGenericSendFromISR+0x64>
								*pxHigherPriorityTaskWoken = pdTRUE;
 800b7de:	2501      	movs	r5, #1
 800b7e0:	603d      	str	r5, [r7, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800b7e2:	9803      	ldr	r0, [sp, #12]
 800b7e4:	f000 fd13 	bl	800c20e <vClearInterruptMaskFromISR>
}
 800b7e8:	0028      	movs	r0, r5
 800b7ea:	b005      	add	sp, #20
 800b7ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800b7ee:	3501      	adds	r5, #1
 800b7f0:	9b02      	ldr	r3, [sp, #8]
 800b7f2:	b26d      	sxtb	r5, r5
 800b7f4:	701d      	strb	r5, [r3, #0]
 800b7f6:	e7e8      	b.n	800b7ca <xQueueGenericSendFromISR+0x64>

0800b7f8 <xQueueGenericReceive>:
{
 800b7f8:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b7fa:	b085      	sub	sp, #20
 800b7fc:	0004      	movs	r4, r0
 800b7fe:	000e      	movs	r6, r1
 800b800:	9201      	str	r2, [sp, #4]
 800b802:	9300      	str	r3, [sp, #0]
	configASSERT( pxQueue );
 800b804:	2800      	cmp	r0, #0
 800b806:	d101      	bne.n	800b80c <xQueueGenericReceive+0x14>
 800b808:	b672      	cpsid	i
 800b80a:	e7fe      	b.n	800b80a <xQueueGenericReceive+0x12>
 800b80c:	2700      	movs	r7, #0
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800b80e:	42b9      	cmp	r1, r7
 800b810:	d155      	bne.n	800b8be <xQueueGenericReceive+0xc6>
 800b812:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800b814:	42bb      	cmp	r3, r7
 800b816:	d001      	beq.n	800b81c <xQueueGenericReceive+0x24>
 800b818:	b672      	cpsid	i
 800b81a:	e7fe      	b.n	800b81a <xQueueGenericReceive+0x22>
 800b81c:	000f      	movs	r7, r1
 800b81e:	e04e      	b.n	800b8be <xQueueGenericReceive+0xc6>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800b820:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 800b822:	60e7      	str	r7, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800b824:	2b00      	cmp	r3, #0
 800b826:	d064      	beq.n	800b8f2 <xQueueGenericReceive+0xfa>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800b828:	0020      	movs	r0, r4
 800b82a:	3024      	adds	r0, #36	; 0x24
 800b82c:	e05b      	b.n	800b8e6 <xQueueGenericReceive+0xee>
				if( xTicksToWait == ( TickType_t ) 0 )
 800b82e:	9b01      	ldr	r3, [sp, #4]
 800b830:	2b00      	cmp	r3, #0
 800b832:	d103      	bne.n	800b83c <xQueueGenericReceive+0x44>
					taskEXIT_CRITICAL();
 800b834:	f000 fcd8 	bl	800c1e8 <vPortExitCritical>
					return errQUEUE_EMPTY;
 800b838:	2000      	movs	r0, #0
 800b83a:	e05d      	b.n	800b8f8 <xQueueGenericReceive+0x100>
				else if( xEntryTimeSet == pdFALSE )
 800b83c:	2f00      	cmp	r7, #0
 800b83e:	d102      	bne.n	800b846 <xQueueGenericReceive+0x4e>
					vTaskSetTimeOutState( &xTimeOut );
 800b840:	a802      	add	r0, sp, #8
 800b842:	f000 fb85 	bl	800bf50 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 800b846:	f000 fccf 	bl	800c1e8 <vPortExitCritical>
		vTaskSuspendAll();
 800b84a:	f000 f9f5 	bl	800bc38 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800b84e:	f000 fcbf 	bl	800c1d0 <vPortEnterCritical>
 800b852:	0022      	movs	r2, r4
 800b854:	3244      	adds	r2, #68	; 0x44
 800b856:	7813      	ldrb	r3, [r2, #0]
 800b858:	b25b      	sxtb	r3, r3
 800b85a:	3301      	adds	r3, #1
 800b85c:	d101      	bne.n	800b862 <xQueueGenericReceive+0x6a>
 800b85e:	2300      	movs	r3, #0
 800b860:	7013      	strb	r3, [r2, #0]
 800b862:	0022      	movs	r2, r4
 800b864:	3245      	adds	r2, #69	; 0x45
 800b866:	7813      	ldrb	r3, [r2, #0]
 800b868:	b25b      	sxtb	r3, r3
 800b86a:	3301      	adds	r3, #1
 800b86c:	d101      	bne.n	800b872 <xQueueGenericReceive+0x7a>
 800b86e:	2300      	movs	r3, #0
 800b870:	7013      	strb	r3, [r2, #0]
 800b872:	f000 fcb9 	bl	800c1e8 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800b876:	a901      	add	r1, sp, #4
 800b878:	a802      	add	r0, sp, #8
 800b87a:	f000 fb79 	bl	800bf70 <xTaskCheckForTimeOut>
 800b87e:	2800      	cmp	r0, #0
 800b880:	d13c      	bne.n	800b8fc <xQueueGenericReceive+0x104>
	taskENTER_CRITICAL();
 800b882:	f000 fca5 	bl	800c1d0 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800b886:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b888:	2b00      	cmp	r3, #0
 800b88a:	d110      	bne.n	800b8ae <xQueueGenericReceive+0xb6>
	taskEXIT_CRITICAL();
 800b88c:	f000 fcac 	bl	800c1e8 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800b890:	0020      	movs	r0, r4
 800b892:	9901      	ldr	r1, [sp, #4]
 800b894:	3024      	adds	r0, #36	; 0x24
 800b896:	f000 fb15 	bl	800bec4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800b89a:	0020      	movs	r0, r4
 800b89c:	f7ff fe55 	bl	800b54a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800b8a0:	f000 fa3e 	bl	800bd20 <xTaskResumeAll>
 800b8a4:	2800      	cmp	r0, #0
 800b8a6:	d109      	bne.n	800b8bc <xQueueGenericReceive+0xc4>
					portYIELD_WITHIN_API();
 800b8a8:	f000 fc86 	bl	800c1b8 <vPortYield>
 800b8ac:	e006      	b.n	800b8bc <xQueueGenericReceive+0xc4>
	taskEXIT_CRITICAL();
 800b8ae:	f000 fc9b 	bl	800c1e8 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 800b8b2:	0020      	movs	r0, r4
 800b8b4:	f7ff fe49 	bl	800b54a <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800b8b8:	f000 fa32 	bl	800bd20 <xTaskResumeAll>
 800b8bc:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
 800b8be:	f000 fc87 	bl	800c1d0 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800b8c2:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800b8c4:	2d00      	cmp	r5, #0
 800b8c6:	d0b2      	beq.n	800b82e <xQueueGenericReceive+0x36>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800b8c8:	0031      	movs	r1, r6
 800b8ca:	0020      	movs	r0, r4
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 800b8cc:	68e7      	ldr	r7, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800b8ce:	f7ff fe2a 	bl	800b526 <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
 800b8d2:	9b00      	ldr	r3, [sp, #0]
 800b8d4:	2b00      	cmp	r3, #0
 800b8d6:	d1a3      	bne.n	800b820 <xQueueGenericReceive+0x28>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800b8d8:	6923      	ldr	r3, [r4, #16]
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 800b8da:	3d01      	subs	r5, #1
 800b8dc:	63a5      	str	r5, [r4, #56]	; 0x38
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800b8de:	2b00      	cmp	r3, #0
 800b8e0:	d007      	beq.n	800b8f2 <xQueueGenericReceive+0xfa>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800b8e2:	0020      	movs	r0, r4
 800b8e4:	3010      	adds	r0, #16
 800b8e6:	f000 faff 	bl	800bee8 <xTaskRemoveFromEventList>
 800b8ea:	2800      	cmp	r0, #0
 800b8ec:	d001      	beq.n	800b8f2 <xQueueGenericReceive+0xfa>
							queueYIELD_IF_USING_PREEMPTION();
 800b8ee:	f000 fc63 	bl	800c1b8 <vPortYield>
				taskEXIT_CRITICAL();
 800b8f2:	f000 fc79 	bl	800c1e8 <vPortExitCritical>
				return pdPASS;
 800b8f6:	2001      	movs	r0, #1
}
 800b8f8:	b005      	add	sp, #20
 800b8fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
			prvUnlockQueue( pxQueue );
 800b8fc:	0020      	movs	r0, r4
 800b8fe:	f7ff fe24 	bl	800b54a <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800b902:	f000 fa0d 	bl	800bd20 <xTaskResumeAll>
	taskENTER_CRITICAL();
 800b906:	f000 fc63 	bl	800c1d0 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800b90a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b90c:	2b00      	cmp	r3, #0
 800b90e:	d100      	bne.n	800b912 <xQueueGenericReceive+0x11a>
 800b910:	e790      	b.n	800b834 <xQueueGenericReceive+0x3c>
	taskEXIT_CRITICAL();
 800b912:	f000 fc69 	bl	800c1e8 <vPortExitCritical>
 800b916:	e7d1      	b.n	800b8bc <xQueueGenericReceive+0xc4>

0800b918 <xQueueReceiveFromISR>:
{
 800b918:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b91a:	b085      	sub	sp, #20
 800b91c:	0004      	movs	r4, r0
 800b91e:	9102      	str	r1, [sp, #8]
 800b920:	0016      	movs	r6, r2
	configASSERT( pxQueue );
 800b922:	2800      	cmp	r0, #0
 800b924:	d101      	bne.n	800b92a <xQueueReceiveFromISR+0x12>
 800b926:	b672      	cpsid	i
 800b928:	e7fe      	b.n	800b928 <xQueueReceiveFromISR+0x10>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800b92a:	9b02      	ldr	r3, [sp, #8]
 800b92c:	2b00      	cmp	r3, #0
 800b92e:	d104      	bne.n	800b93a <xQueueReceiveFromISR+0x22>
 800b930:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800b932:	2b00      	cmp	r3, #0
 800b934:	d001      	beq.n	800b93a <xQueueReceiveFromISR+0x22>
 800b936:	b672      	cpsid	i
 800b938:	e7fe      	b.n	800b938 <xQueueReceiveFromISR+0x20>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800b93a:	f000 fc63 	bl	800c204 <ulSetInterruptMaskFromISR>
			xReturn = pdFAIL;
 800b93e:	2500      	movs	r5, #0
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800b940:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800b942:	9003      	str	r0, [sp, #12]
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800b944:	9301      	str	r3, [sp, #4]
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800b946:	42ab      	cmp	r3, r5
 800b948:	d01b      	beq.n	800b982 <xQueueReceiveFromISR+0x6a>
			const int8_t cRxLock = pxQueue->cRxLock;
 800b94a:	0027      	movs	r7, r4
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800b94c:	9902      	ldr	r1, [sp, #8]
			const int8_t cRxLock = pxQueue->cRxLock;
 800b94e:	3744      	adds	r7, #68	; 0x44
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800b950:	0020      	movs	r0, r4
			const int8_t cRxLock = pxQueue->cRxLock;
 800b952:	783d      	ldrb	r5, [r7, #0]
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800b954:	f7ff fde7 	bl	800b526 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 800b958:	9b01      	ldr	r3, [sp, #4]
			const int8_t cRxLock = pxQueue->cRxLock;
 800b95a:	b26d      	sxtb	r5, r5
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 800b95c:	3b01      	subs	r3, #1
 800b95e:	63a3      	str	r3, [r4, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 800b960:	1c6b      	adds	r3, r5, #1
 800b962:	d114      	bne.n	800b98e <xQueueReceiveFromISR+0x76>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800b964:	6923      	ldr	r3, [r4, #16]
 800b966:	2b00      	cmp	r3, #0
 800b968:	d101      	bne.n	800b96e <xQueueReceiveFromISR+0x56>
			xReturn = pdPASS;
 800b96a:	2501      	movs	r5, #1
 800b96c:	e009      	b.n	800b982 <xQueueReceiveFromISR+0x6a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800b96e:	0020      	movs	r0, r4
 800b970:	3010      	adds	r0, #16
 800b972:	f000 fab9 	bl	800bee8 <xTaskRemoveFromEventList>
 800b976:	2800      	cmp	r0, #0
 800b978:	d0f7      	beq.n	800b96a <xQueueReceiveFromISR+0x52>
						if( pxHigherPriorityTaskWoken != NULL )
 800b97a:	2e00      	cmp	r6, #0
 800b97c:	d0f5      	beq.n	800b96a <xQueueReceiveFromISR+0x52>
							*pxHigherPriorityTaskWoken = pdTRUE;
 800b97e:	2501      	movs	r5, #1
 800b980:	6035      	str	r5, [r6, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800b982:	9803      	ldr	r0, [sp, #12]
 800b984:	f000 fc43 	bl	800c20e <vClearInterruptMaskFromISR>
}
 800b988:	0028      	movs	r0, r5
 800b98a:	b005      	add	sp, #20
 800b98c:	bdf0      	pop	{r4, r5, r6, r7, pc}
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 800b98e:	3501      	adds	r5, #1
 800b990:	b26d      	sxtb	r5, r5
 800b992:	703d      	strb	r5, [r7, #0]
 800b994:	e7e9      	b.n	800b96a <xQueueReceiveFromISR+0x52>
	...

0800b998 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800b998:	4b06      	ldr	r3, [pc, #24]	; (800b9b4 <prvResetNextTaskUnblockTime+0x1c>)
 800b99a:	681a      	ldr	r2, [r3, #0]
 800b99c:	6812      	ldr	r2, [r2, #0]
 800b99e:	2a00      	cmp	r2, #0
 800b9a0:	d102      	bne.n	800b9a8 <prvResetNextTaskUnblockTime+0x10>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 800b9a2:	3a01      	subs	r2, #1
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800b9a4:	605a      	str	r2, [r3, #4]
	}
}
 800b9a6:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800b9a8:	681a      	ldr	r2, [r3, #0]
 800b9aa:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800b9ac:	68d2      	ldr	r2, [r2, #12]
 800b9ae:	6852      	ldr	r2, [r2, #4]
 800b9b0:	e7f8      	b.n	800b9a4 <prvResetNextTaskUnblockTime+0xc>
 800b9b2:	46c0      	nop			; (mov r8, r8)
 800b9b4:	2000040c 	.word	0x2000040c

0800b9b8 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 800b9b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b9ba:	0005      	movs	r5, r0
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 800b9bc:	4c13      	ldr	r4, [pc, #76]	; (800ba0c <prvAddCurrentTaskToDelayedList+0x54>)
{
 800b9be:	000f      	movs	r7, r1
const TickType_t xConstTickCount = xTickCount;
 800b9c0:	68a6      	ldr	r6, [r4, #8]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800b9c2:	68e0      	ldr	r0, [r4, #12]
 800b9c4:	3004      	adds	r0, #4
 800b9c6:	f7ff fd70 	bl	800b4aa <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800b9ca:	1c6b      	adds	r3, r5, #1
 800b9cc:	d108      	bne.n	800b9e0 <prvAddCurrentTaskToDelayedList+0x28>
 800b9ce:	2f00      	cmp	r7, #0
 800b9d0:	d006      	beq.n	800b9e0 <prvAddCurrentTaskToDelayedList+0x28>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800b9d2:	0020      	movs	r0, r4
 800b9d4:	68e1      	ldr	r1, [r4, #12]
 800b9d6:	3010      	adds	r0, #16
 800b9d8:	3104      	adds	r1, #4
 800b9da:	f7ff fd43 	bl	800b464 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 800b9de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800b9e0:	68e3      	ldr	r3, [r4, #12]
			xTimeToWake = xConstTickCount + xTicksToWait;
 800b9e2:	1975      	adds	r5, r6, r5
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800b9e4:	605d      	str	r5, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 800b9e6:	42ae      	cmp	r6, r5
 800b9e8:	d905      	bls.n	800b9f6 <prvAddCurrentTaskToDelayedList+0x3e>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800b9ea:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b9ec:	68e1      	ldr	r1, [r4, #12]
 800b9ee:	3104      	adds	r1, #4
 800b9f0:	f7ff fd44 	bl	800b47c <vListInsert>
 800b9f4:	e7f3      	b.n	800b9de <prvAddCurrentTaskToDelayedList+0x26>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800b9f6:	6820      	ldr	r0, [r4, #0]
 800b9f8:	68e1      	ldr	r1, [r4, #12]
 800b9fa:	3104      	adds	r1, #4
 800b9fc:	f7ff fd3e 	bl	800b47c <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 800ba00:	6863      	ldr	r3, [r4, #4]
 800ba02:	42ab      	cmp	r3, r5
 800ba04:	d9eb      	bls.n	800b9de <prvAddCurrentTaskToDelayedList+0x26>
					xNextTaskUnblockTime = xTimeToWake;
 800ba06:	6065      	str	r5, [r4, #4]
}
 800ba08:	e7e9      	b.n	800b9de <prvAddCurrentTaskToDelayedList+0x26>
 800ba0a:	46c0      	nop			; (mov r8, r8)
 800ba0c:	2000040c 	.word	0x2000040c

0800ba10 <xTaskCreate>:
	{
 800ba10:	b5f0      	push	{r4, r5, r6, r7, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800ba12:	0095      	lsls	r5, r2, #2
	{
 800ba14:	b085      	sub	sp, #20
 800ba16:	9002      	str	r0, [sp, #8]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800ba18:	0028      	movs	r0, r5
	{
 800ba1a:	000f      	movs	r7, r1
 800ba1c:	9303      	str	r3, [sp, #12]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800ba1e:	f000 faff 	bl	800c020 <pvPortMalloc>
 800ba22:	1e06      	subs	r6, r0, #0
			if( pxStack != NULL )
 800ba24:	d100      	bne.n	800ba28 <xTaskCreate+0x18>
 800ba26:	e08b      	b.n	800bb40 <xTaskCreate+0x130>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 800ba28:	204c      	movs	r0, #76	; 0x4c
 800ba2a:	f000 faf9 	bl	800c020 <pvPortMalloc>
 800ba2e:	1e04      	subs	r4, r0, #0
				if( pxNewTCB != NULL )
 800ba30:	d100      	bne.n	800ba34 <xTaskCreate+0x24>
 800ba32:	e082      	b.n	800bb3a <xTaskCreate+0x12a>
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800ba34:	2307      	movs	r3, #7
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800ba36:	3d04      	subs	r5, #4
					pxNewTCB->pxStack = pxStack;
 800ba38:	6306      	str	r6, [r0, #48]	; 0x30
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800ba3a:	1976      	adds	r6, r6, r5
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800ba3c:	439e      	bics	r6, r3
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800ba3e:	2300      	movs	r3, #0
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800ba40:	9601      	str	r6, [sp, #4]
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800ba42:	001a      	movs	r2, r3
 800ba44:	5cf9      	ldrb	r1, [r7, r3]
 800ba46:	3234      	adds	r2, #52	; 0x34
 800ba48:	54a1      	strb	r1, [r4, r2]
		if( pcName[ x ] == 0x00 )
 800ba4a:	5cfa      	ldrb	r2, [r7, r3]
 800ba4c:	2a00      	cmp	r2, #0
 800ba4e:	d002      	beq.n	800ba56 <xTaskCreate+0x46>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800ba50:	3301      	adds	r3, #1
 800ba52:	2b10      	cmp	r3, #16
 800ba54:	d1f5      	bne.n	800ba42 <xTaskCreate+0x32>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800ba56:	0023      	movs	r3, r4
 800ba58:	2200      	movs	r2, #0
 800ba5a:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 800ba5c:	3343      	adds	r3, #67	; 0x43
 800ba5e:	701a      	strb	r2, [r3, #0]
 800ba60:	2d06      	cmp	r5, #6
 800ba62:	d900      	bls.n	800ba66 <xTaskCreate+0x56>
 800ba64:	2506      	movs	r5, #6
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800ba66:	1d26      	adds	r6, r4, #4
	pxNewTCB->uxPriority = uxPriority;
 800ba68:	62e5      	str	r5, [r4, #44]	; 0x2c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800ba6a:	0030      	movs	r0, r6
 800ba6c:	f7ff fcf7 	bl	800b45e <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 800ba70:	0020      	movs	r0, r4
 800ba72:	3018      	adds	r0, #24
 800ba74:	f7ff fcf3 	bl	800b45e <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800ba78:	2307      	movs	r3, #7
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800ba7a:	0022      	movs	r2, r4
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800ba7c:	1b5d      	subs	r5, r3, r5
		pxNewTCB->ulNotifiedValue = 0;
 800ba7e:	2300      	movs	r3, #0
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800ba80:	3248      	adds	r2, #72	; 0x48
		pxNewTCB->ulNotifiedValue = 0;
 800ba82:	6463      	str	r3, [r4, #68]	; 0x44
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 800ba84:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800ba86:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800ba88:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800ba8a:	9902      	ldr	r1, [sp, #8]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800ba8c:	7013      	strb	r3, [r2, #0]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800ba8e:	9801      	ldr	r0, [sp, #4]
 800ba90:	9a03      	ldr	r2, [sp, #12]
 800ba92:	f000 fb7f 	bl	800c194 <pxPortInitialiseStack>
	if( ( void * ) pxCreatedTask != NULL )
 800ba96:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800ba98:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 800ba9a:	2b00      	cmp	r3, #0
 800ba9c:	d000      	beq.n	800baa0 <xTaskCreate+0x90>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 800ba9e:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
 800baa0:	f000 fb96 	bl	800c1d0 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 800baa4:	4d2d      	ldr	r5, [pc, #180]	; (800bb5c <xTaskCreate+0x14c>)
 800baa6:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800baa8:	3301      	adds	r3, #1
 800baaa:	62ab      	str	r3, [r5, #40]	; 0x28
		if( pxCurrentTCB == NULL )
 800baac:	68ef      	ldr	r7, [r5, #12]
 800baae:	2f00      	cmp	r7, #0
 800bab0:	d149      	bne.n	800bb46 <xTaskCreate+0x136>
			pxCurrentTCB = pxNewTCB;
 800bab2:	60ec      	str	r4, [r5, #12]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800bab4:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800bab6:	2b01      	cmp	r3, #1
 800bab8:	d11f      	bne.n	800bafa <xTaskCreate+0xea>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800baba:	2014      	movs	r0, #20
 800babc:	4378      	muls	r0, r7
 800babe:	4b28      	ldr	r3, [pc, #160]	; (800bb60 <xTaskCreate+0x150>)
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800bac0:	3701      	adds	r7, #1
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800bac2:	1818      	adds	r0, r3, r0
 800bac4:	f7ff fcc0 	bl	800b448 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800bac8:	2f07      	cmp	r7, #7
 800baca:	d1f6      	bne.n	800baba <xTaskCreate+0xaa>
	vListInitialise( &xDelayedTaskList1 );
 800bacc:	002f      	movs	r7, r5
 800bace:	372c      	adds	r7, #44	; 0x2c
 800bad0:	0038      	movs	r0, r7
 800bad2:	f7ff fcb9 	bl	800b448 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800bad6:	4823      	ldr	r0, [pc, #140]	; (800bb64 <xTaskCreate+0x154>)
 800bad8:	f7ff fcb6 	bl	800b448 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 800badc:	0028      	movs	r0, r5
 800bade:	3054      	adds	r0, #84	; 0x54
 800bae0:	f7ff fcb2 	bl	800b448 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 800bae4:	0028      	movs	r0, r5
 800bae6:	3068      	adds	r0, #104	; 0x68
 800bae8:	f7ff fcae 	bl	800b448 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 800baec:	0028      	movs	r0, r5
 800baee:	3010      	adds	r0, #16
 800baf0:	f7ff fcaa 	bl	800b448 <vListInitialise>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800baf4:	4b1b      	ldr	r3, [pc, #108]	; (800bb64 <xTaskCreate+0x154>)
	pxDelayedTaskList = &xDelayedTaskList1;
 800baf6:	602f      	str	r7, [r5, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800baf8:	626b      	str	r3, [r5, #36]	; 0x24
		uxTaskNumber++;
 800bafa:	4b1b      	ldr	r3, [pc, #108]	; (800bb68 <xTaskCreate+0x158>)
 800bafc:	681a      	ldr	r2, [r3, #0]
		prvAddTaskToReadyList( pxNewTCB );
 800bafe:	6859      	ldr	r1, [r3, #4]
		uxTaskNumber++;
 800bb00:	3201      	adds	r2, #1
 800bb02:	601a      	str	r2, [r3, #0]
		prvAddTaskToReadyList( pxNewTCB );
 800bb04:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800bb06:	428a      	cmp	r2, r1
 800bb08:	d900      	bls.n	800bb0c <xTaskCreate+0xfc>
 800bb0a:	605a      	str	r2, [r3, #4]
 800bb0c:	2014      	movs	r0, #20
 800bb0e:	4350      	muls	r0, r2
 800bb10:	4b13      	ldr	r3, [pc, #76]	; (800bb60 <xTaskCreate+0x150>)
 800bb12:	0031      	movs	r1, r6
 800bb14:	1818      	adds	r0, r3, r0
 800bb16:	f7ff fca5 	bl	800b464 <vListInsertEnd>
	taskEXIT_CRITICAL();
 800bb1a:	f000 fb65 	bl	800c1e8 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 800bb1e:	6feb      	ldr	r3, [r5, #124]	; 0x7c
			xReturn = pdPASS;
 800bb20:	2601      	movs	r6, #1
	if( xSchedulerRunning != pdFALSE )
 800bb22:	2b00      	cmp	r3, #0
 800bb24:	d006      	beq.n	800bb34 <xTaskCreate+0x124>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800bb26:	68eb      	ldr	r3, [r5, #12]
 800bb28:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800bb2a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800bb2c:	429a      	cmp	r2, r3
 800bb2e:	d201      	bcs.n	800bb34 <xTaskCreate+0x124>
			taskYIELD_IF_USING_PREEMPTION();
 800bb30:	f000 fb42 	bl	800c1b8 <vPortYield>
	}
 800bb34:	0030      	movs	r0, r6
 800bb36:	b005      	add	sp, #20
 800bb38:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vPortFree( pxStack );
 800bb3a:	0030      	movs	r0, r6
 800bb3c:	f000 fae2 	bl	800c104 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800bb40:	2601      	movs	r6, #1
 800bb42:	4276      	negs	r6, r6
 800bb44:	e7f6      	b.n	800bb34 <xTaskCreate+0x124>
			if( xSchedulerRunning == pdFALSE )
 800bb46:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 800bb48:	2b00      	cmp	r3, #0
 800bb4a:	d1d6      	bne.n	800bafa <xTaskCreate+0xea>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 800bb4c:	68eb      	ldr	r3, [r5, #12]
 800bb4e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800bb50:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bb52:	4293      	cmp	r3, r2
 800bb54:	d8d1      	bhi.n	800bafa <xTaskCreate+0xea>
					pxCurrentTCB = pxNewTCB;
 800bb56:	60ec      	str	r4, [r5, #12]
 800bb58:	e7cf      	b.n	800bafa <xTaskCreate+0xea>
 800bb5a:	46c0      	nop			; (mov r8, r8)
 800bb5c:	2000040c 	.word	0x2000040c
 800bb60:	200004ac 	.word	0x200004ac
 800bb64:	2000044c 	.word	0x2000044c
 800bb68:	2000048c 	.word	0x2000048c

0800bb6c <vTaskDelete>:
	{
 800bb6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800bb6e:	0004      	movs	r4, r0
		taskENTER_CRITICAL();
 800bb70:	f000 fb2e 	bl	800c1d0 <vPortEnterCritical>
 800bb74:	4d1c      	ldr	r5, [pc, #112]	; (800bbe8 <vTaskDelete+0x7c>)
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 800bb76:	2c00      	cmp	r4, #0
 800bb78:	d100      	bne.n	800bb7c <vTaskDelete+0x10>
 800bb7a:	68ec      	ldr	r4, [r5, #12]
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800bb7c:	1d27      	adds	r7, r4, #4
 800bb7e:	0038      	movs	r0, r7
 800bb80:	f7ff fc93 	bl	800b4aa <uxListRemove>
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800bb84:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800bb86:	2b00      	cmp	r3, #0
 800bb88:	d003      	beq.n	800bb92 <vTaskDelete+0x26>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800bb8a:	0020      	movs	r0, r4
 800bb8c:	3018      	adds	r0, #24
 800bb8e:	f7ff fc8c 	bl	800b4aa <uxListRemove>
			uxTaskNumber++;
 800bb92:	4e16      	ldr	r6, [pc, #88]	; (800bbec <vTaskDelete+0x80>)
 800bb94:	6833      	ldr	r3, [r6, #0]
 800bb96:	3301      	adds	r3, #1
 800bb98:	6033      	str	r3, [r6, #0]
			if( pxTCB == pxCurrentTCB )
 800bb9a:	68eb      	ldr	r3, [r5, #12]
 800bb9c:	42a3      	cmp	r3, r4
 800bb9e:	d114      	bne.n	800bbca <vTaskDelete+0x5e>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 800bba0:	0028      	movs	r0, r5
 800bba2:	0039      	movs	r1, r7
 800bba4:	3068      	adds	r0, #104	; 0x68
 800bba6:	f7ff fc5d 	bl	800b464 <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
 800bbaa:	68b3      	ldr	r3, [r6, #8]
 800bbac:	3301      	adds	r3, #1
 800bbae:	60b3      	str	r3, [r6, #8]
		taskEXIT_CRITICAL();
 800bbb0:	f000 fb1a 	bl	800c1e8 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 800bbb4:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 800bbb6:	2b00      	cmp	r3, #0
 800bbb8:	d015      	beq.n	800bbe6 <vTaskDelete+0x7a>
			if( pxTCB == pxCurrentTCB )
 800bbba:	68eb      	ldr	r3, [r5, #12]
 800bbbc:	42a3      	cmp	r3, r4
 800bbbe:	d112      	bne.n	800bbe6 <vTaskDelete+0x7a>
				configASSERT( uxSchedulerSuspended == 0 );
 800bbc0:	68f3      	ldr	r3, [r6, #12]
 800bbc2:	2b00      	cmp	r3, #0
 800bbc4:	d00d      	beq.n	800bbe2 <vTaskDelete+0x76>
 800bbc6:	b672      	cpsid	i
 800bbc8:	e7fe      	b.n	800bbc8 <vTaskDelete+0x5c>
				--uxCurrentNumberOfTasks;
 800bbca:	6aab      	ldr	r3, [r5, #40]	; 0x28
			vPortFree( pxTCB->pxStack );
 800bbcc:	6b20      	ldr	r0, [r4, #48]	; 0x30
				--uxCurrentNumberOfTasks;
 800bbce:	3b01      	subs	r3, #1
 800bbd0:	62ab      	str	r3, [r5, #40]	; 0x28
			vPortFree( pxTCB->pxStack );
 800bbd2:	f000 fa97 	bl	800c104 <vPortFree>
			vPortFree( pxTCB );
 800bbd6:	0020      	movs	r0, r4
 800bbd8:	f000 fa94 	bl	800c104 <vPortFree>
				prvResetNextTaskUnblockTime();
 800bbdc:	f7ff fedc 	bl	800b998 <prvResetNextTaskUnblockTime>
 800bbe0:	e7e6      	b.n	800bbb0 <vTaskDelete+0x44>
				portYIELD_WITHIN_API();
 800bbe2:	f000 fae9 	bl	800c1b8 <vPortYield>
	}
 800bbe6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800bbe8:	2000040c 	.word	0x2000040c
 800bbec:	2000048c 	.word	0x2000048c

0800bbf0 <vTaskStartScheduler>:
{
 800bbf0:	b513      	push	{r0, r1, r4, lr}
		xReturn = xTaskCreate(	prvIdleTask,
 800bbf2:	2400      	movs	r4, #0
 800bbf4:	4b0c      	ldr	r3, [pc, #48]	; (800bc28 <vTaskStartScheduler+0x38>)
 800bbf6:	9400      	str	r4, [sp, #0]
 800bbf8:	3310      	adds	r3, #16
 800bbfa:	9301      	str	r3, [sp, #4]
 800bbfc:	2228      	movs	r2, #40	; 0x28
 800bbfe:	0023      	movs	r3, r4
 800bc00:	490a      	ldr	r1, [pc, #40]	; (800bc2c <vTaskStartScheduler+0x3c>)
 800bc02:	480b      	ldr	r0, [pc, #44]	; (800bc30 <vTaskStartScheduler+0x40>)
 800bc04:	f7ff ff04 	bl	800ba10 <xTaskCreate>
	if( xReturn == pdPASS )
 800bc08:	2801      	cmp	r0, #1
 800bc0a:	d109      	bne.n	800bc20 <vTaskStartScheduler+0x30>
		portDISABLE_INTERRUPTS();
 800bc0c:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
 800bc0e:	2201      	movs	r2, #1
 800bc10:	4b08      	ldr	r3, [pc, #32]	; (800bc34 <vTaskStartScheduler+0x44>)
 800bc12:	4252      	negs	r2, r2
 800bc14:	605a      	str	r2, [r3, #4]
		xSchedulerRunning = pdTRUE;
 800bc16:	67d8      	str	r0, [r3, #124]	; 0x7c
		xTickCount = ( TickType_t ) 0U;
 800bc18:	609c      	str	r4, [r3, #8]
		if( xPortStartScheduler() != pdFALSE )
 800bc1a:	f000 fb49 	bl	800c2b0 <xPortStartScheduler>
}
 800bc1e:	bd13      	pop	{r0, r1, r4, pc}
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 800bc20:	1c43      	adds	r3, r0, #1
 800bc22:	d1fc      	bne.n	800bc1e <vTaskStartScheduler+0x2e>
 800bc24:	b672      	cpsid	i
 800bc26:	e7fe      	b.n	800bc26 <vTaskStartScheduler+0x36>
 800bc28:	2000048c 	.word	0x2000048c
 800bc2c:	0800c7e6 	.word	0x0800c7e6
 800bc30:	0800be05 	.word	0x0800be05
 800bc34:	2000040c 	.word	0x2000040c

0800bc38 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 800bc38:	4a02      	ldr	r2, [pc, #8]	; (800bc44 <vTaskSuspendAll+0xc>)
 800bc3a:	68d3      	ldr	r3, [r2, #12]
 800bc3c:	3301      	adds	r3, #1
 800bc3e:	60d3      	str	r3, [r2, #12]
}
 800bc40:	4770      	bx	lr
 800bc42:	46c0      	nop			; (mov r8, r8)
 800bc44:	2000048c 	.word	0x2000048c

0800bc48 <uxTaskGetNumberOfTasks>:
	return uxCurrentNumberOfTasks;
 800bc48:	4b01      	ldr	r3, [pc, #4]	; (800bc50 <uxTaskGetNumberOfTasks+0x8>)
 800bc4a:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
 800bc4c:	4770      	bx	lr
 800bc4e:	46c0      	nop			; (mov r8, r8)
 800bc50:	2000040c 	.word	0x2000040c

0800bc54 <xTaskIncrementTick>:
{
 800bc54:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800bc56:	4d2f      	ldr	r5, [pc, #188]	; (800bd14 <xTaskIncrementTick+0xc0>)
 800bc58:	68eb      	ldr	r3, [r5, #12]
 800bc5a:	2b00      	cmp	r3, #0
 800bc5c:	d155      	bne.n	800bd0a <xTaskIncrementTick+0xb6>
		const TickType_t xConstTickCount = xTickCount + 1;
 800bc5e:	4c2e      	ldr	r4, [pc, #184]	; (800bd18 <xTaskIncrementTick+0xc4>)
 800bc60:	68a3      	ldr	r3, [r4, #8]
 800bc62:	3301      	adds	r3, #1
 800bc64:	9300      	str	r3, [sp, #0]
		xTickCount = xConstTickCount;
 800bc66:	60a3      	str	r3, [r4, #8]
		if( xConstTickCount == ( TickType_t ) 0U )
 800bc68:	2b00      	cmp	r3, #0
 800bc6a:	d10e      	bne.n	800bc8a <xTaskIncrementTick+0x36>
			taskSWITCH_DELAYED_LISTS();
 800bc6c:	6823      	ldr	r3, [r4, #0]
 800bc6e:	681b      	ldr	r3, [r3, #0]
 800bc70:	2b00      	cmp	r3, #0
 800bc72:	d001      	beq.n	800bc78 <xTaskIncrementTick+0x24>
 800bc74:	b672      	cpsid	i
 800bc76:	e7fe      	b.n	800bc76 <xTaskIncrementTick+0x22>
 800bc78:	6823      	ldr	r3, [r4, #0]
 800bc7a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800bc7c:	6022      	str	r2, [r4, #0]
 800bc7e:	6263      	str	r3, [r4, #36]	; 0x24
 800bc80:	696b      	ldr	r3, [r5, #20]
 800bc82:	3301      	adds	r3, #1
 800bc84:	616b      	str	r3, [r5, #20]
 800bc86:	f7ff fe87 	bl	800b998 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 800bc8a:	6863      	ldr	r3, [r4, #4]
 800bc8c:	9a00      	ldr	r2, [sp, #0]
BaseType_t xSwitchRequired = pdFALSE;
 800bc8e:	2600      	movs	r6, #0
		if( xConstTickCount >= xNextTaskUnblockTime )
 800bc90:	4293      	cmp	r3, r2
 800bc92:	d933      	bls.n	800bcfc <xTaskIncrementTick+0xa8>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800bc94:	68e3      	ldr	r3, [r4, #12]
 800bc96:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800bc98:	2314      	movs	r3, #20
 800bc9a:	4353      	muls	r3, r2
 800bc9c:	4a1f      	ldr	r2, [pc, #124]	; (800bd1c <xTaskIncrementTick+0xc8>)
 800bc9e:	58d3      	ldr	r3, [r2, r3]
 800bca0:	2b01      	cmp	r3, #1
 800bca2:	d900      	bls.n	800bca6 <xTaskIncrementTick+0x52>
				xSwitchRequired = pdTRUE;
 800bca4:	2601      	movs	r6, #1
		if( xYieldPending != pdFALSE )
 800bca6:	69eb      	ldr	r3, [r5, #28]
 800bca8:	2b00      	cmp	r3, #0
 800bcaa:	d000      	beq.n	800bcae <xTaskIncrementTick+0x5a>
			xSwitchRequired = pdTRUE;
 800bcac:	2601      	movs	r6, #1
}
 800bcae:	0030      	movs	r0, r6
 800bcb0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800bcb2:	6823      	ldr	r3, [r4, #0]
					if( xConstTickCount < xItemValue )
 800bcb4:	9a00      	ldr	r2, [sp, #0]
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800bcb6:	68db      	ldr	r3, [r3, #12]
 800bcb8:	68df      	ldr	r7, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800bcba:	687b      	ldr	r3, [r7, #4]
					if( xConstTickCount < xItemValue )
 800bcbc:	429a      	cmp	r2, r3
 800bcbe:	d322      	bcc.n	800bd06 <xTaskIncrementTick+0xb2>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800bcc0:	1d3b      	adds	r3, r7, #4
 800bcc2:	0018      	movs	r0, r3
 800bcc4:	9301      	str	r3, [sp, #4]
 800bcc6:	f7ff fbf0 	bl	800b4aa <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800bcca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bccc:	2b00      	cmp	r3, #0
 800bcce:	d003      	beq.n	800bcd8 <xTaskIncrementTick+0x84>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800bcd0:	0038      	movs	r0, r7
 800bcd2:	3018      	adds	r0, #24
 800bcd4:	f7ff fbe9 	bl	800b4aa <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800bcd8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800bcda:	686b      	ldr	r3, [r5, #4]
 800bcdc:	4298      	cmp	r0, r3
 800bcde:	d900      	bls.n	800bce2 <xTaskIncrementTick+0x8e>
 800bce0:	6068      	str	r0, [r5, #4]
 800bce2:	2314      	movs	r3, #20
 800bce4:	4358      	muls	r0, r3
 800bce6:	4b0d      	ldr	r3, [pc, #52]	; (800bd1c <xTaskIncrementTick+0xc8>)
 800bce8:	1d39      	adds	r1, r7, #4
 800bcea:	1818      	adds	r0, r3, r0
 800bcec:	f7ff fbba 	bl	800b464 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800bcf0:	68e3      	ldr	r3, [r4, #12]
 800bcf2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800bcf4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bcf6:	429a      	cmp	r2, r3
 800bcf8:	d300      	bcc.n	800bcfc <xTaskIncrementTick+0xa8>
							xSwitchRequired = pdTRUE;
 800bcfa:	2601      	movs	r6, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800bcfc:	6823      	ldr	r3, [r4, #0]
 800bcfe:	681b      	ldr	r3, [r3, #0]
 800bd00:	2b00      	cmp	r3, #0
 800bd02:	d1d6      	bne.n	800bcb2 <xTaskIncrementTick+0x5e>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bd04:	3b01      	subs	r3, #1
						xNextTaskUnblockTime = xItemValue;
 800bd06:	6063      	str	r3, [r4, #4]
						break;
 800bd08:	e7c4      	b.n	800bc94 <xTaskIncrementTick+0x40>
		++uxPendedTicks;
 800bd0a:	69ab      	ldr	r3, [r5, #24]
BaseType_t xSwitchRequired = pdFALSE;
 800bd0c:	2600      	movs	r6, #0
		++uxPendedTicks;
 800bd0e:	3301      	adds	r3, #1
 800bd10:	61ab      	str	r3, [r5, #24]
 800bd12:	e7c8      	b.n	800bca6 <xTaskIncrementTick+0x52>
 800bd14:	2000048c 	.word	0x2000048c
 800bd18:	2000040c 	.word	0x2000040c
 800bd1c:	200004ac 	.word	0x200004ac

0800bd20 <xTaskResumeAll>:
{
 800bd20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( uxSchedulerSuspended );
 800bd22:	4c28      	ldr	r4, [pc, #160]	; (800bdc4 <xTaskResumeAll+0xa4>)
 800bd24:	68e3      	ldr	r3, [r4, #12]
 800bd26:	2b00      	cmp	r3, #0
 800bd28:	d101      	bne.n	800bd2e <xTaskResumeAll+0xe>
 800bd2a:	b672      	cpsid	i
 800bd2c:	e7fe      	b.n	800bd2c <xTaskResumeAll+0xc>
	taskENTER_CRITICAL();
 800bd2e:	f000 fa4f 	bl	800c1d0 <vPortEnterCritical>
		--uxSchedulerSuspended;
 800bd32:	68e3      	ldr	r3, [r4, #12]
 800bd34:	3b01      	subs	r3, #1
 800bd36:	60e3      	str	r3, [r4, #12]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800bd38:	68e5      	ldr	r5, [r4, #12]
 800bd3a:	2d00      	cmp	r5, #0
 800bd3c:	d004      	beq.n	800bd48 <xTaskResumeAll+0x28>
BaseType_t xAlreadyYielded = pdFALSE;
 800bd3e:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 800bd40:	f000 fa52 	bl	800c1e8 <vPortExitCritical>
}
 800bd44:	0020      	movs	r0, r4
 800bd46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800bd48:	4e1f      	ldr	r6, [pc, #124]	; (800bdc8 <xTaskResumeAll+0xa8>)
 800bd4a:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800bd4c:	2b00      	cmp	r3, #0
 800bd4e:	d0f6      	beq.n	800bd3e <xTaskResumeAll+0x1e>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800bd50:	6d73      	ldr	r3, [r6, #84]	; 0x54
 800bd52:	2b00      	cmp	r3, #0
 800bd54:	d117      	bne.n	800bd86 <xTaskResumeAll+0x66>
				if( pxTCB != NULL )
 800bd56:	2d00      	cmp	r5, #0
 800bd58:	d001      	beq.n	800bd5e <xTaskResumeAll+0x3e>
					prvResetNextTaskUnblockTime();
 800bd5a:	f7ff fe1d 	bl	800b998 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 800bd5e:	69a5      	ldr	r5, [r4, #24]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 800bd60:	2d00      	cmp	r5, #0
 800bd62:	d009      	beq.n	800bd78 <xTaskResumeAll+0x58>
								xYieldPending = pdTRUE;
 800bd64:	2601      	movs	r6, #1
							if( xTaskIncrementTick() != pdFALSE )
 800bd66:	f7ff ff75 	bl	800bc54 <xTaskIncrementTick>
 800bd6a:	2800      	cmp	r0, #0
 800bd6c:	d000      	beq.n	800bd70 <xTaskResumeAll+0x50>
								xYieldPending = pdTRUE;
 800bd6e:	61e6      	str	r6, [r4, #28]
							--uxPendedCounts;
 800bd70:	3d01      	subs	r5, #1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 800bd72:	2d00      	cmp	r5, #0
 800bd74:	d1f7      	bne.n	800bd66 <xTaskResumeAll+0x46>
						uxPendedTicks = 0;
 800bd76:	61a5      	str	r5, [r4, #24]
				if( xYieldPending != pdFALSE )
 800bd78:	69e3      	ldr	r3, [r4, #28]
 800bd7a:	2b00      	cmp	r3, #0
 800bd7c:	d0df      	beq.n	800bd3e <xTaskResumeAll+0x1e>
					taskYIELD_IF_USING_PREEMPTION();
 800bd7e:	f000 fa1b 	bl	800c1b8 <vPortYield>
						xAlreadyYielded = pdTRUE;
 800bd82:	2401      	movs	r4, #1
 800bd84:	e7dc      	b.n	800bd40 <xTaskResumeAll+0x20>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 800bd86:	6e33      	ldr	r3, [r6, #96]	; 0x60
 800bd88:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800bd8a:	0028      	movs	r0, r5
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800bd8c:	1d2f      	adds	r7, r5, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800bd8e:	3018      	adds	r0, #24
 800bd90:	f7ff fb8b 	bl	800b4aa <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800bd94:	0038      	movs	r0, r7
 800bd96:	f7ff fb88 	bl	800b4aa <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800bd9a:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 800bd9c:	6863      	ldr	r3, [r4, #4]
 800bd9e:	4298      	cmp	r0, r3
 800bda0:	d900      	bls.n	800bda4 <xTaskResumeAll+0x84>
 800bda2:	6060      	str	r0, [r4, #4]
 800bda4:	2314      	movs	r3, #20
 800bda6:	4358      	muls	r0, r3
 800bda8:	4b08      	ldr	r3, [pc, #32]	; (800bdcc <xTaskResumeAll+0xac>)
 800bdaa:	0039      	movs	r1, r7
 800bdac:	18c0      	adds	r0, r0, r3
 800bdae:	f7ff fb59 	bl	800b464 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800bdb2:	68f3      	ldr	r3, [r6, #12]
 800bdb4:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800bdb6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bdb8:	429a      	cmp	r2, r3
 800bdba:	d3c9      	bcc.n	800bd50 <xTaskResumeAll+0x30>
						xYieldPending = pdTRUE;
 800bdbc:	2301      	movs	r3, #1
 800bdbe:	61e3      	str	r3, [r4, #28]
 800bdc0:	e7c6      	b.n	800bd50 <xTaskResumeAll+0x30>
 800bdc2:	46c0      	nop			; (mov r8, r8)
 800bdc4:	2000048c 	.word	0x2000048c
 800bdc8:	2000040c 	.word	0x2000040c
 800bdcc:	200004ac 	.word	0x200004ac

0800bdd0 <vTaskDelay>:
	{
 800bdd0:	b570      	push	{r4, r5, r6, lr}
 800bdd2:	1e04      	subs	r4, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
 800bdd4:	d102      	bne.n	800bddc <vTaskDelay+0xc>
			portYIELD_WITHIN_API();
 800bdd6:	f000 f9ef 	bl	800c1b8 <vPortYield>
	}
 800bdda:	bd70      	pop	{r4, r5, r6, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 800bddc:	4b08      	ldr	r3, [pc, #32]	; (800be00 <vTaskDelay+0x30>)
 800bdde:	68dd      	ldr	r5, [r3, #12]
 800bde0:	2d00      	cmp	r5, #0
 800bde2:	d001      	beq.n	800bde8 <vTaskDelay+0x18>
 800bde4:	b672      	cpsid	i
 800bde6:	e7fe      	b.n	800bde6 <vTaskDelay+0x16>
			vTaskSuspendAll();
 800bde8:	f7ff ff26 	bl	800bc38 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 800bdec:	0029      	movs	r1, r5
 800bdee:	0020      	movs	r0, r4
 800bdf0:	f7ff fde2 	bl	800b9b8 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 800bdf4:	f7ff ff94 	bl	800bd20 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 800bdf8:	2800      	cmp	r0, #0
 800bdfa:	d0ec      	beq.n	800bdd6 <vTaskDelay+0x6>
 800bdfc:	e7ed      	b.n	800bdda <vTaskDelay+0xa>
 800bdfe:	46c0      	nop			; (mov r8, r8)
 800be00:	2000048c 	.word	0x2000048c

0800be04 <prvIdleTask>:
{
 800be04:	b570      	push	{r4, r5, r6, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800be06:	4d14      	ldr	r5, [pc, #80]	; (800be58 <prvIdleTask+0x54>)
 800be08:	68ab      	ldr	r3, [r5, #8]
 800be0a:	2b00      	cmp	r3, #0
 800be0c:	d106      	bne.n	800be1c <prvIdleTask+0x18>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800be0e:	4b13      	ldr	r3, [pc, #76]	; (800be5c <prvIdleTask+0x58>)
 800be10:	681b      	ldr	r3, [r3, #0]
 800be12:	2b01      	cmp	r3, #1
 800be14:	d9f7      	bls.n	800be06 <prvIdleTask+0x2>
				taskYIELD();
 800be16:	f000 f9cf 	bl	800c1b8 <vPortYield>
 800be1a:	e7f4      	b.n	800be06 <prvIdleTask+0x2>
			vTaskSuspendAll();
 800be1c:	f7ff ff0c 	bl	800bc38 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 800be20:	4c0f      	ldr	r4, [pc, #60]	; (800be60 <prvIdleTask+0x5c>)
 800be22:	6ea6      	ldr	r6, [r4, #104]	; 0x68
			( void ) xTaskResumeAll();
 800be24:	f7ff ff7c 	bl	800bd20 <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 800be28:	2e00      	cmp	r6, #0
 800be2a:	d0ec      	beq.n	800be06 <prvIdleTask+0x2>
				taskENTER_CRITICAL();
 800be2c:	f000 f9d0 	bl	800c1d0 <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 800be30:	6f63      	ldr	r3, [r4, #116]	; 0x74
 800be32:	68de      	ldr	r6, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800be34:	1d30      	adds	r0, r6, #4
 800be36:	f7ff fb38 	bl	800b4aa <uxListRemove>
					--uxCurrentNumberOfTasks;
 800be3a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800be3c:	3b01      	subs	r3, #1
 800be3e:	62a3      	str	r3, [r4, #40]	; 0x28
					--uxDeletedTasksWaitingCleanUp;
 800be40:	68ab      	ldr	r3, [r5, #8]
 800be42:	3b01      	subs	r3, #1
 800be44:	60ab      	str	r3, [r5, #8]
				taskEXIT_CRITICAL();
 800be46:	f000 f9cf 	bl	800c1e8 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 800be4a:	6b30      	ldr	r0, [r6, #48]	; 0x30
 800be4c:	f000 f95a 	bl	800c104 <vPortFree>
			vPortFree( pxTCB );
 800be50:	0030      	movs	r0, r6
 800be52:	f000 f957 	bl	800c104 <vPortFree>
 800be56:	e7d6      	b.n	800be06 <prvIdleTask+0x2>
 800be58:	2000048c 	.word	0x2000048c
 800be5c:	200004ac 	.word	0x200004ac
 800be60:	2000040c 	.word	0x2000040c

0800be64 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800be64:	4914      	ldr	r1, [pc, #80]	; (800beb8 <vTaskSwitchContext+0x54>)
{
 800be66:	b570      	push	{r4, r5, r6, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800be68:	68cb      	ldr	r3, [r1, #12]
 800be6a:	2b00      	cmp	r3, #0
 800be6c:	d002      	beq.n	800be74 <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
 800be6e:	2301      	movs	r3, #1
 800be70:	61cb      	str	r3, [r1, #28]
}
 800be72:	bd70      	pop	{r4, r5, r6, pc}
 800be74:	2514      	movs	r5, #20
		xYieldPending = pdFALSE;
 800be76:	61cb      	str	r3, [r1, #28]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800be78:	684b      	ldr	r3, [r1, #4]
 800be7a:	4810      	ldr	r0, [pc, #64]	; (800bebc <vTaskSwitchContext+0x58>)
 800be7c:	002a      	movs	r2, r5
 800be7e:	435a      	muls	r2, r3
 800be80:	1814      	adds	r4, r2, r0
 800be82:	6826      	ldr	r6, [r4, #0]
 800be84:	2e00      	cmp	r6, #0
 800be86:	d011      	beq.n	800beac <vTaskSwitchContext+0x48>
 800be88:	6865      	ldr	r5, [r4, #4]
 800be8a:	3208      	adds	r2, #8
 800be8c:	686d      	ldr	r5, [r5, #4]
 800be8e:	1812      	adds	r2, r2, r0
 800be90:	6065      	str	r5, [r4, #4]
 800be92:	4295      	cmp	r5, r2
 800be94:	d101      	bne.n	800be9a <vTaskSwitchContext+0x36>
 800be96:	686a      	ldr	r2, [r5, #4]
 800be98:	6062      	str	r2, [r4, #4]
 800be9a:	2214      	movs	r2, #20
 800be9c:	435a      	muls	r2, r3
 800be9e:	1880      	adds	r0, r0, r2
 800bea0:	6842      	ldr	r2, [r0, #4]
 800bea2:	68d0      	ldr	r0, [r2, #12]
 800bea4:	4a06      	ldr	r2, [pc, #24]	; (800bec0 <vTaskSwitchContext+0x5c>)
 800bea6:	60d0      	str	r0, [r2, #12]
 800bea8:	604b      	str	r3, [r1, #4]
}
 800beaa:	e7e2      	b.n	800be72 <vTaskSwitchContext+0xe>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800beac:	2b00      	cmp	r3, #0
 800beae:	d101      	bne.n	800beb4 <vTaskSwitchContext+0x50>
 800beb0:	b672      	cpsid	i
 800beb2:	e7fe      	b.n	800beb2 <vTaskSwitchContext+0x4e>
 800beb4:	3b01      	subs	r3, #1
 800beb6:	e7e1      	b.n	800be7c <vTaskSwitchContext+0x18>
 800beb8:	2000048c 	.word	0x2000048c
 800bebc:	200004ac 	.word	0x200004ac
 800bec0:	2000040c 	.word	0x2000040c

0800bec4 <vTaskPlaceOnEventList>:
{
 800bec4:	b510      	push	{r4, lr}
 800bec6:	000c      	movs	r4, r1
	configASSERT( pxEventList );
 800bec8:	2800      	cmp	r0, #0
 800beca:	d101      	bne.n	800bed0 <vTaskPlaceOnEventList+0xc>
 800becc:	b672      	cpsid	i
 800bece:	e7fe      	b.n	800bece <vTaskPlaceOnEventList+0xa>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800bed0:	4b04      	ldr	r3, [pc, #16]	; (800bee4 <vTaskPlaceOnEventList+0x20>)
 800bed2:	68d9      	ldr	r1, [r3, #12]
 800bed4:	3118      	adds	r1, #24
 800bed6:	f7ff fad1 	bl	800b47c <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800beda:	2101      	movs	r1, #1
 800bedc:	0020      	movs	r0, r4
 800bede:	f7ff fd6b 	bl	800b9b8 <prvAddCurrentTaskToDelayedList>
}
 800bee2:	bd10      	pop	{r4, pc}
 800bee4:	2000040c 	.word	0x2000040c

0800bee8 <xTaskRemoveFromEventList>:
{
 800bee8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800beea:	68c3      	ldr	r3, [r0, #12]
 800beec:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 800beee:	2c00      	cmp	r4, #0
 800bef0:	d101      	bne.n	800bef6 <xTaskRemoveFromEventList+0xe>
 800bef2:	b672      	cpsid	i
 800bef4:	e7fe      	b.n	800bef4 <xTaskRemoveFromEventList+0xc>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800bef6:	0027      	movs	r7, r4
 800bef8:	3718      	adds	r7, #24
 800befa:	0038      	movs	r0, r7
 800befc:	f7ff fad5 	bl	800b4aa <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800bf00:	4d10      	ldr	r5, [pc, #64]	; (800bf44 <xTaskRemoveFromEventList+0x5c>)
 800bf02:	4e11      	ldr	r6, [pc, #68]	; (800bf48 <xTaskRemoveFromEventList+0x60>)
 800bf04:	68eb      	ldr	r3, [r5, #12]
 800bf06:	2b00      	cmp	r3, #0
 800bf08:	d118      	bne.n	800bf3c <xTaskRemoveFromEventList+0x54>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800bf0a:	1d27      	adds	r7, r4, #4
 800bf0c:	0038      	movs	r0, r7
 800bf0e:	f7ff facc 	bl	800b4aa <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800bf12:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800bf14:	686a      	ldr	r2, [r5, #4]
 800bf16:	4293      	cmp	r3, r2
 800bf18:	d900      	bls.n	800bf1c <xTaskRemoveFromEventList+0x34>
 800bf1a:	606b      	str	r3, [r5, #4]
 800bf1c:	2014      	movs	r0, #20
 800bf1e:	4358      	muls	r0, r3
 800bf20:	4b0a      	ldr	r3, [pc, #40]	; (800bf4c <xTaskRemoveFromEventList+0x64>)
 800bf22:	18c0      	adds	r0, r0, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800bf24:	0039      	movs	r1, r7
 800bf26:	f7ff fa9d 	bl	800b464 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800bf2a:	68f3      	ldr	r3, [r6, #12]
 800bf2c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800bf2e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		xReturn = pdFALSE;
 800bf30:	2000      	movs	r0, #0
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800bf32:	429a      	cmp	r2, r3
 800bf34:	d901      	bls.n	800bf3a <xTaskRemoveFromEventList+0x52>
		xYieldPending = pdTRUE;
 800bf36:	3001      	adds	r0, #1
 800bf38:	61e8      	str	r0, [r5, #28]
}
 800bf3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800bf3c:	0030      	movs	r0, r6
 800bf3e:	3054      	adds	r0, #84	; 0x54
 800bf40:	e7f0      	b.n	800bf24 <xTaskRemoveFromEventList+0x3c>
 800bf42:	46c0      	nop			; (mov r8, r8)
 800bf44:	2000048c 	.word	0x2000048c
 800bf48:	2000040c 	.word	0x2000040c
 800bf4c:	200004ac 	.word	0x200004ac

0800bf50 <vTaskSetTimeOutState>:
	configASSERT( pxTimeOut );
 800bf50:	2800      	cmp	r0, #0
 800bf52:	d101      	bne.n	800bf58 <vTaskSetTimeOutState+0x8>
 800bf54:	b672      	cpsid	i
 800bf56:	e7fe      	b.n	800bf56 <vTaskSetTimeOutState+0x6>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800bf58:	4b03      	ldr	r3, [pc, #12]	; (800bf68 <vTaskSetTimeOutState+0x18>)
 800bf5a:	695b      	ldr	r3, [r3, #20]
 800bf5c:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800bf5e:	4b03      	ldr	r3, [pc, #12]	; (800bf6c <vTaskSetTimeOutState+0x1c>)
 800bf60:	689b      	ldr	r3, [r3, #8]
 800bf62:	6043      	str	r3, [r0, #4]
}
 800bf64:	4770      	bx	lr
 800bf66:	46c0      	nop			; (mov r8, r8)
 800bf68:	2000048c 	.word	0x2000048c
 800bf6c:	2000040c 	.word	0x2000040c

0800bf70 <xTaskCheckForTimeOut>:
{
 800bf70:	b570      	push	{r4, r5, r6, lr}
 800bf72:	0004      	movs	r4, r0
 800bf74:	000d      	movs	r5, r1
	configASSERT( pxTimeOut );
 800bf76:	2800      	cmp	r0, #0
 800bf78:	d101      	bne.n	800bf7e <xTaskCheckForTimeOut+0xe>
 800bf7a:	b672      	cpsid	i
 800bf7c:	e7fe      	b.n	800bf7c <xTaskCheckForTimeOut+0xc>
	configASSERT( pxTicksToWait );
 800bf7e:	2900      	cmp	r1, #0
 800bf80:	d101      	bne.n	800bf86 <xTaskCheckForTimeOut+0x16>
 800bf82:	b672      	cpsid	i
 800bf84:	e7fe      	b.n	800bf84 <xTaskCheckForTimeOut+0x14>
	taskENTER_CRITICAL();
 800bf86:	f000 f923 	bl	800c1d0 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 800bf8a:	4b0f      	ldr	r3, [pc, #60]	; (800bfc8 <xTaskCheckForTimeOut+0x58>)
				xReturn = pdFALSE;
 800bf8c:	2600      	movs	r6, #0
		const TickType_t xConstTickCount = xTickCount;
 800bf8e:	6899      	ldr	r1, [r3, #8]
			if( *pxTicksToWait == portMAX_DELAY )
 800bf90:	682b      	ldr	r3, [r5, #0]
 800bf92:	1c5a      	adds	r2, r3, #1
 800bf94:	d013      	beq.n	800bfbe <xTaskCheckForTimeOut+0x4e>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800bf96:	4a0d      	ldr	r2, [pc, #52]	; (800bfcc <xTaskCheckForTimeOut+0x5c>)
 800bf98:	6826      	ldr	r6, [r4, #0]
 800bf9a:	6950      	ldr	r0, [r2, #20]
 800bf9c:	6862      	ldr	r2, [r4, #4]
 800bf9e:	4286      	cmp	r6, r0
 800bfa0:	d002      	beq.n	800bfa8 <xTaskCheckForTimeOut+0x38>
			xReturn = pdTRUE;
 800bfa2:	2601      	movs	r6, #1
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800bfa4:	4291      	cmp	r1, r2
 800bfa6:	d20a      	bcs.n	800bfbe <xTaskCheckForTimeOut+0x4e>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800bfa8:	1a88      	subs	r0, r1, r2
			xReturn = pdTRUE;
 800bfaa:	2601      	movs	r6, #1
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800bfac:	4283      	cmp	r3, r0
 800bfae:	d906      	bls.n	800bfbe <xTaskCheckForTimeOut+0x4e>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 800bfb0:	1a5b      	subs	r3, r3, r1
 800bfb2:	189b      	adds	r3, r3, r2
 800bfb4:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 800bfb6:	0020      	movs	r0, r4
 800bfb8:	f7ff ffca 	bl	800bf50 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 800bfbc:	2600      	movs	r6, #0
	taskEXIT_CRITICAL();
 800bfbe:	f000 f913 	bl	800c1e8 <vPortExitCritical>
}
 800bfc2:	0030      	movs	r0, r6
 800bfc4:	bd70      	pop	{r4, r5, r6, pc}
 800bfc6:	46c0      	nop			; (mov r8, r8)
 800bfc8:	2000040c 	.word	0x2000040c
 800bfcc:	2000048c 	.word	0x2000048c

0800bfd0 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 800bfd0:	2201      	movs	r2, #1
 800bfd2:	4b01      	ldr	r3, [pc, #4]	; (800bfd8 <vTaskMissedYield+0x8>)
 800bfd4:	61da      	str	r2, [r3, #28]
}
 800bfd6:	4770      	bx	lr
 800bfd8:	2000048c 	.word	0x2000048c

0800bfdc <prvInsertBlockIntoFreeList>:
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800bfdc:	4b0f      	ldr	r3, [pc, #60]	; (800c01c <prvInsertBlockIntoFreeList+0x40>)
{
 800bfde:	b530      	push	{r4, r5, lr}
 800bfe0:	001d      	movs	r5, r3
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800bfe2:	681a      	ldr	r2, [r3, #0]
 800bfe4:	4282      	cmp	r2, r0
 800bfe6:	d317      	bcc.n	800c018 <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800bfe8:	685c      	ldr	r4, [r3, #4]
 800bfea:	1919      	adds	r1, r3, r4
 800bfec:	4288      	cmp	r0, r1
 800bfee:	d103      	bne.n	800bff8 <prvInsertBlockIntoFreeList+0x1c>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800bff0:	6841      	ldr	r1, [r0, #4]
 800bff2:	0018      	movs	r0, r3
 800bff4:	1909      	adds	r1, r1, r4
 800bff6:	6059      	str	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800bff8:	6841      	ldr	r1, [r0, #4]
 800bffa:	1844      	adds	r4, r0, r1
 800bffc:	42a2      	cmp	r2, r4
 800bffe:	d106      	bne.n	800c00e <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800c000:	68ac      	ldr	r4, [r5, #8]
 800c002:	42a2      	cmp	r2, r4
 800c004:	d003      	beq.n	800c00e <prvInsertBlockIntoFreeList+0x32>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800c006:	6854      	ldr	r4, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800c008:	6812      	ldr	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800c00a:	1861      	adds	r1, r4, r1
 800c00c:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 800c00e:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 800c010:	4298      	cmp	r0, r3
 800c012:	d000      	beq.n	800c016 <prvInsertBlockIntoFreeList+0x3a>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800c014:	6018      	str	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800c016:	bd30      	pop	{r4, r5, pc}
 800c018:	0013      	movs	r3, r2
 800c01a:	e7e2      	b.n	800bfe2 <prvInsertBlockIntoFreeList+0x6>
 800c01c:	20000538 	.word	0x20000538

0800c020 <pvPortMalloc>:
{
 800c020:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800c022:	0005      	movs	r5, r0
	vTaskSuspendAll();
 800c024:	f7ff fe08 	bl	800bc38 <vTaskSuspendAll>
		if( pxEnd == NULL )
 800c028:	4c33      	ldr	r4, [pc, #204]	; (800c0f8 <pvPortMalloc+0xd8>)
 800c02a:	68a3      	ldr	r3, [r4, #8]
 800c02c:	2b00      	cmp	r3, #0
 800c02e:	d11a      	bne.n	800c066 <pvPortMalloc+0x46>
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800c030:	2107      	movs	r1, #7
	uxAddress = ( size_t ) ucHeap;
 800c032:	4a32      	ldr	r2, [pc, #200]	; (800c0fc <pvPortMalloc+0xdc>)
 800c034:	4b32      	ldr	r3, [pc, #200]	; (800c100 <pvPortMalloc+0xe0>)
 800c036:	18d3      	adds	r3, r2, r3
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800c038:	420a      	tst	r2, r1
 800c03a:	d03c      	beq.n	800c0b6 <pvPortMalloc+0x96>
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800c03c:	1852      	adds	r2, r2, r1
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800c03e:	438a      	bics	r2, r1
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 800c040:	1a9b      	subs	r3, r3, r2
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800c042:	2007      	movs	r0, #7
	xStart.xBlockSize = ( size_t ) 0;
 800c044:	2100      	movs	r1, #0
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 800c046:	18d3      	adds	r3, r2, r3
	uxAddress -= xHeapStructSize;
 800c048:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800c04a:	4383      	bics	r3, r0
	xStart.xBlockSize = ( size_t ) 0;
 800c04c:	6061      	str	r1, [r4, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800c04e:	6022      	str	r2, [r4, #0]
	pxEnd->xBlockSize = 0;
 800c050:	6059      	str	r1, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 800c052:	6019      	str	r1, [r3, #0]
	pxEnd = ( void * ) uxAddress;
 800c054:	60a3      	str	r3, [r4, #8]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800c056:	1a99      	subs	r1, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 800c058:	6013      	str	r3, [r2, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800c05a:	2380      	movs	r3, #128	; 0x80
 800c05c:	061b      	lsls	r3, r3, #24
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800c05e:	6051      	str	r1, [r2, #4]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800c060:	60e1      	str	r1, [r4, #12]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800c062:	6121      	str	r1, [r4, #16]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800c064:	6163      	str	r3, [r4, #20]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800c066:	6967      	ldr	r7, [r4, #20]
 800c068:	423d      	tst	r5, r7
 800c06a:	d140      	bne.n	800c0ee <pvPortMalloc+0xce>
			if( xWantedSize > 0 )
 800c06c:	2d00      	cmp	r5, #0
 800c06e:	d03e      	beq.n	800c0ee <pvPortMalloc+0xce>
				xWantedSize += xHeapStructSize;
 800c070:	002b      	movs	r3, r5
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800c072:	2207      	movs	r2, #7
				xWantedSize += xHeapStructSize;
 800c074:	3308      	adds	r3, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800c076:	4213      	tst	r3, r2
 800c078:	d001      	beq.n	800c07e <pvPortMalloc+0x5e>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800c07a:	4393      	bics	r3, r2
 800c07c:	3308      	adds	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 800c07e:	2b00      	cmp	r3, #0
 800c080:	d035      	beq.n	800c0ee <pvPortMalloc+0xce>
 800c082:	6926      	ldr	r6, [r4, #16]
 800c084:	429e      	cmp	r6, r3
 800c086:	d332      	bcc.n	800c0ee <pvPortMalloc+0xce>
				pxPreviousBlock = &xStart;
 800c088:	0021      	movs	r1, r4
				pxBlock = xStart.pxNextFreeBlock;
 800c08a:	6825      	ldr	r5, [r4, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800c08c:	686a      	ldr	r2, [r5, #4]
 800c08e:	429a      	cmp	r2, r3
 800c090:	d202      	bcs.n	800c098 <pvPortMalloc+0x78>
 800c092:	6828      	ldr	r0, [r5, #0]
 800c094:	2800      	cmp	r0, #0
 800c096:	d110      	bne.n	800c0ba <pvPortMalloc+0x9a>
				if( pxBlock != pxEnd )
 800c098:	68a0      	ldr	r0, [r4, #8]
 800c09a:	42a8      	cmp	r0, r5
 800c09c:	d027      	beq.n	800c0ee <pvPortMalloc+0xce>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c09e:	6808      	ldr	r0, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800c0a0:	1ad2      	subs	r2, r2, r3
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c0a2:	9001      	str	r0, [sp, #4]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 800c0a4:	6828      	ldr	r0, [r5, #0]
 800c0a6:	6008      	str	r0, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800c0a8:	2a10      	cmp	r2, #16
 800c0aa:	d90d      	bls.n	800c0c8 <pvPortMalloc+0xa8>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800c0ac:	18e8      	adds	r0, r5, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 800c0ae:	0741      	lsls	r1, r0, #29
 800c0b0:	d006      	beq.n	800c0c0 <pvPortMalloc+0xa0>
 800c0b2:	b672      	cpsid	i
 800c0b4:	e7fe      	b.n	800c0b4 <pvPortMalloc+0x94>
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 800c0b6:	4b12      	ldr	r3, [pc, #72]	; (800c100 <pvPortMalloc+0xe0>)
 800c0b8:	e7c3      	b.n	800c042 <pvPortMalloc+0x22>
 800c0ba:	0029      	movs	r1, r5
 800c0bc:	0005      	movs	r5, r0
 800c0be:	e7e5      	b.n	800c08c <pvPortMalloc+0x6c>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 800c0c0:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 800c0c2:	606b      	str	r3, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 800c0c4:	f7ff ff8a 	bl	800bfdc <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800c0c8:	686b      	ldr	r3, [r5, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800c0ca:	68e2      	ldr	r2, [r4, #12]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800c0cc:	1af6      	subs	r6, r6, r3
 800c0ce:	6126      	str	r6, [r4, #16]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800c0d0:	4296      	cmp	r6, r2
 800c0d2:	d200      	bcs.n	800c0d6 <pvPortMalloc+0xb6>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 800c0d4:	60e6      	str	r6, [r4, #12]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800c0d6:	431f      	orrs	r7, r3
					pxBlock->pxNextFreeBlock = NULL;
 800c0d8:	2300      	movs	r3, #0
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c0da:	9c01      	ldr	r4, [sp, #4]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800c0dc:	606f      	str	r7, [r5, #4]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c0de:	3408      	adds	r4, #8
					pxBlock->pxNextFreeBlock = NULL;
 800c0e0:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 800c0e2:	f7ff fe1d 	bl	800bd20 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 800c0e6:	0763      	lsls	r3, r4, #29
 800c0e8:	d003      	beq.n	800c0f2 <pvPortMalloc+0xd2>
 800c0ea:	b672      	cpsid	i
 800c0ec:	e7fe      	b.n	800c0ec <pvPortMalloc+0xcc>
void *pvReturn = NULL;
 800c0ee:	2400      	movs	r4, #0
 800c0f0:	e7f7      	b.n	800c0e2 <pvPortMalloc+0xc2>
}
 800c0f2:	0020      	movs	r0, r4
 800c0f4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800c0f6:	46c0      	nop			; (mov r8, r8)
 800c0f8:	20000538 	.word	0x20000538
 800c0fc:	20000550 	.word	0x20000550
 800c100:	00001450 	.word	0x00001450

0800c104 <vPortFree>:
{
 800c104:	b570      	push	{r4, r5, r6, lr}
	if( pv != NULL )
 800c106:	2800      	cmp	r0, #0
 800c108:	d01a      	beq.n	800c140 <vPortFree+0x3c>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800c10a:	4d0e      	ldr	r5, [pc, #56]	; (800c144 <vPortFree+0x40>)
 800c10c:	3808      	subs	r0, #8
 800c10e:	6843      	ldr	r3, [r0, #4]
 800c110:	696a      	ldr	r2, [r5, #20]
 800c112:	0004      	movs	r4, r0
 800c114:	421a      	tst	r2, r3
 800c116:	d101      	bne.n	800c11c <vPortFree+0x18>
 800c118:	b672      	cpsid	i
 800c11a:	e7fe      	b.n	800c11a <vPortFree+0x16>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800c11c:	6801      	ldr	r1, [r0, #0]
 800c11e:	2900      	cmp	r1, #0
 800c120:	d001      	beq.n	800c126 <vPortFree+0x22>
 800c122:	b672      	cpsid	i
 800c124:	e7fe      	b.n	800c124 <vPortFree+0x20>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800c126:	4393      	bics	r3, r2
 800c128:	6043      	str	r3, [r0, #4]
				vTaskSuspendAll();
 800c12a:	f7ff fd85 	bl	800bc38 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 800c12e:	692a      	ldr	r2, [r5, #16]
 800c130:	6863      	ldr	r3, [r4, #4]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800c132:	0020      	movs	r0, r4
					xFreeBytesRemaining += pxLink->xBlockSize;
 800c134:	189b      	adds	r3, r3, r2
 800c136:	612b      	str	r3, [r5, #16]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800c138:	f7ff ff50 	bl	800bfdc <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 800c13c:	f7ff fdf0 	bl	800bd20 <xTaskResumeAll>
}
 800c140:	bd70      	pop	{r4, r5, r6, pc}
 800c142:	46c0      	nop			; (mov r8, r8)
 800c144:	20000538 	.word	0x20000538

0800c148 <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800c148:	4b03      	ldr	r3, [pc, #12]	; (800c158 <prvTaskExitError+0x10>)
 800c14a:	681b      	ldr	r3, [r3, #0]
 800c14c:	3301      	adds	r3, #1
 800c14e:	d001      	beq.n	800c154 <prvTaskExitError+0xc>
 800c150:	b672      	cpsid	i
 800c152:	e7fe      	b.n	800c152 <prvTaskExitError+0xa>
	portDISABLE_INTERRUPTS();
 800c154:	b672      	cpsid	i
 800c156:	e7fe      	b.n	800c156 <prvTaskExitError+0xe>
 800c158:	2000025c 	.word	0x2000025c
 800c15c:	00000000 	.word	0x00000000

0800c160 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
 800c160:	4a0b      	ldr	r2, [pc, #44]	; (800c190 <pxCurrentTCBConst2>)
 800c162:	6813      	ldr	r3, [r2, #0]
 800c164:	6818      	ldr	r0, [r3, #0]
 800c166:	3020      	adds	r0, #32
 800c168:	f380 8809 	msr	PSP, r0
 800c16c:	2002      	movs	r0, #2
 800c16e:	f380 8814 	msr	CONTROL, r0
 800c172:	f3bf 8f6f 	isb	sy
 800c176:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
 800c178:	46ae      	mov	lr, r5
 800c17a:	bc08      	pop	{r3}
 800c17c:	bc04      	pop	{r2}
 800c17e:	b662      	cpsie	i
 800c180:	4718      	bx	r3
 800c182:	46c0      	nop			; (mov r8, r8)
 800c184:	46c0      	nop			; (mov r8, r8)
 800c186:	46c0      	nop			; (mov r8, r8)
 800c188:	46c0      	nop			; (mov r8, r8)
 800c18a:	46c0      	nop			; (mov r8, r8)
 800c18c:	46c0      	nop			; (mov r8, r8)
 800c18e:	46c0      	nop			; (mov r8, r8)

0800c190 <pxCurrentTCBConst2>:
 800c190:	20000418 	.word	0x20000418

0800c194 <pxPortInitialiseStack>:
{
 800c194:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800c196:	2480      	movs	r4, #128	; 0x80
 800c198:	1f03      	subs	r3, r0, #4
 800c19a:	0464      	lsls	r4, r4, #17
 800c19c:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 800c19e:	3b04      	subs	r3, #4
 800c1a0:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 800c1a2:	4903      	ldr	r1, [pc, #12]	; (800c1b0 <pxPortInitialiseStack+0x1c>)
 800c1a4:	3b04      	subs	r3, #4
 800c1a6:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800c1a8:	3b14      	subs	r3, #20
	pxTopOfStack -= 8; /* R11..R4. */
 800c1aa:	3840      	subs	r0, #64	; 0x40
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800c1ac:	601a      	str	r2, [r3, #0]
}
 800c1ae:	bd10      	pop	{r4, pc}
 800c1b0:	0800c149 	.word	0x0800c149

0800c1b4 <SVC_Handler>:
}
 800c1b4:	4770      	bx	lr
	...

0800c1b8 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
 800c1b8:	2280      	movs	r2, #128	; 0x80
 800c1ba:	4b04      	ldr	r3, [pc, #16]	; (800c1cc <vPortYield+0x14>)
 800c1bc:	0552      	lsls	r2, r2, #21
 800c1be:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 800c1c0:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800c1c4:	f3bf 8f6f 	isb	sy
}
 800c1c8:	4770      	bx	lr
 800c1ca:	46c0      	nop			; (mov r8, r8)
 800c1cc:	e000ed04 	.word	0xe000ed04

0800c1d0 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
 800c1d0:	b672      	cpsid	i
    uxCriticalNesting++;
 800c1d2:	4a04      	ldr	r2, [pc, #16]	; (800c1e4 <vPortEnterCritical+0x14>)
 800c1d4:	6813      	ldr	r3, [r2, #0]
 800c1d6:	3301      	adds	r3, #1
 800c1d8:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
 800c1da:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800c1de:	f3bf 8f6f 	isb	sy
}
 800c1e2:	4770      	bx	lr
 800c1e4:	2000025c 	.word	0x2000025c

0800c1e8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
 800c1e8:	4a05      	ldr	r2, [pc, #20]	; (800c200 <vPortExitCritical+0x18>)
 800c1ea:	6813      	ldr	r3, [r2, #0]
 800c1ec:	2b00      	cmp	r3, #0
 800c1ee:	d101      	bne.n	800c1f4 <vPortExitCritical+0xc>
 800c1f0:	b672      	cpsid	i
 800c1f2:	e7fe      	b.n	800c1f2 <vPortExitCritical+0xa>
    uxCriticalNesting--;
 800c1f4:	3b01      	subs	r3, #1
 800c1f6:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
 800c1f8:	2b00      	cmp	r3, #0
 800c1fa:	d100      	bne.n	800c1fe <vPortExitCritical+0x16>
    {
        portENABLE_INTERRUPTS();
 800c1fc:	b662      	cpsie	i
    }
}
 800c1fe:	4770      	bx	lr
 800c200:	2000025c 	.word	0x2000025c

0800c204 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
	__asm volatile(
 800c204:	f3ef 8010 	mrs	r0, PRIMASK
 800c208:	b672      	cpsid	i
 800c20a:	4770      	bx	lr
					" bx lr				  "
				  );

	/* To avoid compiler warnings.  This line will never be reached. */
	return 0;
}
 800c20c:	2000      	movs	r0, #0

0800c20e <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( uint32_t ulMask )
{
	__asm volatile(
 800c20e:	f380 8810 	msr	PRIMASK, r0
 800c212:	4770      	bx	lr
	...

0800c220 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 800c220:	f3ef 8009 	mrs	r0, PSP
 800c224:	4b0e      	ldr	r3, [pc, #56]	; (800c260 <pxCurrentTCBConst>)
 800c226:	681a      	ldr	r2, [r3, #0]
 800c228:	3820      	subs	r0, #32
 800c22a:	6010      	str	r0, [r2, #0]
 800c22c:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800c22e:	4644      	mov	r4, r8
 800c230:	464d      	mov	r5, r9
 800c232:	4656      	mov	r6, sl
 800c234:	465f      	mov	r7, fp
 800c236:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800c238:	b508      	push	{r3, lr}
 800c23a:	b672      	cpsid	i
 800c23c:	f7ff fe12 	bl	800be64 <vTaskSwitchContext>
 800c240:	b662      	cpsie	i
 800c242:	bc0c      	pop	{r2, r3}
 800c244:	6811      	ldr	r1, [r2, #0]
 800c246:	6808      	ldr	r0, [r1, #0]
 800c248:	3010      	adds	r0, #16
 800c24a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800c24c:	46a0      	mov	r8, r4
 800c24e:	46a9      	mov	r9, r5
 800c250:	46b2      	mov	sl, r6
 800c252:	46bb      	mov	fp, r7
 800c254:	f380 8809 	msr	PSP, r0
 800c258:	3820      	subs	r0, #32
 800c25a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800c25c:	4718      	bx	r3
 800c25e:	46c0      	nop			; (mov r8, r8)

0800c260 <pxCurrentTCBConst>:
 800c260:	20000418 	.word	0x20000418

0800c264 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 800c264:	b510      	push	{r4, lr}
uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 800c266:	f7ff ffcd 	bl	800c204 <ulSetInterruptMaskFromISR>
 800c26a:	0004      	movs	r4, r0
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 800c26c:	f7ff fcf2 	bl	800bc54 <xTaskIncrementTick>
 800c270:	2800      	cmp	r0, #0
 800c272:	d003      	beq.n	800c27c <xPortSysTickHandler+0x18>
		{
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 800c274:	2280      	movs	r2, #128	; 0x80
 800c276:	4b03      	ldr	r3, [pc, #12]	; (800c284 <xPortSysTickHandler+0x20>)
 800c278:	0552      	lsls	r2, r2, #21
 800c27a:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 800c27c:	0020      	movs	r0, r4
 800c27e:	f7ff ffc6 	bl	800c20e <vClearInterruptMaskFromISR>
}
 800c282:	bd10      	pop	{r4, pc}
 800c284:	e000ed04 	.word	0xe000ed04

0800c288 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */
	/* Configure SysTick to interrupt at the requested rate. */

	portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800c288:	21fa      	movs	r1, #250	; 0xfa
 800c28a:	4b06      	ldr	r3, [pc, #24]	; (800c2a4 <vPortSetupTimerInterrupt+0x1c>)
{
 800c28c:	b510      	push	{r4, lr}
	portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800c28e:	6818      	ldr	r0, [r3, #0]
 800c290:	0089      	lsls	r1, r1, #2
 800c292:	f7f9 fb8f 	bl	80059b4 <__udivsi3>
	portNVIC_SYSTICK_CTRL = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 800c296:	2207      	movs	r2, #7
	portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800c298:	4b03      	ldr	r3, [pc, #12]	; (800c2a8 <vPortSetupTimerInterrupt+0x20>)
 800c29a:	3801      	subs	r0, #1
 800c29c:	6018      	str	r0, [r3, #0]
	portNVIC_SYSTICK_CTRL = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 800c29e:	4b03      	ldr	r3, [pc, #12]	; (800c2ac <vPortSetupTimerInterrupt+0x24>)
 800c2a0:	601a      	str	r2, [r3, #0]
}
 800c2a2:	bd10      	pop	{r4, pc}
 800c2a4:	20000054 	.word	0x20000054
 800c2a8:	e000e014 	.word	0xe000e014
 800c2ac:	e000e010 	.word	0xe000e010

0800c2b0 <xPortStartScheduler>:
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 800c2b0:	22ff      	movs	r2, #255	; 0xff
 800c2b2:	4b0a      	ldr	r3, [pc, #40]	; (800c2dc <xPortStartScheduler+0x2c>)
 800c2b4:	0412      	lsls	r2, r2, #16
 800c2b6:	6819      	ldr	r1, [r3, #0]
{
 800c2b8:	b510      	push	{r4, lr}
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 800c2ba:	430a      	orrs	r2, r1
 800c2bc:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 800c2be:	22ff      	movs	r2, #255	; 0xff
 800c2c0:	6819      	ldr	r1, [r3, #0]
 800c2c2:	0612      	lsls	r2, r2, #24
 800c2c4:	430a      	orrs	r2, r1
 800c2c6:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 800c2c8:	f7ff ffde 	bl	800c288 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 800c2cc:	2200      	movs	r2, #0
 800c2ce:	4b04      	ldr	r3, [pc, #16]	; (800c2e0 <xPortStartScheduler+0x30>)
 800c2d0:	601a      	str	r2, [r3, #0]
	vPortStartFirstTask();
 800c2d2:	f7ff ff45 	bl	800c160 <vPortStartFirstTask>
	prvTaskExitError();
 800c2d6:	f7ff ff37 	bl	800c148 <prvTaskExitError>
 800c2da:	46c0      	nop			; (mov r8, r8)
 800c2dc:	e000ed20 	.word	0xe000ed20
 800c2e0:	2000025c 	.word	0x2000025c

0800c2e4 <Led_Init>:
/**
  * @brief This function performs an init of the LED manager.
  * @retval None
  */
void Led_Init()
{
 800c2e4:	2300      	movs	r3, #0
 800c2e6:	4a08      	ldr	r2, [pc, #32]	; (800c308 <Led_Init+0x24>)
 800c2e8:	b530      	push	{r4, r5, lr}
 800c2ea:	0010      	movs	r0, r2
static inline void prvLedStatusInit(LED_BSP_TypeDef Index)
{
  configASSERT(LED_INDEX_IsValid(Index));

  Status[Index].Index = Index;
  Status[Index].Mode = LED_MODE_OFF;
 800c2ec:	0019      	movs	r1, r3
  Status[Index].Period = LED_PERIOD_DEFAULT;
 800c2ee:	2564      	movs	r5, #100	; 0x64
    LedOrder[i] = i;
 800c2f0:	4c06      	ldr	r4, [pc, #24]	; (800c30c <Led_Init+0x28>)
    prvLedStatusInit((LED_BSP_TypeDef)i);
 800c2f2:	7013      	strb	r3, [r2, #0]
    LedOrder[i] = i;
 800c2f4:	54e3      	strb	r3, [r4, r3]
 800c2f6:	3301      	adds	r3, #1
  Status[Index].Mode = LED_MODE_OFF;
 800c2f8:	7051      	strb	r1, [r2, #1]
  Status[Index].Period = LED_PERIOD_DEFAULT;
 800c2fa:	8095      	strh	r5, [r2, #4]
  Status[Index].Count = 0;
 800c2fc:	80d1      	strh	r1, [r2, #6]
 800c2fe:	3208      	adds	r2, #8
  for(i=0; i<LED_INDEX_LEN; i++)
 800c300:	2b07      	cmp	r3, #7
 800c302:	d1f6      	bne.n	800c2f2 <Led_Init+0xe>
  GlobalCount = 0;
 800c304:	8701      	strh	r1, [r0, #56]	; 0x38
}
 800c306:	bd30      	pop	{r4, r5, pc}
 800c308:	200019a0 	.word	0x200019a0
 800c30c:	20001d1c 	.word	0x20001d1c

0800c310 <Led_Set>:
{
 800c310:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (!LED_INDEX_IsValid(Index) || 
 800c312:	b2c3      	uxtb	r3, r0
{
 800c314:	b089      	sub	sp, #36	; 0x24
 800c316:	0006      	movs	r6, r0
 800c318:	000d      	movs	r5, r1
  if (!LED_INDEX_IsValid(Index) || 
 800c31a:	2b06      	cmp	r3, #6
 800c31c:	d821      	bhi.n	800c362 <Led_Set+0x52>
 800c31e:	2909      	cmp	r1, #9
 800c320:	d81f      	bhi.n	800c362 <Led_Set+0x52>
      !LED_MODE_IsValid(Mode) || 
 800c322:	2902      	cmp	r1, #2
 800c324:	d105      	bne.n	800c332 <Led_Set+0x22>
      !LED_PERIOD_IsValid(Mode, Period) )
 800c326:	0013      	movs	r3, r2
 800c328:	491e      	ldr	r1, [pc, #120]	; (800c3a4 <Led_Set+0x94>)
 800c32a:	3b0a      	subs	r3, #10
 800c32c:	b29b      	uxth	r3, r3
 800c32e:	428b      	cmp	r3, r1
 800c330:	d817      	bhi.n	800c362 <Led_Set+0x52>
  pStatus->Count = 0;
 800c332:	2100      	movs	r1, #0
  pStatus->Mode = Mode;
 800c334:	4c1c      	ldr	r4, [pc, #112]	; (800c3a8 <Led_Set+0x98>)
 800c336:	00f3      	lsls	r3, r6, #3
 800c338:	9301      	str	r3, [sp, #4]
  switch(Mode)
 800c33a:	1e68      	subs	r0, r5, #1
  pStatus->Mode = Mode;
 800c33c:	18e3      	adds	r3, r4, r3
 800c33e:	705d      	strb	r5, [r3, #1]
  pStatus->Period = Period;
 800c340:	809a      	strh	r2, [r3, #4]
  pStatus->Count = 0;
 800c342:	80d9      	strh	r1, [r3, #6]
  switch(Mode)
 800c344:	2808      	cmp	r0, #8
 800c346:	d829      	bhi.n	800c39c <Led_Set+0x8c>
 800c348:	f7f9 fb2a 	bl	80059a0 <__gnu_thumb1_case_uqi>
 800c34c:	10100d05 	.word	0x10100d05
 800c350:	10101010 	.word	0x10101010
 800c354:	10          	.byte	0x10
 800c355:	00          	.byte	0x00
 * @brief  Turn on a LED.
 * @param  cIndex: State Index
 */
void prvLedOn(LED_BSP_TypeDef Index)
{
  USBPD_BSP_LED_On(Index);
 800c356:	0030      	movs	r0, r6
 800c358:	f7fa fd68 	bl	8006e2c <USBPD_BSP_LED_On>
  pStatus->ModePrevious = Mode;
 800c35c:	9b01      	ldr	r3, [sp, #4]
 800c35e:	18e4      	adds	r4, r4, r3
 800c360:	70a5      	strb	r5, [r4, #2]
}
 800c362:	b009      	add	sp, #36	; 0x24
 800c364:	bdf0      	pop	{r4, r5, r6, r7, pc}
    pStatus->Count = pStatus->Period;
 800c366:	00f3      	lsls	r3, r6, #3
 800c368:	18e3      	adds	r3, r4, r3
 800c36a:	80da      	strh	r2, [r3, #6]
    if (xLedThreadId == NULL)
 800c36c:	4b0f      	ldr	r3, [pc, #60]	; (800c3ac <Led_Set+0x9c>)
 800c36e:	681b      	ldr	r3, [r3, #0]
 800c370:	469c      	mov	ip, r3
 800c372:	2b00      	cmp	r3, #0
 800c374:	d10d      	bne.n	800c392 <Led_Set+0x82>
      osThreadDef(LEDThread, prvLedThread, LED_THREAD_PRIORITY, 0, configMINIMAL_STACK_SIZE);
 800c376:	ab03      	add	r3, sp, #12
 800c378:	9300      	str	r3, [sp, #0]
 800c37a:	9a00      	ldr	r2, [sp, #0]
 800c37c:	4b0c      	ldr	r3, [pc, #48]	; (800c3b0 <Led_Set+0xa0>)
 800c37e:	cb83      	ldmia	r3!, {r0, r1, r7}
 800c380:	c283      	stmia	r2!, {r0, r1, r7}
 800c382:	cb03      	ldmia	r3!, {r0, r1}
 800c384:	c203      	stmia	r2!, {r0, r1}
      xLedThreadId = osThreadCreate(osThread(LEDThread), NULL);
 800c386:	4661      	mov	r1, ip
 800c388:	9800      	ldr	r0, [sp, #0]
 800c38a:	f7fe ffcc 	bl	800b326 <osThreadCreate>
 800c38e:	4b07      	ldr	r3, [pc, #28]	; (800c3ac <Led_Set+0x9c>)
 800c390:	6018      	str	r0, [r3, #0]
    if (pStatus->ModePrevious != Mode)
 800c392:	00f3      	lsls	r3, r6, #3
 800c394:	18e3      	adds	r3, r4, r3
 800c396:	789b      	ldrb	r3, [r3, #2]
 800c398:	42ab      	cmp	r3, r5
 800c39a:	d0df      	beq.n	800c35c <Led_Set+0x4c>
 * @brief  Turn off a LED.
 * @param  cIndex: State Index
 */
void prvLedOff(LED_BSP_TypeDef Index)
{
  USBPD_BSP_LED_Off(Index);
 800c39c:	0030      	movs	r0, r6
 800c39e:	f7fa fd53 	bl	8006e48 <USBPD_BSP_LED_Off>
 800c3a2:	e7db      	b.n	800c35c <Led_Set+0x4c>
 800c3a4:	00002706 	.word	0x00002706
 800c3a8:	200019a0 	.word	0x200019a0
 800c3ac:	20001d24 	.word	0x20001d24
 800c3b0:	0800c7bc 	.word	0x0800c7bc

0800c3b4 <prvLedThread>:
{
 800c3b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    half_period = GlobalPeriod>>1;
 800c3b6:	2401      	movs	r4, #1
  osDelay(100);
 800c3b8:	2064      	movs	r0, #100	; 0x64
 800c3ba:	f7fe ffd2 	bl	800b362 <osDelay>
    half_period = GlobalPeriod>>1;
 800c3be:	4f2c      	ldr	r7, [pc, #176]	; (800c470 <prvLedThread+0xbc>)
 800c3c0:	883d      	ldrh	r5, [r7, #0]
 800c3c2:	086d      	lsrs	r5, r5, #1
      if (LED_MODE_IsBlinking(pStatus->Mode))
 800c3c4:	4e2b      	ldr	r6, [pc, #172]	; (800c474 <prvLedThread+0xc0>)
 800c3c6:	00e3      	lsls	r3, r4, #3
 800c3c8:	3b07      	subs	r3, #7
 800c3ca:	5cf0      	ldrb	r0, [r6, r3]
 800c3cc:	1ec3      	subs	r3, r0, #3
 800c3ce:	2b06      	cmp	r3, #6
 800c3d0:	d810      	bhi.n	800c3f4 <prvLedThread+0x40>
        switch(pStatus->Mode)
 800c3d2:	3804      	subs	r0, #4
 800c3d4:	8f33      	ldrh	r3, [r6, #56]	; 0x38
 800c3d6:	2805      	cmp	r0, #5
 800c3d8:	d804      	bhi.n	800c3e4 <prvLedThread+0x30>
 800c3da:	f7f9 fae1 	bl	80059a0 <__gnu_thumb1_case_uqi>
 800c3de:	1633      	.short	0x1633
 800c3e0:	3e383328 	.word	0x3e383328
          prvLed((LED_BSP_TypeDef)i, (GlobalMap >> GlobalCount) & 0x01);
 800c3e4:	6879      	ldr	r1, [r7, #4]
 * @brief  Turn on off a LED.
 * @param  cIndex: State Index
 */
void prvLed(LED_BSP_TypeDef Index, uint8_t Value)
{
  USBPD_BSP_LED_Set(Index, Value);
 800c3e6:	1e60      	subs	r0, r4, #1
          prvLed((LED_BSP_TypeDef)i, (GlobalMap >> GlobalCount) & 0x01);
 800c3e8:	40d9      	lsrs	r1, r3
  USBPD_BSP_LED_Set(Index, Value);
 800c3ea:	2301      	movs	r3, #1
 800c3ec:	b240      	sxtb	r0, r0
 800c3ee:	4019      	ands	r1, r3
 800c3f0:	f7fa fd0c 	bl	8006e0c <USBPD_BSP_LED_Set>
 800c3f4:	3401      	adds	r4, #1
    for(i=0; i<LED_INDEX_LEN; i++)
 800c3f6:	2c08      	cmp	r4, #8
 800c3f8:	d1e4      	bne.n	800c3c4 <prvLedThread+0x10>
    GlobalCount++;
 800c3fa:	8f30      	ldrh	r0, [r6, #56]	; 0x38
    GlobalCount %= GlobalPeriod;
 800c3fc:	8839      	ldrh	r1, [r7, #0]
    GlobalCount++;
 800c3fe:	3001      	adds	r0, #1
    GlobalCount %= GlobalPeriod;
 800c400:	b280      	uxth	r0, r0
 800c402:	f7f9 fb5d 	bl	8005ac0 <__aeabi_uidivmod>
 800c406:	8731      	strh	r1, [r6, #56]	; 0x38
 800c408:	e7d5      	b.n	800c3b6 <prvLedThread+0x2>
          if (GlobalCount == 0 || GlobalCount == 3) 
 800c40a:	2b00      	cmp	r3, #0
 800c40c:	d001      	beq.n	800c412 <prvLedThread+0x5e>
 800c40e:	2b03      	cmp	r3, #3
 800c410:	d104      	bne.n	800c41c <prvLedThread+0x68>
  USBPD_BSP_LED_On(Index);
 800c412:	1e60      	subs	r0, r4, #1
 800c414:	b240      	sxtb	r0, r0
 800c416:	f7fa fd09 	bl	8006e2c <USBPD_BSP_LED_On>
 800c41a:	e7eb      	b.n	800c3f4 <prvLedThread+0x40>
          else if (GlobalCount == 1 || GlobalCount == 4) 
 800c41c:	2b01      	cmp	r3, #1
 800c41e:	d001      	beq.n	800c424 <prvLedThread+0x70>
 800c420:	2b04      	cmp	r3, #4
 800c422:	d1e7      	bne.n	800c3f4 <prvLedThread+0x40>
  USBPD_BSP_LED_Off(Index);
 800c424:	1e60      	subs	r0, r4, #1
 800c426:	b240      	sxtb	r0, r0
 800c428:	f7fa fd0e 	bl	8006e48 <USBPD_BSP_LED_Off>
 800c42c:	e7e2      	b.n	800c3f4 <prvLedThread+0x40>
          if (GlobalCount == 0 || GlobalCount == 4 || GlobalCount == 8) 
 800c42e:	001a      	movs	r2, r3
 800c430:	2104      	movs	r1, #4
 800c432:	438a      	bics	r2, r1
 800c434:	d0ed      	beq.n	800c412 <prvLedThread+0x5e>
 800c436:	2b08      	cmp	r3, #8
 800c438:	d0eb      	beq.n	800c412 <prvLedThread+0x5e>
          else if (GlobalCount == 2 || GlobalCount == 6 || GlobalCount == 10) 
 800c43a:	2a02      	cmp	r2, #2
 800c43c:	d0f2      	beq.n	800c424 <prvLedThread+0x70>
 800c43e:	2b0a      	cmp	r3, #10
 800c440:	d1d8      	bne.n	800c3f4 <prvLedThread+0x40>
 800c442:	e7ef      	b.n	800c424 <prvLedThread+0x70>
          if (GlobalCount == 0) 
 800c444:	2b00      	cmp	r3, #0
 800c446:	d0e4      	beq.n	800c412 <prvLedThread+0x5e>
          else if (GlobalCount == 2) 
 800c448:	2b02      	cmp	r3, #2
 800c44a:	d1d3      	bne.n	800c3f4 <prvLedThread+0x40>
 800c44c:	e7ea      	b.n	800c424 <prvLedThread+0x70>
          else if (GlobalCount == (half_period+2)) 
 800c44e:	1caa      	adds	r2, r5, #2
          if (GlobalCount == half_period) 
 800c450:	429d      	cmp	r5, r3
 800c452:	d0de      	beq.n	800c412 <prvLedThread+0x5e>
          else if (GlobalCount == (half_period+1) || GlobalCount == (half_period+4))
 800c454:	4293      	cmp	r3, r2
 800c456:	d1cd      	bne.n	800c3f4 <prvLedThread+0x40>
 800c458:	e7e4      	b.n	800c424 <prvLedThread+0x70>
          if (GlobalCount == half_period || GlobalCount == (half_period+3)) 
 800c45a:	429d      	cmp	r5, r3
 800c45c:	d0d9      	beq.n	800c412 <prvLedThread+0x5e>
 800c45e:	1cea      	adds	r2, r5, #3
 800c460:	4293      	cmp	r3, r2
 800c462:	d0d6      	beq.n	800c412 <prvLedThread+0x5e>
          else if (GlobalCount == (half_period+1) || GlobalCount == (half_period+4))
 800c464:	1c6a      	adds	r2, r5, #1
 800c466:	4293      	cmp	r3, r2
 800c468:	d0dc      	beq.n	800c424 <prvLedThread+0x70>
 800c46a:	1d2a      	adds	r2, r5, #4
 800c46c:	e7f2      	b.n	800c454 <prvLedThread+0xa0>
 800c46e:	46c0      	nop			; (mov r8, r8)
 800c470:	20000260 	.word	0x20000260
 800c474:	200019a0 	.word	0x200019a0

0800c478 <__aeabi_memclr>:
 800c478:	b510      	push	{r4, lr}
 800c47a:	2200      	movs	r2, #0
 800c47c:	f000 f801 	bl	800c482 <__aeabi_memset>
 800c480:	bd10      	pop	{r4, pc}

0800c482 <__aeabi_memset>:
 800c482:	0013      	movs	r3, r2
 800c484:	b510      	push	{r4, lr}
 800c486:	000a      	movs	r2, r1
 800c488:	0019      	movs	r1, r3
 800c48a:	f000 f838 	bl	800c4fe <memset>
 800c48e:	bd10      	pop	{r4, pc}

0800c490 <__libc_init_array>:
 800c490:	b570      	push	{r4, r5, r6, lr}
 800c492:	2600      	movs	r6, #0
 800c494:	4d0c      	ldr	r5, [pc, #48]	; (800c4c8 <__libc_init_array+0x38>)
 800c496:	4c0d      	ldr	r4, [pc, #52]	; (800c4cc <__libc_init_array+0x3c>)
 800c498:	1b64      	subs	r4, r4, r5
 800c49a:	10a4      	asrs	r4, r4, #2
 800c49c:	42a6      	cmp	r6, r4
 800c49e:	d109      	bne.n	800c4b4 <__libc_init_array+0x24>
 800c4a0:	2600      	movs	r6, #0
 800c4a2:	f000 f8b7 	bl	800c614 <_init>
 800c4a6:	4d0a      	ldr	r5, [pc, #40]	; (800c4d0 <__libc_init_array+0x40>)
 800c4a8:	4c0a      	ldr	r4, [pc, #40]	; (800c4d4 <__libc_init_array+0x44>)
 800c4aa:	1b64      	subs	r4, r4, r5
 800c4ac:	10a4      	asrs	r4, r4, #2
 800c4ae:	42a6      	cmp	r6, r4
 800c4b0:	d105      	bne.n	800c4be <__libc_init_array+0x2e>
 800c4b2:	bd70      	pop	{r4, r5, r6, pc}
 800c4b4:	00b3      	lsls	r3, r6, #2
 800c4b6:	58eb      	ldr	r3, [r5, r3]
 800c4b8:	4798      	blx	r3
 800c4ba:	3601      	adds	r6, #1
 800c4bc:	e7ee      	b.n	800c49c <__libc_init_array+0xc>
 800c4be:	00b3      	lsls	r3, r6, #2
 800c4c0:	58eb      	ldr	r3, [r5, r3]
 800c4c2:	4798      	blx	r3
 800c4c4:	3601      	adds	r6, #1
 800c4c6:	e7f2      	b.n	800c4ae <__libc_init_array+0x1e>
 800c4c8:	0800c7f8 	.word	0x0800c7f8
 800c4cc:	0800c7f8 	.word	0x0800c7f8
 800c4d0:	0800c7f8 	.word	0x0800c7f8
 800c4d4:	0800c7fc 	.word	0x0800c7fc

0800c4d8 <malloc>:
 800c4d8:	b510      	push	{r4, lr}
 800c4da:	4b03      	ldr	r3, [pc, #12]	; (800c4e8 <malloc+0x10>)
 800c4dc:	0001      	movs	r1, r0
 800c4de:	6818      	ldr	r0, [r3, #0]
 800c4e0:	f000 f816 	bl	800c510 <_malloc_r>
 800c4e4:	bd10      	pop	{r4, pc}
 800c4e6:	46c0      	nop			; (mov r8, r8)
 800c4e8:	20000268 	.word	0x20000268

0800c4ec <memcpy>:
 800c4ec:	2300      	movs	r3, #0
 800c4ee:	b510      	push	{r4, lr}
 800c4f0:	429a      	cmp	r2, r3
 800c4f2:	d100      	bne.n	800c4f6 <memcpy+0xa>
 800c4f4:	bd10      	pop	{r4, pc}
 800c4f6:	5ccc      	ldrb	r4, [r1, r3]
 800c4f8:	54c4      	strb	r4, [r0, r3]
 800c4fa:	3301      	adds	r3, #1
 800c4fc:	e7f8      	b.n	800c4f0 <memcpy+0x4>

0800c4fe <memset>:
 800c4fe:	0003      	movs	r3, r0
 800c500:	1812      	adds	r2, r2, r0
 800c502:	4293      	cmp	r3, r2
 800c504:	d100      	bne.n	800c508 <memset+0xa>
 800c506:	4770      	bx	lr
 800c508:	7019      	strb	r1, [r3, #0]
 800c50a:	3301      	adds	r3, #1
 800c50c:	e7f9      	b.n	800c502 <memset+0x4>
	...

0800c510 <_malloc_r>:
 800c510:	2303      	movs	r3, #3
 800c512:	b570      	push	{r4, r5, r6, lr}
 800c514:	1ccd      	adds	r5, r1, #3
 800c516:	439d      	bics	r5, r3
 800c518:	3508      	adds	r5, #8
 800c51a:	0006      	movs	r6, r0
 800c51c:	2d0c      	cmp	r5, #12
 800c51e:	d21e      	bcs.n	800c55e <_malloc_r+0x4e>
 800c520:	250c      	movs	r5, #12
 800c522:	42a9      	cmp	r1, r5
 800c524:	d81d      	bhi.n	800c562 <_malloc_r+0x52>
 800c526:	0030      	movs	r0, r6
 800c528:	f000 f862 	bl	800c5f0 <__malloc_lock>
 800c52c:	4a25      	ldr	r2, [pc, #148]	; (800c5c4 <_malloc_r+0xb4>)
 800c52e:	6814      	ldr	r4, [r2, #0]
 800c530:	0021      	movs	r1, r4
 800c532:	2900      	cmp	r1, #0
 800c534:	d119      	bne.n	800c56a <_malloc_r+0x5a>
 800c536:	4c24      	ldr	r4, [pc, #144]	; (800c5c8 <_malloc_r+0xb8>)
 800c538:	6823      	ldr	r3, [r4, #0]
 800c53a:	2b00      	cmp	r3, #0
 800c53c:	d103      	bne.n	800c546 <_malloc_r+0x36>
 800c53e:	0030      	movs	r0, r6
 800c540:	f000 f844 	bl	800c5cc <_sbrk_r>
 800c544:	6020      	str	r0, [r4, #0]
 800c546:	0029      	movs	r1, r5
 800c548:	0030      	movs	r0, r6
 800c54a:	f000 f83f 	bl	800c5cc <_sbrk_r>
 800c54e:	1c43      	adds	r3, r0, #1
 800c550:	d12b      	bne.n	800c5aa <_malloc_r+0x9a>
 800c552:	230c      	movs	r3, #12
 800c554:	0030      	movs	r0, r6
 800c556:	6033      	str	r3, [r6, #0]
 800c558:	f000 f84b 	bl	800c5f2 <__malloc_unlock>
 800c55c:	e003      	b.n	800c566 <_malloc_r+0x56>
 800c55e:	2d00      	cmp	r5, #0
 800c560:	dadf      	bge.n	800c522 <_malloc_r+0x12>
 800c562:	230c      	movs	r3, #12
 800c564:	6033      	str	r3, [r6, #0]
 800c566:	2000      	movs	r0, #0
 800c568:	bd70      	pop	{r4, r5, r6, pc}
 800c56a:	680b      	ldr	r3, [r1, #0]
 800c56c:	1b5b      	subs	r3, r3, r5
 800c56e:	d419      	bmi.n	800c5a4 <_malloc_r+0x94>
 800c570:	2b0b      	cmp	r3, #11
 800c572:	d903      	bls.n	800c57c <_malloc_r+0x6c>
 800c574:	600b      	str	r3, [r1, #0]
 800c576:	18cc      	adds	r4, r1, r3
 800c578:	6025      	str	r5, [r4, #0]
 800c57a:	e003      	b.n	800c584 <_malloc_r+0x74>
 800c57c:	684b      	ldr	r3, [r1, #4]
 800c57e:	428c      	cmp	r4, r1
 800c580:	d10d      	bne.n	800c59e <_malloc_r+0x8e>
 800c582:	6013      	str	r3, [r2, #0]
 800c584:	0030      	movs	r0, r6
 800c586:	f000 f834 	bl	800c5f2 <__malloc_unlock>
 800c58a:	0020      	movs	r0, r4
 800c58c:	2207      	movs	r2, #7
 800c58e:	300b      	adds	r0, #11
 800c590:	1d23      	adds	r3, r4, #4
 800c592:	4390      	bics	r0, r2
 800c594:	1ac3      	subs	r3, r0, r3
 800c596:	d0e7      	beq.n	800c568 <_malloc_r+0x58>
 800c598:	425a      	negs	r2, r3
 800c59a:	50e2      	str	r2, [r4, r3]
 800c59c:	e7e4      	b.n	800c568 <_malloc_r+0x58>
 800c59e:	6063      	str	r3, [r4, #4]
 800c5a0:	000c      	movs	r4, r1
 800c5a2:	e7ef      	b.n	800c584 <_malloc_r+0x74>
 800c5a4:	000c      	movs	r4, r1
 800c5a6:	6849      	ldr	r1, [r1, #4]
 800c5a8:	e7c3      	b.n	800c532 <_malloc_r+0x22>
 800c5aa:	2303      	movs	r3, #3
 800c5ac:	1cc4      	adds	r4, r0, #3
 800c5ae:	439c      	bics	r4, r3
 800c5b0:	42a0      	cmp	r0, r4
 800c5b2:	d0e1      	beq.n	800c578 <_malloc_r+0x68>
 800c5b4:	1a21      	subs	r1, r4, r0
 800c5b6:	0030      	movs	r0, r6
 800c5b8:	f000 f808 	bl	800c5cc <_sbrk_r>
 800c5bc:	1c43      	adds	r3, r0, #1
 800c5be:	d1db      	bne.n	800c578 <_malloc_r+0x68>
 800c5c0:	e7c7      	b.n	800c552 <_malloc_r+0x42>
 800c5c2:	46c0      	nop			; (mov r8, r8)
 800c5c4:	20001a08 	.word	0x20001a08
 800c5c8:	20001a0c 	.word	0x20001a0c

0800c5cc <_sbrk_r>:
 800c5cc:	2300      	movs	r3, #0
 800c5ce:	b570      	push	{r4, r5, r6, lr}
 800c5d0:	4c06      	ldr	r4, [pc, #24]	; (800c5ec <_sbrk_r+0x20>)
 800c5d2:	0005      	movs	r5, r0
 800c5d4:	0008      	movs	r0, r1
 800c5d6:	6023      	str	r3, [r4, #0]
 800c5d8:	f000 f80c 	bl	800c5f4 <_sbrk>
 800c5dc:	1c43      	adds	r3, r0, #1
 800c5de:	d103      	bne.n	800c5e8 <_sbrk_r+0x1c>
 800c5e0:	6823      	ldr	r3, [r4, #0]
 800c5e2:	2b00      	cmp	r3, #0
 800c5e4:	d000      	beq.n	800c5e8 <_sbrk_r+0x1c>
 800c5e6:	602b      	str	r3, [r5, #0]
 800c5e8:	bd70      	pop	{r4, r5, r6, pc}
 800c5ea:	46c0      	nop			; (mov r8, r8)
 800c5ec:	20001d28 	.word	0x20001d28

0800c5f0 <__malloc_lock>:
 800c5f0:	4770      	bx	lr

0800c5f2 <__malloc_unlock>:
 800c5f2:	4770      	bx	lr

0800c5f4 <_sbrk>:
 800c5f4:	4b05      	ldr	r3, [pc, #20]	; (800c60c <_sbrk+0x18>)
 800c5f6:	0002      	movs	r2, r0
 800c5f8:	6819      	ldr	r1, [r3, #0]
 800c5fa:	2900      	cmp	r1, #0
 800c5fc:	d101      	bne.n	800c602 <_sbrk+0xe>
 800c5fe:	4904      	ldr	r1, [pc, #16]	; (800c610 <_sbrk+0x1c>)
 800c600:	6019      	str	r1, [r3, #0]
 800c602:	6818      	ldr	r0, [r3, #0]
 800c604:	1882      	adds	r2, r0, r2
 800c606:	601a      	str	r2, [r3, #0]
 800c608:	4770      	bx	lr
 800c60a:	46c0      	nop			; (mov r8, r8)
 800c60c:	20001a10 	.word	0x20001a10
 800c610:	20001d30 	.word	0x20001d30

0800c614 <_init>:
 800c614:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c616:	46c0      	nop			; (mov r8, r8)
 800c618:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800c61a:	bc08      	pop	{r3}
 800c61c:	469e      	mov	lr, r3
 800c61e:	4770      	bx	lr

0800c620 <_fini>:
 800c620:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c622:	46c0      	nop			; (mov r8, r8)
 800c624:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800c626:	bc08      	pop	{r3}
 800c628:	469e      	mov	lr, r3
 800c62a:	4770      	bx	lr
