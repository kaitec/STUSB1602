
STM32F072RB-Nucleo_MB1303_Provider_PD30.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000cb2c  080000c0  080000c0  000100c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000200  0800cbec  0800cbec  0001cbec  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  0800cdec  0800cdec  0001cdec  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  0800cdf0  0800cdf0  0001cdf0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         000002a8  20000000  0800cdf4  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00001b20  200002a8  0800d09c  000202a8  2**2
                  ALLOC
  7 ._user_heap_stack 00000800  20001dc8  0800d09c  00021dc8  2**0
                  ALLOC
  8 .ARM.attributes 0000002e  00000000  00000000  000202a8  2**0
                  CONTENTS, READONLY
  9 .debug_line   00022f15  00000000  00000000  000202d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00046a2d  00000000  00000000  000431eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00007f74  00000000  00000000  00089c18  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00001ea8  00000000  00000000  00091b90  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000a32d2  00000000  00000000  00093a38  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00002bd0  00000000  00000000  00136d10  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0001790b  00000000  00000000  001398e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  000212d7  00000000  00000000  001511eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      00000f98  00000000  00000000  001724c2  2**0
                  CONTENTS, READONLY
 18 .iar.rtmodel  000000c9  00000000  00000000  0017345a  2**0
                  CONTENTS, READONLY
 19 .iar_vfe_header 0000000c  00000000  00000000  00173524  2**2
                  CONTENTS, READONLY
 20 .debug_frame  0000766c  00000000  00000000  00173530  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	200002a8 	.word	0x200002a8
 80000e0:	00000000 	.word	0x00000000
 80000e4:	0800cbd4 	.word	0x0800cbd4

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	200002ac 	.word	0x200002ac
 8000104:	0800cbd4 	.word	0x0800cbd4

08000108 <USBPD_CAD_Init>:
 8000108:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800010a:	0007      	movs	r7, r0
 800010c:	000c      	movs	r4, r1
 800010e:	0015      	movs	r5, r2
 8000110:	001e      	movs	r6, r3
 8000112:	2801      	cmp	r0, #1
 8000114:	d830      	bhi.n	8000178 <USBPD_CAD_Init+0x70>
 8000116:	200c      	movs	r0, #12
 8000118:	f00c fcbe 	bl	800ca98 <malloc>
 800011c:	0002      	movs	r2, r0
 800011e:	4841      	ldr	r0, [pc, #260]	; (8000224 <.text_6>)
 8000120:	00b9      	lsls	r1, r7, #2
 8000122:	1841      	adds	r1, r0, r1
 8000124:	604a      	str	r2, [r1, #4]
 8000126:	2a00      	cmp	r2, #0
 8000128:	d101      	bne.n	800012e <USBPD_CAD_Init+0x26>
 800012a:	2003      	movs	r0, #3
 800012c:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 800012e:	9600      	str	r6, [sp, #0]
 8000130:	2300      	movs	r3, #0
 8000132:	2600      	movs	r6, #0
 8000134:	c248      	stmia	r2!, {r3, r6}
 8000136:	6013      	str	r3, [r2, #0]
 8000138:	7802      	ldrb	r2, [r0, #0]
 800013a:	1c52      	adds	r2, r2, #1
 800013c:	7002      	strb	r2, [r0, #0]
 800013e:	6848      	ldr	r0, [r1, #4]
 8000140:	9900      	ldr	r1, [sp, #0]
 8000142:	6001      	str	r1, [r0, #0]
 8000144:	7103      	strb	r3, [r0, #4]
 8000146:	6084      	str	r4, [r0, #8]
 8000148:	4837      	ldr	r0, [pc, #220]	; (8000228 <.text_7>)
 800014a:	6882      	ldr	r2, [r0, #8]
 800014c:	2301      	movs	r3, #1
 800014e:	6083      	str	r3, [r0, #8]
 8000150:	6881      	ldr	r1, [r0, #8]
 8000152:	2900      	cmp	r1, #0
 8000154:	d1fc      	bne.n	8000150 <USBPD_CAD_Init+0x48>
 8000156:	0029      	movs	r1, r5
 8000158:	4d34      	ldr	r5, [pc, #208]	; (800022c <.text_8>)
 800015a:	6005      	str	r5, [r0, #0]
 800015c:	6805      	ldr	r5, [r0, #0]
 800015e:	4e34      	ldr	r6, [pc, #208]	; (8000230 <.text_9>)
 8000160:	6035      	str	r5, [r6, #0]
 8000162:	6082      	str	r2, [r0, #8]
 8000164:	6882      	ldr	r2, [r0, #8]
 8000166:	4313      	orrs	r3, r2
 8000168:	6083      	str	r3, [r0, #8]
 800016a:	6863      	ldr	r3, [r4, #4]
 800016c:	9a00      	ldr	r2, [sp, #0]
 800016e:	0038      	movs	r0, r7
 8000170:	f009 fb36 	bl	80097e0 <CAD_Init>
 8000174:	2000      	movs	r0, #0
 8000176:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 8000178:	2001      	movs	r0, #1
 800017a:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

0800017c <USBPD_CAD_PortEnable>:
 800017c:	2802      	cmp	r0, #2
 800017e:	d204      	bcs.n	800018a <USBPD_CAD_PortEnable+0xe>
 8000180:	4a28      	ldr	r2, [pc, #160]	; (8000224 <.text_6>)
 8000182:	0080      	lsls	r0, r0, #2
 8000184:	1810      	adds	r0, r2, r0
 8000186:	6840      	ldr	r0, [r0, #4]
 8000188:	7101      	strb	r1, [r0, #4]
 800018a:	4770      	bx	lr

0800018c <USBPD_CAD_Process>:
 800018c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800018e:	b084      	sub	sp, #16
 8000190:	a802      	add	r0, sp, #8
 8000192:	bf00      	nop
 8000194:	a132      	add	r1, pc, #200	; (adr r1, 8000260 <.text_14>)
 8000196:	c90c      	ldmia	r1!, {r2, r3}
 8000198:	c00c      	stmia	r0!, {r2, r3}
 800019a:	2400      	movs	r4, #0
 800019c:	4d22      	ldr	r5, [pc, #136]	; (8000228 <.text_7>)
 800019e:	4e21      	ldr	r6, [pc, #132]	; (8000224 <.text_6>)
 80001a0:	e031      	b.n	8000206 <USBPD_CAD_Process+0x7a>
 80001a2:	68a8      	ldr	r0, [r5, #8]
 80001a4:	2101      	movs	r1, #1
 80001a6:	60a9      	str	r1, [r5, #8]
 80001a8:	68aa      	ldr	r2, [r5, #8]
 80001aa:	2a00      	cmp	r2, #0
 80001ac:	d1fc      	bne.n	80001a8 <USBPD_CAD_Process+0x1c>
 80001ae:	4a1f      	ldr	r2, [pc, #124]	; (800022c <.text_8>)
 80001b0:	602a      	str	r2, [r5, #0]
 80001b2:	4a1f      	ldr	r2, [pc, #124]	; (8000230 <.text_9>)
 80001b4:	682b      	ldr	r3, [r5, #0]
 80001b6:	6013      	str	r3, [r2, #0]
 80001b8:	60a8      	str	r0, [r5, #8]
 80001ba:	68a8      	ldr	r0, [r5, #8]
 80001bc:	4301      	orrs	r1, r0
 80001be:	60a9      	str	r1, [r5, #8]
 80001c0:	e018      	b.n	80001f4 <USBPD_CAD_Process+0x68>
 80001c2:	0620      	lsls	r0, r4, #24
 80001c4:	0d80      	lsrs	r0, r0, #22
 80001c6:	9001      	str	r0, [sp, #4]
 80001c8:	1d30      	adds	r0, r6, #4
 80001ca:	9901      	ldr	r1, [sp, #4]
 80001cc:	1847      	adds	r7, r0, r1
 80001ce:	6838      	ldr	r0, [r7, #0]
 80001d0:	7900      	ldrb	r0, [r0, #4]
 80001d2:	2801      	cmp	r0, #1
 80001d4:	d116      	bne.n	8000204 <USBPD_CAD_Process+0x78>
 80001d6:	aa00      	add	r2, sp, #0
 80001d8:	1c52      	adds	r2, r2, #1
 80001da:	4669      	mov	r1, sp
 80001dc:	b2e0      	uxtb	r0, r4
 80001de:	f00b f9c5 	bl	800b56c <CAD_StateMachine>
 80001e2:	a902      	add	r1, sp, #8
 80001e4:	9a01      	ldr	r2, [sp, #4]
 80001e6:	5088      	str	r0, [r1, r2]
 80001e8:	4668      	mov	r0, sp
 80001ea:	7800      	ldrb	r0, [r0, #0]
 80001ec:	2800      	cmp	r0, #0
 80001ee:	d009      	beq.n	8000204 <USBPD_CAD_Process+0x78>
 80001f0:	2801      	cmp	r0, #1
 80001f2:	d0d6      	beq.n	80001a2 <USBPD_CAD_Process+0x16>
 80001f4:	4668      	mov	r0, sp
 80001f6:	7842      	ldrb	r2, [r0, #1]
 80001f8:	7801      	ldrb	r1, [r0, #0]
 80001fa:	b2e0      	uxtb	r0, r4
 80001fc:	683b      	ldr	r3, [r7, #0]
 80001fe:	689b      	ldr	r3, [r3, #8]
 8000200:	681b      	ldr	r3, [r3, #0]
 8000202:	4798      	blx	r3
 8000204:	1c64      	adds	r4, r4, #1
 8000206:	7830      	ldrb	r0, [r6, #0]
 8000208:	b2e1      	uxtb	r1, r4
 800020a:	4281      	cmp	r1, r0
 800020c:	d3d9      	bcc.n	80001c2 <USBPD_CAD_Process+0x36>
 800020e:	2801      	cmp	r0, #1
 8000210:	d101      	bne.n	8000216 <USBPD_CAD_Process+0x8a>
 8000212:	9802      	ldr	r0, [sp, #8]
 8000214:	e004      	b.n	8000220 <USBPD_CAD_Process+0x94>
 8000216:	9803      	ldr	r0, [sp, #12]
 8000218:	9902      	ldr	r1, [sp, #8]
 800021a:	4288      	cmp	r0, r1
 800021c:	d300      	bcc.n	8000220 <USBPD_CAD_Process+0x94>
 800021e:	4608      	mov	r0, r1
 8000220:	b005      	add	sp, #20
 8000222:	bdf0      	pop	{r4, r5, r6, r7, pc}

08000224 <.text_6>:
 8000224:	2000199c 	.word	0x2000199c

08000228 <.text_7>:
 8000228:	40023000 	.word	0x40023000

0800022c <.text_8>:
 800022c:	f407a5c2 	.word	0xf407a5c2

08000230 <.text_9>:
 8000230:	200019b8 	.word	0x200019b8

08000234 <USBPD_CAD_AssertRd>:
 8000234:	b510      	push	{r4, lr}
 8000236:	0004      	movs	r4, r0
 8000238:	f00a fb43 	bl	800a8c2 <USBPDM1_DeAssertRp>
 800023c:	0020      	movs	r0, r4
 800023e:	f00a fb41 	bl	800a8c4 <USBPDM1_AssertRd>
 8000242:	bd10      	pop	{r4, pc}

08000244 <USBPD_CAD_AssertRp>:
 8000244:	b510      	push	{r4, lr}
 8000246:	0004      	movs	r4, r0
 8000248:	f00a fb3d 	bl	800a8c6 <USBPDM1_DeAssertRd>
 800024c:	0020      	movs	r0, r4
 800024e:	f00a fb37 	bl	800a8c0 <USBPDM1_AssertRp>
 8000252:	bd10      	pop	{r4, pc}

08000254 <USBPD_CAD_EnterErrorRecovery>:
 8000254:	b580      	push	{r7, lr}
 8000256:	f009 fae7 	bl	8009828 <CAD_Enter_ErrorRecovery>
 800025a:	bd01      	pop	{r0, pc}

0800025c <USBPD_CAD_GetMemoryConsumption>:
 800025c:	2018      	movs	r0, #24
 800025e:	4770      	bx	lr

08000260 <.text_14>:
 8000260:	00000002 	.word	0x00000002
 8000264:	00000002 	.word	0x00000002

08000268 <USBPD_PE_Init>:
 8000268:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
 800026a:	b083      	sub	sp, #12
 800026c:	0017      	movs	r7, r2
 800026e:	001d      	movs	r5, r3
 8000270:	4668      	mov	r0, sp
 8000272:	7b06      	ldrb	r6, [r0, #12]
 8000274:	2e01      	cmp	r6, #1
 8000276:	d838      	bhi.n	80002ea <USBPD_PE_Init+0x82>
 8000278:	20e6      	movs	r0, #230	; 0xe6
 800027a:	0080      	lsls	r0, r0, #2
 800027c:	f00c fc0c 	bl	800ca98 <malloc>
 8000280:	499b      	ldr	r1, [pc, #620]	; (80004f0 <.text_10>)
 8000282:	466a      	mov	r2, sp
 8000284:	7b12      	ldrb	r2, [r2, #12]
 8000286:	0092      	lsls	r2, r2, #2
 8000288:	5088      	str	r0, [r1, r2]
 800028a:	0004      	movs	r4, r0
 800028c:	d101      	bne.n	8000292 <USBPD_PE_Init+0x2a>
 800028e:	2016      	movs	r0, #22
 8000290:	e073      	b.n	800037a <USBPD_PE_Init+0x112>
 8000292:	9500      	str	r5, [sp, #0]
 8000294:	9d04      	ldr	r5, [sp, #16]
 8000296:	21e6      	movs	r1, #230	; 0xe6
 8000298:	0089      	lsls	r1, r1, #2
 800029a:	f00c fbcd 	bl	800ca38 <__aeabi_memclr>
 800029e:	6025      	str	r5, [r4, #0]
 80002a0:	6067      	str	r7, [r4, #4]
 80002a2:	2701      	movs	r7, #1
 80002a4:	68e0      	ldr	r0, [r4, #12]
 80002a6:	43b8      	bics	r0, r7
 80002a8:	403e      	ands	r6, r7
 80002aa:	4306      	orrs	r6, r0
 80002ac:	60e6      	str	r6, [r4, #12]
 80002ae:	9800      	ldr	r0, [sp, #0]
 80002b0:	60a0      	str	r0, [r4, #8]
 80002b2:	2600      	movs	r6, #0
 80002b4:	498f      	ldr	r1, [pc, #572]	; (80004f4 <.text_11>)
 80002b6:	1861      	adds	r1, r4, r1
 80002b8:	704e      	strb	r6, [r1, #1]
 80002ba:	6820      	ldr	r0, [r4, #0]
 80002bc:	6801      	ldr	r1, [r0, #0]
 80002be:	9102      	str	r1, [sp, #8]
 80002c0:	498d      	ldr	r1, [pc, #564]	; (80004f8 <.text_12>)
 80002c2:	1861      	adds	r1, r4, r1
 80002c4:	9101      	str	r1, [sp, #4]
 80002c6:	0021      	movs	r1, r4
 80002c8:	3136      	adds	r1, #54	; 0x36
 80002ca:	9100      	str	r1, [sp, #0]
 80002cc:	7900      	ldrb	r0, [r0, #4]
 80002ce:	0880      	lsrs	r0, r0, #2
 80002d0:	2301      	movs	r3, #1
 80002d2:	4003      	ands	r3, r0
 80002d4:	209d      	movs	r0, #157	; 0x9d
 80002d6:	0040      	lsls	r0, r0, #1
 80002d8:	1822      	adds	r2, r4, r0
 80002da:	bf00      	nop
 80002dc:	a128      	add	r1, pc, #160	; (adr r1, 8000380 <PE_PrlCallbacks>)
 80002de:	4668      	mov	r0, sp
 80002e0:	7b00      	ldrb	r0, [r0, #12]
 80002e2:	f004 fdad 	bl	8004e40 <USBPD_PRL_Init>
 80002e6:	2800      	cmp	r0, #0
 80002e8:	d001      	beq.n	80002ee <USBPD_PE_Init+0x86>
 80002ea:	2002      	movs	r0, #2
 80002ec:	e045      	b.n	800037a <USBPD_PE_Init+0x112>
 80002ee:	68e0      	ldr	r0, [r4, #12]
 80002f0:	4982      	ldr	r1, [pc, #520]	; (80004fc <.text_13>)
 80002f2:	4001      	ands	r1, r0
 80002f4:	60e1      	str	r1, [r4, #12]
 80002f6:	6860      	ldr	r0, [r4, #4]
 80002f8:	9000      	str	r0, [sp, #0]
 80002fa:	7800      	ldrb	r0, [r0, #0]
 80002fc:	2303      	movs	r3, #3
 80002fe:	6821      	ldr	r1, [r4, #0]
 8000300:	7909      	ldrb	r1, [r1, #4]
 8000302:	088a      	lsrs	r2, r1, #2
 8000304:	423a      	tst	r2, r7
 8000306:	d00c      	beq.n	8000322 <USBPD_PE_Init+0xba>
 8000308:	2108      	movs	r1, #8
 800030a:	4301      	orrs	r1, r0
 800030c:	9800      	ldr	r0, [sp, #0]
 800030e:	7001      	strb	r1, [r0, #0]
 8000310:	7928      	ldrb	r0, [r5, #4]
 8000312:	4003      	ands	r3, r0
 8000314:	2201      	movs	r2, #1
 8000316:	2101      	movs	r1, #1
 8000318:	4668      	mov	r0, sp
 800031a:	7b00      	ldrb	r0, [r0, #12]
 800031c:	f004 fde4 	bl	8004ee8 <USBPD_PRL_SetHeader>
 8000320:	e017      	b.n	8000352 <USBPD_PE_Init+0xea>
 8000322:	21f7      	movs	r1, #247	; 0xf7
 8000324:	4001      	ands	r1, r0
 8000326:	9800      	ldr	r0, [sp, #0]
 8000328:	7001      	strb	r1, [r0, #0]
 800032a:	4872      	ldr	r0, [pc, #456]	; (80004f4 <.text_11>)
 800032c:	5426      	strb	r6, [r4, r0]
 800032e:	7928      	ldrb	r0, [r5, #4]
 8000330:	4003      	ands	r3, r0
 8000332:	2200      	movs	r2, #0
 8000334:	2100      	movs	r1, #0
 8000336:	4668      	mov	r0, sp
 8000338:	7b00      	ldrb	r0, [r0, #12]
 800033a:	f004 fdd5 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800033e:	0638      	lsls	r0, r7, #24
 8000340:	9001      	str	r0, [sp, #4]
 8000342:	2304      	movs	r3, #4
 8000344:	aa01      	add	r2, sp, #4
 8000346:	2106      	movs	r1, #6
 8000348:	4668      	mov	r0, sp
 800034a:	7b00      	ldrb	r0, [r0, #12]
 800034c:	68a5      	ldr	r5, [r4, #8]
 800034e:	69ed      	ldr	r5, [r5, #28]
 8000350:	47a8      	blx	r5
 8000352:	6820      	ldr	r0, [r4, #0]
 8000354:	7900      	ldrb	r0, [r0, #4]
 8000356:	0880      	lsrs	r0, r0, #2
 8000358:	4007      	ands	r7, r0
 800035a:	0039      	movs	r1, r7
 800035c:	4668      	mov	r0, sp
 800035e:	7b00      	ldrb	r0, [r0, #12]
 8000360:	f004 fddf 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8000364:	6860      	ldr	r0, [r4, #4]
 8000366:	7841      	ldrb	r1, [r0, #1]
 8000368:	228f      	movs	r2, #143	; 0x8f
 800036a:	400a      	ands	r2, r1
 800036c:	7042      	strb	r2, [r0, #1]
 800036e:	6860      	ldr	r0, [r4, #4]
 8000370:	6801      	ldr	r1, [r0, #0]
 8000372:	2210      	movs	r2, #16
 8000374:	4391      	bics	r1, r2
 8000376:	6001      	str	r1, [r0, #0]
 8000378:	2000      	movs	r0, #0
 800037a:	b005      	add	sp, #20
 800037c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08000380 <PE_PrlCallbacks>:
 8000380:	4463 0800 4481 0800 4139 0800 418d 0800     cD...D..9A...A..

08000390 <USBPD_PE_SetTrace>:
 8000390:	4a5b      	ldr	r2, [pc, #364]	; (8000500 <.text_14>)
 8000392:	60d0      	str	r0, [r2, #12]
 8000394:	7011      	strb	r1, [r2, #0]
 8000396:	4770      	bx	lr

08000398 <USBPD_PE_CheckLIB>:
 8000398:	495a      	ldr	r1, [pc, #360]	; (8000504 <.text_15>)
 800039a:	4288      	cmp	r0, r1
 800039c:	d101      	bne.n	80003a2 <USBPD_PE_CheckLIB+0xa>
 800039e:	2001      	movs	r0, #1
 80003a0:	4770      	bx	lr
 80003a2:	2000      	movs	r0, #0
 80003a4:	4770      	bx	lr

080003a6 <USBPD_PE_GetMemoryConsumption>:
 80003a6:	b510      	push	{r4, lr}
 80003a8:	f004 fd9c 	bl	8004ee4 <USBPD_PRL_GetMemoryConsumption>
 80003ac:	0004      	movs	r4, r0
 80003ae:	f7ff ff55 	bl	800025c <USBPD_CAD_GetMemoryConsumption>
 80003b2:	1820      	adds	r0, r4, r0
 80003b4:	21e6      	movs	r1, #230	; 0xe6
 80003b6:	00c9      	lsls	r1, r1, #3
 80003b8:	1840      	adds	r0, r0, r1
 80003ba:	bd10      	pop	{r4, pc}

080003bc <USBPD_PE_TimerCounter>:
 80003bc:	b081      	sub	sp, #4
 80003be:	4950      	ldr	r1, [pc, #320]	; (8000500 <.text_14>)
 80003c0:	0080      	lsls	r0, r0, #2
 80003c2:	1808      	adds	r0, r1, r0
 80003c4:	6840      	ldr	r0, [r0, #4]
 80003c6:	21d9      	movs	r1, #217	; 0xd9
 80003c8:	0089      	lsls	r1, r1, #2
 80003ca:	1840      	adds	r0, r0, r1
 80003cc:	494e      	ldr	r1, [pc, #312]	; (8000508 <.text_16>)
 80003ce:	084a      	lsrs	r2, r1, #1
 80003d0:	8b43      	ldrh	r3, [r0, #26]
 80003d2:	4013      	ands	r3, r2
 80003d4:	2b01      	cmp	r3, #1
 80003d6:	db02      	blt.n	80003de <USBPD_PE_TimerCounter+0x22>
 80003d8:	8b43      	ldrh	r3, [r0, #26]
 80003da:	185b      	adds	r3, r3, r1
 80003dc:	8343      	strh	r3, [r0, #26]
 80003de:	8803      	ldrh	r3, [r0, #0]
 80003e0:	4013      	ands	r3, r2
 80003e2:	2b01      	cmp	r3, #1
 80003e4:	db02      	blt.n	80003ec <USBPD_PE_TimerCounter+0x30>
 80003e6:	8803      	ldrh	r3, [r0, #0]
 80003e8:	185b      	adds	r3, r3, r1
 80003ea:	8003      	strh	r3, [r0, #0]
 80003ec:	8843      	ldrh	r3, [r0, #2]
 80003ee:	4013      	ands	r3, r2
 80003f0:	2b01      	cmp	r3, #1
 80003f2:	db02      	blt.n	80003fa <USBPD_PE_TimerCounter+0x3e>
 80003f4:	8843      	ldrh	r3, [r0, #2]
 80003f6:	185b      	adds	r3, r3, r1
 80003f8:	8043      	strh	r3, [r0, #2]
 80003fa:	8883      	ldrh	r3, [r0, #4]
 80003fc:	4013      	ands	r3, r2
 80003fe:	2b01      	cmp	r3, #1
 8000400:	db02      	blt.n	8000408 <USBPD_PE_TimerCounter+0x4c>
 8000402:	8883      	ldrh	r3, [r0, #4]
 8000404:	185b      	adds	r3, r3, r1
 8000406:	8083      	strh	r3, [r0, #4]
 8000408:	88c3      	ldrh	r3, [r0, #6]
 800040a:	4013      	ands	r3, r2
 800040c:	2b01      	cmp	r3, #1
 800040e:	db02      	blt.n	8000416 <USBPD_PE_TimerCounter+0x5a>
 8000410:	88c3      	ldrh	r3, [r0, #6]
 8000412:	185b      	adds	r3, r3, r1
 8000414:	80c3      	strh	r3, [r0, #6]
 8000416:	8903      	ldrh	r3, [r0, #8]
 8000418:	4013      	ands	r3, r2
 800041a:	2b01      	cmp	r3, #1
 800041c:	db02      	blt.n	8000424 <USBPD_PE_TimerCounter+0x68>
 800041e:	8903      	ldrh	r3, [r0, #8]
 8000420:	185b      	adds	r3, r3, r1
 8000422:	8103      	strh	r3, [r0, #8]
 8000424:	8943      	ldrh	r3, [r0, #10]
 8000426:	4013      	ands	r3, r2
 8000428:	2b01      	cmp	r3, #1
 800042a:	db02      	blt.n	8000432 <USBPD_PE_TimerCounter+0x76>
 800042c:	8943      	ldrh	r3, [r0, #10]
 800042e:	185b      	adds	r3, r3, r1
 8000430:	8143      	strh	r3, [r0, #10]
 8000432:	8983      	ldrh	r3, [r0, #12]
 8000434:	4013      	ands	r3, r2
 8000436:	2b01      	cmp	r3, #1
 8000438:	db02      	blt.n	8000440 <USBPD_PE_TimerCounter+0x84>
 800043a:	8983      	ldrh	r3, [r0, #12]
 800043c:	185b      	adds	r3, r3, r1
 800043e:	8183      	strh	r3, [r0, #12]
 8000440:	89c3      	ldrh	r3, [r0, #14]
 8000442:	4013      	ands	r3, r2
 8000444:	2b01      	cmp	r3, #1
 8000446:	db02      	blt.n	800044e <USBPD_PE_TimerCounter+0x92>
 8000448:	89c3      	ldrh	r3, [r0, #14]
 800044a:	185b      	adds	r3, r3, r1
 800044c:	81c3      	strh	r3, [r0, #14]
 800044e:	8a43      	ldrh	r3, [r0, #18]
 8000450:	4013      	ands	r3, r2
 8000452:	2b01      	cmp	r3, #1
 8000454:	db02      	blt.n	800045c <USBPD_PE_TimerCounter+0xa0>
 8000456:	8a43      	ldrh	r3, [r0, #18]
 8000458:	185b      	adds	r3, r3, r1
 800045a:	8243      	strh	r3, [r0, #18]
 800045c:	8a83      	ldrh	r3, [r0, #20]
 800045e:	4013      	ands	r3, r2
 8000460:	2b01      	cmp	r3, #1
 8000462:	db02      	blt.n	800046a <USBPD_PE_TimerCounter+0xae>
 8000464:	8a83      	ldrh	r3, [r0, #20]
 8000466:	185b      	adds	r3, r3, r1
 8000468:	8283      	strh	r3, [r0, #20]
 800046a:	8ac3      	ldrh	r3, [r0, #22]
 800046c:	4013      	ands	r3, r2
 800046e:	2b01      	cmp	r3, #1
 8000470:	db02      	blt.n	8000478 <USBPD_PE_TimerCounter+0xbc>
 8000472:	8ac3      	ldrh	r3, [r0, #22]
 8000474:	185b      	adds	r3, r3, r1
 8000476:	82c3      	strh	r3, [r0, #22]
 8000478:	8a03      	ldrh	r3, [r0, #16]
 800047a:	4013      	ands	r3, r2
 800047c:	2b01      	cmp	r3, #1
 800047e:	db02      	blt.n	8000486 <USBPD_PE_TimerCounter+0xca>
 8000480:	8a03      	ldrh	r3, [r0, #16]
 8000482:	185b      	adds	r3, r3, r1
 8000484:	8203      	strh	r3, [r0, #16]
 8000486:	8b03      	ldrh	r3, [r0, #24]
 8000488:	4013      	ands	r3, r2
 800048a:	2b01      	cmp	r3, #1
 800048c:	db02      	blt.n	8000494 <USBPD_PE_TimerCounter+0xd8>
 800048e:	8b03      	ldrh	r3, [r0, #24]
 8000490:	185b      	adds	r3, r3, r1
 8000492:	8303      	strh	r3, [r0, #24]
 8000494:	8b83      	ldrh	r3, [r0, #28]
 8000496:	4013      	ands	r3, r2
 8000498:	2b01      	cmp	r3, #1
 800049a:	db02      	blt.n	80004a2 <USBPD_PE_TimerCounter+0xe6>
 800049c:	8b83      	ldrh	r3, [r0, #28]
 800049e:	185b      	adds	r3, r3, r1
 80004a0:	8383      	strh	r3, [r0, #28]
 80004a2:	8bc3      	ldrh	r3, [r0, #30]
 80004a4:	401a      	ands	r2, r3
 80004a6:	2a01      	cmp	r2, #1
 80004a8:	db02      	blt.n	80004b0 <USBPD_PE_TimerCounter+0xf4>
 80004aa:	8bc2      	ldrh	r2, [r0, #30]
 80004ac:	1851      	adds	r1, r2, r1
 80004ae:	83c1      	strh	r1, [r0, #30]
 80004b0:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80004b2:	1c49      	adds	r1, r1, #1
 80004b4:	6241      	str	r1, [r0, #36]	; 0x24
 80004b6:	b001      	add	sp, #4
 80004b8:	4770      	bx	lr

080004ba <USBPD_PE_IsCableConnected>:
 80004ba:	b538      	push	{r3, r4, r5, lr}
 80004bc:	000c      	movs	r4, r1
 80004be:	490c      	ldr	r1, [pc, #48]	; (80004f0 <.text_10>)
 80004c0:	0082      	lsls	r2, r0, #2
 80004c2:	588d      	ldr	r5, [r1, r2]
 80004c4:	2100      	movs	r1, #0
 80004c6:	f003 fe62 	bl	800418e <PE_Reset>
 80004ca:	6868      	ldr	r0, [r5, #4]
 80004cc:	6801      	ldr	r1, [r0, #0]
 80004ce:	2c01      	cmp	r4, #1
 80004d0:	d104      	bne.n	80004dc <USBPD_PE_IsCableConnected+0x22>
 80004d2:	2280      	movs	r2, #128	; 0x80
 80004d4:	0112      	lsls	r2, r2, #4
 80004d6:	430a      	orrs	r2, r1
 80004d8:	6002      	str	r2, [r0, #0]
 80004da:	e006      	b.n	80004ea <USBPD_PE_IsCableConnected+0x30>
 80004dc:	4a07      	ldr	r2, [pc, #28]	; (80004fc <.text_13>)
 80004de:	400a      	ands	r2, r1
 80004e0:	6002      	str	r2, [r0, #0]
 80004e2:	2000      	movs	r0, #0
 80004e4:	21d6      	movs	r1, #214	; 0xd6
 80004e6:	0089      	lsls	r1, r1, #2
 80004e8:	5468      	strb	r0, [r5, r1]
 80004ea:	2000      	movs	r0, #0
 80004ec:	bd32      	pop	{r1, r4, r5, pc}
	...

080004f0 <.text_10>:
 80004f0:	200019ac 	.word	0x200019ac

080004f4 <.text_11>:
 80004f4:	00000357 	.word	0x00000357

080004f8 <.text_12>:
 80004f8:	0000034a 	.word	0x0000034a

080004fc <.text_13>:
 80004fc:	fffff7ff 	.word	0xfffff7ff

08000500 <.text_14>:
 8000500:	200019a8 	.word	0x200019a8

08000504 <.text_15>:
 8000504:	30210001 	.word	0x30210001

08000508 <.text_16>:
 8000508:	0000ffff 	.word	0x0000ffff

0800050c <USBPD_PE_StateMachine_SRC>:
 800050c:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 800050e:	b08a      	sub	sp, #40	; 0x28
 8000510:	48b5      	ldr	r0, [pc, #724]	; (80007e8 <__iar_annotation$$branch+0xc>)
 8000512:	a90a      	add	r1, sp, #40	; 0x28
 8000514:	7809      	ldrb	r1, [r1, #0]
 8000516:	0089      	lsls	r1, r1, #2
 8000518:	1840      	adds	r0, r0, r1
 800051a:	6844      	ldr	r4, [r0, #4]
 800051c:	2000      	movs	r0, #0
 800051e:	9008      	str	r0, [sp, #32]
 8000520:	20d9      	movs	r0, #217	; 0xd9
 8000522:	0080      	lsls	r0, r0, #2
 8000524:	1820      	adds	r0, r4, r0
 8000526:	9004      	str	r0, [sp, #16]
 8000528:	6a46      	ldr	r6, [r0, #36]	; 0x24
 800052a:	8807      	ldrh	r7, [r0, #0]
 800052c:	4668      	mov	r0, sp
 800052e:	9904      	ldr	r1, [sp, #16]
 8000530:	8849      	ldrh	r1, [r1, #2]
 8000532:	8281      	strh	r1, [r0, #20]
 8000534:	9904      	ldr	r1, [sp, #16]
 8000536:	8889      	ldrh	r1, [r1, #4]
 8000538:	81c1      	strh	r1, [r0, #14]
 800053a:	9904      	ldr	r1, [sp, #16]
 800053c:	88c9      	ldrh	r1, [r1, #6]
 800053e:	8141      	strh	r1, [r0, #10]
 8000540:	9904      	ldr	r1, [sp, #16]
 8000542:	8909      	ldrh	r1, [r1, #8]
 8000544:	8101      	strh	r1, [r0, #8]
 8000546:	9904      	ldr	r1, [sp, #16]
 8000548:	8949      	ldrh	r1, [r1, #10]
 800054a:	80c1      	strh	r1, [r0, #6]
 800054c:	9904      	ldr	r1, [sp, #16]
 800054e:	8989      	ldrh	r1, [r1, #12]
 8000550:	8081      	strh	r1, [r0, #4]
 8000552:	9904      	ldr	r1, [sp, #16]
 8000554:	89c9      	ldrh	r1, [r1, #14]
 8000556:	8041      	strh	r1, [r0, #2]
 8000558:	9904      	ldr	r1, [sp, #16]
 800055a:	89c9      	ldrh	r1, [r1, #14]
 800055c:	8001      	strh	r1, [r0, #0]
 800055e:	9804      	ldr	r0, [sp, #16]
 8000560:	8a00      	ldrh	r0, [r0, #16]
 8000562:	9904      	ldr	r1, [sp, #16]
 8000564:	8a49      	ldrh	r1, [r1, #18]
 8000566:	9a04      	ldr	r2, [sp, #16]
 8000568:	8a92      	ldrh	r2, [r2, #20]
 800056a:	9b04      	ldr	r3, [sp, #16]
 800056c:	8adb      	ldrh	r3, [r3, #22]
 800056e:	9d04      	ldr	r5, [sp, #16]
 8000570:	8c2d      	ldrh	r5, [r5, #32]
 8000572:	0536      	lsls	r6, r6, #20
 8000574:	0d36      	lsrs	r6, r6, #20
 8000576:	19f6      	adds	r6, r6, r7
 8000578:	466f      	mov	r7, sp
 800057a:	8abf      	ldrh	r7, [r7, #20]
 800057c:	19f6      	adds	r6, r6, r7
 800057e:	466f      	mov	r7, sp
 8000580:	89ff      	ldrh	r7, [r7, #14]
 8000582:	19f6      	adds	r6, r6, r7
 8000584:	466f      	mov	r7, sp
 8000586:	897f      	ldrh	r7, [r7, #10]
 8000588:	19f6      	adds	r6, r6, r7
 800058a:	466f      	mov	r7, sp
 800058c:	893f      	ldrh	r7, [r7, #8]
 800058e:	19f6      	adds	r6, r6, r7
 8000590:	466f      	mov	r7, sp
 8000592:	88ff      	ldrh	r7, [r7, #6]
 8000594:	19f6      	adds	r6, r6, r7
 8000596:	466f      	mov	r7, sp
 8000598:	88bf      	ldrh	r7, [r7, #4]
 800059a:	19f6      	adds	r6, r6, r7
 800059c:	466f      	mov	r7, sp
 800059e:	887f      	ldrh	r7, [r7, #2]
 80005a0:	19f6      	adds	r6, r6, r7
 80005a2:	466f      	mov	r7, sp
 80005a4:	883f      	ldrh	r7, [r7, #0]
 80005a6:	19f6      	adds	r6, r6, r7
 80005a8:	1830      	adds	r0, r6, r0
 80005aa:	1840      	adds	r0, r0, r1
 80005ac:	1880      	adds	r0, r0, r2
 80005ae:	18c0      	adds	r0, r0, r3
 80005b0:	0529      	lsls	r1, r5, #20
 80005b2:	0f49      	lsrs	r1, r1, #29
 80005b4:	1840      	adds	r0, r0, r1
 80005b6:	9904      	ldr	r1, [sp, #16]
 80005b8:	8c09      	ldrh	r1, [r1, #32]
 80005ba:	06c9      	lsls	r1, r1, #27
 80005bc:	0ec9      	lsrs	r1, r1, #27
 80005be:	1840      	adds	r0, r0, r1
 80005c0:	b280      	uxth	r0, r0
 80005c2:	9007      	str	r0, [sp, #28]
 80005c4:	0020      	movs	r0, r4
 80005c6:	f003 f9f9 	bl	80039bc <PE_Check_RxEvent>
 80005ca:	4669      	mov	r1, sp
 80005cc:	7308      	strb	r0, [r1, #12]
 80005ce:	2803      	cmp	r0, #3
 80005d0:	d101      	bne.n	80005d6 <USBPD_PE_StateMachine_SRC+0xca>
 80005d2:	2001      	movs	r0, #1
 80005d4:	e254      	b.n	8000a80 <__iar_annotation$$branch+0x88>
 80005d6:	2502      	movs	r5, #2
 80005d8:	20d4      	movs	r0, #212	; 0xd4
 80005da:	0080      	lsls	r0, r0, #2
 80005dc:	1826      	adds	r6, r4, r0
 80005de:	7930      	ldrb	r0, [r6, #4]
 80005e0:	280f      	cmp	r0, #15
 80005e2:	d117      	bne.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 80005e4:	7230      	strb	r0, [r6, #8]
 80005e6:	2000      	movs	r0, #0
 80005e8:	7130      	strb	r0, [r6, #4]
 80005ea:	487f      	ldr	r0, [pc, #508]	; (80007e8 <__iar_annotation$$branch+0xc>)
 80005ec:	68c7      	ldr	r7, [r0, #12]
 80005ee:	2f00      	cmp	r7, #0
 80005f0:	d010      	beq.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 80005f2:	7800      	ldrb	r0, [r0, #0]
 80005f4:	07c0      	lsls	r0, r0, #31
 80005f6:	d50d      	bpl.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 80005f8:	7a30      	ldrb	r0, [r6, #8]
 80005fa:	7a71      	ldrb	r1, [r6, #9]
 80005fc:	4281      	cmp	r1, r0
 80005fe:	d009      	beq.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 8000600:	7270      	strb	r0, [r6, #9]
 8000602:	2000      	movs	r0, #0
 8000604:	9000      	str	r0, [sp, #0]
 8000606:	2300      	movs	r3, #0
 8000608:	7a32      	ldrb	r2, [r6, #8]
 800060a:	7b20      	ldrb	r0, [r4, #12]
 800060c:	07c1      	lsls	r1, r0, #31
 800060e:	0fc9      	lsrs	r1, r1, #31
 8000610:	2004      	movs	r0, #4
 8000612:	47b8      	blx	r7
 8000614:	9807      	ldr	r0, [sp, #28]
 8000616:	2800      	cmp	r0, #0
 8000618:	d006      	beq.n	8000628 <USBPD_PE_StateMachine_SRC+0x11c>
 800061a:	2107      	movs	r1, #7
 800061c:	f005 fb44 	bl	8005ca8 <__aeabi_idivmod>
 8000620:	2900      	cmp	r1, #0
 8000622:	d101      	bne.n	8000628 <USBPD_PE_StateMachine_SRC+0x11c>
 8000624:	2001      	movs	r0, #1
 8000626:	9008      	str	r0, [sp, #32]
 8000628:	496f      	ldr	r1, [pc, #444]	; (80007e8 <__iar_annotation$$branch+0xc>)
 800062a:	7808      	ldrb	r0, [r1, #0]
 800062c:	4028      	ands	r0, r5
 800062e:	68c9      	ldr	r1, [r1, #12]
 8000630:	9101      	str	r1, [sp, #4]
 8000632:	4669      	mov	r1, sp
 8000634:	7b09      	ldrb	r1, [r1, #12]
 8000636:	7a32      	ldrb	r2, [r6, #8]
 8000638:	2a00      	cmp	r2, #0
 800063a:	d100      	bne.n	800063e <USBPD_PE_StateMachine_SRC+0x132>
 800063c:	e0eb      	b.n	8000816 <__iar_annotation$$branch+0x3a>
 800063e:	1e52      	subs	r2, r2, #1
 8000640:	d100      	bne.n	8000644 <USBPD_PE_StateMachine_SRC+0x138>
 8000642:	e0a8      	b.n	8000796 <__iar_annotation$$branch+0xe>
 8000644:	1e52      	subs	r2, r2, #1
 8000646:	d100      	bne.n	800064a <USBPD_PE_StateMachine_SRC+0x13e>
 8000648:	e0ed      	b.n	8000826 <__iar_annotation$$branch+0x4a>
 800064a:	1e52      	subs	r2, r2, #1
 800064c:	d101      	bne.n	8000652 <__iar_annotation$$branch+0x4>

0800064e <__iar_annotation$$branch>:
 800064e:	f001 f8e6 	bl	800181e <__iar_annotation$$branch+0x250>
 8000652:	1e52      	subs	r2, r2, #1
 8000654:	d101      	bne.n	800065a <__iar_annotation$$branch+0x4>

08000656 <__iar_annotation$$branch>:
 8000656:	f001 f8fc 	bl	8001852 <__iar_annotation$$branch+0x284>
 800065a:	1e52      	subs	r2, r2, #1
 800065c:	d100      	bne.n	8000660 <__iar_annotation$$branch+0xa>
 800065e:	e133      	b.n	80008c8 <__iar_annotation$$branch+0xec>
 8000660:	1e52      	subs	r2, r2, #1
 8000662:	d100      	bne.n	8000666 <__iar_annotation$$branch+0x10>
 8000664:	e214      	b.n	8000a90 <__iar_annotation$$branch+0x98>
 8000666:	1e52      	subs	r2, r2, #1
 8000668:	d100      	bne.n	800066c <__iar_annotation$$branch+0x16>
 800066a:	e219      	b.n	8000aa0 <__iar_annotation$$branch+0xa8>
 800066c:	1e52      	subs	r2, r2, #1
 800066e:	d100      	bne.n	8000672 <__iar_annotation$$branch+0x1c>
 8000670:	e282      	b.n	8000b78 <__iar_annotation$$branch+0x180>
 8000672:	1e52      	subs	r2, r2, #1
 8000674:	d100      	bne.n	8000678 <__iar_annotation$$branch+0x22>
 8000676:	e2ca      	b.n	8000c0e <__iar_annotation$$branch+0x216>
 8000678:	1e52      	subs	r2, r2, #1
 800067a:	2a01      	cmp	r2, #1
 800067c:	d800      	bhi.n	8000680 <__iar_annotation$$branch+0x2a>
 800067e:	e3c3      	b.n	8000e08 <__iar_annotation$$branch+0x410>
 8000680:	1e92      	subs	r2, r2, #2
 8000682:	d100      	bne.n	8000686 <__iar_annotation$$branch+0x30>
 8000684:	e357      	b.n	8000d36 <__iar_annotation$$branch+0x33e>
 8000686:	1e52      	subs	r2, r2, #1
 8000688:	d100      	bne.n	800068c <__iar_annotation$$branch+0x36>
 800068a:	e383      	b.n	8000d94 <__iar_annotation$$branch+0x39c>
 800068c:	1e52      	subs	r2, r2, #1
 800068e:	d100      	bne.n	8000692 <__iar_annotation$$branch+0x3c>
 8000690:	e3b7      	b.n	8000e02 <__iar_annotation$$branch+0x40a>
 8000692:	1e52      	subs	r2, r2, #1
 8000694:	d101      	bne.n	800069a <__iar_annotation$$branch+0x4>

08000696 <__iar_annotation$$branch>:
 8000696:	f000 fc91 	bl	8000fbc <__iar_annotation$$branch+0x5c4>
 800069a:	1e52      	subs	r2, r2, #1
 800069c:	d101      	bne.n	80006a2 <__iar_annotation$$branch+0x4>

0800069e <__iar_annotation$$branch>:
 800069e:	f000 fc21 	bl	8000ee4 <__iar_annotation$$branch+0x4ec>
 80006a2:	1e52      	subs	r2, r2, #1
 80006a4:	d101      	bne.n	80006aa <__iar_annotation$$branch+0x4>

080006a6 <__iar_annotation$$branch>:
 80006a6:	f000 fc3d 	bl	8000f24 <__iar_annotation$$branch+0x52c>
 80006aa:	1e52      	subs	r2, r2, #1
 80006ac:	d101      	bne.n	80006b2 <__iar_annotation$$branch+0x4>

080006ae <__iar_annotation$$branch>:
 80006ae:	f000 fc56 	bl	8000f5e <__iar_annotation$$branch+0x566>
 80006b2:	1e52      	subs	r2, r2, #1
 80006b4:	d101      	bne.n	80006ba <__iar_annotation$$branch+0x4>

080006b6 <__iar_annotation$$branch>:
 80006b6:	f000 fce5 	bl	8001084 <__iar_annotation$$branch+0x68c>
 80006ba:	1e52      	subs	r2, r2, #1
 80006bc:	d101      	bne.n	80006c2 <__iar_annotation$$branch+0x4>

080006be <__iar_annotation$$branch>:
 80006be:	f000 fc9d 	bl	8000ffc <__iar_annotation$$branch+0x604>
 80006c2:	1e52      	subs	r2, r2, #1
 80006c4:	d101      	bne.n	80006ca <__iar_annotation$$branch+0x4>

080006c6 <__iar_annotation$$branch>:
 80006c6:	f000 fcac 	bl	8001022 <__iar_annotation$$branch+0x62a>
 80006ca:	1e52      	subs	r2, r2, #1
 80006cc:	d100      	bne.n	80006d0 <__iar_annotation$$branch+0xa>
 80006ce:	e263      	b.n	8000b98 <__iar_annotation$$branch+0x1a0>
 80006d0:	1e92      	subs	r2, r2, #2
 80006d2:	d101      	bne.n	80006d8 <__iar_annotation$$branch+0x4>

080006d4 <__iar_annotation$$branch>:
 80006d4:	f000 fd2a 	bl	800112c <__iar_annotation$$branch+0x734>
 80006d8:	1e52      	subs	r2, r2, #1
 80006da:	d101      	bne.n	80006e0 <__iar_annotation$$branch+0x4>

080006dc <__iar_annotation$$branch>:
 80006dc:	f000 fd56 	bl	800118c <__iar_annotation$$branch+0x794>
 80006e0:	1e52      	subs	r2, r2, #1
 80006e2:	d101      	bne.n	80006e8 <__iar_annotation$$branch+0x4>

080006e4 <__iar_annotation$$branch>:
 80006e4:	f000 fdcd 	bl	8001282 <__iar_annotation$$branch+0x88a>
 80006e8:	1e52      	subs	r2, r2, #1
 80006ea:	d101      	bne.n	80006f0 <__iar_annotation$$branch+0x4>

080006ec <__iar_annotation$$branch>:
 80006ec:	f000 fde9 	bl	80012c2 <__iar_annotation$$branch+0x8ca>
 80006f0:	1e92      	subs	r2, r2, #2
 80006f2:	d101      	bne.n	80006f8 <__iar_annotation$$branch+0x4>

080006f4 <__iar_annotation$$branch>:
 80006f4:	f001 f869 	bl	80017ca <__iar_annotation$$branch+0x1fc>
 80006f8:	1e52      	subs	r2, r2, #1
 80006fa:	d101      	bne.n	8000700 <__iar_annotation$$branch+0x4>

080006fc <__iar_annotation$$branch>:
 80006fc:	f000 ff69 	bl	80015d2 <__iar_annotation$$branch+0x4>
 8000700:	1e52      	subs	r2, r2, #1
 8000702:	d101      	bne.n	8000708 <__iar_annotation$$branch+0x4>

08000704 <__iar_annotation$$branch>:
 8000704:	f000 ff8e 	bl	8001624 <__iar_annotation$$branch+0x56>
 8000708:	1e52      	subs	r2, r2, #1
 800070a:	d101      	bne.n	8000710 <__iar_annotation$$branch+0x4>

0800070c <__iar_annotation$$branch>:
 800070c:	f001 f814 	bl	8001738 <__iar_annotation$$branch+0x16a>
 8000710:	1e52      	subs	r2, r2, #1
 8000712:	d101      	bne.n	8000718 <__iar_annotation$$branch+0x4>

08000714 <__iar_annotation$$branch>:
 8000714:	f001 f849 	bl	80017aa <__iar_annotation$$branch+0x1dc>
 8000718:	1e52      	subs	r2, r2, #1
 800071a:	d101      	bne.n	8000720 <__iar_annotation$$branch+0x4>

0800071c <__iar_annotation$$branch>:
 800071c:	f000 fe39 	bl	8001392 <__iar_annotation$$branch+0x99a>
 8000720:	1e92      	subs	r2, r2, #2
 8000722:	d101      	bne.n	8000728 <__iar_annotation$$branch+0x4>

08000724 <__iar_annotation$$branch>:
 8000724:	f000 fea0 	bl	8001468 <__iar_annotation$$branch+0xa70>
 8000728:	1e52      	subs	r2, r2, #1
 800072a:	d101      	bne.n	8000730 <__iar_annotation$$branch+0x4>

0800072c <__iar_annotation$$branch>:
 800072c:	f000 fefa 	bl	8001524 <__iar_annotation$$branch+0xb2c>
 8000730:	1e52      	subs	r2, r2, #1
 8000732:	d101      	bne.n	8000738 <__iar_annotation$$branch+0x4>

08000734 <__iar_annotation$$branch>:
 8000734:	f000 ff1a 	bl	800156c <__iar_annotation$$branch+0xb74>
 8000738:	1e52      	subs	r2, r2, #1
 800073a:	d101      	bne.n	8000740 <__iar_annotation$$branch+0x4>

0800073c <__iar_annotation$$branch>:
 800073c:	f000 fcc7 	bl	80010ce <__iar_annotation$$branch+0x6d6>
 8000740:	1e52      	subs	r2, r2, #1
 8000742:	d101      	bne.n	8000748 <__iar_annotation$$branch+0x4>

08000744 <__iar_annotation$$branch>:
 8000744:	f000 fcd1 	bl	80010ea <__iar_annotation$$branch+0x6f2>
 8000748:	1e52      	subs	r2, r2, #1
 800074a:	d101      	bne.n	8000750 <__iar_annotation$$branch+0x4>

0800074c <__iar_annotation$$branch>:
 800074c:	f000 fcda 	bl	8001104 <__iar_annotation$$branch+0x70c>
 8000750:	1e52      	subs	r2, r2, #1
 8000752:	d101      	bne.n	8000758 <__iar_annotation$$branch+0x4>

08000754 <__iar_annotation$$branch>:
 8000754:	f000 fe21 	bl	800139a <__iar_annotation$$branch+0x9a2>
 8000758:	1e52      	subs	r2, r2, #1
 800075a:	d101      	bne.n	8000760 <__iar_annotation$$branch+0x4>

0800075c <__iar_annotation$$branch>:
 800075c:	f001 f9a5 	bl	8001aaa <__iar_annotation$$branch+0xca>
 8000760:	1e52      	subs	r2, r2, #1
 8000762:	d018      	beq.n	8000796 <__iar_annotation$$branch+0xe>
 8000764:	1e52      	subs	r2, r2, #1
 8000766:	d101      	bne.n	800076c <__iar_annotation$$branch+0x4>

08000768 <__iar_annotation$$branch>:
 8000768:	f001 f9ae 	bl	8001ac8 <__iar_annotation$$branch+0xe8>
 800076c:	1e52      	subs	r2, r2, #1
 800076e:	d101      	bne.n	8000774 <__iar_annotation$$branch+0x4>

08000770 <__iar_annotation$$branch>:
 8000770:	f001 f9e6 	bl	8001b40 <__iar_annotation$$branch+0x160>
 8000774:	1e52      	subs	r2, r2, #1
 8000776:	2a01      	cmp	r2, #1
 8000778:	d90d      	bls.n	8000796 <__iar_annotation$$branch+0xe>
 800077a:	1e92      	subs	r2, r2, #2
 800077c:	2a07      	cmp	r2, #7
 800077e:	d801      	bhi.n	8000784 <__iar_annotation$$branch+0x4>

08000780 <__iar_annotation$$branch>:
 8000780:	f001 fa10 	bl	8001ba4 <__iar_annotation$$branch+0x22>
 8000784:	3a08      	subs	r2, #8
 8000786:	d101      	bne.n	800078c <__iar_annotation$$branch+0x4>

08000788 <__iar_annotation$$branch>:
 8000788:	f001 f9fd 	bl	8001b86 <__iar_annotation$$branch+0x4>
 800078c:	1e52      	subs	r2, r2, #1
 800078e:	2a03      	cmp	r2, #3
 8000790:	d901      	bls.n	8000796 <__iar_annotation$$branch+0xe>
 8000792:	3a28      	subs	r2, #40	; 0x28
 8000794:	2a01      	cmp	r2, #1
 8000796:	d801      	bhi.n	800079c <__iar_annotation$$branch+0x4>

08000798 <__iar_annotation$$branch>:
 8000798:	f001 fa09 	bl	8001bae <__iar_annotation$$branch+0x2c>
 800079c:	3a12      	subs	r2, #18
 800079e:	d0fa      	beq.n	8000796 <__iar_annotation$$branch+0xe>
 80007a0:	3a1e      	subs	r2, #30
 80007a2:	d023      	beq.n	80007ec <__iar_annotation$$branch+0x10>
 80007a4:	1e52      	subs	r2, r2, #1
 80007a6:	d101      	bne.n	80007ac <__iar_annotation$$branch+0x4>

080007a8 <__iar_annotation$$branch>:
 80007a8:	f001 f898 	bl	80018dc <__iar_annotation$$branch+0x1e>
 80007ac:	1e52      	subs	r2, r2, #1
 80007ae:	d101      	bne.n	80007b4 <__iar_annotation$$branch+0x4>

080007b0 <__iar_annotation$$branch>:
 80007b0:	f001 f8e0 	bl	8001974 <__iar_annotation$$branch+0xb6>
 80007b4:	1e52      	subs	r2, r2, #1
 80007b6:	d101      	bne.n	80007bc <__iar_annotation$$branch+0x4>

080007b8 <__iar_annotation$$branch>:
 80007b8:	f001 f8fb 	bl	80019b2 <__iar_annotation$$branch+0xf4>
 80007bc:	1e52      	subs	r2, r2, #1
 80007be:	d100      	bne.n	80007c2 <__iar_annotation$$branch+0xa>
 80007c0:	e339      	b.n	8000e36 <__iar_annotation$$branch+0x43e>
 80007c2:	1e52      	subs	r2, r2, #1
 80007c4:	d100      	bne.n	80007c8 <__iar_annotation$$branch+0x10>
 80007c6:	e35c      	b.n	8000e82 <__iar_annotation$$branch+0x48a>
 80007c8:	1e92      	subs	r2, r2, #2
 80007ca:	d101      	bne.n	80007d0 <__iar_annotation$$branch+0x4>

080007cc <__iar_annotation$$branch>:
 80007cc:	f001 fa02 	bl	8001bd4 <__iar_annotation$$branch+0x52>
 80007d0:	1e52      	subs	r2, r2, #1
 80007d2:	d100      	bne.n	80007d6 <__iar_annotation$$branch+0xa>
 80007d4:	e0b9      	b.n	800094a <__iar_annotation$$branch+0x16e>
 80007d6:	1e92      	subs	r2, r2, #2
 80007d8:	2a08      	cmp	r2, #8
 80007da:	d801      	bhi.n	80007e0 <__iar_annotation$$branch+0x4>

080007dc <__iar_annotation$$branch>:
 80007dc:	f001 f9ec 	bl	8001bb8 <__iar_annotation$$branch+0x36>
 80007e0:	3a09      	subs	r2, #9
 80007e2:	d0cc      	beq.n	800077e <__iar_annotation$$branch+0xe>
 80007e4:	e0ee      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80007e6:	bf00      	nop
 80007e8:	200019a8 	.word	0x200019a8
 80007ec:	68a0      	ldr	r0, [r4, #8]
 80007ee:	6b81      	ldr	r1, [r0, #56]	; 0x38
 80007f0:	2900      	cmp	r1, #0
 80007f2:	d003      	beq.n	80007fc <__iar_annotation$$branch+0x20>
 80007f4:	7b22      	ldrb	r2, [r4, #12]
 80007f6:	07d0      	lsls	r0, r2, #31
 80007f8:	0fc0      	lsrs	r0, r0, #31
 80007fa:	4788      	blx	r1
 80007fc:	2014      	movs	r0, #20
 80007fe:	4669      	mov	r1, sp
 8000800:	7308      	strb	r0, [r1, #12]
 8000802:	2101      	movs	r1, #1
 8000804:	a80a      	add	r0, sp, #40	; 0x28
 8000806:	7800      	ldrb	r0, [r0, #0]
 8000808:	f003 fcc1 	bl	800418e <PE_Reset>
 800080c:	a80a      	add	r0, sp, #40	; 0x28
 800080e:	7800      	ldrb	r0, [r0, #0]
 8000810:	f004 fe20 	bl	8005454 <USBPD_PRL_Reset>
 8000814:	e0d6      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000816:	2500      	movs	r5, #0
 8000818:	43ed      	mvns	r5, r5
 800081a:	6860      	ldr	r0, [r4, #4]
 800081c:	6801      	ldr	r1, [r0, #0]
 800081e:	2210      	movs	r2, #16
 8000820:	4391      	bics	r1, r2
 8000822:	6001      	str	r1, [r0, #0]
 8000824:	e0ce      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000826:	6860      	ldr	r0, [r4, #4]
 8000828:	6800      	ldr	r0, [r0, #0]
 800082a:	0340      	lsls	r0, r0, #13
 800082c:	0fc1      	lsrs	r1, r0, #31
 800082e:	a80a      	add	r0, sp, #40	; 0x28
 8000830:	7800      	ldrb	r0, [r0, #0]
 8000832:	f004 fbb2 	bl	8004f9a <USBPD_PRL_CableCapable>
 8000836:	6860      	ldr	r0, [r4, #4]
 8000838:	2701      	movs	r7, #1
 800083a:	6801      	ldr	r1, [r0, #0]
 800083c:	0ac9      	lsrs	r1, r1, #11
 800083e:	4039      	ands	r1, r7
 8000840:	d100      	bne.n	8000844 <__iar_annotation$$branch+0x68>
 8000842:	e170      	b.n	8000b26 <__iar_annotation$$branch+0x12e>
 8000844:	2103      	movs	r1, #3
 8000846:	6822      	ldr	r2, [r4, #0]
 8000848:	7913      	ldrb	r3, [r2, #4]
 800084a:	2203      	movs	r2, #3
 800084c:	401a      	ands	r2, r3
 800084e:	7803      	ldrb	r3, [r0, #0]
 8000850:	25fc      	movs	r5, #252	; 0xfc
 8000852:	401d      	ands	r5, r3
 8000854:	432a      	orrs	r2, r5
 8000856:	7002      	strb	r2, [r0, #0]
 8000858:	6860      	ldr	r0, [r4, #4]
 800085a:	7802      	ldrb	r2, [r0, #0]
 800085c:	4011      	ands	r1, r2
 800085e:	2901      	cmp	r1, #1
 8000860:	d101      	bne.n	8000866 <__iar_annotation$$branch+0x8a>
 8000862:	2100      	movs	r1, #0
 8000864:	e000      	b.n	8000868 <__iar_annotation$$branch+0x8c>
 8000866:	2101      	movs	r1, #1
 8000868:	239f      	movs	r3, #159	; 0x9f
 800086a:	4013      	ands	r3, r2
 800086c:	0149      	lsls	r1, r1, #5
 800086e:	4319      	orrs	r1, r3
 8000870:	7001      	strb	r1, [r0, #0]
 8000872:	2000      	movs	r0, #0
 8000874:	7560      	strb	r0, [r4, #21]
 8000876:	6860      	ldr	r0, [r4, #4]
 8000878:	7841      	ldrb	r1, [r0, #1]
 800087a:	228f      	movs	r2, #143	; 0x8f
 800087c:	400a      	ands	r2, r1
 800087e:	2110      	movs	r1, #16
 8000880:	4311      	orrs	r1, r2
 8000882:	7041      	strb	r1, [r0, #1]
 8000884:	4db3      	ldr	r5, [pc, #716]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000886:	7828      	ldrb	r0, [r5, #0]
 8000888:	0780      	lsls	r0, r0, #30
 800088a:	d509      	bpl.n	80008a0 <__iar_annotation$$branch+0xc4>
 800088c:	2000      	movs	r0, #0
 800088e:	9000      	str	r0, [sp, #0]
 8000890:	2300      	movs	r3, #0
 8000892:	2256      	movs	r2, #86	; 0x56
 8000894:	68e0      	ldr	r0, [r4, #12]
 8000896:	2101      	movs	r1, #1
 8000898:	4001      	ands	r1, r0
 800089a:	2009      	movs	r0, #9
 800089c:	68ed      	ldr	r5, [r5, #12]
 800089e:	47a8      	blx	r5
 80008a0:	2156      	movs	r1, #86	; 0x56
 80008a2:	68e2      	ldr	r2, [r4, #12]
 80008a4:	2001      	movs	r0, #1
 80008a6:	4010      	ands	r0, r2
 80008a8:	68a2      	ldr	r2, [r4, #8]
 80008aa:	68d2      	ldr	r2, [r2, #12]
 80008ac:	4790      	blx	r2
 80008ae:	6860      	ldr	r0, [r4, #4]
 80008b0:	6800      	ldr	r0, [r0, #0]
 80008b2:	0900      	lsrs	r0, r0, #4
 80008b4:	4007      	ands	r7, r0
 80008b6:	d005      	beq.n	80008c4 <__iar_annotation$$branch+0xe8>
 80008b8:	48a7      	ldr	r0, [pc, #668]	; (8000b58 <__iar_annotation$$branch+0x160>)
 80008ba:	84b0      	strh	r0, [r6, #36]	; 0x24
 80008bc:	2514      	movs	r5, #20
 80008be:	2006      	movs	r0, #6
 80008c0:	7230      	strb	r0, [r6, #8]
 80008c2:	e07f      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80008c4:	2005      	movs	r0, #5
 80008c6:	e0e8      	b.n	8000a9a <__iar_annotation$$branch+0xa2>
 80008c8:	2001      	movs	r0, #1
 80008ca:	6861      	ldr	r1, [r4, #4]
 80008cc:	6809      	ldr	r1, [r1, #0]
 80008ce:	0c89      	lsrs	r1, r1, #18
 80008d0:	4001      	ands	r1, r0
 80008d2:	d100      	bne.n	80008d6 <__iar_annotation$$branch+0xfa>
 80008d4:	e0e0      	b.n	8000a98 <__iar_annotation$$branch+0xa0>
 80008d6:	6821      	ldr	r1, [r4, #0]
 80008d8:	7809      	ldrb	r1, [r1, #0]
 80008da:	0789      	lsls	r1, r1, #30
 80008dc:	d400      	bmi.n	80008e0 <__iar_annotation$$branch+0x104>
 80008de:	e0db      	b.n	8000a98 <__iar_annotation$$branch+0xa0>
 80008e0:	21ff      	movs	r1, #255	; 0xff
 80008e2:	1c89      	adds	r1, r1, #2
 80008e4:	82e1      	strh	r1, [r4, #22]
 80008e6:	7831      	ldrb	r1, [r6, #0]
 80008e8:	22e0      	movs	r2, #224	; 0xe0
 80008ea:	400a      	ands	r2, r1
 80008ec:	4310      	orrs	r0, r2
 80008ee:	7030      	strb	r0, [r6, #0]
 80008f0:	7870      	ldrb	r0, [r6, #1]
 80008f2:	2180      	movs	r1, #128	; 0x80
 80008f4:	4301      	orrs	r1, r0
 80008f6:	7071      	strb	r1, [r6, #1]
 80008f8:	6860      	ldr	r0, [r4, #4]
 80008fa:	7800      	ldrb	r0, [r0, #0]
 80008fc:	0640      	lsls	r0, r0, #25
 80008fe:	0f80      	lsrs	r0, r0, #30
 8000900:	6831      	ldr	r1, [r6, #0]
 8000902:	4a96      	ldr	r2, [pc, #600]	; (8000b5c <__iar_annotation$$branch+0x164>)
 8000904:	400a      	ands	r2, r1
 8000906:	0340      	lsls	r0, r0, #13
 8000908:	4310      	orrs	r0, r2
 800090a:	6030      	str	r0, [r6, #0]
 800090c:	4994      	ldr	r1, [pc, #592]	; (8000b60 <__iar_annotation$$branch+0x168>)
 800090e:	4001      	ands	r1, r0
 8000910:	6031      	str	r1, [r6, #0]
 8000912:	7830      	ldrb	r0, [r6, #0]
 8000914:	0680      	lsls	r0, r0, #26
 8000916:	0e80      	lsrs	r0, r0, #26
 8000918:	7030      	strb	r0, [r6, #0]
 800091a:	6830      	ldr	r0, [r6, #0]
 800091c:	b280      	uxth	r0, r0
 800091e:	21ff      	movs	r1, #255	; 0xff
 8000920:	0609      	lsls	r1, r1, #24
 8000922:	4301      	orrs	r1, r0
 8000924:	6031      	str	r1, [r6, #0]
 8000926:	2001      	movs	r0, #1
 8000928:	9002      	str	r0, [sp, #8]
 800092a:	209a      	movs	r0, #154	; 0x9a
 800092c:	9001      	str	r0, [sp, #4]
 800092e:	2001      	movs	r0, #1
 8000930:	9000      	str	r0, [sp, #0]
 8000932:	0033      	movs	r3, r6
 8000934:	220f      	movs	r2, #15
 8000936:	2101      	movs	r1, #1
 8000938:	0020      	movs	r0, r4
 800093a:	f002 ff61 	bl	8003800 <PE_Send_DataMessage>
 800093e:	2800      	cmp	r0, #0
 8000940:	d140      	bne.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000942:	4888      	ldr	r0, [pc, #544]	; (8000b64 <__iar_annotation$$branch+0x16c>)
 8000944:	83b0      	strh	r0, [r6, #28]
 8000946:	251e      	movs	r5, #30
 8000948:	e03c      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 800094a:	2912      	cmp	r1, #18
 800094c:	d136      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 800094e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000950:	0bc0      	lsrs	r0, r0, #15
 8000952:	d133      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 8000954:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000956:	0b00      	lsrs	r0, r0, #12
 8000958:	0740      	lsls	r0, r0, #29
 800095a:	d02f      	beq.n	80009bc <__iar_annotation$$branch+0x1e0>
 800095c:	201f      	movs	r0, #31
 800095e:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000960:	4001      	ands	r1, r0
 8000962:	290f      	cmp	r1, #15
 8000964:	d12a      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 8000966:	219e      	movs	r1, #158	; 0x9e
 8000968:	0049      	lsls	r1, r1, #1
 800096a:	1861      	adds	r1, r4, r1
 800096c:	780a      	ldrb	r2, [r1, #0]
 800096e:	784b      	ldrb	r3, [r1, #1]
 8000970:	021b      	lsls	r3, r3, #8
 8000972:	18d2      	adds	r2, r2, r3
 8000974:	788b      	ldrb	r3, [r1, #2]
 8000976:	041b      	lsls	r3, r3, #16
 8000978:	18d2      	adds	r2, r2, r3
 800097a:	78c9      	ldrb	r1, [r1, #3]
 800097c:	0609      	lsls	r1, r1, #24
 800097e:	1851      	adds	r1, r2, r1
 8000980:	9100      	str	r1, [sp, #0]
 8000982:	4669      	mov	r1, sp
 8000984:	7809      	ldrb	r1, [r1, #0]
 8000986:	4008      	ands	r0, r1
 8000988:	2801      	cmp	r0, #1
 800098a:	d117      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 800098c:	0988      	lsrs	r0, r1, #6
 800098e:	2801      	cmp	r0, #1
 8000990:	d114      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 8000992:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000994:	0440      	lsls	r0, r0, #17
 8000996:	0f40      	lsrs	r0, r0, #29
 8000998:	1e43      	subs	r3, r0, #1
 800099a:	20a0      	movs	r0, #160	; 0xa0
 800099c:	0040      	lsls	r0, r0, #1
 800099e:	1822      	adds	r2, r4, r0
 80009a0:	2113      	movs	r1, #19
 80009a2:	7b27      	ldrb	r7, [r4, #12]
 80009a4:	07f8      	lsls	r0, r7, #31
 80009a6:	0fc0      	lsrs	r0, r0, #31
 80009a8:	68a7      	ldr	r7, [r4, #8]
 80009aa:	69ff      	ldr	r7, [r7, #28]
 80009ac:	47b8      	blx	r7
 80009ae:	2007      	movs	r0, #7
 80009b0:	7230      	strb	r0, [r6, #8]
 80009b2:	2000      	movs	r0, #0
 80009b4:	83b0      	strh	r0, [r6, #28]
 80009b6:	2014      	movs	r0, #20
 80009b8:	4669      	mov	r1, sp
 80009ba:	7308      	strb	r0, [r1, #12]
 80009bc:	8bb0      	ldrh	r0, [r6, #28]
 80009be:	03a9      	lsls	r1, r5, #14
 80009c0:	4288      	cmp	r0, r1
 80009c2:	d05f      	beq.n	8000a84 <__iar_annotation$$branch+0x8c>
 80009c4:	4863      	ldr	r0, [pc, #396]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 80009c6:	68c7      	ldr	r7, [r0, #12]
 80009c8:	2f00      	cmp	r7, #0
 80009ca:	d010      	beq.n	80009ee <__iar_annotation$$branch+0x212>
 80009cc:	7800      	ldrb	r0, [r0, #0]
 80009ce:	07c0      	lsls	r0, r0, #31
 80009d0:	d50d      	bpl.n	80009ee <__iar_annotation$$branch+0x212>
 80009d2:	7a30      	ldrb	r0, [r6, #8]
 80009d4:	7a71      	ldrb	r1, [r6, #9]
 80009d6:	4281      	cmp	r1, r0
 80009d8:	d009      	beq.n	80009ee <__iar_annotation$$branch+0x212>
 80009da:	7270      	strb	r0, [r6, #9]
 80009dc:	2000      	movs	r0, #0
 80009de:	9000      	str	r0, [sp, #0]
 80009e0:	2300      	movs	r3, #0
 80009e2:	7a32      	ldrb	r2, [r6, #8]
 80009e4:	7b20      	ldrb	r0, [r4, #12]
 80009e6:	07c1      	lsls	r1, r0, #31
 80009e8:	0fc9      	lsrs	r1, r1, #31
 80009ea:	2004      	movs	r0, #4
 80009ec:	47b8      	blx	r7
 80009ee:	2701      	movs	r7, #1
 80009f0:	4668      	mov	r0, sp
 80009f2:	7b00      	ldrb	r0, [r0, #12]
 80009f4:	2814      	cmp	r0, #20
 80009f6:	d101      	bne.n	80009fc <__iar_annotation$$branch+0x4>

080009f8 <__iar_annotation$$branch>:
 80009f8:	f001 f8fd 	bl	8001bf6 <__iar_annotation$$branch+0x4>
 80009fc:	0020      	movs	r0, r4
 80009fe:	f003 f809 	bl	8003a14 <PE_Check_AMSConflict>
 8000a02:	2815      	cmp	r0, #21
 8000a04:	d102      	bne.n	8000a0c <__iar_annotation$$branch+0x14>
 8000a06:	2014      	movs	r0, #20
 8000a08:	4669      	mov	r1, sp
 8000a0a:	7308      	strb	r0, [r1, #12]
 8000a0c:	4851      	ldr	r0, [pc, #324]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000a0e:	68c5      	ldr	r5, [r0, #12]
 8000a10:	2d00      	cmp	r5, #0
 8000a12:	d010      	beq.n	8000a36 <__iar_annotation$$branch+0x3e>
 8000a14:	7800      	ldrb	r0, [r0, #0]
 8000a16:	07c0      	lsls	r0, r0, #31
 8000a18:	d50d      	bpl.n	8000a36 <__iar_annotation$$branch+0x3e>
 8000a1a:	7a30      	ldrb	r0, [r6, #8]
 8000a1c:	7a71      	ldrb	r1, [r6, #9]
 8000a1e:	4281      	cmp	r1, r0
 8000a20:	d009      	beq.n	8000a36 <__iar_annotation$$branch+0x3e>
 8000a22:	7270      	strb	r0, [r6, #9]
 8000a24:	2000      	movs	r0, #0
 8000a26:	9000      	str	r0, [sp, #0]
 8000a28:	2300      	movs	r3, #0
 8000a2a:	7a32      	ldrb	r2, [r6, #8]
 8000a2c:	68e0      	ldr	r0, [r4, #12]
 8000a2e:	2101      	movs	r1, #1
 8000a30:	4001      	ands	r1, r0
 8000a32:	2004      	movs	r0, #4
 8000a34:	47a8      	blx	r5
 8000a36:	2500      	movs	r5, #0
 8000a38:	9808      	ldr	r0, [sp, #32]
 8000a3a:	2800      	cmp	r0, #0
 8000a3c:	d01c      	beq.n	8000a78 <__iar_annotation$$branch+0x80>
 8000a3e:	4845      	ldr	r0, [pc, #276]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000a40:	6901      	ldr	r1, [r0, #16]
 8000a42:	4a49      	ldr	r2, [pc, #292]	; (8000b68 <__iar_annotation$$branch+0x170>)
 8000a44:	4291      	cmp	r1, r2
 8000a46:	d017      	beq.n	8000a78 <__iar_annotation$$branch+0x80>
 8000a48:	1d01      	adds	r1, r0, #4
 8000a4a:	68e2      	ldr	r2, [r4, #12]
 8000a4c:	403a      	ands	r2, r7
 8000a4e:	0092      	lsls	r2, r2, #2
 8000a50:	5889      	ldr	r1, [r1, r2]
 8000a52:	68ce      	ldr	r6, [r1, #12]
 8000a54:	0b33      	lsrs	r3, r6, #12
 8000a56:	1c5b      	adds	r3, r3, #1
 8000a58:	4a44      	ldr	r2, [pc, #272]	; (8000b6c <__iar_annotation$$branch+0x174>)
 8000a5a:	4016      	ands	r6, r2
 8000a5c:	031b      	lsls	r3, r3, #12
 8000a5e:	4333      	orrs	r3, r6
 8000a60:	60cb      	str	r3, [r1, #12]
 8000a62:	1d00      	adds	r0, r0, #4
 8000a64:	68e1      	ldr	r1, [r4, #12]
 8000a66:	400f      	ands	r7, r1
 8000a68:	00b9      	lsls	r1, r7, #2
 8000a6a:	5840      	ldr	r0, [r0, r1]
 8000a6c:	68c1      	ldr	r1, [r0, #12]
 8000a6e:	0b0b      	lsrs	r3, r1, #12
 8000a70:	2b08      	cmp	r3, #8
 8000a72:	db01      	blt.n	8000a78 <__iar_annotation$$branch+0x80>
 8000a74:	400a      	ands	r2, r1
 8000a76:	60c2      	str	r2, [r0, #12]
 8000a78:	2d00      	cmp	r5, #0
 8000a7a:	d100      	bne.n	8000a7e <__iar_annotation$$branch+0x86>
 8000a7c:	e5ab      	b.n	80005d6 <USBPD_PE_StateMachine_SRC+0xca>
 8000a7e:	0028      	movs	r0, r5
 8000a80:	b00b      	add	sp, #44	; 0x2c
 8000a82:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000a84:	2000      	movs	r0, #0
 8000a86:	83b0      	strh	r0, [r6, #28]
 8000a88:	2007      	movs	r0, #7
 8000a8a:	7230      	strb	r0, [r6, #8]
 8000a8c:	2010      	movs	r0, #16
 8000a8e:	e7f7      	b.n	8000a80 <__iar_annotation$$branch+0x88>
 8000a90:	8cb0      	ldrh	r0, [r6, #36]	; 0x24
 8000a92:	03a9      	lsls	r1, r5, #14
 8000a94:	4288      	cmp	r0, r1
 8000a96:	d195      	bne.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000a98:	2007      	movs	r0, #7
 8000a9a:	7230      	strb	r0, [r6, #8]
 8000a9c:	2500      	movs	r5, #0
 8000a9e:	e791      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000aa0:	2101      	movs	r1, #1
 8000aa2:	0020      	movs	r0, r4
 8000aa4:	f002 fe0b 	bl	80036be <PE_Send_SRCCapabilities>
 8000aa8:	2805      	cmp	r0, #5
 8000aaa:	d002      	beq.n	8000ab2 <__iar_annotation$$branch+0xba>
 8000aac:	2809      	cmp	r0, #9
 8000aae:	d089      	beq.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000ab0:	e023      	b.n	8000afa <__iar_annotation$$branch+0x102>
 8000ab2:	2001      	movs	r0, #1
 8000ab4:	82e0      	strh	r0, [r4, #22]
 8000ab6:	2002      	movs	r0, #2
 8000ab8:	68e1      	ldr	r1, [r4, #12]
 8000aba:	4301      	orrs	r1, r0
 8000abc:	60e1      	str	r1, [r4, #12]
 8000abe:	2100      	movs	r1, #0
 8000ac0:	7561      	strb	r1, [r4, #21]
 8000ac2:	7521      	strb	r1, [r4, #20]
 8000ac4:	492a      	ldr	r1, [pc, #168]	; (8000b70 <__iar_annotation$$branch+0x178>)
 8000ac6:	83b1      	strh	r1, [r6, #28]
 8000ac8:	251a      	movs	r5, #26
 8000aca:	2116      	movs	r1, #22
 8000acc:	7231      	strb	r1, [r6, #8]
 8000ace:	4f21      	ldr	r7, [pc, #132]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000ad0:	7839      	ldrb	r1, [r7, #0]
 8000ad2:	4201      	tst	r1, r0
 8000ad4:	d009      	beq.n	8000aea <__iar_annotation$$branch+0xf2>
 8000ad6:	2000      	movs	r0, #0
 8000ad8:	9000      	str	r0, [sp, #0]
 8000ada:	2300      	movs	r3, #0
 8000adc:	220f      	movs	r2, #15
 8000ade:	7b20      	ldrb	r0, [r4, #12]
 8000ae0:	07c1      	lsls	r1, r0, #31
 8000ae2:	0fc9      	lsrs	r1, r1, #31
 8000ae4:	2009      	movs	r0, #9
 8000ae6:	68ff      	ldr	r7, [r7, #12]
 8000ae8:	47b8      	blx	r7
 8000aea:	210f      	movs	r1, #15
 8000aec:	7b22      	ldrb	r2, [r4, #12]
 8000aee:	07d0      	lsls	r0, r2, #31
 8000af0:	0fc0      	lsrs	r0, r0, #31
 8000af2:	68a2      	ldr	r2, [r4, #8]
 8000af4:	68d2      	ldr	r2, [r2, #12]
 8000af6:	4790      	blx	r2
 8000af8:	e764      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000afa:	2701      	movs	r7, #1
 8000afc:	68e1      	ldr	r1, [r4, #12]
 8000afe:	2001      	movs	r0, #1
 8000b00:	4008      	ands	r0, r1
 8000b02:	f004 fa37 	bl	8004f74 <USBPD_PRL_SRCReleaseSinkNG>
 8000b06:	68e0      	ldr	r0, [r4, #12]
 8000b08:	0840      	lsrs	r0, r0, #1
 8000b0a:	4007      	ands	r7, r0
 8000b0c:	d107      	bne.n	8000b1e <__iar_annotation$$branch+0x126>
 8000b0e:	7d60      	ldrb	r0, [r4, #21]
 8000b10:	2833      	cmp	r0, #51	; 0x33
 8000b12:	d204      	bcs.n	8000b1e <__iar_annotation$$branch+0x126>
 8000b14:	4817      	ldr	r0, [pc, #92]	; (8000b74 <__iar_annotation$$branch+0x17c>)
 8000b16:	8430      	strh	r0, [r6, #32]
 8000b18:	2596      	movs	r5, #150	; 0x96
 8000b1a:	2008      	movs	r0, #8
 8000b1c:	e6d0      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000b1e:	2f00      	cmp	r7, #0
 8000b20:	d001      	beq.n	8000b26 <__iar_annotation$$branch+0x12e>
 8000b22:	200f      	movs	r0, #15
 8000b24:	e7b9      	b.n	8000a9a <__iar_annotation$$branch+0xa2>
 8000b26:	4f0b      	ldr	r7, [pc, #44]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000b28:	7838      	ldrb	r0, [r7, #0]
 8000b2a:	0780      	lsls	r0, r0, #30
 8000b2c:	d509      	bpl.n	8000b42 <__iar_annotation$$branch+0x14a>
 8000b2e:	2000      	movs	r0, #0
 8000b30:	9000      	str	r0, [sp, #0]
 8000b32:	2300      	movs	r3, #0
 8000b34:	2220      	movs	r2, #32
 8000b36:	7b20      	ldrb	r0, [r4, #12]
 8000b38:	07c1      	lsls	r1, r0, #31
 8000b3a:	0fc9      	lsrs	r1, r1, #31
 8000b3c:	2009      	movs	r0, #9
 8000b3e:	68ff      	ldr	r7, [r7, #12]
 8000b40:	47b8      	blx	r7
 8000b42:	2120      	movs	r1, #32
 8000b44:	7b22      	ldrb	r2, [r4, #12]
 8000b46:	07d0      	lsls	r0, r2, #31
 8000b48:	0fc0      	lsrs	r0, r0, #31
 8000b4a:	68a2      	ldr	r2, [r4, #8]
 8000b4c:	68d2      	ldr	r2, [r2, #12]
 8000b4e:	4790      	blx	r2
 8000b50:	2000      	movs	r0, #0
 8000b52:	e6b5      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000b54:	200019a8 	.word	0x200019a8
 8000b58:	00008014 	.word	0x00008014
 8000b5c:	ffff9fff 	.word	0xffff9fff
 8000b60:	fffff8ff 	.word	0xfffff8ff
 8000b64:	0000801e 	.word	0x0000801e
 8000b68:	b5e8b5cd 	.word	0xb5e8b5cd
 8000b6c:	00000fff 	.word	0x00000fff
 8000b70:	0000801a 	.word	0x0000801a
 8000b74:	00008096 	.word	0x00008096
 8000b78:	8c30      	ldrh	r0, [r6, #32]
 8000b7a:	03a9      	lsls	r1, r5, #14
 8000b7c:	4288      	cmp	r0, r1
 8000b7e:	d1bb      	bne.n	8000af8 <__iar_annotation$$branch+0x100>
 8000b80:	2000      	movs	r0, #0
 8000b82:	8430      	strh	r0, [r6, #32]
 8000b84:	6820      	ldr	r0, [r4, #0]
 8000b86:	6840      	ldr	r0, [r0, #4]
 8000b88:	0601      	lsls	r1, r0, #24
 8000b8a:	0fc9      	lsrs	r1, r1, #31
 8000b8c:	d002      	beq.n	8000b94 <__iar_annotation$$branch+0x19c>
 8000b8e:	7d60      	ldrb	r0, [r4, #21]
 8000b90:	1c40      	adds	r0, r0, #1
 8000b92:	7560      	strb	r0, [r4, #21]
 8000b94:	2007      	movs	r0, #7
 8000b96:	e693      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000b98:	2911      	cmp	r1, #17
 8000b9a:	d132      	bne.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000b9c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000b9e:	0bc0      	lsrs	r0, r0, #15
 8000ba0:	d12f      	bne.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000ba2:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000ba4:	0b00      	lsrs	r0, r0, #12
 8000ba6:	0740      	lsls	r0, r0, #29
 8000ba8:	d02b      	beq.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000baa:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000bac:	06c0      	lsls	r0, r0, #27
 8000bae:	0ec0      	lsrs	r0, r0, #27
 8000bb0:	2802      	cmp	r0, #2
 8000bb2:	d126      	bne.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000bb4:	2501      	movs	r5, #1
 8000bb6:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000bb8:	0600      	lsls	r0, r0, #24
 8000bba:	0f81      	lsrs	r1, r0, #30
 8000bbc:	68e2      	ldr	r2, [r4, #12]
 8000bbe:	2001      	movs	r0, #1
 8000bc0:	4010      	ands	r0, r2
 8000bc2:	f003 fc05 	bl	80043d0 <PE_ExtRevisionInteroperability>
 8000bc6:	209e      	movs	r0, #158	; 0x9e
 8000bc8:	0040      	lsls	r0, r0, #1
 8000bca:	1820      	adds	r0, r4, r0
 8000bcc:	7801      	ldrb	r1, [r0, #0]
 8000bce:	7842      	ldrb	r2, [r0, #1]
 8000bd0:	0212      	lsls	r2, r2, #8
 8000bd2:	1889      	adds	r1, r1, r2
 8000bd4:	7882      	ldrb	r2, [r0, #2]
 8000bd6:	0412      	lsls	r2, r2, #16
 8000bd8:	1889      	adds	r1, r1, r2
 8000bda:	78c0      	ldrb	r0, [r0, #3]
 8000bdc:	0600      	lsls	r0, r0, #24
 8000bde:	1808      	adds	r0, r1, r0
 8000be0:	9000      	str	r0, [sp, #0]
 8000be2:	2304      	movs	r3, #4
 8000be4:	466a      	mov	r2, sp
 8000be6:	2106      	movs	r1, #6
 8000be8:	68e0      	ldr	r0, [r4, #12]
 8000bea:	4005      	ands	r5, r0
 8000bec:	0028      	movs	r0, r5
 8000bee:	68a5      	ldr	r5, [r4, #8]
 8000bf0:	69ed      	ldr	r5, [r5, #28]
 8000bf2:	47a8      	blx	r5
 8000bf4:	2500      	movs	r5, #0
 8000bf6:	83b5      	strh	r5, [r6, #28]
 8000bf8:	2009      	movs	r0, #9
 8000bfa:	7230      	strb	r0, [r6, #8]
 8000bfc:	2014      	movs	r0, #20
 8000bfe:	4669      	mov	r1, sp
 8000c00:	7308      	strb	r0, [r1, #12]
 8000c02:	8bb0      	ldrh	r0, [r6, #28]
 8000c04:	2180      	movs	r1, #128	; 0x80
 8000c06:	0209      	lsls	r1, r1, #8
 8000c08:	4288      	cmp	r0, r1
 8000c0a:	d163      	bne.n	8000cd4 <__iar_annotation$$branch+0x2dc>
 8000c0c:	e1d3      	b.n	8000fb6 <__iar_annotation$$branch+0x5be>
 8000c0e:	a901      	add	r1, sp, #4
 8000c10:	7b22      	ldrb	r2, [r4, #12]
 8000c12:	07d0      	lsls	r0, r2, #31
 8000c14:	0fc0      	lsrs	r0, r0, #31
 8000c16:	68a2      	ldr	r2, [r4, #8]
 8000c18:	6a12      	ldr	r2, [r2, #32]
 8000c1a:	4790      	blx	r2
 8000c1c:	280a      	cmp	r0, #10
 8000c1e:	d01c      	beq.n	8000c5a <__iar_annotation$$branch+0x262>
 8000c20:	280b      	cmp	r0, #11
 8000c22:	d002      	beq.n	8000c2a <__iar_annotation$$branch+0x232>
 8000c24:	280d      	cmp	r0, #13
 8000c26:	d056      	beq.n	8000cd6 <__iar_annotation$$branch+0x2de>
 8000c28:	e06d      	b.n	8000d06 <__iar_annotation$$branch+0x30e>
 8000c2a:	2000      	movs	r0, #0
 8000c2c:	9000      	str	r0, [sp, #0]
 8000c2e:	230c      	movs	r3, #12
 8000c30:	2202      	movs	r2, #2
 8000c32:	2100      	movs	r1, #0
 8000c34:	0020      	movs	r0, r4
 8000c36:	f002 fd9c 	bl	8003772 <PE_Send_CtrlMessage>
 8000c3a:	4fb8      	ldr	r7, [pc, #736]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000c3c:	7838      	ldrb	r0, [r7, #0]
 8000c3e:	0780      	lsls	r0, r0, #30
 8000c40:	d509      	bpl.n	8000c56 <__iar_annotation$$branch+0x25e>
 8000c42:	2000      	movs	r0, #0
 8000c44:	9000      	str	r0, [sp, #0]
 8000c46:	2300      	movs	r3, #0
 8000c48:	2204      	movs	r2, #4
 8000c4a:	7b20      	ldrb	r0, [r4, #12]
 8000c4c:	07c1      	lsls	r1, r0, #31
 8000c4e:	0fc9      	lsrs	r1, r1, #31
 8000c50:	2009      	movs	r0, #9
 8000c52:	68ff      	ldr	r7, [r7, #12]
 8000c54:	47b8      	blx	r7
 8000c56:	2104      	movs	r1, #4
 8000c58:	e748      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000c5a:	6860      	ldr	r0, [r4, #4]
 8000c5c:	7840      	ldrb	r0, [r0, #1]
 8000c5e:	0640      	lsls	r0, r0, #25
 8000c60:	0f40      	lsrs	r0, r0, #29
 8000c62:	2801      	cmp	r0, #1
 8000c64:	d00c      	beq.n	8000c80 <__iar_annotation$$branch+0x288>
 8000c66:	4668      	mov	r0, sp
 8000c68:	7900      	ldrb	r0, [r0, #4]
 8000c6a:	2803      	cmp	r0, #3
 8000c6c:	d108      	bne.n	8000c80 <__iar_annotation$$branch+0x288>
 8000c6e:	7b20      	ldrb	r0, [r4, #12]
 8000c70:	0700      	lsls	r0, r0, #28
 8000c72:	0f80      	lsrs	r0, r0, #30
 8000c74:	2803      	cmp	r0, #3
 8000c76:	d103      	bne.n	8000c80 <__iar_annotation$$branch+0x288>
 8000c78:	03a8      	lsls	r0, r5, #14
 8000c7a:	8470      	strh	r0, [r6, #34]	; 0x22
 8000c7c:	2500      	movs	r5, #0
 8000c7e:	e002      	b.n	8000c86 <__iar_annotation$$branch+0x28e>
 8000c80:	48a7      	ldr	r0, [pc, #668]	; (8000f20 <__iar_annotation$$branch+0x528>)
 8000c82:	8470      	strh	r0, [r6, #34]	; 0x22
 8000c84:	251e      	movs	r5, #30
 8000c86:	2000      	movs	r0, #0
 8000c88:	9000      	str	r0, [sp, #0]
 8000c8a:	230c      	movs	r3, #12
 8000c8c:	2203      	movs	r2, #3
 8000c8e:	2100      	movs	r1, #0
 8000c90:	0020      	movs	r0, r4
 8000c92:	f002 fd6e 	bl	8003772 <PE_Send_CtrlMessage>
 8000c96:	4fa1      	ldr	r7, [pc, #644]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000c98:	7838      	ldrb	r0, [r7, #0]
 8000c9a:	0780      	lsls	r0, r0, #30
 8000c9c:	d509      	bpl.n	8000cb2 <__iar_annotation$$branch+0x2ba>
 8000c9e:	2000      	movs	r0, #0
 8000ca0:	9000      	str	r0, [sp, #0]
 8000ca2:	2300      	movs	r3, #0
 8000ca4:	2201      	movs	r2, #1
 8000ca6:	7b20      	ldrb	r0, [r4, #12]
 8000ca8:	07c1      	lsls	r1, r0, #31
 8000caa:	0fc9      	lsrs	r1, r1, #31
 8000cac:	2009      	movs	r0, #9
 8000cae:	68ff      	ldr	r7, [r7, #12]
 8000cb0:	47b8      	blx	r7
 8000cb2:	2101      	movs	r1, #1
 8000cb4:	7b22      	ldrb	r2, [r4, #12]
 8000cb6:	07d0      	lsls	r0, r2, #31
 8000cb8:	0fc0      	lsrs	r0, r0, #31
 8000cba:	68a2      	ldr	r2, [r4, #8]
 8000cbc:	68d2      	ldr	r2, [r2, #12]
 8000cbe:	4790      	blx	r2
 8000cc0:	7b21      	ldrb	r1, [r4, #12]
 8000cc2:	20f3      	movs	r0, #243	; 0xf3
 8000cc4:	4008      	ands	r0, r1
 8000cc6:	4669      	mov	r1, sp
 8000cc8:	7909      	ldrb	r1, [r1, #4]
 8000cca:	0089      	lsls	r1, r1, #2
 8000ccc:	220c      	movs	r2, #12
 8000cce:	400a      	ands	r2, r1
 8000cd0:	4302      	orrs	r2, r0
 8000cd2:	7322      	strb	r2, [r4, #12]
 8000cd4:	e676      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000cd6:	2000      	movs	r0, #0
 8000cd8:	9000      	str	r0, [sp, #0]
 8000cda:	2303      	movs	r3, #3
 8000cdc:	220c      	movs	r2, #12
 8000cde:	2100      	movs	r1, #0
 8000ce0:	0020      	movs	r0, r4
 8000ce2:	f002 fd46 	bl	8003772 <PE_Send_CtrlMessage>
 8000ce6:	4f8d      	ldr	r7, [pc, #564]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000ce8:	7838      	ldrb	r0, [r7, #0]
 8000cea:	0780      	lsls	r0, r0, #30
 8000cec:	d509      	bpl.n	8000d02 <__iar_annotation$$branch+0x30a>
 8000cee:	2000      	movs	r0, #0
 8000cf0:	9000      	str	r0, [sp, #0]
 8000cf2:	2300      	movs	r3, #0
 8000cf4:	2203      	movs	r2, #3
 8000cf6:	7b20      	ldrb	r0, [r4, #12]
 8000cf8:	07c1      	lsls	r1, r0, #31
 8000cfa:	0fc9      	lsrs	r1, r1, #31
 8000cfc:	2009      	movs	r0, #9
 8000cfe:	68ff      	ldr	r7, [r7, #12]
 8000d00:	47b8      	blx	r7
 8000d02:	2103      	movs	r1, #3
 8000d04:	e6f2      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000d06:	2000      	movs	r0, #0
 8000d08:	9000      	str	r0, [sp, #0]
 8000d0a:	230e      	movs	r3, #14
 8000d0c:	2204      	movs	r2, #4
 8000d0e:	2100      	movs	r1, #0
 8000d10:	0020      	movs	r0, r4
 8000d12:	f002 fd2e 	bl	8003772 <PE_Send_CtrlMessage>
 8000d16:	4f81      	ldr	r7, [pc, #516]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000d18:	7838      	ldrb	r0, [r7, #0]
 8000d1a:	0780      	lsls	r0, r0, #30
 8000d1c:	d509      	bpl.n	8000d32 <__iar_annotation$$branch+0x33a>
 8000d1e:	2000      	movs	r0, #0
 8000d20:	9000      	str	r0, [sp, #0]
 8000d22:	2300      	movs	r3, #0
 8000d24:	2202      	movs	r2, #2
 8000d26:	7b20      	ldrb	r0, [r4, #12]
 8000d28:	07c1      	lsls	r1, r0, #31
 8000d2a:	0fc9      	lsrs	r1, r1, #31
 8000d2c:	2009      	movs	r0, #9
 8000d2e:	68ff      	ldr	r7, [r7, #12]
 8000d30:	47b8      	blx	r7
 8000d32:	2102      	movs	r1, #2
 8000d34:	e6da      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000d36:	8c71      	ldrh	r1, [r6, #34]	; 0x22
 8000d38:	03aa      	lsls	r2, r5, #14
 8000d3a:	4291      	cmp	r1, r2
 8000d3c:	d1ca      	bne.n	8000cd4 <__iar_annotation$$branch+0x2dc>
 8000d3e:	2100      	movs	r1, #0
 8000d40:	8471      	strh	r1, [r6, #34]	; 0x22
 8000d42:	6861      	ldr	r1, [r4, #4]
 8000d44:	784a      	ldrb	r2, [r1, #1]
 8000d46:	238f      	movs	r3, #143	; 0x8f
 8000d48:	4013      	ands	r3, r2
 8000d4a:	2240      	movs	r2, #64	; 0x40
 8000d4c:	431a      	orrs	r2, r3
 8000d4e:	704a      	strb	r2, [r1, #1]
 8000d50:	2800      	cmp	r0, #0
 8000d52:	d009      	beq.n	8000d68 <__iar_annotation$$branch+0x370>
 8000d54:	2000      	movs	r0, #0
 8000d56:	9000      	str	r0, [sp, #0]
 8000d58:	2300      	movs	r3, #0
 8000d5a:	2256      	movs	r2, #86	; 0x56
 8000d5c:	7b20      	ldrb	r0, [r4, #12]
 8000d5e:	07c1      	lsls	r1, r0, #31
 8000d60:	0fc9      	lsrs	r1, r1, #31
 8000d62:	2009      	movs	r0, #9
 8000d64:	9f01      	ldr	r7, [sp, #4]
 8000d66:	47b8      	blx	r7
 8000d68:	2701      	movs	r7, #1
 8000d6a:	2156      	movs	r1, #86	; 0x56
 8000d6c:	68e2      	ldr	r2, [r4, #12]
 8000d6e:	2001      	movs	r0, #1
 8000d70:	4010      	ands	r0, r2
 8000d72:	68a2      	ldr	r2, [r4, #8]
 8000d74:	68d2      	ldr	r2, [r2, #12]
 8000d76:	4790      	blx	r2
 8000d78:	68a0      	ldr	r0, [r4, #8]
 8000d7a:	6801      	ldr	r1, [r0, #0]
 8000d7c:	2900      	cmp	r1, #0
 8000d7e:	d007      	beq.n	8000d90 <__iar_annotation$$branch+0x398>
 8000d80:	68e0      	ldr	r0, [r4, #12]
 8000d82:	4007      	ands	r7, r0
 8000d84:	0038      	movs	r0, r7
 8000d86:	4788      	blx	r1
 8000d88:	2800      	cmp	r0, #0
 8000d8a:	d001      	beq.n	8000d90 <__iar_annotation$$branch+0x398>
 8000d8c:	200f      	movs	r0, #15
 8000d8e:	7230      	strb	r0, [r6, #8]
 8000d90:	200d      	movs	r0, #13
 8000d92:	e595      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000d94:	2000      	movs	r0, #0
 8000d96:	9000      	str	r0, [sp, #0]
 8000d98:	2303      	movs	r3, #3
 8000d9a:	2206      	movs	r2, #6
 8000d9c:	2100      	movs	r1, #0
 8000d9e:	0020      	movs	r0, r4
 8000da0:	f002 fce7 	bl	8003772 <PE_Send_CtrlMessage>
 8000da4:	2800      	cmp	r0, #0
 8000da6:	d12e      	bne.n	8000e06 <__iar_annotation$$branch+0x40e>
 8000da8:	6860      	ldr	r0, [r4, #4]
 8000daa:	7841      	ldrb	r1, [r0, #1]
 8000dac:	228f      	movs	r2, #143	; 0x8f
 8000dae:	400a      	ands	r2, r1
 8000db0:	2130      	movs	r1, #48	; 0x30
 8000db2:	4311      	orrs	r1, r2
 8000db4:	7041      	strb	r1, [r0, #1]
 8000db6:	4859      	ldr	r0, [pc, #356]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000db8:	7800      	ldrb	r0, [r0, #0]
 8000dba:	0780      	lsls	r0, r0, #30
 8000dbc:	d50a      	bpl.n	8000dd4 <__iar_annotation$$branch+0x3dc>
 8000dbe:	2000      	movs	r0, #0
 8000dc0:	9000      	str	r0, [sp, #0]
 8000dc2:	2300      	movs	r3, #0
 8000dc4:	2256      	movs	r2, #86	; 0x56
 8000dc6:	7b20      	ldrb	r0, [r4, #12]
 8000dc8:	07c1      	lsls	r1, r0, #31
 8000dca:	0fc9      	lsrs	r1, r1, #31
 8000dcc:	2009      	movs	r0, #9
 8000dce:	4f53      	ldr	r7, [pc, #332]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000dd0:	68ff      	ldr	r7, [r7, #12]
 8000dd2:	47b8      	blx	r7
 8000dd4:	2156      	movs	r1, #86	; 0x56
 8000dd6:	7b22      	ldrb	r2, [r4, #12]
 8000dd8:	07d0      	lsls	r0, r2, #31
 8000dda:	0fc0      	lsrs	r0, r0, #31
 8000ddc:	68a2      	ldr	r2, [r4, #8]
 8000dde:	68d2      	ldr	r2, [r2, #12]
 8000de0:	4790      	blx	r2
 8000de2:	4f4e      	ldr	r7, [pc, #312]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000de4:	7838      	ldrb	r0, [r7, #0]
 8000de6:	0780      	lsls	r0, r0, #30
 8000de8:	d509      	bpl.n	8000dfe <__iar_annotation$$branch+0x406>
 8000dea:	2000      	movs	r0, #0
 8000dec:	9000      	str	r0, [sp, #0]
 8000dee:	2300      	movs	r3, #0
 8000df0:	2210      	movs	r2, #16
 8000df2:	7b20      	ldrb	r0, [r4, #12]
 8000df4:	07c1      	lsls	r1, r0, #31
 8000df6:	0fc9      	lsrs	r1, r1, #31
 8000df8:	2009      	movs	r0, #9
 8000dfa:	68ff      	ldr	r7, [r7, #12]
 8000dfc:	47b8      	blx	r7
 8000dfe:	2110      	movs	r1, #16
 8000e00:	e674      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000e02:	2500      	movs	r5, #0
 8000e04:	43ed      	mvns	r5, r5
 8000e06:	e5dd      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000e08:	6860      	ldr	r0, [r4, #4]
 8000e0a:	7840      	ldrb	r0, [r0, #1]
 8000e0c:	0640      	lsls	r0, r0, #25
 8000e0e:	0f40      	lsrs	r0, r0, #29
 8000e10:	2803      	cmp	r0, #3
 8000e12:	d001      	beq.n	8000e18 <__iar_annotation$$branch+0x420>
 8000e14:	200e      	movs	r0, #14
 8000e16:	e553      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000e18:	7a30      	ldrb	r0, [r6, #8]
 8000e1a:	280a      	cmp	r0, #10
 8000e1c:	d007      	beq.n	8000e2e <__iar_annotation$$branch+0x436>
 8000e1e:	7b21      	ldrb	r1, [r4, #12]
 8000e20:	07c8      	lsls	r0, r1, #31
 8000e22:	0fc0      	lsrs	r0, r0, #31
 8000e24:	68a1      	ldr	r1, [r4, #8]
 8000e26:	6909      	ldr	r1, [r1, #16]
 8000e28:	4788      	blx	r1
 8000e2a:	2800      	cmp	r0, #0
 8000e2c:	d101      	bne.n	8000e32 <__iar_annotation$$branch+0x43a>
 8000e2e:	2003      	movs	r0, #3
 8000e30:	e546      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000e32:	200f      	movs	r0, #15
 8000e34:	e544      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000e36:	2001      	movs	r0, #1
 8000e38:	9000      	str	r0, [sp, #0]
 8000e3a:	2397      	movs	r3, #151	; 0x97
 8000e3c:	2202      	movs	r2, #2
 8000e3e:	2100      	movs	r1, #0
 8000e40:	0020      	movs	r0, r4
 8000e42:	f002 fc96 	bl	8003772 <PE_Send_CtrlMessage>
 8000e46:	2800      	cmp	r0, #0
 8000e48:	d11a      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000e4a:	2002      	movs	r0, #2
 8000e4c:	82e0      	strh	r0, [r4, #22]
 8000e4e:	2501      	movs	r5, #1
 8000e50:	4f32      	ldr	r7, [pc, #200]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000e52:	7839      	ldrb	r1, [r7, #0]
 8000e54:	4201      	tst	r1, r0
 8000e56:	d009      	beq.n	8000e6c <__iar_annotation$$branch+0x474>
 8000e58:	2000      	movs	r0, #0
 8000e5a:	9000      	str	r0, [sp, #0]
 8000e5c:	2300      	movs	r3, #0
 8000e5e:	2227      	movs	r2, #39	; 0x27
 8000e60:	68e0      	ldr	r0, [r4, #12]
 8000e62:	2101      	movs	r1, #1
 8000e64:	4001      	ands	r1, r0
 8000e66:	2009      	movs	r0, #9
 8000e68:	68ff      	ldr	r7, [r7, #12]
 8000e6a:	47b8      	blx	r7
 8000e6c:	2127      	movs	r1, #39	; 0x27
 8000e6e:	68e0      	ldr	r0, [r4, #12]
 8000e70:	4005      	ands	r5, r0
 8000e72:	0028      	movs	r0, r5
 8000e74:	68a2      	ldr	r2, [r4, #8]
 8000e76:	68d2      	ldr	r2, [r2, #12]
 8000e78:	4790      	blx	r2
 8000e7a:	48bc      	ldr	r0, [pc, #752]	; (800116c <__iar_annotation$$branch+0x774>)
 8000e7c:	8470      	strh	r0, [r6, #34]	; 0x22
 8000e7e:	4dbc      	ldr	r5, [pc, #752]	; (8001170 <__iar_annotation$$branch+0x778>)
 8000e80:	e5a0      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000e82:	8c71      	ldrh	r1, [r6, #34]	; 0x22
 8000e84:	03aa      	lsls	r2, r5, #14
 8000e86:	4291      	cmp	r1, r2
 8000e88:	d1fa      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000e8a:	2800      	cmp	r0, #0
 8000e8c:	d009      	beq.n	8000ea2 <__iar_annotation$$branch+0x4aa>
 8000e8e:	2000      	movs	r0, #0
 8000e90:	9000      	str	r0, [sp, #0]
 8000e92:	2300      	movs	r3, #0
 8000e94:	2228      	movs	r2, #40	; 0x28
 8000e96:	7b20      	ldrb	r0, [r4, #12]
 8000e98:	07c1      	lsls	r1, r0, #31
 8000e9a:	0fc9      	lsrs	r1, r1, #31
 8000e9c:	2009      	movs	r0, #9
 8000e9e:	9f01      	ldr	r7, [sp, #4]
 8000ea0:	47b8      	blx	r7
 8000ea2:	2128      	movs	r1, #40	; 0x28
 8000ea4:	7b22      	ldrb	r2, [r4, #12]
 8000ea6:	07d0      	lsls	r0, r2, #31
 8000ea8:	0fc0      	lsrs	r0, r0, #31
 8000eaa:	68a2      	ldr	r2, [r4, #8]
 8000eac:	68d2      	ldr	r2, [r2, #12]
 8000eae:	4790      	blx	r2
 8000eb0:	2000      	movs	r0, #0
 8000eb2:	9000      	str	r0, [sp, #0]
 8000eb4:	2303      	movs	r3, #3
 8000eb6:	2206      	movs	r2, #6
 8000eb8:	2100      	movs	r1, #0
 8000eba:	0020      	movs	r0, r4
 8000ebc:	f002 fc59 	bl	8003772 <PE_Send_CtrlMessage>
 8000ec0:	2800      	cmp	r0, #0
 8000ec2:	d1dd      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000ec4:	4f15      	ldr	r7, [pc, #84]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000ec6:	7838      	ldrb	r0, [r7, #0]
 8000ec8:	0780      	lsls	r0, r0, #30
 8000eca:	d509      	bpl.n	8000ee0 <__iar_annotation$$branch+0x4e8>
 8000ecc:	2000      	movs	r0, #0
 8000ece:	9000      	str	r0, [sp, #0]
 8000ed0:	2300      	movs	r3, #0
 8000ed2:	222c      	movs	r2, #44	; 0x2c
 8000ed4:	7b20      	ldrb	r0, [r4, #12]
 8000ed6:	07c1      	lsls	r1, r0, #31
 8000ed8:	0fc9      	lsrs	r1, r1, #31
 8000eda:	2009      	movs	r0, #9
 8000edc:	68ff      	ldr	r7, [r7, #12]
 8000ede:	47b8      	blx	r7
 8000ee0:	212c      	movs	r1, #44	; 0x2c
 8000ee2:	e603      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000ee4:	0020      	movs	r0, r4
 8000ee6:	f002 fd2a 	bl	800393e <PE_PerformSoftReset>
 8000eea:	2000      	movs	r0, #0
 8000eec:	9000      	str	r0, [sp, #0]
 8000eee:	2307      	movs	r3, #7
 8000ef0:	2203      	movs	r2, #3
 8000ef2:	2100      	movs	r1, #0
 8000ef4:	0020      	movs	r0, r4
 8000ef6:	f002 fc3c 	bl	8003772 <PE_Send_CtrlMessage>
 8000efa:	4f08      	ldr	r7, [pc, #32]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000efc:	7838      	ldrb	r0, [r7, #0]
 8000efe:	0780      	lsls	r0, r0, #30
 8000f00:	d509      	bpl.n	8000f16 <__iar_annotation$$branch+0x51e>
 8000f02:	2000      	movs	r0, #0
 8000f04:	9000      	str	r0, [sp, #0]
 8000f06:	2300      	movs	r3, #0
 8000f08:	222f      	movs	r2, #47	; 0x2f
 8000f0a:	7b20      	ldrb	r0, [r4, #12]
 8000f0c:	07c1      	lsls	r1, r0, #31
 8000f0e:	0fc9      	lsrs	r1, r1, #31
 8000f10:	2009      	movs	r0, #9
 8000f12:	68ff      	ldr	r7, [r7, #12]
 8000f14:	47b8      	blx	r7
 8000f16:	212f      	movs	r1, #47	; 0x2f
 8000f18:	e5e8      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000f1a:	bf00      	nop
 8000f1c:	200019a8 	.word	0x200019a8
 8000f20:	0000801e 	.word	0x0000801e
 8000f24:	2000      	movs	r0, #0
 8000f26:	9000      	str	r0, [sp, #0]
 8000f28:	2312      	movs	r3, #18
 8000f2a:	220d      	movs	r2, #13
 8000f2c:	2100      	movs	r1, #0
 8000f2e:	0020      	movs	r0, r4
 8000f30:	f002 fc1f 	bl	8003772 <PE_Send_CtrlMessage>
 8000f34:	2800      	cmp	r0, #0
 8000f36:	d1a3      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000f38:	488e      	ldr	r0, [pc, #568]	; (8001174 <__iar_annotation$$branch+0x77c>)
 8000f3a:	83b0      	strh	r0, [r6, #28]
 8000f3c:	251a      	movs	r5, #26
 8000f3e:	4f8e      	ldr	r7, [pc, #568]	; (8001178 <__iar_annotation$$branch+0x780>)
 8000f40:	7838      	ldrb	r0, [r7, #0]
 8000f42:	0780      	lsls	r0, r0, #30
 8000f44:	d509      	bpl.n	8000f5a <__iar_annotation$$branch+0x562>
 8000f46:	2000      	movs	r0, #0
 8000f48:	9000      	str	r0, [sp, #0]
 8000f4a:	2300      	movs	r3, #0
 8000f4c:	222e      	movs	r2, #46	; 0x2e
 8000f4e:	7b20      	ldrb	r0, [r4, #12]
 8000f50:	07c1      	lsls	r1, r0, #31
 8000f52:	0fc9      	lsrs	r1, r1, #31
 8000f54:	2009      	movs	r0, #9
 8000f56:	68ff      	ldr	r7, [r7, #12]
 8000f58:	47b8      	blx	r7
 8000f5a:	212e      	movs	r1, #46	; 0x2e
 8000f5c:	e5c6      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000f5e:	2911      	cmp	r1, #17
 8000f60:	d124      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f62:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000f64:	0bc9      	lsrs	r1, r1, #15
 8000f66:	d121      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f68:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000f6a:	0b09      	lsrs	r1, r1, #12
 8000f6c:	0749      	lsls	r1, r1, #29
 8000f6e:	d11d      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f70:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000f72:	06c9      	lsls	r1, r1, #27
 8000f74:	0ec9      	lsrs	r1, r1, #27
 8000f76:	2903      	cmp	r1, #3
 8000f78:	d118      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f7a:	2100      	movs	r1, #0
 8000f7c:	83b1      	strh	r1, [r6, #28]
 8000f7e:	2800      	cmp	r0, #0
 8000f80:	d008      	beq.n	8000f94 <__iar_annotation$$branch+0x59c>
 8000f82:	9100      	str	r1, [sp, #0]
 8000f84:	2300      	movs	r3, #0
 8000f86:	222f      	movs	r2, #47	; 0x2f
 8000f88:	7b20      	ldrb	r0, [r4, #12]
 8000f8a:	07c1      	lsls	r1, r0, #31
 8000f8c:	0fc9      	lsrs	r1, r1, #31
 8000f8e:	2009      	movs	r0, #9
 8000f90:	9f01      	ldr	r7, [sp, #4]
 8000f92:	47b8      	blx	r7
 8000f94:	212f      	movs	r1, #47	; 0x2f
 8000f96:	7b22      	ldrb	r2, [r4, #12]
 8000f98:	07d0      	lsls	r0, r2, #31
 8000f9a:	0fc0      	lsrs	r0, r0, #31
 8000f9c:	68a2      	ldr	r2, [r4, #8]
 8000f9e:	68d2      	ldr	r2, [r2, #12]
 8000fa0:	4790      	blx	r2
 8000fa2:	2007      	movs	r0, #7
 8000fa4:	7230      	strb	r0, [r6, #8]
 8000fa6:	2014      	movs	r0, #20
 8000fa8:	4669      	mov	r1, sp
 8000faa:	7308      	strb	r0, [r1, #12]
 8000fac:	8bb0      	ldrh	r0, [r6, #28]
 8000fae:	03a9      	lsls	r1, r5, #14
 8000fb0:	4288      	cmp	r0, r1
 8000fb2:	d000      	beq.n	8000fb6 <__iar_annotation$$branch+0x5be>
 8000fb4:	e506      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000fb6:	2000      	movs	r0, #0
 8000fb8:	83b0      	strh	r0, [r6, #28]
 8000fba:	e73a      	b.n	8000e32 <__iar_annotation$$branch+0x43a>
 8000fbc:	7b60      	ldrb	r0, [r4, #13]
 8000fbe:	21fc      	movs	r1, #252	; 0xfc
 8000fc0:	4001      	ands	r1, r0
 8000fc2:	7361      	strb	r1, [r4, #13]
 8000fc4:	0020      	movs	r0, r4
 8000fc6:	f002 fc81 	bl	80038cc <PE_Send_HARDRESET>
 8000fca:	68a0      	ldr	r0, [r4, #8]
 8000fcc:	6843      	ldr	r3, [r0, #4]
 8000fce:	2b00      	cmp	r3, #0
 8000fd0:	d005      	beq.n	8000fde <__iar_annotation$$branch+0x5e6>
 8000fd2:	2202      	movs	r2, #2
 8000fd4:	2101      	movs	r1, #1
 8000fd6:	7b25      	ldrb	r5, [r4, #12]
 8000fd8:	07e8      	lsls	r0, r5, #31
 8000fda:	0fc0      	lsrs	r0, r0, #31
 8000fdc:	4798      	blx	r3
 8000fde:	4867      	ldr	r0, [pc, #412]	; (800117c <__iar_annotation$$branch+0x784>)
 8000fe0:	82f0      	strh	r0, [r6, #22]
 8000fe2:	251b      	movs	r5, #27
 8000fe4:	7d20      	ldrb	r0, [r4, #20]
 8000fe6:	1c40      	adds	r0, r0, #1
 8000fe8:	7520      	strb	r0, [r4, #20]
 8000fea:	6860      	ldr	r0, [r4, #4]
 8000fec:	6801      	ldr	r1, [r0, #0]
 8000fee:	2210      	movs	r2, #16
 8000ff0:	4391      	bics	r1, r2
 8000ff2:	6001      	str	r1, [r0, #0]
 8000ff4:	2000      	movs	r0, #0
 8000ff6:	7130      	strb	r0, [r6, #4]
 8000ff8:	2015      	movs	r0, #21
 8000ffa:	e461      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000ffc:	495f      	ldr	r1, [pc, #380]	; (800117c <__iar_annotation$$branch+0x784>)
 8000ffe:	82f1      	strh	r1, [r6, #22]
 8001000:	251b      	movs	r5, #27
 8001002:	2115      	movs	r1, #21
 8001004:	7231      	strb	r1, [r6, #8]
 8001006:	2800      	cmp	r0, #0
 8001008:	d009      	beq.n	800101e <__iar_annotation$$branch+0x626>
 800100a:	2000      	movs	r0, #0
 800100c:	9000      	str	r0, [sp, #0]
 800100e:	2300      	movs	r3, #0
 8001010:	221d      	movs	r2, #29
 8001012:	7b20      	ldrb	r0, [r4, #12]
 8001014:	07c1      	lsls	r1, r0, #31
 8001016:	0fc9      	lsrs	r1, r1, #31
 8001018:	2009      	movs	r0, #9
 800101a:	9f01      	ldr	r7, [sp, #4]
 800101c:	47b8      	blx	r7
 800101e:	211d      	movs	r1, #29
 8001020:	e564      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8001022:	8af0      	ldrh	r0, [r6, #22]
 8001024:	03a9      	lsls	r1, r5, #14
 8001026:	4288      	cmp	r0, r1
 8001028:	d150      	bne.n	80010cc <__iar_annotation$$branch+0x6d4>
 800102a:	2000      	movs	r0, #0
 800102c:	82f0      	strh	r0, [r6, #22]
 800102e:	7d21      	ldrb	r1, [r4, #20]
 8001030:	2903      	cmp	r1, #3
 8001032:	d311      	bcc.n	8001058 <__iar_annotation$$branch+0x660>
 8001034:	7520      	strb	r0, [r4, #20]
 8001036:	7230      	strb	r0, [r6, #8]
 8001038:	4f4f      	ldr	r7, [pc, #316]	; (8001178 <__iar_annotation$$branch+0x780>)
 800103a:	7838      	ldrb	r0, [r7, #0]
 800103c:	0780      	lsls	r0, r0, #30
 800103e:	d509      	bpl.n	8001054 <__iar_annotation$$branch+0x65c>
 8001040:	2000      	movs	r0, #0
 8001042:	9000      	str	r0, [sp, #0]
 8001044:	2300      	movs	r3, #0
 8001046:	2220      	movs	r2, #32
 8001048:	7b20      	ldrb	r0, [r4, #12]
 800104a:	07c1      	lsls	r1, r0, #31
 800104c:	0fc9      	lsrs	r1, r1, #31
 800104e:	2009      	movs	r0, #9
 8001050:	68ff      	ldr	r7, [r7, #12]
 8001052:	47b8      	blx	r7
 8001054:	2120      	movs	r1, #32
 8001056:	e549      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8001058:	68a0      	ldr	r0, [r4, #8]
 800105a:	6843      	ldr	r3, [r0, #4]
 800105c:	2b00      	cmp	r3, #0
 800105e:	d00a      	beq.n	8001076 <__iar_annotation$$branch+0x67e>
 8001060:	7b60      	ldrb	r0, [r4, #13]
 8001062:	0780      	lsls	r0, r0, #30
 8001064:	0f80      	lsrs	r0, r0, #30
 8001066:	1e42      	subs	r2, r0, #1
 8001068:	4192      	sbcs	r2, r2
 800106a:	0fd2      	lsrs	r2, r2, #31
 800106c:	2101      	movs	r1, #1
 800106e:	7b25      	ldrb	r5, [r4, #12]
 8001070:	07e8      	lsls	r0, r5, #31
 8001072:	0fc0      	lsrs	r0, r0, #31
 8001074:	4798      	blx	r3
 8001076:	4842      	ldr	r0, [pc, #264]	; (8001180 <__iar_annotation$$branch+0x788>)
 8001078:	9904      	ldr	r1, [sp, #16]
 800107a:	8008      	strh	r0, [r1, #0]
 800107c:	25c8      	movs	r5, #200	; 0xc8
 800107e:	00ad      	lsls	r5, r5, #2
 8001080:	2013      	movs	r0, #19
 8001082:	e41d      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8001084:	68a0      	ldr	r0, [r4, #8]
 8001086:	6843      	ldr	r3, [r0, #4]
 8001088:	2701      	movs	r7, #1
 800108a:	2b00      	cmp	r3, #0
 800108c:	d005      	beq.n	800109a <__iar_annotation$$branch+0x6a2>
 800108e:	2204      	movs	r2, #4
 8001090:	68e1      	ldr	r1, [r4, #12]
 8001092:	2001      	movs	r0, #1
 8001094:	4008      	ands	r0, r1
 8001096:	2101      	movs	r1, #1
 8001098:	4798      	blx	r3
 800109a:	8ab0      	ldrh	r0, [r6, #20]
 800109c:	03a9      	lsls	r1, r5, #14
 800109e:	4288      	cmp	r0, r1
 80010a0:	d114      	bne.n	80010cc <__iar_annotation$$branch+0x6d4>
 80010a2:	2000      	movs	r0, #0
 80010a4:	9904      	ldr	r1, [sp, #16]
 80010a6:	8008      	strh	r0, [r1, #0]
 80010a8:	68a0      	ldr	r0, [r4, #8]
 80010aa:	6843      	ldr	r3, [r0, #4]
 80010ac:	2b00      	cmp	r3, #0
 80010ae:	d005      	beq.n	80010bc <__iar_annotation$$branch+0x6c4>
 80010b0:	2205      	movs	r2, #5
 80010b2:	2101      	movs	r1, #1
 80010b4:	68e0      	ldr	r0, [r4, #12]
 80010b6:	4007      	ands	r7, r0
 80010b8:	0038      	movs	r0, r7
 80010ba:	4798      	blx	r3
 80010bc:	4831      	ldr	r0, [pc, #196]	; (8001184 <__iar_annotation$$branch+0x78c>)
 80010be:	83f0      	strh	r0, [r6, #30]
 80010c0:	2101      	movs	r1, #1
 80010c2:	a80a      	add	r0, sp, #40	; 0x28
 80010c4:	7800      	ldrb	r0, [r0, #0]
 80010c6:	f003 f862 	bl	800418e <PE_Reset>
 80010ca:	7235      	strb	r5, [r6, #8]
 80010cc:	e47a      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80010ce:	2011      	movs	r0, #17
 80010d0:	82e0      	strh	r0, [r4, #22]
 80010d2:	2105      	movs	r1, #5
 80010d4:	7b22      	ldrb	r2, [r4, #12]
 80010d6:	07d0      	lsls	r0, r2, #31
 80010d8:	0fc0      	lsrs	r0, r0, #31
 80010da:	f004 f9aa 	bl	8005432 <USBDPD_PRL_BistCarrierEyeMode>
 80010de:	2028      	movs	r0, #40	; 0x28
 80010e0:	7230      	strb	r0, [r6, #8]
 80010e2:	4829      	ldr	r0, [pc, #164]	; (8001188 <__iar_annotation$$branch+0x790>)
 80010e4:	85b0      	strh	r0, [r6, #44]	; 0x2c
 80010e6:	253a      	movs	r5, #58	; 0x3a
 80010e8:	e46c      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80010ea:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 80010ec:	03a9      	lsls	r1, r5, #14
 80010ee:	4288      	cmp	r0, r1
 80010f0:	d1fa      	bne.n	80010e8 <__iar_annotation$$branch+0x6f0>
 80010f2:	2105      	movs	r1, #5
 80010f4:	7b22      	ldrb	r2, [r4, #12]
 80010f6:	07d0      	lsls	r0, r2, #31
 80010f8:	0fc0      	lsrs	r0, r0, #31
 80010fa:	f004 f9a2 	bl	8005442 <USBDPD_PRL_BistCarrierEyeModeExit>
 80010fe:	2000      	movs	r0, #0
 8001100:	85b0      	strh	r0, [r6, #44]	; 0x2c
 8001102:	e694      	b.n	8000e2e <__iar_annotation$$branch+0x436>
 8001104:	2911      	cmp	r1, #17
 8001106:	d10e      	bne.n	8001126 <__iar_annotation$$branch+0x72e>
 8001108:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800110a:	0bc0      	lsrs	r0, r0, #15
 800110c:	d10b      	bne.n	8001126 <__iar_annotation$$branch+0x72e>
 800110e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001110:	0b00      	lsrs	r0, r0, #12
 8001112:	0740      	lsls	r0, r0, #29
 8001114:	d007      	beq.n	8001126 <__iar_annotation$$branch+0x72e>
 8001116:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001118:	06c0      	lsls	r0, r0, #27
 800111a:	0ec0      	lsrs	r0, r0, #27
 800111c:	2803      	cmp	r0, #3
 800111e:	d102      	bne.n	8001126 <__iar_annotation$$branch+0x72e>
 8001120:	2014      	movs	r0, #20
 8001122:	4669      	mov	r1, sp
 8001124:	7308      	strb	r0, [r1, #12]
 8001126:	2011      	movs	r0, #17
 8001128:	82e0      	strh	r0, [r4, #22]
 800112a:	e44b      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 800112c:	2000      	movs	r0, #0
 800112e:	9000      	str	r0, [sp, #0]
 8001130:	2319      	movs	r3, #25
 8001132:	2208      	movs	r2, #8
 8001134:	2100      	movs	r1, #0
 8001136:	0020      	movs	r0, r4
 8001138:	f002 fb1b 	bl	8003772 <PE_Send_CtrlMessage>
 800113c:	2800      	cmp	r0, #0
 800113e:	d1f4      	bne.n	800112a <__iar_annotation$$branch+0x732>
 8001140:	2007      	movs	r0, #7
 8001142:	82e0      	strh	r0, [r4, #22]
 8001144:	480b      	ldr	r0, [pc, #44]	; (8001174 <__iar_annotation$$branch+0x77c>)
 8001146:	83b0      	strh	r0, [r6, #28]
 8001148:	251a      	movs	r5, #26
 800114a:	4f0b      	ldr	r7, [pc, #44]	; (8001178 <__iar_annotation$$branch+0x780>)
 800114c:	7838      	ldrb	r0, [r7, #0]
 800114e:	0780      	lsls	r0, r0, #30
 8001150:	d509      	bpl.n	8001166 <__iar_annotation$$branch+0x76e>
 8001152:	2000      	movs	r0, #0
 8001154:	9000      	str	r0, [sp, #0]
 8001156:	2300      	movs	r3, #0
 8001158:	2205      	movs	r2, #5
 800115a:	7b20      	ldrb	r0, [r4, #12]
 800115c:	07c1      	lsls	r1, r0, #31
 800115e:	0fc9      	lsrs	r1, r1, #31
 8001160:	2009      	movs	r0, #9
 8001162:	68ff      	ldr	r7, [r7, #12]
 8001164:	47b8      	blx	r7
 8001166:	2105      	movs	r1, #5
 8001168:	e4c0      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 800116a:	bf00      	nop
 800116c:	00008226 	.word	0x00008226
 8001170:	00000226 	.word	0x00000226
 8001174:	0000801a 	.word	0x0000801a
 8001178:	200019a8 	.word	0x200019a8
 800117c:	0000801b 	.word	0x0000801b
 8001180:	00008320 	.word	0x00008320
 8001184:	0000957c 	.word	0x0000957c
 8001188:	0000803a 	.word	0x0000803a
 800118c:	2911      	cmp	r1, #17
 800118e:	d15e      	bne.n	800124e <__iar_annotation$$branch+0x856>
 8001190:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001192:	0bc0      	lsrs	r0, r0, #15
 8001194:	d133      	bne.n	80011fe <__iar_annotation$$branch+0x806>
 8001196:	2007      	movs	r0, #7
 8001198:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800119a:	0b09      	lsrs	r1, r1, #12
 800119c:	4201      	tst	r1, r0
 800119e:	d02e      	beq.n	80011fe <__iar_annotation$$branch+0x806>
 80011a0:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80011a2:	06c9      	lsls	r1, r1, #27
 80011a4:	0ec9      	lsrs	r1, r1, #27
 80011a6:	2904      	cmp	r1, #4
 80011a8:	d129      	bne.n	80011fe <__iar_annotation$$branch+0x806>
 80011aa:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80011ac:	0b09      	lsrs	r1, r1, #12
 80011ae:	4008      	ands	r0, r1
 80011b0:	0083      	lsls	r3, r0, #2
 80011b2:	209e      	movs	r0, #158	; 0x9e
 80011b4:	0040      	lsls	r0, r0, #1
 80011b6:	1822      	adds	r2, r4, r0
 80011b8:	2105      	movs	r1, #5
 80011ba:	7b27      	ldrb	r7, [r4, #12]
 80011bc:	07f8      	lsls	r0, r7, #31
 80011be:	0fc0      	lsrs	r0, r0, #31
 80011c0:	68a7      	ldr	r7, [r4, #8]
 80011c2:	69ff      	ldr	r7, [r7, #28]
 80011c4:	47b8      	blx	r7
 80011c6:	2000      	movs	r0, #0
 80011c8:	83b0      	strh	r0, [r6, #28]
 80011ca:	2003      	movs	r0, #3
 80011cc:	7230      	strb	r0, [r6, #8]
 80011ce:	2014      	movs	r0, #20
 80011d0:	4669      	mov	r1, sp
 80011d2:	7308      	strb	r0, [r1, #12]
 80011d4:	4fd0      	ldr	r7, [pc, #832]	; (8001518 <__iar_annotation$$branch+0xb20>)
 80011d6:	7838      	ldrb	r0, [r7, #0]
 80011d8:	0780      	lsls	r0, r0, #30
 80011da:	d509      	bpl.n	80011f0 <__iar_annotation$$branch+0x7f8>
 80011dc:	2000      	movs	r0, #0
 80011de:	9000      	str	r0, [sp, #0]
 80011e0:	2300      	movs	r3, #0
 80011e2:	2207      	movs	r2, #7
 80011e4:	7b20      	ldrb	r0, [r4, #12]
 80011e6:	07c1      	lsls	r1, r0, #31
 80011e8:	0fc9      	lsrs	r1, r1, #31
 80011ea:	2009      	movs	r0, #9
 80011ec:	68ff      	ldr	r7, [r7, #12]
 80011ee:	47b8      	blx	r7
 80011f0:	2107      	movs	r1, #7
 80011f2:	7b22      	ldrb	r2, [r4, #12]
 80011f4:	07d0      	lsls	r0, r2, #31
 80011f6:	0fc0      	lsrs	r0, r0, #31
 80011f8:	68a2      	ldr	r2, [r4, #8]
 80011fa:	68d2      	ldr	r2, [r2, #12]
 80011fc:	4790      	blx	r2
 80011fe:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001200:	0bc0      	lsrs	r0, r0, #15
 8001202:	d124      	bne.n	800124e <__iar_annotation$$branch+0x856>
 8001204:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001206:	0b00      	lsrs	r0, r0, #12
 8001208:	0740      	lsls	r0, r0, #29
 800120a:	d120      	bne.n	800124e <__iar_annotation$$branch+0x856>
 800120c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800120e:	06c0      	lsls	r0, r0, #27
 8001210:	0ec0      	lsrs	r0, r0, #27
 8001212:	2804      	cmp	r0, #4
 8001214:	d11b      	bne.n	800124e <__iar_annotation$$branch+0x856>
 8001216:	2000      	movs	r0, #0
 8001218:	83b0      	strh	r0, [r6, #28]
 800121a:	2003      	movs	r0, #3
 800121c:	7230      	strb	r0, [r6, #8]
 800121e:	2014      	movs	r0, #20
 8001220:	4669      	mov	r1, sp
 8001222:	7308      	strb	r0, [r1, #12]
 8001224:	4fbc      	ldr	r7, [pc, #752]	; (8001518 <__iar_annotation$$branch+0xb20>)
 8001226:	7838      	ldrb	r0, [r7, #0]
 8001228:	0780      	lsls	r0, r0, #30
 800122a:	d509      	bpl.n	8001240 <__iar_annotation$$branch+0x848>
 800122c:	2000      	movs	r0, #0
 800122e:	9000      	str	r0, [sp, #0]
 8001230:	2300      	movs	r3, #0
 8001232:	2208      	movs	r2, #8
 8001234:	7b20      	ldrb	r0, [r4, #12]
 8001236:	07c1      	lsls	r1, r0, #31
 8001238:	0fc9      	lsrs	r1, r1, #31
 800123a:	2009      	movs	r0, #9
 800123c:	68ff      	ldr	r7, [r7, #12]
 800123e:	47b8      	blx	r7
 8001240:	2108      	movs	r1, #8
 8001242:	7b22      	ldrb	r2, [r4, #12]
 8001244:	07d0      	lsls	r0, r2, #31
 8001246:	0fc0      	lsrs	r0, r0, #31
 8001248:	68a2      	ldr	r2, [r4, #8]
 800124a:	68d2      	ldr	r2, [r2, #12]
 800124c:	4790      	blx	r2
 800124e:	8bb0      	ldrh	r0, [r6, #28]
 8001250:	03a9      	lsls	r1, r5, #14
 8001252:	4288      	cmp	r0, r1
 8001254:	d11e      	bne.n	8001294 <__iar_annotation$$branch+0x89c>
 8001256:	4fb0      	ldr	r7, [pc, #704]	; (8001518 <__iar_annotation$$branch+0xb20>)
 8001258:	7838      	ldrb	r0, [r7, #0]
 800125a:	0780      	lsls	r0, r0, #30
 800125c:	d509      	bpl.n	8001272 <__iar_annotation$$branch+0x87a>
 800125e:	2000      	movs	r0, #0
 8001260:	9000      	str	r0, [sp, #0]
 8001262:	2300      	movs	r3, #0
 8001264:	2209      	movs	r2, #9
 8001266:	7b20      	ldrb	r0, [r4, #12]
 8001268:	07c1      	lsls	r1, r0, #31
 800126a:	0fc9      	lsrs	r1, r1, #31
 800126c:	2009      	movs	r0, #9
 800126e:	68ff      	ldr	r7, [r7, #12]
 8001270:	47b8      	blx	r7
 8001272:	2109      	movs	r1, #9
 8001274:	7b22      	ldrb	r2, [r4, #12]
 8001276:	07d0      	lsls	r0, r2, #31
 8001278:	0fc0      	lsrs	r0, r0, #31
 800127a:	68a2      	ldr	r2, [r4, #8]
 800127c:	68d2      	ldr	r2, [r2, #12]
 800127e:	4790      	blx	r2
 8001280:	e5d5      	b.n	8000e2e <__iar_annotation$$branch+0x436>
 8001282:	2001      	movs	r0, #1
 8001284:	9000      	str	r0, [sp, #0]
 8001286:	231b      	movs	r3, #27
 8001288:	2207      	movs	r2, #7
 800128a:	2100      	movs	r1, #0
 800128c:	0020      	movs	r0, r4
 800128e:	f002 fa70 	bl	8003772 <PE_Send_CtrlMessage>
 8001292:	2800      	cmp	r0, #0
 8001294:	d000      	beq.n	8001298 <__iar_annotation$$branch+0x8a0>
 8001296:	e748      	b.n	800112a <__iar_annotation$$branch+0x732>
 8001298:	2006      	movs	r0, #6
 800129a:	82e0      	strh	r0, [r4, #22]
 800129c:	489f      	ldr	r0, [pc, #636]	; (800151c <__iar_annotation$$branch+0xb24>)
 800129e:	83b0      	strh	r0, [r6, #28]
 80012a0:	251a      	movs	r5, #26
 80012a2:	4f9d      	ldr	r7, [pc, #628]	; (8001518 <__iar_annotation$$branch+0xb20>)
 80012a4:	7838      	ldrb	r0, [r7, #0]
 80012a6:	0780      	lsls	r0, r0, #30
 80012a8:	d509      	bpl.n	80012be <__iar_annotation$$branch+0x8c6>
 80012aa:	2000      	movs	r0, #0
 80012ac:	9000      	str	r0, [sp, #0]
 80012ae:	2300      	movs	r3, #0
 80012b0:	220b      	movs	r2, #11
 80012b2:	7b20      	ldrb	r0, [r4, #12]
 80012b4:	07c1      	lsls	r1, r0, #31
 80012b6:	0fc9      	lsrs	r1, r1, #31
 80012b8:	2009      	movs	r0, #9
 80012ba:	68ff      	ldr	r7, [r7, #12]
 80012bc:	47b8      	blx	r7
 80012be:	210b      	movs	r1, #11
 80012c0:	e752      	b.n	8001168 <__iar_annotation$$branch+0x770>
 80012c2:	2911      	cmp	r1, #17
 80012c4:	d162      	bne.n	800138c <__iar_annotation$$branch+0x994>
 80012c6:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 80012c8:	0bc0      	lsrs	r0, r0, #15
 80012ca:	d133      	bne.n	8001334 <__iar_annotation$$branch+0x93c>
 80012cc:	2007      	movs	r0, #7
 80012ce:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80012d0:	0b09      	lsrs	r1, r1, #12
 80012d2:	4201      	tst	r1, r0
 80012d4:	d02e      	beq.n	8001334 <__iar_annotation$$branch+0x93c>
 80012d6:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80012d8:	06c9      	lsls	r1, r1, #27
 80012da:	0ec9      	lsrs	r1, r1, #27
 80012dc:	2901      	cmp	r1, #1
 80012de:	d129      	bne.n	8001334 <__iar_annotation$$branch+0x93c>
 80012e0:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80012e2:	0b09      	lsrs	r1, r1, #12
 80012e4:	4008      	ands	r0, r1
 80012e6:	0083      	lsls	r3, r0, #2
 80012e8:	209e      	movs	r0, #158	; 0x9e
 80012ea:	0040      	lsls	r0, r0, #1
 80012ec:	1822      	adds	r2, r4, r0
 80012ee:	2104      	movs	r1, #4
 80012f0:	7b27      	ldrb	r7, [r4, #12]
 80012f2:	07f8      	lsls	r0, r7, #31
 80012f4:	0fc0      	lsrs	r0, r0, #31
 80012f6:	68a7      	ldr	r7, [r4, #8]
 80012f8:	69ff      	ldr	r7, [r7, #28]
 80012fa:	47b8      	blx	r7
 80012fc:	2000      	movs	r0, #0
 80012fe:	83b0      	strh	r0, [r6, #28]
 8001300:	2003      	movs	r0, #3
 8001302:	7230      	strb	r0, [r6, #8]
 8001304:	2014      	movs	r0, #20
 8001306:	4669      	mov	r1, sp
 8001308:	7308      	strb	r0, [r1, #12]
 800130a:	4f83      	ldr	r7, [pc, #524]	; (8001518 <__iar_annotation$$branch+0xb20>)
 800130c:	7838      	ldrb	r0, [r7, #0]
 800130e:	0780      	lsls	r0, r0, #30
 8001310:	d509      	bpl.n	8001326 <__iar_annotation$$branch+0x92e>
 8001312:	2000      	movs	r0, #0
 8001314:	9000      	str	r0, [sp, #0]
 8001316:	2300      	movs	r3, #0
 8001318:	220d      	movs	r2, #13
 800131a:	7b20      	ldrb	r0, [r4, #12]
 800131c:	07c1      	lsls	r1, r0, #31
 800131e:	0fc9      	lsrs	r1, r1, #31
 8001320:	2009      	movs	r0, #9
 8001322:	68ff      	ldr	r7, [r7, #12]
 8001324:	47b8      	blx	r7
 8001326:	210d      	movs	r1, #13
 8001328:	7b22      	ldrb	r2, [r4, #12]
 800132a:	07d0      	lsls	r0, r2, #31
 800132c:	0fc0      	lsrs	r0, r0, #31
 800132e:	68a2      	ldr	r2, [r4, #8]
 8001330:	68d2      	ldr	r2, [r2, #12]
 8001332:	4790      	blx	r2
 8001334:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001336:	0bc0      	lsrs	r0, r0, #15
 8001338:	d128      	bne.n	800138c <__iar_annotation$$branch+0x994>
 800133a:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800133c:	0b00      	lsrs	r0, r0, #12
 800133e:	0740      	lsls	r0, r0, #29
 8001340:	d124      	bne.n	800138c <__iar_annotation$$branch+0x994>
 8001342:	201f      	movs	r0, #31
 8001344:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8001346:	4001      	ands	r1, r0
 8001348:	2904      	cmp	r1, #4
 800134a:	d003      	beq.n	8001354 <__iar_annotation$$branch+0x95c>
 800134c:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800134e:	4008      	ands	r0, r1
 8001350:	2810      	cmp	r0, #16
 8001352:	d11b      	bne.n	800138c <__iar_annotation$$branch+0x994>
 8001354:	2000      	movs	r0, #0
 8001356:	83b0      	strh	r0, [r6, #28]
 8001358:	2003      	movs	r0, #3
 800135a:	7230      	strb	r0, [r6, #8]
 800135c:	2014      	movs	r0, #20
 800135e:	4669      	mov	r1, sp
 8001360:	7308      	strb	r0, [r1, #12]
 8001362:	4f6d      	ldr	r7, [pc, #436]	; (8001518 <__iar_annotation$$branch+0xb20>)
 8001364:	7838      	ldrb	r0, [r7, #0]
 8001366:	0780      	lsls	r0, r0, #30
 8001368:	d509      	bpl.n	800137e <__iar_annotation$$branch+0x986>
 800136a:	2000      	movs	r0, #0
 800136c:	9000      	str	r0, [sp, #0]
 800136e:	2300      	movs	r3, #0
 8001370:	220e      	movs	r2, #14
 8001372:	7b20      	ldrb	r0, [r4, #12]
 8001374:	07c1      	lsls	r1, r0, #31
 8001376:	0fc9      	lsrs	r1, r1, #31
 8001378:	2009      	movs	r0, #9
 800137a:	68ff      	ldr	r7, [r7, #12]
 800137c:	47b8      	blx	r7
 800137e:	210e      	movs	r1, #14
 8001380:	7b22      	ldrb	r2, [r4, #12]
 8001382:	07d0      	lsls	r0, r2, #31
 8001384:	0fc0      	lsrs	r0, r0, #31
 8001386:	68a2      	ldr	r2, [r4, #8]
 8001388:	68d2      	ldr	r2, [r2, #12]
 800138a:	4790      	blx	r2
 800138c:	8bb0      	ldrh	r0, [r6, #28]
 800138e:	03a9      	lsls	r1, r5, #14
 8001390:	e1cf      	b.n	8001732 <__iar_annotation$$branch+0x164>
 8001392:	68a0      	ldr	r0, [r4, #8]
 8001394:	6881      	ldr	r1, [r0, #8]
 8001396:	2900      	cmp	r1, #0
 8001398:	d108      	bne.n	80013ac <__iar_annotation$$branch+0x9b4>
 800139a:	2000      	movs	r0, #0
 800139c:	9000      	str	r0, [sp, #0]
 800139e:	2303      	movs	r3, #3
 80013a0:	2204      	movs	r2, #4
 80013a2:	2100      	movs	r1, #0
 80013a4:	0020      	movs	r0, r4
 80013a6:	f002 f9e4 	bl	8003772 <PE_Send_CtrlMessage>
 80013aa:	e6be      	b.n	800112a <__iar_annotation$$branch+0x732>
 80013ac:	7b22      	ldrb	r2, [r4, #12]
 80013ae:	07d0      	lsls	r0, r2, #31
 80013b0:	0fc0      	lsrs	r0, r0, #31
 80013b2:	4788      	blx	r1
 80013b4:	280a      	cmp	r0, #10
 80013b6:	d002      	beq.n	80013be <__iar_annotation$$branch+0x9c6>
 80013b8:	280d      	cmp	r0, #13
 80013ba:	d025      	beq.n	8001408 <__iar_annotation$$branch+0xa10>
 80013bc:	e03c      	b.n	8001438 <__iar_annotation$$branch+0xa40>
 80013be:	4858      	ldr	r0, [pc, #352]	; (8001520 <__iar_annotation$$branch+0xb28>)
 80013c0:	8470      	strh	r0, [r6, #34]	; 0x22
 80013c2:	251e      	movs	r5, #30
 80013c4:	2000      	movs	r0, #0
 80013c6:	9000      	str	r0, [sp, #0]
 80013c8:	2324      	movs	r3, #36	; 0x24
 80013ca:	2203      	movs	r2, #3
 80013cc:	2100      	movs	r1, #0
 80013ce:	0020      	movs	r0, r4
 80013d0:	f002 f9cf 	bl	8003772 <PE_Send_CtrlMessage>
 80013d4:	68a0      	ldr	r0, [r4, #8]
 80013d6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80013d8:	2b00      	cmp	r3, #0
 80013da:	d005      	beq.n	80013e8 <__iar_annotation$$branch+0x9f0>
 80013dc:	2201      	movs	r2, #1
 80013de:	2101      	movs	r1, #1
 80013e0:	7b27      	ldrb	r7, [r4, #12]
 80013e2:	07f8      	lsls	r0, r7, #31
 80013e4:	0fc0      	lsrs	r0, r0, #31
 80013e6:	4798      	blx	r3
 80013e8:	4f4b      	ldr	r7, [pc, #300]	; (8001518 <__iar_annotation$$branch+0xb20>)
 80013ea:	7838      	ldrb	r0, [r7, #0]
 80013ec:	0780      	lsls	r0, r0, #30
 80013ee:	d509      	bpl.n	8001404 <__iar_annotation$$branch+0xa0c>
 80013f0:	2000      	movs	r0, #0
 80013f2:	9000      	str	r0, [sp, #0]
 80013f4:	2300      	movs	r3, #0
 80013f6:	2238      	movs	r2, #56	; 0x38
 80013f8:	7b20      	ldrb	r0, [r4, #12]
 80013fa:	07c1      	lsls	r1, r0, #31
 80013fc:	0fc9      	lsrs	r1, r1, #31
 80013fe:	2009      	movs	r0, #9
 8001400:	68ff      	ldr	r7, [r7, #12]
 8001402:	47b8      	blx	r7
 8001404:	2138      	movs	r1, #56	; 0x38
 8001406:	e6af      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001408:	2000      	movs	r0, #0
 800140a:	9000      	str	r0, [sp, #0]
 800140c:	2303      	movs	r3, #3
 800140e:	220c      	movs	r2, #12
 8001410:	2100      	movs	r1, #0
 8001412:	0020      	movs	r0, r4
 8001414:	f002 f9ad 	bl	8003772 <PE_Send_CtrlMessage>
 8001418:	4f3f      	ldr	r7, [pc, #252]	; (8001518 <__iar_annotation$$branch+0xb20>)
 800141a:	7838      	ldrb	r0, [r7, #0]
 800141c:	0780      	lsls	r0, r0, #30
 800141e:	d509      	bpl.n	8001434 <__iar_annotation$$branch+0xa3c>
 8001420:	2000      	movs	r0, #0
 8001422:	9000      	str	r0, [sp, #0]
 8001424:	2300      	movs	r3, #0
 8001426:	2239      	movs	r2, #57	; 0x39
 8001428:	7b20      	ldrb	r0, [r4, #12]
 800142a:	07c1      	lsls	r1, r0, #31
 800142c:	0fc9      	lsrs	r1, r1, #31
 800142e:	2009      	movs	r0, #9
 8001430:	68ff      	ldr	r7, [r7, #12]
 8001432:	47b8      	blx	r7
 8001434:	2139      	movs	r1, #57	; 0x39
 8001436:	e697      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001438:	2000      	movs	r0, #0
 800143a:	9000      	str	r0, [sp, #0]
 800143c:	2303      	movs	r3, #3
 800143e:	2204      	movs	r2, #4
 8001440:	2100      	movs	r1, #0
 8001442:	0020      	movs	r0, r4
 8001444:	f002 f995 	bl	8003772 <PE_Send_CtrlMessage>
 8001448:	4f33      	ldr	r7, [pc, #204]	; (8001518 <__iar_annotation$$branch+0xb20>)
 800144a:	7838      	ldrb	r0, [r7, #0]
 800144c:	0780      	lsls	r0, r0, #30
 800144e:	d509      	bpl.n	8001464 <__iar_annotation$$branch+0xa6c>
 8001450:	2000      	movs	r0, #0
 8001452:	9000      	str	r0, [sp, #0]
 8001454:	2300      	movs	r3, #0
 8001456:	2216      	movs	r2, #22
 8001458:	7b20      	ldrb	r0, [r4, #12]
 800145a:	07c1      	lsls	r1, r0, #31
 800145c:	0fc9      	lsrs	r1, r1, #31
 800145e:	2009      	movs	r0, #9
 8001460:	68ff      	ldr	r7, [r7, #12]
 8001462:	47b8      	blx	r7
 8001464:	2116      	movs	r1, #22
 8001466:	e67f      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001468:	8c71      	ldrh	r1, [r6, #34]	; 0x22
 800146a:	03aa      	lsls	r2, r5, #14
 800146c:	4291      	cmp	r1, r2
 800146e:	d151      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 8001470:	2100      	movs	r1, #0
 8001472:	8471      	strh	r1, [r6, #34]	; 0x22
 8001474:	6861      	ldr	r1, [r4, #4]
 8001476:	784a      	ldrb	r2, [r1, #1]
 8001478:	238f      	movs	r3, #143	; 0x8f
 800147a:	4013      	ands	r3, r2
 800147c:	2240      	movs	r2, #64	; 0x40
 800147e:	431a      	orrs	r2, r3
 8001480:	704a      	strb	r2, [r1, #1]
 8001482:	2800      	cmp	r0, #0
 8001484:	d009      	beq.n	800149a <__iar_annotation$$branch+0xaa2>
 8001486:	2000      	movs	r0, #0
 8001488:	9000      	str	r0, [sp, #0]
 800148a:	2300      	movs	r3, #0
 800148c:	2256      	movs	r2, #86	; 0x56
 800148e:	7b20      	ldrb	r0, [r4, #12]
 8001490:	07c1      	lsls	r1, r0, #31
 8001492:	0fc9      	lsrs	r1, r1, #31
 8001494:	2009      	movs	r0, #9
 8001496:	9f01      	ldr	r7, [sp, #4]
 8001498:	47b8      	blx	r7
 800149a:	2701      	movs	r7, #1
 800149c:	2156      	movs	r1, #86	; 0x56
 800149e:	68e2      	ldr	r2, [r4, #12]
 80014a0:	2001      	movs	r0, #1
 80014a2:	4010      	ands	r0, r2
 80014a4:	68a2      	ldr	r2, [r4, #8]
 80014a6:	68d2      	ldr	r2, [r2, #12]
 80014a8:	4790      	blx	r2
 80014aa:	6860      	ldr	r0, [r4, #4]
 80014ac:	6801      	ldr	r1, [r0, #0]
 80014ae:	2210      	movs	r2, #16
 80014b0:	430a      	orrs	r2, r1
 80014b2:	6002      	str	r2, [r0, #0]
 80014b4:	68a0      	ldr	r0, [r4, #8]
 80014b6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80014b8:	2b00      	cmp	r3, #0
 80014ba:	d00f      	beq.n	80014dc <__iar_annotation$$branch+0xae4>
 80014bc:	2206      	movs	r2, #6
 80014be:	68e1      	ldr	r1, [r4, #12]
 80014c0:	2001      	movs	r0, #1
 80014c2:	4008      	ands	r0, r1
 80014c4:	2101      	movs	r1, #1
 80014c6:	4798      	blx	r3
 80014c8:	68a0      	ldr	r0, [r4, #8]
 80014ca:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80014cc:	2b00      	cmp	r3, #0
 80014ce:	d005      	beq.n	80014dc <__iar_annotation$$branch+0xae4>
 80014d0:	2207      	movs	r2, #7
 80014d2:	68e1      	ldr	r1, [r4, #12]
 80014d4:	2001      	movs	r0, #1
 80014d6:	4008      	ands	r0, r1
 80014d8:	2101      	movs	r1, #1
 80014da:	4798      	blx	r3
 80014dc:	2100      	movs	r1, #0
 80014de:	68e2      	ldr	r2, [r4, #12]
 80014e0:	2001      	movs	r0, #1
 80014e2:	4010      	ands	r0, r2
 80014e4:	f003 fd1d 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 80014e8:	2000      	movs	r0, #0
 80014ea:	9000      	str	r0, [sp, #0]
 80014ec:	2325      	movs	r3, #37	; 0x25
 80014ee:	2206      	movs	r2, #6
 80014f0:	2100      	movs	r1, #0
 80014f2:	0020      	movs	r0, r4
 80014f4:	f002 f93d 	bl	8003772 <PE_Send_CtrlMessage>
 80014f8:	2800      	cmp	r0, #0
 80014fa:	d10b      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 80014fc:	68a0      	ldr	r0, [r4, #8]
 80014fe:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001500:	2b00      	cmp	r3, #0
 8001502:	d005      	beq.n	8001510 <__iar_annotation$$branch+0xb18>
 8001504:	2208      	movs	r2, #8
 8001506:	2101      	movs	r1, #1
 8001508:	68e0      	ldr	r0, [r4, #12]
 800150a:	4007      	ands	r7, r0
 800150c:	0038      	movs	r0, r7
 800150e:	4798      	blx	r3
 8001510:	48bd      	ldr	r0, [pc, #756]	; (8001808 <__iar_annotation$$branch+0x23a>)
 8001512:	8370      	strh	r0, [r6, #26]
 8001514:	e609      	b.n	800112a <__iar_annotation$$branch+0x732>
 8001516:	bf00      	nop
 8001518:	200019a8 	.word	0x200019a8
 800151c:	0000801a 	.word	0x0000801a
 8001520:	0000801e 	.word	0x0000801e
 8001524:	2911      	cmp	r1, #17
 8001526:	d112      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 8001528:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800152a:	0bc0      	lsrs	r0, r0, #15
 800152c:	d10f      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 800152e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001530:	0b00      	lsrs	r0, r0, #12
 8001532:	0740      	lsls	r0, r0, #29
 8001534:	d10b      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 8001536:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001538:	06c0      	lsls	r0, r0, #27
 800153a:	0ec0      	lsrs	r0, r0, #27
 800153c:	2806      	cmp	r0, #6
 800153e:	d106      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 8001540:	2000      	movs	r0, #0
 8001542:	8370      	strh	r0, [r6, #26]
 8001544:	2014      	movs	r0, #20
 8001546:	4669      	mov	r1, sp
 8001548:	7308      	strb	r0, [r1, #12]
 800154a:	2026      	movs	r0, #38	; 0x26
 800154c:	7230      	strb	r0, [r6, #8]
 800154e:	8b70      	ldrh	r0, [r6, #26]
 8001550:	03a9      	lsls	r1, r5, #14
 8001552:	4288      	cmp	r0, r1
 8001554:	d1de      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 8001556:	68a0      	ldr	r0, [r4, #8]
 8001558:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800155a:	2b00      	cmp	r3, #0
 800155c:	d005      	beq.n	800156a <__iar_annotation$$branch+0xb72>
 800155e:	220a      	movs	r2, #10
 8001560:	2101      	movs	r1, #1
 8001562:	7b27      	ldrb	r7, [r4, #12]
 8001564:	07f8      	lsls	r0, r7, #31
 8001566:	0fc0      	lsrs	r0, r0, #31
 8001568:	4798      	blx	r3
 800156a:	e12b      	b.n	80017c4 <__iar_annotation$$branch+0x1f6>
 800156c:	2100      	movs	r1, #0
 800156e:	0020      	movs	r0, r4
 8001570:	f002 fa14 	bl	800399c <PE_ChangePowerRole>
 8001574:	68a0      	ldr	r0, [r4, #8]
 8001576:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001578:	2501      	movs	r5, #1
 800157a:	2b00      	cmp	r3, #0
 800157c:	d005      	beq.n	800158a <__iar_annotation$$branch+0xb92>
 800157e:	220d      	movs	r2, #13
 8001580:	2100      	movs	r1, #0
 8001582:	68e7      	ldr	r7, [r4, #12]
 8001584:	2001      	movs	r0, #1
 8001586:	4038      	ands	r0, r7
 8001588:	4798      	blx	r3
 800158a:	0020      	movs	r0, r4
 800158c:	f002 feb0 	bl	80042f0 <PE_ResetDuringSwap>
 8001590:	4fae      	ldr	r7, [pc, #696]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001592:	7838      	ldrb	r0, [r7, #0]
 8001594:	0780      	lsls	r0, r0, #30
 8001596:	d509      	bpl.n	80015ac <__iar_annotation$$branch+0xbb4>
 8001598:	2000      	movs	r0, #0
 800159a:	9000      	str	r0, [sp, #0]
 800159c:	2300      	movs	r3, #0
 800159e:	2214      	movs	r2, #20
 80015a0:	68e0      	ldr	r0, [r4, #12]
 80015a2:	2101      	movs	r1, #1
 80015a4:	4001      	ands	r1, r0
 80015a6:	2009      	movs	r0, #9
 80015a8:	68ff      	ldr	r7, [r7, #12]
 80015aa:	47b8      	blx	r7
 80015ac:	2114      	movs	r1, #20
 80015ae:	68e2      	ldr	r2, [r4, #12]
 80015b0:	2001      	movs	r0, #1
 80015b2:	4010      	ands	r0, r2
 80015b4:	68a2      	ldr	r2, [r4, #8]
 80015b6:	68d2      	ldr	r2, [r2, #12]
 80015b8:	4790      	blx	r2
 80015ba:	68a0      	ldr	r0, [r4, #8]
 80015bc:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80015be:	2b00      	cmp	r3, #0
 80015c0:	d005      	beq.n	80015ce <__iar_annotation$$branch>
 80015c2:	220e      	movs	r2, #14
 80015c4:	2100      	movs	r1, #0
 80015c6:	68e0      	ldr	r0, [r4, #12]
 80015c8:	4005      	ands	r5, r0
 80015ca:	0028      	movs	r0, r5
 80015cc:	4798      	blx	r3

080015ce <__iar_annotation$$branch>:
 80015ce:	f7ff fa65 	bl	8000a9c <__iar_annotation$$branch+0xa4>
 80015d2:	2001      	movs	r0, #1
 80015d4:	9000      	str	r0, [sp, #0]
 80015d6:	231f      	movs	r3, #31
 80015d8:	220a      	movs	r2, #10
 80015da:	2100      	movs	r1, #0
 80015dc:	0020      	movs	r0, r4
 80015de:	f002 f8c8 	bl	8003772 <PE_Send_CtrlMessage>
 80015e2:	2800      	cmp	r0, #0
 80015e4:	d196      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 80015e6:	2008      	movs	r0, #8
 80015e8:	82e0      	strh	r0, [r4, #22]
 80015ea:	48b7      	ldr	r0, [pc, #732]	; (80018c8 <__iar_annotation$$branch+0xa>)
 80015ec:	83b0      	strh	r0, [r6, #28]
 80015ee:	251a      	movs	r5, #26
 80015f0:	68a0      	ldr	r0, [r4, #8]
 80015f2:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80015f4:	2b00      	cmp	r3, #0
 80015f6:	d005      	beq.n	8001604 <__iar_annotation$$branch+0x36>
 80015f8:	2202      	movs	r2, #2
 80015fa:	2101      	movs	r1, #1
 80015fc:	7b27      	ldrb	r7, [r4, #12]
 80015fe:	07f8      	lsls	r0, r7, #31
 8001600:	0fc0      	lsrs	r0, r0, #31
 8001602:	4798      	blx	r3
 8001604:	4f91      	ldr	r7, [pc, #580]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001606:	7838      	ldrb	r0, [r7, #0]
 8001608:	0780      	lsls	r0, r0, #30
 800160a:	d509      	bpl.n	8001620 <__iar_annotation$$branch+0x52>
 800160c:	2000      	movs	r0, #0
 800160e:	9000      	str	r0, [sp, #0]
 8001610:	2300      	movs	r3, #0
 8001612:	2237      	movs	r2, #55	; 0x37
 8001614:	7b20      	ldrb	r0, [r4, #12]
 8001616:	07c1      	lsls	r1, r0, #31
 8001618:	0fc9      	lsrs	r1, r1, #31
 800161a:	2009      	movs	r0, #9
 800161c:	68ff      	ldr	r7, [r7, #12]
 800161e:	47b8      	blx	r7
 8001620:	2137      	movs	r1, #55	; 0x37
 8001622:	e5a1      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001624:	2911      	cmp	r1, #17
 8001626:	d000      	beq.n	800162a <__iar_annotation$$branch+0x5c>
 8001628:	e57f      	b.n	800112a <__iar_annotation$$branch+0x732>
 800162a:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800162c:	0bc9      	lsrs	r1, r1, #15
 800162e:	d17d      	bne.n	800172c <__iar_annotation$$branch+0x15e>
 8001630:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8001632:	0b09      	lsrs	r1, r1, #12
 8001634:	0749      	lsls	r1, r1, #29
 8001636:	d179      	bne.n	800172c <__iar_annotation$$branch+0x15e>
 8001638:	2703      	movs	r7, #3
 800163a:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800163c:	06c9      	lsls	r1, r1, #27
 800163e:	0ec9      	lsrs	r1, r1, #27
 8001640:	2903      	cmp	r1, #3
 8001642:	d006      	beq.n	8001652 <__iar_annotation$$branch+0x84>
 8001644:	2904      	cmp	r1, #4
 8001646:	d031      	beq.n	80016ac <__iar_annotation$$branch+0xde>
 8001648:	290c      	cmp	r1, #12
 800164a:	d013      	beq.n	8001674 <__iar_annotation$$branch+0xa6>
 800164c:	2910      	cmp	r1, #16
 800164e:	d049      	beq.n	80016e4 <__iar_annotation$$branch+0x116>
 8001650:	e06c      	b.n	800172c <__iar_annotation$$branch+0x15e>
 8001652:	2500      	movs	r5, #0
 8001654:	83b5      	strh	r5, [r6, #28]
 8001656:	2120      	movs	r1, #32
 8001658:	7231      	strb	r1, [r6, #8]
 800165a:	2800      	cmp	r0, #0
 800165c:	d008      	beq.n	8001670 <__iar_annotation$$branch+0xa2>
 800165e:	9500      	str	r5, [sp, #0]
 8001660:	2300      	movs	r3, #0
 8001662:	2238      	movs	r2, #56	; 0x38
 8001664:	7b20      	ldrb	r0, [r4, #12]
 8001666:	07c1      	lsls	r1, r0, #31
 8001668:	0fc9      	lsrs	r1, r1, #31
 800166a:	2009      	movs	r0, #9
 800166c:	9f01      	ldr	r7, [sp, #4]
 800166e:	47b8      	blx	r7
 8001670:	2138      	movs	r1, #56	; 0x38
 8001672:	e052      	b.n	800171a <__iar_annotation$$branch+0x14c>
 8001674:	68a0      	ldr	r0, [r4, #8]
 8001676:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001678:	2b00      	cmp	r3, #0
 800167a:	d005      	beq.n	8001688 <__iar_annotation$$branch+0xba>
 800167c:	2205      	movs	r2, #5
 800167e:	2101      	movs	r1, #1
 8001680:	7b25      	ldrb	r5, [r4, #12]
 8001682:	07e8      	lsls	r0, r5, #31
 8001684:	0fc0      	lsrs	r0, r0, #31
 8001686:	4798      	blx	r3
 8001688:	2500      	movs	r5, #0
 800168a:	83b5      	strh	r5, [r6, #28]
 800168c:	7237      	strb	r7, [r6, #8]
 800168e:	4f6f      	ldr	r7, [pc, #444]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001690:	7838      	ldrb	r0, [r7, #0]
 8001692:	0780      	lsls	r0, r0, #30
 8001694:	d508      	bpl.n	80016a8 <__iar_annotation$$branch+0xda>
 8001696:	9500      	str	r5, [sp, #0]
 8001698:	2300      	movs	r3, #0
 800169a:	2239      	movs	r2, #57	; 0x39
 800169c:	7b20      	ldrb	r0, [r4, #12]
 800169e:	07c1      	lsls	r1, r0, #31
 80016a0:	0fc9      	lsrs	r1, r1, #31
 80016a2:	2009      	movs	r0, #9
 80016a4:	68ff      	ldr	r7, [r7, #12]
 80016a6:	47b8      	blx	r7
 80016a8:	2139      	movs	r1, #57	; 0x39
 80016aa:	e036      	b.n	800171a <__iar_annotation$$branch+0x14c>
 80016ac:	68a0      	ldr	r0, [r4, #8]
 80016ae:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80016b0:	2b00      	cmp	r3, #0
 80016b2:	d005      	beq.n	80016c0 <__iar_annotation$$branch+0xf2>
 80016b4:	2204      	movs	r2, #4
 80016b6:	2101      	movs	r1, #1
 80016b8:	7b25      	ldrb	r5, [r4, #12]
 80016ba:	07e8      	lsls	r0, r5, #31
 80016bc:	0fc0      	lsrs	r0, r0, #31
 80016be:	4798      	blx	r3
 80016c0:	2500      	movs	r5, #0
 80016c2:	83b5      	strh	r5, [r6, #28]
 80016c4:	7237      	strb	r7, [r6, #8]
 80016c6:	4f61      	ldr	r7, [pc, #388]	; (800184c <__iar_annotation$$branch+0x27e>)
 80016c8:	7838      	ldrb	r0, [r7, #0]
 80016ca:	0780      	lsls	r0, r0, #30
 80016cc:	d508      	bpl.n	80016e0 <__iar_annotation$$branch+0x112>
 80016ce:	9500      	str	r5, [sp, #0]
 80016d0:	2300      	movs	r3, #0
 80016d2:	2216      	movs	r2, #22
 80016d4:	7b20      	ldrb	r0, [r4, #12]
 80016d6:	07c1      	lsls	r1, r0, #31
 80016d8:	0fc9      	lsrs	r1, r1, #31
 80016da:	2009      	movs	r0, #9
 80016dc:	68ff      	ldr	r7, [r7, #12]
 80016de:	47b8      	blx	r7
 80016e0:	2116      	movs	r1, #22
 80016e2:	e01a      	b.n	800171a <__iar_annotation$$branch+0x14c>
 80016e4:	68a0      	ldr	r0, [r4, #8]
 80016e6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80016e8:	2b00      	cmp	r3, #0
 80016ea:	d005      	beq.n	80016f8 <__iar_annotation$$branch+0x12a>
 80016ec:	2204      	movs	r2, #4
 80016ee:	2101      	movs	r1, #1
 80016f0:	7b25      	ldrb	r5, [r4, #12]
 80016f2:	07e8      	lsls	r0, r5, #31
 80016f4:	0fc0      	lsrs	r0, r0, #31
 80016f6:	4798      	blx	r3
 80016f8:	2500      	movs	r5, #0
 80016fa:	83b5      	strh	r5, [r6, #28]
 80016fc:	7237      	strb	r7, [r6, #8]
 80016fe:	4f53      	ldr	r7, [pc, #332]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001700:	7838      	ldrb	r0, [r7, #0]
 8001702:	0780      	lsls	r0, r0, #30
 8001704:	d508      	bpl.n	8001718 <__iar_annotation$$branch+0x14a>
 8001706:	9500      	str	r5, [sp, #0]
 8001708:	2300      	movs	r3, #0
 800170a:	2255      	movs	r2, #85	; 0x55
 800170c:	7b20      	ldrb	r0, [r4, #12]
 800170e:	07c1      	lsls	r1, r0, #31
 8001710:	0fc9      	lsrs	r1, r1, #31
 8001712:	2009      	movs	r0, #9
 8001714:	68ff      	ldr	r7, [r7, #12]
 8001716:	47b8      	blx	r7
 8001718:	2155      	movs	r1, #85	; 0x55
 800171a:	7b22      	ldrb	r2, [r4, #12]
 800171c:	07d0      	lsls	r0, r2, #31
 800171e:	0fc0      	lsrs	r0, r0, #31
 8001720:	68a2      	ldr	r2, [r4, #8]
 8001722:	68d2      	ldr	r2, [r2, #12]
 8001724:	4790      	blx	r2
 8001726:	2014      	movs	r0, #20
 8001728:	4669      	mov	r1, sp
 800172a:	7308      	strb	r0, [r1, #12]
 800172c:	8bb0      	ldrh	r0, [r6, #28]
 800172e:	2180      	movs	r1, #128	; 0x80
 8001730:	0209      	lsls	r1, r1, #8
 8001732:	4288      	cmp	r0, r1
 8001734:	d138      	bne.n	80017a8 <__iar_annotation$$branch+0x1da>
 8001736:	e22a      	b.n	8001b8e <__iar_annotation$$branch+0xc>
 8001738:	6860      	ldr	r0, [r4, #4]
 800173a:	6801      	ldr	r1, [r0, #0]
 800173c:	2210      	movs	r2, #16
 800173e:	430a      	orrs	r2, r1
 8001740:	6002      	str	r2, [r0, #0]
 8001742:	68a0      	ldr	r0, [r4, #8]
 8001744:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001746:	2701      	movs	r7, #1
 8001748:	2b00      	cmp	r3, #0
 800174a:	d00f      	beq.n	800176c <__iar_annotation$$branch+0x19e>
 800174c:	2206      	movs	r2, #6
 800174e:	68e1      	ldr	r1, [r4, #12]
 8001750:	2001      	movs	r0, #1
 8001752:	4008      	ands	r0, r1
 8001754:	2101      	movs	r1, #1
 8001756:	4798      	blx	r3
 8001758:	68a0      	ldr	r0, [r4, #8]
 800175a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800175c:	2b00      	cmp	r3, #0
 800175e:	d005      	beq.n	800176c <__iar_annotation$$branch+0x19e>
 8001760:	2207      	movs	r2, #7
 8001762:	68e1      	ldr	r1, [r4, #12]
 8001764:	2001      	movs	r0, #1
 8001766:	4008      	ands	r0, r1
 8001768:	2101      	movs	r1, #1
 800176a:	4798      	blx	r3
 800176c:	2100      	movs	r1, #0
 800176e:	68e2      	ldr	r2, [r4, #12]
 8001770:	2001      	movs	r0, #1
 8001772:	4010      	ands	r0, r2
 8001774:	f003 fbd5 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8001778:	2000      	movs	r0, #0
 800177a:	9000      	str	r0, [sp, #0]
 800177c:	2321      	movs	r3, #33	; 0x21
 800177e:	2206      	movs	r2, #6
 8001780:	2100      	movs	r1, #0
 8001782:	0020      	movs	r0, r4
 8001784:	f001 fff5 	bl	8003772 <PE_Send_CtrlMessage>
 8001788:	2800      	cmp	r0, #0
 800178a:	d10d      	bne.n	80017a8 <__iar_annotation$$branch+0x1da>
 800178c:	68a0      	ldr	r0, [r4, #8]
 800178e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001790:	2b00      	cmp	r3, #0
 8001792:	d005      	beq.n	80017a0 <__iar_annotation$$branch+0x1d2>
 8001794:	2208      	movs	r2, #8
 8001796:	2101      	movs	r1, #1
 8001798:	68e0      	ldr	r0, [r4, #12]
 800179a:	4007      	ands	r7, r0
 800179c:	0038      	movs	r0, r7
 800179e:	4798      	blx	r3
 80017a0:	484a      	ldr	r0, [pc, #296]	; (80018cc <__iar_annotation$$branch+0xe>)
 80017a2:	8370      	strh	r0, [r6, #26]
 80017a4:	25f0      	movs	r5, #240	; 0xf0
 80017a6:	006d      	lsls	r5, r5, #1
 80017a8:	e4bf      	b.n	800112a <__iar_annotation$$branch+0x732>
 80017aa:	2911      	cmp	r1, #17
 80017ac:	d106      	bne.n	80017bc <__iar_annotation$$branch+0x1ee>
 80017ae:	2000      	movs	r0, #0
 80017b0:	8370      	strh	r0, [r6, #26]
 80017b2:	2026      	movs	r0, #38	; 0x26
 80017b4:	7230      	strb	r0, [r6, #8]
 80017b6:	2014      	movs	r0, #20
 80017b8:	4669      	mov	r1, sp
 80017ba:	7308      	strb	r0, [r1, #12]
 80017bc:	8b70      	ldrh	r0, [r6, #26]
 80017be:	03a9      	lsls	r1, r5, #14
 80017c0:	4288      	cmp	r0, r1
 80017c2:	d1f1      	bne.n	80017a8 <__iar_annotation$$branch+0x1da>
 80017c4:	2000      	movs	r0, #0
 80017c6:	8370      	strh	r0, [r6, #26]
 80017c8:	e069      	b.n	800189e <__iar_annotation$$branch>
 80017ca:	6860      	ldr	r0, [r4, #4]
 80017cc:	7841      	ldrb	r1, [r0, #1]
 80017ce:	0649      	lsls	r1, r1, #25
 80017d0:	0f49      	lsrs	r1, r1, #29
 80017d2:	2903      	cmp	r1, #3
 80017d4:	d11a      	bne.n	800180c <__iar_annotation$$branch+0x23e>
 80017d6:	6821      	ldr	r1, [r4, #0]
 80017d8:	6849      	ldr	r1, [r1, #4]
 80017da:	070a      	lsls	r2, r1, #28
 80017dc:	0fd2      	lsrs	r2, r2, #31
 80017de:	d015      	beq.n	800180c <__iar_annotation$$branch+0x23e>
 80017e0:	2103      	movs	r1, #3
 80017e2:	0020      	movs	r0, r4
 80017e4:	f001 ffaa 	bl	800373c <PE_Send_SNKCapabilities>
 80017e8:	4f18      	ldr	r7, [pc, #96]	; (800184c <__iar_annotation$$branch+0x27e>)
 80017ea:	7838      	ldrb	r0, [r7, #0]
 80017ec:	0780      	lsls	r0, r0, #30
 80017ee:	d509      	bpl.n	8001804 <__iar_annotation$$branch+0x236>
 80017f0:	2000      	movs	r0, #0
 80017f2:	9000      	str	r0, [sp, #0]
 80017f4:	2300      	movs	r3, #0
 80017f6:	220a      	movs	r2, #10
 80017f8:	7b20      	ldrb	r0, [r4, #12]
 80017fa:	07c1      	lsls	r1, r0, #31
 80017fc:	0fc9      	lsrs	r1, r1, #31
 80017fe:	2009      	movs	r0, #9
 8001800:	68ff      	ldr	r7, [r7, #12]
 8001802:	47b8      	blx	r7
 8001804:	210a      	movs	r1, #10
 8001806:	e4af      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001808:	000081ae 	.word	0x000081ae
 800180c:	7800      	ldrb	r0, [r0, #0]
 800180e:	0780      	lsls	r0, r0, #30
 8001810:	0f80      	lsrs	r0, r0, #30
 8001812:	2802      	cmp	r0, #2
 8001814:	d101      	bne.n	800181a <__iar_annotation$$branch+0x24c>
 8001816:	2001      	movs	r0, #1
 8001818:	e433      	b.n	8001082 <__iar_annotation$$branch+0x68a>
 800181a:	202a      	movs	r0, #42	; 0x2a
 800181c:	e431      	b.n	8001082 <__iar_annotation$$branch+0x68a>
 800181e:	2700      	movs	r7, #0
 8001820:	82e7      	strh	r7, [r4, #22]
 8001822:	7b21      	ldrb	r1, [r4, #12]
 8001824:	07c8      	lsls	r0, r1, #31
 8001826:	0fc0      	lsrs	r0, r0, #31
 8001828:	f003 fba4 	bl	8004f74 <USBPD_PRL_SRCReleaseSinkNG>
 800182c:	2004      	movs	r0, #4
 800182e:	7230      	strb	r0, [r6, #8]
 8001830:	7b20      	ldrb	r0, [r4, #12]
 8001832:	0700      	lsls	r0, r0, #28
 8001834:	0f80      	lsrs	r0, r0, #30
 8001836:	2803      	cmp	r0, #3
 8001838:	d10a      	bne.n	8001850 <__iar_annotation$$branch+0x282>
 800183a:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 800183c:	0440      	lsls	r0, r0, #17
 800183e:	0c40      	lsrs	r0, r0, #17
 8001840:	2800      	cmp	r0, #0
 8001842:	dc06      	bgt.n	8001852 <__iar_annotation$$branch+0x284>
 8001844:	4822      	ldr	r0, [pc, #136]	; (80018d0 <__iar_annotation$$branch+0x12>)
 8001846:	8670      	strh	r0, [r6, #50]	; 0x32
 8001848:	4d22      	ldr	r5, [pc, #136]	; (80018d4 <__iar_annotation$$branch+0x16>)
 800184a:	e002      	b.n	8001852 <__iar_annotation$$branch+0x284>
 800184c:	200019a8 	.word	0x200019a8
 8001850:	8677      	strh	r7, [r6, #50]	; 0x32
 8001852:	4668      	mov	r0, sp
 8001854:	7b00      	ldrb	r0, [r0, #12]
 8001856:	2814      	cmp	r0, #20
 8001858:	d01a      	beq.n	8001890 <__iar_annotation$$branch+0x2c2>
 800185a:	7ab0      	ldrb	r0, [r6, #10]
 800185c:	72f0      	strb	r0, [r6, #11]
 800185e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001860:	0bc0      	lsrs	r0, r0, #15
 8001862:	d003      	beq.n	800186c <__iar_annotation$$branch+0x29e>
 8001864:	0020      	movs	r0, r4
 8001866:	f002 fb57 	bl	8003f18 <PE_Check_ExtendedMessage>
 800186a:	e00d      	b.n	8001888 <__iar_annotation$$branch+0x2ba>
 800186c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800186e:	0bc0      	lsrs	r0, r0, #15
 8001870:	d107      	bne.n	8001882 <__iar_annotation$$branch+0x2b4>
 8001872:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001874:	0b00      	lsrs	r0, r0, #12
 8001876:	0740      	lsls	r0, r0, #29
 8001878:	d103      	bne.n	8001882 <__iar_annotation$$branch+0x2b4>
 800187a:	0020      	movs	r0, r4
 800187c:	f002 f902 	bl	8003a84 <PE_Check_ControlMessage>
 8001880:	e002      	b.n	8001888 <__iar_annotation$$branch+0x2ba>
 8001882:	0020      	movs	r0, r4
 8001884:	f002 fa9a 	bl	8003dbc <PE_Check_DataMessage>
 8001888:	2014      	movs	r0, #20
 800188a:	4669      	mov	r1, sp
 800188c:	7308      	strb	r0, [r1, #12]
 800188e:	e44c      	b.n	800112a <__iar_annotation$$branch+0x732>
 8001890:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 8001892:	2180      	movs	r1, #128	; 0x80
 8001894:	0209      	lsls	r1, r1, #8
 8001896:	4288      	cmp	r0, r1
 8001898:	d103      	bne.n	80018a2 <__iar_annotation$$branch+0x4>
 800189a:	2500      	movs	r5, #0
 800189c:	8675      	strh	r5, [r6, #50]	; 0x32

0800189e <__iar_annotation$$branch>:
 800189e:	f7ff fac8 	bl	8000e32 <__iar_annotation$$branch+0x43a>
 80018a2:	7930      	ldrb	r0, [r6, #4]
 80018a4:	2800      	cmp	r0, #0
 80018a6:	d006      	beq.n	80018b6 <__iar_annotation$$branch+0x18>
 80018a8:	7970      	ldrb	r0, [r6, #5]
 80018aa:	72f0      	strb	r0, [r6, #11]
 80018ac:	7930      	ldrb	r0, [r6, #4]
 80018ae:	7230      	strb	r0, [r6, #8]
 80018b0:	2500      	movs	r5, #0
 80018b2:	7135      	strb	r5, [r6, #4]
 80018b4:	e439      	b.n	800112a <__iar_annotation$$branch+0x732>
 80018b6:	4d08      	ldr	r5, [pc, #32]	; (80018d8 <__iar_annotation$$branch+0x1a>)
 80018b8:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 80018ba:	4028      	ands	r0, r5
 80018bc:	dc01      	bgt.n	80018c2 <__iar_annotation$$branch+0x4>

080018be <__iar_annotation$$branch>:
 80018be:	f7ff faa0 	bl	8000e02 <__iar_annotation$$branch+0x40a>
 80018c2:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 80018c4:	4005      	ands	r5, r0
 80018c6:	e430      	b.n	800112a <__iar_annotation$$branch+0x732>
 80018c8:	0000801a 	.word	0x0000801a
 80018cc:	000081e0 	.word	0x000081e0
 80018d0:	0000b6b0 	.word	0x0000b6b0
 80018d4:	000036b0 	.word	0x000036b0
 80018d8:	00007fff 	.word	0x00007fff
 80018dc:	a80a      	add	r0, sp, #40	; 0x28
 80018de:	7800      	ldrb	r0, [r0, #0]
 80018e0:	68a1      	ldr	r1, [r4, #8]
 80018e2:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
 80018e4:	4788      	blx	r1
 80018e6:	280a      	cmp	r0, #10
 80018e8:	d142      	bne.n	8001970 <__iar_annotation$$branch+0xb2>
 80018ea:	2000      	movs	r0, #0
 80018ec:	9000      	str	r0, [sp, #0]
 80018ee:	2303      	movs	r3, #3
 80018f0:	2203      	movs	r2, #3
 80018f2:	2100      	movs	r1, #0
 80018f4:	0020      	movs	r0, r4
 80018f6:	f001 ff3c 	bl	8003772 <PE_Send_CtrlMessage>
 80018fa:	2800      	cmp	r0, #0
 80018fc:	d170      	bne.n	80019e0 <__iar_annotation$$branch>
 80018fe:	6861      	ldr	r1, [r4, #4]
 8001900:	780a      	ldrb	r2, [r1, #0]
 8001902:	48c8      	ldr	r0, [pc, #800]	; (8001c24 <.text_18>)
 8001904:	68c7      	ldr	r7, [r0, #12]
 8001906:	7800      	ldrb	r0, [r0, #0]
 8001908:	4028      	ands	r0, r5
 800190a:	08d3      	lsrs	r3, r2, #3
 800190c:	07db      	lsls	r3, r3, #31
 800190e:	d40f      	bmi.n	8001930 <__iar_annotation$$branch+0x72>
 8001910:	2308      	movs	r3, #8
 8001912:	4313      	orrs	r3, r2
 8001914:	700b      	strb	r3, [r1, #0]
 8001916:	2800      	cmp	r0, #0
 8001918:	d008      	beq.n	800192c <__iar_annotation$$branch+0x6e>
 800191a:	2000      	movs	r0, #0
 800191c:	9000      	str	r0, [sp, #0]
 800191e:	2300      	movs	r3, #0
 8001920:	2224      	movs	r2, #36	; 0x24
 8001922:	7b20      	ldrb	r0, [r4, #12]
 8001924:	07c1      	lsls	r1, r0, #31
 8001926:	0fc9      	lsrs	r1, r1, #31
 8001928:	2009      	movs	r0, #9
 800192a:	47b8      	blx	r7
 800192c:	2124      	movs	r1, #36	; 0x24
 800192e:	e00e      	b.n	800194e <__iar_annotation$$branch+0x90>
 8001930:	23f7      	movs	r3, #247	; 0xf7
 8001932:	4013      	ands	r3, r2
 8001934:	700b      	strb	r3, [r1, #0]
 8001936:	2800      	cmp	r0, #0
 8001938:	d008      	beq.n	800194c <__iar_annotation$$branch+0x8e>
 800193a:	2000      	movs	r0, #0
 800193c:	9000      	str	r0, [sp, #0]
 800193e:	2300      	movs	r3, #0
 8001940:	2223      	movs	r2, #35	; 0x23
 8001942:	7b20      	ldrb	r0, [r4, #12]
 8001944:	07c1      	lsls	r1, r0, #31
 8001946:	0fc9      	lsrs	r1, r1, #31
 8001948:	2009      	movs	r0, #9
 800194a:	47b8      	blx	r7
 800194c:	2123      	movs	r1, #35	; 0x23
 800194e:	7b22      	ldrb	r2, [r4, #12]
 8001950:	07d0      	lsls	r0, r2, #31
 8001952:	0fc0      	lsrs	r0, r0, #31
 8001954:	68a2      	ldr	r2, [r4, #8]
 8001956:	68d2      	ldr	r2, [r2, #12]
 8001958:	4790      	blx	r2
 800195a:	2001      	movs	r0, #1
 800195c:	6861      	ldr	r1, [r4, #4]
 800195e:	7809      	ldrb	r1, [r1, #0]
 8001960:	08ca      	lsrs	r2, r1, #3
 8001962:	2101      	movs	r1, #1
 8001964:	4011      	ands	r1, r2
 8001966:	68e2      	ldr	r2, [r4, #12]
 8001968:	4010      	ands	r0, r2
 800196a:	f003 fae5 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 800196e:	e037      	b.n	80019e0 <__iar_annotation$$branch>
 8001970:	6860      	ldr	r0, [r4, #4]
 8001972:	e74b      	b.n	800180c <__iar_annotation$$branch+0x23e>
 8001974:	2001      	movs	r0, #1
 8001976:	9000      	str	r0, [sp, #0]
 8001978:	2395      	movs	r3, #149	; 0x95
 800197a:	2209      	movs	r2, #9
 800197c:	2100      	movs	r1, #0
 800197e:	0020      	movs	r0, r4
 8001980:	f001 fef7 	bl	8003772 <PE_Send_CtrlMessage>
 8001984:	2800      	cmp	r0, #0
 8001986:	d12b      	bne.n	80019e0 <__iar_annotation$$branch>
 8001988:	200f      	movs	r0, #15
 800198a:	82e0      	strh	r0, [r4, #22]
 800198c:	48a6      	ldr	r0, [pc, #664]	; (8001c28 <.text_19>)
 800198e:	83b0      	strh	r0, [r6, #28]
 8001990:	251a      	movs	r5, #26
 8001992:	4fa4      	ldr	r7, [pc, #656]	; (8001c24 <.text_18>)
 8001994:	7838      	ldrb	r0, [r7, #0]
 8001996:	0780      	lsls	r0, r0, #30
 8001998:	d509      	bpl.n	80019ae <__iar_annotation$$branch+0xf0>
 800199a:	2000      	movs	r0, #0
 800199c:	9000      	str	r0, [sp, #0]
 800199e:	2300      	movs	r3, #0
 80019a0:	2221      	movs	r2, #33	; 0x21
 80019a2:	7b20      	ldrb	r0, [r4, #12]
 80019a4:	07c1      	lsls	r1, r0, #31
 80019a6:	0fc9      	lsrs	r1, r1, #31
 80019a8:	2009      	movs	r0, #9
 80019aa:	68ff      	ldr	r7, [r7, #12]
 80019ac:	47b8      	blx	r7
 80019ae:	2121      	movs	r1, #33	; 0x21
 80019b0:	e0e7      	b.n	8001b82 <__iar_annotation$$branch>
 80019b2:	8bb2      	ldrh	r2, [r6, #28]
 80019b4:	03ab      	lsls	r3, r5, #14
 80019b6:	429a      	cmp	r2, r3
 80019b8:	d100      	bne.n	80019bc <__iar_annotation$$branch+0xfe>
 80019ba:	e0e8      	b.n	8001b8e <__iar_annotation$$branch+0xc>
 80019bc:	2914      	cmp	r1, #20
 80019be:	d00f      	beq.n	80019e0 <__iar_annotation$$branch>
 80019c0:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80019c2:	0bc9      	lsrs	r1, r1, #15
 80019c4:	d10c      	bne.n	80019e0 <__iar_annotation$$branch>
 80019c6:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80019c8:	0b09      	lsrs	r1, r1, #12
 80019ca:	0749      	lsls	r1, r1, #29
 80019cc:	d108      	bne.n	80019e0 <__iar_annotation$$branch>
 80019ce:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80019d0:	06c9      	lsls	r1, r1, #27
 80019d2:	0ec9      	lsrs	r1, r1, #27
 80019d4:	2903      	cmp	r1, #3
 80019d6:	d005      	beq.n	80019e4 <__iar_annotation$$branch+0x4>
 80019d8:	2904      	cmp	r1, #4
 80019da:	d052      	beq.n	8001a82 <__iar_annotation$$branch+0xa2>
 80019dc:	290c      	cmp	r1, #12
 80019de:	d03c      	beq.n	8001a5a <__iar_annotation$$branch+0x7a>

080019e0 <__iar_annotation$$branch>:
 80019e0:	f7fe fff0 	bl	80009c4 <__iar_annotation$$branch+0x1e8>
 80019e4:	6861      	ldr	r1, [r4, #4]
 80019e6:	780a      	ldrb	r2, [r1, #0]
 80019e8:	08d3      	lsrs	r3, r2, #3
 80019ea:	07db      	lsls	r3, r3, #31
 80019ec:	d410      	bmi.n	8001a10 <__iar_annotation$$branch+0x30>
 80019ee:	2308      	movs	r3, #8
 80019f0:	4313      	orrs	r3, r2
 80019f2:	700b      	strb	r3, [r1, #0]
 80019f4:	2800      	cmp	r0, #0
 80019f6:	d009      	beq.n	8001a0c <__iar_annotation$$branch+0x2c>
 80019f8:	2000      	movs	r0, #0
 80019fa:	9000      	str	r0, [sp, #0]
 80019fc:	2300      	movs	r3, #0
 80019fe:	2224      	movs	r2, #36	; 0x24
 8001a00:	7b20      	ldrb	r0, [r4, #12]
 8001a02:	07c1      	lsls	r1, r0, #31
 8001a04:	0fc9      	lsrs	r1, r1, #31
 8001a06:	2009      	movs	r0, #9
 8001a08:	9f01      	ldr	r7, [sp, #4]
 8001a0a:	47b8      	blx	r7
 8001a0c:	2124      	movs	r1, #36	; 0x24
 8001a0e:	e00f      	b.n	8001a30 <__iar_annotation$$branch+0x50>
 8001a10:	23f7      	movs	r3, #247	; 0xf7
 8001a12:	4013      	ands	r3, r2
 8001a14:	700b      	strb	r3, [r1, #0]
 8001a16:	2800      	cmp	r0, #0
 8001a18:	d009      	beq.n	8001a2e <__iar_annotation$$branch+0x4e>
 8001a1a:	2000      	movs	r0, #0
 8001a1c:	9000      	str	r0, [sp, #0]
 8001a1e:	2300      	movs	r3, #0
 8001a20:	2223      	movs	r2, #35	; 0x23
 8001a22:	7b20      	ldrb	r0, [r4, #12]
 8001a24:	07c1      	lsls	r1, r0, #31
 8001a26:	0fc9      	lsrs	r1, r1, #31
 8001a28:	2009      	movs	r0, #9
 8001a2a:	9f01      	ldr	r7, [sp, #4]
 8001a2c:	47b8      	blx	r7
 8001a2e:	2123      	movs	r1, #35	; 0x23
 8001a30:	7b22      	ldrb	r2, [r4, #12]
 8001a32:	07d0      	lsls	r0, r2, #31
 8001a34:	0fc0      	lsrs	r0, r0, #31
 8001a36:	68a2      	ldr	r2, [r4, #8]
 8001a38:	68d2      	ldr	r2, [r2, #12]
 8001a3a:	4790      	blx	r2
 8001a3c:	2001      	movs	r0, #1
 8001a3e:	6861      	ldr	r1, [r4, #4]
 8001a40:	7809      	ldrb	r1, [r1, #0]
 8001a42:	08ca      	lsrs	r2, r1, #3
 8001a44:	2101      	movs	r1, #1
 8001a46:	4011      	ands	r1, r2
 8001a48:	68e2      	ldr	r2, [r4, #12]
 8001a4a:	4010      	ands	r0, r2
 8001a4c:	f003 fa74 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 8001a50:	2000      	movs	r0, #0
 8001a52:	83b0      	strh	r0, [r6, #28]
 8001a54:	2003      	movs	r0, #3
 8001a56:	7230      	strb	r0, [r6, #8]
 8001a58:	e716      	b.n	8001888 <__iar_annotation$$branch+0x2ba>
 8001a5a:	2800      	cmp	r0, #0
 8001a5c:	d009      	beq.n	8001a72 <__iar_annotation$$branch+0x92>
 8001a5e:	2000      	movs	r0, #0
 8001a60:	9000      	str	r0, [sp, #0]
 8001a62:	2300      	movs	r3, #0
 8001a64:	2225      	movs	r2, #37	; 0x25
 8001a66:	7b20      	ldrb	r0, [r4, #12]
 8001a68:	07c1      	lsls	r1, r0, #31
 8001a6a:	0fc9      	lsrs	r1, r1, #31
 8001a6c:	2009      	movs	r0, #9
 8001a6e:	9f01      	ldr	r7, [sp, #4]
 8001a70:	47b8      	blx	r7
 8001a72:	2125      	movs	r1, #37	; 0x25
 8001a74:	7b22      	ldrb	r2, [r4, #12]
 8001a76:	07d0      	lsls	r0, r2, #31
 8001a78:	0fc0      	lsrs	r0, r0, #31
 8001a7a:	68a2      	ldr	r2, [r4, #8]
 8001a7c:	68d2      	ldr	r2, [r2, #12]
 8001a7e:	4790      	blx	r2
 8001a80:	e7e6      	b.n	8001a50 <__iar_annotation$$branch+0x70>
 8001a82:	2800      	cmp	r0, #0
 8001a84:	d009      	beq.n	8001a9a <__iar_annotation$$branch+0xba>
 8001a86:	2000      	movs	r0, #0
 8001a88:	9000      	str	r0, [sp, #0]
 8001a8a:	2300      	movs	r3, #0
 8001a8c:	2226      	movs	r2, #38	; 0x26
 8001a8e:	7b20      	ldrb	r0, [r4, #12]
 8001a90:	07c1      	lsls	r1, r0, #31
 8001a92:	0fc9      	lsrs	r1, r1, #31
 8001a94:	2009      	movs	r0, #9
 8001a96:	9f01      	ldr	r7, [sp, #4]
 8001a98:	47b8      	blx	r7
 8001a9a:	2126      	movs	r1, #38	; 0x26
 8001a9c:	7b22      	ldrb	r2, [r4, #12]
 8001a9e:	07d0      	lsls	r0, r2, #31
 8001aa0:	0fc0      	lsrs	r0, r0, #31
 8001aa2:	68a2      	ldr	r2, [r4, #8]
 8001aa4:	68d2      	ldr	r2, [r2, #12]
 8001aa6:	4790      	blx	r2
 8001aa8:	e7d2      	b.n	8001a50 <__iar_annotation$$branch+0x70>
 8001aaa:	2000      	movs	r0, #0
 8001aac:	9002      	str	r0, [sp, #8]
 8001aae:	2003      	movs	r0, #3
 8001ab0:	9001      	str	r0, [sp, #4]
 8001ab2:	2001      	movs	r0, #1
 8001ab4:	9000      	str	r0, [sp, #0]
 8001ab6:	20e3      	movs	r0, #227	; 0xe3
 8001ab8:	0080      	lsls	r0, r0, #2
 8001aba:	1823      	adds	r3, r4, r0
 8001abc:	2206      	movs	r2, #6
 8001abe:	2100      	movs	r1, #0
 8001ac0:	0020      	movs	r0, r4
 8001ac2:	f001 fe9d 	bl	8003800 <PE_Send_DataMessage>
 8001ac6:	e78b      	b.n	80019e0 <__iar_annotation$$branch>
 8001ac8:	ab06      	add	r3, sp, #24
 8001aca:	aa05      	add	r2, sp, #20
 8001acc:	210a      	movs	r1, #10
 8001ace:	a80a      	add	r0, sp, #40	; 0x28
 8001ad0:	7800      	ldrb	r0, [r0, #0]
 8001ad2:	68a7      	ldr	r7, [r4, #8]
 8001ad4:	69bf      	ldr	r7, [r7, #24]
 8001ad6:	47b8      	blx	r7
 8001ad8:	2700      	movs	r7, #0
 8001ada:	76e7      	strb	r7, [r4, #27]
 8001adc:	76a7      	strb	r7, [r4, #26]
 8001ade:	7b21      	ldrb	r1, [r4, #12]
 8001ae0:	07c8      	lsls	r0, r1, #31
 8001ae2:	0fc0      	lsrs	r0, r0, #31
 8001ae4:	f002 fcde 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8001ae8:	2800      	cmp	r0, #0
 8001aea:	d103      	bne.n	8001af4 <__iar_annotation$$branch+0x114>
 8001aec:	8b60      	ldrh	r0, [r4, #26]
 8001aee:	03a9      	lsls	r1, r5, #14
 8001af0:	4301      	orrs	r1, r0
 8001af2:	8361      	strh	r1, [r4, #26]
 8001af4:	9805      	ldr	r0, [sp, #20]
 8001af6:	00f9      	lsls	r1, r7, #3
 8001af8:	40c8      	lsrs	r0, r1
 8001afa:	0021      	movs	r1, r4
 8001afc:	311c      	adds	r1, #28
 8001afe:	55c8      	strb	r0, [r1, r7]
 8001b00:	1c7f      	adds	r7, r7, #1
 8001b02:	2f04      	cmp	r7, #4
 8001b04:	dbf6      	blt.n	8001af4 <__iar_annotation$$branch+0x114>
 8001b06:	2000      	movs	r0, #0
 8001b08:	9002      	str	r0, [sp, #8]
 8001b0a:	2003      	movs	r0, #3
 8001b0c:	9001      	str	r0, [sp, #4]
 8001b0e:	2008      	movs	r0, #8
 8001b10:	9000      	str	r0, [sp, #0]
 8001b12:	0023      	movs	r3, r4
 8001b14:	3318      	adds	r3, #24
 8001b16:	228c      	movs	r2, #140	; 0x8c
 8001b18:	2100      	movs	r1, #0
 8001b1a:	0020      	movs	r0, r4
 8001b1c:	f002 fcd2 	bl	80044c4 <PE_Send_ExtendedMessage>
 8001b20:	4f40      	ldr	r7, [pc, #256]	; (8001c24 <.text_18>)
 8001b22:	7838      	ldrb	r0, [r7, #0]
 8001b24:	0780      	lsls	r0, r0, #30
 8001b26:	d509      	bpl.n	8001b3c <__iar_annotation$$branch+0x15c>
 8001b28:	2000      	movs	r0, #0
 8001b2a:	9000      	str	r0, [sp, #0]
 8001b2c:	2300      	movs	r3, #0
 8001b2e:	2249      	movs	r2, #73	; 0x49
 8001b30:	7b20      	ldrb	r0, [r4, #12]
 8001b32:	07c1      	lsls	r1, r0, #31
 8001b34:	0fc9      	lsrs	r1, r1, #31
 8001b36:	2009      	movs	r0, #9
 8001b38:	68ff      	ldr	r7, [r7, #12]
 8001b3a:	47b8      	blx	r7
 8001b3c:	2149      	movs	r1, #73	; 0x49
 8001b3e:	e020      	b.n	8001b82 <__iar_annotation$$branch>
 8001b40:	20e5      	movs	r0, #229	; 0xe5
 8001b42:	0080      	lsls	r0, r0, #2
 8001b44:	1827      	adds	r7, r4, r0
 8001b46:	2001      	movs	r0, #1
 8001b48:	9000      	str	r0, [sp, #0]
 8001b4a:	2339      	movs	r3, #57	; 0x39
 8001b4c:	783a      	ldrb	r2, [r7, #0]
 8001b4e:	7971      	ldrb	r1, [r6, #5]
 8001b50:	0020      	movs	r0, r4
 8001b52:	f001 fe0e 	bl	8003772 <PE_Send_CtrlMessage>
 8001b56:	2800      	cmp	r0, #0
 8001b58:	d128      	bne.n	8001bac <__iar_annotation$$branch+0x2a>
 8001b5a:	8878      	ldrh	r0, [r7, #2]
 8001b5c:	82e0      	strh	r0, [r4, #22]
 8001b5e:	4832      	ldr	r0, [pc, #200]	; (8001c28 <.text_19>)
 8001b60:	83b0      	strh	r0, [r6, #28]
 8001b62:	251a      	movs	r5, #26
 8001b64:	4f2f      	ldr	r7, [pc, #188]	; (8001c24 <.text_18>)
 8001b66:	7838      	ldrb	r0, [r7, #0]
 8001b68:	0780      	lsls	r0, r0, #30
 8001b6a:	d509      	bpl.n	8001b80 <__iar_annotation$$branch+0x1a0>
 8001b6c:	2000      	movs	r0, #0
 8001b6e:	9000      	str	r0, [sp, #0]
 8001b70:	2300      	movs	r3, #0
 8001b72:	2241      	movs	r2, #65	; 0x41
 8001b74:	7b20      	ldrb	r0, [r4, #12]
 8001b76:	07c1      	lsls	r1, r0, #31
 8001b78:	0fc9      	lsrs	r1, r1, #31
 8001b7a:	2009      	movs	r0, #9
 8001b7c:	68ff      	ldr	r7, [r7, #12]
 8001b7e:	47b8      	blx	r7
 8001b80:	2141      	movs	r1, #65	; 0x41

08001b82 <__iar_annotation$$branch>:
 8001b82:	f7fe ffb3 	bl	8000aec <__iar_annotation$$branch+0xf4>
 8001b86:	8bb0      	ldrh	r0, [r6, #28]
 8001b88:	03aa      	lsls	r2, r5, #14
 8001b8a:	4290      	cmp	r0, r2
 8001b8c:	d102      	bne.n	8001b94 <__iar_annotation$$branch+0x12>
 8001b8e:	2000      	movs	r0, #0
 8001b90:	83b0      	strh	r0, [r6, #28]
 8001b92:	e02e      	b.n	8001bf2 <__iar_annotation$$branch>
 8001b94:	2914      	cmp	r1, #20
 8001b96:	d009      	beq.n	8001bac <__iar_annotation$$branch+0x2a>
 8001b98:	2000      	movs	r0, #0
 8001b9a:	83b0      	strh	r0, [r6, #28]
 8001b9c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001b9e:	0bc0      	lsrs	r0, r0, #15
 8001ba0:	d027      	beq.n	8001bf2 <__iar_annotation$$branch>
 8001ba2:	e65f      	b.n	8001864 <__iar_annotation$$branch+0x296>
 8001ba4:	0020      	movs	r0, r4
 8001ba6:	f002 fce0 	bl	800456a <PE_SubStateMachine_ExtendedMessages>
 8001baa:	0005      	movs	r5, r0
 8001bac:	e718      	b.n	80019e0 <__iar_annotation$$branch>
 8001bae:	a903      	add	r1, sp, #12
 8001bb0:	0020      	movs	r0, r4
 8001bb2:	f002 fdf1 	bl	8004798 <PE_SubStateMachine_Generic>
 8001bb6:	e7f8      	b.n	8001baa <__iar_annotation$$branch+0x28>
 8001bb8:	a903      	add	r1, sp, #12
 8001bba:	0020      	movs	r0, r4
 8001bbc:	f002 ff5e 	bl	8004a7c <PE_SubStateMachine_VconnSwap>
 8001bc0:	0005      	movs	r5, r0
 8001bc2:	6860      	ldr	r0, [r4, #4]
 8001bc4:	6800      	ldr	r0, [r0, #0]
 8001bc6:	0340      	lsls	r0, r0, #13
 8001bc8:	0fc1      	lsrs	r1, r0, #31
 8001bca:	a80a      	add	r0, sp, #40	; 0x28
 8001bcc:	7800      	ldrb	r0, [r0, #0]
 8001bce:	f003 f9e4 	bl	8004f9a <USBPD_PRL_CableCapable>
 8001bd2:	e705      	b.n	80019e0 <__iar_annotation$$branch>
 8001bd4:	2106      	movs	r1, #6
 8001bd6:	a80a      	add	r0, sp, #40	; 0x28
 8001bd8:	7800      	ldrb	r0, [r0, #0]
 8001bda:	f008 f8d3 	bl	8009d84 <USBPD_PHY_ResetRequest>
 8001bde:	2007      	movs	r0, #7
 8001be0:	6861      	ldr	r1, [r4, #4]
 8001be2:	7849      	ldrb	r1, [r1, #1]
 8001be4:	0909      	lsrs	r1, r1, #4
 8001be6:	2207      	movs	r2, #7
 8001be8:	400a      	ands	r2, r1
 8001bea:	2a03      	cmp	r2, #3
 8001bec:	d001      	beq.n	8001bf2 <__iar_annotation$$branch>

08001bee <__iar_annotation$$branch>:
 8001bee:	f7fe fe67 	bl	80008c0 <__iar_annotation$$branch+0xe4>

08001bf2 <__iar_annotation$$branch>:
 8001bf2:	f7ff f91c 	bl	8000e2e <__iar_annotation$$branch+0x436>
 8001bf6:	7a30      	ldrb	r0, [r6, #8]
 8001bf8:	2803      	cmp	r0, #3
 8001bfa:	d110      	bne.n	8001c1e <__iar_annotation$$branch>
 8001bfc:	200e      	movs	r0, #14
 8001bfe:	5e30      	ldrsh	r0, [r6, r0]
 8001c00:	2800      	cmp	r0, #0
 8001c02:	d00c      	beq.n	8001c1e <__iar_annotation$$branch>
 8001c04:	2016      	movs	r0, #22
 8001c06:	5e20      	ldrsh	r0, [r4, r0]
 8001c08:	2800      	cmp	r0, #0
 8001c0a:	d108      	bne.n	8001c1e <__iar_annotation$$branch>
 8001c0c:	7b30      	ldrb	r0, [r6, #12]
 8001c0e:	7230      	strb	r0, [r6, #8]
 8001c10:	7b70      	ldrb	r0, [r6, #13]
 8001c12:	72f0      	strb	r0, [r6, #11]
 8001c14:	89f0      	ldrh	r0, [r6, #14]
 8001c16:	82e0      	strh	r0, [r4, #22]
 8001c18:	2000      	movs	r0, #0
 8001c1a:	81f0      	strh	r0, [r6, #14]
 8001c1c:	2501      	movs	r5, #1

08001c1e <__iar_annotation$$branch>:
 8001c1e:	f7fe ff0b 	bl	8000a38 <__iar_annotation$$branch+0x40>
	...

08001c24 <.text_18>:
 8001c24:	200019a8 	.word	0x200019a8

08001c28 <.text_19>:
 8001c28:	0000801a 	.word	0x0000801a

08001c2c <USBPD_PE_StateMachine_SNK>:
 8001c2c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001c2e:	b08f      	sub	sp, #60	; 0x3c
 8001c30:	0005      	movs	r5, r0
 8001c32:	48b3      	ldr	r0, [pc, #716]	; (8001f00 <__iar_annotation$$branch+0xce>)
 8001c34:	00a9      	lsls	r1, r5, #2
 8001c36:	1840      	adds	r0, r0, r1
 8001c38:	6840      	ldr	r0, [r0, #4]
 8001c3a:	9006      	str	r0, [sp, #24]
 8001c3c:	2400      	movs	r4, #0
 8001c3e:	21d9      	movs	r1, #217	; 0xd9
 8001c40:	0089      	lsls	r1, r1, #2
 8001c42:	1840      	adds	r0, r0, r1
 8001c44:	9004      	str	r0, [sp, #16]
 8001c46:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8001c48:	8807      	ldrh	r7, [r0, #0]
 8001c4a:	4668      	mov	r0, sp
 8001c4c:	9904      	ldr	r1, [sp, #16]
 8001c4e:	8849      	ldrh	r1, [r1, #2]
 8001c50:	82c1      	strh	r1, [r0, #22]
 8001c52:	9904      	ldr	r1, [sp, #16]
 8001c54:	8889      	ldrh	r1, [r1, #4]
 8001c56:	8281      	strh	r1, [r0, #20]
 8001c58:	9904      	ldr	r1, [sp, #16]
 8001c5a:	88c9      	ldrh	r1, [r1, #6]
 8001c5c:	81c1      	strh	r1, [r0, #14]
 8001c5e:	9904      	ldr	r1, [sp, #16]
 8001c60:	8909      	ldrh	r1, [r1, #8]
 8001c62:	8141      	strh	r1, [r0, #10]
 8001c64:	9904      	ldr	r1, [sp, #16]
 8001c66:	8949      	ldrh	r1, [r1, #10]
 8001c68:	8101      	strh	r1, [r0, #8]
 8001c6a:	9904      	ldr	r1, [sp, #16]
 8001c6c:	8989      	ldrh	r1, [r1, #12]
 8001c6e:	80c1      	strh	r1, [r0, #6]
 8001c70:	9904      	ldr	r1, [sp, #16]
 8001c72:	89c9      	ldrh	r1, [r1, #14]
 8001c74:	8081      	strh	r1, [r0, #4]
 8001c76:	9904      	ldr	r1, [sp, #16]
 8001c78:	89c9      	ldrh	r1, [r1, #14]
 8001c7a:	8041      	strh	r1, [r0, #2]
 8001c7c:	9904      	ldr	r1, [sp, #16]
 8001c7e:	8a09      	ldrh	r1, [r1, #16]
 8001c80:	8001      	strh	r1, [r0, #0]
 8001c82:	9804      	ldr	r0, [sp, #16]
 8001c84:	8a40      	ldrh	r0, [r0, #18]
 8001c86:	9904      	ldr	r1, [sp, #16]
 8001c88:	8a89      	ldrh	r1, [r1, #20]
 8001c8a:	9a04      	ldr	r2, [sp, #16]
 8001c8c:	8ad2      	ldrh	r2, [r2, #22]
 8001c8e:	9b04      	ldr	r3, [sp, #16]
 8001c90:	8c1b      	ldrh	r3, [r3, #32]
 8001c92:	0536      	lsls	r6, r6, #20
 8001c94:	0d36      	lsrs	r6, r6, #20
 8001c96:	19f6      	adds	r6, r6, r7
 8001c98:	466f      	mov	r7, sp
 8001c9a:	8aff      	ldrh	r7, [r7, #22]
 8001c9c:	19f6      	adds	r6, r6, r7
 8001c9e:	466f      	mov	r7, sp
 8001ca0:	8abf      	ldrh	r7, [r7, #20]
 8001ca2:	19f6      	adds	r6, r6, r7
 8001ca4:	466f      	mov	r7, sp
 8001ca6:	89ff      	ldrh	r7, [r7, #14]
 8001ca8:	19f6      	adds	r6, r6, r7
 8001caa:	466f      	mov	r7, sp
 8001cac:	897f      	ldrh	r7, [r7, #10]
 8001cae:	19f6      	adds	r6, r6, r7
 8001cb0:	466f      	mov	r7, sp
 8001cb2:	893f      	ldrh	r7, [r7, #8]
 8001cb4:	19f6      	adds	r6, r6, r7
 8001cb6:	466f      	mov	r7, sp
 8001cb8:	88ff      	ldrh	r7, [r7, #6]
 8001cba:	19f6      	adds	r6, r6, r7
 8001cbc:	466f      	mov	r7, sp
 8001cbe:	88bf      	ldrh	r7, [r7, #4]
 8001cc0:	19f6      	adds	r6, r6, r7
 8001cc2:	466f      	mov	r7, sp
 8001cc4:	887f      	ldrh	r7, [r7, #2]
 8001cc6:	19f6      	adds	r6, r6, r7
 8001cc8:	466f      	mov	r7, sp
 8001cca:	883f      	ldrh	r7, [r7, #0]
 8001ccc:	19f6      	adds	r6, r6, r7
 8001cce:	1830      	adds	r0, r6, r0
 8001cd0:	1840      	adds	r0, r0, r1
 8001cd2:	1880      	adds	r0, r0, r2
 8001cd4:	0519      	lsls	r1, r3, #20
 8001cd6:	0f49      	lsrs	r1, r1, #29
 8001cd8:	1840      	adds	r0, r0, r1
 8001cda:	9904      	ldr	r1, [sp, #16]
 8001cdc:	8c09      	ldrh	r1, [r1, #32]
 8001cde:	06c9      	lsls	r1, r1, #27
 8001ce0:	0ec9      	lsrs	r1, r1, #27
 8001ce2:	1846      	adds	r6, r0, r1
 8001ce4:	b2b6      	uxth	r6, r6
 8001ce6:	9806      	ldr	r0, [sp, #24]
 8001ce8:	f001 fe68 	bl	80039bc <PE_Check_RxEvent>
 8001cec:	4669      	mov	r1, sp
 8001cee:	7308      	strb	r0, [r1, #12]
 8001cf0:	2803      	cmp	r0, #3
 8001cf2:	d001      	beq.n	8001cf8 <__iar_annotation$$branch+0x4>

08001cf4 <__iar_annotation$$branch>:
 8001cf4:	f001 f97c 	bl	8002ff0 <__iar_annotation$$branch+0xaa0>
 8001cf8:	2001      	movs	r0, #1

08001cfa <__iar_annotation$$branch>:
 8001cfa:	f001 f974 	bl	8002fe6 <__iar_annotation$$branch+0xa96>
 8001cfe:	2400      	movs	r4, #0
 8001d00:	43e4      	mvns	r4, r4
 8001d02:	6868      	ldr	r0, [r5, #4]
 8001d04:	6801      	ldr	r1, [r0, #0]
 8001d06:	2210      	movs	r2, #16
 8001d08:	4391      	bics	r1, r2
 8001d0a:	6001      	str	r1, [r0, #0]

08001d0c <__iar_annotation$$branch>:
 8001d0c:	f001 f8fe 	bl	8002f0c <__iar_annotation$$branch+0x9bc>
 8001d10:	6868      	ldr	r0, [r5, #4]
 8001d12:	6800      	ldr	r0, [r0, #0]
 8001d14:	0340      	lsls	r0, r0, #13
 8001d16:	0fc1      	lsrs	r1, r0, #31
 8001d18:	4668      	mov	r0, sp
 8001d1a:	7b40      	ldrb	r0, [r0, #13]
 8001d1c:	f003 f93d 	bl	8004f9a <USBPD_PRL_CableCapable>
 8001d20:	2701      	movs	r7, #1
 8001d22:	68e9      	ldr	r1, [r5, #12]
 8001d24:	2001      	movs	r0, #1
 8001d26:	4008      	ands	r0, r1
 8001d28:	f003 fb94 	bl	8005454 <USBPD_PRL_Reset>
 8001d2c:	6868      	ldr	r0, [r5, #4]
 8001d2e:	6801      	ldr	r1, [r0, #0]
 8001d30:	0ac9      	lsrs	r1, r1, #11
 8001d32:	4039      	ands	r1, r7
 8001d34:	d0ea      	beq.n	8001d0c <__iar_annotation$$branch>
 8001d36:	2103      	movs	r1, #3
 8001d38:	682a      	ldr	r2, [r5, #0]
 8001d3a:	7913      	ldrb	r3, [r2, #4]
 8001d3c:	2203      	movs	r2, #3
 8001d3e:	401a      	ands	r2, r3
 8001d40:	7803      	ldrb	r3, [r0, #0]
 8001d42:	24fc      	movs	r4, #252	; 0xfc
 8001d44:	401c      	ands	r4, r3
 8001d46:	4322      	orrs	r2, r4
 8001d48:	7002      	strb	r2, [r0, #0]
 8001d4a:	6868      	ldr	r0, [r5, #4]
 8001d4c:	7802      	ldrb	r2, [r0, #0]
 8001d4e:	4011      	ands	r1, r2
 8001d50:	2901      	cmp	r1, #1
 8001d52:	d100      	bne.n	8001d56 <__iar_annotation$$branch+0x4a>
 8001d54:	2700      	movs	r7, #0
 8001d56:	219f      	movs	r1, #159	; 0x9f
 8001d58:	4011      	ands	r1, r2
 8001d5a:	017a      	lsls	r2, r7, #5
 8001d5c:	430a      	orrs	r2, r1
 8001d5e:	7002      	strb	r2, [r0, #0]
 8001d60:	48b3      	ldr	r0, [pc, #716]	; (8002030 <__iar_annotation$$branch+0x1fe>)
 8001d62:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001d64:	24fa      	movs	r4, #250	; 0xfa
 8001d66:	0064      	lsls	r4, r4, #1

08001d68 <__iar_annotation$$branch>:
 8001d68:	f001 f8ce 	bl	8002f08 <__iar_annotation$$branch+0x9b8>
 8001d6c:	2911      	cmp	r1, #17
 8001d6e:	d131      	bne.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d70:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d72:	0bc0      	lsrs	r0, r0, #15
 8001d74:	d12e      	bne.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d76:	2707      	movs	r7, #7
 8001d78:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d7a:	0b00      	lsrs	r0, r0, #12
 8001d7c:	4238      	tst	r0, r7
 8001d7e:	d029      	beq.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d80:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d82:	06c0      	lsls	r0, r0, #27
 8001d84:	0ec0      	lsrs	r0, r0, #27
 8001d86:	2801      	cmp	r0, #1
 8001d88:	d124      	bne.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d8a:	2000      	movs	r0, #0
 8001d8c:	7528      	strb	r0, [r5, #20]
 8001d8e:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d90:	0600      	lsls	r0, r0, #24
 8001d92:	0f81      	lsrs	r1, r0, #30
 8001d94:	4668      	mov	r0, sp
 8001d96:	7b40      	ldrb	r0, [r0, #13]
 8001d98:	f002 fb1a 	bl	80043d0 <PE_ExtRevisionInteroperability>
 8001d9c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d9e:	0b00      	lsrs	r0, r0, #12
 8001da0:	4007      	ands	r7, r0
 8001da2:	00bb      	lsls	r3, r7, #2
 8001da4:	209e      	movs	r0, #158	; 0x9e
 8001da6:	0040      	lsls	r0, r0, #1
 8001da8:	182a      	adds	r2, r5, r0
 8001daa:	2104      	movs	r1, #4
 8001dac:	7b2f      	ldrb	r7, [r5, #12]
 8001dae:	07f8      	lsls	r0, r7, #31
 8001db0:	0fc0      	lsrs	r0, r0, #31
 8001db2:	68af      	ldr	r7, [r5, #8]
 8001db4:	69ff      	ldr	r7, [r7, #28]
 8001db6:	47b8      	blx	r7
 8001db8:	2001      	movs	r0, #1
 8001dba:	82e8      	strh	r0, [r5, #22]
 8001dbc:	2044      	movs	r0, #68	; 0x44
 8001dbe:	7130      	strb	r0, [r6, #4]
 8001dc0:	6868      	ldr	r0, [r5, #4]
 8001dc2:	6801      	ldr	r1, [r0, #0]
 8001dc4:	2210      	movs	r2, #16
 8001dc6:	4391      	bics	r1, r2
 8001dc8:	6001      	str	r1, [r0, #0]
 8001dca:	2000      	movs	r0, #0
 8001dcc:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001dce:	2014      	movs	r0, #20
 8001dd0:	4669      	mov	r1, sp
 8001dd2:	7308      	strb	r0, [r1, #12]
 8001dd4:	8cf0      	ldrh	r0, [r6, #38]	; 0x26
 8001dd6:	03a1      	lsls	r1, r4, #14
 8001dd8:	4288      	cmp	r0, r1
 8001dda:	d197      	bne.n	8001d0c <__iar_annotation$$branch>
 8001ddc:	6868      	ldr	r0, [r5, #4]
 8001dde:	6801      	ldr	r1, [r0, #0]
 8001de0:	2210      	movs	r2, #16
 8001de2:	4391      	bics	r1, r2
 8001de4:	6001      	str	r1, [r0, #0]
 8001de6:	2000      	movs	r0, #0
 8001de8:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001dea:	e241      	b.n	8002270 <__iar_annotation$$branch>
 8001dec:	2001      	movs	r0, #1
 8001dee:	82e8      	strh	r0, [r5, #22]
 8001df0:	466a      	mov	r2, sp
 8001df2:	0029      	movs	r1, r5
 8001df4:	3110      	adds	r1, #16
 8001df6:	68eb      	ldr	r3, [r5, #12]
 8001df8:	4018      	ands	r0, r3
 8001dfa:	68ab      	ldr	r3, [r5, #8]
 8001dfc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001dfe:	4798      	blx	r3
 8001e00:	7b28      	ldrb	r0, [r5, #12]
 8001e02:	21f3      	movs	r1, #243	; 0xf3
 8001e04:	4001      	ands	r1, r0
 8001e06:	4668      	mov	r0, sp
 8001e08:	7800      	ldrb	r0, [r0, #0]
 8001e0a:	0080      	lsls	r0, r0, #2
 8001e0c:	220c      	movs	r2, #12
 8001e0e:	4002      	ands	r2, r0
 8001e10:	430a      	orrs	r2, r1
 8001e12:	732a      	strb	r2, [r5, #12]
 8001e14:	2045      	movs	r0, #69	; 0x45
 8001e16:	e181      	b.n	800211c <__iar_annotation$$branch+0x2ea>
 8001e18:	2000      	movs	r0, #0
 8001e1a:	9002      	str	r0, [sp, #8]
 8001e1c:	2046      	movs	r0, #70	; 0x46
 8001e1e:	9001      	str	r0, [sp, #4]
 8001e20:	2001      	movs	r0, #1
 8001e22:	9000      	str	r0, [sp, #0]
 8001e24:	002b      	movs	r3, r5
 8001e26:	3310      	adds	r3, #16
 8001e28:	2202      	movs	r2, #2
 8001e2a:	2100      	movs	r1, #0
 8001e2c:	0028      	movs	r0, r5
 8001e2e:	f001 fce7 	bl	8003800 <PE_Send_DataMessage>

08001e32 <__iar_annotation$$branch>:
 8001e32:	f000 fff6 	bl	8002e22 <__iar_annotation$$branch+0x8d2>
 8001e36:	2911      	cmp	r1, #17
 8001e38:	d111      	bne.n	8001e5e <__iar_annotation$$branch+0x2c>
 8001e3a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001e3c:	0bc9      	lsrs	r1, r1, #15
 8001e3e:	d10e      	bne.n	8001e5e <__iar_annotation$$branch+0x2c>
 8001e40:	2107      	movs	r1, #7
 8001e42:	8e32      	ldrh	r2, [r6, #48]	; 0x30
 8001e44:	0b12      	lsrs	r2, r2, #12
 8001e46:	420a      	tst	r2, r1
 8001e48:	d109      	bne.n	8001e5e <__iar_annotation$$branch+0x2c>
 8001e4a:	8e32      	ldrh	r2, [r6, #48]	; 0x30
 8001e4c:	06d2      	lsls	r2, r2, #27
 8001e4e:	0ed2      	lsrs	r2, r2, #27
 8001e50:	1e92      	subs	r2, r2, #2
 8001e52:	2a01      	cmp	r2, #1
 8001e54:	d904      	bls.n	8001e60 <__iar_annotation$$branch+0x2e>
 8001e56:	1e92      	subs	r2, r2, #2
 8001e58:	d026      	beq.n	8001ea8 <__iar_annotation$$branch+0x76>
 8001e5a:	3a08      	subs	r2, #8
 8001e5c:	d024      	beq.n	8001ea8 <__iar_annotation$$branch+0x76>
 8001e5e:	e08a      	b.n	8001f76 <__iar_annotation$$branch+0x144>
 8001e60:	2100      	movs	r1, #0
 8001e62:	8331      	strh	r1, [r6, #24]
 8001e64:	8471      	strh	r1, [r6, #34]	; 0x22
 8001e66:	2147      	movs	r1, #71	; 0x47
 8001e68:	7131      	strb	r1, [r6, #4]
 8001e6a:	4971      	ldr	r1, [pc, #452]	; (8002030 <__iar_annotation$$branch+0x1fe>)
 8001e6c:	8471      	strh	r1, [r6, #34]	; 0x22
 8001e6e:	24fa      	movs	r4, #250	; 0xfa
 8001e70:	0064      	lsls	r4, r4, #1
 8001e72:	6869      	ldr	r1, [r5, #4]
 8001e74:	784a      	ldrb	r2, [r1, #1]
 8001e76:	238f      	movs	r3, #143	; 0x8f
 8001e78:	4013      	ands	r3, r2
 8001e7a:	2240      	movs	r2, #64	; 0x40
 8001e7c:	431a      	orrs	r2, r3
 8001e7e:	704a      	strb	r2, [r1, #1]
 8001e80:	2800      	cmp	r0, #0
 8001e82:	d009      	beq.n	8001e98 <__iar_annotation$$branch+0x66>
 8001e84:	2000      	movs	r0, #0
 8001e86:	9000      	str	r0, [sp, #0]
 8001e88:	2300      	movs	r3, #0
 8001e8a:	2256      	movs	r2, #86	; 0x56
 8001e8c:	7b28      	ldrb	r0, [r5, #12]
 8001e8e:	07c1      	lsls	r1, r0, #31
 8001e90:	0fc9      	lsrs	r1, r1, #31
 8001e92:	2009      	movs	r0, #9
 8001e94:	9f01      	ldr	r7, [sp, #4]
 8001e96:	47b8      	blx	r7
 8001e98:	2156      	movs	r1, #86	; 0x56
 8001e9a:	7b2a      	ldrb	r2, [r5, #12]
 8001e9c:	07d0      	lsls	r0, r2, #31
 8001e9e:	0fc0      	lsrs	r0, r0, #31
 8001ea0:	68aa      	ldr	r2, [r5, #8]
 8001ea2:	68d2      	ldr	r2, [r2, #12]
 8001ea4:	4790      	blx	r2
 8001ea6:	e016      	b.n	8001ed6 <__iar_annotation$$branch+0xa4>
 8001ea8:	2400      	movs	r4, #0
 8001eaa:	8474      	strh	r4, [r6, #34]	; 0x22
 8001eac:	6868      	ldr	r0, [r5, #4]
 8001eae:	7840      	ldrb	r0, [r0, #1]
 8001eb0:	0900      	lsrs	r0, r0, #4
 8001eb2:	4001      	ands	r1, r0
 8001eb4:	2903      	cmp	r1, #3
 8001eb6:	d005      	beq.n	8001ec4 <__iar_annotation$$branch+0x92>
 8001eb8:	485d      	ldr	r0, [pc, #372]	; (8002030 <__iar_annotation$$branch+0x1fe>)
 8001eba:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001ebc:	24fa      	movs	r4, #250	; 0xfa
 8001ebe:	0064      	lsls	r4, r4, #1
 8001ec0:	2043      	movs	r0, #67	; 0x43
 8001ec2:	e007      	b.n	8001ed4 <__iar_annotation$$branch+0xa2>
 8001ec4:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001ec6:	06c0      	lsls	r0, r0, #27
 8001ec8:	0ec0      	lsrs	r0, r0, #27
 8001eca:	280c      	cmp	r0, #12
 8001ecc:	d101      	bne.n	8001ed2 <__iar_annotation$$branch+0xa0>
 8001ece:	2049      	movs	r0, #73	; 0x49
 8001ed0:	e000      	b.n	8001ed4 <__iar_annotation$$branch+0xa2>
 8001ed2:	2003      	movs	r0, #3
 8001ed4:	7130      	strb	r0, [r6, #4]
 8001ed6:	2014      	movs	r0, #20
 8001ed8:	4669      	mov	r1, sp
 8001eda:	7308      	strb	r0, [r1, #12]
 8001edc:	4808      	ldr	r0, [pc, #32]	; (8001f00 <__iar_annotation$$branch+0xce>)
 8001ede:	68c7      	ldr	r7, [r0, #12]
 8001ee0:	7800      	ldrb	r0, [r0, #0]
 8001ee2:	2102      	movs	r1, #2
 8001ee4:	4008      	ands	r0, r1
 8001ee6:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001ee8:	06c9      	lsls	r1, r1, #27
 8001eea:	0ec9      	lsrs	r1, r1, #27
 8001eec:	2902      	cmp	r1, #2
 8001eee:	d016      	beq.n	8001f1e <__iar_annotation$$branch+0xec>
 8001ef0:	2903      	cmp	r1, #3
 8001ef2:	d007      	beq.n	8001f04 <__iar_annotation$$branch+0xd2>
 8001ef4:	2904      	cmp	r1, #4
 8001ef6:	d01f      	beq.n	8001f38 <__iar_annotation$$branch+0x106>
 8001ef8:	290c      	cmp	r1, #12
 8001efa:	d02a      	beq.n	8001f52 <__iar_annotation$$branch+0x120>
 8001efc:	e03b      	b.n	8001f76 <__iar_annotation$$branch+0x144>
 8001efe:	bf00      	nop
 8001f00:	200019a8 	.word	0x200019a8
 8001f04:	2800      	cmp	r0, #0
 8001f06:	d008      	beq.n	8001f1a <__iar_annotation$$branch+0xe8>
 8001f08:	2000      	movs	r0, #0
 8001f0a:	9000      	str	r0, [sp, #0]
 8001f0c:	2300      	movs	r3, #0
 8001f0e:	2201      	movs	r2, #1
 8001f10:	7b28      	ldrb	r0, [r5, #12]
 8001f12:	07c1      	lsls	r1, r0, #31
 8001f14:	0fc9      	lsrs	r1, r1, #31
 8001f16:	2009      	movs	r0, #9
 8001f18:	47b8      	blx	r7
 8001f1a:	2101      	movs	r1, #1
 8001f1c:	e025      	b.n	8001f6a <__iar_annotation$$branch+0x138>
 8001f1e:	2800      	cmp	r0, #0
 8001f20:	d008      	beq.n	8001f34 <__iar_annotation$$branch+0x102>
 8001f22:	2000      	movs	r0, #0
 8001f24:	9000      	str	r0, [sp, #0]
 8001f26:	2300      	movs	r3, #0
 8001f28:	2204      	movs	r2, #4
 8001f2a:	7b28      	ldrb	r0, [r5, #12]
 8001f2c:	07c1      	lsls	r1, r0, #31
 8001f2e:	0fc9      	lsrs	r1, r1, #31
 8001f30:	2009      	movs	r0, #9
 8001f32:	47b8      	blx	r7
 8001f34:	2104      	movs	r1, #4
 8001f36:	e018      	b.n	8001f6a <__iar_annotation$$branch+0x138>
 8001f38:	2800      	cmp	r0, #0
 8001f3a:	d008      	beq.n	8001f4e <__iar_annotation$$branch+0x11c>
 8001f3c:	2000      	movs	r0, #0
 8001f3e:	9000      	str	r0, [sp, #0]
 8001f40:	2300      	movs	r3, #0
 8001f42:	2202      	movs	r2, #2
 8001f44:	7b28      	ldrb	r0, [r5, #12]
 8001f46:	07c1      	lsls	r1, r0, #31
 8001f48:	0fc9      	lsrs	r1, r1, #31
 8001f4a:	2009      	movs	r0, #9
 8001f4c:	47b8      	blx	r7
 8001f4e:	2102      	movs	r1, #2
 8001f50:	e00b      	b.n	8001f6a <__iar_annotation$$branch+0x138>
 8001f52:	2800      	cmp	r0, #0
 8001f54:	d008      	beq.n	8001f68 <__iar_annotation$$branch+0x136>
 8001f56:	2000      	movs	r0, #0
 8001f58:	9000      	str	r0, [sp, #0]
 8001f5a:	2300      	movs	r3, #0
 8001f5c:	2203      	movs	r2, #3
 8001f5e:	7b28      	ldrb	r0, [r5, #12]
 8001f60:	07c1      	lsls	r1, r0, #31
 8001f62:	0fc9      	lsrs	r1, r1, #31
 8001f64:	2009      	movs	r0, #9
 8001f66:	47b8      	blx	r7
 8001f68:	2103      	movs	r1, #3
 8001f6a:	7b2a      	ldrb	r2, [r5, #12]
 8001f6c:	07d0      	lsls	r0, r2, #31
 8001f6e:	0fc0      	lsrs	r0, r0, #31
 8001f70:	68aa      	ldr	r2, [r5, #8]
 8001f72:	68d2      	ldr	r2, [r2, #12]
 8001f74:	4790      	blx	r2
 8001f76:	8b30      	ldrh	r0, [r6, #24]
 8001f78:	2180      	movs	r1, #128	; 0x80
 8001f7a:	0209      	lsls	r1, r1, #8
 8001f7c:	4288      	cmp	r0, r1
 8001f7e:	d000      	beq.n	8001f82 <__iar_annotation$$branch+0x150>
 8001f80:	e6c4      	b.n	8001d0c <__iar_annotation$$branch>
 8001f82:	2400      	movs	r4, #0
 8001f84:	8334      	strh	r4, [r6, #24]
 8001f86:	e173      	b.n	8002270 <__iar_annotation$$branch>
 8001f88:	2911      	cmp	r1, #17
 8001f8a:	d148      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001f8c:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001f8e:	0bc9      	lsrs	r1, r1, #15
 8001f90:	d145      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001f92:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001f94:	0b09      	lsrs	r1, r1, #12
 8001f96:	0749      	lsls	r1, r1, #29
 8001f98:	d141      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001f9a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001f9c:	06c9      	lsls	r1, r1, #27
 8001f9e:	0ec9      	lsrs	r1, r1, #27
 8001fa0:	2906      	cmp	r1, #6
 8001fa2:	d13c      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001fa4:	2400      	movs	r4, #0
 8001fa6:	8474      	strh	r4, [r6, #34]	; 0x22
 8001fa8:	2114      	movs	r1, #20
 8001faa:	466a      	mov	r2, sp
 8001fac:	7311      	strb	r1, [r2, #12]
 8001fae:	6869      	ldr	r1, [r5, #4]
 8001fb0:	784a      	ldrb	r2, [r1, #1]
 8001fb2:	238f      	movs	r3, #143	; 0x8f
 8001fb4:	4013      	ands	r3, r2
 8001fb6:	2230      	movs	r2, #48	; 0x30
 8001fb8:	431a      	orrs	r2, r3
 8001fba:	704a      	strb	r2, [r1, #1]
 8001fbc:	2800      	cmp	r0, #0
 8001fbe:	d008      	beq.n	8001fd2 <__iar_annotation$$branch+0x1a0>
 8001fc0:	9400      	str	r4, [sp, #0]
 8001fc2:	2300      	movs	r3, #0
 8001fc4:	2256      	movs	r2, #86	; 0x56
 8001fc6:	7b28      	ldrb	r0, [r5, #12]
 8001fc8:	07c1      	lsls	r1, r0, #31
 8001fca:	0fc9      	lsrs	r1, r1, #31
 8001fcc:	2009      	movs	r0, #9
 8001fce:	9f01      	ldr	r7, [sp, #4]
 8001fd0:	47b8      	blx	r7
 8001fd2:	2156      	movs	r1, #86	; 0x56
 8001fd4:	7b2a      	ldrb	r2, [r5, #12]
 8001fd6:	07d0      	lsls	r0, r2, #31
 8001fd8:	0fc0      	lsrs	r0, r0, #31
 8001fda:	68aa      	ldr	r2, [r5, #8]
 8001fdc:	68d2      	ldr	r2, [r2, #12]
 8001fde:	4790      	blx	r2
 8001fe0:	82ec      	strh	r4, [r5, #22]
 8001fe2:	2003      	movs	r0, #3
 8001fe4:	7130      	strb	r0, [r6, #4]
 8001fe6:	4fb0      	ldr	r7, [pc, #704]	; (80022a8 <__iar_annotation$$branch+0x38>)
 8001fe8:	7838      	ldrb	r0, [r7, #0]
 8001fea:	0780      	lsls	r0, r0, #30
 8001fec:	d508      	bpl.n	8002000 <__iar_annotation$$branch+0x1ce>
 8001fee:	9400      	str	r4, [sp, #0]
 8001ff0:	2300      	movs	r3, #0
 8001ff2:	2210      	movs	r2, #16
 8001ff4:	7b28      	ldrb	r0, [r5, #12]
 8001ff6:	07c1      	lsls	r1, r0, #31
 8001ff8:	0fc9      	lsrs	r1, r1, #31
 8001ffa:	2009      	movs	r0, #9
 8001ffc:	68ff      	ldr	r7, [r7, #12]
 8001ffe:	47b8      	blx	r7
 8002000:	2110      	movs	r1, #16
 8002002:	7b2a      	ldrb	r2, [r5, #12]
 8002004:	07d0      	lsls	r0, r2, #31
 8002006:	0fc0      	lsrs	r0, r0, #31
 8002008:	68aa      	ldr	r2, [r5, #8]
 800200a:	68d2      	ldr	r2, [r2, #12]
 800200c:	4790      	blx	r2
 800200e:	7b28      	ldrb	r0, [r5, #12]
 8002010:	0700      	lsls	r0, r0, #28
 8002012:	0f80      	lsrs	r0, r0, #30
 8002014:	2803      	cmp	r0, #3
 8002016:	d102      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8002018:	48a4      	ldr	r0, [pc, #656]	; (80022ac <__iar_annotation$$branch+0x3c>)
 800201a:	85b0      	strh	r0, [r6, #44]	; 0x2c
 800201c:	4ca4      	ldr	r4, [pc, #656]	; (80022b0 <__iar_annotation$$branch+0x40>)
 800201e:	8c70      	ldrh	r0, [r6, #34]	; 0x22
 8002020:	2180      	movs	r1, #128	; 0x80
 8002022:	0209      	lsls	r1, r1, #8
 8002024:	4288      	cmp	r0, r1
 8002026:	d000      	beq.n	800202a <__iar_annotation$$branch+0x1f8>
 8002028:	e670      	b.n	8001d0c <__iar_annotation$$branch>
 800202a:	2400      	movs	r4, #0
 800202c:	8474      	strh	r4, [r6, #34]	; 0x22
 800202e:	e11f      	b.n	8002270 <__iar_annotation$$branch>
 8002030:	000081f4 	.word	0x000081f4
 8002034:	7b69      	ldrb	r1, [r5, #13]
 8002036:	22fc      	movs	r2, #252	; 0xfc
 8002038:	400a      	ands	r2, r1
 800203a:	736a      	strb	r2, [r5, #13]
 800203c:	686a      	ldr	r2, [r5, #4]
 800203e:	2110      	movs	r1, #16
 8002040:	6813      	ldr	r3, [r2, #0]
 8002042:	430b      	orrs	r3, r1
 8002044:	6013      	str	r3, [r2, #0]
 8002046:	2200      	movs	r2, #0
 8002048:	82ea      	strh	r2, [r5, #22]
 800204a:	686a      	ldr	r2, [r5, #4]
 800204c:	7853      	ldrb	r3, [r2, #1]
 800204e:	278f      	movs	r7, #143	; 0x8f
 8002050:	401f      	ands	r7, r3
 8002052:	4339      	orrs	r1, r7
 8002054:	7051      	strb	r1, [r2, #1]
 8002056:	2800      	cmp	r0, #0
 8002058:	d009      	beq.n	800206e <__iar_annotation$$branch+0x23c>
 800205a:	2000      	movs	r0, #0
 800205c:	9000      	str	r0, [sp, #0]
 800205e:	2300      	movs	r3, #0
 8002060:	2256      	movs	r2, #86	; 0x56
 8002062:	7b28      	ldrb	r0, [r5, #12]
 8002064:	07c1      	lsls	r1, r0, #31
 8002066:	0fc9      	lsrs	r1, r1, #31
 8002068:	2009      	movs	r0, #9
 800206a:	9f01      	ldr	r7, [sp, #4]
 800206c:	47b8      	blx	r7
 800206e:	2156      	movs	r1, #86	; 0x56
 8002070:	7b2a      	ldrb	r2, [r5, #12]
 8002072:	07d0      	lsls	r0, r2, #31
 8002074:	0fc0      	lsrs	r0, r0, #31
 8002076:	68aa      	ldr	r2, [r5, #8]
 8002078:	68d2      	ldr	r2, [r2, #12]
 800207a:	4790      	blx	r2
 800207c:	2700      	movs	r7, #0
 800207e:	7037      	strb	r7, [r6, #0]
 8002080:	7d28      	ldrb	r0, [r5, #20]
 8002082:	2803      	cmp	r0, #3
 8002084:	d302      	bcc.n	800208c <__iar_annotation$$branch+0x25a>
 8002086:	752f      	strb	r7, [r5, #20]
 8002088:	7137      	strb	r7, [r6, #4]
 800208a:	e3ab      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800208c:	1c40      	adds	r0, r0, #1
 800208e:	7528      	strb	r0, [r5, #20]
 8002090:	0028      	movs	r0, r5
 8002092:	f001 fc1b 	bl	80038cc <PE_Send_HARDRESET>
 8002096:	2101      	movs	r1, #1
 8002098:	4668      	mov	r0, sp
 800209a:	7b40      	ldrb	r0, [r0, #13]
 800209c:	f002 f877 	bl	800418e <PE_Reset>
 80020a0:	6868      	ldr	r0, [r5, #4]
 80020a2:	6801      	ldr	r1, [r0, #0]
 80020a4:	2210      	movs	r2, #16
 80020a6:	430a      	orrs	r2, r1
 80020a8:	6002      	str	r2, [r0, #0]
 80020aa:	4882      	ldr	r0, [pc, #520]	; (80022b4 <__iar_annotation$$branch+0x44>)
 80020ac:	8270      	strh	r0, [r6, #18]
 80020ae:	209b      	movs	r0, #155	; 0x9b
 80020b0:	7130      	strb	r0, [r6, #4]
 80020b2:	e38d      	b.n	80027d0 <__iar_annotation$$branch+0x280>
 80020b4:	68e8      	ldr	r0, [r5, #12]
 80020b6:	4a80      	ldr	r2, [pc, #512]	; (80022b8 <__iar_annotation$$branch+0x48>)
 80020b8:	4002      	ands	r2, r0
 80020ba:	60ea      	str	r2, [r5, #12]
 80020bc:	2401      	movs	r4, #1
 80020be:	6868      	ldr	r0, [r5, #4]
 80020c0:	6800      	ldr	r0, [r0, #0]
 80020c2:	0c80      	lsrs	r0, r0, #18
 80020c4:	4020      	ands	r0, r4
 80020c6:	d007      	beq.n	80020d8 <__iar_annotation$$branch+0x2a6>
 80020c8:	68a8      	ldr	r0, [r5, #8]
 80020ca:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80020cc:	2b00      	cmp	r3, #0
 80020ce:	d003      	beq.n	80020d8 <__iar_annotation$$branch+0x2a6>
 80020d0:	2100      	movs	r1, #0
 80020d2:	2001      	movs	r0, #1
 80020d4:	4010      	ands	r0, r2
 80020d6:	4798      	blx	r3
 80020d8:	4f73      	ldr	r7, [pc, #460]	; (80022a8 <__iar_annotation$$branch+0x38>)
 80020da:	7838      	ldrb	r0, [r7, #0]
 80020dc:	0780      	lsls	r0, r0, #30
 80020de:	d509      	bpl.n	80020f4 <__iar_annotation$$branch+0x2c2>
 80020e0:	2000      	movs	r0, #0
 80020e2:	9000      	str	r0, [sp, #0]
 80020e4:	2300      	movs	r3, #0
 80020e6:	221d      	movs	r2, #29
 80020e8:	68e8      	ldr	r0, [r5, #12]
 80020ea:	2101      	movs	r1, #1
 80020ec:	4001      	ands	r1, r0
 80020ee:	2009      	movs	r0, #9
 80020f0:	68ff      	ldr	r7, [r7, #12]
 80020f2:	47b8      	blx	r7
 80020f4:	211d      	movs	r1, #29
 80020f6:	68e8      	ldr	r0, [r5, #12]
 80020f8:	4004      	ands	r4, r0
 80020fa:	0020      	movs	r0, r4
 80020fc:	68aa      	ldr	r2, [r5, #8]
 80020fe:	68d2      	ldr	r2, [r2, #12]
 8002100:	4790      	blx	r2
 8002102:	2101      	movs	r1, #1
 8002104:	4668      	mov	r0, sp
 8002106:	7b40      	ldrb	r0, [r0, #13]
 8002108:	f002 f841 	bl	800418e <PE_Reset>
 800210c:	6868      	ldr	r0, [r5, #4]
 800210e:	6801      	ldr	r1, [r0, #0]
 8002110:	2210      	movs	r2, #16
 8002112:	430a      	orrs	r2, r1
 8002114:	6002      	str	r2, [r0, #0]
 8002116:	4867      	ldr	r0, [pc, #412]	; (80022b4 <__iar_annotation$$branch+0x44>)
 8002118:	8270      	strh	r0, [r6, #18]
 800211a:	209b      	movs	r0, #155	; 0x9b
 800211c:	e357      	b.n	80027ce <__iar_annotation$$branch+0x27e>
 800211e:	68a8      	ldr	r0, [r5, #8]
 8002120:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8002122:	2a00      	cmp	r2, #0
 8002124:	d005      	beq.n	8002132 <__iar_annotation$$branch+0x300>
 8002126:	2100      	movs	r1, #0
 8002128:	4668      	mov	r0, sp
 800212a:	7b40      	ldrb	r0, [r0, #13]
 800212c:	4790      	blx	r2
 800212e:	2801      	cmp	r0, #1
 8002130:	d004      	beq.n	800213c <__iar_annotation$$branch+0x30a>
 8002132:	8a70      	ldrh	r0, [r6, #18]
 8002134:	03a1      	lsls	r1, r4, #14
 8002136:	4288      	cmp	r0, r1
 8002138:	d000      	beq.n	800213c <__iar_annotation$$branch+0x30a>
 800213a:	e353      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800213c:	485f      	ldr	r0, [pc, #380]	; (80022bc <__iar_annotation$$branch+0x4c>)
 800213e:	8270      	strh	r0, [r6, #18]
 8002140:	2040      	movs	r0, #64	; 0x40
 8002142:	7130      	strb	r0, [r6, #4]
 8002144:	2400      	movs	r4, #0
 8002146:	4f58      	ldr	r7, [pc, #352]	; (80022a8 <__iar_annotation$$branch+0x38>)
 8002148:	7838      	ldrb	r0, [r7, #0]
 800214a:	0780      	lsls	r0, r0, #30
 800214c:	d508      	bpl.n	8002160 <__iar_annotation$$branch+0x32e>
 800214e:	9400      	str	r4, [sp, #0]
 8002150:	2300      	movs	r3, #0
 8002152:	2213      	movs	r2, #19
 8002154:	7b28      	ldrb	r0, [r5, #12]
 8002156:	07c1      	lsls	r1, r0, #31
 8002158:	0fc9      	lsrs	r1, r1, #31
 800215a:	2009      	movs	r0, #9
 800215c:	68ff      	ldr	r7, [r7, #12]
 800215e:	47b8      	blx	r7
 8002160:	2113      	movs	r1, #19
 8002162:	e377      	b.n	8002854 <__iar_annotation$$branch+0x304>
 8002164:	68a8      	ldr	r0, [r5, #8]
 8002166:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8002168:	2a00      	cmp	r2, #0
 800216a:	d012      	beq.n	8002192 <__iar_annotation$$branch+0x360>
 800216c:	2101      	movs	r1, #1
 800216e:	4668      	mov	r0, sp
 8002170:	7b40      	ldrb	r0, [r0, #13]
 8002172:	4790      	blx	r2
 8002174:	2801      	cmp	r0, #1
 8002176:	d10c      	bne.n	8002192 <__iar_annotation$$branch+0x360>
 8002178:	6868      	ldr	r0, [r5, #4]
 800217a:	6801      	ldr	r1, [r0, #0]
 800217c:	2210      	movs	r2, #16
 800217e:	4391      	bics	r1, r2
 8002180:	6001      	str	r1, [r0, #0]
 8002182:	2000      	movs	r0, #0
 8002184:	8270      	strh	r0, [r6, #18]
 8002186:	484e      	ldr	r0, [pc, #312]	; (80022c0 <__iar_annotation$$branch+0x50>)
 8002188:	84f0      	strh	r0, [r6, #38]	; 0x26
 800218a:	24fa      	movs	r4, #250	; 0xfa
 800218c:	0064      	lsls	r4, r4, #1
 800218e:	2043      	movs	r0, #67	; 0x43
 8002190:	7130      	strb	r0, [r6, #4]
 8002192:	8a70      	ldrh	r0, [r6, #18]
 8002194:	2180      	movs	r1, #128	; 0x80
 8002196:	0209      	lsls	r1, r1, #8
 8002198:	4288      	cmp	r0, r1
 800219a:	d000      	beq.n	800219e <__iar_annotation$$branch+0x36c>
 800219c:	e322      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800219e:	2000      	movs	r0, #0
 80021a0:	8270      	strh	r0, [r6, #18]
 80021a2:	6868      	ldr	r0, [r5, #4]
 80021a4:	6801      	ldr	r1, [r0, #0]
 80021a6:	2210      	movs	r2, #16
 80021a8:	4391      	bics	r1, r2
 80021aa:	6001      	str	r1, [r0, #0]
 80021ac:	e060      	b.n	8002270 <__iar_annotation$$branch>
 80021ae:	0028      	movs	r0, r5
 80021b0:	f001 fbc5 	bl	800393e <PE_PerformSoftReset>
 80021b4:	2000      	movs	r0, #0
 80021b6:	9000      	str	r0, [sp, #0]
 80021b8:	2303      	movs	r3, #3
 80021ba:	2203      	movs	r2, #3
 80021bc:	2100      	movs	r1, #0
 80021be:	0028      	movs	r0, r5
 80021c0:	f001 fad7 	bl	8003772 <PE_Send_CtrlMessage>
 80021c4:	4f38      	ldr	r7, [pc, #224]	; (80022a8 <__iar_annotation$$branch+0x38>)
 80021c6:	7838      	ldrb	r0, [r7, #0]
 80021c8:	0780      	lsls	r0, r0, #30
 80021ca:	d509      	bpl.n	80021e0 <__iar_annotation$$branch+0x3ae>
 80021cc:	2000      	movs	r0, #0
 80021ce:	9000      	str	r0, [sp, #0]
 80021d0:	2300      	movs	r3, #0
 80021d2:	222f      	movs	r2, #47	; 0x2f
 80021d4:	7b28      	ldrb	r0, [r5, #12]
 80021d6:	07c1      	lsls	r1, r0, #31
 80021d8:	0fc9      	lsrs	r1, r1, #31
 80021da:	2009      	movs	r0, #9
 80021dc:	68ff      	ldr	r7, [r7, #12]
 80021de:	47b8      	blx	r7
 80021e0:	212f      	movs	r1, #47	; 0x2f
 80021e2:	e337      	b.n	8002854 <__iar_annotation$$branch+0x304>
 80021e4:	6868      	ldr	r0, [r5, #4]
 80021e6:	7840      	ldrb	r0, [r0, #1]
 80021e8:	0640      	lsls	r0, r0, #25
 80021ea:	0f40      	lsrs	r0, r0, #29
 80021ec:	2804      	cmp	r0, #4
 80021ee:	d101      	bne.n	80021f4 <__iar_annotation$$branch+0x3c2>
 80021f0:	200f      	movs	r0, #15
 80021f2:	e2ec      	b.n	80027ce <__iar_annotation$$branch+0x27e>
 80021f4:	2000      	movs	r0, #0
 80021f6:	9000      	str	r0, [sp, #0]
 80021f8:	2350      	movs	r3, #80	; 0x50
 80021fa:	220d      	movs	r2, #13
 80021fc:	2100      	movs	r1, #0
 80021fe:	0028      	movs	r0, r5
 8002200:	f001 fab7 	bl	8003772 <PE_Send_CtrlMessage>
 8002204:	2800      	cmp	r0, #0
 8002206:	d000      	beq.n	800220a <__iar_annotation$$branch+0x3d8>
 8002208:	e2ec      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800220a:	2003      	movs	r0, #3
 800220c:	82e8      	strh	r0, [r5, #22]
 800220e:	8337      	strh	r7, [r6, #24]
 8002210:	241a      	movs	r4, #26
 8002212:	4f25      	ldr	r7, [pc, #148]	; (80022a8 <__iar_annotation$$branch+0x38>)
 8002214:	7838      	ldrb	r0, [r7, #0]
 8002216:	0780      	lsls	r0, r0, #30
 8002218:	d509      	bpl.n	800222e <__iar_annotation$$branch+0x3fc>
 800221a:	2000      	movs	r0, #0
 800221c:	9000      	str	r0, [sp, #0]
 800221e:	2300      	movs	r3, #0
 8002220:	222e      	movs	r2, #46	; 0x2e
 8002222:	7b28      	ldrb	r0, [r5, #12]
 8002224:	07c1      	lsls	r1, r0, #31
 8002226:	0fc9      	lsrs	r1, r1, #31
 8002228:	2009      	movs	r0, #9
 800222a:	68ff      	ldr	r7, [r7, #12]
 800222c:	47b8      	blx	r7
 800222e:	212e      	movs	r1, #46	; 0x2e
 8002230:	e310      	b.n	8002854 <__iar_annotation$$branch+0x304>
 8002232:	2911      	cmp	r1, #17
 8002234:	d115      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 8002236:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002238:	0bc0      	lsrs	r0, r0, #15
 800223a:	d112      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 800223c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800223e:	0b00      	lsrs	r0, r0, #12
 8002240:	0740      	lsls	r0, r0, #29
 8002242:	d10e      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 8002244:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002246:	06c0      	lsls	r0, r0, #27
 8002248:	0ec0      	lsrs	r0, r0, #27
 800224a:	2803      	cmp	r0, #3
 800224c:	d109      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 800224e:	2000      	movs	r0, #0
 8002250:	8330      	strh	r0, [r6, #24]
 8002252:	0028      	movs	r0, r5
 8002254:	f001 fb73 	bl	800393e <PE_PerformSoftReset>
 8002258:	2003      	movs	r0, #3
 800225a:	7130      	strb	r0, [r6, #4]
 800225c:	2014      	movs	r0, #20
 800225e:	4669      	mov	r1, sp
 8002260:	7308      	strb	r0, [r1, #12]
 8002262:	8b30      	ldrh	r0, [r6, #24]
 8002264:	03a1      	lsls	r1, r4, #14
 8002266:	4288      	cmp	r0, r1
 8002268:	d000      	beq.n	800226c <__iar_annotation$$branch+0x43a>
 800226a:	e2bb      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800226c:	2000      	movs	r0, #0
 800226e:	8330      	strh	r0, [r6, #24]

08002270 <__iar_annotation$$branch>:
 8002270:	f000 fcd3 	bl	8002c1a <__iar_annotation$$branch+0x6ca>
 8002274:	6868      	ldr	r0, [r5, #4]
 8002276:	7840      	ldrb	r0, [r0, #1]
 8002278:	0640      	lsls	r0, r0, #25
 800227a:	0f40      	lsrs	r0, r0, #29
 800227c:	2803      	cmp	r0, #3
 800227e:	d121      	bne.n	80022c4 <__iar_annotation$$branch+0x54>
 8002280:	2103      	movs	r1, #3
 8002282:	0028      	movs	r0, r5
 8002284:	f001 fa5a 	bl	800373c <PE_Send_SNKCapabilities>
 8002288:	4f07      	ldr	r7, [pc, #28]	; (80022a8 <__iar_annotation$$branch+0x38>)
 800228a:	7838      	ldrb	r0, [r7, #0]
 800228c:	0780      	lsls	r0, r0, #30
 800228e:	d509      	bpl.n	80022a4 <__iar_annotation$$branch+0x34>
 8002290:	2000      	movs	r0, #0
 8002292:	9000      	str	r0, [sp, #0]
 8002294:	2300      	movs	r3, #0
 8002296:	220a      	movs	r2, #10
 8002298:	7b28      	ldrb	r0, [r5, #12]
 800229a:	07c1      	lsls	r1, r0, #31
 800229c:	0fc9      	lsrs	r1, r1, #31
 800229e:	2009      	movs	r0, #9
 80022a0:	68ff      	ldr	r7, [r7, #12]
 80022a2:	47b8      	blx	r7
 80022a4:	210a      	movs	r1, #10
 80022a6:	e2d5      	b.n	8002854 <__iar_annotation$$branch+0x304>
 80022a8:	200019a8 	.word	0x200019a8
 80022ac:	0000a328 	.word	0x0000a328
 80022b0:	00002328 	.word	0x00002328
 80022b4:	0000828a 	.word	0x0000828a
 80022b8:	fffff7ff 	.word	0xfffff7ff
 80022bc:	000084fb 	.word	0x000084fb
 80022c0:	000081f4 	.word	0x000081f4
 80022c4:	2000      	movs	r0, #0
 80022c6:	9000      	str	r0, [sp, #0]
 80022c8:	2303      	movs	r3, #3
 80022ca:	2204      	movs	r2, #4
 80022cc:	2100      	movs	r1, #0
 80022ce:	0028      	movs	r0, r5
 80022d0:	f001 fa4f 	bl	8003772 <PE_Send_CtrlMessage>
 80022d4:	e286      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80022d6:	9400      	str	r4, [sp, #0]
 80022d8:	2343      	movs	r3, #67	; 0x43
 80022da:	2207      	movs	r2, #7
 80022dc:	2100      	movs	r1, #0
 80022de:	0028      	movs	r0, r5
 80022e0:	f001 fa47 	bl	8003772 <PE_Send_CtrlMessage>
 80022e4:	2800      	cmp	r0, #0
 80022e6:	d000      	beq.n	80022ea <__iar_annotation$$branch+0x7a>
 80022e8:	e27c      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80022ea:	2006      	movs	r0, #6
 80022ec:	82e8      	strh	r0, [r5, #22]
 80022ee:	8337      	strh	r7, [r6, #24]
 80022f0:	241a      	movs	r4, #26
 80022f2:	4fbf      	ldr	r7, [pc, #764]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 80022f4:	7838      	ldrb	r0, [r7, #0]
 80022f6:	0780      	lsls	r0, r0, #30
 80022f8:	d509      	bpl.n	800230e <__iar_annotation$$branch+0x9e>
 80022fa:	2000      	movs	r0, #0
 80022fc:	9000      	str	r0, [sp, #0]
 80022fe:	2300      	movs	r3, #0
 8002300:	220b      	movs	r2, #11
 8002302:	7b28      	ldrb	r0, [r5, #12]
 8002304:	07c1      	lsls	r1, r0, #31
 8002306:	0fc9      	lsrs	r1, r1, #31
 8002308:	2009      	movs	r0, #9
 800230a:	68ff      	ldr	r7, [r7, #12]
 800230c:	47b8      	blx	r7
 800230e:	210b      	movs	r1, #11
 8002310:	e2a0      	b.n	8002854 <__iar_annotation$$branch+0x304>
 8002312:	2914      	cmp	r1, #20
 8002314:	d00e      	beq.n	8002334 <__iar_annotation$$branch+0xc4>
 8002316:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002318:	0bc0      	lsrs	r0, r0, #15
 800231a:	d10b      	bne.n	8002334 <__iar_annotation$$branch+0xc4>
 800231c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800231e:	0b00      	lsrs	r0, r0, #12
 8002320:	0740      	lsls	r0, r0, #29
 8002322:	d007      	beq.n	8002334 <__iar_annotation$$branch+0xc4>
 8002324:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002326:	06c0      	lsls	r0, r0, #27
 8002328:	0ec0      	lsrs	r0, r0, #27
 800232a:	2803      	cmp	r0, #3
 800232c:	d102      	bne.n	8002334 <__iar_annotation$$branch+0xc4>
 800232e:	2014      	movs	r0, #20
 8002330:	4669      	mov	r1, sp
 8002332:	7308      	strb	r0, [r1, #12]
 8002334:	2011      	movs	r0, #17

08002336 <__iar_annotation$$branch>:
 8002336:	f000 fd1d 	bl	8002d74 <__iar_annotation$$branch+0x824>
 800233a:	2011      	movs	r0, #17
 800233c:	82e8      	strh	r0, [r5, #22]
 800233e:	2105      	movs	r1, #5
 8002340:	7b2a      	ldrb	r2, [r5, #12]
 8002342:	07d0      	lsls	r0, r2, #31
 8002344:	0fc0      	lsrs	r0, r0, #31
 8002346:	f003 f874 	bl	8005432 <USBDPD_PRL_BistCarrierEyeMode>
 800234a:	205d      	movs	r0, #93	; 0x5d
 800234c:	7130      	strb	r0, [r6, #4]
 800234e:	48a9      	ldr	r0, [pc, #676]	; (80025f4 <__iar_annotation$$branch+0xa4>)
 8002350:	8530      	strh	r0, [r6, #40]	; 0x28
 8002352:	243a      	movs	r4, #58	; 0x3a
 8002354:	e246      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002356:	8d30      	ldrh	r0, [r6, #40]	; 0x28
 8002358:	03a1      	lsls	r1, r4, #14
 800235a:	4288      	cmp	r0, r1
 800235c:	d000      	beq.n	8002360 <__iar_annotation$$branch+0x2a>
 800235e:	e241      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002360:	2105      	movs	r1, #5
 8002362:	7b2a      	ldrb	r2, [r5, #12]
 8002364:	07d0      	lsls	r0, r2, #31
 8002366:	0fc0      	lsrs	r0, r0, #31
 8002368:	f003 f86b 	bl	8005442 <USBDPD_PRL_BistCarrierEyeModeExit>
 800236c:	2000      	movs	r0, #0
 800236e:	8530      	strh	r0, [r6, #40]	; 0x28

08002370 <__iar_annotation$$branch>:
 8002370:	f000 fda5 	bl	8002ebe <__iar_annotation$$branch+0x96e>
 8002374:	2911      	cmp	r1, #17
 8002376:	d000      	beq.n	800237a <__iar_annotation$$branch+0xa>
 8002378:	e234      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800237a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800237c:	0bc9      	lsrs	r1, r1, #15
 800237e:	d000      	beq.n	8002382 <__iar_annotation$$branch+0x12>
 8002380:	e230      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002382:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002384:	0b09      	lsrs	r1, r1, #12
 8002386:	0749      	lsls	r1, r1, #29
 8002388:	d000      	beq.n	800238c <__iar_annotation$$branch+0x1c>
 800238a:	e22b      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800238c:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800238e:	06c9      	lsls	r1, r1, #27
 8002390:	0ec9      	lsrs	r1, r1, #27
 8002392:	2906      	cmp	r1, #6
 8002394:	d000      	beq.n	8002398 <__iar_annotation$$branch+0x28>
 8002396:	e225      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002398:	2800      	cmp	r0, #0
 800239a:	d009      	beq.n	80023b0 <__iar_annotation$$branch+0x40>
 800239c:	2000      	movs	r0, #0
 800239e:	9000      	str	r0, [sp, #0]
 80023a0:	2300      	movs	r3, #0
 80023a2:	222a      	movs	r2, #42	; 0x2a
 80023a4:	7b28      	ldrb	r0, [r5, #12]
 80023a6:	07c1      	lsls	r1, r0, #31
 80023a8:	0fc9      	lsrs	r1, r1, #31
 80023aa:	2009      	movs	r0, #9
 80023ac:	9f01      	ldr	r7, [sp, #4]
 80023ae:	47b8      	blx	r7
 80023b0:	212a      	movs	r1, #42	; 0x2a
 80023b2:	7b2a      	ldrb	r2, [r5, #12]
 80023b4:	07d0      	lsls	r0, r2, #31
 80023b6:	0fc0      	lsrs	r0, r0, #31
 80023b8:	68aa      	ldr	r2, [r5, #8]
 80023ba:	68d2      	ldr	r2, [r2, #12]
 80023bc:	4790      	blx	r2

080023be <__iar_annotation$$branch>:
 80023be:	f000 fceb 	bl	8002d98 <__iar_annotation$$branch+0x848>
 80023c2:	9400      	str	r4, [sp, #0]
 80023c4:	2360      	movs	r3, #96	; 0x60
 80023c6:	2208      	movs	r2, #8
 80023c8:	2100      	movs	r1, #0
 80023ca:	0028      	movs	r0, r5
 80023cc:	f001 f9d1 	bl	8003772 <PE_Send_CtrlMessage>
 80023d0:	2800      	cmp	r0, #0
 80023d2:	d000      	beq.n	80023d6 <__iar_annotation$$branch+0x18>
 80023d4:	e206      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80023d6:	2007      	movs	r0, #7
 80023d8:	82e8      	strh	r0, [r5, #22]
 80023da:	8337      	strh	r7, [r6, #24]
 80023dc:	241a      	movs	r4, #26
 80023de:	4f84      	ldr	r7, [pc, #528]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 80023e0:	7838      	ldrb	r0, [r7, #0]
 80023e2:	0780      	lsls	r0, r0, #30
 80023e4:	d509      	bpl.n	80023fa <__iar_annotation$$branch+0x3c>
 80023e6:	2000      	movs	r0, #0
 80023e8:	9000      	str	r0, [sp, #0]
 80023ea:	2300      	movs	r3, #0
 80023ec:	2205      	movs	r2, #5
 80023ee:	7b28      	ldrb	r0, [r5, #12]
 80023f0:	07c1      	lsls	r1, r0, #31
 80023f2:	0fc9      	lsrs	r1, r1, #31
 80023f4:	2009      	movs	r0, #9
 80023f6:	68ff      	ldr	r7, [r7, #12]
 80023f8:	47b8      	blx	r7
 80023fa:	2105      	movs	r1, #5
 80023fc:	e22a      	b.n	8002854 <__iar_annotation$$branch+0x304>
 80023fe:	2911      	cmp	r1, #17
 8002400:	d15e      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 8002402:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002404:	0bc0      	lsrs	r0, r0, #15
 8002406:	d133      	bne.n	8002470 <__iar_annotation$$branch+0xb2>
 8002408:	2007      	movs	r0, #7
 800240a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800240c:	0b09      	lsrs	r1, r1, #12
 800240e:	4201      	tst	r1, r0
 8002410:	d02e      	beq.n	8002470 <__iar_annotation$$branch+0xb2>
 8002412:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002414:	06c9      	lsls	r1, r1, #27
 8002416:	0ec9      	lsrs	r1, r1, #27
 8002418:	2904      	cmp	r1, #4
 800241a:	d129      	bne.n	8002470 <__iar_annotation$$branch+0xb2>
 800241c:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800241e:	0b09      	lsrs	r1, r1, #12
 8002420:	4008      	ands	r0, r1
 8002422:	0083      	lsls	r3, r0, #2
 8002424:	209e      	movs	r0, #158	; 0x9e
 8002426:	0040      	lsls	r0, r0, #1
 8002428:	182a      	adds	r2, r5, r0
 800242a:	2105      	movs	r1, #5
 800242c:	7b2f      	ldrb	r7, [r5, #12]
 800242e:	07f8      	lsls	r0, r7, #31
 8002430:	0fc0      	lsrs	r0, r0, #31
 8002432:	68af      	ldr	r7, [r5, #8]
 8002434:	69ff      	ldr	r7, [r7, #28]
 8002436:	47b8      	blx	r7
 8002438:	2000      	movs	r0, #0
 800243a:	8330      	strh	r0, [r6, #24]
 800243c:	2014      	movs	r0, #20
 800243e:	4669      	mov	r1, sp
 8002440:	7308      	strb	r0, [r1, #12]
 8002442:	2003      	movs	r0, #3
 8002444:	7130      	strb	r0, [r6, #4]
 8002446:	4f6a      	ldr	r7, [pc, #424]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 8002448:	7838      	ldrb	r0, [r7, #0]
 800244a:	0780      	lsls	r0, r0, #30
 800244c:	d509      	bpl.n	8002462 <__iar_annotation$$branch+0xa4>
 800244e:	2000      	movs	r0, #0
 8002450:	9000      	str	r0, [sp, #0]
 8002452:	2300      	movs	r3, #0
 8002454:	2207      	movs	r2, #7
 8002456:	7b28      	ldrb	r0, [r5, #12]
 8002458:	07c1      	lsls	r1, r0, #31
 800245a:	0fc9      	lsrs	r1, r1, #31
 800245c:	2009      	movs	r0, #9
 800245e:	68ff      	ldr	r7, [r7, #12]
 8002460:	47b8      	blx	r7
 8002462:	2107      	movs	r1, #7
 8002464:	7b2a      	ldrb	r2, [r5, #12]
 8002466:	07d0      	lsls	r0, r2, #31
 8002468:	0fc0      	lsrs	r0, r0, #31
 800246a:	68aa      	ldr	r2, [r5, #8]
 800246c:	68d2      	ldr	r2, [r2, #12]
 800246e:	4790      	blx	r2
 8002470:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002472:	0bc0      	lsrs	r0, r0, #15
 8002474:	d124      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 8002476:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002478:	0b00      	lsrs	r0, r0, #12
 800247a:	0740      	lsls	r0, r0, #29
 800247c:	d120      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 800247e:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002480:	06c0      	lsls	r0, r0, #27
 8002482:	0ec0      	lsrs	r0, r0, #27
 8002484:	2804      	cmp	r0, #4
 8002486:	d11b      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 8002488:	2000      	movs	r0, #0
 800248a:	8330      	strh	r0, [r6, #24]
 800248c:	2014      	movs	r0, #20
 800248e:	4669      	mov	r1, sp
 8002490:	7308      	strb	r0, [r1, #12]
 8002492:	2003      	movs	r0, #3
 8002494:	7130      	strb	r0, [r6, #4]
 8002496:	4f56      	ldr	r7, [pc, #344]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 8002498:	7838      	ldrb	r0, [r7, #0]
 800249a:	0780      	lsls	r0, r0, #30
 800249c:	d509      	bpl.n	80024b2 <__iar_annotation$$branch+0xf4>
 800249e:	2000      	movs	r0, #0
 80024a0:	9000      	str	r0, [sp, #0]
 80024a2:	2300      	movs	r3, #0
 80024a4:	2208      	movs	r2, #8
 80024a6:	7b28      	ldrb	r0, [r5, #12]
 80024a8:	07c1      	lsls	r1, r0, #31
 80024aa:	0fc9      	lsrs	r1, r1, #31
 80024ac:	2009      	movs	r0, #9
 80024ae:	68ff      	ldr	r7, [r7, #12]
 80024b0:	47b8      	blx	r7
 80024b2:	2108      	movs	r1, #8
 80024b4:	7b2a      	ldrb	r2, [r5, #12]
 80024b6:	07d0      	lsls	r0, r2, #31
 80024b8:	0fc0      	lsrs	r0, r0, #31
 80024ba:	68aa      	ldr	r2, [r5, #8]
 80024bc:	68d2      	ldr	r2, [r2, #12]
 80024be:	4790      	blx	r2
 80024c0:	8b30      	ldrh	r0, [r6, #24]
 80024c2:	03a1      	lsls	r1, r4, #14
 80024c4:	4288      	cmp	r0, r1
 80024c6:	d000      	beq.n	80024ca <__iar_annotation$$branch>
 80024c8:	e18c      	b.n	80027e4 <__iar_annotation$$branch+0x294>

080024ca <__iar_annotation$$branch>:
 80024ca:	f000 fcf6 	bl	8002eba <__iar_annotation$$branch+0x96a>
 80024ce:	2000      	movs	r0, #0
 80024d0:	9000      	str	r0, [sp, #0]
 80024d2:	2303      	movs	r3, #3
 80024d4:	2204      	movs	r2, #4
 80024d6:	2100      	movs	r1, #0
 80024d8:	0028      	movs	r0, r5
 80024da:	f001 f94a 	bl	8003772 <PE_Send_CtrlMessage>
 80024de:	4844      	ldr	r0, [pc, #272]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 80024e0:	7800      	ldrb	r0, [r0, #0]
 80024e2:	0780      	lsls	r0, r0, #30
 80024e4:	d500      	bpl.n	80024e8 <__iar_annotation$$branch+0x1e>
 80024e6:	e1d5      	b.n	8002894 <__iar_annotation$$branch+0x344>
 80024e8:	e1df      	b.n	80028aa <__iar_annotation$$branch+0x35a>
 80024ea:	4943      	ldr	r1, [pc, #268]	; (80025f8 <__iar_annotation$$branch+0xa8>)
 80024ec:	84b1      	strh	r1, [r6, #36]	; 0x24
 80024ee:	2464      	movs	r4, #100	; 0x64
 80024f0:	2100      	movs	r1, #0
 80024f2:	82e9      	strh	r1, [r5, #22]
 80024f4:	2104      	movs	r1, #4
 80024f6:	7131      	strb	r1, [r6, #4]
 80024f8:	2800      	cmp	r0, #0
 80024fa:	d009      	beq.n	8002510 <__iar_annotation$$branch+0x46>
 80024fc:	2000      	movs	r0, #0
 80024fe:	9000      	str	r0, [sp, #0]
 8002500:	2300      	movs	r3, #0
 8002502:	221f      	movs	r2, #31
 8002504:	7b28      	ldrb	r0, [r5, #12]
 8002506:	07c1      	lsls	r1, r0, #31
 8002508:	0fc9      	lsrs	r1, r1, #31
 800250a:	2009      	movs	r0, #9
 800250c:	9f01      	ldr	r7, [sp, #4]
 800250e:	47b8      	blx	r7
 8002510:	211f      	movs	r1, #31
 8002512:	7b2a      	ldrb	r2, [r5, #12]
 8002514:	07d0      	lsls	r0, r2, #31
 8002516:	0fc0      	lsrs	r0, r0, #31
 8002518:	68aa      	ldr	r2, [r5, #8]
 800251a:	68d2      	ldr	r2, [r2, #12]
 800251c:	4790      	blx	r2
 800251e:	4668      	mov	r0, sp
 8002520:	7b00      	ldrb	r0, [r0, #12]
 8002522:	2814      	cmp	r0, #20
 8002524:	d016      	beq.n	8002554 <__iar_annotation$$branch+0x4>
 8002526:	79b0      	ldrb	r0, [r6, #6]
 8002528:	71f0      	strb	r0, [r6, #7]
 800252a:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800252c:	0bc0      	lsrs	r0, r0, #15
 800252e:	d001      	beq.n	8002534 <__iar_annotation$$branch+0x4>

08002530 <__iar_annotation$$branch>:
 8002530:	f000 fcad 	bl	8002e8e <__iar_annotation$$branch+0x93e>
 8002534:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002536:	0bc0      	lsrs	r0, r0, #15
 8002538:	d107      	bne.n	800254a <__iar_annotation$$branch+0x1a>
 800253a:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800253c:	0b00      	lsrs	r0, r0, #12
 800253e:	0740      	lsls	r0, r0, #29
 8002540:	d103      	bne.n	800254a <__iar_annotation$$branch+0x1a>
 8002542:	0028      	movs	r0, r5
 8002544:	f001 fa9e 	bl	8003a84 <PE_Check_ControlMessage>
 8002548:	e002      	b.n	8002550 <__iar_annotation$$branch>
 800254a:	0028      	movs	r0, r5
 800254c:	f001 fc36 	bl	8003dbc <PE_Check_DataMessage>

08002550 <__iar_annotation$$branch>:
 8002550:	f000 fca0 	bl	8002e94 <__iar_annotation$$branch+0x944>
 8002554:	68e8      	ldr	r0, [r5, #12]
 8002556:	0b00      	lsrs	r0, r0, #12
 8002558:	2180      	movs	r1, #128	; 0x80
 800255a:	0209      	lsls	r1, r1, #8
 800255c:	240f      	movs	r4, #15
 800255e:	2800      	cmp	r0, #0
 8002560:	d01e      	beq.n	80025a0 <__iar_annotation$$branch+0x50>
 8002562:	8a32      	ldrh	r2, [r6, #16]
 8002564:	428a      	cmp	r2, r1
 8002566:	d104      	bne.n	8002572 <__iar_annotation$$branch+0x22>
 8002568:	7134      	strb	r4, [r6, #4]
 800256a:	7d28      	ldrb	r0, [r5, #20]
 800256c:	1c40      	adds	r0, r0, #1
 800256e:	7528      	strb	r0, [r5, #20]
 8002570:	e12e      	b.n	80027d0 <__iar_annotation$$branch+0x280>
 8002572:	6b72      	ldr	r2, [r6, #52]	; 0x34
 8002574:	0512      	lsls	r2, r2, #20
 8002576:	0d12      	lsrs	r2, r2, #20
 8002578:	2307      	movs	r3, #7
 800257a:	8e34      	ldrh	r4, [r6, #48]	; 0x30
 800257c:	0a67      	lsrs	r7, r4, #9
 800257e:	2407      	movs	r4, #7
 8002580:	403c      	ands	r4, r7
 8002582:	1824      	adds	r4, r4, r0
 8002584:	2733      	movs	r7, #51	; 0x33
 8002586:	437c      	muls	r4, r7
 8002588:	18a4      	adds	r4, r4, r2
 800258a:	4321      	orrs	r1, r4
 800258c:	9c04      	ldr	r4, [sp, #16]
 800258e:	8021      	strh	r1, [r4, #0]
 8002590:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002592:	0a49      	lsrs	r1, r1, #9
 8002594:	400b      	ands	r3, r1
 8002596:	1818      	adds	r0, r3, r0
 8002598:	2133      	movs	r1, #51	; 0x33
 800259a:	4348      	muls	r0, r1
 800259c:	1884      	adds	r4, r0, r2
 800259e:	e121      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80025a0:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 80025a2:	4288      	cmp	r0, r1
 80025a4:	d103      	bne.n	80025ae <__iar_annotation$$branch+0x5e>
 80025a6:	2400      	movs	r4, #0
 80025a8:	85b4      	strh	r4, [r6, #44]	; 0x2c
 80025aa:	2044      	movs	r0, #68	; 0x44
 80025ac:	e1b0      	b.n	8002910 <__iar_annotation$$branch+0x3c0>
 80025ae:	7830      	ldrb	r0, [r6, #0]
 80025b0:	2800      	cmp	r0, #0
 80025b2:	d014      	beq.n	80025de <__iar_annotation$$branch+0x8e>
 80025b4:	6868      	ldr	r0, [r5, #4]
 80025b6:	7800      	ldrb	r0, [r0, #0]
 80025b8:	0781      	lsls	r1, r0, #30
 80025ba:	0f89      	lsrs	r1, r1, #30
 80025bc:	2901      	cmp	r1, #1
 80025be:	d007      	beq.n	80025d0 <__iar_annotation$$branch+0x80>
 80025c0:	2902      	cmp	r1, #2
 80025c2:	d10c      	bne.n	80025de <__iar_annotation$$branch+0x8e>
 80025c4:	4668      	mov	r0, sp
 80025c6:	7b40      	ldrb	r0, [r0, #13]
 80025c8:	f002 fcdf 	bl	8004f8a <USBPD_PRL_IsResistor_SinkTxOK>
 80025cc:	2801      	cmp	r0, #1
 80025ce:	d106      	bne.n	80025de <__iar_annotation$$branch+0x8e>
 80025d0:	7870      	ldrb	r0, [r6, #1]
 80025d2:	71f0      	strb	r0, [r6, #7]
 80025d4:	7830      	ldrb	r0, [r6, #0]
 80025d6:	7130      	strb	r0, [r6, #4]
 80025d8:	2400      	movs	r4, #0
 80025da:	7034      	strb	r4, [r6, #0]
 80025dc:	e102      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80025de:	48b4      	ldr	r0, [pc, #720]	; (80028b0 <__iar_annotation$$branch+0x360>)
 80025e0:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 80025e2:	4001      	ands	r1, r0
 80025e4:	2900      	cmp	r1, #0
 80025e6:	dd09      	ble.n	80025fc <__iar_annotation$$branch+0xac>
 80025e8:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 80025ea:	0004      	movs	r4, r0
 80025ec:	400c      	ands	r4, r1
 80025ee:	e0f9      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80025f0:	200019a8 	.word	0x200019a8
 80025f4:	0000803a 	.word	0x0000803a
 80025f8:	00008064 	.word	0x00008064
 80025fc:	7830      	ldrb	r0, [r6, #0]
 80025fe:	2800      	cmp	r0, #0
 8002600:	d000      	beq.n	8002604 <__iar_annotation$$branch+0xb4>
 8002602:	e0ef      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002604:	2400      	movs	r4, #0
 8002606:	43e4      	mvns	r4, r4
 8002608:	e0ec      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800260a:	4668      	mov	r0, sp
 800260c:	7b40      	ldrb	r0, [r0, #13]
 800260e:	68a9      	ldr	r1, [r5, #8]
 8002610:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
 8002612:	4788      	blx	r1
 8002614:	280a      	cmp	r0, #10
 8002616:	d145      	bne.n	80026a4 <__iar_annotation$$branch+0x154>
 8002618:	2000      	movs	r0, #0
 800261a:	9000      	str	r0, [sp, #0]
 800261c:	2303      	movs	r3, #3
 800261e:	2203      	movs	r2, #3
 8002620:	2100      	movs	r1, #0
 8002622:	0028      	movs	r0, r5
 8002624:	f001 f8a5 	bl	8003772 <PE_Send_CtrlMessage>
 8002628:	2800      	cmp	r0, #0
 800262a:	d000      	beq.n	800262e <__iar_annotation$$branch+0xde>
 800262c:	e0da      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800262e:	6868      	ldr	r0, [r5, #4]
 8002630:	7801      	ldrb	r1, [r0, #0]
 8002632:	08ca      	lsrs	r2, r1, #3
 8002634:	07d2      	lsls	r2, r2, #31
 8002636:	d412      	bmi.n	800265e <__iar_annotation$$branch+0x10e>
 8002638:	2208      	movs	r2, #8
 800263a:	430a      	orrs	r2, r1
 800263c:	7002      	strb	r2, [r0, #0]
 800263e:	4f9d      	ldr	r7, [pc, #628]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002640:	7838      	ldrb	r0, [r7, #0]
 8002642:	0780      	lsls	r0, r0, #30
 8002644:	d509      	bpl.n	800265a <__iar_annotation$$branch+0x10a>
 8002646:	2000      	movs	r0, #0
 8002648:	9000      	str	r0, [sp, #0]
 800264a:	2300      	movs	r3, #0
 800264c:	2224      	movs	r2, #36	; 0x24
 800264e:	7b28      	ldrb	r0, [r5, #12]
 8002650:	07c1      	lsls	r1, r0, #31
 8002652:	0fc9      	lsrs	r1, r1, #31
 8002654:	2009      	movs	r0, #9
 8002656:	68ff      	ldr	r7, [r7, #12]
 8002658:	47b8      	blx	r7
 800265a:	2124      	movs	r1, #36	; 0x24
 800265c:	e011      	b.n	8002682 <__iar_annotation$$branch+0x132>
 800265e:	22f7      	movs	r2, #247	; 0xf7
 8002660:	400a      	ands	r2, r1
 8002662:	7002      	strb	r2, [r0, #0]
 8002664:	4f93      	ldr	r7, [pc, #588]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002666:	7838      	ldrb	r0, [r7, #0]
 8002668:	0780      	lsls	r0, r0, #30
 800266a:	d509      	bpl.n	8002680 <__iar_annotation$$branch+0x130>
 800266c:	2000      	movs	r0, #0
 800266e:	9000      	str	r0, [sp, #0]
 8002670:	2300      	movs	r3, #0
 8002672:	2223      	movs	r2, #35	; 0x23
 8002674:	7b28      	ldrb	r0, [r5, #12]
 8002676:	07c1      	lsls	r1, r0, #31
 8002678:	0fc9      	lsrs	r1, r1, #31
 800267a:	2009      	movs	r0, #9
 800267c:	68ff      	ldr	r7, [r7, #12]
 800267e:	47b8      	blx	r7
 8002680:	2123      	movs	r1, #35	; 0x23
 8002682:	7b2a      	ldrb	r2, [r5, #12]
 8002684:	07d0      	lsls	r0, r2, #31
 8002686:	0fc0      	lsrs	r0, r0, #31
 8002688:	68aa      	ldr	r2, [r5, #8]
 800268a:	68d2      	ldr	r2, [r2, #12]
 800268c:	4790      	blx	r2
 800268e:	2001      	movs	r0, #1
 8002690:	6869      	ldr	r1, [r5, #4]
 8002692:	7809      	ldrb	r1, [r1, #0]
 8002694:	08ca      	lsrs	r2, r1, #3
 8002696:	2101      	movs	r1, #1
 8002698:	4011      	ands	r1, r2
 800269a:	68ea      	ldr	r2, [r5, #12]
 800269c:	4010      	ands	r0, r2
 800269e:	f002 fc4b 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 80026a2:	e09f      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026a4:	6868      	ldr	r0, [r5, #4]
 80026a6:	7800      	ldrb	r0, [r0, #0]
 80026a8:	0780      	lsls	r0, r0, #30
 80026aa:	0f80      	lsrs	r0, r0, #30
 80026ac:	2802      	cmp	r0, #2
 80026ae:	d101      	bne.n	80026b4 <__iar_annotation$$branch+0x164>
 80026b0:	2001      	movs	r0, #1
 80026b2:	e12d      	b.n	8002910 <__iar_annotation$$branch+0x3c0>
 80026b4:	202a      	movs	r0, #42	; 0x2a
 80026b6:	e12b      	b.n	8002910 <__iar_annotation$$branch+0x3c0>
 80026b8:	9400      	str	r4, [sp, #0]
 80026ba:	2395      	movs	r3, #149	; 0x95
 80026bc:	2209      	movs	r2, #9
 80026be:	2100      	movs	r1, #0
 80026c0:	0028      	movs	r0, r5
 80026c2:	f001 f856 	bl	8003772 <PE_Send_CtrlMessage>
 80026c6:	2800      	cmp	r0, #0
 80026c8:	d000      	beq.n	80026cc <__iar_annotation$$branch+0x17c>
 80026ca:	e08b      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026cc:	200f      	movs	r0, #15
 80026ce:	82e8      	strh	r0, [r5, #22]
 80026d0:	e3a7      	b.n	8002e22 <__iar_annotation$$branch+0x8d2>
 80026d2:	8b32      	ldrh	r2, [r6, #24]
 80026d4:	03a3      	lsls	r3, r4, #14
 80026d6:	429a      	cmp	r2, r3
 80026d8:	d100      	bne.n	80026dc <__iar_annotation$$branch+0x18c>
 80026da:	e6f6      	b.n	80024ca <__iar_annotation$$branch>
 80026dc:	2914      	cmp	r1, #20
 80026de:	d100      	bne.n	80026e2 <__iar_annotation$$branch+0x192>
 80026e0:	e080      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026e2:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 80026e4:	0bc9      	lsrs	r1, r1, #15
 80026e6:	d000      	beq.n	80026ea <__iar_annotation$$branch+0x19a>
 80026e8:	e07c      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026ea:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 80026ec:	0b09      	lsrs	r1, r1, #12
 80026ee:	0749      	lsls	r1, r1, #29
 80026f0:	d178      	bne.n	80027e4 <__iar_annotation$$branch+0x294>
 80026f2:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 80026f4:	06c9      	lsls	r1, r1, #27
 80026f6:	0ec9      	lsrs	r1, r1, #27
 80026f8:	2903      	cmp	r1, #3
 80026fa:	d004      	beq.n	8002706 <__iar_annotation$$branch+0x1b6>
 80026fc:	2904      	cmp	r1, #4
 80026fe:	d04d      	beq.n	800279c <__iar_annotation$$branch+0x24c>
 8002700:	290c      	cmp	r1, #12
 8002702:	d037      	beq.n	8002774 <__iar_annotation$$branch+0x224>
 8002704:	e06e      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002706:	6869      	ldr	r1, [r5, #4]
 8002708:	780a      	ldrb	r2, [r1, #0]
 800270a:	08d3      	lsrs	r3, r2, #3
 800270c:	07db      	lsls	r3, r3, #31
 800270e:	d410      	bmi.n	8002732 <__iar_annotation$$branch+0x1e2>
 8002710:	2308      	movs	r3, #8
 8002712:	4313      	orrs	r3, r2
 8002714:	700b      	strb	r3, [r1, #0]
 8002716:	2800      	cmp	r0, #0
 8002718:	d009      	beq.n	800272e <__iar_annotation$$branch+0x1de>
 800271a:	2000      	movs	r0, #0
 800271c:	9000      	str	r0, [sp, #0]
 800271e:	2300      	movs	r3, #0
 8002720:	2224      	movs	r2, #36	; 0x24
 8002722:	7b28      	ldrb	r0, [r5, #12]
 8002724:	07c1      	lsls	r1, r0, #31
 8002726:	0fc9      	lsrs	r1, r1, #31
 8002728:	2009      	movs	r0, #9
 800272a:	9f01      	ldr	r7, [sp, #4]
 800272c:	47b8      	blx	r7
 800272e:	2124      	movs	r1, #36	; 0x24
 8002730:	e00f      	b.n	8002752 <__iar_annotation$$branch+0x202>
 8002732:	23f7      	movs	r3, #247	; 0xf7
 8002734:	4013      	ands	r3, r2
 8002736:	700b      	strb	r3, [r1, #0]
 8002738:	2800      	cmp	r0, #0
 800273a:	d009      	beq.n	8002750 <__iar_annotation$$branch+0x200>
 800273c:	2000      	movs	r0, #0
 800273e:	9000      	str	r0, [sp, #0]
 8002740:	2300      	movs	r3, #0
 8002742:	2223      	movs	r2, #35	; 0x23
 8002744:	7b28      	ldrb	r0, [r5, #12]
 8002746:	07c1      	lsls	r1, r0, #31
 8002748:	0fc9      	lsrs	r1, r1, #31
 800274a:	2009      	movs	r0, #9
 800274c:	9f01      	ldr	r7, [sp, #4]
 800274e:	47b8      	blx	r7
 8002750:	2123      	movs	r1, #35	; 0x23
 8002752:	7b2a      	ldrb	r2, [r5, #12]
 8002754:	07d0      	lsls	r0, r2, #31
 8002756:	0fc0      	lsrs	r0, r0, #31
 8002758:	68aa      	ldr	r2, [r5, #8]
 800275a:	68d2      	ldr	r2, [r2, #12]
 800275c:	4790      	blx	r2
 800275e:	2001      	movs	r0, #1
 8002760:	6869      	ldr	r1, [r5, #4]
 8002762:	7809      	ldrb	r1, [r1, #0]
 8002764:	08ca      	lsrs	r2, r1, #3
 8002766:	2101      	movs	r1, #1
 8002768:	4011      	ands	r1, r2
 800276a:	68ea      	ldr	r2, [r5, #12]
 800276c:	4010      	ands	r0, r2
 800276e:	f002 fbe3 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 8002772:	e30f      	b.n	8002d94 <__iar_annotation$$branch+0x844>
 8002774:	2800      	cmp	r0, #0
 8002776:	d009      	beq.n	800278c <__iar_annotation$$branch+0x23c>
 8002778:	2000      	movs	r0, #0
 800277a:	9000      	str	r0, [sp, #0]
 800277c:	2300      	movs	r3, #0
 800277e:	2225      	movs	r2, #37	; 0x25
 8002780:	7b28      	ldrb	r0, [r5, #12]
 8002782:	07c1      	lsls	r1, r0, #31
 8002784:	0fc9      	lsrs	r1, r1, #31
 8002786:	2009      	movs	r0, #9
 8002788:	9f01      	ldr	r7, [sp, #4]
 800278a:	47b8      	blx	r7
 800278c:	2125      	movs	r1, #37	; 0x25
 800278e:	7b2a      	ldrb	r2, [r5, #12]
 8002790:	07d0      	lsls	r0, r2, #31
 8002792:	0fc0      	lsrs	r0, r0, #31
 8002794:	68aa      	ldr	r2, [r5, #8]
 8002796:	68d2      	ldr	r2, [r2, #12]
 8002798:	4790      	blx	r2
 800279a:	e2fb      	b.n	8002d94 <__iar_annotation$$branch+0x844>
 800279c:	2800      	cmp	r0, #0
 800279e:	d009      	beq.n	80027b4 <__iar_annotation$$branch+0x264>
 80027a0:	2000      	movs	r0, #0
 80027a2:	9000      	str	r0, [sp, #0]
 80027a4:	2300      	movs	r3, #0
 80027a6:	2226      	movs	r2, #38	; 0x26
 80027a8:	7b28      	ldrb	r0, [r5, #12]
 80027aa:	07c1      	lsls	r1, r0, #31
 80027ac:	0fc9      	lsrs	r1, r1, #31
 80027ae:	2009      	movs	r0, #9
 80027b0:	9f01      	ldr	r7, [sp, #4]
 80027b2:	47b8      	blx	r7
 80027b4:	2126      	movs	r1, #38	; 0x26
 80027b6:	7b2a      	ldrb	r2, [r5, #12]
 80027b8:	07d0      	lsls	r0, r2, #31
 80027ba:	0fc0      	lsrs	r0, r0, #31
 80027bc:	68aa      	ldr	r2, [r5, #8]
 80027be:	68d2      	ldr	r2, [r2, #12]
 80027c0:	4790      	blx	r2
 80027c2:	e2e7      	b.n	8002d94 <__iar_annotation$$branch+0x844>
 80027c4:	68a8      	ldr	r0, [r5, #8]
 80027c6:	6881      	ldr	r1, [r0, #8]
 80027c8:	2900      	cmp	r1, #0
 80027ca:	d102      	bne.n	80027d2 <__iar_annotation$$branch+0x282>
 80027cc:	202a      	movs	r0, #42	; 0x2a
 80027ce:	7130      	strb	r0, [r6, #4]
 80027d0:	e354      	b.n	8002e7c <__iar_annotation$$branch+0x92c>
 80027d2:	4668      	mov	r0, sp
 80027d4:	7b40      	ldrb	r0, [r0, #13]
 80027d6:	4788      	blx	r1
 80027d8:	280a      	cmp	r0, #10
 80027da:	d004      	beq.n	80027e6 <__iar_annotation$$branch+0x296>
 80027dc:	280c      	cmp	r0, #12
 80027de:	d052      	beq.n	8002886 <__iar_annotation$$branch+0x336>
 80027e0:	280d      	cmp	r0, #13
 80027e2:	d038      	beq.n	8002856 <__iar_annotation$$branch+0x306>
 80027e4:	e392      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 80027e6:	68a8      	ldr	r0, [r5, #8]
 80027e8:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80027ea:	2b00      	cmp	r3, #0
 80027ec:	d005      	beq.n	80027fa <__iar_annotation$$branch+0x2aa>
 80027ee:	2201      	movs	r2, #1
 80027f0:	2100      	movs	r1, #0
 80027f2:	7b2f      	ldrb	r7, [r5, #12]
 80027f4:	07f8      	lsls	r0, r7, #31
 80027f6:	0fc0      	lsrs	r0, r0, #31
 80027f8:	4798      	blx	r3
 80027fa:	2000      	movs	r0, #0
 80027fc:	9000      	str	r0, [sp, #0]
 80027fe:	2352      	movs	r3, #82	; 0x52
 8002800:	2203      	movs	r2, #3
 8002802:	2100      	movs	r1, #0
 8002804:	0028      	movs	r0, r5
 8002806:	f000 ffb4 	bl	8003772 <PE_Send_CtrlMessage>
 800280a:	2800      	cmp	r0, #0
 800280c:	d1ea      	bne.n	80027e4 <__iar_annotation$$branch+0x294>
 800280e:	2008      	movs	r0, #8
 8002810:	82e8      	strh	r0, [r5, #22]
 8002812:	6868      	ldr	r0, [r5, #4]
 8002814:	6801      	ldr	r1, [r0, #0]
 8002816:	2210      	movs	r2, #16
 8002818:	430a      	orrs	r2, r1
 800281a:	6002      	str	r2, [r0, #0]
 800281c:	68a8      	ldr	r0, [r5, #8]
 800281e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002820:	2b00      	cmp	r3, #0
 8002822:	d005      	beq.n	8002830 <__iar_annotation$$branch+0x2e0>
 8002824:	2206      	movs	r2, #6
 8002826:	2100      	movs	r1, #0
 8002828:	7b2c      	ldrb	r4, [r5, #12]
 800282a:	07e0      	lsls	r0, r4, #31
 800282c:	0fc0      	lsrs	r0, r0, #31
 800282e:	4798      	blx	r3
 8002830:	489d      	ldr	r0, [pc, #628]	; (8002aa8 <__iar_annotation$$branch+0x558>)
 8002832:	82b0      	strh	r0, [r6, #20]
 8002834:	4c9d      	ldr	r4, [pc, #628]	; (8002aac <__iar_annotation$$branch+0x55c>)
 8002836:	4f1f      	ldr	r7, [pc, #124]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002838:	7838      	ldrb	r0, [r7, #0]
 800283a:	0780      	lsls	r0, r0, #30
 800283c:	d509      	bpl.n	8002852 <__iar_annotation$$branch+0x302>
 800283e:	2000      	movs	r0, #0
 8002840:	9000      	str	r0, [sp, #0]
 8002842:	2300      	movs	r3, #0
 8002844:	2238      	movs	r2, #56	; 0x38
 8002846:	7b28      	ldrb	r0, [r5, #12]
 8002848:	07c1      	lsls	r1, r0, #31
 800284a:	0fc9      	lsrs	r1, r1, #31
 800284c:	2009      	movs	r0, #9
 800284e:	68ff      	ldr	r7, [r7, #12]
 8002850:	47b8      	blx	r7
 8002852:	2138      	movs	r1, #56	; 0x38
 8002854:	e2fe      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 8002856:	2000      	movs	r0, #0
 8002858:	9000      	str	r0, [sp, #0]
 800285a:	2303      	movs	r3, #3
 800285c:	220c      	movs	r2, #12
 800285e:	2100      	movs	r1, #0
 8002860:	0028      	movs	r0, r5
 8002862:	f000 ff86 	bl	8003772 <PE_Send_CtrlMessage>
 8002866:	4f13      	ldr	r7, [pc, #76]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002868:	7838      	ldrb	r0, [r7, #0]
 800286a:	0780      	lsls	r0, r0, #30
 800286c:	d509      	bpl.n	8002882 <__iar_annotation$$branch+0x332>
 800286e:	2000      	movs	r0, #0
 8002870:	9000      	str	r0, [sp, #0]
 8002872:	2300      	movs	r3, #0
 8002874:	2239      	movs	r2, #57	; 0x39
 8002876:	7b28      	ldrb	r0, [r5, #12]
 8002878:	07c1      	lsls	r1, r0, #31
 800287a:	0fc9      	lsrs	r1, r1, #31
 800287c:	2009      	movs	r0, #9
 800287e:	68ff      	ldr	r7, [r7, #12]
 8002880:	47b8      	blx	r7
 8002882:	2139      	movs	r1, #57	; 0x39
 8002884:	e2e6      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 8002886:	202a      	movs	r0, #42	; 0x2a
 8002888:	7130      	strb	r0, [r6, #4]
 800288a:	2400      	movs	r4, #0
 800288c:	4809      	ldr	r0, [pc, #36]	; (80028b4 <__iar_annotation$$branch+0x364>)
 800288e:	7800      	ldrb	r0, [r0, #0]
 8002890:	0780      	lsls	r0, r0, #30
 8002892:	d50a      	bpl.n	80028aa <__iar_annotation$$branch+0x35a>
 8002894:	2000      	movs	r0, #0
 8002896:	9000      	str	r0, [sp, #0]
 8002898:	2300      	movs	r3, #0
 800289a:	2216      	movs	r2, #22
 800289c:	7b28      	ldrb	r0, [r5, #12]
 800289e:	07c1      	lsls	r1, r0, #31
 80028a0:	0fc9      	lsrs	r1, r1, #31
 80028a2:	2009      	movs	r0, #9
 80028a4:	4f03      	ldr	r7, [pc, #12]	; (80028b4 <__iar_annotation$$branch+0x364>)
 80028a6:	68ff      	ldr	r7, [r7, #12]
 80028a8:	47b8      	blx	r7
 80028aa:	2116      	movs	r1, #22
 80028ac:	e2d2      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 80028ae:	bf00      	nop
 80028b0:	00007fff 	.word	0x00007fff
 80028b4:	200019a8 	.word	0x200019a8
 80028b8:	2911      	cmp	r1, #17
 80028ba:	d11c      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028bc:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 80028be:	0bc0      	lsrs	r0, r0, #15
 80028c0:	d119      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028c2:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 80028c4:	0b00      	lsrs	r0, r0, #12
 80028c6:	0740      	lsls	r0, r0, #29
 80028c8:	d115      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028ca:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 80028cc:	06c0      	lsls	r0, r0, #27
 80028ce:	0ec0      	lsrs	r0, r0, #27
 80028d0:	2806      	cmp	r0, #6
 80028d2:	d110      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028d4:	2000      	movs	r0, #0
 80028d6:	82f0      	strh	r0, [r6, #22]
 80028d8:	68a8      	ldr	r0, [r5, #8]
 80028da:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80028dc:	2b00      	cmp	r3, #0
 80028de:	d005      	beq.n	80028ec <__iar_annotation$$branch+0x39c>
 80028e0:	2209      	movs	r2, #9
 80028e2:	2100      	movs	r1, #0
 80028e4:	7b2f      	ldrb	r7, [r5, #12]
 80028e6:	07f8      	lsls	r0, r7, #31
 80028e8:	0fc0      	lsrs	r0, r0, #31
 80028ea:	4798      	blx	r3
 80028ec:	2053      	movs	r0, #83	; 0x53
 80028ee:	7130      	strb	r0, [r6, #4]
 80028f0:	2014      	movs	r0, #20
 80028f2:	4669      	mov	r1, sp
 80028f4:	7308      	strb	r0, [r1, #12]
 80028f6:	8ab0      	ldrh	r0, [r6, #20]
 80028f8:	03a1      	lsls	r1, r4, #14
 80028fa:	4288      	cmp	r0, r1
 80028fc:	d000      	beq.n	8002900 <__iar_annotation$$branch+0x3b0>
 80028fe:	e305      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002900:	2000      	movs	r0, #0
 8002902:	82b0      	strh	r0, [r6, #20]
 8002904:	68a8      	ldr	r0, [r5, #8]
 8002906:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8002908:	2800      	cmp	r0, #0
 800290a:	d100      	bne.n	800290e <__iar_annotation$$branch+0x3be>
 800290c:	e185      	b.n	8002c1a <__iar_annotation$$branch+0x6ca>
 800290e:	2092      	movs	r0, #146	; 0x92
 8002910:	e2fb      	b.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002912:	6869      	ldr	r1, [r5, #4]
 8002914:	784a      	ldrb	r2, [r1, #1]
 8002916:	238f      	movs	r3, #143	; 0x8f
 8002918:	4013      	ands	r3, r2
 800291a:	2240      	movs	r2, #64	; 0x40
 800291c:	431a      	orrs	r2, r3
 800291e:	704a      	strb	r2, [r1, #1]
 8002920:	2800      	cmp	r0, #0
 8002922:	d009      	beq.n	8002938 <__iar_annotation$$branch+0x3e8>
 8002924:	2000      	movs	r0, #0
 8002926:	9000      	str	r0, [sp, #0]
 8002928:	2300      	movs	r3, #0
 800292a:	2256      	movs	r2, #86	; 0x56
 800292c:	7b28      	ldrb	r0, [r5, #12]
 800292e:	07c1      	lsls	r1, r0, #31
 8002930:	0fc9      	lsrs	r1, r1, #31
 8002932:	2009      	movs	r0, #9
 8002934:	9f01      	ldr	r7, [sp, #4]
 8002936:	47b8      	blx	r7
 8002938:	2701      	movs	r7, #1
 800293a:	2156      	movs	r1, #86	; 0x56
 800293c:	68ea      	ldr	r2, [r5, #12]
 800293e:	2001      	movs	r0, #1
 8002940:	4010      	ands	r0, r2
 8002942:	68aa      	ldr	r2, [r5, #8]
 8002944:	68d2      	ldr	r2, [r2, #12]
 8002946:	4790      	blx	r2
 8002948:	68a8      	ldr	r0, [r5, #8]
 800294a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800294c:	2b00      	cmp	r3, #0
 800294e:	d005      	beq.n	800295c <__iar_annotation$$branch+0x40c>
 8002950:	220a      	movs	r2, #10
 8002952:	68e9      	ldr	r1, [r5, #12]
 8002954:	2001      	movs	r0, #1
 8002956:	4008      	ands	r0, r1
 8002958:	2100      	movs	r1, #0
 800295a:	4798      	blx	r3
 800295c:	68e9      	ldr	r1, [r5, #12]
 800295e:	2001      	movs	r0, #1
 8002960:	4008      	ands	r0, r1
 8002962:	f002 fb03 	bl	8004f6c <USBPD_PRL_SRCSetSinkNG>
 8002966:	68a8      	ldr	r0, [r5, #8]
 8002968:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800296a:	2b00      	cmp	r3, #0
 800296c:	d005      	beq.n	800297a <__iar_annotation$$branch+0x42a>
 800296e:	220b      	movs	r2, #11
 8002970:	68e9      	ldr	r1, [r5, #12]
 8002972:	2001      	movs	r0, #1
 8002974:	4008      	ands	r0, r1
 8002976:	2101      	movs	r1, #1
 8002978:	4798      	blx	r3
 800297a:	2101      	movs	r1, #1
 800297c:	4668      	mov	r0, sp
 800297e:	7b40      	ldrb	r0, [r0, #13]
 8002980:	f002 facf 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8002984:	2000      	movs	r0, #0
 8002986:	9000      	str	r0, [sp, #0]
 8002988:	2354      	movs	r3, #84	; 0x54
 800298a:	2206      	movs	r2, #6
 800298c:	2100      	movs	r1, #0
 800298e:	0028      	movs	r0, r5
 8002990:	f000 feef 	bl	8003772 <PE_Send_CtrlMessage>
 8002994:	2800      	cmp	r0, #0
 8002996:	d10c      	bne.n	80029b2 <__iar_annotation$$branch+0x462>
 8002998:	68a8      	ldr	r0, [r5, #8]
 800299a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800299c:	2b00      	cmp	r3, #0
 800299e:	d005      	beq.n	80029ac <__iar_annotation$$branch+0x45c>
 80029a0:	220c      	movs	r2, #12
 80029a2:	2100      	movs	r1, #0
 80029a4:	68ec      	ldr	r4, [r5, #12]
 80029a6:	2001      	movs	r0, #1
 80029a8:	4020      	ands	r0, r4
 80029aa:	4798      	blx	r3
 80029ac:	48b2      	ldr	r0, [pc, #712]	; (8002c78 <__iar_annotation$$branch+0x728>)
 80029ae:	8430      	strh	r0, [r6, #32]
 80029b0:	2414      	movs	r4, #20
 80029b2:	7930      	ldrb	r0, [r6, #4]
 80029b4:	2854      	cmp	r0, #84	; 0x54
 80029b6:	d05c      	beq.n	8002a72 <__iar_annotation$$branch+0x522>
 80029b8:	2100      	movs	r1, #0
 80029ba:	4668      	mov	r0, sp
 80029bc:	7b40      	ldrb	r0, [r0, #13]
 80029be:	f002 fab0 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 80029c2:	68a8      	ldr	r0, [r5, #8]
 80029c4:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80029c6:	2b00      	cmp	r3, #0
 80029c8:	d053      	beq.n	8002a72 <__iar_annotation$$branch+0x522>
 80029ca:	2206      	movs	r2, #6
 80029cc:	68e9      	ldr	r1, [r5, #12]
 80029ce:	2001      	movs	r0, #1
 80029d0:	4008      	ands	r0, r1
 80029d2:	2101      	movs	r1, #1
 80029d4:	4798      	blx	r3
 80029d6:	68a8      	ldr	r0, [r5, #8]
 80029d8:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80029da:	2b00      	cmp	r3, #0
 80029dc:	d049      	beq.n	8002a72 <__iar_annotation$$branch+0x522>
 80029de:	2207      	movs	r2, #7
 80029e0:	2100      	movs	r1, #0
 80029e2:	68e8      	ldr	r0, [r5, #12]
 80029e4:	4007      	ands	r7, r0
 80029e6:	0038      	movs	r0, r7
 80029e8:	e151      	b.n	8002c8e <__iar_annotation$$branch+0x73e>
 80029ea:	8c30      	ldrh	r0, [r6, #32]
 80029ec:	03a1      	lsls	r1, r4, #14
 80029ee:	4288      	cmp	r0, r1
 80029f0:	d13f      	bne.n	8002a72 <__iar_annotation$$branch+0x522>
 80029f2:	2000      	movs	r0, #0
 80029f4:	8430      	strh	r0, [r6, #32]
 80029f6:	2101      	movs	r1, #1
 80029f8:	0028      	movs	r0, r5
 80029fa:	f000 ffcf 	bl	800399c <PE_ChangePowerRole>
 80029fe:	68a8      	ldr	r0, [r5, #8]
 8002a00:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002a02:	2b00      	cmp	r3, #0
 8002a04:	d005      	beq.n	8002a12 <__iar_annotation$$branch+0x4c2>
 8002a06:	220e      	movs	r2, #14
 8002a08:	2101      	movs	r1, #1
 8002a0a:	7b2f      	ldrb	r7, [r5, #12]
 8002a0c:	07f8      	lsls	r0, r7, #31
 8002a0e:	0fc0      	lsrs	r0, r0, #31
 8002a10:	4798      	blx	r3
 8002a12:	7b29      	ldrb	r1, [r5, #12]
 8002a14:	07c8      	lsls	r0, r1, #31
 8002a16:	0fc0      	lsrs	r0, r0, #31
 8002a18:	f002 faac 	bl	8004f74 <USBPD_PRL_SRCReleaseSinkNG>
 8002a1c:	0028      	movs	r0, r5
 8002a1e:	f001 fc67 	bl	80042f0 <PE_ResetDuringSwap>
 8002a22:	48b0      	ldr	r0, [pc, #704]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002a24:	7800      	ldrb	r0, [r0, #0]
 8002a26:	0780      	lsls	r0, r0, #30
 8002a28:	d500      	bpl.n	8002a2c <__iar_annotation$$branch+0x4dc>
 8002a2a:	e14d      	b.n	8002cc8 <__iar_annotation$$branch+0x778>
 8002a2c:	e157      	b.n	8002cde <__iar_annotation$$branch+0x78e>
 8002a2e:	68a8      	ldr	r0, [r5, #8]
 8002a30:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002a32:	2b00      	cmp	r3, #0
 8002a34:	d005      	beq.n	8002a42 <__iar_annotation$$branch+0x4f2>
 8002a36:	2202      	movs	r2, #2
 8002a38:	7b29      	ldrb	r1, [r5, #12]
 8002a3a:	07c8      	lsls	r0, r1, #31
 8002a3c:	0fc0      	lsrs	r0, r0, #31
 8002a3e:	2100      	movs	r1, #0
 8002a40:	4798      	blx	r3
 8002a42:	9400      	str	r4, [sp, #0]
 8002a44:	2358      	movs	r3, #88	; 0x58
 8002a46:	20e5      	movs	r0, #229	; 0xe5
 8002a48:	0080      	lsls	r0, r0, #2
 8002a4a:	5c2a      	ldrb	r2, [r5, r0]
 8002a4c:	2100      	movs	r1, #0
 8002a4e:	0028      	movs	r0, r5
 8002a50:	f000 fe8f 	bl	8003772 <PE_Send_CtrlMessage>
 8002a54:	2800      	cmp	r0, #0
 8002a56:	d000      	beq.n	8002a5a <__iar_annotation$$branch+0x50a>
 8002a58:	e110      	b.n	8002c7c <__iar_annotation$$branch+0x72c>
 8002a5a:	20e5      	movs	r0, #229	; 0xe5
 8002a5c:	0080      	lsls	r0, r0, #2
 8002a5e:	1828      	adds	r0, r5, r0
 8002a60:	8840      	ldrh	r0, [r0, #2]
 8002a62:	82e8      	strh	r0, [r5, #22]
 8002a64:	8337      	strh	r7, [r6, #24]
 8002a66:	241a      	movs	r4, #26
 8002a68:	6868      	ldr	r0, [r5, #4]
 8002a6a:	6801      	ldr	r1, [r0, #0]
 8002a6c:	2210      	movs	r2, #16
 8002a6e:	430a      	orrs	r2, r1
 8002a70:	6002      	str	r2, [r0, #0]
 8002a72:	e24b      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002a74:	2911      	cmp	r1, #17
 8002a76:	d111      	bne.n	8002a9c <__iar_annotation$$branch+0x54c>
 8002a78:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002a7a:	0bc9      	lsrs	r1, r1, #15
 8002a7c:	d10e      	bne.n	8002a9c <__iar_annotation$$branch+0x54c>
 8002a7e:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002a80:	0b09      	lsrs	r1, r1, #12
 8002a82:	0749      	lsls	r1, r1, #29
 8002a84:	d10a      	bne.n	8002a9c <__iar_annotation$$branch+0x54c>
 8002a86:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002a88:	06c9      	lsls	r1, r1, #27
 8002a8a:	0ec9      	lsrs	r1, r1, #27
 8002a8c:	2903      	cmp	r1, #3
 8002a8e:	d006      	beq.n	8002a9e <__iar_annotation$$branch+0x54e>
 8002a90:	2904      	cmp	r1, #4
 8002a92:	d066      	beq.n	8002b62 <__iar_annotation$$branch+0x612>
 8002a94:	290c      	cmp	r1, #12
 8002a96:	d049      	beq.n	8002b2c <__iar_annotation$$branch+0x5dc>
 8002a98:	2910      	cmp	r1, #16
 8002a9a:	d077      	beq.n	8002b8c <__iar_annotation$$branch+0x63c>
 8002a9c:	e090      	b.n	8002bc0 <__iar_annotation$$branch+0x670>
 8002a9e:	4802      	ldr	r0, [pc, #8]	; (8002aa8 <__iar_annotation$$branch+0x558>)
 8002aa0:	82b0      	strh	r0, [r6, #20]
 8002aa2:	4c02      	ldr	r4, [pc, #8]	; (8002aac <__iar_annotation$$branch+0x55c>)
 8002aa4:	e004      	b.n	8002ab0 <__iar_annotation$$branch+0x560>
 8002aa6:	bf00      	nop
 8002aa8:	00008343 	.word	0x00008343
 8002aac:	00000343 	.word	0x00000343
 8002ab0:	2000      	movs	r0, #0
 8002ab2:	8330      	strh	r0, [r6, #24]
 8002ab4:	2014      	movs	r0, #20
 8002ab6:	4669      	mov	r1, sp
 8002ab8:	7308      	strb	r0, [r1, #12]
 8002aba:	2059      	movs	r0, #89	; 0x59
 8002abc:	7130      	strb	r0, [r6, #4]
 8002abe:	68a8      	ldr	r0, [r5, #8]
 8002ac0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002ac2:	2b00      	cmp	r3, #0
 8002ac4:	d005      	beq.n	8002ad2 <__iar_annotation$$branch+0x582>
 8002ac6:	2206      	movs	r2, #6
 8002ac8:	2100      	movs	r1, #0
 8002aca:	7b2f      	ldrb	r7, [r5, #12]
 8002acc:	07f8      	lsls	r0, r7, #31
 8002ace:	0fc0      	lsrs	r0, r0, #31
 8002ad0:	4798      	blx	r3
 8002ad2:	6868      	ldr	r0, [r5, #4]
 8002ad4:	7841      	ldrb	r1, [r0, #1]
 8002ad6:	228f      	movs	r2, #143	; 0x8f
 8002ad8:	400a      	ands	r2, r1
 8002ada:	2140      	movs	r1, #64	; 0x40
 8002adc:	4311      	orrs	r1, r2
 8002ade:	7041      	strb	r1, [r0, #1]
 8002ae0:	4880      	ldr	r0, [pc, #512]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002ae2:	7800      	ldrb	r0, [r0, #0]
 8002ae4:	0780      	lsls	r0, r0, #30
 8002ae6:	d50a      	bpl.n	8002afe <__iar_annotation$$branch+0x5ae>
 8002ae8:	2000      	movs	r0, #0
 8002aea:	9000      	str	r0, [sp, #0]
 8002aec:	2300      	movs	r3, #0
 8002aee:	2256      	movs	r2, #86	; 0x56
 8002af0:	7b28      	ldrb	r0, [r5, #12]
 8002af2:	07c1      	lsls	r1, r0, #31
 8002af4:	0fc9      	lsrs	r1, r1, #31
 8002af6:	2009      	movs	r0, #9
 8002af8:	4f7a      	ldr	r7, [pc, #488]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002afa:	68ff      	ldr	r7, [r7, #12]
 8002afc:	47b8      	blx	r7
 8002afe:	2156      	movs	r1, #86	; 0x56
 8002b00:	7b2a      	ldrb	r2, [r5, #12]
 8002b02:	07d0      	lsls	r0, r2, #31
 8002b04:	0fc0      	lsrs	r0, r0, #31
 8002b06:	68aa      	ldr	r2, [r5, #8]
 8002b08:	68d2      	ldr	r2, [r2, #12]
 8002b0a:	4790      	blx	r2
 8002b0c:	4f75      	ldr	r7, [pc, #468]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002b0e:	7838      	ldrb	r0, [r7, #0]
 8002b10:	0780      	lsls	r0, r0, #30
 8002b12:	d509      	bpl.n	8002b28 <__iar_annotation$$branch+0x5d8>
 8002b14:	2000      	movs	r0, #0
 8002b16:	9000      	str	r0, [sp, #0]
 8002b18:	2300      	movs	r3, #0
 8002b1a:	2238      	movs	r2, #56	; 0x38
 8002b1c:	7b28      	ldrb	r0, [r5, #12]
 8002b1e:	07c1      	lsls	r1, r0, #31
 8002b20:	0fc9      	lsrs	r1, r1, #31
 8002b22:	2009      	movs	r0, #9
 8002b24:	68ff      	ldr	r7, [r7, #12]
 8002b26:	47b8      	blx	r7
 8002b28:	2138      	movs	r1, #56	; 0x38
 8002b2a:	e043      	b.n	8002bb4 <__iar_annotation$$branch+0x664>
 8002b2c:	2800      	cmp	r0, #0
 8002b2e:	d009      	beq.n	8002b44 <__iar_annotation$$branch+0x5f4>
 8002b30:	2000      	movs	r0, #0
 8002b32:	9000      	str	r0, [sp, #0]
 8002b34:	2300      	movs	r3, #0
 8002b36:	2239      	movs	r2, #57	; 0x39
 8002b38:	7b28      	ldrb	r0, [r5, #12]
 8002b3a:	07c1      	lsls	r1, r0, #31
 8002b3c:	0fc9      	lsrs	r1, r1, #31
 8002b3e:	2009      	movs	r0, #9
 8002b40:	9f01      	ldr	r7, [sp, #4]
 8002b42:	47b8      	blx	r7
 8002b44:	2139      	movs	r1, #57	; 0x39
 8002b46:	7b2a      	ldrb	r2, [r5, #12]
 8002b48:	07d0      	lsls	r0, r2, #31
 8002b4a:	0fc0      	lsrs	r0, r0, #31
 8002b4c:	68aa      	ldr	r2, [r5, #8]
 8002b4e:	68d2      	ldr	r2, [r2, #12]
 8002b50:	4790      	blx	r2
 8002b52:	2000      	movs	r0, #0
 8002b54:	8330      	strh	r0, [r6, #24]
 8002b56:	2014      	movs	r0, #20
 8002b58:	4669      	mov	r1, sp
 8002b5a:	7308      	strb	r0, [r1, #12]
 8002b5c:	2003      	movs	r0, #3
 8002b5e:	7130      	strb	r0, [r6, #4]
 8002b60:	e02e      	b.n	8002bc0 <__iar_annotation$$branch+0x670>
 8002b62:	2100      	movs	r1, #0
 8002b64:	8331      	strh	r1, [r6, #24]
 8002b66:	2114      	movs	r1, #20
 8002b68:	466a      	mov	r2, sp
 8002b6a:	7311      	strb	r1, [r2, #12]
 8002b6c:	2103      	movs	r1, #3
 8002b6e:	7131      	strb	r1, [r6, #4]
 8002b70:	2800      	cmp	r0, #0
 8002b72:	d009      	beq.n	8002b88 <__iar_annotation$$branch+0x638>
 8002b74:	2000      	movs	r0, #0
 8002b76:	9000      	str	r0, [sp, #0]
 8002b78:	2300      	movs	r3, #0
 8002b7a:	2216      	movs	r2, #22
 8002b7c:	7b28      	ldrb	r0, [r5, #12]
 8002b7e:	07c1      	lsls	r1, r0, #31
 8002b80:	0fc9      	lsrs	r1, r1, #31
 8002b82:	2009      	movs	r0, #9
 8002b84:	9f01      	ldr	r7, [sp, #4]
 8002b86:	47b8      	blx	r7
 8002b88:	2116      	movs	r1, #22
 8002b8a:	e013      	b.n	8002bb4 <__iar_annotation$$branch+0x664>
 8002b8c:	2100      	movs	r1, #0
 8002b8e:	8331      	strh	r1, [r6, #24]
 8002b90:	2114      	movs	r1, #20
 8002b92:	466a      	mov	r2, sp
 8002b94:	7311      	strb	r1, [r2, #12]
 8002b96:	2103      	movs	r1, #3
 8002b98:	7131      	strb	r1, [r6, #4]
 8002b9a:	2800      	cmp	r0, #0
 8002b9c:	d009      	beq.n	8002bb2 <__iar_annotation$$branch+0x662>
 8002b9e:	2000      	movs	r0, #0
 8002ba0:	9000      	str	r0, [sp, #0]
 8002ba2:	2300      	movs	r3, #0
 8002ba4:	2255      	movs	r2, #85	; 0x55
 8002ba6:	7b28      	ldrb	r0, [r5, #12]
 8002ba8:	07c1      	lsls	r1, r0, #31
 8002baa:	0fc9      	lsrs	r1, r1, #31
 8002bac:	2009      	movs	r0, #9
 8002bae:	9f01      	ldr	r7, [sp, #4]
 8002bb0:	47b8      	blx	r7
 8002bb2:	2155      	movs	r1, #85	; 0x55
 8002bb4:	7b2a      	ldrb	r2, [r5, #12]
 8002bb6:	07d0      	lsls	r0, r2, #31
 8002bb8:	0fc0      	lsrs	r0, r0, #31
 8002bba:	68aa      	ldr	r2, [r5, #8]
 8002bbc:	68d2      	ldr	r2, [r2, #12]
 8002bbe:	4790      	blx	r2
 8002bc0:	8b30      	ldrh	r0, [r6, #24]
 8002bc2:	2180      	movs	r1, #128	; 0x80
 8002bc4:	0209      	lsls	r1, r1, #8
 8002bc6:	4288      	cmp	r0, r1
 8002bc8:	d155      	bne.n	8002c76 <__iar_annotation$$branch+0x726>
 8002bca:	2400      	movs	r4, #0
 8002bcc:	8334      	strh	r4, [r6, #24]
 8002bce:	e176      	b.n	8002ebe <__iar_annotation$$branch+0x96e>
 8002bd0:	2911      	cmp	r1, #17
 8002bd2:	d112      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002bd4:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002bd6:	0bc0      	lsrs	r0, r0, #15
 8002bd8:	d10f      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002bda:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002bdc:	0b00      	lsrs	r0, r0, #12
 8002bde:	0740      	lsls	r0, r0, #29
 8002be0:	d10b      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002be2:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002be4:	06c0      	lsls	r0, r0, #27
 8002be6:	0ec0      	lsrs	r0, r0, #27
 8002be8:	2806      	cmp	r0, #6
 8002bea:	d106      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002bec:	2000      	movs	r0, #0
 8002bee:	82b0      	strh	r0, [r6, #20]
 8002bf0:	205a      	movs	r0, #90	; 0x5a
 8002bf2:	7130      	strb	r0, [r6, #4]
 8002bf4:	2014      	movs	r0, #20
 8002bf6:	4669      	mov	r1, sp
 8002bf8:	7308      	strb	r0, [r1, #12]
 8002bfa:	8ab0      	ldrh	r0, [r6, #20]
 8002bfc:	03a1      	lsls	r1, r4, #14
 8002bfe:	4288      	cmp	r0, r1
 8002c00:	d139      	bne.n	8002c76 <__iar_annotation$$branch+0x726>
 8002c02:	68a8      	ldr	r0, [r5, #8]
 8002c04:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c06:	2b00      	cmp	r3, #0
 8002c08:	d005      	beq.n	8002c16 <__iar_annotation$$branch+0x6c6>
 8002c0a:	220f      	movs	r2, #15
 8002c0c:	2100      	movs	r1, #0
 8002c0e:	7b2f      	ldrb	r7, [r5, #12]
 8002c10:	07f8      	lsls	r0, r7, #31
 8002c12:	0fc0      	lsrs	r0, r0, #31
 8002c14:	4798      	blx	r3
 8002c16:	2000      	movs	r0, #0
 8002c18:	82b0      	strh	r0, [r6, #20]
 8002c1a:	200f      	movs	r0, #15
 8002c1c:	e175      	b.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002c1e:	68a8      	ldr	r0, [r5, #8]
 8002c20:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c22:	2701      	movs	r7, #1
 8002c24:	2b00      	cmp	r3, #0
 8002c26:	d00f      	beq.n	8002c48 <__iar_annotation$$branch+0x6f8>
 8002c28:	220a      	movs	r2, #10
 8002c2a:	68e9      	ldr	r1, [r5, #12]
 8002c2c:	2001      	movs	r0, #1
 8002c2e:	4008      	ands	r0, r1
 8002c30:	2100      	movs	r1, #0
 8002c32:	4798      	blx	r3
 8002c34:	68a8      	ldr	r0, [r5, #8]
 8002c36:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c38:	2b00      	cmp	r3, #0
 8002c3a:	d005      	beq.n	8002c48 <__iar_annotation$$branch+0x6f8>
 8002c3c:	220b      	movs	r2, #11
 8002c3e:	68e9      	ldr	r1, [r5, #12]
 8002c40:	2001      	movs	r0, #1
 8002c42:	4008      	ands	r0, r1
 8002c44:	2101      	movs	r1, #1
 8002c46:	4798      	blx	r3
 8002c48:	2000      	movs	r0, #0
 8002c4a:	9000      	str	r0, [sp, #0]
 8002c4c:	235b      	movs	r3, #91	; 0x5b
 8002c4e:	2206      	movs	r2, #6
 8002c50:	2100      	movs	r1, #0
 8002c52:	0028      	movs	r0, r5
 8002c54:	f000 fd8d 	bl	8003772 <PE_Send_CtrlMessage>
 8002c58:	2800      	cmp	r0, #0
 8002c5a:	d10f      	bne.n	8002c7c <__iar_annotation$$branch+0x72c>
 8002c5c:	68a8      	ldr	r0, [r5, #8]
 8002c5e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c60:	2b00      	cmp	r3, #0
 8002c62:	d005      	beq.n	8002c70 <__iar_annotation$$branch+0x720>
 8002c64:	220c      	movs	r2, #12
 8002c66:	2100      	movs	r1, #0
 8002c68:	68e8      	ldr	r0, [r5, #12]
 8002c6a:	4007      	ands	r7, r0
 8002c6c:	0038      	movs	r0, r7
 8002c6e:	4798      	blx	r3
 8002c70:	4801      	ldr	r0, [pc, #4]	; (8002c78 <__iar_annotation$$branch+0x728>)
 8002c72:	8430      	strh	r0, [r6, #32]
 8002c74:	2414      	movs	r4, #20
 8002c76:	e149      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002c78:	00008014 	.word	0x00008014
 8002c7c:	68a8      	ldr	r0, [r5, #8]
 8002c7e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c80:	2b00      	cmp	r3, #0
 8002c82:	d0f8      	beq.n	8002c76 <__iar_annotation$$branch+0x726>
 8002c84:	220f      	movs	r2, #15
 8002c86:	2100      	movs	r1, #0
 8002c88:	7b2f      	ldrb	r7, [r5, #12]
 8002c8a:	07f8      	lsls	r0, r7, #31
 8002c8c:	0fc0      	lsrs	r0, r0, #31
 8002c8e:	4798      	blx	r3
 8002c90:	e13c      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002c92:	8c30      	ldrh	r0, [r6, #32]
 8002c94:	03a1      	lsls	r1, r4, #14
 8002c96:	4288      	cmp	r0, r1
 8002c98:	d1fa      	bne.n	8002c90 <__iar_annotation$$branch+0x740>
 8002c9a:	2000      	movs	r0, #0
 8002c9c:	8430      	strh	r0, [r6, #32]
 8002c9e:	2101      	movs	r1, #1
 8002ca0:	0028      	movs	r0, r5
 8002ca2:	f000 fe7b 	bl	800399c <PE_ChangePowerRole>
 8002ca6:	0028      	movs	r0, r5
 8002ca8:	f001 fb22 	bl	80042f0 <PE_ResetDuringSwap>
 8002cac:	68a8      	ldr	r0, [r5, #8]
 8002cae:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002cb0:	2b00      	cmp	r3, #0
 8002cb2:	d005      	beq.n	8002cc0 <__iar_annotation$$branch+0x770>
 8002cb4:	220e      	movs	r2, #14
 8002cb6:	2101      	movs	r1, #1
 8002cb8:	7b2f      	ldrb	r7, [r5, #12]
 8002cba:	07f8      	lsls	r0, r7, #31
 8002cbc:	0fc0      	lsrs	r0, r0, #31
 8002cbe:	4798      	blx	r3
 8002cc0:	4808      	ldr	r0, [pc, #32]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002cc2:	7800      	ldrb	r0, [r0, #0]
 8002cc4:	0780      	lsls	r0, r0, #30
 8002cc6:	d50a      	bpl.n	8002cde <__iar_annotation$$branch+0x78e>
 8002cc8:	2000      	movs	r0, #0
 8002cca:	9000      	str	r0, [sp, #0]
 8002ccc:	2300      	movs	r3, #0
 8002cce:	2215      	movs	r2, #21
 8002cd0:	7b28      	ldrb	r0, [r5, #12]
 8002cd2:	07c1      	lsls	r1, r0, #31
 8002cd4:	0fc9      	lsrs	r1, r1, #31
 8002cd6:	2009      	movs	r0, #9
 8002cd8:	4f02      	ldr	r7, [pc, #8]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002cda:	68ff      	ldr	r7, [r7, #12]
 8002cdc:	47b8      	blx	r7
 8002cde:	2115      	movs	r1, #21
 8002ce0:	e0b8      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 8002ce2:	bf00      	nop
 8002ce4:	200019a8 	.word	0x200019a8
 8002ce8:	ab05      	add	r3, sp, #20
 8002cea:	aa08      	add	r2, sp, #32
 8002cec:	2100      	movs	r1, #0
 8002cee:	7b2f      	ldrb	r7, [r5, #12]
 8002cf0:	07f8      	lsls	r0, r7, #31
 8002cf2:	0fc0      	lsrs	r0, r0, #31
 8002cf4:	68af      	ldr	r7, [r5, #8]
 8002cf6:	69bf      	ldr	r7, [r7, #24]
 8002cf8:	47b8      	blx	r7
 8002cfa:	2000      	movs	r0, #0
 8002cfc:	9002      	str	r0, [sp, #8]
 8002cfe:	2003      	movs	r0, #3
 8002d00:	9001      	str	r0, [sp, #4]
 8002d02:	9805      	ldr	r0, [sp, #20]
 8002d04:	0880      	lsrs	r0, r0, #2
 8002d06:	9000      	str	r0, [sp, #0]
 8002d08:	ab08      	add	r3, sp, #32
 8002d0a:	2201      	movs	r2, #1
 8002d0c:	2100      	movs	r1, #0
 8002d0e:	0028      	movs	r0, r5
 8002d10:	f000 fd76 	bl	8003800 <PE_Send_DataMessage>
 8002d14:	e0fa      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002d16:	9402      	str	r4, [sp, #8]
 8002d18:	2003      	movs	r0, #3
 8002d1a:	9001      	str	r0, [sp, #4]
 8002d1c:	2001      	movs	r0, #1
 8002d1e:	9000      	str	r0, [sp, #0]
 8002d20:	20e3      	movs	r0, #227	; 0xe3
 8002d22:	0080      	lsls	r0, r0, #2
 8002d24:	182b      	adds	r3, r5, r0
 8002d26:	2206      	movs	r2, #6
 8002d28:	2100      	movs	r1, #0
 8002d2a:	0028      	movs	r0, r5
 8002d2c:	f000 fd68 	bl	8003800 <PE_Send_DataMessage>
 8002d30:	e0ec      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002d32:	9400      	str	r4, [sp, #0]
 8002d34:	2366      	movs	r3, #102	; 0x66
 8002d36:	2214      	movs	r2, #20
 8002d38:	2100      	movs	r1, #0
 8002d3a:	0028      	movs	r0, r5
 8002d3c:	f000 fd19 	bl	8003772 <PE_Send_CtrlMessage>
 8002d40:	2800      	cmp	r0, #0
 8002d42:	d1f5      	bne.n	8002d30 <__iar_annotation$$branch+0x7e0>
 8002d44:	8337      	strh	r7, [r6, #24]
 8002d46:	241a      	movs	r4, #26
 8002d48:	4fa8      	ldr	r7, [pc, #672]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002d4a:	7838      	ldrb	r0, [r7, #0]
 8002d4c:	0780      	lsls	r0, r0, #30
 8002d4e:	d509      	bpl.n	8002d64 <__iar_annotation$$branch+0x814>
 8002d50:	2000      	movs	r0, #0
 8002d52:	9000      	str	r0, [sp, #0]
 8002d54:	2300      	movs	r3, #0
 8002d56:	2247      	movs	r2, #71	; 0x47
 8002d58:	7b28      	ldrb	r0, [r5, #12]
 8002d5a:	07c1      	lsls	r1, r0, #31
 8002d5c:	0fc9      	lsrs	r1, r1, #31
 8002d5e:	2009      	movs	r0, #9
 8002d60:	68ff      	ldr	r7, [r7, #12]
 8002d62:	47b8      	blx	r7
 8002d64:	2147      	movs	r1, #71	; 0x47
 8002d66:	7b2a      	ldrb	r2, [r5, #12]
 8002d68:	07d0      	lsls	r0, r2, #31
 8002d6a:	0fc0      	lsrs	r0, r0, #31
 8002d6c:	68aa      	ldr	r2, [r5, #8]
 8002d6e:	68d2      	ldr	r2, [r2, #12]
 8002d70:	4790      	blx	r2
 8002d72:	200b      	movs	r0, #11
 8002d74:	82e8      	strh	r0, [r5, #22]
 8002d76:	e0c9      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002d78:	2911      	cmp	r1, #17
 8002d7a:	d107      	bne.n	8002d8c <__iar_annotation$$branch+0x83c>
 8002d7c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002d7e:	0bc0      	lsrs	r0, r0, #15
 8002d80:	d004      	beq.n	8002d8c <__iar_annotation$$branch+0x83c>
 8002d82:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002d84:	0b00      	lsrs	r0, r0, #12
 8002d86:	0740      	lsls	r0, r0, #29
 8002d88:	d000      	beq.n	8002d8c <__iar_annotation$$branch+0x83c>
 8002d8a:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002d8c:	8b30      	ldrh	r0, [r6, #24]
 8002d8e:	03a1      	lsls	r1, r4, #14
 8002d90:	4288      	cmp	r0, r1
 8002d92:	d1f0      	bne.n	8002d76 <__iar_annotation$$branch+0x826>
 8002d94:	2000      	movs	r0, #0
 8002d96:	8330      	strh	r0, [r6, #24]
 8002d98:	2003      	movs	r0, #3
 8002d9a:	7130      	strb	r0, [r6, #4]
 8002d9c:	e07a      	b.n	8002e94 <__iar_annotation$$branch+0x944>
 8002d9e:	9400      	str	r4, [sp, #0]
 8002da0:	2339      	movs	r3, #57	; 0x39
 8002da2:	20e5      	movs	r0, #229	; 0xe5
 8002da4:	0080      	lsls	r0, r0, #2
 8002da6:	5c2a      	ldrb	r2, [r5, r0]
 8002da8:	2100      	movs	r1, #0
 8002daa:	0028      	movs	r0, r5
 8002dac:	f000 fce1 	bl	8003772 <PE_Send_CtrlMessage>
 8002db0:	2800      	cmp	r0, #0
 8002db2:	d139      	bne.n	8002e28 <__iar_annotation$$branch+0x8d8>
 8002db4:	20e5      	movs	r0, #229	; 0xe5
 8002db6:	0080      	lsls	r0, r0, #2
 8002db8:	1828      	adds	r0, r5, r0
 8002dba:	8840      	ldrh	r0, [r0, #2]
 8002dbc:	82e8      	strh	r0, [r5, #22]
 8002dbe:	6868      	ldr	r0, [r5, #4]
 8002dc0:	7841      	ldrb	r1, [r0, #1]
 8002dc2:	228f      	movs	r2, #143	; 0x8f
 8002dc4:	400a      	ands	r2, r1
 8002dc6:	2130      	movs	r1, #48	; 0x30
 8002dc8:	4311      	orrs	r1, r2
 8002dca:	7041      	strb	r1, [r0, #1]
 8002dcc:	4887      	ldr	r0, [pc, #540]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002dce:	7800      	ldrb	r0, [r0, #0]
 8002dd0:	0780      	lsls	r0, r0, #30
 8002dd2:	d50a      	bpl.n	8002dea <__iar_annotation$$branch+0x89a>
 8002dd4:	2000      	movs	r0, #0
 8002dd6:	9000      	str	r0, [sp, #0]
 8002dd8:	2300      	movs	r3, #0
 8002dda:	2256      	movs	r2, #86	; 0x56
 8002ddc:	7b28      	ldrb	r0, [r5, #12]
 8002dde:	07c1      	lsls	r1, r0, #31
 8002de0:	0fc9      	lsrs	r1, r1, #31
 8002de2:	2009      	movs	r0, #9
 8002de4:	4c81      	ldr	r4, [pc, #516]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002de6:	68e4      	ldr	r4, [r4, #12]
 8002de8:	47a0      	blx	r4
 8002dea:	2156      	movs	r1, #86	; 0x56
 8002dec:	7b2a      	ldrb	r2, [r5, #12]
 8002dee:	07d0      	lsls	r0, r2, #31
 8002df0:	0fc0      	lsrs	r0, r0, #31
 8002df2:	68aa      	ldr	r2, [r5, #8]
 8002df4:	68d2      	ldr	r2, [r2, #12]
 8002df6:	4790      	blx	r2
 8002df8:	4c7c      	ldr	r4, [pc, #496]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002dfa:	7820      	ldrb	r0, [r4, #0]
 8002dfc:	0780      	lsls	r0, r0, #30
 8002dfe:	d509      	bpl.n	8002e14 <__iar_annotation$$branch+0x8c4>
 8002e00:	2000      	movs	r0, #0
 8002e02:	9000      	str	r0, [sp, #0]
 8002e04:	2300      	movs	r3, #0
 8002e06:	2241      	movs	r2, #65	; 0x41
 8002e08:	7b28      	ldrb	r0, [r5, #12]
 8002e0a:	07c1      	lsls	r1, r0, #31
 8002e0c:	0fc9      	lsrs	r1, r1, #31
 8002e0e:	2009      	movs	r0, #9
 8002e10:	68e4      	ldr	r4, [r4, #12]
 8002e12:	47a0      	blx	r4
 8002e14:	2141      	movs	r1, #65	; 0x41
 8002e16:	7b2a      	ldrb	r2, [r5, #12]
 8002e18:	07d0      	lsls	r0, r2, #31
 8002e1a:	0fc0      	lsrs	r0, r0, #31
 8002e1c:	68aa      	ldr	r2, [r5, #8]
 8002e1e:	68d2      	ldr	r2, [r2, #12]
 8002e20:	4790      	blx	r2
 8002e22:	8337      	strh	r7, [r6, #24]
 8002e24:	241a      	movs	r4, #26
 8002e26:	e071      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e28:	6868      	ldr	r0, [r5, #4]
 8002e2a:	7841      	ldrb	r1, [r0, #1]
 8002e2c:	228f      	movs	r2, #143	; 0x8f
 8002e2e:	400a      	ands	r2, r1
 8002e30:	2130      	movs	r1, #48	; 0x30
 8002e32:	4311      	orrs	r1, r2
 8002e34:	7041      	strb	r1, [r0, #1]
 8002e36:	4f6d      	ldr	r7, [pc, #436]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002e38:	7838      	ldrb	r0, [r7, #0]
 8002e3a:	0780      	lsls	r0, r0, #30
 8002e3c:	d509      	bpl.n	8002e52 <__iar_annotation$$branch+0x902>
 8002e3e:	2000      	movs	r0, #0
 8002e40:	9000      	str	r0, [sp, #0]
 8002e42:	2300      	movs	r3, #0
 8002e44:	2256      	movs	r2, #86	; 0x56
 8002e46:	7b28      	ldrb	r0, [r5, #12]
 8002e48:	07c1      	lsls	r1, r0, #31
 8002e4a:	0fc9      	lsrs	r1, r1, #31
 8002e4c:	2009      	movs	r0, #9
 8002e4e:	68ff      	ldr	r7, [r7, #12]
 8002e50:	47b8      	blx	r7
 8002e52:	2156      	movs	r1, #86	; 0x56
 8002e54:	7b2a      	ldrb	r2, [r5, #12]
 8002e56:	07d0      	lsls	r0, r2, #31
 8002e58:	0fc0      	lsrs	r0, r0, #31
 8002e5a:	68aa      	ldr	r2, [r5, #8]
 8002e5c:	68d2      	ldr	r2, [r2, #12]
 8002e5e:	4790      	blx	r2
 8002e60:	e054      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e62:	8b30      	ldrh	r0, [r6, #24]
 8002e64:	03a2      	lsls	r2, r4, #14
 8002e66:	4290      	cmp	r0, r2
 8002e68:	d10a      	bne.n	8002e80 <__iar_annotation$$branch+0x930>
 8002e6a:	2000      	movs	r0, #0
 8002e6c:	8330      	strh	r0, [r6, #24]
 8002e6e:	2103      	movs	r1, #3
 8002e70:	22e5      	movs	r2, #229	; 0xe5
 8002e72:	0092      	lsls	r2, r2, #2
 8002e74:	5caa      	ldrb	r2, [r5, r2]
 8002e76:	2a11      	cmp	r2, #17
 8002e78:	7131      	strb	r1, [r6, #4]
 8002e7a:	d147      	bne.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e7c:	2400      	movs	r4, #0
 8002e7e:	e045      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e80:	2914      	cmp	r1, #20
 8002e82:	d043      	beq.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e84:	2000      	movs	r0, #0
 8002e86:	8330      	strh	r0, [r6, #24]
 8002e88:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002e8a:	0bc0      	lsrs	r0, r0, #15
 8002e8c:	d006      	beq.n	8002e9c <__iar_annotation$$branch+0x94c>
 8002e8e:	0028      	movs	r0, r5
 8002e90:	f001 f842 	bl	8003f18 <PE_Check_ExtendedMessage>
 8002e94:	2014      	movs	r0, #20
 8002e96:	4669      	mov	r1, sp
 8002e98:	7308      	strb	r0, [r1, #12]
 8002e9a:	e037      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e9c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002e9e:	0bc0      	lsrs	r0, r0, #15
 8002ea0:	d10b      	bne.n	8002eba <__iar_annotation$$branch+0x96a>
 8002ea2:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002ea4:	0b00      	lsrs	r0, r0, #12
 8002ea6:	0740      	lsls	r0, r0, #29
 8002ea8:	d107      	bne.n	8002eba <__iar_annotation$$branch+0x96a>
 8002eaa:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002eac:	06c0      	lsls	r0, r0, #27
 8002eae:	0ec0      	lsrs	r0, r0, #27
 8002eb0:	2810      	cmp	r0, #16
 8002eb2:	d102      	bne.n	8002eba <__iar_annotation$$branch+0x96a>
 8002eb4:	2014      	movs	r0, #20
 8002eb6:	4669      	mov	r1, sp
 8002eb8:	7308      	strb	r0, [r1, #12]
 8002eba:	2000      	movs	r0, #0
 8002ebc:	8330      	strh	r0, [r6, #24]
 8002ebe:	2003      	movs	r0, #3
 8002ec0:	e023      	b.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002ec2:	0028      	movs	r0, r5
 8002ec4:	f001 fb51 	bl	800456a <PE_SubStateMachine_ExtendedMessages>
 8002ec8:	e003      	b.n	8002ed2 <__iar_annotation$$branch+0x982>
 8002eca:	a903      	add	r1, sp, #12
 8002ecc:	0028      	movs	r0, r5
 8002ece:	f001 fc63 	bl	8004798 <PE_SubStateMachine_Generic>
 8002ed2:	0004      	movs	r4, r0
 8002ed4:	e01a      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002ed6:	a903      	add	r1, sp, #12
 8002ed8:	0028      	movs	r0, r5
 8002eda:	f001 fdcf 	bl	8004a7c <PE_SubStateMachine_VconnSwap>
 8002ede:	0004      	movs	r4, r0
 8002ee0:	6868      	ldr	r0, [r5, #4]
 8002ee2:	6800      	ldr	r0, [r0, #0]
 8002ee4:	0340      	lsls	r0, r0, #13
 8002ee6:	0fc1      	lsrs	r1, r0, #31
 8002ee8:	4668      	mov	r0, sp
 8002eea:	7b40      	ldrb	r0, [r0, #13]
 8002eec:	f002 f855 	bl	8004f9a <USBPD_PRL_CableCapable>
 8002ef0:	e00c      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002ef2:	2106      	movs	r1, #6
 8002ef4:	4668      	mov	r0, sp
 8002ef6:	7b40      	ldrb	r0, [r0, #13]
 8002ef8:	f006 ff44 	bl	8009d84 <USBPD_PHY_ResetRequest>
 8002efc:	6868      	ldr	r0, [r5, #4]
 8002efe:	7840      	ldrb	r0, [r0, #1]
 8002f00:	0640      	lsls	r0, r0, #25
 8002f02:	0f40      	lsrs	r0, r0, #29
 8002f04:	2803      	cmp	r0, #3
 8002f06:	d000      	beq.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002f08:	2043      	movs	r0, #67	; 0x43
 8002f0a:	7130      	strb	r0, [r6, #4]
 8002f0c:	4837      	ldr	r0, [pc, #220]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002f0e:	68c7      	ldr	r7, [r0, #12]
 8002f10:	2f00      	cmp	r7, #0
 8002f12:	d00f      	beq.n	8002f34 <__iar_annotation$$branch+0x9e4>
 8002f14:	7800      	ldrb	r0, [r0, #0]
 8002f16:	07c0      	lsls	r0, r0, #31
 8002f18:	d50c      	bpl.n	8002f34 <__iar_annotation$$branch+0x9e4>
 8002f1a:	7932      	ldrb	r2, [r6, #4]
 8002f1c:	7970      	ldrb	r0, [r6, #5]
 8002f1e:	4290      	cmp	r0, r2
 8002f20:	d008      	beq.n	8002f34 <__iar_annotation$$branch+0x9e4>
 8002f22:	7172      	strb	r2, [r6, #5]
 8002f24:	2000      	movs	r0, #0
 8002f26:	9000      	str	r0, [sp, #0]
 8002f28:	2300      	movs	r3, #0
 8002f2a:	7b28      	ldrb	r0, [r5, #12]
 8002f2c:	07c1      	lsls	r1, r0, #31
 8002f2e:	0fc9      	lsrs	r1, r1, #31
 8002f30:	2004      	movs	r0, #4
 8002f32:	47b8      	blx	r7
 8002f34:	4668      	mov	r0, sp
 8002f36:	7b00      	ldrb	r0, [r0, #12]
 8002f38:	2814      	cmp	r0, #20
 8002f3a:	d01d      	beq.n	8002f78 <__iar_annotation$$branch+0xa28>
 8002f3c:	0028      	movs	r0, r5
 8002f3e:	f000 fd69 	bl	8003a14 <PE_Check_AMSConflict>
 8002f42:	2815      	cmp	r0, #21
 8002f44:	d102      	bne.n	8002f4c <__iar_annotation$$branch+0x9fc>
 8002f46:	2014      	movs	r0, #20
 8002f48:	4669      	mov	r1, sp
 8002f4a:	7308      	strb	r0, [r1, #12]
 8002f4c:	4827      	ldr	r0, [pc, #156]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002f4e:	68c4      	ldr	r4, [r0, #12]
 8002f50:	2c00      	cmp	r4, #0
 8002f52:	d00f      	beq.n	8002f74 <__iar_annotation$$branch+0xa24>
 8002f54:	7800      	ldrb	r0, [r0, #0]
 8002f56:	07c0      	lsls	r0, r0, #31
 8002f58:	d50c      	bpl.n	8002f74 <__iar_annotation$$branch+0xa24>
 8002f5a:	7932      	ldrb	r2, [r6, #4]
 8002f5c:	7970      	ldrb	r0, [r6, #5]
 8002f5e:	4290      	cmp	r0, r2
 8002f60:	d008      	beq.n	8002f74 <__iar_annotation$$branch+0xa24>
 8002f62:	7172      	strb	r2, [r6, #5]
 8002f64:	2000      	movs	r0, #0
 8002f66:	9000      	str	r0, [sp, #0]
 8002f68:	2300      	movs	r3, #0
 8002f6a:	7b28      	ldrb	r0, [r5, #12]
 8002f6c:	07c1      	lsls	r1, r0, #31
 8002f6e:	0fc9      	lsrs	r1, r1, #31
 8002f70:	2004      	movs	r0, #4
 8002f72:	47a0      	blx	r4
 8002f74:	2400      	movs	r4, #0
 8002f76:	e012      	b.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f78:	7930      	ldrb	r0, [r6, #4]
 8002f7a:	2803      	cmp	r0, #3
 8002f7c:	d10f      	bne.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f7e:	200a      	movs	r0, #10
 8002f80:	5e30      	ldrsh	r0, [r6, r0]
 8002f82:	2800      	cmp	r0, #0
 8002f84:	d00b      	beq.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f86:	2116      	movs	r1, #22
 8002f88:	5e69      	ldrsh	r1, [r5, r1]
 8002f8a:	2900      	cmp	r1, #0
 8002f8c:	d107      	bne.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f8e:	7a31      	ldrb	r1, [r6, #8]
 8002f90:	7131      	strb	r1, [r6, #4]
 8002f92:	7a71      	ldrb	r1, [r6, #9]
 8002f94:	71f1      	strb	r1, [r6, #7]
 8002f96:	82e8      	strh	r0, [r5, #22]
 8002f98:	2000      	movs	r0, #0
 8002f9a:	8170      	strh	r0, [r6, #10]
 8002f9c:	2401      	movs	r4, #1
 8002f9e:	9807      	ldr	r0, [sp, #28]
 8002fa0:	2800      	cmp	r0, #0
 8002fa2:	d01d      	beq.n	8002fe0 <__iar_annotation$$branch+0xa90>
 8002fa4:	4811      	ldr	r0, [pc, #68]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002fa6:	6901      	ldr	r1, [r0, #16]
 8002fa8:	4aa9      	ldr	r2, [pc, #676]	; (8003250 <.text_23>)
 8002faa:	4291      	cmp	r1, r2
 8002fac:	d018      	beq.n	8002fe0 <__iar_annotation$$branch+0xa90>
 8002fae:	2101      	movs	r1, #1
 8002fb0:	1d02      	adds	r2, r0, #4
 8002fb2:	68eb      	ldr	r3, [r5, #12]
 8002fb4:	400b      	ands	r3, r1
 8002fb6:	009b      	lsls	r3, r3, #2
 8002fb8:	58d2      	ldr	r2, [r2, r3]
 8002fba:	68d7      	ldr	r7, [r2, #12]
 8002fbc:	0b3e      	lsrs	r6, r7, #12
 8002fbe:	1c76      	adds	r6, r6, #1
 8002fc0:	4ba4      	ldr	r3, [pc, #656]	; (8003254 <.text_24>)
 8002fc2:	401f      	ands	r7, r3
 8002fc4:	0336      	lsls	r6, r6, #12
 8002fc6:	433e      	orrs	r6, r7
 8002fc8:	60d6      	str	r6, [r2, #12]
 8002fca:	1d00      	adds	r0, r0, #4
 8002fcc:	68ea      	ldr	r2, [r5, #12]
 8002fce:	4011      	ands	r1, r2
 8002fd0:	0089      	lsls	r1, r1, #2
 8002fd2:	5840      	ldr	r0, [r0, r1]
 8002fd4:	68c1      	ldr	r1, [r0, #12]
 8002fd6:	0b0a      	lsrs	r2, r1, #12
 8002fd8:	2a08      	cmp	r2, #8
 8002fda:	db01      	blt.n	8002fe0 <__iar_annotation$$branch+0xa90>
 8002fdc:	400b      	ands	r3, r1
 8002fde:	60c3      	str	r3, [r0, #12]
 8002fe0:	2c00      	cmp	r4, #0
 8002fe2:	d00a      	beq.n	8002ffa <__iar_annotation$$branch+0xaaa>
 8002fe4:	0020      	movs	r0, r4
 8002fe6:	b00f      	add	sp, #60	; 0x3c
 8002fe8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002fea:	bf00      	nop
 8002fec:	200019a8 	.word	0x200019a8
 8002ff0:	4668      	mov	r0, sp
 8002ff2:	7345      	strb	r5, [r0, #13]
 8002ff4:	9d06      	ldr	r5, [sp, #24]
 8002ff6:	9407      	str	r4, [sp, #28]
 8002ff8:	9606      	str	r6, [sp, #24]
 8002ffa:	2402      	movs	r4, #2
 8002ffc:	20d5      	movs	r0, #213	; 0xd5
 8002ffe:	0080      	lsls	r0, r0, #2
 8003000:	182e      	adds	r6, r5, r0
 8003002:	7832      	ldrb	r2, [r6, #0]
 8003004:	2a0f      	cmp	r2, #15
 8003006:	d115      	bne.n	8003034 <__iar_annotation$$branch+0xae4>
 8003008:	7132      	strb	r2, [r6, #4]
 800300a:	2000      	movs	r0, #0
 800300c:	7030      	strb	r0, [r6, #0]
 800300e:	4892      	ldr	r0, [pc, #584]	; (8003258 <.text_25>)
 8003010:	68c7      	ldr	r7, [r0, #12]
 8003012:	2f00      	cmp	r7, #0
 8003014:	d00e      	beq.n	8003034 <__iar_annotation$$branch+0xae4>
 8003016:	7800      	ldrb	r0, [r0, #0]
 8003018:	07c0      	lsls	r0, r0, #31
 800301a:	d50b      	bpl.n	8003034 <__iar_annotation$$branch+0xae4>
 800301c:	7970      	ldrb	r0, [r6, #5]
 800301e:	4290      	cmp	r0, r2
 8003020:	d008      	beq.n	8003034 <__iar_annotation$$branch+0xae4>
 8003022:	7172      	strb	r2, [r6, #5]
 8003024:	2000      	movs	r0, #0
 8003026:	9000      	str	r0, [sp, #0]
 8003028:	2300      	movs	r3, #0
 800302a:	7b28      	ldrb	r0, [r5, #12]
 800302c:	07c1      	lsls	r1, r0, #31
 800302e:	0fc9      	lsrs	r1, r1, #31
 8003030:	2004      	movs	r0, #4
 8003032:	47b8      	blx	r7
 8003034:	9806      	ldr	r0, [sp, #24]
 8003036:	2800      	cmp	r0, #0
 8003038:	d006      	beq.n	8003048 <__iar_annotation$$branch+0xaf8>
 800303a:	2107      	movs	r1, #7
 800303c:	f002 fe34 	bl	8005ca8 <__aeabi_idivmod>
 8003040:	2900      	cmp	r1, #0
 8003042:	d101      	bne.n	8003048 <__iar_annotation$$branch+0xaf8>
 8003044:	2001      	movs	r0, #1
 8003046:	9007      	str	r0, [sp, #28]
 8003048:	4983      	ldr	r1, [pc, #524]	; (8003258 <.text_25>)
 800304a:	7808      	ldrb	r0, [r1, #0]
 800304c:	4020      	ands	r0, r4
 800304e:	68c9      	ldr	r1, [r1, #12]
 8003050:	9101      	str	r1, [sp, #4]
 8003052:	4669      	mov	r1, sp
 8003054:	7b09      	ldrb	r1, [r1, #12]
 8003056:	4f81      	ldr	r7, [pc, #516]	; (800325c <.text_26>)
 8003058:	7932      	ldrb	r2, [r6, #4]
 800305a:	2a00      	cmp	r2, #0
 800305c:	d101      	bne.n	8003062 <__iar_annotation$$branch+0x4>

0800305e <__iar_annotation$$branch>:
 800305e:	f7fe fe4e 	bl	8001cfe <__iar_annotation$$branch+0x4>
 8003062:	1e52      	subs	r2, r2, #1
 8003064:	d046      	beq.n	80030f4 <__iar_annotation$$branch+0x2c>
 8003066:	1e92      	subs	r2, r2, #2
 8003068:	d101      	bne.n	800306e <__iar_annotation$$branch+0x4>

0800306a <__iar_annotation$$branch>:
 800306a:	f7ff fa41 	bl	80024f0 <__iar_annotation$$branch+0x26>
 800306e:	1e52      	subs	r2, r2, #1
 8003070:	d101      	bne.n	8003076 <__iar_annotation$$branch+0x4>

08003072 <__iar_annotation$$branch>:
 8003072:	f7ff fa54 	bl	800251e <__iar_annotation$$branch+0x54>
 8003076:	3a0b      	subs	r2, #11
 8003078:	d101      	bne.n	800307e <__iar_annotation$$branch+0x4>

0800307a <__iar_annotation$$branch>:
 800307a:	f7fe ffdb 	bl	8002034 <__iar_annotation$$branch+0x202>
 800307e:	1e52      	subs	r2, r2, #1
 8003080:	d101      	bne.n	8003086 <__iar_annotation$$branch+0x4>

08003082 <__iar_annotation$$branch>:
 8003082:	f7ff f894 	bl	80021ae <__iar_annotation$$branch+0x37c>
 8003086:	1e52      	subs	r2, r2, #1
 8003088:	d101      	bne.n	800308e <__iar_annotation$$branch+0x4>

0800308a <__iar_annotation$$branch>:
 800308a:	f7ff f8ab 	bl	80021e4 <__iar_annotation$$branch+0x3b2>
 800308e:	1fd2      	subs	r2, r2, #7
 8003090:	d101      	bne.n	8003096 <__iar_annotation$$branch+0x4>

08003092 <__iar_annotation$$branch>:
 8003092:	f7ff f996 	bl	80023c2 <__iar_annotation$$branch+0x4>
 8003096:	1e92      	subs	r2, r2, #2
 8003098:	d101      	bne.n	800309e <__iar_annotation$$branch+0x4>

0800309a <__iar_annotation$$branch>:
 800309a:	f7ff f91c 	bl	80022d6 <__iar_annotation$$branch+0x66>
 800309e:	1ed2      	subs	r2, r2, #3
 80030a0:	d101      	bne.n	80030a6 <__iar_annotation$$branch+0x4>

080030a2 <__iar_annotation$$branch>:
 80030a2:	f7ff f8e7 	bl	8002274 <__iar_annotation$$branch+0x4>
 80030a6:	1e52      	subs	r2, r2, #1
 80030a8:	d100      	bne.n	80030ac <__iar_annotation$$branch+0xa>
 80030aa:	e4c0      	b.n	8002a2e <__iar_annotation$$branch+0x4de>
 80030ac:	1f12      	subs	r2, r2, #4
 80030ae:	d101      	bne.n	80030b4 <__iar_annotation$$branch+0x4>

080030b0 <__iar_annotation$$branch>:
 80030b0:	f7ff fb88 	bl	80027c4 <__iar_annotation$$branch+0x274>
 80030b4:	1f52      	subs	r2, r2, #5
 80030b6:	d101      	bne.n	80030bc <__iar_annotation$$branch+0x4>

080030b8 <__iar_annotation$$branch>:
 80030b8:	f7ff f93f 	bl	800233a <__iar_annotation$$branch+0x4>
 80030bc:	1e92      	subs	r2, r2, #2
 80030be:	d101      	bne.n	80030c4 <__iar_annotation$$branch+0x4>

080030c0 <__iar_annotation$$branch>:
 80030c0:	f7ff f927 	bl	8002312 <__iar_annotation$$branch+0xa2>
 80030c4:	1e52      	subs	r2, r2, #1
 80030c6:	d101      	bne.n	80030cc <__iar_annotation$$branch+0x4>

080030c8 <__iar_annotation$$branch>:
 80030c8:	f7ff fa01 	bl	80024ce <__iar_annotation$$branch+0x4>
 80030cc:	1e52      	subs	r2, r2, #1
 80030ce:	d100      	bne.n	80030d2 <__iar_annotation$$branch+0xa>
 80030d0:	e621      	b.n	8002d16 <__iar_annotation$$branch+0x7c6>
 80030d2:	1e52      	subs	r2, r2, #1
 80030d4:	d00e      	beq.n	80030f4 <__iar_annotation$$branch+0x2c>
 80030d6:	1e92      	subs	r2, r2, #2
 80030d8:	d100      	bne.n	80030dc <__iar_annotation$$branch+0x14>
 80030da:	e660      	b.n	8002d9e <__iar_annotation$$branch+0x84e>
 80030dc:	1e52      	subs	r2, r2, #1
 80030de:	2a01      	cmp	r2, #1
 80030e0:	d908      	bls.n	80030f4 <__iar_annotation$$branch+0x2c>
 80030e2:	1e92      	subs	r2, r2, #2
 80030e4:	2a07      	cmp	r2, #7
 80030e6:	d800      	bhi.n	80030ea <__iar_annotation$$branch+0x22>
 80030e8:	e6eb      	b.n	8002ec2 <__iar_annotation$$branch+0x972>
 80030ea:	3a08      	subs	r2, #8
 80030ec:	d100      	bne.n	80030f0 <__iar_annotation$$branch+0x28>
 80030ee:	e6b8      	b.n	8002e62 <__iar_annotation$$branch+0x912>
 80030f0:	1e52      	subs	r2, r2, #1
 80030f2:	2a03      	cmp	r2, #3
 80030f4:	d800      	bhi.n	80030f8 <__iar_annotation$$branch+0x30>
 80030f6:	e6e8      	b.n	8002eca <__iar_annotation$$branch+0x97a>
 80030f8:	1f12      	subs	r2, r2, #4
 80030fa:	d101      	bne.n	8003100 <__iar_annotation$$branch+0x4>

080030fc <__iar_annotation$$branch>:
 80030fc:	f7fe fe08 	bl	8001d10 <__iar_annotation$$branch+0x4>
 8003100:	1e52      	subs	r2, r2, #1
 8003102:	d101      	bne.n	8003108 <__iar_annotation$$branch+0x4>

08003104 <__iar_annotation$$branch>:
 8003104:	f7fe ffd6 	bl	80020b4 <__iar_annotation$$branch+0x282>
 8003108:	1e52      	subs	r2, r2, #1
 800310a:	d101      	bne.n	8003110 <__iar_annotation$$branch+0x4>

0800310c <__iar_annotation$$branch>:
 800310c:	f7ff f82a 	bl	8002164 <__iar_annotation$$branch+0x332>
 8003110:	1ed2      	subs	r2, r2, #3
 8003112:	d101      	bne.n	8003118 <__iar_annotation$$branch+0x4>

08003114 <__iar_annotation$$branch>:
 8003114:	f7fe fe2a 	bl	8001d6c <__iar_annotation$$branch+0x4>
 8003118:	1e52      	subs	r2, r2, #1
 800311a:	d101      	bne.n	8003120 <__iar_annotation$$branch+0x4>

0800311c <__iar_annotation$$branch>:
 800311c:	f7fe fe66 	bl	8001dec <__iar_annotation$$branch+0x84>
 8003120:	1e52      	subs	r2, r2, #1
 8003122:	d101      	bne.n	8003128 <__iar_annotation$$branch+0x4>

08003124 <__iar_annotation$$branch>:
 8003124:	f7fe fe78 	bl	8001e18 <__iar_annotation$$branch+0xb0>
 8003128:	1e52      	subs	r2, r2, #1
 800312a:	d101      	bne.n	8003130 <__iar_annotation$$branch+0x4>

0800312c <__iar_annotation$$branch>:
 800312c:	f7fe fe83 	bl	8001e36 <__iar_annotation$$branch+0x4>
 8003130:	1e52      	subs	r2, r2, #1
 8003132:	d101      	bne.n	8003138 <__iar_annotation$$branch+0x4>

08003134 <__iar_annotation$$branch>:
 8003134:	f7fe ff28 	bl	8001f88 <__iar_annotation$$branch+0x156>
 8003138:	1e92      	subs	r2, r2, #2
 800313a:	d101      	bne.n	8003140 <__iar_annotation$$branch+0x4>

0800313c <__iar_annotation$$branch>:
 800313c:	f7ff f9d5 	bl	80024ea <__iar_annotation$$branch+0x20>
 8003140:	1ed2      	subs	r2, r2, #3
 8003142:	d100      	bne.n	8003146 <__iar_annotation$$branch+0xa>
 8003144:	e5d0      	b.n	8002ce8 <__iar_annotation$$branch+0x798>
 8003146:	1f12      	subs	r2, r2, #4
 8003148:	d101      	bne.n	800314e <__iar_annotation$$branch+0x4>

0800314a <__iar_annotation$$branch>:
 800314a:	f7ff f872 	bl	8002232 <__iar_annotation$$branch+0x400>
 800314e:	1e92      	subs	r2, r2, #2
 8003150:	d101      	bne.n	8003156 <__iar_annotation$$branch+0x4>

08003152 <__iar_annotation$$branch>:
 8003152:	f7ff fbb1 	bl	80028b8 <__iar_annotation$$branch+0x368>
 8003156:	1e52      	subs	r2, r2, #1
 8003158:	d101      	bne.n	800315e <__iar_annotation$$branch+0x4>

0800315a <__iar_annotation$$branch>:
 800315a:	f7ff fbda 	bl	8002912 <__iar_annotation$$branch+0x3c2>
 800315e:	1e52      	subs	r2, r2, #1
 8003160:	d100      	bne.n	8003164 <__iar_annotation$$branch+0xa>
 8003162:	e442      	b.n	80029ea <__iar_annotation$$branch+0x49a>
 8003164:	1f12      	subs	r2, r2, #4
 8003166:	d100      	bne.n	800316a <__iar_annotation$$branch+0x10>
 8003168:	e484      	b.n	8002a74 <__iar_annotation$$branch+0x524>
 800316a:	1e52      	subs	r2, r2, #1
 800316c:	d100      	bne.n	8003170 <__iar_annotation$$branch+0x16>
 800316e:	e52f      	b.n	8002bd0 <__iar_annotation$$branch+0x680>
 8003170:	1e52      	subs	r2, r2, #1
 8003172:	d100      	bne.n	8003176 <__iar_annotation$$branch+0x1c>
 8003174:	e553      	b.n	8002c1e <__iar_annotation$$branch+0x6ce>
 8003176:	1e52      	subs	r2, r2, #1
 8003178:	d100      	bne.n	800317c <__iar_annotation$$branch+0x22>
 800317a:	e58a      	b.n	8002c92 <__iar_annotation$$branch+0x742>
 800317c:	1e92      	subs	r2, r2, #2
 800317e:	d101      	bne.n	8003184 <__iar_annotation$$branch+0x4>

08003180 <__iar_annotation$$branch>:
 8003180:	f7ff f8e9 	bl	8002356 <__iar_annotation$$branch+0x20>
 8003184:	1ed2      	subs	r2, r2, #3
 8003186:	d101      	bne.n	800318c <__iar_annotation$$branch+0x4>

08003188 <__iar_annotation$$branch>:
 8003188:	f7ff f939 	bl	80023fe <__iar_annotation$$branch+0x40>
 800318c:	1e92      	subs	r2, r2, #2
 800318e:	2a01      	cmp	r2, #1
 8003190:	d9b0      	bls.n	80030f4 <__iar_annotation$$branch+0x2c>
 8003192:	1ed2      	subs	r2, r2, #3
 8003194:	d100      	bne.n	8003198 <__iar_annotation$$branch+0x10>
 8003196:	e5cc      	b.n	8002d32 <__iar_annotation$$branch+0x7e2>
 8003198:	1e52      	subs	r2, r2, #1
 800319a:	d100      	bne.n	800319e <__iar_annotation$$branch+0x16>
 800319c:	e5ec      	b.n	8002d78 <__iar_annotation$$branch+0x828>
 800319e:	3a0e      	subs	r2, #14
 80031a0:	d0a8      	beq.n	80030f4 <__iar_annotation$$branch+0x2c>
 80031a2:	3a1e      	subs	r2, #30
 80031a4:	d01e      	beq.n	80031e4 <__iar_annotation$$branch+0x14>
 80031a6:	1e52      	subs	r2, r2, #1
 80031a8:	d101      	bne.n	80031ae <__iar_annotation$$branch+0x4>

080031aa <__iar_annotation$$branch>:
 80031aa:	f7ff fa2e 	bl	800260a <__iar_annotation$$branch+0xba>
 80031ae:	1e52      	subs	r2, r2, #1
 80031b0:	d101      	bne.n	80031b6 <__iar_annotation$$branch+0x4>

080031b2 <__iar_annotation$$branch>:
 80031b2:	f7ff fa81 	bl	80026b8 <__iar_annotation$$branch+0x168>
 80031b6:	1e52      	subs	r2, r2, #1
 80031b8:	d101      	bne.n	80031be <__iar_annotation$$branch+0x4>

080031ba <__iar_annotation$$branch>:
 80031ba:	f7ff fa8a 	bl	80026d2 <__iar_annotation$$branch+0x182>
 80031be:	1ed2      	subs	r2, r2, #3
 80031c0:	d101      	bne.n	80031c6 <__iar_annotation$$branch+0x4>

080031c2 <__iar_annotation$$branch>:
 80031c2:	f7ff f8d7 	bl	8002374 <__iar_annotation$$branch+0x4>
 80031c6:	1e52      	subs	r2, r2, #1
 80031c8:	d100      	bne.n	80031cc <__iar_annotation$$branch+0xa>
 80031ca:	e692      	b.n	8002ef2 <__iar_annotation$$branch+0x9a2>
 80031cc:	1e92      	subs	r2, r2, #2
 80031ce:	d101      	bne.n	80031d4 <__iar_annotation$$branch+0x4>

080031d0 <__iar_annotation$$branch>:
 80031d0:	f7fe ffa5 	bl	800211e <__iar_annotation$$branch+0x2ec>
 80031d4:	1e52      	subs	r2, r2, #1
 80031d6:	2a08      	cmp	r2, #8
 80031d8:	d800      	bhi.n	80031dc <__iar_annotation$$branch+0xc>
 80031da:	e67c      	b.n	8002ed6 <__iar_annotation$$branch+0x986>
 80031dc:	3a09      	subs	r2, #9
 80031de:	d100      	bne.n	80031e2 <__iar_annotation$$branch+0x12>
 80031e0:	e66f      	b.n	8002ec2 <__iar_annotation$$branch+0x972>
 80031e2:	e693      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 80031e4:	68a8      	ldr	r0, [r5, #8]
 80031e6:	6b81      	ldr	r1, [r0, #56]	; 0x38
 80031e8:	2900      	cmp	r1, #0
 80031ea:	d003      	beq.n	80031f4 <__iar_annotation$$branch+0x24>
 80031ec:	7b2a      	ldrb	r2, [r5, #12]
 80031ee:	07d0      	lsls	r0, r2, #31
 80031f0:	0fc0      	lsrs	r0, r0, #31
 80031f2:	4788      	blx	r1
 80031f4:	2014      	movs	r0, #20
 80031f6:	4669      	mov	r1, sp
 80031f8:	7308      	strb	r0, [r1, #12]
 80031fa:	2101      	movs	r1, #1
 80031fc:	4668      	mov	r0, sp
 80031fe:	7b40      	ldrb	r0, [r0, #13]
 8003200:	f000 ffc5 	bl	800418e <PE_Reset>
 8003204:	4668      	mov	r0, sp
 8003206:	7b40      	ldrb	r0, [r0, #13]
 8003208:	f002 f924 	bl	8005454 <USBPD_PRL_Reset>
 800320c:	e67e      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>

0800320e <USBPD_PE_StateMachine_DRP>:
 800320e:	b580      	push	{r7, lr}
 8003210:	4911      	ldr	r1, [pc, #68]	; (8003258 <.text_25>)
 8003212:	0082      	lsls	r2, r0, #2
 8003214:	1889      	adds	r1, r1, r2
 8003216:	6849      	ldr	r1, [r1, #4]
 8003218:	6849      	ldr	r1, [r1, #4]
 800321a:	7809      	ldrb	r1, [r1, #0]
 800321c:	0889      	lsrs	r1, r1, #2
 800321e:	07c9      	lsls	r1, r1, #31
 8003220:	d502      	bpl.n	8003228 <USBPD_PE_StateMachine_DRP+0x1a>
 8003222:	f7fd f973 	bl	800050c <USBPD_PE_StateMachine_SRC>
 8003226:	bd02      	pop	{r1, pc}
 8003228:	f7fe fd00 	bl	8001c2c <USBPD_PE_StateMachine_SNK>
 800322c:	bd02      	pop	{r1, pc}

0800322e <USBPD_PE_Request_HardReset>:
 800322e:	b580      	push	{r7, lr}
 8003230:	4909      	ldr	r1, [pc, #36]	; (8003258 <.text_25>)
 8003232:	0082      	lsls	r2, r0, #2
 8003234:	1889      	adds	r1, r1, r2
 8003236:	6849      	ldr	r1, [r1, #4]
 8003238:	22d5      	movs	r2, #213	; 0xd5
 800323a:	0092      	lsls	r2, r2, #2
 800323c:	188a      	adds	r2, r1, r2
 800323e:	2300      	movs	r3, #0
 8003240:	7053      	strb	r3, [r2, #1]
 8003242:	230f      	movs	r3, #15
 8003244:	7013      	strb	r3, [r2, #0]
 8003246:	6889      	ldr	r1, [r1, #8]
 8003248:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800324a:	4788      	blx	r1
 800324c:	2000      	movs	r0, #0
 800324e:	bd02      	pop	{r1, pc}

08003250 <.text_23>:
 8003250:	b5e8b5cd 	.word	0xb5e8b5cd

08003254 <.text_24>:
 8003254:	00000fff 	.word	0x00000fff

08003258 <.text_25>:
 8003258:	200019a8 	.word	0x200019a8

0800325c <.text_26>:
 800325c:	0000801a 	.word	0x0000801a

08003260 <USBPD_PE_Request_CtrlMessage>:
 8003260:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 8003262:	b082      	sub	sp, #8
 8003264:	48b9      	ldr	r0, [pc, #740]	; (800354c <.text_29>)
 8003266:	466b      	mov	r3, sp
 8003268:	7a1b      	ldrb	r3, [r3, #8]
 800326a:	009b      	lsls	r3, r3, #2
 800326c:	58c0      	ldr	r0, [r0, r3]
 800326e:	9000      	str	r0, [sp, #0]
 8003270:	2402      	movs	r4, #2
 8003272:	23d5      	movs	r3, #213	; 0xd5
 8003274:	009b      	lsls	r3, r3, #2
 8003276:	18c0      	adds	r0, r0, r3
 8003278:	7803      	ldrb	r3, [r0, #0]
 800327a:	2b00      	cmp	r3, #0
 800327c:	d106      	bne.n	800328c <USBPD_PE_Request_CtrlMessage+0x2c>
 800327e:	9b00      	ldr	r3, [sp, #0]
 8003280:	685b      	ldr	r3, [r3, #4]
 8003282:	2501      	movs	r5, #1
 8003284:	681e      	ldr	r6, [r3, #0]
 8003286:	0af6      	lsrs	r6, r6, #11
 8003288:	402e      	ands	r6, r5
 800328a:	d101      	bne.n	8003290 <USBPD_PE_Request_CtrlMessage+0x30>
 800328c:	2003      	movs	r0, #3
 800328e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8003290:	466e      	mov	r6, sp
 8003292:	7132      	strb	r2, [r6, #4]
 8003294:	466a      	mov	r2, sp
 8003296:	7151      	strb	r1, [r2, #5]
 8003298:	9900      	ldr	r1, [sp, #0]
 800329a:	22e5      	movs	r2, #229	; 0xe5
 800329c:	0092      	lsls	r2, r2, #2
 800329e:	1889      	adds	r1, r1, r2
 80032a0:	222e      	movs	r2, #46	; 0x2e
 80032a2:	2603      	movs	r6, #3
 80032a4:	466f      	mov	r7, sp
 80032a6:	797f      	ldrb	r7, [r7, #5]
 80032a8:	2f02      	cmp	r7, #2
 80032aa:	d01a      	beq.n	80032e2 <USBPD_PE_Request_CtrlMessage+0x82>
 80032ac:	2f07      	cmp	r7, #7
 80032ae:	d029      	beq.n	8003304 <USBPD_PE_Request_CtrlMessage+0xa4>
 80032b0:	2f08      	cmp	r7, #8
 80032b2:	d03a      	beq.n	800332a <USBPD_PE_Request_CtrlMessage+0xca>
 80032b4:	2f09      	cmp	r7, #9
 80032b6:	d04b      	beq.n	8003350 <USBPD_PE_Request_CtrlMessage+0xf0>
 80032b8:	2f0a      	cmp	r7, #10
 80032ba:	d052      	beq.n	8003362 <USBPD_PE_Request_CtrlMessage+0x102>
 80032bc:	2f0b      	cmp	r7, #11
 80032be:	d063      	beq.n	8003388 <USBPD_PE_Request_CtrlMessage+0x128>
 80032c0:	2f0d      	cmp	r7, #13
 80032c2:	d06c      	beq.n	800339e <USBPD_PE_Request_CtrlMessage+0x13e>
 80032c4:	2f11      	cmp	r7, #17
 80032c6:	d071      	beq.n	80033ac <USBPD_PE_Request_CtrlMessage+0x14c>
 80032c8:	2f12      	cmp	r7, #18
 80032ca:	d100      	bne.n	80032ce <USBPD_PE_Request_CtrlMessage+0x6e>
 80032cc:	e082      	b.n	80033d4 <USBPD_PE_Request_CtrlMessage+0x174>
 80032ce:	2f13      	cmp	r7, #19
 80032d0:	d100      	bne.n	80032d4 <USBPD_PE_Request_CtrlMessage+0x74>
 80032d2:	e090      	b.n	80033f6 <USBPD_PE_Request_CtrlMessage+0x196>
 80032d4:	2f14      	cmp	r7, #20
 80032d6:	d100      	bne.n	80032da <USBPD_PE_Request_CtrlMessage+0x7a>
 80032d8:	e0a3      	b.n	8003422 <USBPD_PE_Request_CtrlMessage+0x1c2>
 80032da:	2f15      	cmp	r7, #21
 80032dc:	d100      	bne.n	80032e0 <USBPD_PE_Request_CtrlMessage+0x80>
 80032de:	e0b8      	b.n	8003452 <USBPD_PE_Request_CtrlMessage+0x1f2>
 80032e0:	e0d0      	b.n	8003484 <USBPD_PE_Request_CtrlMessage+0x224>
 80032e2:	781a      	ldrb	r2, [r3, #0]
 80032e4:	0892      	lsrs	r2, r2, #2
 80032e6:	422a      	tst	r2, r5
 80032e8:	d00a      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80032ea:	804c      	strh	r4, [r1, #2]
 80032ec:	2400      	movs	r4, #0
 80032ee:	7044      	strb	r4, [r0, #1]
 80032f0:	2196      	movs	r1, #150	; 0x96
 80032f2:	7001      	strb	r1, [r0, #0]
 80032f4:	4668      	mov	r0, sp
 80032f6:	7a00      	ldrb	r0, [r0, #8]
 80032f8:	9900      	ldr	r1, [sp, #0]
 80032fa:	6889      	ldr	r1, [r1, #8]
 80032fc:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80032fe:	4788      	blx	r1
 8003300:	0020      	movs	r0, r4
 8003302:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8003304:	7859      	ldrb	r1, [r3, #1]
 8003306:	0649      	lsls	r1, r1, #25
 8003308:	0f49      	lsrs	r1, r1, #29
 800330a:	2903      	cmp	r1, #3
 800330c:	d1f8      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 800330e:	9900      	ldr	r1, [sp, #0]
 8003310:	6809      	ldr	r1, [r1, #0]
 8003312:	6849      	ldr	r1, [r1, #4]
 8003314:	08c9      	lsrs	r1, r1, #3
 8003316:	4029      	ands	r1, r5
 8003318:	d103      	bne.n	8003322 <USBPD_PE_Request_CtrlMessage+0xc2>
 800331a:	7819      	ldrb	r1, [r3, #0]
 800331c:	0889      	lsrs	r1, r1, #2
 800331e:	4229      	tst	r1, r5
 8003320:	d1ee      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003322:	2400      	movs	r4, #0
 8003324:	7044      	strb	r4, [r0, #1]
 8003326:	211a      	movs	r1, #26
 8003328:	e7e3      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 800332a:	7859      	ldrb	r1, [r3, #1]
 800332c:	0649      	lsls	r1, r1, #25
 800332e:	0f49      	lsrs	r1, r1, #29
 8003330:	2903      	cmp	r1, #3
 8003332:	d1e5      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003334:	9900      	ldr	r1, [sp, #0]
 8003336:	6809      	ldr	r1, [r1, #0]
 8003338:	6849      	ldr	r1, [r1, #4]
 800333a:	08c9      	lsrs	r1, r1, #3
 800333c:	4029      	ands	r1, r5
 800333e:	d103      	bne.n	8003348 <USBPD_PE_Request_CtrlMessage+0xe8>
 8003340:	7819      	ldrb	r1, [r3, #0]
 8003342:	0889      	lsrs	r1, r1, #2
 8003344:	4229      	tst	r1, r5
 8003346:	d0db      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003348:	2400      	movs	r4, #0
 800334a:	7044      	strb	r4, [r0, #1]
 800334c:	2118      	movs	r1, #24
 800334e:	e7d0      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003350:	7859      	ldrb	r1, [r3, #1]
 8003352:	0649      	lsls	r1, r1, #25
 8003354:	0f49      	lsrs	r1, r1, #29
 8003356:	2903      	cmp	r1, #3
 8003358:	d1d2      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 800335a:	2400      	movs	r4, #0
 800335c:	7044      	strb	r4, [r0, #1]
 800335e:	2194      	movs	r1, #148	; 0x94
 8003360:	e7c7      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003362:	785a      	ldrb	r2, [r3, #1]
 8003364:	0652      	lsls	r2, r2, #25
 8003366:	0f52      	lsrs	r2, r2, #29
 8003368:	2a03      	cmp	r2, #3
 800336a:	d1c9      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 800336c:	9a00      	ldr	r2, [sp, #0]
 800336e:	6812      	ldr	r2, [r2, #0]
 8003370:	6852      	ldr	r2, [r2, #4]
 8003372:	08d2      	lsrs	r2, r2, #3
 8003374:	4015      	ands	r5, r2
 8003376:	d0c3      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003378:	220a      	movs	r2, #10
 800337a:	700a      	strb	r2, [r1, #0]
 800337c:	2208      	movs	r2, #8
 800337e:	804a      	strh	r2, [r1, #2]
 8003380:	2400      	movs	r4, #0
 8003382:	7044      	strb	r4, [r0, #1]
 8003384:	211e      	movs	r1, #30
 8003386:	e7b4      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003388:	9a00      	ldr	r2, [sp, #0]
 800338a:	6892      	ldr	r2, [r2, #8]
 800338c:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800338e:	2a00      	cmp	r2, #0
 8003390:	d0b6      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003392:	2210      	movs	r2, #16
 8003394:	804a      	strh	r2, [r1, #2]
 8003396:	2400      	movs	r4, #0
 8003398:	7044      	strb	r4, [r0, #1]
 800339a:	21a2      	movs	r1, #162	; 0xa2
 800339c:	e7a9      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 800339e:	4669      	mov	r1, sp
 80033a0:	7909      	ldrb	r1, [r1, #4]
 80033a2:	7041      	strb	r1, [r0, #1]
 80033a4:	2111      	movs	r1, #17
 80033a6:	7001      	strb	r1, [r0, #0]
 80033a8:	2400      	movs	r4, #0
 80033aa:	e7a3      	b.n	80032f4 <USBPD_PE_Request_CtrlMessage+0x94>
 80033ac:	785f      	ldrb	r7, [r3, #1]
 80033ae:	067f      	lsls	r7, r7, #25
 80033b0:	0f7f      	lsrs	r7, r7, #29
 80033b2:	2f03      	cmp	r7, #3
 80033b4:	d1a4      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033b6:	781b      	ldrb	r3, [r3, #0]
 80033b8:	401e      	ands	r6, r3
 80033ba:	2e01      	cmp	r6, #1
 80033bc:	dda0      	ble.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033be:	089b      	lsrs	r3, r3, #2
 80033c0:	422b      	tst	r3, r5
 80033c2:	d19d      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033c4:	2311      	movs	r3, #17
 80033c6:	700b      	strb	r3, [r1, #0]
 80033c8:	230a      	movs	r3, #10
 80033ca:	804b      	strh	r3, [r1, #2]
 80033cc:	2400      	movs	r4, #0
 80033ce:	7044      	strb	r4, [r0, #1]
 80033d0:	7002      	strb	r2, [r0, #0]
 80033d2:	e78f      	b.n	80032f4 <USBPD_PE_Request_CtrlMessage+0x94>
 80033d4:	785d      	ldrb	r5, [r3, #1]
 80033d6:	066d      	lsls	r5, r5, #25
 80033d8:	0f6d      	lsrs	r5, r5, #29
 80033da:	2d03      	cmp	r5, #3
 80033dc:	d190      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033de:	781b      	ldrb	r3, [r3, #0]
 80033e0:	401e      	ands	r6, r3
 80033e2:	2e01      	cmp	r6, #1
 80033e4:	dd8c      	ble.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033e6:	7002      	strb	r2, [r0, #0]
 80033e8:	2212      	movs	r2, #18
 80033ea:	700a      	strb	r2, [r1, #0]
 80033ec:	220b      	movs	r2, #11
 80033ee:	804a      	strh	r2, [r1, #2]
 80033f0:	2400      	movs	r4, #0
 80033f2:	7044      	strb	r4, [r0, #1]
 80033f4:	e77e      	b.n	80032f4 <USBPD_PE_Request_CtrlMessage+0x94>
 80033f6:	785a      	ldrb	r2, [r3, #1]
 80033f8:	0652      	lsls	r2, r2, #25
 80033fa:	0f52      	lsrs	r2, r2, #29
 80033fc:	2a03      	cmp	r2, #3
 80033fe:	d1ed      	bne.n	80033dc <USBPD_PE_Request_CtrlMessage+0x17c>
 8003400:	781a      	ldrb	r2, [r3, #0]
 8003402:	4016      	ands	r6, r2
 8003404:	2e01      	cmp	r6, #1
 8003406:	dded      	ble.n	80033e4 <USBPD_PE_Request_CtrlMessage+0x184>
 8003408:	0892      	lsrs	r2, r2, #2
 800340a:	422a      	tst	r2, r5
 800340c:	d1e6      	bne.n	80033dc <USBPD_PE_Request_CtrlMessage+0x17c>
 800340e:	9a00      	ldr	r2, [sp, #0]
 8003410:	6812      	ldr	r2, [r2, #0]
 8003412:	88d2      	ldrh	r2, [r2, #6]
 8003414:	0852      	lsrs	r2, r2, #1
 8003416:	422a      	tst	r2, r5
 8003418:	d0e4      	beq.n	80033e4 <USBPD_PE_Request_CtrlMessage+0x184>
 800341a:	2213      	movs	r2, #19
 800341c:	700a      	strb	r2, [r1, #0]
 800341e:	2209      	movs	r2, #9
 8003420:	e7ad      	b.n	800337e <USBPD_PE_Request_CtrlMessage+0x11e>
 8003422:	785a      	ldrb	r2, [r3, #1]
 8003424:	0652      	lsls	r2, r2, #25
 8003426:	0f52      	lsrs	r2, r2, #29
 8003428:	2a03      	cmp	r2, #3
 800342a:	d1d7      	bne.n	80033dc <USBPD_PE_Request_CtrlMessage+0x17c>
 800342c:	781a      	ldrb	r2, [r3, #0]
 800342e:	4016      	ands	r6, r2
 8003430:	2e01      	cmp	r6, #1
 8003432:	ddd7      	ble.n	80033e4 <USBPD_PE_Request_CtrlMessage+0x184>
 8003434:	0892      	lsrs	r2, r2, #2
 8003436:	422a      	tst	r2, r5
 8003438:	d125      	bne.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 800343a:	9a00      	ldr	r2, [sp, #0]
 800343c:	6812      	ldr	r2, [r2, #0]
 800343e:	88d2      	ldrh	r2, [r2, #6]
 8003440:	0892      	lsrs	r2, r2, #2
 8003442:	422a      	tst	r2, r5
 8003444:	d01f      	beq.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 8003446:	220b      	movs	r2, #11
 8003448:	804a      	strh	r2, [r1, #2]
 800344a:	2400      	movs	r4, #0
 800344c:	7044      	strb	r4, [r0, #1]
 800344e:	2165      	movs	r1, #101	; 0x65
 8003450:	e74f      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003452:	785f      	ldrb	r7, [r3, #1]
 8003454:	067f      	lsls	r7, r7, #25
 8003456:	0f7f      	lsrs	r7, r7, #29
 8003458:	2f03      	cmp	r7, #3
 800345a:	d114      	bne.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 800345c:	781b      	ldrb	r3, [r3, #0]
 800345e:	401e      	ands	r6, r3
 8003460:	2e01      	cmp	r6, #1
 8003462:	dd10      	ble.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 8003464:	9b00      	ldr	r3, [sp, #0]
 8003466:	681b      	ldr	r3, [r3, #0]
 8003468:	88db      	ldrh	r3, [r3, #6]
 800346a:	0a1b      	lsrs	r3, r3, #8
 800346c:	422b      	tst	r3, r5
 800346e:	d00a      	beq.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 8003470:	466b      	mov	r3, sp
 8003472:	791b      	ldrb	r3, [r3, #4]
 8003474:	7043      	strb	r3, [r0, #1]
 8003476:	23ff      	movs	r3, #255	; 0xff
 8003478:	330e      	adds	r3, #14
 800347a:	804b      	strh	r3, [r1, #2]
 800347c:	2315      	movs	r3, #21
 800347e:	700b      	strb	r3, [r1, #0]
 8003480:	7002      	strb	r2, [r0, #0]
 8003482:	e791      	b.n	80033a8 <USBPD_PE_Request_CtrlMessage+0x148>
 8003484:	2410      	movs	r4, #16
 8003486:	e73b      	b.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>

08003488 <USBPD_PE_Request_DataMessage>:
 8003488:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 800348a:	b084      	sub	sp, #16
 800348c:	482f      	ldr	r0, [pc, #188]	; (800354c <.text_29>)
 800348e:	466b      	mov	r3, sp
 8003490:	7c1b      	ldrb	r3, [r3, #16]
 8003492:	009b      	lsls	r3, r3, #2
 8003494:	58c0      	ldr	r0, [r0, r3]
 8003496:	9001      	str	r0, [sp, #4]
 8003498:	2402      	movs	r4, #2
 800349a:	23d5      	movs	r3, #213	; 0xd5
 800349c:	009b      	lsls	r3, r3, #2
 800349e:	18c0      	adds	r0, r0, r3
 80034a0:	7803      	ldrb	r3, [r0, #0]
 80034a2:	2b00      	cmp	r3, #0
 80034a4:	d106      	bne.n	80034b4 <USBPD_PE_Request_DataMessage+0x2c>
 80034a6:	9b01      	ldr	r3, [sp, #4]
 80034a8:	685b      	ldr	r3, [r3, #4]
 80034aa:	2501      	movs	r5, #1
 80034ac:	681e      	ldr	r6, [r3, #0]
 80034ae:	0af6      	lsrs	r6, r6, #11
 80034b0:	402e      	ands	r6, r5
 80034b2:	d101      	bne.n	80034b8 <USBPD_PE_Request_DataMessage+0x30>
 80034b4:	2003      	movs	r0, #3
 80034b6:	e022      	b.n	80034fe <USBPD_PE_Request_DataMessage+0x76>
 80034b8:	9203      	str	r2, [sp, #12]
 80034ba:	466a      	mov	r2, sp
 80034bc:	7011      	strb	r1, [r2, #0]
 80034be:	9901      	ldr	r1, [sp, #4]
 80034c0:	4a9c      	ldr	r2, [pc, #624]	; (8003734 <.text_33>)
 80034c2:	1889      	adds	r1, r1, r2
 80034c4:	9102      	str	r1, [sp, #8]
 80034c6:	2103      	movs	r1, #3
 80034c8:	2207      	movs	r2, #7
 80034ca:	2600      	movs	r6, #0
 80034cc:	466f      	mov	r7, sp
 80034ce:	783f      	ldrb	r7, [r7, #0]
 80034d0:	2f01      	cmp	r7, #1
 80034d2:	d004      	beq.n	80034de <USBPD_PE_Request_DataMessage+0x56>
 80034d4:	2f06      	cmp	r7, #6
 80034d6:	d014      	beq.n	8003502 <USBPD_PE_Request_DataMessage+0x7a>
 80034d8:	2f07      	cmp	r7, #7
 80034da:	d022      	beq.n	8003522 <USBPD_PE_Request_DataMessage+0x9a>
 80034dc:	e034      	b.n	8003548 <USBPD_PE_Request_DataMessage+0xc0>
 80034de:	7819      	ldrb	r1, [r3, #0]
 80034e0:	0889      	lsrs	r1, r1, #2
 80034e2:	4229      	tst	r1, r5
 80034e4:	d00a      	beq.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 80034e6:	9902      	ldr	r1, [sp, #8]
 80034e8:	800d      	strh	r5, [r1, #0]
 80034ea:	7046      	strb	r6, [r0, #1]
 80034ec:	7002      	strb	r2, [r0, #0]
 80034ee:	2400      	movs	r4, #0
 80034f0:	4668      	mov	r0, sp
 80034f2:	7c00      	ldrb	r0, [r0, #16]
 80034f4:	9901      	ldr	r1, [sp, #4]
 80034f6:	6889      	ldr	r1, [r1, #8]
 80034f8:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80034fa:	4788      	blx	r1
 80034fc:	0020      	movs	r0, r4
 80034fe:	b005      	add	sp, #20
 8003500:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003502:	785d      	ldrb	r5, [r3, #1]
 8003504:	092d      	lsrs	r5, r5, #4
 8003506:	402a      	ands	r2, r5
 8003508:	2a03      	cmp	r2, #3
 800350a:	d1f7      	bne.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 800350c:	781a      	ldrb	r2, [r3, #0]
 800350e:	4011      	ands	r1, r2
 8003510:	2901      	cmp	r1, #1
 8003512:	ddf3      	ble.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 8003514:	7046      	strb	r6, [r0, #1]
 8003516:	9903      	ldr	r1, [sp, #12]
 8003518:	6809      	ldr	r1, [r1, #0]
 800351a:	6381      	str	r1, [r0, #56]	; 0x38
 800351c:	212b      	movs	r1, #43	; 0x2b
 800351e:	7001      	strb	r1, [r0, #0]
 8003520:	e7e5      	b.n	80034ee <USBPD_PE_Request_DataMessage+0x66>
 8003522:	785d      	ldrb	r5, [r3, #1]
 8003524:	092d      	lsrs	r5, r5, #4
 8003526:	402a      	ands	r2, r5
 8003528:	2a03      	cmp	r2, #3
 800352a:	d1e7      	bne.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 800352c:	781a      	ldrb	r2, [r3, #0]
 800352e:	4011      	ands	r1, r2
 8003530:	2901      	cmp	r1, #1
 8003532:	dde3      	ble.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 8003534:	9903      	ldr	r1, [sp, #12]
 8003536:	6809      	ldr	r1, [r1, #0]
 8003538:	6381      	str	r1, [r0, #56]	; 0x38
 800353a:	21ff      	movs	r1, #255	; 0xff
 800353c:	310e      	adds	r1, #14
 800353e:	9a02      	ldr	r2, [sp, #8]
 8003540:	8011      	strh	r1, [r2, #0]
 8003542:	7046      	strb	r6, [r0, #1]
 8003544:	2162      	movs	r1, #98	; 0x62
 8003546:	e7ea      	b.n	800351e <USBPD_PE_Request_DataMessage+0x96>
 8003548:	2410      	movs	r4, #16
 800354a:	e7d7      	b.n	80034fc <USBPD_PE_Request_DataMessage+0x74>

0800354c <.text_29>:
 800354c:	200019ac 	.word	0x200019ac

08003550 <USBPD_PE_Send_Request>:
 8003550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003552:	4b79      	ldr	r3, [pc, #484]	; (8003738 <.text_34>)
 8003554:	0084      	lsls	r4, r0, #2
 8003556:	591b      	ldr	r3, [r3, r4]
 8003558:	24d5      	movs	r4, #213	; 0xd5
 800355a:	00a4      	lsls	r4, r4, #2
 800355c:	191c      	adds	r4, r3, r4
 800355e:	7825      	ldrb	r5, [r4, #0]
 8003560:	2d00      	cmp	r5, #0
 8003562:	d105      	bne.n	8003570 <USBPD_PE_Send_Request+0x20>
 8003564:	685d      	ldr	r5, [r3, #4]
 8003566:	2601      	movs	r6, #1
 8003568:	682f      	ldr	r7, [r5, #0]
 800356a:	0aff      	lsrs	r7, r7, #11
 800356c:	4037      	ands	r7, r6
 800356e:	d101      	bne.n	8003574 <USBPD_PE_Send_Request+0x24>
 8003570:	2003      	movs	r0, #3
 8003572:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 8003574:	786f      	ldrb	r7, [r5, #1]
 8003576:	067f      	lsls	r7, r7, #25
 8003578:	0f7f      	lsrs	r7, r7, #29
 800357a:	2f03      	cmp	r7, #3
 800357c:	d115      	bne.n	80035aa <USBPD_PE_Send_Request+0x5a>
 800357e:	782d      	ldrb	r5, [r5, #0]
 8003580:	08ad      	lsrs	r5, r5, #2
 8003582:	4235      	tst	r5, r6
 8003584:	d111      	bne.n	80035aa <USBPD_PE_Send_Request+0x5a>
 8003586:	2545      	movs	r5, #69	; 0x45
 8003588:	7025      	strb	r5, [r4, #0]
 800358a:	6119      	str	r1, [r3, #16]
 800358c:	7b19      	ldrb	r1, [r3, #12]
 800358e:	25f3      	movs	r5, #243	; 0xf3
 8003590:	400d      	ands	r5, r1
 8003592:	0091      	lsls	r1, r2, #2
 8003594:	220c      	movs	r2, #12
 8003596:	400a      	ands	r2, r1
 8003598:	432a      	orrs	r2, r5
 800359a:	731a      	strb	r2, [r3, #12]
 800359c:	2100      	movs	r1, #0
 800359e:	7061      	strb	r1, [r4, #1]
 80035a0:	6899      	ldr	r1, [r3, #8]
 80035a2:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80035a4:	4788      	blx	r1
 80035a6:	2000      	movs	r0, #0
 80035a8:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 80035aa:	2002      	movs	r0, #2
 80035ac:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

080035ae <USBPD_PE_SendExtendedMessage>:
 80035ae:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
 80035b0:	b083      	sub	sp, #12
 80035b2:	2600      	movs	r6, #0
 80035b4:	9601      	str	r6, [sp, #4]
 80035b6:	4860      	ldr	r0, [pc, #384]	; (8003738 <.text_34>)
 80035b8:	4669      	mov	r1, sp
 80035ba:	7b09      	ldrb	r1, [r1, #12]
 80035bc:	0089      	lsls	r1, r1, #2
 80035be:	5844      	ldr	r4, [r0, r1]
 80035c0:	20d3      	movs	r0, #211	; 0xd3
 80035c2:	0080      	lsls	r0, r0, #2
 80035c4:	1825      	adds	r5, r4, r0
 80035c6:	7a28      	ldrb	r0, [r5, #8]
 80035c8:	2800      	cmp	r0, #0
 80035ca:	d104      	bne.n	80035d6 <USBPD_PE_SendExtendedMessage+0x28>
 80035cc:	6860      	ldr	r0, [r4, #4]
 80035ce:	6801      	ldr	r1, [r0, #0]
 80035d0:	050f      	lsls	r7, r1, #20
 80035d2:	0fff      	lsrs	r7, r7, #31
 80035d4:	d101      	bne.n	80035da <USBPD_PE_SendExtendedMessage+0x2c>
 80035d6:	2003      	movs	r0, #3
 80035d8:	e06f      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 80035da:	7841      	ldrb	r1, [r0, #1]
 80035dc:	0649      	lsls	r1, r1, #25
 80035de:	0f49      	lsrs	r1, r1, #29
 80035e0:	2903      	cmp	r1, #3
 80035e2:	d10c      	bne.n	80035fe <USBPD_PE_SendExtendedMessage+0x50>
 80035e4:	7800      	ldrb	r0, [r0, #0]
 80035e6:	0780      	lsls	r0, r0, #30
 80035e8:	0f80      	lsrs	r0, r0, #30
 80035ea:	2801      	cmp	r0, #1
 80035ec:	dc01      	bgt.n	80035f2 <USBPD_PE_SendExtendedMessage+0x44>
 80035ee:	2001      	movs	r0, #1
 80035f0:	e063      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 80035f2:	4668      	mov	r0, sp
 80035f4:	8d00      	ldrh	r0, [r0, #40]	; 0x28
 80035f6:	21ff      	movs	r1, #255	; 0xff
 80035f8:	1d89      	adds	r1, r1, #6
 80035fa:	4288      	cmp	r0, r1
 80035fc:	d301      	bcc.n	8003602 <USBPD_PE_SendExtendedMessage+0x54>
 80035fe:	2002      	movs	r0, #2
 8003600:	e05b      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 8003602:	4668      	mov	r0, sp
 8003604:	7002      	strb	r2, [r0, #0]
 8003606:	68e0      	ldr	r0, [r4, #12]
 8003608:	2110      	movs	r1, #16
 800360a:	4388      	bics	r0, r1
 800360c:	60e0      	str	r0, [r4, #12]
 800360e:	4949      	ldr	r1, [pc, #292]	; (8003734 <.text_33>)
 8003610:	1861      	adds	r1, r4, r1
 8003612:	2210      	movs	r2, #16
 8003614:	466f      	mov	r7, sp
 8003616:	783f      	ldrb	r7, [r7, #0]
 8003618:	2f83      	cmp	r7, #131	; 0x83
 800361a:	d00c      	beq.n	8003636 <USBPD_PE_SendExtendedMessage+0x88>
 800361c:	2f84      	cmp	r7, #132	; 0x84
 800361e:	d021      	beq.n	8003664 <USBPD_PE_SendExtendedMessage+0xb6>
 8003620:	2f86      	cmp	r7, #134	; 0x86
 8003622:	d021      	beq.n	8003668 <USBPD_PE_SendExtendedMessage+0xba>
 8003624:	2f88      	cmp	r7, #136	; 0x88
 8003626:	d021      	beq.n	800366c <USBPD_PE_SendExtendedMessage+0xbe>
 8003628:	2f89      	cmp	r7, #137	; 0x89
 800362a:	d009      	beq.n	8003640 <USBPD_PE_SendExtendedMessage+0x92>
 800362c:	2f8a      	cmp	r7, #138	; 0x8a
 800362e:	d023      	beq.n	8003678 <USBPD_PE_SendExtendedMessage+0xca>
 8003630:	2f8b      	cmp	r7, #139	; 0x8b
 8003632:	d005      	beq.n	8003640 <USBPD_PE_SendExtendedMessage+0x92>
 8003634:	e025      	b.n	8003682 <USBPD_PE_SendExtendedMessage+0xd4>
 8003636:	200c      	movs	r0, #12
 8003638:	8008      	strh	r0, [r1, #0]
 800363a:	68e0      	ldr	r0, [r4, #12]
 800363c:	4302      	orrs	r2, r0
 800363e:	60e2      	str	r2, [r4, #12]
 8003640:	4668      	mov	r0, sp
 8003642:	8d00      	ldrh	r0, [r0, #40]	; 0x28
 8003644:	2800      	cmp	r0, #0
 8003646:	d028      	beq.n	800369a <USBPD_PE_SendExtendedMessage+0xec>
 8003648:	001f      	movs	r7, r3
 800364a:	4668      	mov	r0, sp
 800364c:	7b00      	ldrb	r0, [r0, #12]
 800364e:	f000 ff29 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8003652:	2801      	cmp	r0, #1
 8003654:	d100      	bne.n	8003658 <USBPD_PE_SendExtendedMessage+0xaa>
 8003656:	2604      	movs	r6, #4
 8003658:	9702      	str	r7, [sp, #8]
 800365a:	9801      	ldr	r0, [sp, #4]
 800365c:	4669      	mov	r1, sp
 800365e:	8d09      	ldrh	r1, [r1, #40]	; 0x28
 8003660:	4fc3      	ldr	r7, [pc, #780]	; (8003970 <.text_40>)
 8003662:	e016      	b.n	8003692 <USBPD_PE_SendExtendedMessage+0xe4>
 8003664:	200d      	movs	r0, #13
 8003666:	e7e7      	b.n	8003638 <USBPD_PE_SendExtendedMessage+0x8a>
 8003668:	200e      	movs	r0, #14
 800366a:	e7e5      	b.n	8003638 <USBPD_PE_SendExtendedMessage+0x8a>
 800366c:	4302      	orrs	r2, r0
 800366e:	60e2      	str	r2, [r4, #12]
 8003670:	20ff      	movs	r0, #255	; 0xff
 8003672:	300c      	adds	r0, #12
 8003674:	8008      	strh	r0, [r1, #0]
 8003676:	e7e3      	b.n	8003640 <USBPD_PE_SendExtendedMessage+0x92>
 8003678:	4302      	orrs	r2, r0
 800367a:	60e2      	str	r2, [r4, #12]
 800367c:	2086      	movs	r0, #134	; 0x86
 800367e:	0040      	lsls	r0, r0, #1
 8003680:	e7f8      	b.n	8003674 <USBPD_PE_SendExtendedMessage+0xc6>
 8003682:	2010      	movs	r0, #16
 8003684:	e019      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 8003686:	9a02      	ldr	r2, [sp, #8]
 8003688:	5c12      	ldrb	r2, [r2, r0]
 800368a:	1983      	adds	r3, r0, r6
 800368c:	18e3      	adds	r3, r4, r3
 800368e:	55da      	strb	r2, [r3, r7]
 8003690:	1c40      	adds	r0, r0, #1
 8003692:	4288      	cmp	r0, r1
 8003694:	d3f7      	bcc.n	8003686 <USBPD_PE_SendExtendedMessage+0xd8>
 8003696:	8029      	strh	r1, [r5, #0]
 8003698:	e000      	b.n	800369c <USBPD_PE_SendExtendedMessage+0xee>
 800369a:	802e      	strh	r6, [r5, #0]
 800369c:	4668      	mov	r0, sp
 800369e:	7c00      	ldrb	r0, [r0, #16]
 80036a0:	7268      	strb	r0, [r5, #9]
 80036a2:	4668      	mov	r0, sp
 80036a4:	7800      	ldrb	r0, [r0, #0]
 80036a6:	49bc      	ldr	r1, [pc, #752]	; (8003998 <.text_43>)
 80036a8:	5460      	strb	r0, [r4, r1]
 80036aa:	2031      	movs	r0, #49	; 0x31
 80036ac:	7228      	strb	r0, [r5, #8]
 80036ae:	4668      	mov	r0, sp
 80036b0:	7b00      	ldrb	r0, [r0, #12]
 80036b2:	68a1      	ldr	r1, [r4, #8]
 80036b4:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80036b6:	4788      	blx	r1
 80036b8:	2000      	movs	r0, #0
 80036ba:	b005      	add	sp, #20
 80036bc:	bdf0      	pop	{r4, r5, r6, r7, pc}

080036be <PE_Send_SRCCapabilities>:
 80036be:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80036c0:	b084      	sub	sp, #16
 80036c2:	0005      	movs	r5, r0
 80036c4:	000f      	movs	r7, r1
 80036c6:	20e2      	movs	r0, #226	; 0xe2
 80036c8:	0080      	lsls	r0, r0, #2
 80036ca:	582e      	ldr	r6, [r5, r0]
 80036cc:	211e      	movs	r1, #30
 80036ce:	0028      	movs	r0, r5
 80036d0:	3018      	adds	r0, #24
 80036d2:	f009 f9b1 	bl	800ca38 <__aeabi_memclr>
 80036d6:	ab02      	add	r3, sp, #8
 80036d8:	002a      	movs	r2, r5
 80036da:	321a      	adds	r2, #26
 80036dc:	2100      	movs	r1, #0
 80036de:	7b2c      	ldrb	r4, [r5, #12]
 80036e0:	07e0      	lsls	r0, r4, #31
 80036e2:	0fc0      	lsrs	r0, r0, #31
 80036e4:	68ac      	ldr	r4, [r5, #8]
 80036e6:	69a4      	ldr	r4, [r4, #24]
 80036e8:	47a0      	blx	r4
 80036ea:	9802      	ldr	r0, [sp, #8]
 80036ec:	1c80      	adds	r0, r0, #2
 80036ee:	b2c0      	uxtb	r0, r0
 80036f0:	4669      	mov	r1, sp
 80036f2:	8188      	strh	r0, [r1, #12]
 80036f4:	2401      	movs	r4, #1
 80036f6:	9701      	str	r7, [sp, #4]
 80036f8:	4668      	mov	r0, sp
 80036fa:	8980      	ldrh	r0, [r0, #12]
 80036fc:	9000      	str	r0, [sp, #0]
 80036fe:	002b      	movs	r3, r5
 8003700:	3318      	adds	r3, #24
 8003702:	2201      	movs	r2, #1
 8003704:	68e9      	ldr	r1, [r5, #12]
 8003706:	2001      	movs	r0, #1
 8003708:	4008      	ands	r0, r1
 800370a:	2100      	movs	r1, #0
 800370c:	f001 fc5a 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8003710:	2803      	cmp	r0, #3
 8003712:	d10c      	bne.n	800372e <PE_Send_SRCCapabilities+0x70>
 8003714:	20e2      	movs	r0, #226	; 0xe2
 8003716:	0080      	lsls	r0, r0, #2
 8003718:	5828      	ldr	r0, [r5, r0]
 800371a:	1b80      	subs	r0, r0, r6
 800371c:	49b9      	ldr	r1, [pc, #740]	; (8003a04 <.text_46>)
 800371e:	4288      	cmp	r0, r1
 8003720:	d204      	bcs.n	800372c <PE_Send_SRCCapabilities+0x6e>
 8003722:	6868      	ldr	r0, [r5, #4]
 8003724:	6800      	ldr	r0, [r0, #0]
 8003726:	0ac0      	lsrs	r0, r0, #11
 8003728:	4004      	ands	r4, r0
 800372a:	d1e3      	bne.n	80036f4 <PE_Send_SRCCapabilities+0x36>
 800372c:	2010      	movs	r0, #16
 800372e:	b005      	add	sp, #20
 8003730:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08003734 <.text_33>:
 8003734:	00000396 	.word	0x00000396

08003738 <.text_34>:
 8003738:	200019ac 	.word	0x200019ac

0800373c <PE_Send_SNKCapabilities>:
 800373c:	b578      	push	{r3, r4, r5, r6, lr}
 800373e:	b08b      	sub	sp, #44	; 0x2c
 8003740:	0004      	movs	r4, r0
 8003742:	000d      	movs	r5, r1
 8003744:	ab03      	add	r3, sp, #12
 8003746:	aa04      	add	r2, sp, #16
 8003748:	2101      	movs	r1, #1
 800374a:	7b26      	ldrb	r6, [r4, #12]
 800374c:	07f0      	lsls	r0, r6, #31
 800374e:	0fc0      	lsrs	r0, r0, #31
 8003750:	68a6      	ldr	r6, [r4, #8]
 8003752:	69b6      	ldr	r6, [r6, #24]
 8003754:	47b0      	blx	r6
 8003756:	2000      	movs	r0, #0
 8003758:	9002      	str	r0, [sp, #8]
 800375a:	9501      	str	r5, [sp, #4]
 800375c:	9803      	ldr	r0, [sp, #12]
 800375e:	0880      	lsrs	r0, r0, #2
 8003760:	9000      	str	r0, [sp, #0]
 8003762:	ab04      	add	r3, sp, #16
 8003764:	2204      	movs	r2, #4
 8003766:	2100      	movs	r1, #0
 8003768:	0020      	movs	r0, r4
 800376a:	f000 f849 	bl	8003800 <PE_Send_DataMessage>
 800376e:	b00c      	add	sp, #48	; 0x30
 8003770:	bd70      	pop	{r4, r5, r6, pc}

08003772 <PE_Send_CtrlMessage>:
 8003772:	b5fc      	push	{r2, r3, r4, r5, r6, r7, lr}
 8003774:	b083      	sub	sp, #12
 8003776:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8003778:	0005      	movs	r5, r0
 800377a:	4668      	mov	r0, sp
 800377c:	7201      	strb	r1, [r0, #8]
 800377e:	0016      	movs	r6, r2
 8003780:	2401      	movs	r4, #1
 8003782:	9701      	str	r7, [sp, #4]
 8003784:	2002      	movs	r0, #2
 8003786:	9000      	str	r0, [sp, #0]
 8003788:	002b      	movs	r3, r5
 800378a:	3318      	adds	r3, #24
 800378c:	0032      	movs	r2, r6
 800378e:	4668      	mov	r0, sp
 8003790:	7a01      	ldrb	r1, [r0, #8]
 8003792:	468c      	mov	ip, r1
 8003794:	68e9      	ldr	r1, [r5, #12]
 8003796:	2001      	movs	r0, #1
 8003798:	4008      	ands	r0, r1
 800379a:	4661      	mov	r1, ip
 800379c:	f001 fc12 	bl	8004fc4 <USBPD_PRL_SendMessage>
 80037a0:	2803      	cmp	r0, #3
 80037a2:	d11a      	bne.n	80037da <PE_Send_CtrlMessage+0x68>
 80037a4:	6868      	ldr	r0, [r5, #4]
 80037a6:	6800      	ldr	r0, [r0, #0]
 80037a8:	0ac0      	lsrs	r0, r0, #11
 80037aa:	4004      	ands	r4, r0
 80037ac:	d1e8      	bne.n	8003780 <PE_Send_CtrlMessage+0xe>
 80037ae:	2000      	movs	r0, #0
 80037b0:	21d5      	movs	r1, #213	; 0xd5
 80037b2:	0089      	lsls	r1, r1, #2
 80037b4:	1869      	adds	r1, r5, r1
 80037b6:	e00c      	b.n	80037d2 <PE_Send_CtrlMessage+0x60>
 80037b8:	700a      	strb	r2, [r1, #0]
 80037ba:	e00b      	b.n	80037d4 <PE_Send_CtrlMessage+0x62>
 80037bc:	6868      	ldr	r0, [r5, #4]
 80037be:	7840      	ldrb	r0, [r0, #1]
 80037c0:	0640      	lsls	r0, r0, #25
 80037c2:	0f40      	lsrs	r0, r0, #29
 80037c4:	2804      	cmp	r0, #4
 80037c6:	d001      	beq.n	80037cc <PE_Send_CtrlMessage+0x5a>
 80037c8:	2e0d      	cmp	r6, #13
 80037ca:	d101      	bne.n	80037d0 <PE_Send_CtrlMessage+0x5e>
 80037cc:	200f      	movs	r0, #15
 80037ce:	e000      	b.n	80037d2 <PE_Send_CtrlMessage+0x60>
 80037d0:	2011      	movs	r0, #17
 80037d2:	7108      	strb	r0, [r1, #4]
 80037d4:	2010      	movs	r0, #16
 80037d6:	b005      	add	sp, #20
 80037d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80037da:	21d5      	movs	r1, #213	; 0xd5
 80037dc:	0089      	lsls	r1, r1, #2
 80037de:	1869      	adds	r1, r5, r1
 80037e0:	2200      	movs	r2, #0
 80037e2:	2805      	cmp	r0, #5
 80037e4:	d006      	beq.n	80037f4 <PE_Send_CtrlMessage+0x82>
 80037e6:	2806      	cmp	r0, #6
 80037e8:	d0e6      	beq.n	80037b8 <PE_Send_CtrlMessage+0x46>
 80037ea:	2807      	cmp	r0, #7
 80037ec:	d0e6      	beq.n	80037bc <PE_Send_CtrlMessage+0x4a>
 80037ee:	2809      	cmp	r0, #9
 80037f0:	d0f1      	beq.n	80037d6 <PE_Send_CtrlMessage+0x64>
 80037f2:	e7ef      	b.n	80037d4 <PE_Send_CtrlMessage+0x62>
 80037f4:	4668      	mov	r0, sp
 80037f6:	7c00      	ldrb	r0, [r0, #16]
 80037f8:	7108      	strb	r0, [r1, #4]
 80037fa:	700a      	strb	r2, [r1, #0]
 80037fc:	2000      	movs	r0, #0
 80037fe:	e7ea      	b.n	80037d6 <PE_Send_CtrlMessage+0x64>

08003800 <PE_Send_DataMessage>:
 8003800:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8003802:	b082      	sub	sp, #8
 8003804:	0005      	movs	r5, r0
 8003806:	2000      	movs	r0, #0
 8003808:	e00c      	b.n	8003824 <PE_Send_DataMessage+0x24>
 800380a:	2600      	movs	r6, #0
 800380c:	0081      	lsls	r1, r0, #2
 800380e:	1869      	adds	r1, r5, r1
 8003810:	198a      	adds	r2, r1, r6
 8003812:	6819      	ldr	r1, [r3, #0]
 8003814:	00f7      	lsls	r7, r6, #3
 8003816:	40f9      	lsrs	r1, r7
 8003818:	7691      	strb	r1, [r2, #26]
 800381a:	1c76      	adds	r6, r6, #1
 800381c:	2e04      	cmp	r6, #4
 800381e:	dbf5      	blt.n	800380c <PE_Send_DataMessage+0xc>
 8003820:	1d1b      	adds	r3, r3, #4
 8003822:	1c40      	adds	r0, r0, #1
 8003824:	990a      	ldr	r1, [sp, #40]	; 0x28
 8003826:	4288      	cmp	r0, r1
 8003828:	d3ef      	bcc.n	800380a <PE_Send_DataMessage+0xa>
 800382a:	2401      	movs	r4, #1
 800382c:	a80c      	add	r0, sp, #48	; 0x30
 800382e:	7800      	ldrb	r0, [r0, #0]
 8003830:	9001      	str	r0, [sp, #4]
 8003832:	980a      	ldr	r0, [sp, #40]	; 0x28
 8003834:	0080      	lsls	r0, r0, #2
 8003836:	1c80      	adds	r0, r0, #2
 8003838:	b280      	uxth	r0, r0
 800383a:	9000      	str	r0, [sp, #0]
 800383c:	002b      	movs	r3, r5
 800383e:	3318      	adds	r3, #24
 8003840:	4668      	mov	r0, sp
 8003842:	7c02      	ldrb	r2, [r0, #16]
 8003844:	7b01      	ldrb	r1, [r0, #12]
 8003846:	68ee      	ldr	r6, [r5, #12]
 8003848:	2001      	movs	r0, #1
 800384a:	4030      	ands	r0, r6
 800384c:	f001 fbba 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8003850:	2803      	cmp	r0, #3
 8003852:	d117      	bne.n	8003884 <PE_Send_DataMessage+0x84>
 8003854:	6868      	ldr	r0, [r5, #4]
 8003856:	6800      	ldr	r0, [r0, #0]
 8003858:	0ac0      	lsrs	r0, r0, #11
 800385a:	4004      	ands	r4, r0
 800385c:	d1e5      	bne.n	800382a <PE_Send_DataMessage+0x2a>
 800385e:	2010      	movs	r0, #16
 8003860:	e00e      	b.n	8003880 <PE_Send_DataMessage+0x80>
 8003862:	2a00      	cmp	r2, #0
 8003864:	d001      	beq.n	800386a <PE_Send_DataMessage+0x6a>
 8003866:	2099      	movs	r0, #153	; 0x99
 8003868:	e008      	b.n	800387c <PE_Send_DataMessage+0x7c>
 800386a:	6868      	ldr	r0, [r5, #4]
 800386c:	7840      	ldrb	r0, [r0, #1]
 800386e:	0640      	lsls	r0, r0, #25
 8003870:	0f40      	lsrs	r0, r0, #29
 8003872:	2804      	cmp	r0, #4
 8003874:	d101      	bne.n	800387a <PE_Send_DataMessage+0x7a>
 8003876:	200f      	movs	r0, #15
 8003878:	e000      	b.n	800387c <PE_Send_DataMessage+0x7c>
 800387a:	2011      	movs	r0, #17
 800387c:	7008      	strb	r0, [r1, #0]
 800387e:	2000      	movs	r0, #0
 8003880:	b005      	add	sp, #20
 8003882:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003884:	4669      	mov	r1, sp
 8003886:	7b0a      	ldrb	r2, [r1, #12]
 8003888:	21d6      	movs	r1, #214	; 0xd6
 800388a:	0089      	lsls	r1, r1, #2
 800388c:	1869      	adds	r1, r5, r1
 800388e:	2805      	cmp	r0, #5
 8003890:	d004      	beq.n	800389c <PE_Send_DataMessage+0x9c>
 8003892:	2807      	cmp	r0, #7
 8003894:	d0e5      	beq.n	8003862 <PE_Send_DataMessage+0x62>
 8003896:	2809      	cmp	r0, #9
 8003898:	d0f2      	beq.n	8003880 <PE_Send_DataMessage+0x80>
 800389a:	e7f0      	b.n	800387e <PE_Send_DataMessage+0x7e>
 800389c:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800389e:	7008      	strb	r0, [r1, #0]
 80038a0:	4e59      	ldr	r6, [pc, #356]	; (8003a08 <.text_47>)
 80038a2:	7830      	ldrb	r0, [r6, #0]
 80038a4:	0780      	lsls	r0, r0, #30
 80038a6:	d509      	bpl.n	80038bc <PE_Send_DataMessage+0xbc>
 80038a8:	2000      	movs	r0, #0
 80038aa:	9000      	str	r0, [sp, #0]
 80038ac:	2300      	movs	r3, #0
 80038ae:	2242      	movs	r2, #66	; 0x42
 80038b0:	68e8      	ldr	r0, [r5, #12]
 80038b2:	2101      	movs	r1, #1
 80038b4:	4001      	ands	r1, r0
 80038b6:	2009      	movs	r0, #9
 80038b8:	68f6      	ldr	r6, [r6, #12]
 80038ba:	47b0      	blx	r6
 80038bc:	2142      	movs	r1, #66	; 0x42
 80038be:	68e8      	ldr	r0, [r5, #12]
 80038c0:	4004      	ands	r4, r0
 80038c2:	0020      	movs	r0, r4
 80038c4:	68aa      	ldr	r2, [r5, #8]
 80038c6:	68d2      	ldr	r2, [r2, #12]
 80038c8:	4790      	blx	r2
 80038ca:	e7d8      	b.n	800387e <PE_Send_DataMessage+0x7e>

080038cc <PE_Send_HARDRESET>:
 80038cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80038ce:	0004      	movs	r4, r0
 80038d0:	20e2      	movs	r0, #226	; 0xe2
 80038d2:	0080      	lsls	r0, r0, #2
 80038d4:	5825      	ldr	r5, [r4, r0]
 80038d6:	2601      	movs	r6, #1
 80038d8:	4f4b      	ldr	r7, [pc, #300]	; (8003a08 <.text_47>)
 80038da:	7838      	ldrb	r0, [r7, #0]
 80038dc:	0780      	lsls	r0, r0, #30
 80038de:	d509      	bpl.n	80038f4 <PE_Send_HARDRESET+0x28>
 80038e0:	2000      	movs	r0, #0
 80038e2:	9000      	str	r0, [sp, #0]
 80038e4:	2300      	movs	r3, #0
 80038e6:	221e      	movs	r2, #30
 80038e8:	68e0      	ldr	r0, [r4, #12]
 80038ea:	2101      	movs	r1, #1
 80038ec:	4001      	ands	r1, r0
 80038ee:	2009      	movs	r0, #9
 80038f0:	68ff      	ldr	r7, [r7, #12]
 80038f2:	47b8      	blx	r7
 80038f4:	211e      	movs	r1, #30
 80038f6:	68e2      	ldr	r2, [r4, #12]
 80038f8:	2001      	movs	r0, #1
 80038fa:	4010      	ands	r0, r2
 80038fc:	68a2      	ldr	r2, [r4, #8]
 80038fe:	68d2      	ldr	r2, [r2, #12]
 8003900:	4790      	blx	r2
 8003902:	68e1      	ldr	r1, [r4, #12]
 8003904:	2001      	movs	r0, #1
 8003906:	4008      	ands	r0, r1
 8003908:	f001 fd3f 	bl	800538a <USBPD_PRL_ResetRequestReset>
 800390c:	20e2      	movs	r0, #226	; 0xe2
 800390e:	0080      	lsls	r0, r0, #2
 8003910:	1820      	adds	r0, r4, r0
 8003912:	9000      	str	r0, [sp, #0]
 8003914:	4f3b      	ldr	r7, [pc, #236]	; (8003a04 <.text_46>)
 8003916:	2105      	movs	r1, #5
 8003918:	68e2      	ldr	r2, [r4, #12]
 800391a:	2001      	movs	r0, #1
 800391c:	4010      	ands	r0, r2
 800391e:	f001 fd3f 	bl	80053a0 <USBPD_PRL_ResetRequestProcess>
 8003922:	2803      	cmp	r0, #3
 8003924:	d10a      	bne.n	800393c <PE_Send_HARDRESET+0x70>
 8003926:	9800      	ldr	r0, [sp, #0]
 8003928:	6800      	ldr	r0, [r0, #0]
 800392a:	1b40      	subs	r0, r0, r5
 800392c:	42b8      	cmp	r0, r7
 800392e:	d204      	bcs.n	800393a <PE_Send_HARDRESET+0x6e>
 8003930:	6860      	ldr	r0, [r4, #4]
 8003932:	6800      	ldr	r0, [r0, #0]
 8003934:	0ac0      	lsrs	r0, r0, #11
 8003936:	4030      	ands	r0, r6
 8003938:	d1ed      	bne.n	8003916 <PE_Send_HARDRESET+0x4a>
 800393a:	2004      	movs	r0, #4
 800393c:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

0800393e <PE_PerformSoftReset>:
 800393e:	b538      	push	{r3, r4, r5, lr}
 8003940:	0004      	movs	r4, r0
 8003942:	2500      	movs	r5, #0
 8003944:	2001      	movs	r0, #1
 8003946:	6861      	ldr	r1, [r4, #4]
 8003948:	7809      	ldrb	r1, [r1, #0]
 800394a:	0889      	lsrs	r1, r1, #2
 800394c:	4201      	tst	r1, r0
 800394e:	d006      	beq.n	800395e <PE_PerformSoftReset+0x20>
 8003950:	7565      	strb	r5, [r4, #21]
 8003952:	2101      	movs	r1, #1
 8003954:	68e2      	ldr	r2, [r4, #12]
 8003956:	4010      	ands	r0, r2
 8003958:	f001 fae3 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 800395c:	bd31      	pop	{r0, r4, r5, pc}
 800395e:	2100      	movs	r1, #0
 8003960:	68e2      	ldr	r2, [r4, #12]
 8003962:	4010      	ands	r0, r2
 8003964:	f001 fadd 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8003968:	4828      	ldr	r0, [pc, #160]	; (8003a0c <.text_48>)
 800396a:	5225      	strh	r5, [r4, r0]
 800396c:	7525      	strb	r5, [r4, #20]
 800396e:	bd31      	pop	{r0, r4, r5, pc}

08003970 <.text_40>:
 8003970:	00000242 	.word	0x00000242

08003974 <PE_Get_DataRole>:
 8003974:	4924      	ldr	r1, [pc, #144]	; (8003a08 <.text_47>)
 8003976:	0080      	lsls	r0, r0, #2
 8003978:	1808      	adds	r0, r1, r0
 800397a:	6840      	ldr	r0, [r0, #4]
 800397c:	6840      	ldr	r0, [r0, #4]
 800397e:	7800      	ldrb	r0, [r0, #0]
 8003980:	0701      	lsls	r1, r0, #28
 8003982:	0fc8      	lsrs	r0, r1, #31
 8003984:	4770      	bx	lr

08003986 <PE_Get_SpecRevision>:
 8003986:	4920      	ldr	r1, [pc, #128]	; (8003a08 <.text_47>)
 8003988:	0080      	lsls	r0, r0, #2
 800398a:	1808      	adds	r0, r1, r0
 800398c:	6840      	ldr	r0, [r0, #4]
 800398e:	6840      	ldr	r0, [r0, #4]
 8003990:	7800      	ldrb	r0, [r0, #0]
 8003992:	0780      	lsls	r0, r0, #30
 8003994:	0f80      	lsrs	r0, r0, #30
 8003996:	4770      	bx	lr

08003998 <.text_43>:
 8003998:	00000393 	.word	0x00000393

0800399c <PE_ChangePowerRole>:
 800399c:	b538      	push	{r3, r4, r5, lr}
 800399e:	6842      	ldr	r2, [r0, #4]
 80039a0:	7813      	ldrb	r3, [r2, #0]
 80039a2:	24fb      	movs	r4, #251	; 0xfb
 80039a4:	401c      	ands	r4, r3
 80039a6:	008b      	lsls	r3, r1, #2
 80039a8:	2504      	movs	r5, #4
 80039aa:	402b      	ands	r3, r5
 80039ac:	4323      	orrs	r3, r4
 80039ae:	7013      	strb	r3, [r2, #0]
 80039b0:	7b02      	ldrb	r2, [r0, #12]
 80039b2:	07d0      	lsls	r0, r2, #31
 80039b4:	0fc0      	lsrs	r0, r0, #31
 80039b6:	f001 fab4 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 80039ba:	bd31      	pop	{r0, r4, r5, pc}

080039bc <PE_Check_RxEvent>:
 80039bc:	b081      	sub	sp, #4
 80039be:	0001      	movs	r1, r0
 80039c0:	2014      	movs	r0, #20
 80039c2:	4a13      	ldr	r2, [pc, #76]	; (8003a10 <.text_49>)
 80039c4:	1889      	adds	r1, r1, r2
 80039c6:	780a      	ldrb	r2, [r1, #0]
 80039c8:	2a00      	cmp	r2, #0
 80039ca:	d019      	beq.n	8003a00 <PE_Check_RxEvent+0x44>
 80039cc:	780a      	ldrb	r2, [r1, #0]
 80039ce:	0692      	lsls	r2, r2, #26
 80039d0:	d401      	bmi.n	80039d6 <PE_Check_RxEvent+0x1a>
 80039d2:	2003      	movs	r0, #3
 80039d4:	e014      	b.n	8003a00 <PE_Check_RxEvent+0x44>
 80039d6:	2200      	movs	r2, #0
 80039d8:	780b      	ldrb	r3, [r1, #0]
 80039da:	06db      	lsls	r3, r3, #27
 80039dc:	0edb      	lsrs	r3, r3, #27
 80039de:	2b01      	cmp	r3, #1
 80039e0:	d004      	beq.n	80039ec <PE_Check_RxEvent+0x30>
 80039e2:	2b02      	cmp	r3, #2
 80039e4:	d005      	beq.n	80039f2 <PE_Check_RxEvent+0x36>
 80039e6:	2b04      	cmp	r3, #4
 80039e8:	d006      	beq.n	80039f8 <PE_Check_RxEvent+0x3c>
 80039ea:	e008      	b.n	80039fe <PE_Check_RxEvent+0x42>
 80039ec:	2011      	movs	r0, #17
 80039ee:	710a      	strb	r2, [r1, #4]
 80039f0:	e005      	b.n	80039fe <PE_Check_RxEvent+0x42>
 80039f2:	2012      	movs	r0, #18
 80039f4:	2301      	movs	r3, #1
 80039f6:	e001      	b.n	80039fc <PE_Check_RxEvent+0x40>
 80039f8:	2013      	movs	r0, #19
 80039fa:	2302      	movs	r3, #2
 80039fc:	710b      	strb	r3, [r1, #4]
 80039fe:	700a      	strb	r2, [r1, #0]
 8003a00:	b001      	add	sp, #4
 8003a02:	4770      	bx	lr

08003a04 <.text_46>:
 8003a04:	00001771 	.word	0x00001771

08003a08 <.text_47>:
 8003a08:	200019a8 	.word	0x200019a8

08003a0c <.text_48>:
 8003a0c:	0000036e 	.word	0x0000036e

08003a10 <.text_49>:
 8003a10:	00000356 	.word	0x00000356

08003a14 <PE_Check_AMSConflict>:
 8003a14:	b081      	sub	sp, #4
 8003a16:	21d6      	movs	r1, #214	; 0xd6
 8003a18:	0089      	lsls	r1, r1, #2
 8003a1a:	1841      	adds	r1, r0, r1
 8003a1c:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
 8003a1e:	0bd2      	lsrs	r2, r2, #15
 8003a20:	d10a      	bne.n	8003a38 <PE_Check_AMSConflict+0x24>
 8003a22:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
 8003a24:	0452      	lsls	r2, r2, #17
 8003a26:	0f52      	lsrs	r2, r2, #29
 8003a28:	d106      	bne.n	8003a38 <PE_Check_AMSConflict+0x24>
 8003a2a:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
 8003a2c:	06d2      	lsls	r2, r2, #27
 8003a2e:	0ed2      	lsrs	r2, r2, #27
 8003a30:	2a0d      	cmp	r2, #13
 8003a32:	d101      	bne.n	8003a38 <PE_Check_AMSConflict+0x24>
 8003a34:	2010      	movs	r0, #16
 8003a36:	e01a      	b.n	8003a6e <PE_Check_AMSConflict+0x5a>
 8003a38:	2216      	movs	r2, #22
 8003a3a:	5e80      	ldrsh	r0, [r0, r2]
 8003a3c:	2203      	movs	r2, #3
 8003a3e:	0003      	movs	r3, r0
 8003a40:	d00f      	beq.n	8003a62 <PE_Check_AMSConflict+0x4e>
 8003a42:	1e43      	subs	r3, r0, #1
 8003a44:	2b01      	cmp	r3, #1
 8003a46:	d90f      	bls.n	8003a68 <PE_Check_AMSConflict+0x54>
 8003a48:	1e9b      	subs	r3, r3, #2
 8003a4a:	d00f      	beq.n	8003a6c <PE_Check_AMSConflict+0x58>
 8003a4c:	1e5b      	subs	r3, r3, #1
 8003a4e:	d00f      	beq.n	8003a70 <PE_Check_AMSConflict+0x5c>
 8003a50:	1e5b      	subs	r3, r3, #1
 8003a52:	2b0b      	cmp	r3, #11
 8003a54:	d908      	bls.n	8003a68 <PE_Check_AMSConflict+0x54>
 8003a56:	3b0c      	subs	r3, #12
 8003a58:	d00f      	beq.n	8003a7a <PE_Check_AMSConflict+0x66>
 8003a5a:	3bef      	subs	r3, #239	; 0xef
 8003a5c:	2b0e      	cmp	r3, #14
 8003a5e:	d909      	bls.n	8003a74 <PE_Check_AMSConflict+0x60>
 8003a60:	e00c      	b.n	8003a7c <PE_Check_AMSConflict+0x68>
 8003a62:	2004      	movs	r0, #4
 8003a64:	7008      	strb	r0, [r1, #0]
 8003a66:	e009      	b.n	8003a7c <PE_Check_AMSConflict+0x68>
 8003a68:	2011      	movs	r0, #17
 8003a6a:	e000      	b.n	8003a6e <PE_Check_AMSConflict+0x5a>
 8003a6c:	200f      	movs	r0, #15
 8003a6e:	7008      	strb	r0, [r1, #0]
 8003a70:	2015      	movs	r0, #21
 8003a72:	e004      	b.n	8003a7e <PE_Check_AMSConflict+0x6a>
 8003a74:	80c8      	strh	r0, [r1, #6]
 8003a76:	7808      	ldrb	r0, [r1, #0]
 8003a78:	7108      	strb	r0, [r1, #4]
 8003a7a:	700a      	strb	r2, [r1, #0]
 8003a7c:	2000      	movs	r0, #0
 8003a7e:	b001      	add	sp, #4
 8003a80:	4770      	bx	lr
	...

08003a84 <PE_Check_ControlMessage>:
 8003a84:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 8003a86:	0004      	movs	r4, r0
 8003a88:	48ca      	ldr	r0, [pc, #808]	; (8003db4 <.text_52>)
 8003a8a:	68c1      	ldr	r1, [r0, #12]
 8003a8c:	9101      	str	r1, [sp, #4]
 8003a8e:	7800      	ldrb	r0, [r0, #0]
 8003a90:	2102      	movs	r1, #2
 8003a92:	4008      	ands	r0, r1
 8003a94:	21d6      	movs	r1, #214	; 0xd6
 8003a96:	0089      	lsls	r1, r1, #2
 8003a98:	1866      	adds	r6, r4, r1
 8003a9a:	2103      	movs	r1, #3
 8003a9c:	2501      	movs	r5, #1
 8003a9e:	222a      	movs	r2, #42	; 0x2a
 8003aa0:	8db3      	ldrh	r3, [r6, #44]	; 0x2c
 8003aa2:	06db      	lsls	r3, r3, #27
 8003aa4:	0edb      	lsrs	r3, r3, #27
 8003aa6:	1e5b      	subs	r3, r3, #1
 8003aa8:	2b14      	cmp	r3, #20
 8003aaa:	d900      	bls.n	8003aae <PE_Check_ControlMessage+0x2a>
 8003aac:	e17b      	b.n	8003da6 <PE_Check_ControlMessage+0x322>
 8003aae:	a702      	add	r7, pc, #8	; (adr r7, 8003ab8 <PE_Check_ControlMessage+0x34>)
 8003ab0:	005b      	lsls	r3, r3, #1
 8003ab2:	5aff      	ldrh	r7, [r7, r3]
 8003ab4:	44bf      	add	pc, r7
 8003ab6:	bf00      	nop
 8003ab8:	002a02fa 	.word	0x002a02fa
 8003abc:	02e802e8 	.word	0x02e802e8
 8003ac0:	02e80090 	.word	0x02e80090
 8003ac4:	01d400ac 	.word	0x01d400ac
 8003ac8:	016e01b8 	.word	0x016e01b8
 8003acc:	02e801a8 	.word	0x02e801a8
 8003ad0:	02ee0064 	.word	0x02ee0064
 8003ad4:	02fa02ee 	.word	0x02fa02ee
 8003ad8:	025e021e 	.word	0x025e021e
 8003adc:	028c02e2 	.word	0x028c02e2
 8003ae0:	02d4      	.short	0x02d4
 8003ae2:	6861      	ldr	r1, [r4, #4]
 8003ae4:	7809      	ldrb	r1, [r1, #0]
 8003ae6:	0889      	lsrs	r1, r1, #2
 8003ae8:	4229      	tst	r1, r5
 8003aea:	d000      	beq.n	8003aee <PE_Check_ControlMessage+0x6a>
 8003aec:	e161      	b.n	8003db2 <PE_Check_ControlMessage+0x32e>
 8003aee:	2102      	movs	r1, #2
 8003af0:	82e1      	strh	r1, [r4, #22]
 8003af2:	2800      	cmp	r0, #0
 8003af4:	d009      	beq.n	8003b0a <PE_Check_ControlMessage+0x86>
 8003af6:	2000      	movs	r0, #0
 8003af8:	9000      	str	r0, [sp, #0]
 8003afa:	2300      	movs	r3, #0
 8003afc:	2229      	movs	r2, #41	; 0x29
 8003afe:	68e0      	ldr	r0, [r4, #12]
 8003b00:	2101      	movs	r1, #1
 8003b02:	4001      	ands	r1, r0
 8003b04:	2009      	movs	r0, #9
 8003b06:	9f01      	ldr	r7, [sp, #4]
 8003b08:	47b8      	blx	r7
 8003b0a:	2129      	movs	r1, #41	; 0x29
 8003b0c:	68e0      	ldr	r0, [r4, #12]
 8003b0e:	4005      	ands	r5, r0
 8003b10:	0028      	movs	r0, r5
 8003b12:	68a2      	ldr	r2, [r4, #8]
 8003b14:	68d2      	ldr	r2, [r2, #12]
 8003b16:	4790      	blx	r2
 8003b18:	2098      	movs	r0, #152	; 0x98
 8003b1a:	e142      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003b1c:	82e1      	strh	r1, [r4, #22]
 8003b1e:	2800      	cmp	r0, #0
 8003b20:	d009      	beq.n	8003b36 <PE_Check_ControlMessage+0xb2>
 8003b22:	2000      	movs	r0, #0
 8003b24:	9000      	str	r0, [sp, #0]
 8003b26:	2300      	movs	r3, #0
 8003b28:	2230      	movs	r2, #48	; 0x30
 8003b2a:	68e0      	ldr	r0, [r4, #12]
 8003b2c:	2101      	movs	r1, #1
 8003b2e:	4001      	ands	r1, r0
 8003b30:	2009      	movs	r0, #9
 8003b32:	9f01      	ldr	r7, [sp, #4]
 8003b34:	47b8      	blx	r7
 8003b36:	2130      	movs	r1, #48	; 0x30
 8003b38:	68e0      	ldr	r0, [r4, #12]
 8003b3a:	4005      	ands	r5, r0
 8003b3c:	0028      	movs	r0, r5
 8003b3e:	68a2      	ldr	r2, [r4, #8]
 8003b40:	68d2      	ldr	r2, [r2, #12]
 8003b42:	4790      	blx	r2
 8003b44:	2010      	movs	r0, #16
 8003b46:	e12c      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003b48:	2800      	cmp	r0, #0
 8003b4a:	d009      	beq.n	8003b60 <PE_Check_ControlMessage+0xdc>
 8003b4c:	2000      	movs	r0, #0
 8003b4e:	9000      	str	r0, [sp, #0]
 8003b50:	2300      	movs	r3, #0
 8003b52:	2231      	movs	r2, #49	; 0x31
 8003b54:	68e0      	ldr	r0, [r4, #12]
 8003b56:	2101      	movs	r1, #1
 8003b58:	4001      	ands	r1, r0
 8003b5a:	2009      	movs	r0, #9
 8003b5c:	9e01      	ldr	r6, [sp, #4]
 8003b5e:	47b0      	blx	r6
 8003b60:	2131      	movs	r1, #49	; 0x31
 8003b62:	e10c      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003b64:	2306      	movs	r3, #6
 8003b66:	82e3      	strh	r3, [r4, #22]
 8003b68:	466b      	mov	r3, sp
 8003b6a:	6867      	ldr	r7, [r4, #4]
 8003b6c:	783f      	ldrb	r7, [r7, #0]
 8003b6e:	701f      	strb	r7, [r3, #0]
 8003b70:	463b      	mov	r3, r7
 8003b72:	089f      	lsrs	r7, r3, #2
 8003b74:	422f      	tst	r7, r5
 8003b76:	d04d      	beq.n	8003c14 <PE_Check_ControlMessage+0x190>
 8003b78:	2800      	cmp	r0, #0
 8003b7a:	d009      	beq.n	8003b90 <PE_Check_ControlMessage+0x10c>
 8003b7c:	2000      	movs	r0, #0
 8003b7e:	9000      	str	r0, [sp, #0]
 8003b80:	2300      	movs	r3, #0
 8003b82:	220c      	movs	r2, #12
 8003b84:	68e0      	ldr	r0, [r4, #12]
 8003b86:	2101      	movs	r1, #1
 8003b88:	4001      	ands	r1, r0
 8003b8a:	2009      	movs	r0, #9
 8003b8c:	9f01      	ldr	r7, [sp, #4]
 8003b8e:	47b8      	blx	r7
 8003b90:	210c      	movs	r1, #12
 8003b92:	68e2      	ldr	r2, [r4, #12]
 8003b94:	2001      	movs	r0, #1
 8003b96:	4010      	ands	r0, r2
 8003b98:	68a2      	ldr	r2, [r4, #8]
 8003b9a:	68d2      	ldr	r2, [r2, #12]
 8003b9c:	4790      	blx	r2
 8003b9e:	2100      	movs	r1, #0
 8003ba0:	0020      	movs	r0, r4
 8003ba2:	f7ff fd8c 	bl	80036be <PE_Send_SRCCapabilities>
 8003ba6:	2805      	cmp	r0, #5
 8003ba8:	d002      	beq.n	8003bb0 <PE_Check_ControlMessage+0x12c>
 8003baa:	2000      	movs	r0, #0
 8003bac:	82e0      	strh	r0, [r4, #22]
 8003bae:	e0f7      	b.n	8003da0 <PE_Check_ControlMessage+0x31c>
 8003bb0:	6860      	ldr	r0, [r4, #4]
 8003bb2:	7841      	ldrb	r1, [r0, #1]
 8003bb4:	228f      	movs	r2, #143	; 0x8f
 8003bb6:	400a      	ands	r2, r1
 8003bb8:	2140      	movs	r1, #64	; 0x40
 8003bba:	4311      	orrs	r1, r2
 8003bbc:	7041      	strb	r1, [r0, #1]
 8003bbe:	487d      	ldr	r0, [pc, #500]	; (8003db4 <.text_52>)
 8003bc0:	7800      	ldrb	r0, [r0, #0]
 8003bc2:	0780      	lsls	r0, r0, #30
 8003bc4:	d50a      	bpl.n	8003bdc <PE_Check_ControlMessage+0x158>
 8003bc6:	2000      	movs	r0, #0
 8003bc8:	9000      	str	r0, [sp, #0]
 8003bca:	2300      	movs	r3, #0
 8003bcc:	2256      	movs	r2, #86	; 0x56
 8003bce:	68e0      	ldr	r0, [r4, #12]
 8003bd0:	2101      	movs	r1, #1
 8003bd2:	4001      	ands	r1, r0
 8003bd4:	2009      	movs	r0, #9
 8003bd6:	4f77      	ldr	r7, [pc, #476]	; (8003db4 <.text_52>)
 8003bd8:	68ff      	ldr	r7, [r7, #12]
 8003bda:	47b8      	blx	r7
 8003bdc:	2156      	movs	r1, #86	; 0x56
 8003bde:	68e2      	ldr	r2, [r4, #12]
 8003be0:	2001      	movs	r0, #1
 8003be2:	4010      	ands	r0, r2
 8003be4:	68a2      	ldr	r2, [r4, #8]
 8003be6:	68d2      	ldr	r2, [r2, #12]
 8003be8:	4790      	blx	r2
 8003bea:	82e5      	strh	r5, [r4, #22]
 8003bec:	4872      	ldr	r0, [pc, #456]	; (8003db8 <.text_53>)
 8003bee:	82b0      	strh	r0, [r6, #20]
 8003bf0:	2016      	movs	r0, #22
 8003bf2:	7030      	strb	r0, [r6, #0]
 8003bf4:	4e6f      	ldr	r6, [pc, #444]	; (8003db4 <.text_52>)
 8003bf6:	7830      	ldrb	r0, [r6, #0]
 8003bf8:	0780      	lsls	r0, r0, #30
 8003bfa:	d509      	bpl.n	8003c10 <PE_Check_ControlMessage+0x18c>
 8003bfc:	2000      	movs	r0, #0
 8003bfe:	9000      	str	r0, [sp, #0]
 8003c00:	2300      	movs	r3, #0
 8003c02:	220f      	movs	r2, #15
 8003c04:	68e0      	ldr	r0, [r4, #12]
 8003c06:	2101      	movs	r1, #1
 8003c08:	4001      	ands	r1, r0
 8003c0a:	2009      	movs	r0, #9
 8003c0c:	68f6      	ldr	r6, [r6, #12]
 8003c0e:	47b0      	blx	r6
 8003c10:	210f      	movs	r1, #15
 8003c12:	e0b4      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003c14:	6820      	ldr	r0, [r4, #0]
 8003c16:	6840      	ldr	r0, [r0, #4]
 8003c18:	08c0      	lsrs	r0, r0, #3
 8003c1a:	4028      	ands	r0, r5
 8003c1c:	d001      	beq.n	8003c22 <PE_Check_ControlMessage+0x19e>
 8003c1e:	204c      	movs	r0, #76	; 0x4c
 8003c20:	e0bf      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003c22:	4019      	ands	r1, r3
 8003c24:	e02b      	b.n	8003c7e <PE_Check_ControlMessage+0x1fa>
 8003c26:	6823      	ldr	r3, [r4, #0]
 8003c28:	685b      	ldr	r3, [r3, #4]
 8003c2a:	08db      	lsrs	r3, r3, #3
 8003c2c:	402b      	ands	r3, r5
 8003c2e:	d023      	beq.n	8003c78 <PE_Check_ControlMessage+0x1f4>
 8003c30:	2122      	movs	r1, #34	; 0x22
 8003c32:	7031      	strb	r1, [r6, #0]
 8003c34:	2800      	cmp	r0, #0
 8003c36:	d009      	beq.n	8003c4c <PE_Check_ControlMessage+0x1c8>
 8003c38:	2000      	movs	r0, #0
 8003c3a:	9000      	str	r0, [sp, #0]
 8003c3c:	2300      	movs	r3, #0
 8003c3e:	223a      	movs	r2, #58	; 0x3a
 8003c40:	68e0      	ldr	r0, [r4, #12]
 8003c42:	2101      	movs	r1, #1
 8003c44:	4001      	ands	r1, r0
 8003c46:	2009      	movs	r0, #9
 8003c48:	9e01      	ldr	r6, [sp, #4]
 8003c4a:	47b0      	blx	r6
 8003c4c:	213a      	movs	r1, #58	; 0x3a
 8003c4e:	68e0      	ldr	r0, [r4, #12]
 8003c50:	4005      	ands	r5, r0
 8003c52:	0028      	movs	r0, r5
 8003c54:	68a2      	ldr	r2, [r4, #8]
 8003c56:	68d2      	ldr	r2, [r2, #12]
 8003c58:	4790      	blx	r2
 8003c5a:	2008      	movs	r0, #8
 8003c5c:	82e0      	strh	r0, [r4, #22]
 8003c5e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003c60:	68a0      	ldr	r0, [r4, #8]
 8003c62:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8003c64:	2800      	cmp	r0, #0
 8003c66:	d007      	beq.n	8003c78 <PE_Check_ControlMessage+0x1f4>
 8003c68:	2010      	movs	r0, #16
 8003c6a:	82e0      	strh	r0, [r4, #22]
 8003c6c:	209d      	movs	r0, #157	; 0x9d
 8003c6e:	e098      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003c70:	68a0      	ldr	r0, [r4, #8]
 8003c72:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 8003c74:	2800      	cmp	r0, #0
 8003c76:	d105      	bne.n	8003c84 <PE_Check_ControlMessage+0x200>
 8003c78:	6860      	ldr	r0, [r4, #4]
 8003c7a:	7800      	ldrb	r0, [r0, #0]
 8003c7c:	4001      	ands	r1, r0
 8003c7e:	2902      	cmp	r1, #2
 8003c80:	d127      	bne.n	8003cd2 <PE_Check_ControlMessage+0x24e>
 8003c82:	e095      	b.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003c84:	200f      	movs	r0, #15
 8003c86:	82e0      	strh	r0, [r4, #22]
 8003c88:	2093      	movs	r0, #147	; 0x93
 8003c8a:	e08a      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003c8c:	2307      	movs	r3, #7
 8003c8e:	82e3      	strh	r3, [r4, #22]
 8003c90:	466b      	mov	r3, sp
 8003c92:	6867      	ldr	r7, [r4, #4]
 8003c94:	783f      	ldrb	r7, [r7, #0]
 8003c96:	701f      	strb	r7, [r3, #0]
 8003c98:	08bf      	lsrs	r7, r7, #2
 8003c9a:	422f      	tst	r7, r5
 8003c9c:	d004      	beq.n	8003ca8 <PE_Check_ControlMessage+0x224>
 8003c9e:	6823      	ldr	r3, [r4, #0]
 8003ca0:	685b      	ldr	r3, [r3, #4]
 8003ca2:	08db      	lsrs	r3, r3, #3
 8003ca4:	402b      	ands	r3, r5
 8003ca6:	d00f      	beq.n	8003cc8 <PE_Check_ControlMessage+0x244>
 8003ca8:	211d      	movs	r1, #29
 8003caa:	7031      	strb	r1, [r6, #0]
 8003cac:	2800      	cmp	r0, #0
 8003cae:	d009      	beq.n	8003cc4 <PE_Check_ControlMessage+0x240>
 8003cb0:	2000      	movs	r0, #0
 8003cb2:	9000      	str	r0, [sp, #0]
 8003cb4:	2300      	movs	r3, #0
 8003cb6:	2206      	movs	r2, #6
 8003cb8:	68e0      	ldr	r0, [r4, #12]
 8003cba:	2101      	movs	r1, #1
 8003cbc:	4001      	ands	r1, r0
 8003cbe:	2009      	movs	r0, #9
 8003cc0:	9e01      	ldr	r6, [sp, #4]
 8003cc2:	47b0      	blx	r6
 8003cc4:	2106      	movs	r1, #6
 8003cc6:	e05a      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003cc8:	4668      	mov	r0, sp
 8003cca:	7800      	ldrb	r0, [r0, #0]
 8003ccc:	4001      	ands	r1, r0
 8003cce:	2902      	cmp	r1, #2
 8003cd0:	d06e      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003cd2:	7032      	strb	r2, [r6, #0]
 8003cd4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003cd6:	6821      	ldr	r1, [r4, #0]
 8003cd8:	88ca      	ldrh	r2, [r1, #6]
 8003cda:	08d2      	lsrs	r2, r2, #3
 8003cdc:	422a      	tst	r2, r5
 8003cde:	d067      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003ce0:	6862      	ldr	r2, [r4, #4]
 8003ce2:	7812      	ldrb	r2, [r2, #0]
 8003ce4:	0892      	lsrs	r2, r2, #2
 8003ce6:	422a      	tst	r2, r5
 8003ce8:	d103      	bne.n	8003cf2 <PE_Check_ControlMessage+0x26e>
 8003cea:	6849      	ldr	r1, [r1, #4]
 8003cec:	08c9      	lsrs	r1, r1, #3
 8003cee:	4029      	ands	r1, r5
 8003cf0:	d05e      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003cf2:	210a      	movs	r1, #10
 8003cf4:	82e1      	strh	r1, [r4, #22]
 8003cf6:	2163      	movs	r1, #99	; 0x63
 8003cf8:	7031      	strb	r1, [r6, #0]
 8003cfa:	2800      	cmp	r0, #0
 8003cfc:	d009      	beq.n	8003d12 <PE_Check_ControlMessage+0x28e>
 8003cfe:	2000      	movs	r0, #0
 8003d00:	9000      	str	r0, [sp, #0]
 8003d02:	2300      	movs	r3, #0
 8003d04:	2243      	movs	r2, #67	; 0x43
 8003d06:	68e0      	ldr	r0, [r4, #12]
 8003d08:	2101      	movs	r1, #1
 8003d0a:	4001      	ands	r1, r0
 8003d0c:	2009      	movs	r0, #9
 8003d0e:	9e01      	ldr	r6, [sp, #4]
 8003d10:	47b0      	blx	r6
 8003d12:	2143      	movs	r1, #67	; 0x43
 8003d14:	e033      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003d16:	6821      	ldr	r1, [r4, #0]
 8003d18:	88c9      	ldrh	r1, [r1, #6]
 8003d1a:	0949      	lsrs	r1, r1, #5
 8003d1c:	4229      	tst	r1, r5
 8003d1e:	d047      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003d20:	210b      	movs	r1, #11
 8003d22:	82e1      	strh	r1, [r4, #22]
 8003d24:	2130      	movs	r1, #48	; 0x30
 8003d26:	7031      	strb	r1, [r6, #0]
 8003d28:	2800      	cmp	r0, #0
 8003d2a:	d009      	beq.n	8003d40 <PE_Check_ControlMessage+0x2bc>
 8003d2c:	2000      	movs	r0, #0
 8003d2e:	9000      	str	r0, [sp, #0]
 8003d30:	2300      	movs	r3, #0
 8003d32:	224a      	movs	r2, #74	; 0x4a
 8003d34:	68e0      	ldr	r0, [r4, #12]
 8003d36:	2101      	movs	r1, #1
 8003d38:	4001      	ands	r1, r0
 8003d3a:	2009      	movs	r0, #9
 8003d3c:	9e01      	ldr	r6, [sp, #4]
 8003d3e:	47b0      	blx	r6
 8003d40:	214a      	movs	r1, #74	; 0x4a
 8003d42:	e01c      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003d44:	6821      	ldr	r1, [r4, #0]
 8003d46:	88c9      	ldrh	r1, [r1, #6]
 8003d48:	0889      	lsrs	r1, r1, #2
 8003d4a:	4229      	tst	r1, r5
 8003d4c:	d030      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003d4e:	210b      	movs	r1, #11
 8003d50:	82e1      	strh	r1, [r4, #22]
 8003d52:	6861      	ldr	r1, [r4, #4]
 8003d54:	7809      	ldrb	r1, [r1, #0]
 8003d56:	0889      	lsrs	r1, r1, #2
 8003d58:	4229      	tst	r1, r5
 8003d5a:	d001      	beq.n	8003d60 <PE_Check_ControlMessage+0x2dc>
 8003d5c:	212d      	movs	r1, #45	; 0x2d
 8003d5e:	e000      	b.n	8003d62 <PE_Check_ControlMessage+0x2de>
 8003d60:	2111      	movs	r1, #17
 8003d62:	7031      	strb	r1, [r6, #0]
 8003d64:	2800      	cmp	r0, #0
 8003d66:	d009      	beq.n	8003d7c <PE_Check_ControlMessage+0x2f8>
 8003d68:	2000      	movs	r0, #0
 8003d6a:	9000      	str	r0, [sp, #0]
 8003d6c:	2300      	movs	r3, #0
 8003d6e:	2246      	movs	r2, #70	; 0x46
 8003d70:	68e0      	ldr	r0, [r4, #12]
 8003d72:	2101      	movs	r1, #1
 8003d74:	4001      	ands	r1, r0
 8003d76:	2009      	movs	r0, #9
 8003d78:	9e01      	ldr	r6, [sp, #4]
 8003d7a:	47b0      	blx	r6
 8003d7c:	2146      	movs	r1, #70	; 0x46
 8003d7e:	68e0      	ldr	r0, [r4, #12]
 8003d80:	4005      	ands	r5, r0
 8003d82:	0028      	movs	r0, r5
 8003d84:	68a2      	ldr	r2, [r4, #8]
 8003d86:	68d2      	ldr	r2, [r2, #12]
 8003d88:	4790      	blx	r2
 8003d8a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003d8c:	6820      	ldr	r0, [r4, #0]
 8003d8e:	88c0      	ldrh	r0, [r0, #6]
 8003d90:	0a00      	lsrs	r0, r0, #8
 8003d92:	4228      	tst	r0, r5
 8003d94:	d00c      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003d96:	202f      	movs	r0, #47	; 0x2f
 8003d98:	e003      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003d9a:	2009      	movs	r0, #9
 8003d9c:	82e0      	strh	r0, [r4, #22]
 8003d9e:	e007      	b.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003da0:	2011      	movs	r0, #17
 8003da2:	7030      	strb	r0, [r6, #0]
 8003da4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003da6:	6860      	ldr	r0, [r4, #4]
 8003da8:	7800      	ldrb	r0, [r0, #0]
 8003daa:	4001      	ands	r1, r0
 8003dac:	2902      	cmp	r1, #2
 8003dae:	d100      	bne.n	8003db2 <PE_Check_ControlMessage+0x32e>
 8003db0:	7035      	strb	r5, [r6, #0]
 8003db2:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

08003db4 <.text_52>:
 8003db4:	200019a8 	.word	0x200019a8

08003db8 <.text_53>:
 8003db8:	0000801a 	.word	0x0000801a

08003dbc <PE_Check_DataMessage>:
 8003dbc:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 8003dbe:	0004      	movs	r4, r0
 8003dc0:	209e      	movs	r0, #158	; 0x9e
 8003dc2:	0040      	lsls	r0, r0, #1
 8003dc4:	1827      	adds	r7, r4, r0
 8003dc6:	20d6      	movs	r0, #214	; 0xd6
 8003dc8:	0080      	lsls	r0, r0, #2
 8003dca:	1826      	adds	r6, r4, r0
 8003dcc:	2501      	movs	r5, #1
 8003dce:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 8003dd0:	06c0      	lsls	r0, r0, #27
 8003dd2:	0ec0      	lsrs	r0, r0, #27
 8003dd4:	2801      	cmp	r0, #1
 8003dd6:	d02f      	beq.n	8003e38 <PE_Check_DataMessage+0x7c>
 8003dd8:	2802      	cmp	r0, #2
 8003dda:	d009      	beq.n	8003df0 <PE_Check_DataMessage+0x34>
 8003ddc:	2803      	cmp	r0, #3
 8003dde:	d047      	beq.n	8003e70 <PE_Check_DataMessage+0xb4>
 8003de0:	2806      	cmp	r0, #6
 8003de2:	d07d      	beq.n	8003ee0 <PE_Check_DataMessage+0x124>
 8003de4:	2807      	cmp	r0, #7
 8003de6:	d100      	bne.n	8003dea <PE_Check_DataMessage+0x2e>
 8003de8:	e08a      	b.n	8003f00 <PE_Check_DataMessage+0x144>
 8003dea:	280f      	cmp	r0, #15
 8003dec:	d071      	beq.n	8003ed2 <PE_Check_DataMessage+0x116>
 8003dee:	e090      	b.n	8003f12 <PE_Check_DataMessage+0x156>
 8003df0:	6860      	ldr	r0, [r4, #4]
 8003df2:	7800      	ldrb	r0, [r0, #0]
 8003df4:	0880      	lsrs	r0, r0, #2
 8003df6:	4228      	tst	r0, r5
 8003df8:	d100      	bne.n	8003dfc <PE_Check_DataMessage+0x40>
 8003dfa:	e08c      	b.n	8003f16 <PE_Check_DataMessage+0x15a>
 8003dfc:	7838      	ldrb	r0, [r7, #0]
 8003dfe:	7879      	ldrb	r1, [r7, #1]
 8003e00:	0209      	lsls	r1, r1, #8
 8003e02:	1840      	adds	r0, r0, r1
 8003e04:	78b9      	ldrb	r1, [r7, #2]
 8003e06:	0409      	lsls	r1, r1, #16
 8003e08:	1840      	adds	r0, r0, r1
 8003e0a:	78f9      	ldrb	r1, [r7, #3]
 8003e0c:	0609      	lsls	r1, r1, #24
 8003e0e:	1840      	adds	r0, r0, r1
 8003e10:	9000      	str	r0, [sp, #0]
 8003e12:	2304      	movs	r3, #4
 8003e14:	466a      	mov	r2, sp
 8003e16:	2106      	movs	r1, #6
 8003e18:	68e7      	ldr	r7, [r4, #12]
 8003e1a:	2001      	movs	r0, #1
 8003e1c:	4038      	ands	r0, r7
 8003e1e:	68a7      	ldr	r7, [r4, #8]
 8003e20:	69ff      	ldr	r7, [r7, #28]
 8003e22:	47b8      	blx	r7
 8003e24:	82e5      	strh	r5, [r4, #22]
 8003e26:	8d70      	ldrh	r0, [r6, #42]	; 0x2a
 8003e28:	0440      	lsls	r0, r0, #17
 8003e2a:	0c40      	lsrs	r0, r0, #17
 8003e2c:	2801      	cmp	r0, #1
 8003e2e:	db01      	blt.n	8003e34 <PE_Check_DataMessage+0x78>
 8003e30:	2000      	movs	r0, #0
 8003e32:	8570      	strh	r0, [r6, #42]	; 0x2a
 8003e34:	2009      	movs	r0, #9
 8003e36:	e06d      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003e38:	6860      	ldr	r0, [r4, #4]
 8003e3a:	7800      	ldrb	r0, [r0, #0]
 8003e3c:	0880      	lsrs	r0, r0, #2
 8003e3e:	4228      	tst	r0, r5
 8003e40:	d169      	bne.n	8003f16 <PE_Check_DataMessage+0x15a>
 8003e42:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 8003e44:	0600      	lsls	r0, r0, #24
 8003e46:	0f81      	lsrs	r1, r0, #30
 8003e48:	68e2      	ldr	r2, [r4, #12]
 8003e4a:	2001      	movs	r0, #1
 8003e4c:	4010      	ands	r0, r2
 8003e4e:	f000 fabf 	bl	80043d0 <PE_ExtRevisionInteroperability>
 8003e52:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 8003e54:	0440      	lsls	r0, r0, #17
 8003e56:	0f40      	lsrs	r0, r0, #29
 8003e58:	0083      	lsls	r3, r0, #2
 8003e5a:	003a      	movs	r2, r7
 8003e5c:	2104      	movs	r1, #4
 8003e5e:	68e7      	ldr	r7, [r4, #12]
 8003e60:	2001      	movs	r0, #1
 8003e62:	4038      	ands	r0, r7
 8003e64:	68a7      	ldr	r7, [r4, #8]
 8003e66:	69ff      	ldr	r7, [r7, #28]
 8003e68:	47b8      	blx	r7
 8003e6a:	82e5      	strh	r5, [r4, #22]
 8003e6c:	2044      	movs	r0, #68	; 0x44
 8003e6e:	e051      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003e70:	2000      	movs	r0, #0
 8003e72:	9001      	str	r0, [sp, #4]
 8003e74:	9000      	str	r0, [sp, #0]
 8003e76:	7838      	ldrb	r0, [r7, #0]
 8003e78:	7879      	ldrb	r1, [r7, #1]
 8003e7a:	0209      	lsls	r1, r1, #8
 8003e7c:	1840      	adds	r0, r0, r1
 8003e7e:	78b9      	ldrb	r1, [r7, #2]
 8003e80:	0409      	lsls	r1, r1, #16
 8003e82:	1840      	adds	r0, r0, r1
 8003e84:	78f9      	ldrb	r1, [r7, #3]
 8003e86:	0609      	lsls	r1, r1, #24
 8003e88:	1847      	adds	r7, r0, r1
 8003e8a:	466b      	mov	r3, sp
 8003e8c:	aa01      	add	r2, sp, #4
 8003e8e:	2103      	movs	r1, #3
 8003e90:	68e0      	ldr	r0, [r4, #12]
 8003e92:	4005      	ands	r5, r0
 8003e94:	0028      	movs	r0, r5
 8003e96:	68a5      	ldr	r5, [r4, #8]
 8003e98:	69ad      	ldr	r5, [r5, #24]
 8003e9a:	47a8      	blx	r5
 8003e9c:	9800      	ldr	r0, [sp, #0]
 8003e9e:	2804      	cmp	r0, #4
 8003ea0:	d115      	bne.n	8003ece <PE_Check_DataMessage+0x112>
 8003ea2:	6860      	ldr	r0, [r4, #4]
 8003ea4:	7840      	ldrb	r0, [r0, #1]
 8003ea6:	0640      	lsls	r0, r0, #25
 8003ea8:	0f40      	lsrs	r0, r0, #29
 8003eaa:	2803      	cmp	r0, #3
 8003eac:	d10f      	bne.n	8003ece <PE_Check_DataMessage+0x112>
 8003eae:	9801      	ldr	r0, [sp, #4]
 8003eb0:	49b4      	ldr	r1, [pc, #720]	; (8004184 <.text_57>)
 8003eb2:	4288      	cmp	r0, r1
 8003eb4:	d10b      	bne.n	8003ece <PE_Check_DataMessage+0x112>
 8003eb6:	0f38      	lsrs	r0, r7, #28
 8003eb8:	d003      	beq.n	8003ec2 <PE_Check_DataMessage+0x106>
 8003eba:	2805      	cmp	r0, #5
 8003ebc:	d003      	beq.n	8003ec6 <PE_Check_DataMessage+0x10a>
 8003ebe:	2808      	cmp	r0, #8
 8003ec0:	d103      	bne.n	8003eca <PE_Check_DataMessage+0x10e>
 8003ec2:	2029      	movs	r0, #41	; 0x29
 8003ec4:	e026      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003ec6:	2027      	movs	r0, #39	; 0x27
 8003ec8:	e024      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003eca:	202a      	movs	r0, #42	; 0x2a
 8003ecc:	e022      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003ece:	2003      	movs	r0, #3
 8003ed0:	e020      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003ed2:	6860      	ldr	r0, [r4, #4]
 8003ed4:	7800      	ldrb	r0, [r0, #0]
 8003ed6:	0780      	lsls	r0, r0, #30
 8003ed8:	0f80      	lsrs	r0, r0, #30
 8003eda:	2802      	cmp	r0, #2
 8003edc:	d11b      	bne.n	8003f16 <PE_Check_DataMessage+0x15a>
 8003ede:	e016      	b.n	8003f0e <PE_Check_DataMessage+0x152>
 8003ee0:	6820      	ldr	r0, [r4, #0]
 8003ee2:	88c0      	ldrh	r0, [r0, #6]
 8003ee4:	0900      	lsrs	r0, r0, #4
 8003ee6:	4228      	tst	r0, r5
 8003ee8:	d011      	beq.n	8003f0e <PE_Check_DataMessage+0x152>
 8003eea:	2304      	movs	r3, #4
 8003eec:	003a      	movs	r2, r7
 8003eee:	210b      	movs	r1, #11
 8003ef0:	68e0      	ldr	r0, [r4, #12]
 8003ef2:	4005      	ands	r5, r0
 8003ef4:	0028      	movs	r0, r5
 8003ef6:	68a4      	ldr	r4, [r4, #8]
 8003ef8:	69e4      	ldr	r4, [r4, #28]
 8003efa:	47a0      	blx	r4
 8003efc:	202c      	movs	r0, #44	; 0x2c
 8003efe:	e009      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003f00:	6820      	ldr	r0, [r4, #0]
 8003f02:	88c0      	ldrh	r0, [r0, #6]
 8003f04:	0a40      	lsrs	r0, r0, #9
 8003f06:	4228      	tst	r0, r5
 8003f08:	d001      	beq.n	8003f0e <PE_Check_DataMessage+0x152>
 8003f0a:	203d      	movs	r0, #61	; 0x3d
 8003f0c:	e002      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003f0e:	7035      	strb	r5, [r6, #0]
 8003f10:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003f12:	2011      	movs	r0, #17
 8003f14:	7030      	strb	r0, [r6, #0]
 8003f16:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

08003f18 <PE_Check_ExtendedMessage>:
 8003f18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003f1a:	0005      	movs	r5, r0
 8003f1c:	209e      	movs	r0, #158	; 0x9e
 8003f1e:	0040      	lsls	r0, r0, #1
 8003f20:	1828      	adds	r0, r5, r0
 8003f22:	7801      	ldrb	r1, [r0, #0]
 8003f24:	7840      	ldrb	r0, [r0, #1]
 8003f26:	0200      	lsls	r0, r0, #8
 8003f28:	1808      	adds	r0, r1, r0
 8003f2a:	21e4      	movs	r1, #228	; 0xe4
 8003f2c:	0089      	lsls	r1, r1, #2
 8003f2e:	1869      	adds	r1, r5, r1
 8003f30:	8008      	strh	r0, [r1, #0]
 8003f32:	4a95      	ldr	r2, [pc, #596]	; (8004188 <.text_58>)
 8003f34:	18ac      	adds	r4, r5, r2
 8003f36:	8f62      	ldrh	r2, [r4, #58]	; 0x3a
 8003f38:	06d2      	lsls	r2, r2, #27
 8003f3a:	0ed2      	lsrs	r2, r2, #27
 8003f3c:	2380      	movs	r3, #128	; 0x80
 8003f3e:	4313      	orrs	r3, r2
 8003f40:	708b      	strb	r3, [r1, #2]
 8003f42:	2601      	movs	r6, #1
 8003f44:	0402      	lsls	r2, r0, #16
 8003f46:	0e92      	lsrs	r2, r2, #26
 8003f48:	2101      	movs	r1, #1
 8003f4a:	4011      	ands	r1, r2
 8003f4c:	0402      	lsls	r2, r0, #16
 8003f4e:	0ed2      	lsrs	r2, r2, #27
 8003f50:	0712      	lsls	r2, r2, #28
 8003f52:	d003      	beq.n	8003f5c <PE_Check_ExtendedMessage+0x44>
 8003f54:	000a      	movs	r2, r1
 8003f56:	d001      	beq.n	8003f5c <PE_Check_ExtendedMessage+0x44>
 8003f58:	2034      	movs	r0, #52	; 0x34
 8003f5a:	e0a7      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8003f5c:	05c2      	lsls	r2, r0, #23
 8003f5e:	0dd2      	lsrs	r2, r2, #23
 8003f60:	0403      	lsls	r3, r0, #16
 8003f62:	0fdb      	lsrs	r3, r3, #31
 8003f64:	d10c      	bne.n	8003f80 <PE_Check_ExtendedMessage+0x68>
 8003f66:	8022      	strh	r2, [r4, #0]
 8003f68:	2000      	movs	r0, #0
 8003f6a:	2336      	movs	r3, #54	; 0x36
 8003f6c:	8821      	ldrh	r1, [r4, #0]
 8003f6e:	4288      	cmp	r0, r1
 8003f70:	d218      	bcs.n	8003fa4 <PE_Check_ExtendedMessage+0x8c>
 8003f72:	1829      	adds	r1, r5, r0
 8003f74:	229f      	movs	r2, #159	; 0x9f
 8003f76:	0052      	lsls	r2, r2, #1
 8003f78:	5c8a      	ldrb	r2, [r1, r2]
 8003f7a:	54ca      	strb	r2, [r1, r3]
 8003f7c:	1c40      	adds	r0, r0, #1
 8003f7e:	e7f5      	b.n	8003f6c <PE_Check_ExtendedMessage+0x54>
 8003f80:	23f8      	movs	r3, #248	; 0xf8
 8003f82:	01db      	lsls	r3, r3, #7
 8003f84:	4003      	ands	r3, r0
 8003f86:	d108      	bne.n	8003f9a <PE_Check_ExtendedMessage+0x82>
 8003f88:	8f60      	ldrh	r0, [r4, #58]	; 0x3a
 8003f8a:	0440      	lsls	r0, r0, #17
 8003f8c:	0f40      	lsrs	r0, r0, #29
 8003f8e:	2806      	cmp	r0, #6
 8003f90:	dc00      	bgt.n	8003f94 <PE_Check_ExtendedMessage+0x7c>
 8003f92:	e08f      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003f94:	2a1b      	cmp	r2, #27
 8003f96:	d200      	bcs.n	8003f9a <PE_Check_ExtendedMessage+0x82>
 8003f98:	e08c      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003f9a:	2900      	cmp	r1, #0
 8003f9c:	d000      	beq.n	8003fa0 <PE_Check_ExtendedMessage+0x88>
 8003f9e:	e089      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003fa0:	8820      	ldrh	r0, [r4, #0]
 8003fa2:	4290      	cmp	r0, r2
 8003fa4:	d300      	bcc.n	8003fa8 <PE_Check_ExtendedMessage+0x90>
 8003fa6:	e085      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003fa8:	2037      	movs	r0, #55	; 0x37
 8003faa:	e07f      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8003fac:	2305      	movs	r3, #5
 8003fae:	2109      	movs	r1, #9
 8003fb0:	68ef      	ldr	r7, [r5, #12]
 8003fb2:	2001      	movs	r0, #1
 8003fb4:	4038      	ands	r0, r7
 8003fb6:	68af      	ldr	r7, [r5, #8]
 8003fb8:	69ff      	ldr	r7, [r7, #28]
 8003fba:	47b8      	blx	r7
 8003fbc:	2003      	movs	r0, #3
 8003fbe:	73a0      	strb	r0, [r4, #14]
 8003fc0:	4cca      	ldr	r4, [pc, #808]	; (80042ec <.text_61>)
 8003fc2:	7820      	ldrb	r0, [r4, #0]
 8003fc4:	0780      	lsls	r0, r0, #30
 8003fc6:	d509      	bpl.n	8003fdc <PE_Check_ExtendedMessage+0xc4>
 8003fc8:	2000      	movs	r0, #0
 8003fca:	9000      	str	r0, [sp, #0]
 8003fcc:	2300      	movs	r3, #0
 8003fce:	224b      	movs	r2, #75	; 0x4b
 8003fd0:	68e8      	ldr	r0, [r5, #12]
 8003fd2:	2101      	movs	r1, #1
 8003fd4:	4001      	ands	r1, r0
 8003fd6:	2009      	movs	r0, #9
 8003fd8:	68e4      	ldr	r4, [r4, #12]
 8003fda:	47a0      	blx	r4
 8003fdc:	214b      	movs	r1, #75	; 0x4b
 8003fde:	e0a4      	b.n	800412a <PE_Check_ExtendedMessage+0x212>
 8003fe0:	6828      	ldr	r0, [r5, #0]
 8003fe2:	88c0      	ldrh	r0, [r0, #6]
 8003fe4:	0980      	lsrs	r0, r0, #6
 8003fe6:	4230      	tst	r0, r6
 8003fe8:	d062      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8003fea:	2301      	movs	r3, #1
 8003fec:	2110      	movs	r1, #16
 8003fee:	68e8      	ldr	r0, [r5, #12]
 8003ff0:	4006      	ands	r6, r0
 8003ff2:	0030      	movs	r0, r6
 8003ff4:	68ad      	ldr	r5, [r5, #8]
 8003ff6:	69ed      	ldr	r5, [r5, #28]
 8003ff8:	47a8      	blx	r5
 8003ffa:	203a      	movs	r0, #58	; 0x3a
 8003ffc:	e056      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8003ffe:	6828      	ldr	r0, [r5, #0]
 8004000:	88c0      	ldrh	r0, [r0, #6]
 8004002:	0980      	lsrs	r0, r0, #6
 8004004:	4230      	tst	r0, r6
 8004006:	d053      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004008:	2301      	movs	r3, #1
 800400a:	210e      	movs	r1, #14
 800400c:	68e8      	ldr	r0, [r5, #12]
 800400e:	4006      	ands	r6, r0
 8004010:	0030      	movs	r0, r6
 8004012:	68ad      	ldr	r5, [r5, #8]
 8004014:	69ed      	ldr	r5, [r5, #28]
 8004016:	47a8      	blx	r5
 8004018:	203b      	movs	r0, #59	; 0x3b
 800401a:	e047      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 800401c:	6828      	ldr	r0, [r5, #0]
 800401e:	88c0      	ldrh	r0, [r0, #6]
 8004020:	09c0      	lsrs	r0, r0, #7
 8004022:	4230      	tst	r0, r6
 8004024:	d044      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004026:	2302      	movs	r3, #2
 8004028:	210c      	movs	r1, #12
 800402a:	68e8      	ldr	r0, [r5, #12]
 800402c:	4006      	ands	r6, r0
 800402e:	0030      	movs	r0, r6
 8004030:	68ad      	ldr	r5, [r5, #8]
 8004032:	69ed      	ldr	r5, [r5, #28]
 8004034:	47a8      	blx	r5
 8004036:	203c      	movs	r0, #60	; 0x3c
 8004038:	e038      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 800403a:	68a9      	ldr	r1, [r5, #8]
 800403c:	694f      	ldr	r7, [r1, #20]
 800403e:	2f00      	cmp	r7, #0
 8004040:	d036      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004042:	8823      	ldrh	r3, [r4, #0]
 8004044:	002a      	movs	r2, r5
 8004046:	3236      	adds	r2, #54	; 0x36
 8004048:	7881      	ldrb	r1, [r0, #2]
 800404a:	68e8      	ldr	r0, [r5, #12]
 800404c:	4006      	ands	r6, r0
 800404e:	0030      	movs	r0, r6
 8004050:	47b8      	blx	r7
 8004052:	2038      	movs	r0, #56	; 0x38
 8004054:	e02a      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8004056:	6829      	ldr	r1, [r5, #0]
 8004058:	88c9      	ldrh	r1, [r1, #6]
 800405a:	0ac9      	lsrs	r1, r1, #11
 800405c:	4231      	tst	r1, r6
 800405e:	d027      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004060:	68a9      	ldr	r1, [r5, #8]
 8004062:	6949      	ldr	r1, [r1, #20]
 8004064:	2900      	cmp	r1, #0
 8004066:	d116      	bne.n	8004096 <PE_Check_ExtendedMessage+0x17e>
 8004068:	e022      	b.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 800406a:	68a9      	ldr	r1, [r5, #8]
 800406c:	694f      	ldr	r7, [r1, #20]
 800406e:	2f00      	cmp	r7, #0
 8004070:	d01f      	beq.n	80040b2 <PE_Check_ExtendedMessage+0x19a>
 8004072:	8823      	ldrh	r3, [r4, #0]
 8004074:	002a      	movs	r2, r5
 8004076:	3236      	adds	r2, #54	; 0x36
 8004078:	7881      	ldrb	r1, [r0, #2]
 800407a:	68e8      	ldr	r0, [r5, #12]
 800407c:	4006      	ands	r6, r0
 800407e:	0030      	movs	r0, r6
 8004080:	47b8      	blx	r7
 8004082:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
 8004084:	6829      	ldr	r1, [r5, #0]
 8004086:	88c9      	ldrh	r1, [r1, #6]
 8004088:	0a89      	lsrs	r1, r1, #10
 800408a:	4231      	tst	r1, r6
 800408c:	d010      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 800408e:	68a9      	ldr	r1, [r5, #8]
 8004090:	6949      	ldr	r1, [r1, #20]
 8004092:	2900      	cmp	r1, #0
 8004094:	d00c      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004096:	8823      	ldrh	r3, [r4, #0]
 8004098:	002a      	movs	r2, r5
 800409a:	3236      	adds	r2, #54	; 0x36
 800409c:	7881      	ldrb	r1, [r0, #2]
 800409e:	68e8      	ldr	r0, [r5, #12]
 80040a0:	4006      	ands	r6, r0
 80040a2:	0030      	movs	r0, r6
 80040a4:	68ad      	ldr	r5, [r5, #8]
 80040a6:	696d      	ldr	r5, [r5, #20]
 80040a8:	47a8      	blx	r5
 80040aa:	20a5      	movs	r0, #165	; 0xa5
 80040ac:	73a0      	strb	r0, [r4, #14]
 80040ae:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
 80040b0:	73a6      	strb	r6, [r4, #14]
 80040b2:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
 80040b4:	20e4      	movs	r0, #228	; 0xe4
 80040b6:	0080      	lsls	r0, r0, #2
 80040b8:	1828      	adds	r0, r5, r0
 80040ba:	219f      	movs	r1, #159	; 0x9f
 80040bc:	0049      	lsls	r1, r1, #1
 80040be:	186a      	adds	r2, r5, r1
 80040c0:	7881      	ldrb	r1, [r0, #2]
 80040c2:	3981      	subs	r1, #129	; 0x81
 80040c4:	d018      	beq.n	80040f8 <PE_Check_ExtendedMessage+0x1e0>
 80040c6:	1e49      	subs	r1, r1, #1
 80040c8:	d100      	bne.n	80040cc <PE_Check_ExtendedMessage+0x1b4>
 80040ca:	e76f      	b.n	8003fac <PE_Check_ExtendedMessage+0x94>
 80040cc:	1e49      	subs	r1, r1, #1
 80040ce:	d087      	beq.n	8003fe0 <PE_Check_ExtendedMessage+0xc8>
 80040d0:	1e49      	subs	r1, r1, #1
 80040d2:	d094      	beq.n	8003ffe <PE_Check_ExtendedMessage+0xe6>
 80040d4:	1e49      	subs	r1, r1, #1
 80040d6:	d0b0      	beq.n	800403a <PE_Check_ExtendedMessage+0x122>
 80040d8:	1e49      	subs	r1, r1, #1
 80040da:	d09f      	beq.n	800401c <PE_Check_ExtendedMessage+0x104>
 80040dc:	1e49      	subs	r1, r1, #1
 80040de:	d0ac      	beq.n	800403a <PE_Check_ExtendedMessage+0x122>
 80040e0:	1e49      	subs	r1, r1, #1
 80040e2:	d0cf      	beq.n	8004084 <PE_Check_ExtendedMessage+0x16c>
 80040e4:	1e49      	subs	r1, r1, #1
 80040e6:	d0e4      	beq.n	80040b2 <PE_Check_ExtendedMessage+0x19a>
 80040e8:	1e49      	subs	r1, r1, #1
 80040ea:	d0b4      	beq.n	8004056 <PE_Check_ExtendedMessage+0x13e>
 80040ec:	1e49      	subs	r1, r1, #1
 80040ee:	d0bc      	beq.n	800406a <PE_Check_ExtendedMessage+0x152>
 80040f0:	1e89      	subs	r1, r1, #2
 80040f2:	2901      	cmp	r1, #1
 80040f4:	d9a1      	bls.n	800403a <PE_Check_ExtendedMessage+0x122>
 80040f6:	e7db      	b.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 80040f8:	2318      	movs	r3, #24
 80040fa:	2108      	movs	r1, #8
 80040fc:	68ef      	ldr	r7, [r5, #12]
 80040fe:	2001      	movs	r0, #1
 8004100:	4038      	ands	r0, r7
 8004102:	68af      	ldr	r7, [r5, #8]
 8004104:	69ff      	ldr	r7, [r7, #28]
 8004106:	47b8      	blx	r7
 8004108:	2003      	movs	r0, #3
 800410a:	73a0      	strb	r0, [r4, #14]
 800410c:	4c77      	ldr	r4, [pc, #476]	; (80042ec <.text_61>)
 800410e:	7820      	ldrb	r0, [r4, #0]
 8004110:	0780      	lsls	r0, r0, #30
 8004112:	d509      	bpl.n	8004128 <PE_Check_ExtendedMessage+0x210>
 8004114:	2000      	movs	r0, #0
 8004116:	9000      	str	r0, [sp, #0]
 8004118:	2300      	movs	r3, #0
 800411a:	2244      	movs	r2, #68	; 0x44
 800411c:	68e8      	ldr	r0, [r5, #12]
 800411e:	2101      	movs	r1, #1
 8004120:	4001      	ands	r1, r0
 8004122:	2009      	movs	r0, #9
 8004124:	68e4      	ldr	r4, [r4, #12]
 8004126:	47a0      	blx	r4
 8004128:	2144      	movs	r1, #68	; 0x44
 800412a:	68e8      	ldr	r0, [r5, #12]
 800412c:	4006      	ands	r6, r0
 800412e:	0030      	movs	r0, r6
 8004130:	68aa      	ldr	r2, [r5, #8]
 8004132:	68d2      	ldr	r2, [r2, #12]
 8004134:	4790      	blx	r2
 8004136:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}

08004138 <PE_PRL_HardResetReceived>:
 8004138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800413a:	0007      	movs	r7, r0
 800413c:	48cf      	ldr	r0, [pc, #828]	; (800447c <.text_65>)
 800413e:	00b9      	lsls	r1, r7, #2
 8004140:	5844      	ldr	r4, [r0, r1]
 8004142:	48d7      	ldr	r0, [pc, #860]	; (80044a0 <.text_67>)
 8004144:	1825      	adds	r5, r4, r0
 8004146:	2600      	movs	r6, #0
 8004148:	702e      	strb	r6, [r5, #0]
 800414a:	0038      	movs	r0, r7
 800414c:	f001 f982 	bl	8005454 <USBPD_PRL_Reset>
 8004150:	6860      	ldr	r0, [r4, #4]
 8004152:	2101      	movs	r1, #1
 8004154:	7802      	ldrb	r2, [r0, #0]
 8004156:	0892      	lsrs	r2, r2, #2
 8004158:	420a      	tst	r2, r1
 800415a:	d001      	beq.n	8004160 <PE_PRL_HardResetReceived+0x28>
 800415c:	2014      	movs	r0, #20
 800415e:	e005      	b.n	800416c <PE_PRL_HardResetReceived+0x34>
 8004160:	6802      	ldr	r2, [r0, #0]
 8004162:	2310      	movs	r3, #16
 8004164:	4313      	orrs	r3, r2
 8004166:	6003      	str	r3, [r0, #0]
 8004168:	842e      	strh	r6, [r5, #32]
 800416a:	203f      	movs	r0, #63	; 0x3f
 800416c:	70a8      	strb	r0, [r5, #2]
 800416e:	7b60      	ldrb	r0, [r4, #13]
 8004170:	22fc      	movs	r2, #252	; 0xfc
 8004172:	4002      	ands	r2, r0
 8004174:	4311      	orrs	r1, r2
 8004176:	7361      	strb	r1, [r4, #13]
 8004178:	0038      	movs	r0, r7
 800417a:	68a1      	ldr	r1, [r4, #8]
 800417c:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800417e:	4788      	blx	r1
 8004180:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
	...

08004184 <.text_57>:
 8004184:	00001388 	.word	0x00001388

08004188 <.text_58>:
 8004188:	0000034a 	.word	0x0000034a

0800418c <PE_PRL_BistCompleted>:
 800418c:	4770      	bx	lr

0800418e <PE_Reset>:
 800418e:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 8004190:	b084      	sub	sp, #16
 8004192:	000e      	movs	r6, r1
 8004194:	48c8      	ldr	r0, [pc, #800]	; (80044b8 <.text_69>)
 8004196:	1d01      	adds	r1, r0, #4
 8004198:	466a      	mov	r2, sp
 800419a:	7c12      	ldrb	r2, [r2, #16]
 800419c:	0092      	lsls	r2, r2, #2
 800419e:	588c      	ldr	r4, [r1, r2]
 80041a0:	2500      	movs	r5, #0
 80041a2:	9502      	str	r5, [sp, #8]
 80041a4:	68e1      	ldr	r1, [r4, #12]
 80041a6:	2203      	movs	r2, #3
 80041a8:	4391      	bics	r1, r2
 80041aa:	466a      	mov	r2, sp
 80041ac:	7c12      	ldrb	r2, [r2, #16]
 80041ae:	07d3      	lsls	r3, r2, #31
 80041b0:	0fdb      	lsrs	r3, r3, #31
 80041b2:	430b      	orrs	r3, r1
 80041b4:	60e3      	str	r3, [r4, #12]
 80041b6:	6861      	ldr	r1, [r4, #4]
 80041b8:	680a      	ldr	r2, [r1, #0]
 80041ba:	2310      	movs	r3, #16
 80041bc:	439a      	bics	r2, r3
 80041be:	600a      	str	r2, [r1, #0]
 80041c0:	6861      	ldr	r1, [r4, #4]
 80041c2:	784a      	ldrb	r2, [r1, #1]
 80041c4:	238f      	movs	r3, #143	; 0x8f
 80041c6:	4013      	ands	r3, r2
 80041c8:	704b      	strb	r3, [r1, #1]
 80041ca:	7800      	ldrb	r0, [r0, #0]
 80041cc:	0780      	lsls	r0, r0, #30
 80041ce:	d509      	bpl.n	80041e4 <PE_Reset+0x56>
 80041d0:	9500      	str	r5, [sp, #0]
 80041d2:	2300      	movs	r3, #0
 80041d4:	2256      	movs	r2, #86	; 0x56
 80041d6:	7b20      	ldrb	r0, [r4, #12]
 80041d8:	07c1      	lsls	r1, r0, #31
 80041da:	0fc9      	lsrs	r1, r1, #31
 80041dc:	2009      	movs	r0, #9
 80041de:	4fb6      	ldr	r7, [pc, #728]	; (80044b8 <.text_69>)
 80041e0:	68ff      	ldr	r7, [r7, #12]
 80041e2:	47b8      	blx	r7
 80041e4:	4668      	mov	r0, sp
 80041e6:	7006      	strb	r6, [r0, #0]
 80041e8:	2156      	movs	r1, #86	; 0x56
 80041ea:	7b22      	ldrb	r2, [r4, #12]
 80041ec:	07d0      	lsls	r0, r2, #31
 80041ee:	0fc0      	lsrs	r0, r0, #31
 80041f0:	68a2      	ldr	r2, [r4, #8]
 80041f2:	68d2      	ldr	r2, [r2, #12]
 80041f4:	4790      	blx	r2
 80041f6:	48b1      	ldr	r0, [pc, #708]	; (80044bc <.text_70>)
 80041f8:	1826      	adds	r6, r4, r0
 80041fa:	82b5      	strh	r5, [r6, #20]
 80041fc:	82e5      	strh	r5, [r4, #22]
 80041fe:	72b5      	strb	r5, [r6, #10]
 8004200:	4668      	mov	r0, sp
 8004202:	7800      	ldrb	r0, [r0, #0]
 8004204:	2800      	cmp	r0, #0
 8004206:	d100      	bne.n	800420a <PE_Reset+0x7c>
 8004208:	7525      	strb	r5, [r4, #20]
 800420a:	7335      	strb	r5, [r6, #12]
 800420c:	7475      	strb	r5, [r6, #17]
 800420e:	72f5      	strb	r5, [r6, #11]
 8004210:	6860      	ldr	r0, [r4, #4]
 8004212:	7800      	ldrb	r0, [r0, #0]
 8004214:	0880      	lsrs	r0, r0, #2
 8004216:	07c0      	lsls	r0, r0, #31
 8004218:	d51d      	bpl.n	8004256 <PE_Reset+0xc8>
 800421a:	6820      	ldr	r0, [r4, #0]
 800421c:	7900      	ldrb	r0, [r0, #4]
 800421e:	0783      	lsls	r3, r0, #30
 8004220:	0f9b      	lsrs	r3, r3, #30
 8004222:	2201      	movs	r2, #1
 8004224:	2101      	movs	r1, #1
 8004226:	4668      	mov	r0, sp
 8004228:	7c00      	ldrb	r0, [r0, #16]
 800422a:	f000 fe5d 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800422e:	6860      	ldr	r0, [r4, #4]
 8004230:	7801      	ldrb	r1, [r0, #0]
 8004232:	2208      	movs	r2, #8
 8004234:	430a      	orrs	r2, r1
 8004236:	7002      	strb	r2, [r0, #0]
 8004238:	2002      	movs	r0, #2
 800423a:	73b0      	strb	r0, [r6, #14]
 800423c:	2304      	movs	r3, #4
 800423e:	aa02      	add	r2, sp, #8
 8004240:	2102      	movs	r1, #2
 8004242:	4668      	mov	r0, sp
 8004244:	7c00      	ldrb	r0, [r0, #16]
 8004246:	68a7      	ldr	r7, [r4, #8]
 8004248:	69ff      	ldr	r7, [r7, #28]
 800424a:	47b8      	blx	r7
 800424c:	6860      	ldr	r0, [r4, #4]
 800424e:	7800      	ldrb	r0, [r0, #0]
 8004250:	0880      	lsrs	r0, r0, #2
 8004252:	07c0      	lsls	r0, r0, #31
 8004254:	d428      	bmi.n	80042a8 <PE_Reset+0x11a>
 8004256:	6820      	ldr	r0, [r4, #0]
 8004258:	7900      	ldrb	r0, [r0, #4]
 800425a:	0783      	lsls	r3, r0, #30
 800425c:	0f9b      	lsrs	r3, r3, #30
 800425e:	2200      	movs	r2, #0
 8004260:	2100      	movs	r1, #0
 8004262:	4668      	mov	r0, sp
 8004264:	7c00      	ldrb	r0, [r0, #16]
 8004266:	f000 fe3f 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800426a:	6860      	ldr	r0, [r4, #4]
 800426c:	7801      	ldrb	r1, [r0, #0]
 800426e:	22f7      	movs	r2, #247	; 0xf7
 8004270:	400a      	ands	r2, r1
 8004272:	7002      	strb	r2, [r0, #0]
 8004274:	4668      	mov	r0, sp
 8004276:	7800      	ldrb	r0, [r0, #0]
 8004278:	2800      	cmp	r0, #0
 800427a:	d101      	bne.n	8004280 <PE_Reset+0xf2>
 800427c:	203e      	movs	r0, #62	; 0x3e
 800427e:	73b0      	strb	r0, [r6, #14]
 8004280:	7375      	strb	r5, [r6, #13]
 8004282:	2080      	movs	r0, #128	; 0x80
 8004284:	0440      	lsls	r0, r0, #17
 8004286:	9001      	str	r0, [sp, #4]
 8004288:	2304      	movs	r3, #4
 800428a:	aa01      	add	r2, sp, #4
 800428c:	2107      	movs	r1, #7
 800428e:	4668      	mov	r0, sp
 8004290:	7c00      	ldrb	r0, [r0, #16]
 8004292:	68a7      	ldr	r7, [r4, #8]
 8004294:	69ff      	ldr	r7, [r7, #28]
 8004296:	47b8      	blx	r7
 8004298:	2304      	movs	r3, #4
 800429a:	aa02      	add	r2, sp, #8
 800429c:	2102      	movs	r1, #2
 800429e:	4668      	mov	r0, sp
 80042a0:	7c00      	ldrb	r0, [r0, #16]
 80042a2:	68a7      	ldr	r7, [r4, #8]
 80042a4:	69ff      	ldr	r7, [r7, #28]
 80042a6:	47b8      	blx	r7
 80042a8:	8035      	strh	r5, [r6, #0]
 80042aa:	8075      	strh	r5, [r6, #2]
 80042ac:	2124      	movs	r1, #36	; 0x24
 80042ae:	20d8      	movs	r0, #216	; 0xd8
 80042b0:	0080      	lsls	r0, r0, #2
 80042b2:	1820      	adds	r0, r4, r0
 80042b4:	f008 fbc0 	bl	800ca38 <__aeabi_memclr>
 80042b8:	487f      	ldr	r0, [pc, #508]	; (80044b8 <.text_69>)
 80042ba:	68c5      	ldr	r5, [r0, #12]
 80042bc:	2d00      	cmp	r5, #0
 80042be:	d00f      	beq.n	80042e0 <PE_Reset+0x152>
 80042c0:	7800      	ldrb	r0, [r0, #0]
 80042c2:	07c0      	lsls	r0, r0, #31
 80042c4:	d50c      	bpl.n	80042e0 <PE_Reset+0x152>
 80042c6:	7bb2      	ldrb	r2, [r6, #14]
 80042c8:	7bf0      	ldrb	r0, [r6, #15]
 80042ca:	4290      	cmp	r0, r2
 80042cc:	d008      	beq.n	80042e0 <PE_Reset+0x152>
 80042ce:	73f2      	strb	r2, [r6, #15]
 80042d0:	2000      	movs	r0, #0
 80042d2:	9000      	str	r0, [sp, #0]
 80042d4:	2300      	movs	r3, #0
 80042d6:	7b20      	ldrb	r0, [r4, #12]
 80042d8:	07c1      	lsls	r1, r0, #31
 80042da:	0fc9      	lsrs	r1, r1, #31
 80042dc:	2004      	movs	r0, #4
 80042de:	47a8      	blx	r5
 80042e0:	4668      	mov	r0, sp
 80042e2:	7c00      	ldrb	r0, [r0, #16]
 80042e4:	f001 f8b6 	bl	8005454 <USBPD_PRL_Reset>
 80042e8:	b005      	add	sp, #20
 80042ea:	bdf0      	pop	{r4, r5, r6, r7, pc}

080042ec <.text_61>:
 80042ec:	200019a8 	.word	0x200019a8

080042f0 <PE_ResetDuringSwap>:
 80042f0:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 80042f2:	0004      	movs	r4, r0
 80042f4:	2700      	movs	r7, #0
 80042f6:	9701      	str	r7, [sp, #4]
 80042f8:	6860      	ldr	r0, [r4, #4]
 80042fa:	7841      	ldrb	r1, [r0, #1]
 80042fc:	228f      	movs	r2, #143	; 0x8f
 80042fe:	400a      	ands	r2, r1
 8004300:	2110      	movs	r1, #16
 8004302:	4311      	orrs	r1, r2
 8004304:	7041      	strb	r1, [r0, #1]
 8004306:	4d6c      	ldr	r5, [pc, #432]	; (80044b8 <.text_69>)
 8004308:	2601      	movs	r6, #1
 800430a:	7828      	ldrb	r0, [r5, #0]
 800430c:	0780      	lsls	r0, r0, #30
 800430e:	d508      	bpl.n	8004322 <PE_ResetDuringSwap+0x32>
 8004310:	9700      	str	r7, [sp, #0]
 8004312:	2300      	movs	r3, #0
 8004314:	2256      	movs	r2, #86	; 0x56
 8004316:	68e0      	ldr	r0, [r4, #12]
 8004318:	2101      	movs	r1, #1
 800431a:	4001      	ands	r1, r0
 800431c:	2009      	movs	r0, #9
 800431e:	68ed      	ldr	r5, [r5, #12]
 8004320:	47a8      	blx	r5
 8004322:	2156      	movs	r1, #86	; 0x56
 8004324:	68e2      	ldr	r2, [r4, #12]
 8004326:	2001      	movs	r0, #1
 8004328:	4010      	ands	r0, r2
 800432a:	68a2      	ldr	r2, [r4, #8]
 800432c:	68d2      	ldr	r2, [r2, #12]
 800432e:	4790      	blx	r2
 8004330:	4863      	ldr	r0, [pc, #396]	; (80044c0 <.text_71>)
 8004332:	1825      	adds	r5, r4, r0
 8004334:	702f      	strb	r7, [r5, #0]
 8004336:	712f      	strb	r7, [r5, #4]
 8004338:	68e1      	ldr	r1, [r4, #12]
 800433a:	2001      	movs	r0, #1
 800433c:	4008      	ands	r0, r1
 800433e:	6861      	ldr	r1, [r4, #4]
 8004340:	7809      	ldrb	r1, [r1, #0]
 8004342:	0889      	lsrs	r1, r1, #2
 8004344:	4231      	tst	r1, r6
 8004346:	d014      	beq.n	8004372 <PE_ResetDuringSwap+0x82>
 8004348:	f7ff fb14 	bl	8003974 <PE_Get_DataRole>
 800434c:	6861      	ldr	r1, [r4, #4]
 800434e:	7809      	ldrb	r1, [r1, #0]
 8004350:	2303      	movs	r3, #3
 8004352:	400b      	ands	r3, r1
 8004354:	0002      	movs	r2, r0
 8004356:	2101      	movs	r1, #1
 8004358:	68e7      	ldr	r7, [r4, #12]
 800435a:	2001      	movs	r0, #1
 800435c:	4038      	ands	r0, r7
 800435e:	f000 fdc3 	bl	8004ee8 <USBPD_PRL_SetHeader>
 8004362:	2002      	movs	r0, #2
 8004364:	7068      	strb	r0, [r5, #1]
 8004366:	6860      	ldr	r0, [r4, #4]
 8004368:	6801      	ldr	r1, [r0, #0]
 800436a:	2210      	movs	r2, #16
 800436c:	4391      	bics	r1, r2
 800436e:	6001      	str	r1, [r0, #0]
 8004370:	e019      	b.n	80043a6 <PE_ResetDuringSwap+0xb6>
 8004372:	f7ff faff 	bl	8003974 <PE_Get_DataRole>
 8004376:	6861      	ldr	r1, [r4, #4]
 8004378:	7809      	ldrb	r1, [r1, #0]
 800437a:	2303      	movs	r3, #3
 800437c:	400b      	ands	r3, r1
 800437e:	0002      	movs	r2, r0
 8004380:	2100      	movs	r1, #0
 8004382:	68e7      	ldr	r7, [r4, #12]
 8004384:	2001      	movs	r0, #1
 8004386:	4038      	ands	r0, r7
 8004388:	f000 fdae 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800438c:	203e      	movs	r0, #62	; 0x3e
 800438e:	7068      	strb	r0, [r5, #1]
 8004390:	0630      	lsls	r0, r6, #24
 8004392:	9000      	str	r0, [sp, #0]
 8004394:	2304      	movs	r3, #4
 8004396:	466a      	mov	r2, sp
 8004398:	2107      	movs	r1, #7
 800439a:	68e5      	ldr	r5, [r4, #12]
 800439c:	2001      	movs	r0, #1
 800439e:	4028      	ands	r0, r5
 80043a0:	68a5      	ldr	r5, [r4, #8]
 80043a2:	69ed      	ldr	r5, [r5, #28]
 80043a4:	47a8      	blx	r5
 80043a6:	2304      	movs	r3, #4
 80043a8:	aa01      	add	r2, sp, #4
 80043aa:	2102      	movs	r1, #2
 80043ac:	68e5      	ldr	r5, [r4, #12]
 80043ae:	2001      	movs	r0, #1
 80043b0:	4028      	ands	r0, r5
 80043b2:	68a5      	ldr	r5, [r4, #8]
 80043b4:	69ed      	ldr	r5, [r5, #28]
 80043b6:	47a8      	blx	r5
 80043b8:	2124      	movs	r1, #36	; 0x24
 80043ba:	20d8      	movs	r0, #216	; 0xd8
 80043bc:	0080      	lsls	r0, r0, #2
 80043be:	1820      	adds	r0, r4, r0
 80043c0:	f008 fb3a 	bl	800ca38 <__aeabi_memclr>
 80043c4:	68e0      	ldr	r0, [r4, #12]
 80043c6:	4006      	ands	r6, r0
 80043c8:	0030      	movs	r0, r6
 80043ca:	f001 f843 	bl	8005454 <USBPD_PRL_Reset>
 80043ce:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

080043d0 <PE_ExtRevisionInteroperability>:
 80043d0:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 80043d2:	000a      	movs	r2, r1
 80043d4:	4c38      	ldr	r4, [pc, #224]	; (80044b8 <.text_69>)
 80043d6:	0081      	lsls	r1, r0, #2
 80043d8:	1861      	adds	r1, r4, r1
 80043da:	9101      	str	r1, [sp, #4]
 80043dc:	684e      	ldr	r6, [r1, #4]
 80043de:	2103      	movs	r1, #3
 80043e0:	6873      	ldr	r3, [r6, #4]
 80043e2:	781b      	ldrb	r3, [r3, #0]
 80043e4:	400b      	ands	r3, r1
 80043e6:	4293      	cmp	r3, r2
 80043e8:	d03a      	beq.n	8004460 <PE_ExtRevisionInteroperability+0x90>
 80043ea:	6873      	ldr	r3, [r6, #4]
 80043ec:	781b      	ldrb	r3, [r3, #0]
 80043ee:	079b      	lsls	r3, r3, #30
 80043f0:	0f9b      	lsrs	r3, r3, #30
 80043f2:	429a      	cmp	r2, r3
 80043f4:	d300      	bcc.n	80043f8 <PE_ExtRevisionInteroperability+0x28>
 80043f6:	001a      	movs	r2, r3
 80043f8:	6873      	ldr	r3, [r6, #4]
 80043fa:	781d      	ldrb	r5, [r3, #0]
 80043fc:	27fc      	movs	r7, #252	; 0xfc
 80043fe:	402f      	ands	r7, r5
 8004400:	400a      	ands	r2, r1
 8004402:	433a      	orrs	r2, r7
 8004404:	701a      	strb	r2, [r3, #0]
 8004406:	6872      	ldr	r2, [r6, #4]
 8004408:	7812      	ldrb	r2, [r2, #0]
 800440a:	2501      	movs	r5, #1
 800440c:	2303      	movs	r3, #3
 800440e:	4013      	ands	r3, r2
 8004410:	2b01      	cmp	r3, #1
 8004412:	d101      	bne.n	8004418 <PE_ExtRevisionInteroperability+0x48>
 8004414:	2700      	movs	r7, #0
 8004416:	e000      	b.n	800441a <PE_ExtRevisionInteroperability+0x4a>
 8004418:	2701      	movs	r7, #1
 800441a:	239f      	movs	r3, #159	; 0x9f
 800441c:	4013      	ands	r3, r2
 800441e:	017a      	lsls	r2, r7, #5
 8004420:	431a      	orrs	r2, r3
 8004422:	6873      	ldr	r3, [r6, #4]
 8004424:	701a      	strb	r2, [r3, #0]
 8004426:	6872      	ldr	r2, [r6, #4]
 8004428:	7812      	ldrb	r2, [r2, #0]
 800442a:	4011      	ands	r1, r2
 800442c:	f000 fd91 	bl	8004f52 <USBPD_PRL_SetHeaderSpecification>
 8004430:	7820      	ldrb	r0, [r4, #0]
 8004432:	0780      	lsls	r0, r0, #30
 8004434:	d50b      	bpl.n	800444e <PE_ExtRevisionInteroperability+0x7e>
 8004436:	2000      	movs	r0, #0
 8004438:	9000      	str	r0, [sp, #0]
 800443a:	2300      	movs	r3, #0
 800443c:	2236      	movs	r2, #54	; 0x36
 800443e:	9801      	ldr	r0, [sp, #4]
 8004440:	6840      	ldr	r0, [r0, #4]
 8004442:	68c0      	ldr	r0, [r0, #12]
 8004444:	2101      	movs	r1, #1
 8004446:	4001      	ands	r1, r0
 8004448:	2009      	movs	r0, #9
 800444a:	68e4      	ldr	r4, [r4, #12]
 800444c:	47a0      	blx	r4
 800444e:	9801      	ldr	r0, [sp, #4]
 8004450:	6842      	ldr	r2, [r0, #4]
 8004452:	2136      	movs	r1, #54	; 0x36
 8004454:	68d0      	ldr	r0, [r2, #12]
 8004456:	4005      	ands	r5, r0
 8004458:	0028      	movs	r0, r5
 800445a:	6892      	ldr	r2, [r2, #8]
 800445c:	68d2      	ldr	r2, [r2, #12]
 800445e:	4790      	blx	r2
 8004460:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

08004462 <PE_PRL_PostReceiveEvent>:
 8004462:	4b15      	ldr	r3, [pc, #84]	; (80044b8 <.text_69>)
 8004464:	0080      	lsls	r0, r0, #2
 8004466:	1818      	adds	r0, r3, r0
 8004468:	6840      	ldr	r0, [r0, #4]
 800446a:	4b0d      	ldr	r3, [pc, #52]	; (80044a0 <.text_67>)
 800446c:	18c0      	adds	r0, r0, r3
 800446e:	2301      	movs	r3, #1
 8004470:	408b      	lsls	r3, r1
 8004472:	7003      	strb	r3, [r0, #0]
 8004474:	8811      	ldrh	r1, [r2, #0]
 8004476:	85c1      	strh	r1, [r0, #46]	; 0x2e
 8004478:	4770      	bx	lr
	...

0800447c <.text_65>:
 800447c:	200019ac 	.word	0x200019ac

08004480 <PE_PRL_PostReceiveEventComplete>:
 8004480:	b510      	push	{r4, lr}
 8004482:	490d      	ldr	r1, [pc, #52]	; (80044b8 <.text_69>)
 8004484:	0082      	lsls	r2, r0, #2
 8004486:	1889      	adds	r1, r1, r2
 8004488:	6849      	ldr	r1, [r1, #4]
 800448a:	4a05      	ldr	r2, [pc, #20]	; (80044a0 <.text_67>)
 800448c:	188a      	adds	r2, r1, r2
 800448e:	7813      	ldrb	r3, [r2, #0]
 8004490:	2420      	movs	r4, #32
 8004492:	431c      	orrs	r4, r3
 8004494:	7014      	strb	r4, [r2, #0]
 8004496:	6889      	ldr	r1, [r1, #8]
 8004498:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800449a:	4788      	blx	r1
 800449c:	bd10      	pop	{r4, pc}
	...

080044a0 <.text_67>:
 80044a0:	00000356 	.word	0x00000356

080044a4 <PE_Get_UnchunkedSupport>:
 80044a4:	4904      	ldr	r1, [pc, #16]	; (80044b8 <.text_69>)
 80044a6:	0080      	lsls	r0, r0, #2
 80044a8:	1808      	adds	r0, r1, r0
 80044aa:	6840      	ldr	r0, [r0, #4]
 80044ac:	6840      	ldr	r0, [r0, #4]
 80044ae:	6800      	ldr	r0, [r0, #0]
 80044b0:	0301      	lsls	r1, r0, #12
 80044b2:	0fc8      	lsrs	r0, r1, #31
 80044b4:	4770      	bx	lr
	...

080044b8 <.text_69>:
 80044b8:	200019a8 	.word	0x200019a8

080044bc <.text_70>:
 80044bc:	0000034a 	.word	0x0000034a

080044c0 <.text_71>:
 80044c0:	00000357 	.word	0x00000357

080044c4 <PE_Send_ExtendedMessage>:
 80044c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80044c6:	b085      	sub	sp, #20
 80044c8:	6844      	ldr	r4, [r0, #4]
 80044ca:	25d6      	movs	r5, #214	; 0xd6
 80044cc:	00ad      	lsls	r5, r5, #2
 80044ce:	1945      	adds	r5, r0, r5
 80044d0:	9503      	str	r5, [sp, #12]
 80044d2:	2511      	movs	r5, #17
 80044d4:	7866      	ldrb	r6, [r4, #1]
 80044d6:	0676      	lsls	r6, r6, #25
 80044d8:	0f76      	lsrs	r6, r6, #29
 80044da:	2e03      	cmp	r6, #3
 80044dc:	d129      	bne.n	8004532 <PE_Send_ExtendedMessage+0x6e>
 80044de:	7824      	ldrb	r4, [r4, #0]
 80044e0:	07a4      	lsls	r4, r4, #30
 80044e2:	0fa4      	lsrs	r4, r4, #30
 80044e4:	2c01      	cmp	r4, #1
 80044e6:	dd24      	ble.n	8004532 <PE_Send_ExtendedMessage+0x6e>
 80044e8:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 80044ea:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80044ec:	9304      	str	r3, [sp, #16]
 80044ee:	23ff      	movs	r3, #255	; 0xff
 80044f0:	330a      	adds	r3, #10
 80044f2:	429f      	cmp	r7, r3
 80044f4:	d21d      	bcs.n	8004532 <PE_Send_ExtendedMessage+0x6e>
 80044f6:	0006      	movs	r6, r0
 80044f8:	4668      	mov	r0, sp
 80044fa:	7241      	strb	r1, [r0, #9]
 80044fc:	7202      	strb	r2, [r0, #8]
 80044fe:	970a      	str	r7, [sp, #40]	; 0x28
 8004500:	a80c      	add	r0, sp, #48	; 0x30
 8004502:	7004      	strb	r4, [r0, #0]
 8004504:	2401      	movs	r4, #1
 8004506:	a80c      	add	r0, sp, #48	; 0x30
 8004508:	7800      	ldrb	r0, [r0, #0]
 800450a:	9001      	str	r0, [sp, #4]
 800450c:	980a      	ldr	r0, [sp, #40]	; 0x28
 800450e:	b280      	uxth	r0, r0
 8004510:	9000      	str	r0, [sp, #0]
 8004512:	9b04      	ldr	r3, [sp, #16]
 8004514:	4668      	mov	r0, sp
 8004516:	7a02      	ldrb	r2, [r0, #8]
 8004518:	7a41      	ldrb	r1, [r0, #9]
 800451a:	68f7      	ldr	r7, [r6, #12]
 800451c:	2001      	movs	r0, #1
 800451e:	4038      	ands	r0, r7
 8004520:	f000 fd50 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8004524:	2803      	cmp	r0, #3
 8004526:	d117      	bne.n	8004558 <PE_Send_ExtendedMessage+0x94>
 8004528:	6870      	ldr	r0, [r6, #4]
 800452a:	6800      	ldr	r0, [r0, #0]
 800452c:	0ac0      	lsrs	r0, r0, #11
 800452e:	4004      	ands	r4, r0
 8004530:	d1e8      	bne.n	8004504 <PE_Send_ExtendedMessage+0x40>
 8004532:	9803      	ldr	r0, [sp, #12]
 8004534:	7005      	strb	r5, [r0, #0]
 8004536:	2010      	movs	r0, #16
 8004538:	e00c      	b.n	8004554 <PE_Send_ExtendedMessage+0x90>
 800453a:	6870      	ldr	r0, [r6, #4]
 800453c:	7840      	ldrb	r0, [r0, #1]
 800453e:	0640      	lsls	r0, r0, #25
 8004540:	0f40      	lsrs	r0, r0, #29
 8004542:	2804      	cmp	r0, #4
 8004544:	d103      	bne.n	800454e <PE_Send_ExtendedMessage+0x8a>
 8004546:	200f      	movs	r0, #15
 8004548:	9903      	ldr	r1, [sp, #12]
 800454a:	7008      	strb	r0, [r1, #0]
 800454c:	e001      	b.n	8004552 <PE_Send_ExtendedMessage+0x8e>
 800454e:	9803      	ldr	r0, [sp, #12]
 8004550:	7005      	strb	r5, [r0, #0]
 8004552:	2000      	movs	r0, #0
 8004554:	b005      	add	sp, #20
 8004556:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004558:	2805      	cmp	r0, #5
 800455a:	d004      	beq.n	8004566 <PE_Send_ExtendedMessage+0xa2>
 800455c:	2807      	cmp	r0, #7
 800455e:	d0ec      	beq.n	800453a <PE_Send_ExtendedMessage+0x76>
 8004560:	2809      	cmp	r0, #9
 8004562:	d0f7      	beq.n	8004554 <PE_Send_ExtendedMessage+0x90>
 8004564:	e7f5      	b.n	8004552 <PE_Send_ExtendedMessage+0x8e>
 8004566:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8004568:	e7ee      	b.n	8004548 <PE_Send_ExtendedMessage+0x84>

0800456a <PE_SubStateMachine_ExtendedMessages>:
 800456a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800456c:	b084      	sub	sp, #16
 800456e:	0005      	movs	r5, r0
 8004570:	2702      	movs	r7, #2
 8004572:	4886      	ldr	r0, [pc, #536]	; (800478c <.text_74>)
 8004574:	1828      	adds	r0, r5, r0
 8004576:	9002      	str	r0, [sp, #8]
 8004578:	4885      	ldr	r0, [pc, #532]	; (8004790 <.text_75>)
 800457a:	182c      	adds	r4, r5, r0
 800457c:	4985      	ldr	r1, [pc, #532]	; (8004794 <.text_76>)
 800457e:	2600      	movs	r6, #0
 8004580:	2003      	movs	r0, #3
 8004582:	7ba2      	ldrb	r2, [r4, #14]
 8004584:	2a31      	cmp	r2, #49	; 0x31
 8004586:	d016      	beq.n	80045b6 <PE_SubStateMachine_ExtendedMessages+0x4c>
 8004588:	2a32      	cmp	r2, #50	; 0x32
 800458a:	d049      	beq.n	8004620 <PE_SubStateMachine_ExtendedMessages+0xb6>
 800458c:	2a33      	cmp	r2, #51	; 0x33
 800458e:	d074      	beq.n	800467a <PE_SubStateMachine_ExtendedMessages+0x110>
 8004590:	2a34      	cmp	r2, #52	; 0x34
 8004592:	d100      	bne.n	8004596 <PE_SubStateMachine_ExtendedMessages+0x2c>
 8004594:	e083      	b.n	800469e <PE_SubStateMachine_ExtendedMessages+0x134>
 8004596:	2a35      	cmp	r2, #53	; 0x35
 8004598:	d100      	bne.n	800459c <PE_SubStateMachine_ExtendedMessages+0x32>
 800459a:	e0b6      	b.n	800470a <PE_SubStateMachine_ExtendedMessages+0x1a0>
 800459c:	2a36      	cmp	r2, #54	; 0x36
 800459e:	d100      	bne.n	80045a2 <PE_SubStateMachine_ExtendedMessages+0x38>
 80045a0:	e0c3      	b.n	800472a <PE_SubStateMachine_ExtendedMessages+0x1c0>
 80045a2:	2a37      	cmp	r2, #55	; 0x37
 80045a4:	d100      	bne.n	80045a8 <PE_SubStateMachine_ExtendedMessages+0x3e>
 80045a6:	e0c9      	b.n	800473c <PE_SubStateMachine_ExtendedMessages+0x1d2>
 80045a8:	2a38      	cmp	r2, #56	; 0x38
 80045aa:	d100      	bne.n	80045ae <PE_SubStateMachine_ExtendedMessages+0x44>
 80045ac:	e0e8      	b.n	8004780 <PE_SubStateMachine_ExtendedMessages+0x216>
 80045ae:	2aa5      	cmp	r2, #165	; 0xa5
 80045b0:	d100      	bne.n	80045b4 <PE_SubStateMachine_ExtendedMessages+0x4a>
 80045b2:	e0d9      	b.n	8004768 <PE_SubStateMachine_ExtendedMessages+0x1fe>
 80045b4:	e0e7      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 80045b6:	8026      	strh	r6, [r4, #0]
 80045b8:	2701      	movs	r7, #1
 80045ba:	68e9      	ldr	r1, [r5, #12]
 80045bc:	2001      	movs	r0, #1
 80045be:	4008      	ands	r0, r1
 80045c0:	f7ff ff70 	bl	80044a4 <PE_Get_UnchunkedSupport>
 80045c4:	2801      	cmp	r0, #1
 80045c6:	d105      	bne.n	80045d4 <PE_SubStateMachine_ExtendedMessages+0x6a>
 80045c8:	2091      	movs	r0, #145	; 0x91
 80045ca:	0080      	lsls	r0, r0, #2
 80045cc:	1828      	adds	r0, r5, r0
 80045ce:	7046      	strb	r6, [r0, #1]
 80045d0:	7006      	strb	r6, [r0, #0]
 80045d2:	e023      	b.n	800461c <PE_SubStateMachine_ExtendedMessages+0xb2>
 80045d4:	76ee      	strb	r6, [r5, #27]
 80045d6:	76ae      	strb	r6, [r5, #26]
 80045d8:	68e8      	ldr	r0, [r5, #12]
 80045da:	4007      	ands	r7, r0
 80045dc:	0038      	movs	r0, r7
 80045de:	f7ff ff61 	bl	80044a4 <PE_Get_UnchunkedSupport>
 80045e2:	2800      	cmp	r0, #0
 80045e4:	d104      	bne.n	80045f0 <PE_SubStateMachine_ExtendedMessages+0x86>
 80045e6:	8b68      	ldrh	r0, [r5, #26]
 80045e8:	2180      	movs	r1, #128	; 0x80
 80045ea:	0209      	lsls	r1, r1, #8
 80045ec:	4301      	orrs	r1, r0
 80045ee:	8369      	strh	r1, [r5, #26]
 80045f0:	4866      	ldr	r0, [pc, #408]	; (800478c <.text_74>)
 80045f2:	1828      	adds	r0, r5, r0
 80045f4:	8861      	ldrh	r1, [r4, #2]
 80045f6:	291a      	cmp	r1, #26
 80045f8:	4631      	mov	r1, r6
 80045fa:	d90c      	bls.n	8004616 <PE_SubStateMachine_ExtendedMessages+0xac>
 80045fc:	5c42      	ldrb	r2, [r0, r1]
 80045fe:	002b      	movs	r3, r5
 8004600:	331c      	adds	r3, #28
 8004602:	545a      	strb	r2, [r3, r1]
 8004604:	1c49      	adds	r1, r1, #1
 8004606:	291a      	cmp	r1, #26
 8004608:	d208      	bcs.n	800461c <PE_SubStateMachine_ExtendedMessages+0xb2>
 800460a:	e7f7      	b.n	80045fc <PE_SubStateMachine_ExtendedMessages+0x92>
 800460c:	5c42      	ldrb	r2, [r0, r1]
 800460e:	002b      	movs	r3, r5
 8004610:	331c      	adds	r3, #28
 8004612:	545a      	strb	r2, [r3, r1]
 8004614:	1c49      	adds	r1, r1, #1
 8004616:	8862      	ldrh	r2, [r4, #2]
 8004618:	4291      	cmp	r1, r2
 800461a:	d3f7      	bcc.n	800460c <PE_SubStateMachine_ExtendedMessages+0xa2>
 800461c:	2032      	movs	r0, #50	; 0x32
 800461e:	e08b      	b.n	8004738 <PE_SubStateMachine_ExtendedMessages+0x1ce>
 8004620:	0028      	movs	r0, r5
 8004622:	3018      	adds	r0, #24
 8004624:	9003      	str	r0, [sp, #12]
 8004626:	7b29      	ldrb	r1, [r5, #12]
 8004628:	07c8      	lsls	r0, r1, #31
 800462a:	0fc0      	lsrs	r0, r0, #31
 800462c:	f7ff ff3a 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004630:	2801      	cmp	r0, #1
 8004632:	d101      	bne.n	8004638 <PE_SubStateMachine_ExtendedMessages+0xce>
 8004634:	9802      	ldr	r0, [sp, #8]
 8004636:	9003      	str	r0, [sp, #12]
 8004638:	2001      	movs	r0, #1
 800463a:	68e9      	ldr	r1, [r5, #12]
 800463c:	0909      	lsrs	r1, r1, #4
 800463e:	4001      	ands	r1, r0
 8004640:	d006      	beq.n	8004650 <PE_SubStateMachine_ExtendedMessages+0xe6>
 8004642:	6869      	ldr	r1, [r5, #4]
 8004644:	7809      	ldrb	r1, [r1, #0]
 8004646:	0889      	lsrs	r1, r1, #2
 8004648:	4201      	tst	r1, r0
 800464a:	d102      	bne.n	8004652 <PE_SubStateMachine_ExtendedMessages+0xe8>
 800464c:	2002      	movs	r0, #2
 800464e:	e000      	b.n	8004652 <PE_SubStateMachine_ExtendedMessages+0xe8>
 8004650:	2000      	movs	r0, #0
 8004652:	21e4      	movs	r1, #228	; 0xe4
 8004654:	0089      	lsls	r1, r1, #2
 8004656:	186e      	adds	r6, r5, r1
 8004658:	9002      	str	r0, [sp, #8]
 800465a:	2033      	movs	r0, #51	; 0x33
 800465c:	9001      	str	r0, [sp, #4]
 800465e:	8860      	ldrh	r0, [r4, #2]
 8004660:	1d00      	adds	r0, r0, #4
 8004662:	9000      	str	r0, [sp, #0]
 8004664:	9b03      	ldr	r3, [sp, #12]
 8004666:	78f2      	ldrb	r2, [r6, #3]
 8004668:	7ae1      	ldrb	r1, [r4, #11]
 800466a:	0028      	movs	r0, r5
 800466c:	f7ff ff2a 	bl	80044c4 <PE_Send_ExtendedMessage>
 8004670:	2800      	cmp	r0, #0
 8004672:	d101      	bne.n	8004678 <PE_SubStateMachine_ExtendedMessages+0x10e>
 8004674:	88f0      	ldrh	r0, [r6, #6]
 8004676:	82e8      	strh	r0, [r5, #22]
 8004678:	e085      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800467a:	68ea      	ldr	r2, [r5, #12]
 800467c:	06d3      	lsls	r3, r2, #27
 800467e:	0fdb      	lsrs	r3, r3, #31
 8004680:	d009      	beq.n	8004696 <PE_SubStateMachine_ExtendedMessages+0x12c>
 8004682:	8461      	strh	r1, [r4, #34]	; 0x22
 8004684:	271a      	movs	r7, #26
 8004686:	20e4      	movs	r0, #228	; 0xe4
 8004688:	0080      	lsls	r0, r0, #2
 800468a:	1828      	adds	r0, r5, r0
 800468c:	78c0      	ldrb	r0, [r0, #3]
 800468e:	2884      	cmp	r0, #132	; 0x84
 8004690:	d166      	bne.n	8004760 <PE_SubStateMachine_ExtendedMessages+0x1f6>
 8004692:	2074      	movs	r0, #116	; 0x74
 8004694:	e072      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 8004696:	73a0      	strb	r0, [r4, #14]
 8004698:	2700      	movs	r7, #0
 800469a:	8466      	strh	r6, [r4, #34]	; 0x22
 800469c:	e073      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800469e:	4669      	mov	r1, sp
 80046a0:	22e4      	movs	r2, #228	; 0xe4
 80046a2:	0092      	lsls	r2, r2, #2
 80046a4:	5aaa      	ldrh	r2, [r5, r2]
 80046a6:	0452      	lsls	r2, r2, #17
 80046a8:	0f12      	lsrs	r2, r2, #28
 80046aa:	800a      	strh	r2, [r1, #0]
 80046ac:	4611      	mov	r1, r2
 80046ae:	221a      	movs	r2, #26
 80046b0:	434a      	muls	r2, r1
 80046b2:	9201      	str	r2, [sp, #4]
 80046b4:	8861      	ldrh	r1, [r4, #2]
 80046b6:	428a      	cmp	r2, r1
 80046b8:	da03      	bge.n	80046c2 <PE_SubStateMachine_ExtendedMessages+0x158>
 80046ba:	466a      	mov	r2, sp
 80046bc:	8812      	ldrh	r2, [r2, #0]
 80046be:	2a0a      	cmp	r2, #10
 80046c0:	db01      	blt.n	80046c6 <PE_SubStateMachine_ExtendedMessages+0x15c>
 80046c2:	8466      	strh	r6, [r4, #34]	; 0x22
 80046c4:	e05a      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 80046c6:	9a01      	ldr	r2, [sp, #4]
 80046c8:	1a88      	subs	r0, r1, r2
 80046ca:	281a      	cmp	r0, #26
 80046cc:	d202      	bcs.n	80046d4 <PE_SubStateMachine_ExtendedMessages+0x16a>
 80046ce:	1a89      	subs	r1, r1, r2
 80046d0:	b2c9      	uxtb	r1, r1
 80046d2:	e000      	b.n	80046d6 <PE_SubStateMachine_ExtendedMessages+0x16c>
 80046d4:	211a      	movs	r1, #26
 80046d6:	2000      	movs	r0, #0
 80046d8:	e006      	b.n	80046e8 <PE_SubStateMachine_ExtendedMessages+0x17e>
 80046da:	9b02      	ldr	r3, [sp, #8]
 80046dc:	1817      	adds	r7, r2, r0
 80046de:	5ddb      	ldrb	r3, [r3, r7]
 80046e0:	002f      	movs	r7, r5
 80046e2:	371c      	adds	r7, #28
 80046e4:	543b      	strb	r3, [r7, r0]
 80046e6:	1c40      	adds	r0, r0, #1
 80046e8:	4288      	cmp	r0, r1
 80046ea:	d3f6      	bcc.n	80046da <PE_SubStateMachine_ExtendedMessages+0x170>
 80046ec:	002b      	movs	r3, r5
 80046ee:	3318      	adds	r3, #24
 80046f0:	8862      	ldrh	r2, [r4, #2]
 80046f2:	20e4      	movs	r0, #228	; 0xe4
 80046f4:	0080      	lsls	r0, r0, #2
 80046f6:	5a28      	ldrh	r0, [r5, r0]
 80046f8:	0440      	lsls	r0, r0, #17
 80046fa:	0f01      	lsrs	r1, r0, #28
 80046fc:	7b2d      	ldrb	r5, [r5, #12]
 80046fe:	07e8      	lsls	r0, r5, #31
 8004700:	0fc0      	lsrs	r0, r0, #31
 8004702:	f001 f8cb 	bl	800589c <USBPD_PRL_PrepareExtendedTxChunkSending>
 8004706:	2035      	movs	r0, #53	; 0x35
 8004708:	e016      	b.n	8004738 <PE_SubStateMachine_ExtendedMessages+0x1ce>
 800470a:	9602      	str	r6, [sp, #8]
 800470c:	2036      	movs	r0, #54	; 0x36
 800470e:	9001      	str	r0, [sp, #4]
 8004710:	8860      	ldrh	r0, [r4, #2]
 8004712:	9000      	str	r0, [sp, #0]
 8004714:	002b      	movs	r3, r5
 8004716:	3318      	adds	r3, #24
 8004718:	20e4      	movs	r0, #228	; 0xe4
 800471a:	0080      	lsls	r0, r0, #2
 800471c:	1828      	adds	r0, r5, r0
 800471e:	78c2      	ldrb	r2, [r0, #3]
 8004720:	7ae1      	ldrb	r1, [r4, #11]
 8004722:	0028      	movs	r0, r5
 8004724:	f7ff fece 	bl	80044c4 <PE_Send_ExtendedMessage>
 8004728:	e02d      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800472a:	8026      	strh	r6, [r4, #0]
 800472c:	68ea      	ldr	r2, [r5, #12]
 800472e:	06d3      	lsls	r3, r2, #27
 8004730:	0fdb      	lsrs	r3, r3, #31
 8004732:	d001      	beq.n	8004738 <PE_SubStateMachine_ExtendedMessages+0x1ce>
 8004734:	8461      	strh	r1, [r4, #34]	; 0x22
 8004736:	2039      	movs	r0, #57	; 0x39
 8004738:	73a0      	strb	r0, [r4, #14]
 800473a:	e01d      	b.n	8004778 <PE_SubStateMachine_ExtendedMessages+0x20e>
 800473c:	8c60      	ldrh	r0, [r4, #34]	; 0x22
 800473e:	03ba      	lsls	r2, r7, #14
 8004740:	4290      	cmp	r0, r2
 8004742:	d101      	bne.n	8004748 <PE_SubStateMachine_ExtendedMessages+0x1de>
 8004744:	8466      	strh	r6, [r4, #34]	; 0x22
 8004746:	e00d      	b.n	8004764 <PE_SubStateMachine_ExtendedMessages+0x1fa>
 8004748:	8461      	strh	r1, [r4, #34]	; 0x22
 800474a:	271a      	movs	r7, #26
 800474c:	48c9      	ldr	r0, [pc, #804]	; (8004a74 <.text_78>)
 800474e:	182a      	adds	r2, r5, r0
 8004750:	7ae1      	ldrb	r1, [r4, #11]
 8004752:	7b2b      	ldrb	r3, [r5, #12]
 8004754:	07d8      	lsls	r0, r3, #31
 8004756:	0fc0      	lsrs	r0, r0, #31
 8004758:	f001 f8c8 	bl	80058ec <USBPD_PRL_ManageExtendedRx>
 800475c:	2800      	cmp	r0, #0
 800475e:	d101      	bne.n	8004764 <PE_SubStateMachine_ExtendedMessages+0x1fa>
 8004760:	2039      	movs	r0, #57	; 0x39
 8004762:	e00b      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 8004764:	200f      	movs	r0, #15
 8004766:	e009      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 8004768:	7aa1      	ldrb	r1, [r4, #10]
 800476a:	2900      	cmp	r1, #0
 800476c:	d006      	beq.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 800476e:	7ae0      	ldrb	r0, [r4, #11]
 8004770:	7460      	strb	r0, [r4, #17]
 8004772:	7aa0      	ldrb	r0, [r4, #10]
 8004774:	73a0      	strb	r0, [r4, #14]
 8004776:	72a6      	strb	r6, [r4, #10]
 8004778:	2700      	movs	r7, #0
 800477a:	e004      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800477c:	73a0      	strb	r0, [r4, #14]
 800477e:	e002      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 8004780:	8466      	strh	r6, [r4, #34]	; 0x22
 8004782:	73a0      	strb	r0, [r4, #14]
 8004784:	8026      	strh	r6, [r4, #0]
 8004786:	0038      	movs	r0, r7
 8004788:	b005      	add	sp, #20
 800478a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800478c <.text_74>:
 800478c:	00000242 	.word	0x00000242

08004790 <.text_75>:
 8004790:	0000034a 	.word	0x0000034a

08004794 <.text_76>:
 8004794:	0000801a 	.word	0x0000801a

08004798 <PE_SubStateMachine_Generic>:
 8004798:	b5f0      	push	{r4, r5, r6, r7, lr}
 800479a:	b085      	sub	sp, #20
 800479c:	0004      	movs	r4, r0
 800479e:	2601      	movs	r6, #1
 80047a0:	2703      	movs	r7, #3
 80047a2:	2500      	movs	r5, #0
 80047a4:	20d6      	movs	r0, #214	; 0xd6
 80047a6:	0080      	lsls	r0, r0, #2
 80047a8:	5c20      	ldrb	r0, [r4, r0]
 80047aa:	2801      	cmp	r0, #1
 80047ac:	d013      	beq.n	80047d6 <PE_SubStateMachine_Generic+0x3e>
 80047ae:	282c      	cmp	r0, #44	; 0x2c
 80047b0:	d100      	bne.n	80047b4 <PE_SubStateMachine_Generic+0x1c>
 80047b2:	e136      	b.n	8004a22 <PE_SubStateMachine_Generic+0x28a>
 80047b4:	2830      	cmp	r0, #48	; 0x30
 80047b6:	d05a      	beq.n	800486e <PE_SubStateMachine_Generic+0xd6>
 80047b8:	283a      	cmp	r0, #58	; 0x3a
 80047ba:	d100      	bne.n	80047be <PE_SubStateMachine_Generic+0x26>
 80047bc:	e10b      	b.n	80049d6 <PE_SubStateMachine_Generic+0x23e>
 80047be:	283b      	cmp	r0, #59	; 0x3b
 80047c0:	d100      	bne.n	80047c4 <PE_SubStateMachine_Generic+0x2c>
 80047c2:	e0e6      	b.n	8004992 <PE_SubStateMachine_Generic+0x1fa>
 80047c4:	283c      	cmp	r0, #60	; 0x3c
 80047c6:	d100      	bne.n	80047ca <PE_SubStateMachine_Generic+0x32>
 80047c8:	e0c1      	b.n	800494e <PE_SubStateMachine_Generic+0x1b6>
 80047ca:	2863      	cmp	r0, #99	; 0x63
 80047cc:	d01a      	beq.n	8004804 <PE_SubStateMachine_Generic+0x6c>
 80047ce:	2874      	cmp	r0, #116	; 0x74
 80047d0:	d100      	bne.n	80047d4 <PE_SubStateMachine_Generic+0x3c>
 80047d2:	e087      	b.n	80048e4 <PE_SubStateMachine_Generic+0x14c>
 80047d4:	e147      	b.n	8004a66 <PE_SubStateMachine_Generic+0x2ce>
 80047d6:	9500      	str	r5, [sp, #0]
 80047d8:	2303      	movs	r3, #3
 80047da:	2210      	movs	r2, #16
 80047dc:	2100      	movs	r1, #0
 80047de:	0020      	movs	r0, r4
 80047e0:	f7fe ffc7 	bl	8003772 <PE_Send_CtrlMessage>
 80047e4:	4da4      	ldr	r5, [pc, #656]	; (8004a78 <.text_79>)
 80047e6:	7828      	ldrb	r0, [r5, #0]
 80047e8:	0780      	lsls	r0, r0, #30
 80047ea:	d509      	bpl.n	8004800 <PE_SubStateMachine_Generic+0x68>
 80047ec:	2000      	movs	r0, #0
 80047ee:	9000      	str	r0, [sp, #0]
 80047f0:	2300      	movs	r3, #0
 80047f2:	2255      	movs	r2, #85	; 0x55
 80047f4:	68e0      	ldr	r0, [r4, #12]
 80047f6:	2101      	movs	r1, #1
 80047f8:	4001      	ands	r1, r0
 80047fa:	2009      	movs	r0, #9
 80047fc:	68ed      	ldr	r5, [r5, #12]
 80047fe:	47a8      	blx	r5
 8004800:	2155      	movs	r1, #85	; 0x55
 8004802:	e068      	b.n	80048d6 <PE_SubStateMachine_Generic+0x13e>
 8004804:	9503      	str	r5, [sp, #12]
 8004806:	ab03      	add	r3, sp, #12
 8004808:	0022      	movs	r2, r4
 800480a:	321c      	adds	r2, #28
 800480c:	2108      	movs	r1, #8
 800480e:	68e7      	ldr	r7, [r4, #12]
 8004810:	2001      	movs	r0, #1
 8004812:	4038      	ands	r0, r7
 8004814:	68a7      	ldr	r7, [r4, #8]
 8004816:	69bf      	ldr	r7, [r7, #24]
 8004818:	47b8      	blx	r7
 800481a:	76e5      	strb	r5, [r4, #27]
 800481c:	76a5      	strb	r5, [r4, #26]
 800481e:	68e1      	ldr	r1, [r4, #12]
 8004820:	2001      	movs	r0, #1
 8004822:	4008      	ands	r0, r1
 8004824:	f7ff fe3e 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004828:	2800      	cmp	r0, #0
 800482a:	d103      	bne.n	8004834 <PE_SubStateMachine_Generic+0x9c>
 800482c:	8b60      	ldrh	r0, [r4, #26]
 800482e:	03f1      	lsls	r1, r6, #15
 8004830:	4301      	orrs	r1, r0
 8004832:	8361      	strh	r1, [r4, #26]
 8004834:	9502      	str	r5, [sp, #8]
 8004836:	2003      	movs	r0, #3
 8004838:	9001      	str	r0, [sp, #4]
 800483a:	9803      	ldr	r0, [sp, #12]
 800483c:	1d00      	adds	r0, r0, #4
 800483e:	9000      	str	r0, [sp, #0]
 8004840:	0023      	movs	r3, r4
 8004842:	3318      	adds	r3, #24
 8004844:	2281      	movs	r2, #129	; 0x81
 8004846:	2100      	movs	r1, #0
 8004848:	0020      	movs	r0, r4
 800484a:	f7ff fe3b 	bl	80044c4 <PE_Send_ExtendedMessage>
 800484e:	4d8a      	ldr	r5, [pc, #552]	; (8004a78 <.text_79>)
 8004850:	7828      	ldrb	r0, [r5, #0]
 8004852:	0780      	lsls	r0, r0, #30
 8004854:	d509      	bpl.n	800486a <PE_SubStateMachine_Generic+0xd2>
 8004856:	2000      	movs	r0, #0
 8004858:	9000      	str	r0, [sp, #0]
 800485a:	2300      	movs	r3, #0
 800485c:	2245      	movs	r2, #69	; 0x45
 800485e:	68e0      	ldr	r0, [r4, #12]
 8004860:	2101      	movs	r1, #1
 8004862:	4001      	ands	r1, r0
 8004864:	2009      	movs	r0, #9
 8004866:	68ed      	ldr	r5, [r5, #12]
 8004868:	47a8      	blx	r5
 800486a:	2145      	movs	r1, #69	; 0x45
 800486c:	e033      	b.n	80048d6 <PE_SubStateMachine_Generic+0x13e>
 800486e:	9503      	str	r5, [sp, #12]
 8004870:	ab03      	add	r3, sp, #12
 8004872:	0022      	movs	r2, r4
 8004874:	321c      	adds	r2, #28
 8004876:	2109      	movs	r1, #9
 8004878:	68e7      	ldr	r7, [r4, #12]
 800487a:	2001      	movs	r0, #1
 800487c:	4038      	ands	r0, r7
 800487e:	68a7      	ldr	r7, [r4, #8]
 8004880:	69bf      	ldr	r7, [r7, #24]
 8004882:	47b8      	blx	r7
 8004884:	76e5      	strb	r5, [r4, #27]
 8004886:	76a5      	strb	r5, [r4, #26]
 8004888:	68e1      	ldr	r1, [r4, #12]
 800488a:	2001      	movs	r0, #1
 800488c:	4008      	ands	r0, r1
 800488e:	f7ff fe09 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004892:	2800      	cmp	r0, #0
 8004894:	d103      	bne.n	800489e <PE_SubStateMachine_Generic+0x106>
 8004896:	8b60      	ldrh	r0, [r4, #26]
 8004898:	03f1      	lsls	r1, r6, #15
 800489a:	4301      	orrs	r1, r0
 800489c:	8361      	strh	r1, [r4, #26]
 800489e:	9502      	str	r5, [sp, #8]
 80048a0:	2003      	movs	r0, #3
 80048a2:	9001      	str	r0, [sp, #4]
 80048a4:	9803      	ldr	r0, [sp, #12]
 80048a6:	1d00      	adds	r0, r0, #4
 80048a8:	9000      	str	r0, [sp, #0]
 80048aa:	0023      	movs	r3, r4
 80048ac:	3318      	adds	r3, #24
 80048ae:	2282      	movs	r2, #130	; 0x82
 80048b0:	2100      	movs	r1, #0
 80048b2:	0020      	movs	r0, r4
 80048b4:	f7ff fe06 	bl	80044c4 <PE_Send_ExtendedMessage>
 80048b8:	4d6f      	ldr	r5, [pc, #444]	; (8004a78 <.text_79>)
 80048ba:	7828      	ldrb	r0, [r5, #0]
 80048bc:	0780      	lsls	r0, r0, #30
 80048be:	d509      	bpl.n	80048d4 <PE_SubStateMachine_Generic+0x13c>
 80048c0:	2000      	movs	r0, #0
 80048c2:	9000      	str	r0, [sp, #0]
 80048c4:	2300      	movs	r3, #0
 80048c6:	224c      	movs	r2, #76	; 0x4c
 80048c8:	68e0      	ldr	r0, [r4, #12]
 80048ca:	2101      	movs	r1, #1
 80048cc:	4001      	ands	r1, r0
 80048ce:	2009      	movs	r0, #9
 80048d0:	68ed      	ldr	r5, [r5, #12]
 80048d2:	47a8      	blx	r5
 80048d4:	214c      	movs	r1, #76	; 0x4c
 80048d6:	68e0      	ldr	r0, [r4, #12]
 80048d8:	4006      	ands	r6, r0
 80048da:	0030      	movs	r0, r6
 80048dc:	68a2      	ldr	r2, [r4, #8]
 80048de:	68d2      	ldr	r2, [r2, #12]
 80048e0:	4790      	blx	r2
 80048e2:	e0c3      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 80048e4:	9100      	str	r1, [sp, #0]
 80048e6:	7808      	ldrb	r0, [r1, #0]
 80048e8:	2814      	cmp	r0, #20
 80048ea:	d025      	beq.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 80048ec:	20d6      	movs	r0, #214	; 0xd6
 80048ee:	0080      	lsls	r0, r0, #2
 80048f0:	1820      	adds	r0, r4, r0
 80048f2:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
 80048f4:	0bc0      	lsrs	r0, r0, #15
 80048f6:	d11f      	bne.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 80048f8:	20d6      	movs	r0, #214	; 0xd6
 80048fa:	0080      	lsls	r0, r0, #2
 80048fc:	1820      	adds	r0, r4, r0
 80048fe:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
 8004900:	0440      	lsls	r0, r0, #17
 8004902:	0f40      	lsrs	r0, r0, #29
 8004904:	d018      	beq.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 8004906:	20d6      	movs	r0, #214	; 0xd6
 8004908:	0080      	lsls	r0, r0, #2
 800490a:	1820      	adds	r0, r4, r0
 800490c:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
 800490e:	06c0      	lsls	r0, r0, #27
 8004910:	0ec0      	lsrs	r0, r0, #27
 8004912:	2805      	cmp	r0, #5
 8004914:	d110      	bne.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 8004916:	2318      	movs	r3, #24
 8004918:	209f      	movs	r0, #159	; 0x9f
 800491a:	0040      	lsls	r0, r0, #1
 800491c:	1822      	adds	r2, r4, r0
 800491e:	210f      	movs	r1, #15
 8004920:	68e0      	ldr	r0, [r4, #12]
 8004922:	4006      	ands	r6, r0
 8004924:	0030      	movs	r0, r6
 8004926:	68a6      	ldr	r6, [r4, #8]
 8004928:	69f6      	ldr	r6, [r6, #28]
 800492a:	47b0      	blx	r6
 800492c:	20d6      	movs	r0, #214	; 0xd6
 800492e:	0080      	lsls	r0, r0, #2
 8004930:	5427      	strb	r7, [r4, r0]
 8004932:	2014      	movs	r0, #20
 8004934:	9900      	ldr	r1, [sp, #0]
 8004936:	7008      	strb	r0, [r1, #0]
 8004938:	20d6      	movs	r0, #214	; 0xd6
 800493a:	0080      	lsls	r0, r0, #2
 800493c:	1820      	adds	r0, r4, r0
 800493e:	8a81      	ldrh	r1, [r0, #20]
 8004940:	2280      	movs	r2, #128	; 0x80
 8004942:	0212      	lsls	r2, r2, #8
 8004944:	4291      	cmp	r1, r2
 8004946:	d101      	bne.n	800494c <PE_SubStateMachine_Generic+0x1b4>
 8004948:	8285      	strh	r5, [r0, #20]
 800494a:	7007      	strb	r7, [r0, #0]
 800494c:	e08e      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 800494e:	ab03      	add	r3, sp, #12
 8004950:	0022      	movs	r2, r4
 8004952:	321c      	adds	r2, #28
 8004954:	210d      	movs	r1, #13
 8004956:	68e7      	ldr	r7, [r4, #12]
 8004958:	2001      	movs	r0, #1
 800495a:	4038      	ands	r0, r7
 800495c:	68a7      	ldr	r7, [r4, #8]
 800495e:	69bf      	ldr	r7, [r7, #24]
 8004960:	47b8      	blx	r7
 8004962:	76e5      	strb	r5, [r4, #27]
 8004964:	76a5      	strb	r5, [r4, #26]
 8004966:	68e0      	ldr	r0, [r4, #12]
 8004968:	4006      	ands	r6, r0
 800496a:	0030      	movs	r0, r6
 800496c:	f7ff fd9a 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004970:	2800      	cmp	r0, #0
 8004972:	d104      	bne.n	800497e <PE_SubStateMachine_Generic+0x1e6>
 8004974:	8b60      	ldrh	r0, [r4, #26]
 8004976:	2180      	movs	r1, #128	; 0x80
 8004978:	0209      	lsls	r1, r1, #8
 800497a:	4301      	orrs	r1, r0
 800497c:	8361      	strh	r1, [r4, #26]
 800497e:	9502      	str	r5, [sp, #8]
 8004980:	2003      	movs	r0, #3
 8004982:	9001      	str	r0, [sp, #4]
 8004984:	9803      	ldr	r0, [sp, #12]
 8004986:	1d00      	adds	r0, r0, #4
 8004988:	9000      	str	r0, [sp, #0]
 800498a:	0023      	movs	r3, r4
 800498c:	3318      	adds	r3, #24
 800498e:	2287      	movs	r2, #135	; 0x87
 8004990:	e042      	b.n	8004a18 <PE_SubStateMachine_Generic+0x280>
 8004992:	9503      	str	r5, [sp, #12]
 8004994:	ab04      	add	r3, sp, #16
 8004996:	0022      	movs	r2, r4
 8004998:	321c      	adds	r2, #28
 800499a:	210f      	movs	r1, #15
 800499c:	68e0      	ldr	r0, [r4, #12]
 800499e:	4006      	ands	r6, r0
 80049a0:	0030      	movs	r0, r6
 80049a2:	68a5      	ldr	r5, [r4, #8]
 80049a4:	69ad      	ldr	r5, [r5, #24]
 80049a6:	47a8      	blx	r5
 80049a8:	7fe0      	ldrb	r0, [r4, #31]
 80049aa:	0600      	lsls	r0, r0, #24
 80049ac:	7fa1      	ldrb	r1, [r4, #30]
 80049ae:	0409      	lsls	r1, r1, #16
 80049b0:	4301      	orrs	r1, r0
 80049b2:	7f60      	ldrb	r0, [r4, #29]
 80049b4:	0200      	lsls	r0, r0, #8
 80049b6:	4308      	orrs	r0, r1
 80049b8:	7f21      	ldrb	r1, [r4, #28]
 80049ba:	4301      	orrs	r1, r0
 80049bc:	9103      	str	r1, [sp, #12]
 80049be:	2000      	movs	r0, #0
 80049c0:	9002      	str	r0, [sp, #8]
 80049c2:	9701      	str	r7, [sp, #4]
 80049c4:	2001      	movs	r0, #1
 80049c6:	9000      	str	r0, [sp, #0]
 80049c8:	ab03      	add	r3, sp, #12
 80049ca:	2205      	movs	r2, #5
 80049cc:	2100      	movs	r1, #0
 80049ce:	0020      	movs	r0, r4
 80049d0:	f7fe ff16 	bl	8003800 <PE_Send_DataMessage>
 80049d4:	e04a      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 80049d6:	ab03      	add	r3, sp, #12
 80049d8:	0022      	movs	r2, r4
 80049da:	321c      	adds	r2, #28
 80049dc:	2111      	movs	r1, #17
 80049de:	68e7      	ldr	r7, [r4, #12]
 80049e0:	2001      	movs	r0, #1
 80049e2:	4038      	ands	r0, r7
 80049e4:	68a7      	ldr	r7, [r4, #8]
 80049e6:	69bf      	ldr	r7, [r7, #24]
 80049e8:	47b8      	blx	r7
 80049ea:	76e5      	strb	r5, [r4, #27]
 80049ec:	76a5      	strb	r5, [r4, #26]
 80049ee:	68e0      	ldr	r0, [r4, #12]
 80049f0:	4006      	ands	r6, r0
 80049f2:	0030      	movs	r0, r6
 80049f4:	f7ff fd56 	bl	80044a4 <PE_Get_UnchunkedSupport>
 80049f8:	2800      	cmp	r0, #0
 80049fa:	d104      	bne.n	8004a06 <PE_SubStateMachine_Generic+0x26e>
 80049fc:	8b60      	ldrh	r0, [r4, #26]
 80049fe:	2180      	movs	r1, #128	; 0x80
 8004a00:	0209      	lsls	r1, r1, #8
 8004a02:	4301      	orrs	r1, r0
 8004a04:	8361      	strh	r1, [r4, #26]
 8004a06:	9502      	str	r5, [sp, #8]
 8004a08:	2003      	movs	r0, #3
 8004a0a:	9001      	str	r0, [sp, #4]
 8004a0c:	9803      	ldr	r0, [sp, #12]
 8004a0e:	1d00      	adds	r0, r0, #4
 8004a10:	9000      	str	r0, [sp, #0]
 8004a12:	0023      	movs	r3, r4
 8004a14:	3318      	adds	r3, #24
 8004a16:	2285      	movs	r2, #133	; 0x85
 8004a18:	2100      	movs	r1, #0
 8004a1a:	0020      	movs	r0, r4
 8004a1c:	f7ff fd52 	bl	80044c4 <PE_Send_ExtendedMessage>
 8004a20:	e024      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 8004a22:	4d15      	ldr	r5, [pc, #84]	; (8004a78 <.text_79>)
 8004a24:	7828      	ldrb	r0, [r5, #0]
 8004a26:	0780      	lsls	r0, r0, #30
 8004a28:	d509      	bpl.n	8004a3e <PE_SubStateMachine_Generic+0x2a6>
 8004a2a:	2000      	movs	r0, #0
 8004a2c:	9000      	str	r0, [sp, #0]
 8004a2e:	2300      	movs	r3, #0
 8004a30:	224d      	movs	r2, #77	; 0x4d
 8004a32:	68e0      	ldr	r0, [r4, #12]
 8004a34:	2101      	movs	r1, #1
 8004a36:	4001      	ands	r1, r0
 8004a38:	2009      	movs	r0, #9
 8004a3a:	68ed      	ldr	r5, [r5, #12]
 8004a3c:	47a8      	blx	r5
 8004a3e:	214d      	movs	r1, #77	; 0x4d
 8004a40:	68e2      	ldr	r2, [r4, #12]
 8004a42:	2001      	movs	r0, #1
 8004a44:	4010      	ands	r0, r2
 8004a46:	68a2      	ldr	r2, [r4, #8]
 8004a48:	68d2      	ldr	r2, [r2, #12]
 8004a4a:	4790      	blx	r2
 8004a4c:	2300      	movs	r3, #0
 8004a4e:	2200      	movs	r2, #0
 8004a50:	210b      	movs	r1, #11
 8004a52:	68e0      	ldr	r0, [r4, #12]
 8004a54:	4006      	ands	r6, r0
 8004a56:	0030      	movs	r0, r6
 8004a58:	68a5      	ldr	r5, [r4, #8]
 8004a5a:	69ad      	ldr	r5, [r5, #24]
 8004a5c:	47a8      	blx	r5
 8004a5e:	20d6      	movs	r0, #214	; 0xd6
 8004a60:	0080      	lsls	r0, r0, #2
 8004a62:	5427      	strb	r7, [r4, r0]
 8004a64:	e002      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 8004a66:	20d6      	movs	r0, #214	; 0xd6
 8004a68:	0080      	lsls	r0, r0, #2
 8004a6a:	5426      	strb	r6, [r4, r0]
 8004a6c:	2002      	movs	r0, #2
 8004a6e:	b005      	add	sp, #20
 8004a70:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08004a74 <.text_78>:
 8004a74:	00000392 	.word	0x00000392

08004a78 <.text_79>:
 8004a78:	200019a8 	.word	0x200019a8

08004a7c <PE_SubStateMachine_VconnSwap>:
 8004a7c:	b5f2      	push	{r1, r4, r5, r6, r7, lr}
 8004a7e:	b082      	sub	sp, #8
 8004a80:	0004      	movs	r4, r0
 8004a82:	2002      	movs	r0, #2
 8004a84:	9001      	str	r0, [sp, #4]
 8004a86:	20d6      	movs	r0, #214	; 0xd6
 8004a88:	0080      	lsls	r0, r0, #2
 8004a8a:	1826      	adds	r6, r4, r0
 8004a8c:	201f      	movs	r0, #31
 8004a8e:	4d82      	ldr	r5, [pc, #520]	; (8004c98 <PE_SubStateMachine_VconnSwap+0x21c>)
 8004a90:	2107      	movs	r1, #7
 8004a92:	7832      	ldrb	r2, [r6, #0]
 8004a94:	2a9d      	cmp	r2, #157	; 0x9d
 8004a96:	d011      	beq.n	8004abc <PE_SubStateMachine_VconnSwap+0x40>
 8004a98:	d30f      	bcc.n	8004aba <PE_SubStateMachine_VconnSwap+0x3e>
 8004a9a:	2a9f      	cmp	r2, #159	; 0x9f
 8004a9c:	d077      	beq.n	8004b8e <PE_SubStateMachine_VconnSwap+0x112>
 8004a9e:	d34b      	bcc.n	8004b38 <PE_SubStateMachine_VconnSwap+0xbc>
 8004aa0:	2aa1      	cmp	r2, #161	; 0xa1
 8004aa2:	d100      	bne.n	8004aa6 <PE_SubStateMachine_VconnSwap+0x2a>
 8004aa4:	e0b0      	b.n	8004c08 <PE_SubStateMachine_VconnSwap+0x18c>
 8004aa6:	d200      	bcs.n	8004aaa <PE_SubStateMachine_VconnSwap+0x2e>
 8004aa8:	e0a3      	b.n	8004bf2 <PE_SubStateMachine_VconnSwap+0x176>
 8004aaa:	2aa3      	cmp	r2, #163	; 0xa3
 8004aac:	d100      	bne.n	8004ab0 <PE_SubStateMachine_VconnSwap+0x34>
 8004aae:	e0f5      	b.n	8004c9c <PE_SubStateMachine_VconnSwap+0x220>
 8004ab0:	d200      	bcs.n	8004ab4 <PE_SubStateMachine_VconnSwap+0x38>
 8004ab2:	e0c9      	b.n	8004c48 <PE_SubStateMachine_VconnSwap+0x1cc>
 8004ab4:	2aa4      	cmp	r2, #164	; 0xa4
 8004ab6:	d100      	bne.n	8004aba <PE_SubStateMachine_VconnSwap+0x3e>
 8004ab8:	e18f      	b.n	8004dda <PE_SubStateMachine_VconnSwap+0x35e>
 8004aba:	e1a3      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004abc:	6860      	ldr	r0, [r4, #4]
 8004abe:	2703      	movs	r7, #3
 8004ac0:	7842      	ldrb	r2, [r0, #1]
 8004ac2:	0912      	lsrs	r2, r2, #4
 8004ac4:	4011      	ands	r1, r2
 8004ac6:	2903      	cmp	r1, #3
 8004ac8:	d169      	bne.n	8004b9e <PE_SubStateMachine_VconnSwap+0x122>
 8004aca:	6800      	ldr	r0, [r0, #0]
 8004acc:	0501      	lsls	r1, r0, #20
 8004ace:	0fc9      	lsrs	r1, r1, #31
 8004ad0:	d065      	beq.n	8004b9e <PE_SubStateMachine_VconnSwap+0x122>
 8004ad2:	7b21      	ldrb	r1, [r4, #12]
 8004ad4:	07c8      	lsls	r0, r1, #31
 8004ad6:	0fc0      	lsrs	r0, r0, #31
 8004ad8:	68a1      	ldr	r1, [r4, #8]
 8004ada:	6b09      	ldr	r1, [r1, #48]	; 0x30
 8004adc:	4788      	blx	r1
 8004ade:	280a      	cmp	r0, #10
 8004ae0:	d002      	beq.n	8004ae8 <PE_SubStateMachine_VconnSwap+0x6c>
 8004ae2:	280d      	cmp	r0, #13
 8004ae4:	d008      	beq.n	8004af8 <PE_SubStateMachine_VconnSwap+0x7c>
 8004ae6:	e01e      	b.n	8004b26 <PE_SubStateMachine_VconnSwap+0xaa>
 8004ae8:	209e      	movs	r0, #158	; 0x9e
 8004aea:	7030      	strb	r0, [r6, #0]
 8004aec:	68e0      	ldr	r0, [r4, #12]
 8004aee:	2180      	movs	r1, #128	; 0x80
 8004af0:	0109      	lsls	r1, r1, #4
 8004af2:	4301      	orrs	r1, r0
 8004af4:	60e1      	str	r1, [r4, #12]
 8004af6:	e185      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004af8:	2000      	movs	r0, #0
 8004afa:	9000      	str	r0, [sp, #0]
 8004afc:	2303      	movs	r3, #3
 8004afe:	220c      	movs	r2, #12
 8004b00:	2100      	movs	r1, #0
 8004b02:	0020      	movs	r0, r4
 8004b04:	f7fe fe35 	bl	8003772 <PE_Send_CtrlMessage>
 8004b08:	7828      	ldrb	r0, [r5, #0]
 8004b0a:	0780      	lsls	r0, r0, #30
 8004b0c:	d509      	bpl.n	8004b22 <PE_SubStateMachine_VconnSwap+0xa6>
 8004b0e:	2000      	movs	r0, #0
 8004b10:	9000      	str	r0, [sp, #0]
 8004b12:	2300      	movs	r3, #0
 8004b14:	223e      	movs	r2, #62	; 0x3e
 8004b16:	7b20      	ldrb	r0, [r4, #12]
 8004b18:	07c1      	lsls	r1, r0, #31
 8004b1a:	0fc9      	lsrs	r1, r1, #31
 8004b1c:	2009      	movs	r0, #9
 8004b1e:	68ed      	ldr	r5, [r5, #12]
 8004b20:	47a8      	blx	r5
 8004b22:	213e      	movs	r1, #62	; 0x3e
 8004b24:	e08c      	b.n	8004c40 <PE_SubStateMachine_VconnSwap+0x1c4>
 8004b26:	2000      	movs	r0, #0
 8004b28:	9000      	str	r0, [sp, #0]
 8004b2a:	2303      	movs	r3, #3
 8004b2c:	2204      	movs	r2, #4
 8004b2e:	2100      	movs	r1, #0
 8004b30:	0020      	movs	r0, r4
 8004b32:	f7fe fe1e 	bl	8003772 <PE_Send_CtrlMessage>
 8004b36:	e036      	b.n	8004ba6 <PE_SubStateMachine_VconnSwap+0x12a>
 8004b38:	2000      	movs	r0, #0
 8004b3a:	9000      	str	r0, [sp, #0]
 8004b3c:	239e      	movs	r3, #158	; 0x9e
 8004b3e:	2203      	movs	r2, #3
 8004b40:	2100      	movs	r1, #0
 8004b42:	0020      	movs	r0, r4
 8004b44:	f7fe fe15 	bl	8003772 <PE_Send_CtrlMessage>
 8004b48:	2800      	cmp	r0, #0
 8004b4a:	d1d4      	bne.n	8004af6 <PE_SubStateMachine_VconnSwap+0x7a>
 8004b4c:	2701      	movs	r7, #1
 8004b4e:	6860      	ldr	r0, [r4, #4]
 8004b50:	6800      	ldr	r0, [r0, #0]
 8004b52:	0c80      	lsrs	r0, r0, #18
 8004b54:	4038      	ands	r0, r7
 8004b56:	d006      	beq.n	8004b66 <PE_SubStateMachine_VconnSwap+0xea>
 8004b58:	209f      	movs	r0, #159	; 0x9f
 8004b5a:	7030      	strb	r0, [r6, #0]
 8004b5c:	48aa      	ldr	r0, [pc, #680]	; (8004e08 <.text_81>)
 8004b5e:	84f0      	strh	r0, [r6, #38]	; 0x26
 8004b60:	2064      	movs	r0, #100	; 0x64
 8004b62:	9001      	str	r0, [sp, #4]
 8004b64:	e001      	b.n	8004b6a <PE_SubStateMachine_VconnSwap+0xee>
 8004b66:	20a0      	movs	r0, #160	; 0xa0
 8004b68:	7030      	strb	r0, [r6, #0]
 8004b6a:	7828      	ldrb	r0, [r5, #0]
 8004b6c:	0780      	lsls	r0, r0, #30
 8004b6e:	d509      	bpl.n	8004b84 <PE_SubStateMachine_VconnSwap+0x108>
 8004b70:	2000      	movs	r0, #0
 8004b72:	9000      	str	r0, [sp, #0]
 8004b74:	2300      	movs	r3, #0
 8004b76:	223d      	movs	r2, #61	; 0x3d
 8004b78:	68e0      	ldr	r0, [r4, #12]
 8004b7a:	2101      	movs	r1, #1
 8004b7c:	4001      	ands	r1, r0
 8004b7e:	2009      	movs	r0, #9
 8004b80:	68ed      	ldr	r5, [r5, #12]
 8004b82:	47a8      	blx	r5
 8004b84:	213d      	movs	r1, #61	; 0x3d
 8004b86:	68e0      	ldr	r0, [r4, #12]
 8004b88:	4007      	ands	r7, r0
 8004b8a:	0038      	movs	r0, r7
 8004b8c:	e080      	b.n	8004c90 <PE_SubStateMachine_VconnSwap+0x214>
 8004b8e:	2703      	movs	r7, #3
 8004b90:	8cf2      	ldrh	r2, [r6, #38]	; 0x26
 8004b92:	2380      	movs	r3, #128	; 0x80
 8004b94:	021b      	lsls	r3, r3, #8
 8004b96:	429a      	cmp	r2, r3
 8004b98:	d107      	bne.n	8004baa <PE_SubStateMachine_VconnSwap+0x12e>
 8004b9a:	2000      	movs	r0, #0
 8004b9c:	84f0      	strh	r0, [r6, #38]	; 0x26
 8004b9e:	68e0      	ldr	r0, [r4, #12]
 8004ba0:	499a      	ldr	r1, [pc, #616]	; (8004e0c <.text_82>)
 8004ba2:	4001      	ands	r1, r0
 8004ba4:	60e1      	str	r1, [r4, #12]
 8004ba6:	7037      	strb	r7, [r6, #0]
 8004ba8:	e12c      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004baa:	9a02      	ldr	r2, [sp, #8]
 8004bac:	7812      	ldrb	r2, [r2, #0]
 8004bae:	2a11      	cmp	r2, #17
 8004bb0:	d1fa      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bb2:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004bb4:	0bd2      	lsrs	r2, r2, #15
 8004bb6:	d1f7      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bb8:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004bba:	0b12      	lsrs	r2, r2, #12
 8004bbc:	420a      	tst	r2, r1
 8004bbe:	d1f3      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bc0:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 8004bc2:	4008      	ands	r0, r1
 8004bc4:	2806      	cmp	r0, #6
 8004bc6:	d1ef      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bc8:	2014      	movs	r0, #20
 8004bca:	9902      	ldr	r1, [sp, #8]
 8004bcc:	7008      	strb	r0, [r1, #0]
 8004bce:	68a0      	ldr	r0, [r4, #8]
 8004bd0:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004bd2:	2a00      	cmp	r2, #0
 8004bd4:	d004      	beq.n	8004be0 <PE_SubStateMachine_VconnSwap+0x164>
 8004bd6:	2100      	movs	r1, #0
 8004bd8:	7b23      	ldrb	r3, [r4, #12]
 8004bda:	07d8      	lsls	r0, r3, #31
 8004bdc:	0fc0      	lsrs	r0, r0, #31
 8004bde:	4790      	blx	r2
 8004be0:	68e0      	ldr	r0, [r4, #12]
 8004be2:	498a      	ldr	r1, [pc, #552]	; (8004e0c <.text_82>)
 8004be4:	4001      	ands	r1, r0
 8004be6:	60e1      	str	r1, [r4, #12]
 8004be8:	7037      	strb	r7, [r6, #0]
 8004bea:	7828      	ldrb	r0, [r5, #0]
 8004bec:	0780      	lsls	r0, r0, #30
 8004bee:	d41c      	bmi.n	8004c2a <PE_SubStateMachine_VconnSwap+0x1ae>
 8004bf0:	e025      	b.n	8004c3e <PE_SubStateMachine_VconnSwap+0x1c2>
 8004bf2:	68a0      	ldr	r0, [r4, #8]
 8004bf4:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004bf6:	2a00      	cmp	r2, #0
 8004bf8:	d004      	beq.n	8004c04 <PE_SubStateMachine_VconnSwap+0x188>
 8004bfa:	2101      	movs	r1, #1
 8004bfc:	7b23      	ldrb	r3, [r4, #12]
 8004bfe:	07d8      	lsls	r0, r3, #31
 8004c00:	0fc0      	lsrs	r0, r0, #31
 8004c02:	4790      	blx	r2
 8004c04:	20a1      	movs	r0, #161	; 0xa1
 8004c06:	e0fc      	b.n	8004e02 <PE_SubStateMachine_VconnSwap+0x386>
 8004c08:	2000      	movs	r0, #0
 8004c0a:	9000      	str	r0, [sp, #0]
 8004c0c:	2303      	movs	r3, #3
 8004c0e:	2206      	movs	r2, #6
 8004c10:	2100      	movs	r1, #0
 8004c12:	0020      	movs	r0, r4
 8004c14:	f7fe fdad 	bl	8003772 <PE_Send_CtrlMessage>
 8004c18:	2800      	cmp	r0, #0
 8004c1a:	d1c5      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004c1c:	68e0      	ldr	r0, [r4, #12]
 8004c1e:	497b      	ldr	r1, [pc, #492]	; (8004e0c <.text_82>)
 8004c20:	4001      	ands	r1, r0
 8004c22:	60e1      	str	r1, [r4, #12]
 8004c24:	7828      	ldrb	r0, [r5, #0]
 8004c26:	0780      	lsls	r0, r0, #30
 8004c28:	d509      	bpl.n	8004c3e <PE_SubStateMachine_VconnSwap+0x1c2>
 8004c2a:	2000      	movs	r0, #0
 8004c2c:	9000      	str	r0, [sp, #0]
 8004c2e:	2300      	movs	r3, #0
 8004c30:	2240      	movs	r2, #64	; 0x40
 8004c32:	7b20      	ldrb	r0, [r4, #12]
 8004c34:	07c1      	lsls	r1, r0, #31
 8004c36:	0fc9      	lsrs	r1, r1, #31
 8004c38:	2009      	movs	r0, #9
 8004c3a:	68ed      	ldr	r5, [r5, #12]
 8004c3c:	47a8      	blx	r5
 8004c3e:	2140      	movs	r1, #64	; 0x40
 8004c40:	7b22      	ldrb	r2, [r4, #12]
 8004c42:	07d0      	lsls	r0, r2, #31
 8004c44:	0fc0      	lsrs	r0, r0, #31
 8004c46:	e023      	b.n	8004c90 <PE_SubStateMachine_VconnSwap+0x214>
 8004c48:	2000      	movs	r0, #0
 8004c4a:	9000      	str	r0, [sp, #0]
 8004c4c:	23a3      	movs	r3, #163	; 0xa3
 8004c4e:	220b      	movs	r2, #11
 8004c50:	2100      	movs	r1, #0
 8004c52:	0020      	movs	r0, r4
 8004c54:	f7fe fd8d 	bl	8003772 <PE_Send_CtrlMessage>
 8004c58:	2800      	cmp	r0, #0
 8004c5a:	d11c      	bne.n	8004c96 <PE_SubStateMachine_VconnSwap+0x21a>
 8004c5c:	68e1      	ldr	r1, [r4, #12]
 8004c5e:	2080      	movs	r0, #128	; 0x80
 8004c60:	0100      	lsls	r0, r0, #4
 8004c62:	4308      	orrs	r0, r1
 8004c64:	60e0      	str	r0, [r4, #12]
 8004c66:	496a      	ldr	r1, [pc, #424]	; (8004e10 <.text_83>)
 8004c68:	82b1      	strh	r1, [r6, #20]
 8004c6a:	211a      	movs	r1, #26
 8004c6c:	9101      	str	r1, [sp, #4]
 8004c6e:	2601      	movs	r6, #1
 8004c70:	7829      	ldrb	r1, [r5, #0]
 8004c72:	0789      	lsls	r1, r1, #30
 8004c74:	d508      	bpl.n	8004c88 <PE_SubStateMachine_VconnSwap+0x20c>
 8004c76:	2100      	movs	r1, #0
 8004c78:	9100      	str	r1, [sp, #0]
 8004c7a:	2300      	movs	r3, #0
 8004c7c:	223c      	movs	r2, #60	; 0x3c
 8004c7e:	2101      	movs	r1, #1
 8004c80:	4001      	ands	r1, r0
 8004c82:	2009      	movs	r0, #9
 8004c84:	68ed      	ldr	r5, [r5, #12]
 8004c86:	47a8      	blx	r5
 8004c88:	213c      	movs	r1, #60	; 0x3c
 8004c8a:	68e0      	ldr	r0, [r4, #12]
 8004c8c:	4006      	ands	r6, r0
 8004c8e:	0030      	movs	r0, r6
 8004c90:	68a2      	ldr	r2, [r4, #8]
 8004c92:	68d2      	ldr	r2, [r2, #12]
 8004c94:	4790      	blx	r2
 8004c96:	e0b5      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004c98:	200019a8 	.word	0x200019a8
 8004c9c:	9a02      	ldr	r2, [sp, #8]
 8004c9e:	7812      	ldrb	r2, [r2, #0]
 8004ca0:	2a11      	cmp	r2, #17
 8004ca2:	d110      	bne.n	8004cc6 <PE_SubStateMachine_VconnSwap+0x24a>
 8004ca4:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004ca6:	0bd2      	lsrs	r2, r2, #15
 8004ca8:	d10d      	bne.n	8004cc6 <PE_SubStateMachine_VconnSwap+0x24a>
 8004caa:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004cac:	0b12      	lsrs	r2, r2, #12
 8004cae:	420a      	tst	r2, r1
 8004cb0:	d109      	bne.n	8004cc6 <PE_SubStateMachine_VconnSwap+0x24a>
 8004cb2:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 8004cb4:	4008      	ands	r0, r1
 8004cb6:	2803      	cmp	r0, #3
 8004cb8:	d006      	beq.n	8004cc8 <PE_SubStateMachine_VconnSwap+0x24c>
 8004cba:	2804      	cmp	r0, #4
 8004cbc:	d03f      	beq.n	8004d3e <PE_SubStateMachine_VconnSwap+0x2c2>
 8004cbe:	280c      	cmp	r0, #12
 8004cc0:	d020      	beq.n	8004d04 <PE_SubStateMachine_VconnSwap+0x288>
 8004cc2:	2810      	cmp	r0, #16
 8004cc4:	d05a      	beq.n	8004d7c <PE_SubStateMachine_VconnSwap+0x300>
 8004cc6:	e080      	b.n	8004dca <PE_SubStateMachine_VconnSwap+0x34e>
 8004cc8:	2000      	movs	r0, #0
 8004cca:	82b0      	strh	r0, [r6, #20]
 8004ccc:	2701      	movs	r7, #1
 8004cce:	6860      	ldr	r0, [r4, #4]
 8004cd0:	6800      	ldr	r0, [r0, #0]
 8004cd2:	0c80      	lsrs	r0, r0, #18
 8004cd4:	4038      	ands	r0, r7
 8004cd6:	d001      	beq.n	8004cdc <PE_SubStateMachine_VconnSwap+0x260>
 8004cd8:	209f      	movs	r0, #159	; 0x9f
 8004cda:	e000      	b.n	8004cde <PE_SubStateMachine_VconnSwap+0x262>
 8004cdc:	20a0      	movs	r0, #160	; 0xa0
 8004cde:	7030      	strb	r0, [r6, #0]
 8004ce0:	2014      	movs	r0, #20
 8004ce2:	9902      	ldr	r1, [sp, #8]
 8004ce4:	7008      	strb	r0, [r1, #0]
 8004ce6:	7828      	ldrb	r0, [r5, #0]
 8004ce8:	0780      	lsls	r0, r0, #30
 8004cea:	d509      	bpl.n	8004d00 <PE_SubStateMachine_VconnSwap+0x284>
 8004cec:	2000      	movs	r0, #0
 8004cee:	9000      	str	r0, [sp, #0]
 8004cf0:	2300      	movs	r3, #0
 8004cf2:	223d      	movs	r2, #61	; 0x3d
 8004cf4:	68e0      	ldr	r0, [r4, #12]
 8004cf6:	2101      	movs	r1, #1
 8004cf8:	4001      	ands	r1, r0
 8004cfa:	2009      	movs	r0, #9
 8004cfc:	68ed      	ldr	r5, [r5, #12]
 8004cfe:	47a8      	blx	r5
 8004d00:	213d      	movs	r1, #61	; 0x3d
 8004d02:	e05c      	b.n	8004dbe <PE_SubStateMachine_VconnSwap+0x342>
 8004d04:	2000      	movs	r0, #0
 8004d06:	82b0      	strh	r0, [r6, #20]
 8004d08:	68e0      	ldr	r0, [r4, #12]
 8004d0a:	4940      	ldr	r1, [pc, #256]	; (8004e0c <.text_82>)
 8004d0c:	4001      	ands	r1, r0
 8004d0e:	60e1      	str	r1, [r4, #12]
 8004d10:	2003      	movs	r0, #3
 8004d12:	7030      	strb	r0, [r6, #0]
 8004d14:	2014      	movs	r0, #20
 8004d16:	9902      	ldr	r1, [sp, #8]
 8004d18:	7008      	strb	r0, [r1, #0]
 8004d1a:	7828      	ldrb	r0, [r5, #0]
 8004d1c:	0780      	lsls	r0, r0, #30
 8004d1e:	d509      	bpl.n	8004d34 <PE_SubStateMachine_VconnSwap+0x2b8>
 8004d20:	2000      	movs	r0, #0
 8004d22:	9000      	str	r0, [sp, #0]
 8004d24:	2300      	movs	r3, #0
 8004d26:	223e      	movs	r2, #62	; 0x3e
 8004d28:	7b20      	ldrb	r0, [r4, #12]
 8004d2a:	07c1      	lsls	r1, r0, #31
 8004d2c:	0fc9      	lsrs	r1, r1, #31
 8004d2e:	2009      	movs	r0, #9
 8004d30:	68ed      	ldr	r5, [r5, #12]
 8004d32:	47a8      	blx	r5
 8004d34:	213e      	movs	r1, #62	; 0x3e
 8004d36:	7b22      	ldrb	r2, [r4, #12]
 8004d38:	07d0      	lsls	r0, r2, #31
 8004d3a:	0fc0      	lsrs	r0, r0, #31
 8004d3c:	e042      	b.n	8004dc4 <PE_SubStateMachine_VconnSwap+0x348>
 8004d3e:	2000      	movs	r0, #0
 8004d40:	82b0      	strh	r0, [r6, #20]
 8004d42:	68e0      	ldr	r0, [r4, #12]
 8004d44:	4931      	ldr	r1, [pc, #196]	; (8004e0c <.text_82>)
 8004d46:	4001      	ands	r1, r0
 8004d48:	60e1      	str	r1, [r4, #12]
 8004d4a:	2003      	movs	r0, #3
 8004d4c:	7030      	strb	r0, [r6, #0]
 8004d4e:	2014      	movs	r0, #20
 8004d50:	9902      	ldr	r1, [sp, #8]
 8004d52:	7008      	strb	r0, [r1, #0]
 8004d54:	7828      	ldrb	r0, [r5, #0]
 8004d56:	0780      	lsls	r0, r0, #30
 8004d58:	d509      	bpl.n	8004d6e <PE_SubStateMachine_VconnSwap+0x2f2>
 8004d5a:	2000      	movs	r0, #0
 8004d5c:	9000      	str	r0, [sp, #0]
 8004d5e:	2300      	movs	r3, #0
 8004d60:	223f      	movs	r2, #63	; 0x3f
 8004d62:	7b20      	ldrb	r0, [r4, #12]
 8004d64:	07c1      	lsls	r1, r0, #31
 8004d66:	0fc9      	lsrs	r1, r1, #31
 8004d68:	2009      	movs	r0, #9
 8004d6a:	68ef      	ldr	r7, [r5, #12]
 8004d6c:	47b8      	blx	r7
 8004d6e:	213f      	movs	r1, #63	; 0x3f
 8004d70:	7b22      	ldrb	r2, [r4, #12]
 8004d72:	07d0      	lsls	r0, r2, #31
 8004d74:	0fc0      	lsrs	r0, r0, #31
 8004d76:	68a2      	ldr	r2, [r4, #8]
 8004d78:	68d2      	ldr	r2, [r2, #12]
 8004d7a:	4790      	blx	r2
 8004d7c:	2000      	movs	r0, #0
 8004d7e:	82b0      	strh	r0, [r6, #20]
 8004d80:	2701      	movs	r7, #1
 8004d82:	6860      	ldr	r0, [r4, #4]
 8004d84:	6800      	ldr	r0, [r0, #0]
 8004d86:	0c80      	lsrs	r0, r0, #18
 8004d88:	4038      	ands	r0, r7
 8004d8a:	d101      	bne.n	8004d90 <PE_SubStateMachine_VconnSwap+0x314>
 8004d8c:	20a4      	movs	r0, #164	; 0xa4
 8004d8e:	e004      	b.n	8004d9a <PE_SubStateMachine_VconnSwap+0x31e>
 8004d90:	68e0      	ldr	r0, [r4, #12]
 8004d92:	491e      	ldr	r1, [pc, #120]	; (8004e0c <.text_82>)
 8004d94:	4001      	ands	r1, r0
 8004d96:	60e1      	str	r1, [r4, #12]
 8004d98:	2003      	movs	r0, #3
 8004d9a:	7030      	strb	r0, [r6, #0]
 8004d9c:	2014      	movs	r0, #20
 8004d9e:	9902      	ldr	r1, [sp, #8]
 8004da0:	7008      	strb	r0, [r1, #0]
 8004da2:	7828      	ldrb	r0, [r5, #0]
 8004da4:	0780      	lsls	r0, r0, #30
 8004da6:	d509      	bpl.n	8004dbc <PE_SubStateMachine_VconnSwap+0x340>
 8004da8:	2000      	movs	r0, #0
 8004daa:	9000      	str	r0, [sp, #0]
 8004dac:	2300      	movs	r3, #0
 8004dae:	2255      	movs	r2, #85	; 0x55
 8004db0:	68e0      	ldr	r0, [r4, #12]
 8004db2:	2101      	movs	r1, #1
 8004db4:	4001      	ands	r1, r0
 8004db6:	2009      	movs	r0, #9
 8004db8:	68ed      	ldr	r5, [r5, #12]
 8004dba:	47a8      	blx	r5
 8004dbc:	2155      	movs	r1, #85	; 0x55
 8004dbe:	68e0      	ldr	r0, [r4, #12]
 8004dc0:	4007      	ands	r7, r0
 8004dc2:	0038      	movs	r0, r7
 8004dc4:	68a2      	ldr	r2, [r4, #8]
 8004dc6:	68d2      	ldr	r2, [r2, #12]
 8004dc8:	4790      	blx	r2
 8004dca:	8ab0      	ldrh	r0, [r6, #20]
 8004dcc:	2180      	movs	r1, #128	; 0x80
 8004dce:	0209      	lsls	r1, r1, #8
 8004dd0:	4288      	cmp	r0, r1
 8004dd2:	d117      	bne.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004dd4:	2000      	movs	r0, #0
 8004dd6:	82b0      	strh	r0, [r6, #20]
 8004dd8:	e00e      	b.n	8004df8 <PE_SubStateMachine_VconnSwap+0x37c>
 8004dda:	68a0      	ldr	r0, [r4, #8]
 8004ddc:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004dde:	2a00      	cmp	r2, #0
 8004de0:	d004      	beq.n	8004dec <PE_SubStateMachine_VconnSwap+0x370>
 8004de2:	2101      	movs	r1, #1
 8004de4:	7b23      	ldrb	r3, [r4, #12]
 8004de6:	07d8      	lsls	r0, r3, #31
 8004de8:	0fc0      	lsrs	r0, r0, #31
 8004dea:	4790      	blx	r2
 8004dec:	6860      	ldr	r0, [r4, #4]
 8004dee:	6801      	ldr	r1, [r0, #0]
 8004df0:	2280      	movs	r2, #128	; 0x80
 8004df2:	02d2      	lsls	r2, r2, #11
 8004df4:	430a      	orrs	r2, r1
 8004df6:	6002      	str	r2, [r0, #0]
 8004df8:	68e0      	ldr	r0, [r4, #12]
 8004dfa:	4904      	ldr	r1, [pc, #16]	; (8004e0c <.text_82>)
 8004dfc:	4001      	ands	r1, r0
 8004dfe:	60e1      	str	r1, [r4, #12]
 8004e00:	2003      	movs	r0, #3
 8004e02:	7030      	strb	r0, [r6, #0]
 8004e04:	9801      	ldr	r0, [sp, #4]
 8004e06:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08004e08 <.text_81>:
 8004e08:	00008064 	.word	0x00008064

08004e0c <.text_82>:
 8004e0c:	fffff7ff 	.word	0xfffff7ff

08004e10 <.text_83>:
 8004e10:	0000801a 	.word	0x0000801a

08004e14 <USBPD_PE_ExecFastRoleSwapSignalling>:
 8004e14:	b580      	push	{r7, lr}
 8004e16:	f000 f8bc 	bl	8004f92 <USBPD_PRL_FastRoleSwapSignalling>
 8004e1a:	bd01      	pop	{r0, pc}

08004e1c <USBPD_PRL_TimerCounter>:
 8004e1c:	b081      	sub	sp, #4
 8004e1e:	4965      	ldr	r1, [pc, #404]	; (8004fb4 <.text_17>)
 8004e20:	0080      	lsls	r0, r0, #2
 8004e22:	1808      	adds	r0, r1, r0
 8004e24:	6841      	ldr	r1, [r0, #4]
 8004e26:	7a8a      	ldrb	r2, [r1, #10]
 8004e28:	2a00      	cmp	r2, #0
 8004e2a:	d001      	beq.n	8004e30 <USBPD_PRL_TimerCounter+0x14>
 8004e2c:	1e52      	subs	r2, r2, #1
 8004e2e:	728a      	strb	r2, [r1, #10]
 8004e30:	6840      	ldr	r0, [r0, #4]
 8004e32:	8e81      	ldrh	r1, [r0, #52]	; 0x34
 8004e34:	2900      	cmp	r1, #0
 8004e36:	d001      	beq.n	8004e3c <USBPD_PRL_TimerCounter+0x20>
 8004e38:	1e49      	subs	r1, r1, #1
 8004e3a:	8681      	strh	r1, [r0, #52]	; 0x34
 8004e3c:	b001      	add	sp, #4
 8004e3e:	4770      	bx	lr

08004e40 <USBPD_PRL_Init>:
 8004e40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8004e42:	b082      	sub	sp, #8
 8004e44:	001c      	movs	r4, r3
 8004e46:	4668      	mov	r0, sp
 8004e48:	7a00      	ldrb	r0, [r0, #8]
 8004e4a:	2801      	cmp	r0, #1
 8004e4c:	d83a      	bhi.n	8004ec4 <USBPD_PRL_Init+0x84>
 8004e4e:	2038      	movs	r0, #56	; 0x38
 8004e50:	f007 fe22 	bl	800ca98 <malloc>
 8004e54:	4957      	ldr	r1, [pc, #348]	; (8004fb4 <.text_17>)
 8004e56:	466a      	mov	r2, sp
 8004e58:	7a12      	ldrb	r2, [r2, #8]
 8004e5a:	0092      	lsls	r2, r2, #2
 8004e5c:	188d      	adds	r5, r1, r2
 8004e5e:	6068      	str	r0, [r5, #4]
 8004e60:	2800      	cmp	r0, #0
 8004e62:	d101      	bne.n	8004e68 <USBPD_PRL_Init+0x28>
 8004e64:	2016      	movs	r0, #22
 8004e66:	e02e      	b.n	8004ec6 <USBPD_PRL_Init+0x86>
 8004e68:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8004e6a:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8004e6c:	4669      	mov	r1, sp
 8004e6e:	710c      	strb	r4, [r1, #4]
 8004e70:	2138      	movs	r1, #56	; 0x38
 8004e72:	f007 fde1 	bl	800ca38 <__aeabi_memclr>
 8004e76:	6868      	ldr	r0, [r5, #4]
 8004e78:	2400      	movs	r4, #0
 8004e7a:	7104      	strb	r4, [r0, #4]
 8004e7c:	7144      	strb	r4, [r0, #5]
 8004e7e:	6006      	str	r6, [r0, #0]
 8004e80:	7284      	strb	r4, [r0, #10]
 8004e82:	6869      	ldr	r1, [r5, #4]
 8004e84:	72cc      	strb	r4, [r1, #11]
 8004e86:	220f      	movs	r2, #15
 8004e88:	2103      	movs	r1, #3
 8004e8a:	6868      	ldr	r0, [r5, #4]
 8004e8c:	1d80      	adds	r0, r0, #6
 8004e8e:	f007 fdd8 	bl	800ca42 <__aeabi_memset>
 8004e92:	6869      	ldr	r1, [r5, #4]
 8004e94:	730c      	strb	r4, [r1, #12]
 8004e96:	6868      	ldr	r0, [r5, #4]
 8004e98:	9904      	ldr	r1, [sp, #16]
 8004e9a:	62c1      	str	r1, [r0, #44]	; 0x2c
 8004e9c:	990a      	ldr	r1, [sp, #40]	; 0x28
 8004e9e:	6281      	str	r1, [r0, #40]	; 0x28
 8004ea0:	6247      	str	r7, [r0, #36]	; 0x24
 8004ea2:	9903      	ldr	r1, [sp, #12]
 8004ea4:	6301      	str	r1, [r0, #48]	; 0x30
 8004ea6:	7344      	strb	r4, [r0, #13]
 8004ea8:	6868      	ldr	r0, [r5, #4]
 8004eaa:	7384      	strb	r4, [r0, #14]
 8004eac:	2001      	movs	r0, #1
 8004eae:	9000      	str	r0, [sp, #0]
 8004eb0:	4668      	mov	r0, sp
 8004eb2:	7903      	ldrb	r3, [r0, #4]
 8004eb4:	6868      	ldr	r0, [r5, #4]
 8004eb6:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8004eb8:	a104      	add	r1, pc, #16	; (adr r1, 8004ecc <PRL_PhyCallbacks>)
 8004eba:	4668      	mov	r0, sp
 8004ebc:	7a00      	ldrb	r0, [r0, #8]
 8004ebe:	f004 fe69 	bl	8009b94 <USBPD_PHY_Init>
 8004ec2:	e000      	b.n	8004ec6 <USBPD_PRL_Init+0x86>
 8004ec4:	2002      	movs	r0, #2
 8004ec6:	b005      	add	sp, #20
 8004ec8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08004ecc <PRL_PhyCallbacks>:
 8004ecc:	54af 0800 57d1 0800 5819 0800 5827 0800     .T...W...X..'X..
 8004edc:	5839 0800 5855 0800                         9X..UX..

08004ee4 <USBPD_PRL_GetMemoryConsumption>:
 8004ee4:	2070      	movs	r0, #112	; 0x70
 8004ee6:	4770      	bx	lr

08004ee8 <USBPD_PRL_SetHeader>:
 8004ee8:	b530      	push	{r4, r5, lr}
 8004eea:	4c32      	ldr	r4, [pc, #200]	; (8004fb4 <.text_17>)
 8004eec:	0080      	lsls	r0, r0, #2
 8004eee:	1820      	adds	r0, r4, r0
 8004ef0:	6840      	ldr	r0, [r0, #4]
 8004ef2:	8a84      	ldrh	r4, [r0, #20]
 8004ef4:	4d30      	ldr	r5, [pc, #192]	; (8004fb8 <.text_18>)
 8004ef6:	4025      	ands	r5, r4
 8004ef8:	0209      	lsls	r1, r1, #8
 8004efa:	2480      	movs	r4, #128	; 0x80
 8004efc:	0064      	lsls	r4, r4, #1
 8004efe:	4021      	ands	r1, r4
 8004f00:	4329      	orrs	r1, r5
 8004f02:	8281      	strh	r1, [r0, #20]
 8004f04:	4c2d      	ldr	r4, [pc, #180]	; (8004fbc <.text_19>)
 8004f06:	400c      	ands	r4, r1
 8004f08:	0151      	lsls	r1, r2, #5
 8004f0a:	2220      	movs	r2, #32
 8004f0c:	4011      	ands	r1, r2
 8004f0e:	4321      	orrs	r1, r4
 8004f10:	8281      	strh	r1, [r0, #20]
 8004f12:	4a2b      	ldr	r2, [pc, #172]	; (8004fc0 <.text_20>)
 8004f14:	400a      	ands	r2, r1
 8004f16:	0199      	lsls	r1, r3, #6
 8004f18:	23c0      	movs	r3, #192	; 0xc0
 8004f1a:	400b      	ands	r3, r1
 8004f1c:	4313      	orrs	r3, r2
 8004f1e:	8283      	strh	r3, [r0, #20]
 8004f20:	bd30      	pop	{r4, r5, pc}

08004f22 <USBPD_PRL_SetHeaderPowerRole>:
 8004f22:	4a24      	ldr	r2, [pc, #144]	; (8004fb4 <.text_17>)
 8004f24:	0080      	lsls	r0, r0, #2
 8004f26:	1810      	adds	r0, r2, r0
 8004f28:	6840      	ldr	r0, [r0, #4]
 8004f2a:	8a82      	ldrh	r2, [r0, #20]
 8004f2c:	4b22      	ldr	r3, [pc, #136]	; (8004fb8 <.text_18>)
 8004f2e:	4013      	ands	r3, r2
 8004f30:	0209      	lsls	r1, r1, #8
 8004f32:	2280      	movs	r2, #128	; 0x80
 8004f34:	0052      	lsls	r2, r2, #1
 8004f36:	e008      	b.n	8004f4a <.text_10>

08004f38 <USBPD_PRL_SetHeaderDataRole>:
 8004f38:	4a1e      	ldr	r2, [pc, #120]	; (8004fb4 <.text_17>)
 8004f3a:	0080      	lsls	r0, r0, #2
 8004f3c:	1810      	adds	r0, r2, r0
 8004f3e:	6840      	ldr	r0, [r0, #4]
 8004f40:	8a82      	ldrh	r2, [r0, #20]
 8004f42:	4b1e      	ldr	r3, [pc, #120]	; (8004fbc <.text_19>)
 8004f44:	4013      	ands	r3, r2
 8004f46:	0149      	lsls	r1, r1, #5
 8004f48:	2220      	movs	r2, #32

08004f4a <.text_10>:
 8004f4a:	4011      	ands	r1, r2
 8004f4c:	4319      	orrs	r1, r3
 8004f4e:	8281      	strh	r1, [r0, #20]
 8004f50:	4770      	bx	lr

08004f52 <USBPD_PRL_SetHeaderSpecification>:
 8004f52:	4a18      	ldr	r2, [pc, #96]	; (8004fb4 <.text_17>)
 8004f54:	0080      	lsls	r0, r0, #2
 8004f56:	1810      	adds	r0, r2, r0
 8004f58:	6840      	ldr	r0, [r0, #4]
 8004f5a:	8a82      	ldrh	r2, [r0, #20]
 8004f5c:	4b18      	ldr	r3, [pc, #96]	; (8004fc0 <.text_20>)
 8004f5e:	4013      	ands	r3, r2
 8004f60:	0189      	lsls	r1, r1, #6
 8004f62:	22c0      	movs	r2, #192	; 0xc0
 8004f64:	400a      	ands	r2, r1
 8004f66:	431a      	orrs	r2, r3
 8004f68:	8282      	strh	r2, [r0, #20]
 8004f6a:	4770      	bx	lr

08004f6c <USBPD_PRL_SRCSetSinkNG>:
 8004f6c:	b580      	push	{r7, lr}
 8004f6e:	f004 fde5 	bl	8009b3c <USBPD_PHY_SetResistor_SinkTxNG>
 8004f72:	bd01      	pop	{r0, pc}

08004f74 <USBPD_PRL_SRCReleaseSinkNG>:
 8004f74:	b510      	push	{r4, lr}
 8004f76:	0004      	movs	r4, r0
 8004f78:	f004 fde8 	bl	8009b4c <USBPD_PHY_SetResistor_SinkTxOK>
 8004f7c:	480d      	ldr	r0, [pc, #52]	; (8004fb4 <.text_17>)
 8004f7e:	00a1      	lsls	r1, r4, #2
 8004f80:	1840      	adds	r0, r0, r1
 8004f82:	6840      	ldr	r0, [r0, #4]
 8004f84:	2106      	movs	r1, #6
 8004f86:	7101      	strb	r1, [r0, #4]
 8004f88:	bd10      	pop	{r4, pc}

08004f8a <USBPD_PRL_IsResistor_SinkTxOK>:
 8004f8a:	b580      	push	{r7, lr}
 8004f8c:	f004 fde7 	bl	8009b5e <USBPD_PHY_IsResistor_SinkTxOk>
 8004f90:	bd02      	pop	{r1, pc}

08004f92 <USBPD_PRL_FastRoleSwapSignalling>:
 8004f92:	b580      	push	{r7, lr}
 8004f94:	f004 fde7 	bl	8009b66 <USBPD_PHY_FastRoleSwapSignalling>
 8004f98:	bd01      	pop	{r0, pc}

08004f9a <USBPD_PRL_CableCapable>:
 8004f9a:	b580      	push	{r7, lr}
 8004f9c:	2901      	cmp	r1, #1
 8004f9e:	d105      	bne.n	8004fac <USBPD_PRL_CableCapable+0x12>
 8004fa0:	4904      	ldr	r1, [pc, #16]	; (8004fb4 <.text_17>)
 8004fa2:	0082      	lsls	r2, r0, #2
 8004fa4:	1889      	adds	r1, r1, r2
 8004fa6:	6849      	ldr	r1, [r1, #4]
 8004fa8:	6809      	ldr	r1, [r1, #0]
 8004faa:	e000      	b.n	8004fae <USBPD_PRL_CableCapable+0x14>
 8004fac:	2101      	movs	r1, #1
 8004fae:	f004 fdd5 	bl	8009b5c <USBPD_PHY_SOPSupported>
 8004fb2:	bd01      	pop	{r0, pc}

08004fb4 <.text_17>:
 8004fb4:	200019bc 	.word	0x200019bc

08004fb8 <.text_18>:
 8004fb8:	0000feff 	.word	0x0000feff

08004fbc <.text_19>:
 8004fbc:	0000ffdf 	.word	0x0000ffdf

08004fc0 <.text_20>:
 8004fc0:	0000ff3f 	.word	0x0000ff3f

08004fc4 <USBPD_PRL_SendMessage>:
 8004fc4:	b5f5      	push	{r0, r2, r4, r5, r6, r7, lr}
 8004fc6:	b083      	sub	sp, #12
 8004fc8:	2703      	movs	r7, #3
 8004fca:	48b2      	ldr	r0, [pc, #712]	; (8005294 <USBPD_PRL_SendMessage+0x2d0>)
 8004fcc:	466a      	mov	r2, sp
 8004fce:	7b12      	ldrb	r2, [r2, #12]
 8004fd0:	0092      	lsls	r2, r2, #2
 8004fd2:	1884      	adds	r4, r0, r2
 8004fd4:	6860      	ldr	r0, [r4, #4]
 8004fd6:	7a42      	ldrb	r2, [r0, #9]
 8004fd8:	2a00      	cmp	r2, #0
 8004fda:	d104      	bne.n	8004fe6 <USBPD_PRL_SendMessage+0x22>
 8004fdc:	7902      	ldrb	r2, [r0, #4]
 8004fde:	2a06      	cmp	r2, #6
 8004fe0:	dd01      	ble.n	8004fe6 <USBPD_PRL_SendMessage+0x22>
 8004fe2:	220e      	movs	r2, #14
 8004fe4:	7102      	strb	r2, [r0, #4]
 8004fe6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8004fe8:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8004fea:	9302      	str	r3, [sp, #8]
 8004fec:	466b      	mov	r3, sp
 8004fee:	7119      	strb	r1, [r3, #4]
 8004ff0:	9200      	str	r2, [sp, #0]
 8004ff2:	2606      	movs	r6, #6
 8004ff4:	2200      	movs	r2, #0
 8004ff6:	7901      	ldrb	r1, [r0, #4]
 8004ff8:	290f      	cmp	r1, #15
 8004ffa:	d900      	bls.n	8004ffe <USBPD_PRL_SendMessage+0x3a>
 8004ffc:	e1c0      	b.n	8005380 <USBPD_PRL_SendMessage+0x3bc>
 8004ffe:	a302      	add	r3, pc, #8	; (adr r3, 8005008 <USBPD_PRL_SendMessage+0x44>)
 8005000:	0049      	lsls	r1, r1, #1
 8005002:	5a5b      	ldrh	r3, [r3, r1]
 8005004:	449f      	add	pc, r3
 8005006:	bf00      	nop
 8005008:	002e0020 	.word	0x002e0020
 800500c:	03780042 	.word	0x03780042
 8005010:	00900052 	.word	0x00900052
 8005014:	011e0078 	.word	0x011e0078
 8005018:	02900130 	.word	0x02900130
 800501c:	02dc02b6 	.word	0x02dc02b6
 8005020:	037802fc 	.word	0x037802fc
 8005024:	032e0372 	.word	0x032e0372
 8005028:	4668      	mov	r0, sp
 800502a:	7b00      	ldrb	r0, [r0, #12]
 800502c:	f004 fdae 	bl	8009b8c <USBPD_PHY_Reset>
 8005030:	6860      	ldr	r0, [r4, #4]
 8005032:	7106      	strb	r6, [r0, #4]
 8005034:	e1a6      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005036:	4668      	mov	r0, sp
 8005038:	7b00      	ldrb	r0, [r0, #12]
 800503a:	f004 fd7f 	bl	8009b3c <USBPD_PHY_SetResistor_SinkTxNG>
 800503e:	6860      	ldr	r0, [r4, #4]
 8005040:	2102      	movs	r1, #2
 8005042:	7101      	strb	r1, [r0, #4]
 8005044:	2111      	movs	r1, #17
 8005046:	8681      	strh	r1, [r0, #52]	; 0x34
 8005048:	e19c      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 800504a:	9900      	ldr	r1, [sp, #0]
 800504c:	2901      	cmp	r1, #1
 800504e:	d1ef      	bne.n	8005030 <USBPD_PRL_SendMessage+0x6c>
 8005050:	8e81      	ldrh	r1, [r0, #52]	; 0x34
 8005052:	2900      	cmp	r1, #0
 8005054:	d112      	bne.n	800507c <USBPD_PRL_SendMessage+0xb8>
 8005056:	2105      	movs	r1, #5
 8005058:	e168      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 800505a:	9800      	ldr	r0, [sp, #0]
 800505c:	2802      	cmp	r0, #2
 800505e:	d1e7      	bne.n	8005030 <USBPD_PRL_SendMessage+0x6c>
 8005060:	4668      	mov	r0, sp
 8005062:	7b00      	ldrb	r0, [r0, #12]
 8005064:	f004 fd7b 	bl	8009b5e <USBPD_PHY_IsResistor_SinkTxOk>
 8005068:	2801      	cmp	r0, #1
 800506a:	d107      	bne.n	800507c <USBPD_PRL_SendMessage+0xb8>
 800506c:	2005      	movs	r0, #5
 800506e:	6861      	ldr	r1, [r4, #4]
 8005070:	7108      	strb	r0, [r1, #4]
 8005072:	4668      	mov	r0, sp
 8005074:	7b00      	ldrb	r0, [r0, #12]
 8005076:	f004 fd72 	bl	8009b5e <USBPD_PHY_IsResistor_SinkTxOk>
 800507a:	e183      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 800507c:	2009      	movs	r0, #9
 800507e:	e182      	b.n	8005386 <USBPD_PRL_SendMessage+0x3c2>
 8005080:	8a81      	ldrh	r1, [r0, #20]
 8005082:	0609      	lsls	r1, r1, #24
 8005084:	0f89      	lsrs	r1, r1, #30
 8005086:	2902      	cmp	r1, #2
 8005088:	d106      	bne.n	8005098 <USBPD_PRL_SendMessage+0xd4>
 800508a:	9900      	ldr	r1, [sp, #0]
 800508c:	2901      	cmp	r1, #1
 800508e:	d002      	beq.n	8005096 <USBPD_PRL_SendMessage+0xd2>
 8005090:	2902      	cmp	r1, #2
 8005092:	d101      	bne.n	8005098 <USBPD_PRL_SendMessage+0xd4>
 8005094:	2104      	movs	r1, #4
 8005096:	e149      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 8005098:	4669      	mov	r1, sp
 800509a:	7c09      	ldrb	r1, [r1, #16]
 800509c:	23ff      	movs	r3, #255	; 0xff
 800509e:	7243      	strb	r3, [r0, #9]
 80050a0:	8a86      	ldrh	r6, [r0, #20]
 80050a2:	4bbd      	ldr	r3, [pc, #756]	; (8005398 <.text_23>)
 80050a4:	4033      	ands	r3, r6
 80050a6:	06ce      	lsls	r6, r1, #27
 80050a8:	0ef6      	lsrs	r6, r6, #27
 80050aa:	431e      	orrs	r6, r3
 80050ac:	8286      	strh	r6, [r0, #20]
 80050ae:	0473      	lsls	r3, r6, #17
 80050b0:	0c5b      	lsrs	r3, r3, #17
 80050b2:	09ce      	lsrs	r6, r1, #7
 80050b4:	03f6      	lsls	r6, r6, #15
 80050b6:	431e      	orrs	r6, r3
 80050b8:	8286      	strh	r6, [r0, #20]
 80050ba:	7302      	strb	r2, [r0, #12]
 80050bc:	6860      	ldr	r0, [r4, #4]
 80050be:	8a83      	ldrh	r3, [r0, #20]
 80050c0:	0bdc      	lsrs	r4, r3, #15
 80050c2:	d018      	beq.n	80050f6 <USBPD_PRL_SendMessage+0x132>
 80050c4:	9b02      	ldr	r3, [sp, #8]
 80050c6:	789b      	ldrb	r3, [r3, #2]
 80050c8:	9c02      	ldr	r4, [sp, #8]
 80050ca:	78e4      	ldrb	r4, [r4, #3]
 80050cc:	0224      	lsls	r4, r4, #8
 80050ce:	191b      	adds	r3, r3, r4
 80050d0:	8343      	strh	r3, [r0, #26]
 80050d2:	8b43      	ldrh	r3, [r0, #26]
 80050d4:	0a9c      	lsrs	r4, r3, #10
 80050d6:	07e4      	lsls	r4, r4, #31
 80050d8:	d41a      	bmi.n	8005110 <USBPD_PRL_SendMessage+0x14c>
 80050da:	0ada      	lsrs	r2, r3, #11
 80050dc:	0712      	lsls	r2, r2, #28
 80050de:	d118      	bne.n	8005112 <USBPD_PRL_SendMessage+0x14e>
 80050e0:	1f2a      	subs	r2, r5, #4
 80050e2:	8402      	strh	r2, [r0, #32]
 80050e4:	05d2      	lsls	r2, r2, #23
 80050e6:	0dd2      	lsrs	r2, r2, #23
 80050e8:	8b43      	ldrh	r3, [r0, #26]
 80050ea:	24fe      	movs	r4, #254	; 0xfe
 80050ec:	0224      	lsls	r4, r4, #8
 80050ee:	401c      	ands	r4, r3
 80050f0:	4322      	orrs	r2, r4
 80050f2:	8342      	strh	r2, [r0, #26]
 80050f4:	e00d      	b.n	8005112 <USBPD_PRL_SendMessage+0x14e>
 80050f6:	1eac      	subs	r4, r5, #2
 80050f8:	4da8      	ldr	r5, [pc, #672]	; (800539c <.text_24>)
 80050fa:	401d      	ands	r5, r3
 80050fc:	1063      	asrs	r3, r4, #1
 80050fe:	0f9b      	lsrs	r3, r3, #30
 8005100:	191b      	adds	r3, r3, r4
 8005102:	109b      	asrs	r3, r3, #2
 8005104:	031b      	lsls	r3, r3, #12
 8005106:	24e0      	movs	r4, #224	; 0xe0
 8005108:	01e4      	lsls	r4, r4, #7
 800510a:	401c      	ands	r4, r3
 800510c:	432c      	orrs	r4, r5
 800510e:	8284      	strh	r4, [r0, #20]
 8005110:	8402      	strh	r2, [r0, #32]
 8005112:	290d      	cmp	r1, #13
 8005114:	d103      	bne.n	800511e <USBPD_PRL_SendMessage+0x15a>
 8005116:	8a81      	ldrh	r1, [r0, #20]
 8005118:	22f0      	movs	r2, #240	; 0xf0
 800511a:	0212      	lsls	r2, r2, #8
 800511c:	400a      	ands	r2, r1
 800511e:	d000      	beq.n	8005122 <USBPD_PRL_SendMessage+0x15e>
 8005120:	e103      	b.n	800532a <USBPD_PRL_SendMessage+0x366>
 8005122:	2107      	movs	r1, #7
 8005124:	e102      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 8005126:	72c2      	strb	r2, [r0, #11]
 8005128:	220f      	movs	r2, #15
 800512a:	2103      	movs	r1, #3
 800512c:	6860      	ldr	r0, [r4, #4]
 800512e:	1d80      	adds	r0, r0, #6
 8005130:	f007 fc87 	bl	800ca42 <__aeabi_memset>
 8005134:	2008      	movs	r0, #8
 8005136:	e0bf      	b.n	80052b8 <USBPD_PRL_SendMessage+0x2f4>
 8005138:	8a81      	ldrh	r1, [r0, #20]
 800513a:	0bc9      	lsrs	r1, r1, #15
 800513c:	d06f      	beq.n	800521e <USBPD_PRL_SendMessage+0x25a>
 800513e:	8b41      	ldrh	r1, [r0, #26]
 8005140:	0a89      	lsrs	r1, r1, #10
 8005142:	07c9      	lsls	r1, r1, #31
 8005144:	d462      	bmi.n	800520c <USBPD_PRL_SendMessage+0x248>
 8005146:	8c03      	ldrh	r3, [r0, #32]
 8005148:	2b1b      	cmp	r3, #27
 800514a:	d302      	bcc.n	8005152 <USBPD_PRL_SendMessage+0x18e>
 800514c:	8b41      	ldrh	r1, [r0, #26]
 800514e:	0bc9      	lsrs	r1, r1, #15
 8005150:	d153      	bne.n	80051fa <USBPD_PRL_SendMessage+0x236>
 8005152:	4950      	ldr	r1, [pc, #320]	; (8005294 <USBPD_PRL_SendMessage+0x2d0>)
 8005154:	466e      	mov	r6, sp
 8005156:	7b36      	ldrb	r6, [r6, #12]
 8005158:	00b6      	lsls	r6, r6, #2
 800515a:	1989      	adds	r1, r1, r6
 800515c:	6849      	ldr	r1, [r1, #4]
 800515e:	8b49      	ldrh	r1, [r1, #26]
 8005160:	0ace      	lsrs	r6, r1, #11
 8005162:	0736      	lsls	r6, r6, #28
 8005164:	d106      	bne.n	8005174 <USBPD_PRL_SendMessage+0x1b0>
 8005166:	26fe      	movs	r6, #254	; 0xfe
 8005168:	0236      	lsls	r6, r6, #8
 800516a:	400e      	ands	r6, r1
 800516c:	05d9      	lsls	r1, r3, #23
 800516e:	0dc9      	lsrs	r1, r1, #23
 8005170:	4331      	orrs	r1, r6
 8005172:	8341      	strh	r1, [r0, #26]
 8005174:	8a83      	ldrh	r3, [r0, #20]
 8005176:	4989      	ldr	r1, [pc, #548]	; (800539c <.text_24>)
 8005178:	4019      	ands	r1, r3
 800517a:	8281      	strh	r1, [r0, #20]
 800517c:	8b43      	ldrh	r3, [r0, #26]
 800517e:	0bdb      	lsrs	r3, r3, #15
 8005180:	d038      	beq.n	80051f4 <USBPD_PRL_SendMessage+0x230>
 8005182:	8c03      	ldrh	r3, [r0, #32]
 8005184:	1c9b      	adds	r3, r3, #2
 8005186:	105d      	asrs	r5, r3, #1
 8005188:	0fad      	lsrs	r5, r5, #30
 800518a:	18eb      	adds	r3, r5, r3
 800518c:	109b      	asrs	r3, r3, #2
 800518e:	031b      	lsls	r3, r3, #12
 8005190:	25e0      	movs	r5, #224	; 0xe0
 8005192:	01ed      	lsls	r5, r5, #7
 8005194:	401d      	ands	r5, r3
 8005196:	430d      	orrs	r5, r1
 8005198:	8285      	strh	r5, [r0, #20]
 800519a:	8c00      	ldrh	r0, [r0, #32]
 800519c:	1c81      	adds	r1, r0, #2
 800519e:	1c80      	adds	r0, r0, #2
 80051a0:	104b      	asrs	r3, r1, #1
 80051a2:	0f9b      	lsrs	r3, r3, #30
 80051a4:	1859      	adds	r1, r3, r1
 80051a6:	1089      	asrs	r1, r1, #2
 80051a8:	0089      	lsls	r1, r1, #2
 80051aa:	1a40      	subs	r0, r0, r1
 80051ac:	b2c0      	uxtb	r0, r0
 80051ae:	2800      	cmp	r0, #0
 80051b0:	d01a      	beq.n	80051e8 <USBPD_PRL_SendMessage+0x224>
 80051b2:	2500      	movs	r5, #0
 80051b4:	9000      	str	r0, [sp, #0]
 80051b6:	e005      	b.n	80051c4 <USBPD_PRL_SendMessage+0x200>
 80051b8:	9902      	ldr	r1, [sp, #8]
 80051ba:	1d09      	adds	r1, r1, #4
 80051bc:	8c1b      	ldrh	r3, [r3, #32]
 80051be:	1818      	adds	r0, r3, r0
 80051c0:	540a      	strb	r2, [r1, r0]
 80051c2:	1c6d      	adds	r5, r5, #1
 80051c4:	6863      	ldr	r3, [r4, #4]
 80051c6:	b2e8      	uxtb	r0, r5
 80051c8:	2104      	movs	r1, #4
 80051ca:	9e00      	ldr	r6, [sp, #0]
 80051cc:	1b89      	subs	r1, r1, r6
 80051ce:	4288      	cmp	r0, r1
 80051d0:	dbf2      	blt.n	80051b8 <USBPD_PRL_SendMessage+0x1f4>
 80051d2:	8a99      	ldrh	r1, [r3, #20]
 80051d4:	4871      	ldr	r0, [pc, #452]	; (800539c <.text_24>)
 80051d6:	4008      	ands	r0, r1
 80051d8:	0b09      	lsrs	r1, r1, #12
 80051da:	1c49      	adds	r1, r1, #1
 80051dc:	0309      	lsls	r1, r1, #12
 80051de:	25e0      	movs	r5, #224	; 0xe0
 80051e0:	01ed      	lsls	r5, r5, #7
 80051e2:	400d      	ands	r5, r1
 80051e4:	4305      	orrs	r5, r0
 80051e6:	829d      	strh	r5, [r3, #20]
 80051e8:	6860      	ldr	r0, [r4, #4]
 80051ea:	8a80      	ldrh	r0, [r0, #20]
 80051ec:	0440      	lsls	r0, r0, #17
 80051ee:	0f40      	lsrs	r0, r0, #29
 80051f0:	0085      	lsls	r5, r0, #2
 80051f2:	1cad      	adds	r5, r5, #2
 80051f4:	6860      	ldr	r0, [r4, #4]
 80051f6:	8402      	strh	r2, [r0, #32]
 80051f8:	e008      	b.n	800520c <USBPD_PRL_SendMessage+0x248>
 80051fa:	8a81      	ldrh	r1, [r0, #20]
 80051fc:	22e0      	movs	r2, #224	; 0xe0
 80051fe:	01d2      	lsls	r2, r2, #7
 8005200:	430a      	orrs	r2, r1
 8005202:	8282      	strh	r2, [r0, #20]
 8005204:	8c01      	ldrh	r1, [r0, #32]
 8005206:	391a      	subs	r1, #26
 8005208:	8401      	strh	r1, [r0, #32]
 800520a:	251e      	movs	r5, #30
 800520c:	6860      	ldr	r0, [r4, #4]
 800520e:	8b40      	ldrh	r0, [r0, #26]
 8005210:	9902      	ldr	r1, [sp, #8]
 8005212:	7088      	strb	r0, [r1, #2]
 8005214:	6860      	ldr	r0, [r4, #4]
 8005216:	8b40      	ldrh	r0, [r0, #26]
 8005218:	0a00      	lsrs	r0, r0, #8
 800521a:	9902      	ldr	r1, [sp, #8]
 800521c:	70c8      	strb	r0, [r1, #3]
 800521e:	6860      	ldr	r0, [r4, #4]
 8005220:	7ac2      	ldrb	r2, [r0, #11]
 8005222:	8a83      	ldrh	r3, [r0, #20]
 8005224:	4999      	ldr	r1, [pc, #612]	; (800548c <.text_29>)
 8005226:	4019      	ands	r1, r3
 8005228:	0253      	lsls	r3, r2, #9
 800522a:	22e0      	movs	r2, #224	; 0xe0
 800522c:	0112      	lsls	r2, r2, #4
 800522e:	401a      	ands	r2, r3
 8005230:	430a      	orrs	r2, r1
 8005232:	8282      	strh	r2, [r0, #20]
 8005234:	4668      	mov	r0, sp
 8005236:	7900      	ldrb	r0, [r0, #4]
 8005238:	2800      	cmp	r0, #0
 800523a:	d004      	beq.n	8005246 <USBPD_PRL_SendMessage+0x282>
 800523c:	4894      	ldr	r0, [pc, #592]	; (8005490 <.text_30>)
 800523e:	4010      	ands	r0, r2
 8005240:	9a02      	ldr	r2, [sp, #8]
 8005242:	7010      	strb	r0, [r2, #0]
 8005244:	e003      	b.n	800524e <USBPD_PRL_SendMessage+0x28a>
 8005246:	9802      	ldr	r0, [sp, #8]
 8005248:	7002      	strb	r2, [r0, #0]
 800524a:	6860      	ldr	r0, [r4, #4]
 800524c:	8a80      	ldrh	r0, [r0, #20]
 800524e:	0a00      	lsrs	r0, r0, #8
 8005250:	9902      	ldr	r1, [sp, #8]
 8005252:	7048      	strb	r0, [r1, #1]
 8005254:	480f      	ldr	r0, [pc, #60]	; (8005294 <USBPD_PRL_SendMessage+0x2d0>)
 8005256:	8005      	strh	r5, [r0, #0]
 8005258:	6860      	ldr	r0, [r4, #4]
 800525a:	2109      	movs	r1, #9
 800525c:	7101      	strb	r1, [r0, #4]
 800525e:	2102      	movs	r1, #2
 8005260:	7481      	strb	r1, [r0, #18]
 8005262:	488c      	ldr	r0, [pc, #560]	; (8005494 <.text_31>)
 8005264:	6804      	ldr	r4, [r0, #0]
 8005266:	2c00      	cmp	r4, #0
 8005268:	d007      	beq.n	800527a <USBPD_PRL_SendMessage+0x2b6>
 800526a:	b2a8      	uxth	r0, r5
 800526c:	9000      	str	r0, [sp, #0]
 800526e:	9b02      	ldr	r3, [sp, #8]
 8005270:	4668      	mov	r0, sp
 8005272:	7902      	ldrb	r2, [r0, #4]
 8005274:	7b01      	ldrb	r1, [r0, #12]
 8005276:	2002      	movs	r0, #2
 8005278:	47a0      	blx	r4
 800527a:	4668      	mov	r0, sp
 800527c:	7b00      	ldrb	r0, [r0, #12]
 800527e:	2800      	cmp	r0, #0
 8005280:	d101      	bne.n	8005286 <USBPD_PRL_SendMessage+0x2c2>
 8005282:	2001      	movs	r0, #1
 8005284:	e000      	b.n	8005288 <USBPD_PRL_SendMessage+0x2c4>
 8005286:	2003      	movs	r0, #3
 8005288:	4983      	ldr	r1, [pc, #524]	; (8005498 <.text_32>)
 800528a:	f006 fae5 	bl	800b858 <USBPD_TIM_Start>
 800528e:	b2ab      	uxth	r3, r5
 8005290:	e06c      	b.n	800536c <USBPD_PRL_SendMessage+0x3a8>
 8005292:	bf00      	nop
 8005294:	200019bc 	.word	0x200019bc
 8005298:	4668      	mov	r0, sp
 800529a:	7b00      	ldrb	r0, [r0, #12]
 800529c:	2800      	cmp	r0, #0
 800529e:	d101      	bne.n	80052a4 <USBPD_PRL_SendMessage+0x2e0>
 80052a0:	2001      	movs	r0, #1
 80052a2:	e000      	b.n	80052a6 <USBPD_PRL_SendMessage+0x2e2>
 80052a4:	2003      	movs	r0, #3
 80052a6:	f006 fb06 	bl	800b8b6 <USBPD_TIM_IsExpired>
 80052aa:	2801      	cmp	r0, #1
 80052ac:	d003      	beq.n	80052b6 <USBPD_PRL_SendMessage+0x2f2>
 80052ae:	6860      	ldr	r0, [r4, #4]
 80052b0:	7b80      	ldrb	r0, [r0, #14]
 80052b2:	2801      	cmp	r0, #1
 80052b4:	d166      	bne.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 80052b6:	200c      	movs	r0, #12
 80052b8:	6861      	ldr	r1, [r4, #4]
 80052ba:	7108      	strb	r0, [r1, #4]
 80052bc:	e062      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 80052be:	7ac1      	ldrb	r1, [r0, #11]
 80052c0:	2207      	movs	r2, #7
 80052c2:	8b03      	ldrh	r3, [r0, #24]
 80052c4:	0a5d      	lsrs	r5, r3, #9
 80052c6:	2307      	movs	r3, #7
 80052c8:	402b      	ands	r3, r5
 80052ca:	4299      	cmp	r1, r3
 80052cc:	d1f3      	bne.n	80052b6 <USBPD_PRL_SendMessage+0x2f2>
 80052ce:	7e03      	ldrb	r3, [r0, #24]
 80052d0:	06db      	lsls	r3, r3, #27
 80052d2:	0edb      	lsrs	r3, r3, #27
 80052d4:	2b01      	cmp	r3, #1
 80052d6:	d1ee      	bne.n	80052b6 <USBPD_PRL_SendMessage+0x2f2>
 80052d8:	1c49      	adds	r1, r1, #1
 80052da:	400a      	ands	r2, r1
 80052dc:	72c2      	strb	r2, [r0, #11]
 80052de:	6860      	ldr	r0, [r4, #4]
 80052e0:	7106      	strb	r6, [r0, #4]
 80052e2:	e00d      	b.n	8005300 <USBPD_PRL_SendMessage+0x33c>
 80052e4:	7ac1      	ldrb	r1, [r0, #11]
 80052e6:	1c49      	adds	r1, r1, #1
 80052e8:	0749      	lsls	r1, r1, #29
 80052ea:	0f49      	lsrs	r1, r1, #29
 80052ec:	72c1      	strb	r1, [r0, #11]
 80052ee:	6860      	ldr	r0, [r4, #4]
 80052f0:	7106      	strb	r6, [r0, #4]
 80052f2:	8b42      	ldrh	r2, [r0, #26]
 80052f4:	4969      	ldr	r1, [pc, #420]	; (800549c <.text_33>)
 80052f6:	4011      	ands	r1, r2
 80052f8:	8341      	strh	r1, [r0, #26]
 80052fa:	4a69      	ldr	r2, [pc, #420]	; (80054a0 <.text_34>)
 80052fc:	400a      	ands	r2, r1
 80052fe:	8342      	strh	r2, [r0, #26]
 8005300:	2705      	movs	r7, #5
 8005302:	e03f      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005304:	7b01      	ldrb	r1, [r0, #12]
 8005306:	1c49      	adds	r1, r1, #1
 8005308:	7301      	strb	r1, [r0, #12]
 800530a:	6860      	ldr	r0, [r4, #4]
 800530c:	8a81      	ldrh	r1, [r0, #20]
 800530e:	2203      	movs	r2, #3
 8005310:	098b      	lsrs	r3, r1, #6
 8005312:	2403      	movs	r4, #3
 8005314:	401c      	ands	r4, r3
 8005316:	2c01      	cmp	r4, #1
 8005318:	d000      	beq.n	800531c <USBPD_PRL_SendMessage+0x358>
 800531a:	2202      	movs	r2, #2
 800531c:	7b03      	ldrb	r3, [r0, #12]
 800531e:	429a      	cmp	r2, r3
 8005320:	d306      	bcc.n	8005330 <USBPD_PRL_SendMessage+0x36c>
 8005322:	0bc9      	lsrs	r1, r1, #15
 8005324:	d001      	beq.n	800532a <USBPD_PRL_SendMessage+0x366>
 8005326:	210f      	movs	r1, #15
 8005328:	e000      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 800532a:	2108      	movs	r1, #8
 800532c:	7101      	strb	r1, [r0, #4]
 800532e:	e029      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005330:	7106      	strb	r6, [r0, #4]
 8005332:	2707      	movs	r7, #7
 8005334:	e026      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005336:	2109      	movs	r1, #9
 8005338:	7101      	strb	r1, [r0, #4]
 800533a:	2102      	movs	r1, #2
 800533c:	7481      	strb	r1, [r0, #18]
 800533e:	4668      	mov	r0, sp
 8005340:	7b00      	ldrb	r0, [r0, #12]
 8005342:	2800      	cmp	r0, #0
 8005344:	d101      	bne.n	800534a <USBPD_PRL_SendMessage+0x386>
 8005346:	2001      	movs	r0, #1
 8005348:	e000      	b.n	800534c <USBPD_PRL_SendMessage+0x388>
 800534a:	2003      	movs	r0, #3
 800534c:	4955      	ldr	r1, [pc, #340]	; (80054a4 <.text_35>)
 800534e:	f006 fa83 	bl	800b858 <USBPD_TIM_Start>
 8005352:	4850      	ldr	r0, [pc, #320]	; (8005494 <.text_31>)
 8005354:	6804      	ldr	r4, [r0, #0]
 8005356:	2c00      	cmp	r4, #0
 8005358:	d006      	beq.n	8005368 <USBPD_PRL_SendMessage+0x3a4>
 800535a:	9500      	str	r5, [sp, #0]
 800535c:	9b02      	ldr	r3, [sp, #8]
 800535e:	4668      	mov	r0, sp
 8005360:	7902      	ldrb	r2, [r0, #4]
 8005362:	7b01      	ldrb	r1, [r0, #12]
 8005364:	2002      	movs	r0, #2
 8005366:	47a0      	blx	r4
 8005368:	484f      	ldr	r0, [pc, #316]	; (80054a8 <.text_36>)
 800536a:	8803      	ldrh	r3, [r0, #0]
 800536c:	9a02      	ldr	r2, [sp, #8]
 800536e:	4668      	mov	r0, sp
 8005370:	7901      	ldrb	r1, [r0, #4]
 8005372:	7b00      	ldrb	r0, [r0, #12]
 8005374:	f004 fce6 	bl	8009d44 <USBPD_PHY_SendMessage>
 8005378:	e004      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 800537a:	7106      	strb	r6, [r0, #4]
 800537c:	2706      	movs	r7, #6
 800537e:	e001      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005380:	7106      	strb	r6, [r0, #4]
 8005382:	2710      	movs	r7, #16
 8005384:	0038      	movs	r0, r7
 8005386:	b005      	add	sp, #20
 8005388:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800538a <USBPD_PRL_ResetRequestReset>:
 800538a:	4947      	ldr	r1, [pc, #284]	; (80054a8 <.text_36>)
 800538c:	0080      	lsls	r0, r0, #2
 800538e:	1808      	adds	r0, r1, r0
 8005390:	6840      	ldr	r0, [r0, #4]
 8005392:	2100      	movs	r1, #0
 8005394:	7141      	strb	r1, [r0, #5]
 8005396:	4770      	bx	lr

08005398 <.text_23>:
 8005398:	0000ffe0 	.word	0x0000ffe0

0800539c <.text_24>:
 800539c:	00008fff 	.word	0x00008fff

080053a0 <USBPD_PRL_ResetRequestProcess>:
 80053a0:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 80053a2:	b082      	sub	sp, #8
 80053a4:	000d      	movs	r5, r1
 80053a6:	2403      	movs	r4, #3
 80053a8:	483f      	ldr	r0, [pc, #252]	; (80054a8 <.text_36>)
 80053aa:	4669      	mov	r1, sp
 80053ac:	7a09      	ldrb	r1, [r1, #8]
 80053ae:	0089      	lsls	r1, r1, #2
 80053b0:	1846      	adds	r6, r0, r1
 80053b2:	6871      	ldr	r1, [r6, #4]
 80053b4:	2000      	movs	r0, #0
 80053b6:	2202      	movs	r2, #2
 80053b8:	794b      	ldrb	r3, [r1, #5]
 80053ba:	2b00      	cmp	r3, #0
 80053bc:	d003      	beq.n	80053c6 <USBPD_PRL_ResetRequestProcess+0x26>
 80053be:	2b02      	cmp	r3, #2
 80053c0:	d030      	beq.n	8005424 <USBPD_PRL_ResetRequestProcess+0x84>
 80053c2:	d323      	bcc.n	800540c <USBPD_PRL_ResetRequestProcess+0x6c>
 80053c4:	e031      	b.n	800542a <USBPD_PRL_ResetRequestProcess+0x8a>
 80053c6:	7348      	strb	r0, [r1, #13]
 80053c8:	6871      	ldr	r1, [r6, #4]
 80053ca:	72c8      	strb	r0, [r1, #11]
 80053cc:	220f      	movs	r2, #15
 80053ce:	2103      	movs	r1, #3
 80053d0:	6870      	ldr	r0, [r6, #4]
 80053d2:	1d80      	adds	r0, r0, #6
 80053d4:	f007 fb35 	bl	800ca42 <__aeabi_memset>
 80053d8:	2006      	movs	r0, #6
 80053da:	6871      	ldr	r1, [r6, #4]
 80053dc:	7108      	strb	r0, [r1, #4]
 80053de:	482d      	ldr	r0, [pc, #180]	; (8005494 <.text_31>)
 80053e0:	6807      	ldr	r7, [r0, #0]
 80053e2:	2f00      	cmp	r7, #0
 80053e4:	d007      	beq.n	80053f6 <USBPD_PRL_ResetRequestProcess+0x56>
 80053e6:	2000      	movs	r0, #0
 80053e8:	9000      	str	r0, [sp, #0]
 80053ea:	2300      	movs	r3, #0
 80053ec:	2205      	movs	r2, #5
 80053ee:	4668      	mov	r0, sp
 80053f0:	7a01      	ldrb	r1, [r0, #8]
 80053f2:	2002      	movs	r0, #2
 80053f4:	47b8      	blx	r7
 80053f6:	0029      	movs	r1, r5
 80053f8:	4668      	mov	r0, sp
 80053fa:	7a00      	ldrb	r0, [r0, #8]
 80053fc:	f004 fcc2 	bl	8009d84 <USBPD_PHY_ResetRequest>
 8005400:	6870      	ldr	r0, [r6, #4]
 8005402:	2101      	movs	r1, #1
 8005404:	7141      	strb	r1, [r0, #5]
 8005406:	2105      	movs	r1, #5
 8005408:	7281      	strb	r1, [r0, #10]
 800540a:	e010      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 800540c:	7b4b      	ldrb	r3, [r1, #13]
 800540e:	2b01      	cmp	r3, #1
 8005410:	d102      	bne.n	8005418 <USBPD_PRL_ResetRequestProcess+0x78>
 8005412:	714a      	strb	r2, [r1, #5]
 8005414:	7348      	strb	r0, [r1, #13]
 8005416:	e00a      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 8005418:	7a8a      	ldrb	r2, [r1, #10]
 800541a:	2a00      	cmp	r2, #0
 800541c:	d107      	bne.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 800541e:	7148      	strb	r0, [r1, #5]
 8005420:	2404      	movs	r4, #4
 8005422:	e004      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 8005424:	7148      	strb	r0, [r1, #5]
 8005426:	2400      	movs	r4, #0
 8005428:	e001      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 800542a:	7148      	strb	r0, [r1, #5]
 800542c:	2402      	movs	r4, #2
 800542e:	0020      	movs	r0, r4
 8005430:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08005432 <USBDPD_PRL_BistCarrierEyeMode>:
 8005432:	b580      	push	{r7, lr}
 8005434:	2905      	cmp	r1, #5
 8005436:	d102      	bne.n	800543e <USBDPD_PRL_BistCarrierEyeMode+0xc>
 8005438:	f004 fb70 	bl	8009b1c <USBPD_PHY_Send_BIST_Pattern>
 800543c:	bd02      	pop	{r1, pc}
 800543e:	2010      	movs	r0, #16
 8005440:	bd02      	pop	{r1, pc}

08005442 <USBDPD_PRL_BistCarrierEyeModeExit>:
 8005442:	b580      	push	{r7, lr}
 8005444:	2905      	cmp	r1, #5
 8005446:	d103      	bne.n	8005450 <USBDPD_PRL_BistCarrierEyeModeExit+0xe>
 8005448:	2107      	movs	r1, #7
 800544a:	f004 fb75 	bl	8009b38 <USBPD_PHY_ExitTransmit>
 800544e:	bd02      	pop	{r1, pc}
 8005450:	2010      	movs	r0, #16
 8005452:	bd02      	pop	{r1, pc}

08005454 <USBPD_PRL_Reset>:
 8005454:	b538      	push	{r3, r4, r5, lr}
 8005456:	4914      	ldr	r1, [pc, #80]	; (80054a8 <.text_36>)
 8005458:	0080      	lsls	r0, r0, #2
 800545a:	180c      	adds	r4, r1, r0
 800545c:	6860      	ldr	r0, [r4, #4]
 800545e:	2500      	movs	r5, #0
 8005460:	7105      	strb	r5, [r0, #4]
 8005462:	7145      	strb	r5, [r0, #5]
 8005464:	7285      	strb	r5, [r0, #10]
 8005466:	6860      	ldr	r0, [r4, #4]
 8005468:	72c5      	strb	r5, [r0, #11]
 800546a:	220f      	movs	r2, #15
 800546c:	2103      	movs	r1, #3
 800546e:	6860      	ldr	r0, [r4, #4]
 8005470:	1d80      	adds	r0, r0, #6
 8005472:	f007 fae6 	bl	800ca42 <__aeabi_memset>
 8005476:	6860      	ldr	r0, [r4, #4]
 8005478:	7305      	strb	r5, [r0, #12]
 800547a:	6860      	ldr	r0, [r4, #4]
 800547c:	7345      	strb	r5, [r0, #13]
 800547e:	6860      	ldr	r0, [r4, #4]
 8005480:	7385      	strb	r5, [r0, #14]
 8005482:	6860      	ldr	r0, [r4, #4]
 8005484:	2123      	movs	r1, #35	; 0x23
 8005486:	5445      	strb	r5, [r0, r1]
 8005488:	bd31      	pop	{r0, r4, r5, pc}
	...

0800548c <.text_29>:
 800548c:	0000f1ff 	.word	0x0000f1ff

08005490 <.text_30>:
 8005490:	0000fedf 	.word	0x0000fedf

08005494 <.text_31>:
 8005494:	200019b4 	.word	0x200019b4

08005498 <.text_32>:
 8005498:	00002710 	.word	0x00002710

0800549c <.text_33>:
 800549c:	000087ff 	.word	0x000087ff

080054a0 <.text_34>:
 80054a0:	0000fbff 	.word	0x0000fbff

080054a4 <.text_35>:
 80054a4:	000009c4 	.word	0x000009c4

080054a8 <.text_36>:
 80054a8:	200019bc 	.word	0x200019bc

080054ac <USBPD_PRL_DeInit>:
 80054ac:	4770      	bx	lr

080054ae <PRL_Received>:
 80054ae:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
 80054b0:	b083      	sub	sp, #12
 80054b2:	48c4      	ldr	r0, [pc, #784]	; (80057c4 <.text_39>)
 80054b4:	8800      	ldrh	r0, [r0, #0]
 80054b6:	4669      	mov	r1, sp
 80054b8:	80c8      	strh	r0, [r1, #6]
 80054ba:	48c3      	ldr	r0, [pc, #780]	; (80057c8 <.text_40>)
 80054bc:	7b09      	ldrb	r1, [r1, #12]
 80054be:	0089      	lsls	r1, r1, #2
 80054c0:	1846      	adds	r6, r0, r1
 80054c2:	6870      	ldr	r0, [r6, #4]
 80054c4:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80054c6:	780a      	ldrb	r2, [r1, #0]
 80054c8:	7849      	ldrb	r1, [r1, #1]
 80054ca:	0209      	lsls	r1, r1, #8
 80054cc:	1851      	adds	r1, r2, r1
 80054ce:	466a      	mov	r2, sp
 80054d0:	8091      	strh	r1, [r2, #4]
 80054d2:	4fbe      	ldr	r7, [pc, #760]	; (80057cc <.text_41>)
 80054d4:	683c      	ldr	r4, [r7, #0]
 80054d6:	4669      	mov	r1, sp
 80054d8:	8889      	ldrh	r1, [r1, #4]
 80054da:	0bc9      	lsrs	r1, r1, #15
 80054dc:	d00b      	beq.n	80054f6 <PRL_Received+0x48>
 80054de:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80054e0:	7898      	ldrb	r0, [r3, #2]
 80054e2:	78d9      	ldrb	r1, [r3, #3]
 80054e4:	0209      	lsls	r1, r1, #8
 80054e6:	1845      	adds	r5, r0, r1
 80054e8:	2c00      	cmp	r4, #0
 80054ea:	d013      	beq.n	8005514 <PRL_Received+0x66>
 80054ec:	05e8      	lsls	r0, r5, #23
 80054ee:	0dc0      	lsrs	r0, r0, #23
 80054f0:	1d00      	adds	r0, r0, #4
 80054f2:	9000      	str	r0, [sp, #0]
 80054f4:	e009      	b.n	800550a <PRL_Received+0x5c>
 80054f6:	2c00      	cmp	r4, #0
 80054f8:	d00c      	beq.n	8005514 <PRL_Received+0x66>
 80054fa:	4669      	mov	r1, sp
 80054fc:	8889      	ldrh	r1, [r1, #4]
 80054fe:	0449      	lsls	r1, r1, #17
 8005500:	0f49      	lsrs	r1, r1, #29
 8005502:	0089      	lsls	r1, r1, #2
 8005504:	1c89      	adds	r1, r1, #2
 8005506:	9100      	str	r1, [sp, #0]
 8005508:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800550a:	4668      	mov	r0, sp
 800550c:	7c02      	ldrb	r2, [r0, #16]
 800550e:	7b01      	ldrb	r1, [r0, #12]
 8005510:	2001      	movs	r0, #1
 8005512:	47a0      	blx	r4
 8005514:	6870      	ldr	r0, [r6, #4]
 8005516:	49c7      	ldr	r1, [pc, #796]	; (8005834 <.text_45>)
 8005518:	466a      	mov	r2, sp
 800551a:	8892      	ldrh	r2, [r2, #4]
 800551c:	400a      	ands	r2, r1
 800551e:	2a01      	cmp	r2, #1
 8005520:	d105      	bne.n	800552e <PRL_Received+0x80>
 8005522:	210a      	movs	r1, #10
 8005524:	7101      	strb	r1, [r0, #4]
 8005526:	4669      	mov	r1, sp
 8005528:	8889      	ldrh	r1, [r1, #4]
 800552a:	8301      	strh	r1, [r0, #24]
 800552c:	e13b      	b.n	80057a6 <PRL_Received+0x2f8>
 800552e:	466a      	mov	r2, sp
 8005530:	7c12      	ldrb	r2, [r2, #16]
 8005532:	7242      	strb	r2, [r0, #9]
 8005534:	2400      	movs	r4, #0
 8005536:	466a      	mov	r2, sp
 8005538:	8892      	ldrh	r2, [r2, #4]
 800553a:	4011      	ands	r1, r2
 800553c:	290d      	cmp	r1, #13
 800553e:	d108      	bne.n	8005552 <PRL_Received+0xa4>
 8005540:	72c4      	strb	r4, [r0, #11]
 8005542:	220f      	movs	r2, #15
 8005544:	2103      	movs	r1, #3
 8005546:	6870      	ldr	r0, [r6, #4]
 8005548:	1d80      	adds	r0, r0, #6
 800554a:	f007 fa7a 	bl	800ca42 <__aeabi_memset>
 800554e:	6871      	ldr	r1, [r6, #4]
 8005550:	710c      	strb	r4, [r1, #4]
 8005552:	4668      	mov	r0, sp
 8005554:	88c0      	ldrh	r0, [r0, #6]
 8005556:	49bd      	ldr	r1, [pc, #756]	; (800584c <.text_47>)
 8005558:	4001      	ands	r1, r0
 800555a:	2001      	movs	r0, #1
 800555c:	4308      	orrs	r0, r1
 800555e:	4669      	mov	r1, sp
 8005560:	4abb      	ldr	r2, [pc, #748]	; (8005850 <.text_48>)
 8005562:	4002      	ands	r2, r0
 8005564:	800a      	strh	r2, [r1, #0]
 8005566:	4668      	mov	r0, sp
 8005568:	7c00      	ldrb	r0, [r0, #16]
 800556a:	2800      	cmp	r0, #0
 800556c:	d10e      	bne.n	800558c <PRL_Received+0xde>
 800556e:	6870      	ldr	r0, [r6, #4]
 8005570:	8a82      	ldrh	r2, [r0, #20]
 8005572:	2101      	movs	r1, #1
 8005574:	0953      	lsrs	r3, r2, #5
 8005576:	2001      	movs	r0, #1
 8005578:	4018      	ands	r0, r3
 800557a:	0a12      	lsrs	r2, r2, #8
 800557c:	4011      	ands	r1, r2
 800557e:	466a      	mov	r2, sp
 8005580:	8812      	ldrh	r2, [r2, #0]
 8005582:	0140      	lsls	r0, r0, #5
 8005584:	4310      	orrs	r0, r2
 8005586:	0209      	lsls	r1, r1, #8
 8005588:	4301      	orrs	r1, r0
 800558a:	e000      	b.n	800558e <PRL_Received+0xe0>
 800558c:	4611      	mov	r1, r2
 800558e:	48c2      	ldr	r0, [pc, #776]	; (8005898 <.text_50>)
 8005590:	4008      	ands	r0, r1
 8005592:	4669      	mov	r1, sp
 8005594:	8889      	ldrh	r1, [r1, #4]
 8005596:	0609      	lsls	r1, r1, #24
 8005598:	0f89      	lsrs	r1, r1, #30
 800559a:	2902      	cmp	r1, #2
 800559c:	da02      	bge.n	80055a4 <PRL_Received+0xf6>
 800559e:	0001      	movs	r1, r0
 80055a0:	2040      	movs	r0, #64	; 0x40
 80055a2:	4308      	orrs	r0, r1
 80055a4:	05c1      	lsls	r1, r0, #23
 80055a6:	0dc9      	lsrs	r1, r1, #23
 80055a8:	4668      	mov	r0, sp
 80055aa:	8882      	ldrh	r2, [r0, #4]
 80055ac:	20e0      	movs	r0, #224	; 0xe0
 80055ae:	0100      	lsls	r0, r0, #4
 80055b0:	4010      	ands	r0, r2
 80055b2:	4308      	orrs	r0, r1
 80055b4:	6872      	ldr	r2, [r6, #4]
 80055b6:	7590      	strb	r0, [r2, #22]
 80055b8:	0a00      	lsrs	r0, r0, #8
 80055ba:	6871      	ldr	r1, [r6, #4]
 80055bc:	75c8      	strb	r0, [r1, #23]
 80055be:	6870      	ldr	r0, [r6, #4]
 80055c0:	2101      	movs	r1, #1
 80055c2:	7481      	strb	r1, [r0, #18]
 80055c4:	683f      	ldr	r7, [r7, #0]
 80055c6:	2f00      	cmp	r7, #0
 80055c8:	d008      	beq.n	80055dc <PRL_Received+0x12e>
 80055ca:	2102      	movs	r1, #2
 80055cc:	9100      	str	r1, [sp, #0]
 80055ce:	0003      	movs	r3, r0
 80055d0:	3316      	adds	r3, #22
 80055d2:	4668      	mov	r0, sp
 80055d4:	7c02      	ldrb	r2, [r0, #16]
 80055d6:	7b01      	ldrb	r1, [r0, #12]
 80055d8:	2002      	movs	r0, #2
 80055da:	47b8      	blx	r7
 80055dc:	2302      	movs	r3, #2
 80055de:	6872      	ldr	r2, [r6, #4]
 80055e0:	3216      	adds	r2, #22
 80055e2:	4668      	mov	r0, sp
 80055e4:	7c01      	ldrb	r1, [r0, #16]
 80055e6:	7b00      	ldrb	r0, [r0, #12]
 80055e8:	f004 fbac 	bl	8009d44 <USBPD_PHY_SendMessage>
 80055ec:	2800      	cmp	r0, #0
 80055ee:	d19d      	bne.n	800552c <PRL_Received+0x7e>
 80055f0:	6870      	ldr	r0, [r6, #4]
 80055f2:	1d81      	adds	r1, r0, #6
 80055f4:	466a      	mov	r2, sp
 80055f6:	7c12      	ldrb	r2, [r2, #16]
 80055f8:	1889      	adds	r1, r1, r2
 80055fa:	9100      	str	r1, [sp, #0]
 80055fc:	4669      	mov	r1, sp
 80055fe:	8889      	ldrh	r1, [r1, #4]
 8005600:	0a49      	lsrs	r1, r1, #9
 8005602:	2207      	movs	r2, #7
 8005604:	9b00      	ldr	r3, [sp, #0]
 8005606:	781b      	ldrb	r3, [r3, #0]
 8005608:	2707      	movs	r7, #7
 800560a:	400f      	ands	r7, r1
 800560c:	42bb      	cmp	r3, r7
 800560e:	d100      	bne.n	8005612 <PRL_Received+0x164>
 8005610:	e0c8      	b.n	80057a4 <PRL_Received+0x2f6>
 8005612:	2007      	movs	r0, #7
 8005614:	4008      	ands	r0, r1
 8005616:	9900      	ldr	r1, [sp, #0]
 8005618:	7008      	strb	r0, [r1, #0]
 800561a:	6873      	ldr	r3, [r6, #4]
 800561c:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800561e:	7881      	ldrb	r1, [r0, #2]
 8005620:	78c7      	ldrb	r7, [r0, #3]
 8005622:	023f      	lsls	r7, r7, #8
 8005624:	19c9      	adds	r1, r1, r7
 8005626:	7907      	ldrb	r7, [r0, #4]
 8005628:	043f      	lsls	r7, r7, #16
 800562a:	19c9      	adds	r1, r1, r7
 800562c:	7940      	ldrb	r0, [r0, #5]
 800562e:	0600      	lsls	r0, r0, #24
 8005630:	1808      	adds	r0, r1, r0
 8005632:	4669      	mov	r1, sp
 8005634:	8889      	ldrh	r1, [r1, #4]
 8005636:	0b09      	lsrs	r1, r1, #12
 8005638:	4211      	tst	r1, r2
 800563a:	d00f      	beq.n	800565c <PRL_Received+0x1ae>
 800563c:	4669      	mov	r1, sp
 800563e:	8889      	ldrh	r1, [r1, #4]
 8005640:	06c9      	lsls	r1, r1, #27
 8005642:	0ec9      	lsrs	r1, r1, #27
 8005644:	2903      	cmp	r1, #3
 8005646:	d109      	bne.n	800565c <PRL_Received+0x1ae>
 8005648:	0f00      	lsrs	r0, r0, #28
 800564a:	2808      	cmp	r0, #8
 800564c:	d001      	beq.n	8005652 <PRL_Received+0x1a4>
 800564e:	2800      	cmp	r0, #0
 8005650:	d104      	bne.n	800565c <PRL_Received+0x1ae>
 8005652:	aa01      	add	r2, sp, #4
 8005654:	4668      	mov	r0, sp
 8005656:	7c01      	ldrb	r1, [r0, #16]
 8005658:	7b00      	ldrb	r0, [r0, #12]
 800565a:	e09f      	b.n	800579c <PRL_Received+0x2ee>
 800565c:	4668      	mov	r0, sp
 800565e:	8880      	ldrh	r0, [r0, #4]
 8005660:	83d8      	strh	r0, [r3, #30]
 8005662:	4668      	mov	r0, sp
 8005664:	8880      	ldrh	r0, [r0, #4]
 8005666:	0bc0      	lsrs	r0, r0, #15
 8005668:	d031      	beq.n	80056ce <PRL_Received+0x220>
 800566a:	0428      	lsls	r0, r5, #16
 800566c:	0fc0      	lsrs	r0, r0, #31
 800566e:	d02e      	beq.n	80056ce <PRL_Received+0x220>
 8005670:	839d      	strh	r5, [r3, #28]
 8005672:	200f      	movs	r0, #15
 8005674:	4669      	mov	r1, sp
 8005676:	8889      	ldrh	r1, [r1, #4]
 8005678:	0b09      	lsrs	r1, r1, #12
 800567a:	400a      	ands	r2, r1
 800567c:	21f8      	movs	r1, #248	; 0xf8
 800567e:	01c9      	lsls	r1, r1, #7
 8005680:	4029      	ands	r1, r5
 8005682:	d138      	bne.n	80056f6 <PRL_Received+0x248>
 8005684:	2a06      	cmp	r2, #6
 8005686:	dd03      	ble.n	8005690 <PRL_Received+0x1e2>
 8005688:	05e9      	lsls	r1, r5, #23
 800568a:	0dc9      	lsrs	r1, r1, #23
 800568c:	291a      	cmp	r1, #26
 800568e:	d821      	bhi.n	80056d4 <PRL_Received+0x226>
 8005690:	2100      	movs	r1, #0
 8005692:	042a      	lsls	r2, r5, #16
 8005694:	0ed2      	lsrs	r2, r2, #27
 8005696:	4010      	ands	r0, r2
 8005698:	221a      	movs	r2, #26
 800569a:	4342      	muls	r2, r0
 800569c:	2307      	movs	r3, #7
 800569e:	e007      	b.n	80056b0 <PRL_Received+0x202>
 80056a0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80056a2:	1d00      	adds	r0, r0, #4
 80056a4:	5c40      	ldrb	r0, [r0, r1]
 80056a6:	6aa4      	ldr	r4, [r4, #40]	; 0x28
 80056a8:	188f      	adds	r7, r1, r2
 80056aa:	55e0      	strb	r0, [r4, r7]
 80056ac:	1c49      	adds	r1, r1, #1
 80056ae:	b289      	uxth	r1, r1
 80056b0:	4668      	mov	r0, sp
 80056b2:	8880      	ldrh	r0, [r0, #4]
 80056b4:	0b00      	lsrs	r0, r0, #12
 80056b6:	4018      	ands	r0, r3
 80056b8:	0080      	lsls	r0, r0, #2
 80056ba:	1e80      	subs	r0, r0, #2
 80056bc:	6874      	ldr	r4, [r6, #4]
 80056be:	4281      	cmp	r1, r0
 80056c0:	dbee      	blt.n	80056a0 <PRL_Received+0x1f2>
 80056c2:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80056c4:	05e9      	lsls	r1, r5, #23
 80056c6:	0dc9      	lsrs	r1, r1, #23
 80056c8:	4288      	cmp	r0, r1
 80056ca:	da01      	bge.n	80056d0 <PRL_Received+0x222>
 80056cc:	8010      	strh	r0, [r2, #0]
 80056ce:	e060      	b.n	8005792 <PRL_Received+0x2e4>
 80056d0:	8011      	strh	r1, [r2, #0]
 80056d2:	e05e      	b.n	8005792 <PRL_Received+0x2e4>
 80056d4:	2001      	movs	r0, #1
 80056d6:	2123      	movs	r1, #35	; 0x23
 80056d8:	5458      	strb	r0, [r3, r1]
 80056da:	6870      	ldr	r0, [r6, #4]
 80056dc:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80056de:	1d09      	adds	r1, r1, #4
 80056e0:	5d09      	ldrb	r1, [r1, r4]
 80056e2:	6a80      	ldr	r0, [r0, #40]	; 0x28
 80056e4:	5501      	strb	r1, [r0, r4]
 80056e6:	1c64      	adds	r4, r4, #1
 80056e8:	2c1a      	cmp	r4, #26
 80056ea:	d3f6      	bcc.n	80056da <PRL_Received+0x22c>
 80056ec:	201a      	movs	r0, #26
 80056ee:	6871      	ldr	r1, [r6, #4]
 80056f0:	6a49      	ldr	r1, [r1, #36]	; 0x24
 80056f2:	8008      	strh	r0, [r1, #0]
 80056f4:	e04d      	b.n	8005792 <PRL_Received+0x2e4>
 80056f6:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80056f8:	8809      	ldrh	r1, [r1, #0]
 80056fa:	0092      	lsls	r2, r2, #2
 80056fc:	188a      	adds	r2, r1, r2
 80056fe:	1e92      	subs	r2, r2, #2
 8005700:	27ff      	movs	r7, #255	; 0xff
 8005702:	1dbf      	adds	r7, r7, #6
 8005704:	311a      	adds	r1, #26
 8005706:	42b9      	cmp	r1, r7
 8005708:	d21e      	bcs.n	8005748 <PRL_Received+0x29a>
 800570a:	05e9      	lsls	r1, r5, #23
 800570c:	0dc9      	lsrs	r1, r1, #23
 800570e:	428a      	cmp	r2, r1
 8005710:	da1a      	bge.n	8005748 <PRL_Received+0x29a>
 8005712:	2101      	movs	r1, #1
 8005714:	2223      	movs	r2, #35	; 0x23
 8005716:	5499      	strb	r1, [r3, r2]
 8005718:	0429      	lsls	r1, r5, #16
 800571a:	0ec9      	lsrs	r1, r1, #27
 800571c:	4008      	ands	r0, r1
 800571e:	211a      	movs	r1, #26
 8005720:	4341      	muls	r1, r0
 8005722:	2007      	movs	r0, #7
 8005724:	466a      	mov	r2, sp
 8005726:	8892      	ldrh	r2, [r2, #4]
 8005728:	0b12      	lsrs	r2, r2, #12
 800572a:	4002      	ands	r2, r0
 800572c:	0092      	lsls	r2, r2, #2
 800572e:	1e92      	subs	r2, r2, #2
 8005730:	4294      	cmp	r4, r2
 8005732:	da3a      	bge.n	80057aa <PRL_Received+0x2fc>
 8005734:	6872      	ldr	r2, [r6, #4]
 8005736:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8005738:	1d1b      	adds	r3, r3, #4
 800573a:	5d1b      	ldrb	r3, [r3, r4]
 800573c:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800573e:	1865      	adds	r5, r4, r1
 8005740:	5553      	strb	r3, [r2, r5]
 8005742:	1c64      	adds	r4, r4, #1
 8005744:	b2a4      	uxth	r4, r4
 8005746:	e7ed      	b.n	8005724 <PRL_Received+0x276>
 8005748:	42ba      	cmp	r2, r7
 800574a:	d21e      	bcs.n	800578a <PRL_Received+0x2dc>
 800574c:	05e9      	lsls	r1, r5, #23
 800574e:	0dc9      	lsrs	r1, r1, #23
 8005750:	428a      	cmp	r2, r1
 8005752:	db1a      	blt.n	800578a <PRL_Received+0x2dc>
 8005754:	2101      	movs	r1, #1
 8005756:	2223      	movs	r2, #35	; 0x23
 8005758:	5499      	strb	r1, [r3, r2]
 800575a:	0429      	lsls	r1, r5, #16
 800575c:	0ec9      	lsrs	r1, r1, #27
 800575e:	4008      	ands	r0, r1
 8005760:	211a      	movs	r1, #26
 8005762:	4341      	muls	r1, r0
 8005764:	2007      	movs	r0, #7
 8005766:	466a      	mov	r2, sp
 8005768:	8892      	ldrh	r2, [r2, #4]
 800576a:	0b12      	lsrs	r2, r2, #12
 800576c:	4002      	ands	r2, r0
 800576e:	0092      	lsls	r2, r2, #2
 8005770:	1e92      	subs	r2, r2, #2
 8005772:	4294      	cmp	r4, r2
 8005774:	da19      	bge.n	80057aa <PRL_Received+0x2fc>
 8005776:	6872      	ldr	r2, [r6, #4]
 8005778:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 800577a:	1d1b      	adds	r3, r3, #4
 800577c:	5d1b      	ldrb	r3, [r3, r4]
 800577e:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8005780:	1865      	adds	r5, r4, r1
 8005782:	5553      	strb	r3, [r2, r5]
 8005784:	1c64      	adds	r4, r4, #1
 8005786:	b2a4      	uxth	r4, r4
 8005788:	e7ed      	b.n	8005766 <PRL_Received+0x2b8>
 800578a:	2123      	movs	r1, #35	; 0x23
 800578c:	545c      	strb	r4, [r3, r1]
 800578e:	6870      	ldr	r0, [r6, #4]
 8005790:	7104      	strb	r4, [r0, #4]
 8005792:	aa01      	add	r2, sp, #4
 8005794:	4668      	mov	r0, sp
 8005796:	7c01      	ldrb	r1, [r0, #16]
 8005798:	7b00      	ldrb	r0, [r0, #12]
 800579a:	6873      	ldr	r3, [r6, #4]
 800579c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800579e:	681b      	ldr	r3, [r3, #0]
 80057a0:	4798      	blx	r3
 80057a2:	e000      	b.n	80057a6 <PRL_Received+0x2f8>
 80057a4:	7484      	strb	r4, [r0, #18]
 80057a6:	b005      	add	sp, #20
 80057a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80057aa:	6870      	ldr	r0, [r6, #4]
 80057ac:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80057ae:	8801      	ldrh	r1, [r0, #0]
 80057b0:	466a      	mov	r2, sp
 80057b2:	8892      	ldrh	r2, [r2, #4]
 80057b4:	0a92      	lsrs	r2, r2, #10
 80057b6:	231c      	movs	r3, #28
 80057b8:	4013      	ands	r3, r2
 80057ba:	1e9a      	subs	r2, r3, #2
 80057bc:	1889      	adds	r1, r1, r2
 80057be:	8001      	strh	r1, [r0, #0]
 80057c0:	e7e7      	b.n	8005792 <PRL_Received+0x2e4>
	...

080057c4 <.text_39>:
 80057c4:	0800cdc4 	.word	0x0800cdc4

080057c8 <.text_40>:
 80057c8:	200019bc 	.word	0x200019bc

080057cc <.text_41>:
 80057cc:	200019b4 	.word	0x200019b4

080057d0 <PRL_ResetIndicate>:
 80057d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80057d2:	0005      	movs	r5, r0
 80057d4:	000e      	movs	r6, r1
 80057d6:	4869      	ldr	r0, [pc, #420]	; (800597c <.text_53>)
 80057d8:	00a9      	lsls	r1, r5, #2
 80057da:	1844      	adds	r4, r0, r1
 80057dc:	2000      	movs	r0, #0
 80057de:	6861      	ldr	r1, [r4, #4]
 80057e0:	72c8      	strb	r0, [r1, #11]
 80057e2:	220f      	movs	r2, #15
 80057e4:	2103      	movs	r1, #3
 80057e6:	6860      	ldr	r0, [r4, #4]
 80057e8:	1d80      	adds	r0, r0, #6
 80057ea:	f007 f92a 	bl	800ca42 <__aeabi_memset>
 80057ee:	2006      	movs	r0, #6
 80057f0:	6861      	ldr	r1, [r4, #4]
 80057f2:	7108      	strb	r0, [r1, #4]
 80057f4:	4862      	ldr	r0, [pc, #392]	; (8005980 <.text_54>)
 80057f6:	6807      	ldr	r7, [r0, #0]
 80057f8:	2f00      	cmp	r7, #0
 80057fa:	d006      	beq.n	800580a <PRL_ResetIndicate+0x3a>
 80057fc:	2000      	movs	r0, #0
 80057fe:	9000      	str	r0, [sp, #0]
 8005800:	2300      	movs	r3, #0
 8005802:	0032      	movs	r2, r6
 8005804:	0029      	movs	r1, r5
 8005806:	2001      	movs	r0, #1
 8005808:	47b8      	blx	r7
 800580a:	0031      	movs	r1, r6
 800580c:	0028      	movs	r0, r5
 800580e:	6862      	ldr	r2, [r4, #4]
 8005810:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8005812:	6892      	ldr	r2, [r2, #8]
 8005814:	4790      	blx	r2
 8005816:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}

08005818 <PRL_ResetCompleted>:
 8005818:	4958      	ldr	r1, [pc, #352]	; (800597c <.text_53>)
 800581a:	0080      	lsls	r0, r0, #2
 800581c:	1808      	adds	r0, r1, r0
 800581e:	6840      	ldr	r0, [r0, #4]
 8005820:	2101      	movs	r1, #1
 8005822:	7341      	strb	r1, [r0, #13]
 8005824:	4770      	bx	lr

08005826 <PRL_IdleAfterBusy>:
 8005826:	4955      	ldr	r1, [pc, #340]	; (800597c <.text_53>)
 8005828:	0080      	lsls	r0, r0, #2
 800582a:	1808      	adds	r0, r1, r0
 800582c:	6840      	ldr	r0, [r0, #4]
 800582e:	2101      	movs	r1, #1
 8005830:	7381      	strb	r1, [r0, #14]
 8005832:	4770      	bx	lr

08005834 <.text_45>:
 8005834:	0000f01f 	.word	0x0000f01f

08005838 <PRL_BistCompleted>:
 8005838:	b580      	push	{r7, lr}
 800583a:	4b50      	ldr	r3, [pc, #320]	; (800597c <.text_53>)
 800583c:	0082      	lsls	r2, r0, #2
 800583e:	189a      	adds	r2, r3, r2
 8005840:	6852      	ldr	r2, [r2, #4]
 8005842:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8005844:	68d2      	ldr	r2, [r2, #12]
 8005846:	4790      	blx	r2
 8005848:	bd01      	pop	{r0, pc}
	...

0800584c <.text_47>:
 800584c:	0000ffe0 	.word	0x0000ffe0

08005850 <.text_48>:
 8005850:	0000fedf 	.word	0x0000fedf

08005854 <PRL_TxCompleted>:
 8005854:	b538      	push	{r3, r4, r5, lr}
 8005856:	0005      	movs	r5, r0
 8005858:	4848      	ldr	r0, [pc, #288]	; (800597c <.text_53>)
 800585a:	00a9      	lsls	r1, r5, #2
 800585c:	1844      	adds	r4, r0, r1
 800585e:	6861      	ldr	r1, [r4, #4]
 8005860:	7c88      	ldrb	r0, [r1, #18]
 8005862:	2801      	cmp	r0, #1
 8005864:	d002      	beq.n	800586c <PRL_TxCompleted+0x18>
 8005866:	2802      	cmp	r0, #2
 8005868:	d005      	beq.n	8005876 <PRL_TxCompleted+0x22>
 800586a:	e010      	b.n	800588e <PRL_TxCompleted+0x3a>
 800586c:	0028      	movs	r0, r5
 800586e:	6b09      	ldr	r1, [r1, #48]	; 0x30
 8005870:	6849      	ldr	r1, [r1, #4]
 8005872:	4788      	blx	r1
 8005874:	e00b      	b.n	800588e <PRL_TxCompleted+0x3a>
 8005876:	0028      	movs	r0, r5
 8005878:	f004 f94c 	bl	8009b14 <USBPD_PHY_GetRetryTimerValue>
 800587c:	2d00      	cmp	r5, #0
 800587e:	d101      	bne.n	8005884 <PRL_TxCompleted+0x30>
 8005880:	2201      	movs	r2, #1
 8005882:	e000      	b.n	8005886 <PRL_TxCompleted+0x32>
 8005884:	2203      	movs	r2, #3
 8005886:	b281      	uxth	r1, r0
 8005888:	0010      	movs	r0, r2
 800588a:	f005 ffe5 	bl	800b858 <USBPD_TIM_Start>
 800588e:	2000      	movs	r0, #0
 8005890:	6861      	ldr	r1, [r4, #4]
 8005892:	7488      	strb	r0, [r1, #18]
 8005894:	bd31      	pop	{r0, r4, r5, pc}
	...

08005898 <.text_50>:
 8005898:	0000ff3f 	.word	0x0000ff3f

0800589c <USBPD_PRL_PrepareExtendedTxChunkSending>:
 800589c:	b570      	push	{r4, r5, r6, lr}
 800589e:	4c37      	ldr	r4, [pc, #220]	; (800597c <.text_53>)
 80058a0:	0080      	lsls	r0, r0, #2
 80058a2:	1820      	adds	r0, r4, r0
 80058a4:	6840      	ldr	r0, [r0, #4]
 80058a6:	2480      	movs	r4, #128	; 0x80
 80058a8:	0224      	lsls	r4, r4, #8
 80058aa:	8b45      	ldrh	r5, [r0, #26]
 80058ac:	4e35      	ldr	r6, [pc, #212]	; (8005984 <.text_55>)
 80058ae:	402e      	ands	r6, r5
 80058b0:	02c9      	lsls	r1, r1, #11
 80058b2:	4331      	orrs	r1, r6
 80058b4:	25fe      	movs	r5, #254	; 0xfe
 80058b6:	022d      	lsls	r5, r5, #8
 80058b8:	400d      	ands	r5, r1
 80058ba:	05d1      	lsls	r1, r2, #23
 80058bc:	0dc9      	lsrs	r1, r1, #23
 80058be:	4329      	orrs	r1, r5
 80058c0:	4321      	orrs	r1, r4
 80058c2:	8341      	strh	r1, [r0, #26]
 80058c4:	8a81      	ldrh	r1, [r0, #20]
 80058c6:	430c      	orrs	r4, r1
 80058c8:	8284      	strh	r4, [r0, #20]
 80058ca:	4a2f      	ldr	r2, [pc, #188]	; (8005988 <.text_56>)
 80058cc:	4022      	ands	r2, r4
 80058ce:	7f81      	ldrb	r1, [r0, #30]
 80058d0:	06c9      	lsls	r1, r1, #27
 80058d2:	0ec9      	lsrs	r1, r1, #27
 80058d4:	4311      	orrs	r1, r2
 80058d6:	8281      	strh	r1, [r0, #20]
 80058d8:	7019      	strb	r1, [r3, #0]
 80058da:	8a81      	ldrh	r1, [r0, #20]
 80058dc:	0a09      	lsrs	r1, r1, #8
 80058de:	7059      	strb	r1, [r3, #1]
 80058e0:	8b41      	ldrh	r1, [r0, #26]
 80058e2:	7099      	strb	r1, [r3, #2]
 80058e4:	8b40      	ldrh	r0, [r0, #26]
 80058e6:	0a00      	lsrs	r0, r0, #8
 80058e8:	70d8      	strb	r0, [r3, #3]
 80058ea:	bd70      	pop	{r4, r5, r6, pc}

080058ec <USBPD_PRL_ManageExtendedRx>:
 80058ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80058ee:	b084      	sub	sp, #16
 80058f0:	4a22      	ldr	r2, [pc, #136]	; (800597c <.text_53>)
 80058f2:	0083      	lsls	r3, r0, #2
 80058f4:	18d2      	adds	r2, r2, r3
 80058f6:	6853      	ldr	r3, [r2, #4]
 80058f8:	8b5a      	ldrh	r2, [r3, #26]
 80058fa:	2484      	movs	r4, #132	; 0x84
 80058fc:	0224      	lsls	r4, r4, #8
 80058fe:	4314      	orrs	r4, r2
 8005900:	835c      	strh	r4, [r3, #26]
 8005902:	2286      	movs	r2, #134	; 0x86
 8005904:	0212      	lsls	r2, r2, #8
 8005906:	4022      	ands	r2, r4
 8005908:	8b9c      	ldrh	r4, [r3, #28]
 800590a:	0ae4      	lsrs	r4, r4, #11
 800590c:	1c64      	adds	r4, r4, #1
 800590e:	02e4      	lsls	r4, r4, #11
 8005910:	25f0      	movs	r5, #240	; 0xf0
 8005912:	01ed      	lsls	r5, r5, #7
 8005914:	4025      	ands	r5, r4
 8005916:	4315      	orrs	r5, r2
 8005918:	835d      	strh	r5, [r3, #26]
 800591a:	8bdd      	ldrh	r5, [r3, #30]
 800591c:	221f      	movs	r2, #31
 800591e:	261f      	movs	r6, #31
 8005920:	402e      	ands	r6, r5
 8005922:	2480      	movs	r4, #128	; 0x80
 8005924:	4334      	orrs	r4, r6
 8005926:	8a9f      	ldrh	r7, [r3, #20]
 8005928:	4e18      	ldr	r6, [pc, #96]	; (800598c <.text_57>)
 800592a:	403e      	ands	r6, r7
 800592c:	2790      	movs	r7, #144	; 0x90
 800592e:	023f      	lsls	r7, r7, #8
 8005930:	4337      	orrs	r7, r6
 8005932:	829f      	strh	r7, [r3, #20]
 8005934:	4e14      	ldr	r6, [pc, #80]	; (8005988 <.text_56>)
 8005936:	403e      	ands	r6, r7
 8005938:	402a      	ands	r2, r5
 800593a:	4332      	orrs	r2, r6
 800593c:	829a      	strh	r2, [r3, #20]
 800593e:	2506      	movs	r5, #6
 8005940:	711d      	strb	r5, [r3, #4]
 8005942:	ad02      	add	r5, sp, #8
 8005944:	702a      	strb	r2, [r5, #0]
 8005946:	8a9a      	ldrh	r2, [r3, #20]
 8005948:	0a12      	lsrs	r2, r2, #8
 800594a:	706a      	strb	r2, [r5, #1]
 800594c:	8b5a      	ldrh	r2, [r3, #26]
 800594e:	70aa      	strb	r2, [r5, #2]
 8005950:	8b5a      	ldrh	r2, [r3, #26]
 8005952:	0a12      	lsrs	r2, r2, #8
 8005954:	70ea      	strb	r2, [r5, #3]
 8005956:	2200      	movs	r2, #0
 8005958:	80aa      	strh	r2, [r5, #4]
 800595a:	0006      	movs	r6, r0
 800595c:	000d      	movs	r5, r1
 800595e:	2000      	movs	r0, #0
 8005960:	9001      	str	r0, [sp, #4]
 8005962:	2006      	movs	r0, #6
 8005964:	9000      	str	r0, [sp, #0]
 8005966:	ab02      	add	r3, sp, #8
 8005968:	0022      	movs	r2, r4
 800596a:	0029      	movs	r1, r5
 800596c:	0030      	movs	r0, r6
 800596e:	f7ff fb29 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8005972:	2803      	cmp	r0, #3
 8005974:	d0f3      	beq.n	800595e <USBPD_PRL_ManageExtendedRx+0x72>
 8005976:	2000      	movs	r0, #0
 8005978:	b005      	add	sp, #20
 800597a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800597c <.text_53>:
 800597c:	200019bc 	.word	0x200019bc

08005980 <.text_54>:
 8005980:	200019b4 	.word	0x200019b4

08005984 <.text_55>:
 8005984:	000083ff 	.word	0x000083ff

08005988 <.text_56>:
 8005988:	0000ffe0 	.word	0x0000ffe0

0800598c <.text_57>:
 800598c:	00008fff 	.word	0x00008fff

08005990 <strlen>:
 8005990:	2300      	movs	r3, #0
 8005992:	5cc2      	ldrb	r2, [r0, r3]
 8005994:	3301      	adds	r3, #1
 8005996:	2a00      	cmp	r2, #0
 8005998:	d1fb      	bne.n	8005992 <strlen+0x2>
 800599a:	1e58      	subs	r0, r3, #1
 800599c:	4770      	bx	lr
	...

080059a0 <__gnu_thumb1_case_sqi>:
 80059a0:	b402      	push	{r1}
 80059a2:	4671      	mov	r1, lr
 80059a4:	0849      	lsrs	r1, r1, #1
 80059a6:	0049      	lsls	r1, r1, #1
 80059a8:	5609      	ldrsb	r1, [r1, r0]
 80059aa:	0049      	lsls	r1, r1, #1
 80059ac:	448e      	add	lr, r1
 80059ae:	bc02      	pop	{r1}
 80059b0:	4770      	bx	lr
 80059b2:	46c0      	nop			; (mov r8, r8)

080059b4 <__gnu_thumb1_case_uqi>:
 80059b4:	b402      	push	{r1}
 80059b6:	4671      	mov	r1, lr
 80059b8:	0849      	lsrs	r1, r1, #1
 80059ba:	0049      	lsls	r1, r1, #1
 80059bc:	5c09      	ldrb	r1, [r1, r0]
 80059be:	0049      	lsls	r1, r1, #1
 80059c0:	448e      	add	lr, r1
 80059c2:	bc02      	pop	{r1}
 80059c4:	4770      	bx	lr
 80059c6:	46c0      	nop			; (mov r8, r8)

080059c8 <__udivsi3>:
 80059c8:	2200      	movs	r2, #0
 80059ca:	0843      	lsrs	r3, r0, #1
 80059cc:	428b      	cmp	r3, r1
 80059ce:	d374      	bcc.n	8005aba <__udivsi3+0xf2>
 80059d0:	0903      	lsrs	r3, r0, #4
 80059d2:	428b      	cmp	r3, r1
 80059d4:	d35f      	bcc.n	8005a96 <__udivsi3+0xce>
 80059d6:	0a03      	lsrs	r3, r0, #8
 80059d8:	428b      	cmp	r3, r1
 80059da:	d344      	bcc.n	8005a66 <__udivsi3+0x9e>
 80059dc:	0b03      	lsrs	r3, r0, #12
 80059de:	428b      	cmp	r3, r1
 80059e0:	d328      	bcc.n	8005a34 <__udivsi3+0x6c>
 80059e2:	0c03      	lsrs	r3, r0, #16
 80059e4:	428b      	cmp	r3, r1
 80059e6:	d30d      	bcc.n	8005a04 <__udivsi3+0x3c>
 80059e8:	22ff      	movs	r2, #255	; 0xff
 80059ea:	0209      	lsls	r1, r1, #8
 80059ec:	ba12      	rev	r2, r2
 80059ee:	0c03      	lsrs	r3, r0, #16
 80059f0:	428b      	cmp	r3, r1
 80059f2:	d302      	bcc.n	80059fa <__udivsi3+0x32>
 80059f4:	1212      	asrs	r2, r2, #8
 80059f6:	0209      	lsls	r1, r1, #8
 80059f8:	d065      	beq.n	8005ac6 <__udivsi3+0xfe>
 80059fa:	0b03      	lsrs	r3, r0, #12
 80059fc:	428b      	cmp	r3, r1
 80059fe:	d319      	bcc.n	8005a34 <__udivsi3+0x6c>
 8005a00:	e000      	b.n	8005a04 <__udivsi3+0x3c>
 8005a02:	0a09      	lsrs	r1, r1, #8
 8005a04:	0bc3      	lsrs	r3, r0, #15
 8005a06:	428b      	cmp	r3, r1
 8005a08:	d301      	bcc.n	8005a0e <__udivsi3+0x46>
 8005a0a:	03cb      	lsls	r3, r1, #15
 8005a0c:	1ac0      	subs	r0, r0, r3
 8005a0e:	4152      	adcs	r2, r2
 8005a10:	0b83      	lsrs	r3, r0, #14
 8005a12:	428b      	cmp	r3, r1
 8005a14:	d301      	bcc.n	8005a1a <__udivsi3+0x52>
 8005a16:	038b      	lsls	r3, r1, #14
 8005a18:	1ac0      	subs	r0, r0, r3
 8005a1a:	4152      	adcs	r2, r2
 8005a1c:	0b43      	lsrs	r3, r0, #13
 8005a1e:	428b      	cmp	r3, r1
 8005a20:	d301      	bcc.n	8005a26 <__udivsi3+0x5e>
 8005a22:	034b      	lsls	r3, r1, #13
 8005a24:	1ac0      	subs	r0, r0, r3
 8005a26:	4152      	adcs	r2, r2
 8005a28:	0b03      	lsrs	r3, r0, #12
 8005a2a:	428b      	cmp	r3, r1
 8005a2c:	d301      	bcc.n	8005a32 <__udivsi3+0x6a>
 8005a2e:	030b      	lsls	r3, r1, #12
 8005a30:	1ac0      	subs	r0, r0, r3
 8005a32:	4152      	adcs	r2, r2
 8005a34:	0ac3      	lsrs	r3, r0, #11
 8005a36:	428b      	cmp	r3, r1
 8005a38:	d301      	bcc.n	8005a3e <__udivsi3+0x76>
 8005a3a:	02cb      	lsls	r3, r1, #11
 8005a3c:	1ac0      	subs	r0, r0, r3
 8005a3e:	4152      	adcs	r2, r2
 8005a40:	0a83      	lsrs	r3, r0, #10
 8005a42:	428b      	cmp	r3, r1
 8005a44:	d301      	bcc.n	8005a4a <__udivsi3+0x82>
 8005a46:	028b      	lsls	r3, r1, #10
 8005a48:	1ac0      	subs	r0, r0, r3
 8005a4a:	4152      	adcs	r2, r2
 8005a4c:	0a43      	lsrs	r3, r0, #9
 8005a4e:	428b      	cmp	r3, r1
 8005a50:	d301      	bcc.n	8005a56 <__udivsi3+0x8e>
 8005a52:	024b      	lsls	r3, r1, #9
 8005a54:	1ac0      	subs	r0, r0, r3
 8005a56:	4152      	adcs	r2, r2
 8005a58:	0a03      	lsrs	r3, r0, #8
 8005a5a:	428b      	cmp	r3, r1
 8005a5c:	d301      	bcc.n	8005a62 <__udivsi3+0x9a>
 8005a5e:	020b      	lsls	r3, r1, #8
 8005a60:	1ac0      	subs	r0, r0, r3
 8005a62:	4152      	adcs	r2, r2
 8005a64:	d2cd      	bcs.n	8005a02 <__udivsi3+0x3a>
 8005a66:	09c3      	lsrs	r3, r0, #7
 8005a68:	428b      	cmp	r3, r1
 8005a6a:	d301      	bcc.n	8005a70 <__udivsi3+0xa8>
 8005a6c:	01cb      	lsls	r3, r1, #7
 8005a6e:	1ac0      	subs	r0, r0, r3
 8005a70:	4152      	adcs	r2, r2
 8005a72:	0983      	lsrs	r3, r0, #6
 8005a74:	428b      	cmp	r3, r1
 8005a76:	d301      	bcc.n	8005a7c <__udivsi3+0xb4>
 8005a78:	018b      	lsls	r3, r1, #6
 8005a7a:	1ac0      	subs	r0, r0, r3
 8005a7c:	4152      	adcs	r2, r2
 8005a7e:	0943      	lsrs	r3, r0, #5
 8005a80:	428b      	cmp	r3, r1
 8005a82:	d301      	bcc.n	8005a88 <__udivsi3+0xc0>
 8005a84:	014b      	lsls	r3, r1, #5
 8005a86:	1ac0      	subs	r0, r0, r3
 8005a88:	4152      	adcs	r2, r2
 8005a8a:	0903      	lsrs	r3, r0, #4
 8005a8c:	428b      	cmp	r3, r1
 8005a8e:	d301      	bcc.n	8005a94 <__udivsi3+0xcc>
 8005a90:	010b      	lsls	r3, r1, #4
 8005a92:	1ac0      	subs	r0, r0, r3
 8005a94:	4152      	adcs	r2, r2
 8005a96:	08c3      	lsrs	r3, r0, #3
 8005a98:	428b      	cmp	r3, r1
 8005a9a:	d301      	bcc.n	8005aa0 <__udivsi3+0xd8>
 8005a9c:	00cb      	lsls	r3, r1, #3
 8005a9e:	1ac0      	subs	r0, r0, r3
 8005aa0:	4152      	adcs	r2, r2
 8005aa2:	0883      	lsrs	r3, r0, #2
 8005aa4:	428b      	cmp	r3, r1
 8005aa6:	d301      	bcc.n	8005aac <__udivsi3+0xe4>
 8005aa8:	008b      	lsls	r3, r1, #2
 8005aaa:	1ac0      	subs	r0, r0, r3
 8005aac:	4152      	adcs	r2, r2
 8005aae:	0843      	lsrs	r3, r0, #1
 8005ab0:	428b      	cmp	r3, r1
 8005ab2:	d301      	bcc.n	8005ab8 <__udivsi3+0xf0>
 8005ab4:	004b      	lsls	r3, r1, #1
 8005ab6:	1ac0      	subs	r0, r0, r3
 8005ab8:	4152      	adcs	r2, r2
 8005aba:	1a41      	subs	r1, r0, r1
 8005abc:	d200      	bcs.n	8005ac0 <__udivsi3+0xf8>
 8005abe:	4601      	mov	r1, r0
 8005ac0:	4152      	adcs	r2, r2
 8005ac2:	4610      	mov	r0, r2
 8005ac4:	4770      	bx	lr
 8005ac6:	e7ff      	b.n	8005ac8 <__udivsi3+0x100>
 8005ac8:	b501      	push	{r0, lr}
 8005aca:	2000      	movs	r0, #0
 8005acc:	f000 f8f0 	bl	8005cb0 <__aeabi_idiv0>
 8005ad0:	bd02      	pop	{r1, pc}
 8005ad2:	46c0      	nop			; (mov r8, r8)

08005ad4 <__aeabi_uidivmod>:
 8005ad4:	2900      	cmp	r1, #0
 8005ad6:	d0f7      	beq.n	8005ac8 <__udivsi3+0x100>
 8005ad8:	e776      	b.n	80059c8 <__udivsi3>
 8005ada:	4770      	bx	lr

08005adc <__divsi3>:
 8005adc:	4603      	mov	r3, r0
 8005ade:	430b      	orrs	r3, r1
 8005ae0:	d47f      	bmi.n	8005be2 <__divsi3+0x106>
 8005ae2:	2200      	movs	r2, #0
 8005ae4:	0843      	lsrs	r3, r0, #1
 8005ae6:	428b      	cmp	r3, r1
 8005ae8:	d374      	bcc.n	8005bd4 <__divsi3+0xf8>
 8005aea:	0903      	lsrs	r3, r0, #4
 8005aec:	428b      	cmp	r3, r1
 8005aee:	d35f      	bcc.n	8005bb0 <__divsi3+0xd4>
 8005af0:	0a03      	lsrs	r3, r0, #8
 8005af2:	428b      	cmp	r3, r1
 8005af4:	d344      	bcc.n	8005b80 <__divsi3+0xa4>
 8005af6:	0b03      	lsrs	r3, r0, #12
 8005af8:	428b      	cmp	r3, r1
 8005afa:	d328      	bcc.n	8005b4e <__divsi3+0x72>
 8005afc:	0c03      	lsrs	r3, r0, #16
 8005afe:	428b      	cmp	r3, r1
 8005b00:	d30d      	bcc.n	8005b1e <__divsi3+0x42>
 8005b02:	22ff      	movs	r2, #255	; 0xff
 8005b04:	0209      	lsls	r1, r1, #8
 8005b06:	ba12      	rev	r2, r2
 8005b08:	0c03      	lsrs	r3, r0, #16
 8005b0a:	428b      	cmp	r3, r1
 8005b0c:	d302      	bcc.n	8005b14 <__divsi3+0x38>
 8005b0e:	1212      	asrs	r2, r2, #8
 8005b10:	0209      	lsls	r1, r1, #8
 8005b12:	d065      	beq.n	8005be0 <__divsi3+0x104>
 8005b14:	0b03      	lsrs	r3, r0, #12
 8005b16:	428b      	cmp	r3, r1
 8005b18:	d319      	bcc.n	8005b4e <__divsi3+0x72>
 8005b1a:	e000      	b.n	8005b1e <__divsi3+0x42>
 8005b1c:	0a09      	lsrs	r1, r1, #8
 8005b1e:	0bc3      	lsrs	r3, r0, #15
 8005b20:	428b      	cmp	r3, r1
 8005b22:	d301      	bcc.n	8005b28 <__divsi3+0x4c>
 8005b24:	03cb      	lsls	r3, r1, #15
 8005b26:	1ac0      	subs	r0, r0, r3
 8005b28:	4152      	adcs	r2, r2
 8005b2a:	0b83      	lsrs	r3, r0, #14
 8005b2c:	428b      	cmp	r3, r1
 8005b2e:	d301      	bcc.n	8005b34 <__divsi3+0x58>
 8005b30:	038b      	lsls	r3, r1, #14
 8005b32:	1ac0      	subs	r0, r0, r3
 8005b34:	4152      	adcs	r2, r2
 8005b36:	0b43      	lsrs	r3, r0, #13
 8005b38:	428b      	cmp	r3, r1
 8005b3a:	d301      	bcc.n	8005b40 <__divsi3+0x64>
 8005b3c:	034b      	lsls	r3, r1, #13
 8005b3e:	1ac0      	subs	r0, r0, r3
 8005b40:	4152      	adcs	r2, r2
 8005b42:	0b03      	lsrs	r3, r0, #12
 8005b44:	428b      	cmp	r3, r1
 8005b46:	d301      	bcc.n	8005b4c <__divsi3+0x70>
 8005b48:	030b      	lsls	r3, r1, #12
 8005b4a:	1ac0      	subs	r0, r0, r3
 8005b4c:	4152      	adcs	r2, r2
 8005b4e:	0ac3      	lsrs	r3, r0, #11
 8005b50:	428b      	cmp	r3, r1
 8005b52:	d301      	bcc.n	8005b58 <__divsi3+0x7c>
 8005b54:	02cb      	lsls	r3, r1, #11
 8005b56:	1ac0      	subs	r0, r0, r3
 8005b58:	4152      	adcs	r2, r2
 8005b5a:	0a83      	lsrs	r3, r0, #10
 8005b5c:	428b      	cmp	r3, r1
 8005b5e:	d301      	bcc.n	8005b64 <__divsi3+0x88>
 8005b60:	028b      	lsls	r3, r1, #10
 8005b62:	1ac0      	subs	r0, r0, r3
 8005b64:	4152      	adcs	r2, r2
 8005b66:	0a43      	lsrs	r3, r0, #9
 8005b68:	428b      	cmp	r3, r1
 8005b6a:	d301      	bcc.n	8005b70 <__divsi3+0x94>
 8005b6c:	024b      	lsls	r3, r1, #9
 8005b6e:	1ac0      	subs	r0, r0, r3
 8005b70:	4152      	adcs	r2, r2
 8005b72:	0a03      	lsrs	r3, r0, #8
 8005b74:	428b      	cmp	r3, r1
 8005b76:	d301      	bcc.n	8005b7c <__divsi3+0xa0>
 8005b78:	020b      	lsls	r3, r1, #8
 8005b7a:	1ac0      	subs	r0, r0, r3
 8005b7c:	4152      	adcs	r2, r2
 8005b7e:	d2cd      	bcs.n	8005b1c <__divsi3+0x40>
 8005b80:	09c3      	lsrs	r3, r0, #7
 8005b82:	428b      	cmp	r3, r1
 8005b84:	d301      	bcc.n	8005b8a <__divsi3+0xae>
 8005b86:	01cb      	lsls	r3, r1, #7
 8005b88:	1ac0      	subs	r0, r0, r3
 8005b8a:	4152      	adcs	r2, r2
 8005b8c:	0983      	lsrs	r3, r0, #6
 8005b8e:	428b      	cmp	r3, r1
 8005b90:	d301      	bcc.n	8005b96 <__divsi3+0xba>
 8005b92:	018b      	lsls	r3, r1, #6
 8005b94:	1ac0      	subs	r0, r0, r3
 8005b96:	4152      	adcs	r2, r2
 8005b98:	0943      	lsrs	r3, r0, #5
 8005b9a:	428b      	cmp	r3, r1
 8005b9c:	d301      	bcc.n	8005ba2 <__divsi3+0xc6>
 8005b9e:	014b      	lsls	r3, r1, #5
 8005ba0:	1ac0      	subs	r0, r0, r3
 8005ba2:	4152      	adcs	r2, r2
 8005ba4:	0903      	lsrs	r3, r0, #4
 8005ba6:	428b      	cmp	r3, r1
 8005ba8:	d301      	bcc.n	8005bae <__divsi3+0xd2>
 8005baa:	010b      	lsls	r3, r1, #4
 8005bac:	1ac0      	subs	r0, r0, r3
 8005bae:	4152      	adcs	r2, r2
 8005bb0:	08c3      	lsrs	r3, r0, #3
 8005bb2:	428b      	cmp	r3, r1
 8005bb4:	d301      	bcc.n	8005bba <__divsi3+0xde>
 8005bb6:	00cb      	lsls	r3, r1, #3
 8005bb8:	1ac0      	subs	r0, r0, r3
 8005bba:	4152      	adcs	r2, r2
 8005bbc:	0883      	lsrs	r3, r0, #2
 8005bbe:	428b      	cmp	r3, r1
 8005bc0:	d301      	bcc.n	8005bc6 <__divsi3+0xea>
 8005bc2:	008b      	lsls	r3, r1, #2
 8005bc4:	1ac0      	subs	r0, r0, r3
 8005bc6:	4152      	adcs	r2, r2
 8005bc8:	0843      	lsrs	r3, r0, #1
 8005bca:	428b      	cmp	r3, r1
 8005bcc:	d301      	bcc.n	8005bd2 <__divsi3+0xf6>
 8005bce:	004b      	lsls	r3, r1, #1
 8005bd0:	1ac0      	subs	r0, r0, r3
 8005bd2:	4152      	adcs	r2, r2
 8005bd4:	1a41      	subs	r1, r0, r1
 8005bd6:	d200      	bcs.n	8005bda <__divsi3+0xfe>
 8005bd8:	4601      	mov	r1, r0
 8005bda:	4152      	adcs	r2, r2
 8005bdc:	4610      	mov	r0, r2
 8005bde:	4770      	bx	lr
 8005be0:	e05d      	b.n	8005c9e <__divsi3+0x1c2>
 8005be2:	0fca      	lsrs	r2, r1, #31
 8005be4:	d000      	beq.n	8005be8 <__divsi3+0x10c>
 8005be6:	4249      	negs	r1, r1
 8005be8:	1003      	asrs	r3, r0, #32
 8005bea:	d300      	bcc.n	8005bee <__divsi3+0x112>
 8005bec:	4240      	negs	r0, r0
 8005bee:	4053      	eors	r3, r2
 8005bf0:	2200      	movs	r2, #0
 8005bf2:	469c      	mov	ip, r3
 8005bf4:	0903      	lsrs	r3, r0, #4
 8005bf6:	428b      	cmp	r3, r1
 8005bf8:	d32d      	bcc.n	8005c56 <__divsi3+0x17a>
 8005bfa:	0a03      	lsrs	r3, r0, #8
 8005bfc:	428b      	cmp	r3, r1
 8005bfe:	d312      	bcc.n	8005c26 <__divsi3+0x14a>
 8005c00:	22fc      	movs	r2, #252	; 0xfc
 8005c02:	0189      	lsls	r1, r1, #6
 8005c04:	ba12      	rev	r2, r2
 8005c06:	0a03      	lsrs	r3, r0, #8
 8005c08:	428b      	cmp	r3, r1
 8005c0a:	d30c      	bcc.n	8005c26 <__divsi3+0x14a>
 8005c0c:	0189      	lsls	r1, r1, #6
 8005c0e:	1192      	asrs	r2, r2, #6
 8005c10:	428b      	cmp	r3, r1
 8005c12:	d308      	bcc.n	8005c26 <__divsi3+0x14a>
 8005c14:	0189      	lsls	r1, r1, #6
 8005c16:	1192      	asrs	r2, r2, #6
 8005c18:	428b      	cmp	r3, r1
 8005c1a:	d304      	bcc.n	8005c26 <__divsi3+0x14a>
 8005c1c:	0189      	lsls	r1, r1, #6
 8005c1e:	d03a      	beq.n	8005c96 <__divsi3+0x1ba>
 8005c20:	1192      	asrs	r2, r2, #6
 8005c22:	e000      	b.n	8005c26 <__divsi3+0x14a>
 8005c24:	0989      	lsrs	r1, r1, #6
 8005c26:	09c3      	lsrs	r3, r0, #7
 8005c28:	428b      	cmp	r3, r1
 8005c2a:	d301      	bcc.n	8005c30 <__divsi3+0x154>
 8005c2c:	01cb      	lsls	r3, r1, #7
 8005c2e:	1ac0      	subs	r0, r0, r3
 8005c30:	4152      	adcs	r2, r2
 8005c32:	0983      	lsrs	r3, r0, #6
 8005c34:	428b      	cmp	r3, r1
 8005c36:	d301      	bcc.n	8005c3c <__divsi3+0x160>
 8005c38:	018b      	lsls	r3, r1, #6
 8005c3a:	1ac0      	subs	r0, r0, r3
 8005c3c:	4152      	adcs	r2, r2
 8005c3e:	0943      	lsrs	r3, r0, #5
 8005c40:	428b      	cmp	r3, r1
 8005c42:	d301      	bcc.n	8005c48 <__divsi3+0x16c>
 8005c44:	014b      	lsls	r3, r1, #5
 8005c46:	1ac0      	subs	r0, r0, r3
 8005c48:	4152      	adcs	r2, r2
 8005c4a:	0903      	lsrs	r3, r0, #4
 8005c4c:	428b      	cmp	r3, r1
 8005c4e:	d301      	bcc.n	8005c54 <__divsi3+0x178>
 8005c50:	010b      	lsls	r3, r1, #4
 8005c52:	1ac0      	subs	r0, r0, r3
 8005c54:	4152      	adcs	r2, r2
 8005c56:	08c3      	lsrs	r3, r0, #3
 8005c58:	428b      	cmp	r3, r1
 8005c5a:	d301      	bcc.n	8005c60 <__divsi3+0x184>
 8005c5c:	00cb      	lsls	r3, r1, #3
 8005c5e:	1ac0      	subs	r0, r0, r3
 8005c60:	4152      	adcs	r2, r2
 8005c62:	0883      	lsrs	r3, r0, #2
 8005c64:	428b      	cmp	r3, r1
 8005c66:	d301      	bcc.n	8005c6c <__divsi3+0x190>
 8005c68:	008b      	lsls	r3, r1, #2
 8005c6a:	1ac0      	subs	r0, r0, r3
 8005c6c:	4152      	adcs	r2, r2
 8005c6e:	d2d9      	bcs.n	8005c24 <__divsi3+0x148>
 8005c70:	0843      	lsrs	r3, r0, #1
 8005c72:	428b      	cmp	r3, r1
 8005c74:	d301      	bcc.n	8005c7a <__divsi3+0x19e>
 8005c76:	004b      	lsls	r3, r1, #1
 8005c78:	1ac0      	subs	r0, r0, r3
 8005c7a:	4152      	adcs	r2, r2
 8005c7c:	1a41      	subs	r1, r0, r1
 8005c7e:	d200      	bcs.n	8005c82 <__divsi3+0x1a6>
 8005c80:	4601      	mov	r1, r0
 8005c82:	4663      	mov	r3, ip
 8005c84:	4152      	adcs	r2, r2
 8005c86:	105b      	asrs	r3, r3, #1
 8005c88:	4610      	mov	r0, r2
 8005c8a:	d301      	bcc.n	8005c90 <__divsi3+0x1b4>
 8005c8c:	4240      	negs	r0, r0
 8005c8e:	2b00      	cmp	r3, #0
 8005c90:	d500      	bpl.n	8005c94 <__divsi3+0x1b8>
 8005c92:	4249      	negs	r1, r1
 8005c94:	4770      	bx	lr
 8005c96:	4663      	mov	r3, ip
 8005c98:	105b      	asrs	r3, r3, #1
 8005c9a:	d300      	bcc.n	8005c9e <__divsi3+0x1c2>
 8005c9c:	4240      	negs	r0, r0
 8005c9e:	b501      	push	{r0, lr}
 8005ca0:	2000      	movs	r0, #0
 8005ca2:	f000 f805 	bl	8005cb0 <__aeabi_idiv0>
 8005ca6:	bd02      	pop	{r1, pc}

08005ca8 <__aeabi_idivmod>:
 8005ca8:	2900      	cmp	r1, #0
 8005caa:	d0f8      	beq.n	8005c9e <__divsi3+0x1c2>
 8005cac:	e716      	b.n	8005adc <__divsi3>
 8005cae:	4770      	bx	lr

08005cb0 <__aeabi_idiv0>:
 8005cb0:	4770      	bx	lr
 8005cb2:	46c0      	nop			; (mov r8, r8)

08005cb4 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8005cb4:	480d      	ldr	r0, [pc, #52]	; (8005cec <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8005cb6:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 8005cb8:	2100      	movs	r1, #0
  b LoopCopyDataInit
 8005cba:	e003      	b.n	8005cc4 <LoopCopyDataInit>

08005cbc <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 8005cbc:	4b0c      	ldr	r3, [pc, #48]	; (8005cf0 <LoopForever+0x6>)
  ldr r3, [r3, r1]
 8005cbe:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 8005cc0:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 8005cc2:	3104      	adds	r1, #4

08005cc4 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 8005cc4:	480b      	ldr	r0, [pc, #44]	; (8005cf4 <LoopForever+0xa>)
  ldr r3, =_edata
 8005cc6:	4b0c      	ldr	r3, [pc, #48]	; (8005cf8 <LoopForever+0xe>)
  adds r2, r0, r1
 8005cc8:	1842      	adds	r2, r0, r1
  cmp r2, r3
 8005cca:	429a      	cmp	r2, r3
  bcc CopyDataInit
 8005ccc:	d3f6      	bcc.n	8005cbc <CopyDataInit>
  ldr r2, =_sbss
 8005cce:	4a0b      	ldr	r2, [pc, #44]	; (8005cfc <LoopForever+0x12>)
  b LoopFillZerobss
 8005cd0:	e002      	b.n	8005cd8 <LoopFillZerobss>

08005cd2 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 8005cd2:	2300      	movs	r3, #0
  str  r3, [r2]
 8005cd4:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8005cd6:	3204      	adds	r2, #4

08005cd8 <LoopFillZerobss>:


LoopFillZerobss:
  ldr r3, = _ebss
 8005cd8:	4b09      	ldr	r3, [pc, #36]	; (8005d00 <LoopForever+0x16>)
  cmp r2, r3
 8005cda:	429a      	cmp	r2, r3
  bcc FillZerobss
 8005cdc:	d3f9      	bcc.n	8005cd2 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 8005cde:	f001 f9b5 	bl	800704c <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 8005ce2:	f006 feb5 	bl	800ca50 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8005ce6:	f000 f80f 	bl	8005d08 <main>

08005cea <LoopForever>:

LoopForever:
    b LoopForever
 8005cea:	e7fe      	b.n	8005cea <LoopForever>
  ldr   r0, =_estack
 8005cec:	20004000 	.word	0x20004000
  ldr r3, =_sidata
 8005cf0:	0800cdf4 	.word	0x0800cdf4
  ldr r0, =_sdata
 8005cf4:	20000000 	.word	0x20000000
  ldr r3, =_edata
 8005cf8:	200002a8 	.word	0x200002a8
  ldr r2, =_sbss
 8005cfc:	200002a8 	.word	0x200002a8
  ldr r3, = _ebss
 8005d00:	20001dc8 	.word	0x20001dc8

08005d04 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8005d04:	e7fe      	b.n	8005d04 <ADC1_COMP_IRQHandler>
	...

08005d08 <main>:
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
 8005d08:	b510      	push	{r4, lr}
  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8005d0a:	f001 f9e1 	bl	80070d0 <HAL_Init>
  *         @arg @ref LL_FLASH_LATENCY_1
  * @retval None
  */
__STATIC_INLINE void LL_FLASH_SetLatency(uint32_t Latency)
{
  MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
 8005d0e:	2101      	movs	r1, #1
 8005d10:	4a2d      	ldr	r2, [pc, #180]	; (8005dc8 <main+0xc0>)
 8005d12:	6813      	ldr	r3, [r2, #0]
 8005d14:	430b      	orrs	r3, r1
 8005d16:	6013      	str	r3, [r2, #0]
  * @rmtoll CR2          HSI48ON       LL_RCC_HSI48_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI48_Enable(void)
{
  SET_BIT(RCC->CR2, RCC_CR2_HSI48ON);
 8005d18:	2280      	movs	r2, #128	; 0x80
 8005d1a:	4b2c      	ldr	r3, [pc, #176]	; (8005dcc <main+0xc4>)
 8005d1c:	0252      	lsls	r2, r2, #9
 8005d1e:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8005d20:	430a      	orrs	r2, r1
 8005d22:	635a      	str	r2, [r3, #52]	; 0x34
  * @rmtoll CR2          HSI48RDY      LL_RCC_HSI48_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI48_IsReady(void)
{
  return (READ_BIT(RCC->CR2, RCC_CR2_HSI48RDY) == (RCC_CR2_HSI48RDY));
 8005d24:	2280      	movs	r2, #128	; 0x80
 8005d26:	0292      	lsls	r2, r2, #10
 8005d28:	6b59      	ldr	r1, [r3, #52]	; 0x34
  /* Set FLASH latency */ 
  LL_FLASH_SetLatency(LL_FLASH_LATENCY_1);

  /* Enable HSI48 and wait for activation*/
  LL_RCC_HSI48_Enable(); 
  while(LL_RCC_HSI48_IsReady() != 1) 
 8005d2a:	4211      	tst	r1, r2
 8005d2c:	d0fc      	beq.n	8005d28 <main+0x20>
  *         @arg @ref LL_RCC_PREDIV_DIV_16
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_ConfigDomain_SYS(uint32_t Source, uint32_t PLLMul, uint32_t PLLDiv)
{
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL, Source | PLLMul);
 8005d2e:	685a      	ldr	r2, [r3, #4]
 8005d30:	4927      	ldr	r1, [pc, #156]	; (8005dd0 <main+0xc8>)
 8005d32:	4011      	ands	r1, r2
 8005d34:	22c0      	movs	r2, #192	; 0xc0
 8005d36:	0252      	lsls	r2, r2, #9
 8005d38:	430a      	orrs	r2, r1
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, PLLDiv);
 8005d3a:	210f      	movs	r1, #15
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL, Source | PLLMul);
 8005d3c:	605a      	str	r2, [r3, #4]
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, PLLDiv);
 8005d3e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005d40:	438a      	bics	r2, r1
 8005d42:	0011      	movs	r1, r2
 8005d44:	2201      	movs	r2, #1
 8005d46:	430a      	orrs	r2, r1
 8005d48:	62da      	str	r2, [r3, #44]	; 0x2c
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 8005d4a:	2280      	movs	r2, #128	; 0x80
 8005d4c:	6819      	ldr	r1, [r3, #0]
 8005d4e:	0452      	lsls	r2, r2, #17
 8005d50:	430a      	orrs	r2, r1
 8005d52:	601a      	str	r2, [r3, #0]
  return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
 8005d54:	2280      	movs	r2, #128	; 0x80
 8005d56:	0492      	lsls	r2, r2, #18
 8005d58:	6819      	ldr	r1, [r3, #0]
  
  /* Main PLL configuration and activation */
  LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI48, LL_RCC_PLL_MUL_2, LL_RCC_PREDIV_DIV_2);
  
  LL_RCC_PLL_Enable();
  while(LL_RCC_PLL_IsReady() != 1)
 8005d5a:	4211      	tst	r1, r2
 8005d5c:	d0fc      	beq.n	8005d58 <main+0x50>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 8005d5e:	21f0      	movs	r1, #240	; 0xf0
 8005d60:	685a      	ldr	r2, [r3, #4]
 8005d62:	438a      	bics	r2, r1
 8005d64:	605a      	str	r2, [r3, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8005d66:	685a      	ldr	r2, [r3, #4]
 8005d68:	39ed      	subs	r1, #237	; 0xed
 8005d6a:	438a      	bics	r2, r1
 8005d6c:	0011      	movs	r1, r2
 8005d6e:	2202      	movs	r2, #2
 8005d70:	430a      	orrs	r2, r1
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8005d72:	210c      	movs	r1, #12
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8005d74:	605a      	str	r2, [r3, #4]
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8005d76:	685a      	ldr	r2, [r3, #4]
 8005d78:	400a      	ands	r2, r1
  };
  
  /* Sysclk activation on the main PLL */
  LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
  LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
  while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
 8005d7a:	2a08      	cmp	r2, #8
 8005d7c:	d1fb      	bne.n	8005d76 <main+0x6e>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, Prescaler);
 8005d7e:	685a      	ldr	r2, [r3, #4]
 8005d80:	4914      	ldr	r1, [pc, #80]	; (8005dd4 <main+0xcc>)
  LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);
  
  /* Set systick to 1ms in using frequency set to 48MHz */
  /* This frequency can be calculated through LL RCC macro */
  /* ex: __LL_RCC_CALC_PLLCLK_FREQ (HSI48_VALUE, LL_RCC_PLL_MUL_2, LL_RCC_PREDIV_DIV_2) */
  LL_Init1msTick(48000000);
 8005d82:	4815      	ldr	r0, [pc, #84]	; (8005dd8 <main+0xd0>)
 8005d84:	400a      	ands	r2, r1
 8005d86:	605a      	str	r2, [r3, #4]
 8005d88:	f003 fbf6 	bl	8009578 <LL_Init1msTick>
  
  /* Update CMSIS variable (which can be updated also through SystemCoreClockUpdate function) */
  LL_SetSystemCoreClock(48000000);
 8005d8c:	4812      	ldr	r0, [pc, #72]	; (8005dd8 <main+0xd0>)
 8005d8e:	f003 fc03 	bl	8009598 <LL_SetSystemCoreClock>
  HAL_NVIC_SetPriority(SysTick_IRQn, TICK_INT_PRIORITY ,0U);
 8005d92:	2001      	movs	r0, #1
 8005d94:	2200      	movs	r2, #0
 8005d96:	4240      	negs	r0, r0
 8005d98:	2103      	movs	r1, #3
 8005d9a:	f001 fc23 	bl	80075e4 <HAL_NVIC_SetPriority>
  * @rmtoll STK_CTRL     TICKINT       LL_SYSTICK_EnableIT
  * @retval None
  */
__STATIC_INLINE void LL_SYSTICK_EnableIT(void)
{
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 8005d9e:	2302      	movs	r3, #2
 8005da0:	4a0e      	ldr	r2, [pc, #56]	; (8005ddc <main+0xd4>)
 8005da2:	6811      	ldr	r1, [r2, #0]
 8005da4:	430b      	orrs	r3, r1
 8005da6:	6013      	str	r3, [r2, #0]
  USBPD_BSP_LED_Init();
 8005da8:	f001 f8e8 	bl	8006f7c <USBPD_BSP_LED_Init>
  USBPD_HW_IF_GlobalHwInit();
 8005dac:	f004 fbee 	bl	800a58c <USBPD_HW_IF_GlobalHwInit>
  USBPD_BSP_UART_Init();
 8005db0:	f001 f90c 	bl	8006fcc <USBPD_BSP_UART_Init>
  HAL_UART_MspInit(&huart2);
 8005db4:	480a      	ldr	r0, [pc, #40]	; (8005de0 <main+0xd8>)
 8005db6:	f001 f921 	bl	8006ffc <HAL_UART_MspInit>
  if( USBPD_ERROR == USBPD_DPM_Init())
 8005dba:	f003 fc91 	bl	80096e0 <USBPD_DPM_Init>
 8005dbe:	2802      	cmp	r0, #2
 8005dc0:	d100      	bne.n	8005dc4 <main+0xbc>
 8005dc2:	e7fe      	b.n	8005dc2 <main+0xba>
}
 8005dc4:	2000      	movs	r0, #0
 8005dc6:	bd10      	pop	{r4, pc}
 8005dc8:	40022000 	.word	0x40022000
 8005dcc:	40021000 	.word	0x40021000
 8005dd0:	ffc27fff 	.word	0xffc27fff
 8005dd4:	fffff8ff 	.word	0xfffff8ff
 8005dd8:	02dc6c00 	.word	0x02dc6c00
 8005ddc:	e000e010 	.word	0xe000e010
 8005de0:	200019d4 	.word	0x200019d4

08005de4 <HAL_MspInit>:
  *         level initialization (GPIOs, clock, DMA, interrupt).
  * @retval None
  */
void HAL_MspInit(void)
{
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005de4:	2001      	movs	r0, #1
 8005de6:	4b1c      	ldr	r3, [pc, #112]	; (8005e58 <HAL_MspInit+0x74>)
{
 8005de8:	b086      	sub	sp, #24
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005dea:	6999      	ldr	r1, [r3, #24]
 8005dec:	4301      	orrs	r1, r0
 8005dee:	6199      	str	r1, [r3, #24]
 8005df0:	699a      	ldr	r2, [r3, #24]
 8005df2:	4002      	ands	r2, r0
  /* Enable the RCC peripheral clock associated to all the selected GPIOs */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8005df4:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005df6:	9200      	str	r2, [sp, #0]
 8005df8:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8005dfa:	6959      	ldr	r1, [r3, #20]
 8005dfc:	0280      	lsls	r0, r0, #10
 8005dfe:	4301      	orrs	r1, r0
 8005e00:	6159      	str	r1, [r3, #20]
 8005e02:	695a      	ldr	r2, [r3, #20]
 8005e04:	4002      	ands	r2, r0
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8005e06:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8005e08:	9201      	str	r2, [sp, #4]
 8005e0a:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8005e0c:	6959      	ldr	r1, [r3, #20]
 8005e0e:	02c0      	lsls	r0, r0, #11
 8005e10:	4301      	orrs	r1, r0
 8005e12:	6159      	str	r1, [r3, #20]
 8005e14:	695a      	ldr	r2, [r3, #20]
 8005e16:	4002      	ands	r2, r0
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8005e18:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8005e1a:	9202      	str	r2, [sp, #8]
 8005e1c:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8005e1e:	6959      	ldr	r1, [r3, #20]
 8005e20:	0300      	lsls	r0, r0, #12
 8005e22:	4301      	orrs	r1, r0
 8005e24:	6159      	str	r1, [r3, #20]
 8005e26:	695a      	ldr	r2, [r3, #20]
 8005e28:	4002      	ands	r2, r0
#if defined(GPIOD)
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e2a:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8005e2c:	9203      	str	r2, [sp, #12]
 8005e2e:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e30:	6959      	ldr	r1, [r3, #20]
 8005e32:	0340      	lsls	r0, r0, #13
 8005e34:	4301      	orrs	r1, r0
 8005e36:	6159      	str	r1, [r3, #20]
#endif /* GPIOD */
#if defined(GPIOF)
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8005e38:	2180      	movs	r1, #128	; 0x80
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e3a:	695a      	ldr	r2, [r3, #20]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8005e3c:	03c9      	lsls	r1, r1, #15
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e3e:	4002      	ands	r2, r0
 8005e40:	9204      	str	r2, [sp, #16]
 8005e42:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8005e44:	695a      	ldr	r2, [r3, #20]
 8005e46:	430a      	orrs	r2, r1
 8005e48:	615a      	str	r2, [r3, #20]
 8005e4a:	695b      	ldr	r3, [r3, #20]
 8005e4c:	400b      	ands	r3, r1
 8005e4e:	9305      	str	r3, [sp, #20]
 8005e50:	9b05      	ldr	r3, [sp, #20]
#endif /* GPIOD */
}
 8005e52:	b006      	add	sp, #24
 8005e54:	4770      	bx	lr
 8005e56:	46c0      	nop			; (mov r8, r8)
 8005e58:	40021000 	.word	0x40021000

08005e5c <HAL_ADC_MspInit>:
  * @brief ADC MSP Initialization
  * @param hadc: ADC handle pointer
  * @retval None
  */
void HAL_ADC_MspInit(ADC_HandleTypeDef *hadc)
{
 8005e5c:	b513      	push	{r0, r1, r4, lr}
  /* Enable clock of ADCx peripheral */
  ADCx_CLK_ENABLE();
 8005e5e:	2180      	movs	r1, #128	; 0x80
 8005e60:	4c0a      	ldr	r4, [pc, #40]	; (8005e8c <HAL_ADC_MspInit+0x30>)
 8005e62:	0089      	lsls	r1, r1, #2
 8005e64:	69a2      	ldr	r2, [r4, #24]
 8005e66:	430a      	orrs	r2, r1
 8005e68:	61a2      	str	r2, [r4, #24]
 8005e6a:	69a3      	ldr	r3, [r4, #24]
 8005e6c:	400b      	ands	r3, r1
 8005e6e:	9300      	str	r3, [sp, #0]
 8005e70:	9b00      	ldr	r3, [sp, #0]
  PHY_HW_IF_ADCAnalogGPIO_Init();
 8005e72:	f004 f8c5 	bl	800a000 <PHY_HW_IF_ADCAnalogGPIO_Init>
  
  /* Enable clock of DMA associated to the peripheral */
  ADCx_DMA_CLK_ENABLE();
 8005e76:	2101      	movs	r1, #1
 8005e78:	6962      	ldr	r2, [r4, #20]
 8005e7a:	430a      	orrs	r2, r1
 8005e7c:	6162      	str	r2, [r4, #20]
 8005e7e:	6963      	ldr	r3, [r4, #20]
 8005e80:	400b      	ands	r3, r1
 8005e82:	9301      	str	r3, [sp, #4]
 8005e84:	9b01      	ldr	r3, [sp, #4]
  PHY_HW_IF_ADCDMA_Init();
 8005e86:	f004 f8d9 	bl	800a03c <PHY_HW_IF_ADCDMA_Init>
}
 8005e8a:	bd13      	pop	{r0, r1, r4, pc}
 8005e8c:	40021000 	.word	0x40021000

08005e90 <HAL_SPI_MspInit>:
  * @brief SPI MSP Initialization
  * @param hspi: SPI handle pointer
  * @retval None
  */
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8005e90:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  
  uint8_t port_num = GET_PORT_FROM_SPI(hspi);
 8005e92:	4b38      	ldr	r3, [pc, #224]	; (8005f74 <HAL_SPI_MspInit+0xe4>)
 8005e94:	6804      	ldr	r4, [r0, #0]
  
  /* Peripheral clock enable */
  SPI_CLK_ENABLE(port_num);
 8005e96:	4e38      	ldr	r6, [pc, #224]	; (8005f78 <HAL_SPI_MspInit+0xe8>)
  uint8_t port_num = GET_PORT_FROM_SPI(hspi);
 8005e98:	18e5      	adds	r5, r4, r3
 8005e9a:	1e6b      	subs	r3, r5, #1
 8005e9c:	419d      	sbcs	r5, r3
{
 8005e9e:	b089      	sub	sp, #36	; 0x24
  uint8_t port_num = GET_PORT_FROM_SPI(hspi);
 8005ea0:	b2ed      	uxtb	r5, r5
 8005ea2:	4a36      	ldr	r2, [pc, #216]	; (8005f7c <HAL_SPI_MspInit+0xec>)
  SPI_CLK_ENABLE(port_num);
 8005ea4:	42b4      	cmp	r4, r6
 8005ea6:	d159      	bne.n	8005f5c <HAL_SPI_MspInit+0xcc>
 8005ea8:	2380      	movs	r3, #128	; 0x80
 8005eaa:	69d1      	ldr	r1, [r2, #28]
 8005eac:	01db      	lsls	r3, r3, #7
 8005eae:	4319      	orrs	r1, r3
 8005eb0:	61d1      	str	r1, [r2, #28]
 8005eb2:	69d2      	ldr	r2, [r2, #28]
 8005eb4:	401a      	ands	r2, r3
 8005eb6:	9201      	str	r2, [sp, #4]
 8005eb8:	9a01      	ldr	r2, [sp, #4]
  
  GPIO_InitStruct.Pin = SPI_MISO_PIN(port_num);
 8005eba:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005ebc:	2203      	movs	r2, #3
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005ebe:	2300      	movs	r3, #0
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005ec0:	2702      	movs	r7, #2
  GPIO_InitStruct.Alternate = SPI_MISO_ALTERNATE(port_num);
  HAL_GPIO_Init(SPI_MISO_PORT(port_num), &GPIO_InitStruct);
 8005ec2:	a903      	add	r1, sp, #12
 8005ec4:	482e      	ldr	r0, [pc, #184]	; (8005f80 <HAL_SPI_MspInit+0xf0>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005ec6:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = SPI_MISO_ALTERNATE(port_num);
 8005ec8:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005eca:	9704      	str	r7, [sp, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005ecc:	9206      	str	r2, [sp, #24]
  HAL_GPIO_Init(SPI_MISO_PORT(port_num), &GPIO_InitStruct);
 8005ece:	f001 fd63 	bl	8007998 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = SPI_MOSI_PIN(port_num);
 8005ed2:	2320      	movs	r3, #32
 8005ed4:	42b4      	cmp	r4, r6
 8005ed6:	d101      	bne.n	8005edc <HAL_SPI_MspInit+0x4c>
 8005ed8:	2380      	movs	r3, #128	; 0x80
 8005eda:	021b      	lsls	r3, r3, #8
 8005edc:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005ede:	2301      	movs	r3, #1
 8005ee0:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005ee2:	3302      	adds	r3, #2
 8005ee4:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Alternate = SPI_MOSI_ALTERNATE(port_num);
 8005ee6:	2300      	movs	r3, #0
  HAL_GPIO_Init(SPI_MOSI_PORT(port_num), &GPIO_InitStruct);
 8005ee8:	a903      	add	r1, sp, #12
 8005eea:	4825      	ldr	r0, [pc, #148]	; (8005f80 <HAL_SPI_MspInit+0xf0>)
  GPIO_InitStruct.Alternate = SPI_MOSI_ALTERNATE(port_num);
 8005eec:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005eee:	9704      	str	r7, [sp, #16]
  HAL_GPIO_Init(SPI_MOSI_PORT(port_num), &GPIO_InitStruct);
 8005ef0:	f001 fd52 	bl	8007998 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = SPI_CLK_PIN(port_num);
 8005ef4:	2308      	movs	r3, #8
 8005ef6:	42b4      	cmp	r4, r6
 8005ef8:	d101      	bne.n	8005efe <HAL_SPI_MspInit+0x6e>
 8005efa:	2380      	movs	r3, #128	; 0x80
 8005efc:	019b      	lsls	r3, r3, #6
 8005efe:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005f00:	2702      	movs	r7, #2
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005f02:	2601      	movs	r6, #1
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005f04:	2303      	movs	r3, #3
  GPIO_InitStruct.Alternate = SPI_CLK_ALTERNATE(port_num);
 8005f06:	2200      	movs	r2, #0
  HAL_GPIO_Init(SPI_CLK_PORT(port_num), &GPIO_InitStruct);
 8005f08:	a903      	add	r1, sp, #12
 8005f0a:	481d      	ldr	r0, [pc, #116]	; (8005f80 <HAL_SPI_MspInit+0xf0>)
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005f0c:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Alternate = SPI_CLK_ALTERNATE(port_num);
 8005f0e:	9207      	str	r2, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005f10:	9704      	str	r7, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005f12:	9605      	str	r6, [sp, #20]
  HAL_GPIO_Init(SPI_CLK_PORT(port_num), &GPIO_InitStruct);
 8005f14:	f001 fd40 	bl	8007998 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = SPI_NSS_PIN(port_num);
 8005f18:	4916      	ldr	r1, [pc, #88]	; (8005f74 <HAL_SPI_MspInit+0xe4>)
 8005f1a:	4b1a      	ldr	r3, [pc, #104]	; (8005f84 <HAL_SPI_MspInit+0xf4>)
 8005f1c:	1864      	adds	r4, r4, r1
 8005f1e:	4260      	negs	r0, r4
 8005f20:	4160      	adcs	r0, r4
 8005f22:	2180      	movs	r1, #128	; 0x80
 8005f24:	4240      	negs	r0, r0
 8005f26:	4003      	ands	r3, r0
 8005f28:	0209      	lsls	r1, r1, #8
 8005f2a:	185b      	adds	r3, r3, r1
 8005f2c:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005f2e:	2303      	movs	r3, #3
  GPIO_InitStruct.Alternate = SPI_NSS_ALTERNATE(port_num);
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f30:	2480      	movs	r4, #128	; 0x80
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005f32:	9306      	str	r3, [sp, #24]
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f34:	2390      	movs	r3, #144	; 0x90
  GPIO_InitStruct.Alternate = SPI_NSS_ALTERNATE(port_num);
 8005f36:	2200      	movs	r2, #0
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f38:	00e4      	lsls	r4, r4, #3
 8005f3a:	05db      	lsls	r3, r3, #23
 8005f3c:	4020      	ands	r0, r4
 8005f3e:	18c0      	adds	r0, r0, r3
 8005f40:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Alternate = SPI_NSS_ALTERNATE(port_num);
 8005f42:	9207      	str	r2, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005f44:	9704      	str	r7, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005f46:	9605      	str	r6, [sp, #20]
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f48:	f001 fd26 	bl	8007998 <HAL_GPIO_Init>

  /* TX DMA Initialization */
  STUSB16xx_HW_IF_TX_DMA_Init(port_num);
 8005f4c:	0028      	movs	r0, r5
 8005f4e:	f005 f8b3 	bl	800b0b8 <STUSB16xx_HW_IF_TX_DMA_Init>

  /* RX DMA Initialization */
  STUSB16xx_HW_IF_RX_DMA_Init(port_num);  
 8005f52:	0028      	movs	r0, r5
 8005f54:	f005 f8ec 	bl	800b130 <STUSB16xx_HW_IF_RX_DMA_Init>
}
 8005f58:	b009      	add	sp, #36	; 0x24
 8005f5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  SPI_CLK_ENABLE(port_num);
 8005f5c:	2080      	movs	r0, #128	; 0x80
 8005f5e:	6991      	ldr	r1, [r2, #24]
 8005f60:	0140      	lsls	r0, r0, #5
 8005f62:	4301      	orrs	r1, r0
 8005f64:	6191      	str	r1, [r2, #24]
 8005f66:	6993      	ldr	r3, [r2, #24]
 8005f68:	4003      	ands	r3, r0
 8005f6a:	9302      	str	r3, [sp, #8]
 8005f6c:	9b02      	ldr	r3, [sp, #8]
  GPIO_InitStruct.Pin = SPI_MISO_PIN(port_num);
 8005f6e:	2310      	movs	r3, #16
 8005f70:	e7a3      	b.n	8005eba <HAL_SPI_MspInit+0x2a>
 8005f72:	46c0      	nop			; (mov r8, r8)
 8005f74:	bfffc800 	.word	0xbfffc800
 8005f78:	40003800 	.word	0x40003800
 8005f7c:	40021000 	.word	0x40021000
 8005f80:	48000400 	.word	0x48000400
 8005f84:	ffff9000 	.word	0xffff9000

08005f88 <HAL_I2C_MspInit>:
{
  GPIO_InitTypeDef GPIO_InitStruct;

  uint8_t port_num = GET_PORT_FROM_I2C(hi2c);

  GPIO_InitStruct.Pin       = I2C_SCL_PIN(port_num)|I2C_SDA_PIN(port_num);
 8005f88:	23c0      	movs	r3, #192	; 0xc0
{
 8005f8a:	b510      	push	{r4, lr}
  GPIO_InitStruct.Pin       = I2C_SCL_PIN(port_num)|I2C_SDA_PIN(port_num);
 8005f8c:	011b      	lsls	r3, r3, #4
{
 8005f8e:	b088      	sub	sp, #32
  GPIO_InitStruct.Pin       = I2C_SCL_PIN(port_num)|I2C_SDA_PIN(port_num);
 8005f90:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode      = I2C_MODE(port_num);
 8005f92:	2312      	movs	r3, #18
 8005f94:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pull      = I2C_PULL(port_num);
 8005f96:	2300      	movs	r3, #0
 8005f98:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Speed     = I2C_SPEED(port_num);
 8005f9a:	3303      	adds	r3, #3
  uint8_t port_num = GET_PORT_FROM_I2C(hi2c);
 8005f9c:	6804      	ldr	r4, [r0, #0]
  GPIO_InitStruct.Speed     = I2C_SPEED(port_num);
 8005f9e:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Alternate = I2C_ALTERNATE(port_num);
  HAL_GPIO_Init(I2C_PORT(port_num), &GPIO_InitStruct);
 8005fa0:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Alternate = I2C_ALTERNATE(port_num);
 8005fa2:	3b02      	subs	r3, #2
  HAL_GPIO_Init(I2C_PORT(port_num), &GPIO_InitStruct);
 8005fa4:	480e      	ldr	r0, [pc, #56]	; (8005fe0 <HAL_I2C_MspInit+0x58>)
  GPIO_InitStruct.Alternate = I2C_ALTERNATE(port_num);
 8005fa6:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(I2C_PORT(port_num), &GPIO_InitStruct);
 8005fa8:	f001 fcf6 	bl	8007998 <HAL_GPIO_Init>

  /* Peripheral clock enable */
  I2C_CLK_ENABLE(port_num);
 8005fac:	4a0d      	ldr	r2, [pc, #52]	; (8005fe4 <HAL_I2C_MspInit+0x5c>)
 8005fae:	4b0e      	ldr	r3, [pc, #56]	; (8005fe8 <HAL_I2C_MspInit+0x60>)
 8005fb0:	4294      	cmp	r4, r2
 8005fb2:	d10a      	bne.n	8005fca <HAL_I2C_MspInit+0x42>
 8005fb4:	2180      	movs	r1, #128	; 0x80
 8005fb6:	69da      	ldr	r2, [r3, #28]
 8005fb8:	03c9      	lsls	r1, r1, #15
 8005fba:	430a      	orrs	r2, r1
 8005fbc:	61da      	str	r2, [r3, #28]
 8005fbe:	69db      	ldr	r3, [r3, #28]
 8005fc0:	400b      	ands	r3, r1
 8005fc2:	9301      	str	r3, [sp, #4]
 8005fc4:	9b01      	ldr	r3, [sp, #4]
  UNUSED(port_num);
}
 8005fc6:	b008      	add	sp, #32
 8005fc8:	bd10      	pop	{r4, pc}
  I2C_CLK_ENABLE(port_num);
 8005fca:	2180      	movs	r1, #128	; 0x80
 8005fcc:	69da      	ldr	r2, [r3, #28]
 8005fce:	0389      	lsls	r1, r1, #14
 8005fd0:	430a      	orrs	r2, r1
 8005fd2:	61da      	str	r2, [r3, #28]
 8005fd4:	69db      	ldr	r3, [r3, #28]
 8005fd6:	400b      	ands	r3, r1
 8005fd8:	9302      	str	r3, [sp, #8]
 8005fda:	9b02      	ldr	r3, [sp, #8]
}
 8005fdc:	e7f3      	b.n	8005fc6 <HAL_I2C_MspInit+0x3e>
 8005fde:	46c0      	nop			; (mov r8, r8)
 8005fe0:	48000400 	.word	0x48000400
 8005fe4:	40005800 	.word	0x40005800
 8005fe8:	40021000 	.word	0x40021000

08005fec <HAL_CRC_MspInit>:
  * @retval None
  */
void HAL_CRC_MspInit(CRC_HandleTypeDef *hcrc)
{
  /* CRC Peripheral clock enable */
  __HAL_RCC_CRC_CLK_ENABLE();
 8005fec:	2040      	movs	r0, #64	; 0x40
 8005fee:	4a05      	ldr	r2, [pc, #20]	; (8006004 <HAL_CRC_MspInit+0x18>)
{
 8005ff0:	b082      	sub	sp, #8
  __HAL_RCC_CRC_CLK_ENABLE();
 8005ff2:	6951      	ldr	r1, [r2, #20]
 8005ff4:	4301      	orrs	r1, r0
 8005ff6:	6151      	str	r1, [r2, #20]
 8005ff8:	6953      	ldr	r3, [r2, #20]
 8005ffa:	4003      	ands	r3, r0
 8005ffc:	9301      	str	r3, [sp, #4]
 8005ffe:	9b01      	ldr	r3, [sp, #4]
}
 8006000:	b002      	add	sp, #8
 8006002:	4770      	bx	lr
 8006004:	40021000 	.word	0x40021000

08006008 <HAL_TIM_Base_MspInit>:
  * @param htim_base: TIM handle pointer
  * @retval None
  */
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
  uint8_t port_num = GET_PORT_FROM_TIM(htim_base);
 8006008:	6803      	ldr	r3, [r0, #0]
  if(IS_RX_COUNTTIM(htim_base))  /* RX COUNT TIMER IDENTIFIED */
 800600a:	4a13      	ldr	r2, [pc, #76]	; (8006058 <HAL_TIM_Base_MspInit+0x50>)
{
 800600c:	b513      	push	{r0, r1, r4, lr}
  if(IS_RX_COUNTTIM(htim_base))  /* RX COUNT TIMER IDENTIFIED */
 800600e:	4293      	cmp	r3, r2
 8006010:	d113      	bne.n	800603a <HAL_TIM_Base_MspInit+0x32>
  {
    /* Peripheral clock enable */
    RX_COUNTTIM_CLK_ENABLE(port_num);
 8006012:	2080      	movs	r0, #128	; 0x80

    /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(RX_COUNTTIM_IRQN(port_num), RX_COUNTTIMIRQ_PRIO(port_num), 0);
 8006014:	2415      	movs	r4, #21
    RX_COUNTTIM_CLK_ENABLE(port_num);
 8006016:	4a11      	ldr	r2, [pc, #68]	; (800605c <HAL_TIM_Base_MspInit+0x54>)
 8006018:	0280      	lsls	r0, r0, #10
 800601a:	6991      	ldr	r1, [r2, #24]
 800601c:	4301      	orrs	r1, r0
 800601e:	6191      	str	r1, [r2, #24]
 8006020:	6993      	ldr	r3, [r2, #24]
 8006022:	4003      	ands	r3, r0
 8006024:	9300      	str	r3, [sp, #0]
 8006026:	9b00      	ldr	r3, [sp, #0]
    HAL_NVIC_SetPriority(RX_COUNTTIM_IRQN(port_num), RX_COUNTTIMIRQ_PRIO(port_num), 0);
 8006028:	0020      	movs	r0, r4
 800602a:	2200      	movs	r2, #0
 800602c:	2101      	movs	r1, #1
 800602e:	f001 fad9 	bl	80075e4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RX_COUNTTIM_IRQN(port_num));
 8006032:	0020      	movs	r0, r4
 8006034:	f001 fb00 	bl	8007638 <HAL_NVIC_EnableIRQ>
  }
  UNUSED(port_num);
}
 8006038:	bd13      	pop	{r0, r1, r4, pc}
  if(IS_RX_COUNTTIM(htim_base))  /* RX COUNT TIMER IDENTIFIED */
 800603a:	4a09      	ldr	r2, [pc, #36]	; (8006060 <HAL_TIM_Base_MspInit+0x58>)
 800603c:	4293      	cmp	r3, r2
 800603e:	d1fb      	bne.n	8006038 <HAL_TIM_Base_MspInit+0x30>
    RX_COUNTTIM_CLK_ENABLE(port_num);
 8006040:	2080      	movs	r0, #128	; 0x80
 8006042:	4a06      	ldr	r2, [pc, #24]	; (800605c <HAL_TIM_Base_MspInit+0x54>)
 8006044:	02c0      	lsls	r0, r0, #11
 8006046:	6991      	ldr	r1, [r2, #24]
    HAL_NVIC_SetPriority(RX_COUNTTIM_IRQN(port_num), RX_COUNTTIMIRQ_PRIO(port_num), 0);
 8006048:	2416      	movs	r4, #22
    RX_COUNTTIM_CLK_ENABLE(port_num);
 800604a:	4301      	orrs	r1, r0
 800604c:	6191      	str	r1, [r2, #24]
 800604e:	6993      	ldr	r3, [r2, #24]
 8006050:	4003      	ands	r3, r0
 8006052:	9301      	str	r3, [sp, #4]
 8006054:	9b01      	ldr	r3, [sp, #4]
 8006056:	e7e7      	b.n	8006028 <HAL_TIM_Base_MspInit+0x20>
 8006058:	40014400 	.word	0x40014400
 800605c:	40021000 	.word	0x40021000
 8006060:	40014800 	.word	0x40014800

08006064 <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
 8006064:	4770      	bx	lr

08006066 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8006066:	e7fe      	b.n	8006066 <HardFault_Handler>

08006068 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 8006068:	b510      	push	{r4, lr}
  HAL_IncTick();
 800606a:	f001 f841 	bl	80070f0 <HAL_IncTick>
  USBPD_DPM_TimerCounter();
 800606e:	f003 fb9f 	bl	80097b0 <USBPD_DPM_TimerCounter>
}
 8006072:	bd10      	pop	{r4, pc}

08006074 <EXTI0_1_IRQHandler>:
  * @brief  This function handles EXTI line 4_15 interrupts.
  * @param  None
  * @retval None
  */
void EXTI0_1_IRQHandler(void)
{
 8006074:	b510      	push	{r4, lr}
  HAL_GPIO_EXTI_IRQHandler(ALERT_GPIO_PIN(0));
 8006076:	2002      	movs	r0, #2
 8006078:	f001 fd5a 	bl	8007b30 <HAL_GPIO_EXTI_IRQHandler>
}
 800607c:	bd10      	pop	{r4, pc}

0800607e <EXTI2_3_IRQHandler>:
  * @brief  This function handles EXTI line 2 to 3 interrupts.
  * @param  None
  * @retval None
  */
void EXTI2_3_IRQHandler(void)
{  
 800607e:	b510      	push	{r4, lr}
  HAL_GPIO_EXTI_IRQHandler(ALERT_GPIO_PIN(1));
 8006080:	2004      	movs	r0, #4
 8006082:	f001 fd55 	bl	8007b30 <HAL_GPIO_EXTI_IRQHandler>
  
}
 8006086:	bd10      	pop	{r4, pc}

08006088 <EXTI4_15_IRQHandler>:
  * @param  None
  * @retval None
  */
void EXTI4_15_IRQHandler(void)
{
  HAL_GPIO_EXTI_IRQHandler(USER_BUTTON_PIN);
 8006088:	2080      	movs	r0, #128	; 0x80
{
 800608a:	b510      	push	{r4, lr}
  HAL_GPIO_EXTI_IRQHandler(USER_BUTTON_PIN);
 800608c:	0180      	lsls	r0, r0, #6
 800608e:	f001 fd4f 	bl	8007b30 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(SPI_NSS_PIN(0));
 8006092:	2080      	movs	r0, #128	; 0x80
 8006094:	0140      	lsls	r0, r0, #5
 8006096:	f001 fd4b 	bl	8007b30 <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(SPI_NSS_PIN(1));
 800609a:	2080      	movs	r0, #128	; 0x80
 800609c:	0200      	lsls	r0, r0, #8
 800609e:	f001 fd47 	bl	8007b30 <HAL_GPIO_EXTI_IRQHandler>
}
 80060a2:	bd10      	pop	{r4, pc}

080060a4 <DMA1_Channel4_5_6_7_IRQHandler>:
  * @brief  This function handles DMA Channel 4 to 7 interrupts.
  * @param  None
  * @retval None
  */
void DMA1_Channel4_5_6_7_IRQHandler(void)
{
 80060a4:	b510      	push	{r4, lr}
  USBPD_DMA_PORT0_IRQHandler();
 80060a6:	f003 fbe9 	bl	800987c <USBPD_DMA_PORT0_IRQHandler>
}
 80060aa:	bd10      	pop	{r4, pc}

080060ac <TIM16_IRQHandler>:
  * @brief  This function handles TIM6 interrupt.
  * @param  None
  * @retval None
  */
void TIM16_IRQHandler(void)
{
 80060ac:	b510      	push	{r4, lr}
  USBPD_RX_PORT0_COUNTTIM_IRQHandler();
 80060ae:	f003 fc6d 	bl	800998c <USBPD_RX_PORT0_COUNTTIM_IRQHandler>
}
 80060b2:	bd10      	pop	{r4, pc}

080060b4 <DPM_TurnOffPower.isra.0>:
/**
  * @brief  Turn Off power supply.
  * @param  PortNum The current port number
  * @retval USBPD_OK, USBPD_ERROR
  */
static USBPD_StatusTypeDef DPM_TurnOffPower(uint8_t PortNum, USBPD_PortPowerRole_TypeDef Role)
 80060b4:	b510      	push	{r4, lr}
{
  USBPD_StatusTypeDef status = USBPD_OK;

  status = USBPD_PWR_IF_VBUSDisable(PortNum);
 80060b6:	f000 fbd9 	bl	800686c <USBPD_PWR_IF_VBUSDisable>
  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_OFF, 0);
 80060ba:	2200      	movs	r2, #0
  status = USBPD_PWR_IF_VBUSDisable(PortNum);
 80060bc:	0004      	movs	r4, r0
  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_OFF, 0);
 80060be:	0011      	movs	r1, r2
 80060c0:	2002      	movs	r0, #2
 80060c2:	f006 fc05 	bl	800c8d0 <Led_Set>
  return status;
}
 80060c6:	0020      	movs	r0, r4
 80060c8:	bd10      	pop	{r4, pc}
	...

080060cc <USBPD_DPM_UserInit>:
{
 80060cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80060ce:	b089      	sub	sp, #36	; 0x24
  Led_Init();
 80060d0:	f006 fbe8 	bl	800c8a4 <Led_Init>
          ((DPM_Settings[USBPD_PORT_0].PE_DefaultRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC),
 80060d4:	4b17      	ldr	r3, [pc, #92]	; (8006134 <USBPD_DPM_UserInit+0x68>)
  Led_Set(LED_PORT0_ROLE,
 80060d6:	2200      	movs	r2, #0
 80060d8:	7919      	ldrb	r1, [r3, #4]
 80060da:	2304      	movs	r3, #4
 80060dc:	4019      	ands	r1, r3
 80060de:	424b      	negs	r3, r1
 80060e0:	4159      	adcs	r1, r3
 80060e2:	2001      	movs	r0, #1
 80060e4:	3104      	adds	r1, #4
 80060e6:	f006 fbf3 	bl	800c8d0 <Led_Set>
  Led_Set(LED_PORT0_ROLE, LED_MODE_OFF, 0);
 80060ea:	2200      	movs	r2, #0
 80060ec:	2001      	movs	r0, #1
 80060ee:	0011      	movs	r1, r2
 80060f0:	f006 fbee 	bl	800c8d0 <Led_Set>
  USBPD_PWR_IF_Init();
 80060f4:	f000 fab6 	bl	8006664 <USBPD_PWR_IF_Init>
  if(USBPD_OK != USBPD_PWR_IF_PowerResetGlobal()) return USBPD_ERROR;
 80060f8:	f000 fb8a 	bl	8006810 <USBPD_PWR_IF_PowerResetGlobal>
 80060fc:	1e05      	subs	r5, r0, #0
 80060fe:	d003      	beq.n	8006108 <USBPD_DPM_UserInit+0x3c>
 8006100:	2502      	movs	r5, #2
}
 8006102:	0028      	movs	r0, r5
 8006104:	b009      	add	sp, #36	; 0x24
 8006106:	bdf0      	pop	{r4, r5, r6, r7, pc}
  osMessageQDef(MsgBox, DPM_BOX_MESSAGES_MAX, uint32_t);
 8006108:	a801      	add	r0, sp, #4
 800610a:	0003      	movs	r3, r0
 800610c:	4c0a      	ldr	r4, [pc, #40]	; (8006138 <USBPD_DPM_UserInit+0x6c>)
 800610e:	cc06      	ldmia	r4!, {r1, r2}
 8006110:	c306      	stmia	r3!, {r1, r2}
  DPMMsgBox = osMessageCreate(osMessageQ(MsgBox), NULL);
 8006112:	0029      	movs	r1, r5
 8006114:	f005 fc0f 	bl	800b936 <osMessageCreate>
 8006118:	4908      	ldr	r1, [pc, #32]	; (800613c <USBPD_DPM_UserInit+0x70>)
 800611a:	6008      	str	r0, [r1, #0]
  osThreadDef(DPM, USBPD_DPM_UserExecute, osPriorityLow, 0, 120);
 800611c:	a803      	add	r0, sp, #12
 800611e:	0003      	movs	r3, r0
 8006120:	ccc4      	ldmia	r4!, {r2, r6, r7}
 8006122:	c3c4      	stmia	r3!, {r2, r6, r7}
 8006124:	cc44      	ldmia	r4!, {r2, r6}
 8006126:	c344      	stmia	r3!, {r2, r6}
  if(NULL == osThreadCreate(osThread(DPM), &DPMMsgBox))
 8006128:	f005 fbdf 	bl	800b8ea <osThreadCreate>
 800612c:	2800      	cmp	r0, #0
 800612e:	d1e8      	bne.n	8006102 <USBPD_DPM_UserInit+0x36>
 8006130:	e7e6      	b.n	8006100 <USBPD_DPM_UserInit+0x34>
 8006132:	46c0      	nop			; (mov r8, r8)
 8006134:	0800cc80 	.word	0x0800cc80
 8006138:	0800cbec 	.word	0x0800cbec
 800613c:	20001a44 	.word	0x20001a44

08006140 <USBPD_DPM_UserTimerCounter>:
  if((DPM_Ports[PortNum].DPM_TimerSRCExtendedCapa & DPM_TIMER_READ_MSK) > 0)
 8006140:	2378      	movs	r3, #120	; 0x78
 8006142:	4343      	muls	r3, r0
 8006144:	4805      	ldr	r0, [pc, #20]	; (800615c <USBPD_DPM_UserTimerCounter+0x1c>)
 8006146:	18c0      	adds	r0, r0, r3
 8006148:	305a      	adds	r0, #90	; 0x5a
 800614a:	8803      	ldrh	r3, [r0, #0]
 800614c:	045b      	lsls	r3, r3, #17
 800614e:	d003      	beq.n	8006158 <USBPD_DPM_UserTimerCounter+0x18>
    DPM_Ports[PortNum].DPM_TimerSRCExtendedCapa--;
 8006150:	8803      	ldrh	r3, [r0, #0]
 8006152:	3b01      	subs	r3, #1
 8006154:	b29b      	uxth	r3, r3
 8006156:	8003      	strh	r3, [r0, #0]
}
 8006158:	4770      	bx	lr
 800615a:	46c0      	nop			; (mov r8, r8)
 800615c:	200002c4 	.word	0x200002c4

08006160 <USBPD_DPM_UserCableDetection>:
{
 8006160:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006162:	0007      	movs	r7, r0
 8006164:	000e      	movs	r6, r1
 8006166:	4d47      	ldr	r5, [pc, #284]	; (8006284 <USBPD_DPM_UserCableDetection+0x124>)
 8006168:	00c4      	lsls	r4, r0, #3
  switch(State)
 800616a:	2904      	cmp	r1, #4
 800616c:	d015      	beq.n	800619a <USBPD_DPM_UserCableDetection+0x3a>
 800616e:	2907      	cmp	r1, #7
 8006170:	d04a      	beq.n	8006208 <USBPD_DPM_UserCableDetection+0xa8>
 8006172:	2902      	cmp	r1, #2
 8006174:	d164      	bne.n	8006240 <USBPD_DPM_UserCableDetection+0xe0>
    if(USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 8006176:	5d2b      	ldrb	r3, [r5, r4]
 8006178:	075b      	lsls	r3, r3, #29
 800617a:	d511      	bpl.n	80061a0 <USBPD_DPM_UserCableDetection+0x40>
      if (USBPD_OK != USBPD_PWR_IF_VBUSEnable(PortNum))
 800617c:	f000 fb62 	bl	8006844 <USBPD_PWR_IF_VBUSEnable>
 8006180:	2800      	cmp	r0, #0
 8006182:	d140      	bne.n	8006206 <USBPD_DPM_UserCableDetection+0xa6>
 8006184:	003e      	movs	r6, r7
 8006186:	1e73      	subs	r3, r6, #1
 8006188:	419e      	sbcs	r6, r3
 800618a:	3628      	adds	r6, #40	; 0x28
      while (STUSB1602_VBUS_Valid_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_within_VALID_vrange)
 800618c:	0030      	movs	r0, r6
 800618e:	f000 fc31 	bl	80069f4 <STUSB1602_VBUS_Valid_Get>
 8006192:	2801      	cmp	r0, #1
 8006194:	d004      	beq.n	80061a0 <USBPD_DPM_UserCableDetection+0x40>
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 8006196:	46c0      	nop			; (mov r8, r8)
 8006198:	e7f8      	b.n	800618c <USBPD_DPM_UserCableDetection+0x2c>
    if(USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 800619a:	5d2b      	ldrb	r3, [r5, r4]
 800619c:	075b      	lsls	r3, r3, #29
 800619e:	d422      	bmi.n	80061e6 <USBPD_DPM_UserCableDetection+0x86>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_CC : LED_PORT0_CC) , (DPM_Params[PortNum].ActiveCCIs == CC1 ? LED_MODE_BLINK_CC1 : LED_MODE_BLINK_CC2), 0);
 80061a0:	192b      	adds	r3, r5, r4
 80061a2:	7859      	ldrb	r1, [r3, #1]
 80061a4:	2200      	movs	r2, #0
 80061a6:	0789      	lsls	r1, r1, #30
 80061a8:	0f89      	lsrs	r1, r1, #30
 80061aa:	3901      	subs	r1, #1
 80061ac:	1e4b      	subs	r3, r1, #1
 80061ae:	4199      	sbcs	r1, r3
 80061b0:	2003      	movs	r0, #3
 80061b2:	3108      	adds	r1, #8
 80061b4:	f006 fb8c 	bl	800c8d0 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_BLINK_VBUS, 0);
 80061b8:	2200      	movs	r2, #0
 80061ba:	2107      	movs	r1, #7
 80061bc:	2002      	movs	r0, #2
 80061be:	f006 fb87 	bl	800c8d0 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT0_ROLE) , ((DPM_Params[PortNum].PE_PowerRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC), 0);
 80061c2:	5d29      	ldrb	r1, [r5, r4]
 80061c4:	2200      	movs	r2, #0
 80061c6:	0749      	lsls	r1, r1, #29
 80061c8:	0fc9      	lsrs	r1, r1, #31
 80061ca:	424b      	negs	r3, r1
 80061cc:	4159      	adcs	r1, r3
 80061ce:	2001      	movs	r0, #1
 80061d0:	3104      	adds	r1, #4
 80061d2:	f006 fb7d 	bl	800c8d0 <Led_Set>
    DPM_Ports[PortNum].DPM_IsConnected = 1;
 80061d6:	2378      	movs	r3, #120	; 0x78
 80061d8:	437b      	muls	r3, r7
 80061da:	4f2b      	ldr	r7, [pc, #172]	; (8006288 <USBPD_DPM_UserCableDetection+0x128>)
 80061dc:	18ff      	adds	r7, r7, r3
 80061de:	2301      	movs	r3, #1
 80061e0:	3754      	adds	r7, #84	; 0x54
 80061e2:	703b      	strb	r3, [r7, #0]
}
 80061e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (USBPD_OK != USBPD_PWR_IF_VBUSEnable(PortNum))
 80061e6:	f000 fb2d 	bl	8006844 <USBPD_PWR_IF_VBUSEnable>
 80061ea:	2800      	cmp	r0, #0
 80061ec:	d10a      	bne.n	8006204 <USBPD_DPM_UserCableDetection+0xa4>
 80061ee:	003e      	movs	r6, r7
 80061f0:	1e73      	subs	r3, r6, #1
 80061f2:	419e      	sbcs	r6, r3
 80061f4:	3628      	adds	r6, #40	; 0x28
      while (STUSB1602_VBUS_Valid_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_within_VALID_vrange)
 80061f6:	0030      	movs	r0, r6
 80061f8:	f000 fbfc 	bl	80069f4 <STUSB1602_VBUS_Valid_Get>
 80061fc:	2801      	cmp	r0, #1
 80061fe:	d0cf      	beq.n	80061a0 <USBPD_DPM_UserCableDetection+0x40>
 8006200:	46c0      	nop			; (mov r8, r8)
 8006202:	e7f8      	b.n	80061f6 <USBPD_DPM_UserCableDetection+0x96>
 8006204:	e7fe      	b.n	8006204 <USBPD_DPM_UserCableDetection+0xa4>
 8006206:	e7fe      	b.n	8006206 <USBPD_DPM_UserCableDetection+0xa6>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_CC : LED_PORT0_CC) , (DPM_Params[PortNum].ActiveCCIs == CC1 ? LED_MODE_BLINK_CC1 : LED_MODE_BLINK_CC2), 0);
 8006208:	192b      	adds	r3, r5, r4
 800620a:	7859      	ldrb	r1, [r3, #1]
 800620c:	2200      	movs	r2, #0
 800620e:	0789      	lsls	r1, r1, #30
 8006210:	0f89      	lsrs	r1, r1, #30
 8006212:	3901      	subs	r1, #1
 8006214:	1e4b      	subs	r3, r1, #1
 8006216:	4199      	sbcs	r1, r3
 8006218:	2003      	movs	r0, #3
 800621a:	3108      	adds	r1, #8
 800621c:	f006 fb58 	bl	800c8d0 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_BLINK_VBUS, 0);
 8006220:	0031      	movs	r1, r6
 8006222:	2200      	movs	r2, #0
 8006224:	2002      	movs	r0, #2
 8006226:	f006 fb53 	bl	800c8d0 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT0_ROLE) , ((DPM_Params[PortNum].PE_PowerRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC), 0);
 800622a:	5d29      	ldrb	r1, [r5, r4]
            ((DPM_Settings[PortNum].PE_DefaultRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC),
 800622c:	0749      	lsls	r1, r1, #29
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT0_ROLE),
 800622e:	0fc9      	lsrs	r1, r1, #31
 8006230:	424b      	negs	r3, r1
 8006232:	4159      	adcs	r1, r3
 8006234:	2200      	movs	r2, #0
 8006236:	3104      	adds	r1, #4
 8006238:	2001      	movs	r0, #1
 800623a:	f006 fb49 	bl	800c8d0 <Led_Set>
}
 800623e:	e7d1      	b.n	80061e4 <USBPD_DPM_UserCableDetection+0x84>
    memset(&DPM_Ports[PortNum], 0, sizeof(DPM_Ports[PortNum]));
 8006240:	2278      	movs	r2, #120	; 0x78
 8006242:	0013      	movs	r3, r2
 8006244:	4343      	muls	r3, r0
 8006246:	4810      	ldr	r0, [pc, #64]	; (8006288 <USBPD_DPM_UserCableDetection+0x128>)
 8006248:	2100      	movs	r1, #0
 800624a:	18c0      	adds	r0, r0, r3
 800624c:	f006 fc37 	bl	800cabe <memset>
    if(USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 8006250:	5d2b      	ldrb	r3, [r5, r4]
 8006252:	075b      	lsls	r3, r3, #29
 8006254:	d505      	bpl.n	8006262 <USBPD_DPM_UserCableDetection+0x102>
      if (USBPD_OK != USBPD_PWR_IF_VBUSDisable(PortNum))
 8006256:	0038      	movs	r0, r7
 8006258:	f000 fb08 	bl	800686c <USBPD_PWR_IF_VBUSDisable>
 800625c:	2800      	cmp	r0, #0
 800625e:	d000      	beq.n	8006262 <USBPD_DPM_UserCableDetection+0x102>
 8006260:	e7fe      	b.n	8006260 <USBPD_DPM_UserCableDetection+0x100>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_CC : LED_PORT0_CC) , LED_MODE_OFF, 0);
 8006262:	2200      	movs	r2, #0
 8006264:	2003      	movs	r0, #3
 8006266:	0011      	movs	r1, r2
 8006268:	f006 fb32 	bl	800c8d0 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_OFF, 0);
 800626c:	2200      	movs	r2, #0
 800626e:	2002      	movs	r0, #2
 8006270:	0011      	movs	r1, r2
 8006272:	f006 fb2d 	bl	800c8d0 <Led_Set>
            ((DPM_Settings[PortNum].PE_DefaultRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC),
 8006276:	230c      	movs	r3, #12
 8006278:	437b      	muls	r3, r7
 800627a:	4f04      	ldr	r7, [pc, #16]	; (800628c <USBPD_DPM_UserCableDetection+0x12c>)
 800627c:	18ff      	adds	r7, r7, r3
 800627e:	7939      	ldrb	r1, [r7, #4]
 8006280:	e7d4      	b.n	800622c <USBPD_DPM_UserCableDetection+0xcc>
 8006282:	46c0      	nop			; (mov r8, r8)
 8006284:	20001c60 	.word	0x20001c60
 8006288:	200002c4 	.word	0x200002c4
 800628c:	0800cc80 	.word	0x0800cc80

08006290 <USBPD_DPM_HardReset>:
{
 8006290:	b570      	push	{r4, r5, r6, lr}
 8006292:	0004      	movs	r4, r0
 8006294:	000d      	movs	r5, r1
  switch(Status)
 8006296:	2a06      	cmp	r2, #6
 8006298:	d818      	bhi.n	80062cc <USBPD_DPM_HardReset+0x3c>
 800629a:	0010      	movs	r0, r2
 800629c:	f7ff fb8a 	bl	80059b4 <__gnu_thumb1_case_uqi>
 80062a0:	16161704 	.word	0x16161704
 80062a4:	3223      	.short	0x3223
 80062a6:	4a          	.byte	0x4a
 80062a7:	00          	.byte	0x00
    if (USBPD_PORTPOWERROLE_SRC == CurrentRole)
 80062a8:	2901      	cmp	r1, #1
 80062aa:	d107      	bne.n	80062bc <USBPD_DPM_HardReset+0x2c>
  * @param  PortNum The current port number
  * @retval None
  */
static void DPM_AssertRp(uint8_t PortNum)
{
  USBPD_CAD_AssertRp(PortNum);
 80062ac:	0020      	movs	r0, r4
 80062ae:	f7f9 ffc9 	bl	8000244 <USBPD_CAD_AssertRp>

  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT0_ROLE) , LED_MODE_BLINK_ROLE_SRC, 0);
 80062b2:	2200      	movs	r2, #0
 80062b4:	2104      	movs	r1, #4
 80062b6:	0028      	movs	r0, r5
 80062b8:	f006 fb0a 	bl	800c8d0 <Led_Set>
    USBPD_HW_IF_HR_Start(PortNum, CurrentRole, ACKNOWLEDGE);
 80062bc:	2200      	movs	r2, #0
    USBPD_HW_IF_HR_Start(PortNum, CurrentRole, REQUEST);
 80062be:	0029      	movs	r1, r5
 80062c0:	0020      	movs	r0, r4
 80062c2:	f004 fb01 	bl	800a8c8 <USBPD_HW_IF_HR_Start>
    DPM_TurnOffPower(PortNum, CurrentRole);
 80062c6:	0020      	movs	r0, r4
 80062c8:	f7ff fef4 	bl	80060b4 <DPM_TurnOffPower.isra.0>
}
 80062cc:	bd70      	pop	{r4, r5, r6, pc}
    if (USBPD_PORTPOWERROLE_SRC == CurrentRole)
 80062ce:	2901      	cmp	r1, #1
 80062d0:	d107      	bne.n	80062e2 <USBPD_DPM_HardReset+0x52>
  USBPD_CAD_AssertRp(PortNum);
 80062d2:	0020      	movs	r0, r4
 80062d4:	f7f9 ffb6 	bl	8000244 <USBPD_CAD_AssertRp>
  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT0_ROLE) , LED_MODE_BLINK_ROLE_SRC, 0);
 80062d8:	2200      	movs	r2, #0
 80062da:	2104      	movs	r1, #4
 80062dc:	0028      	movs	r0, r5
 80062de:	f006 faf7 	bl	800c8d0 <Led_Set>
    USBPD_HW_IF_HR_Start(PortNum, CurrentRole, REQUEST);
 80062e2:	2201      	movs	r2, #1
 80062e4:	e7eb      	b.n	80062be <USBPD_DPM_HardReset+0x2e>
    USBPD_HW_IF_HR_CheckVbusVSafe0V(PortNum, CurrentRole);
 80062e6:	0020      	movs	r0, r4
 80062e8:	f004 fb42 	bl	800a970 <USBPD_HW_IF_HR_CheckVbusVSafe0V>
    if (CurrentRole == USBPD_PORTPOWERROLE_SNK)
 80062ec:	2d00      	cmp	r5, #0
 80062ee:	d1ed      	bne.n	80062cc <USBPD_DPM_HardReset+0x3c>
 80062f0:	1e63      	subs	r3, r4, #1
 80062f2:	419c      	sbcs	r4, r3
 80062f4:	3428      	adds	r4, #40	; 0x28
      while (STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_below_VSAFE0V_threshold)
 80062f6:	0020      	movs	r0, r4
 80062f8:	f000 fb88 	bl	8006a0c <STUSB1602_VBUS_VSAFE0V_Get>
 80062fc:	2801      	cmp	r0, #1
 80062fe:	d0e5      	beq.n	80062cc <USBPD_DPM_HardReset+0x3c>
 8006300:	46c0      	nop			; (mov r8, r8)
 8006302:	e7f8      	b.n	80062f6 <USBPD_DPM_HardReset+0x66>
    USBPD_HW_IF_HR_End(PortNum, CurrentRole);
 8006304:	0020      	movs	r0, r4
 8006306:	f004 fb45 	bl	800a994 <USBPD_HW_IF_HR_End>
  status = USBPD_PWR_IF_VBUSEnable(PortNum);
 800630a:	0020      	movs	r0, r4
 800630c:	f000 fa9a 	bl	8006844 <USBPD_PWR_IF_VBUSEnable>
  if(USBPD_PORTPOWERROLE_SRC == Role)
 8006310:	2d01      	cmp	r5, #1
 8006312:	d005      	beq.n	8006320 <USBPD_DPM_HardReset+0x90>
  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_BLINK_VBUS, 0);
 8006314:	2200      	movs	r2, #0
 8006316:	2107      	movs	r1, #7
 8006318:	2002      	movs	r0, #2
 800631a:	f006 fad9 	bl	800c8d0 <Led_Set>
 800631e:	e7d5      	b.n	80062cc <USBPD_DPM_HardReset+0x3c>
 8006320:	1e63      	subs	r3, r4, #1
 8006322:	419c      	sbcs	r4, r3
 8006324:	3428      	adds	r4, #40	; 0x28
    while (STUSB1602_VBUS_Valid_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_within_VALID_vrange)
 8006326:	0020      	movs	r0, r4
 8006328:	f000 fb64 	bl	80069f4 <STUSB1602_VBUS_Valid_Get>
 800632c:	2801      	cmp	r0, #1
 800632e:	d0f1      	beq.n	8006314 <USBPD_DPM_HardReset+0x84>
 8006330:	46c0      	nop			; (mov r8, r8)
 8006332:	e7f8      	b.n	8006326 <USBPD_DPM_HardReset+0x96>
    USBPD_HW_IF_HR_End(PortNum, CurrentRole);
 8006334:	0020      	movs	r0, r4
 8006336:	f004 fb2d 	bl	800a994 <USBPD_HW_IF_HR_End>
}
 800633a:	e7c7      	b.n	80062cc <USBPD_DPM_HardReset+0x3c>

0800633c <USBPD_DPM_SetupNewPower>:
  rdoposition = DPM_Ports[PortNum].DPM_RDOPosition;
 800633c:	2278      	movs	r2, #120	; 0x78
 800633e:	4342      	muls	r2, r0
 8006340:	4b06      	ldr	r3, [pc, #24]	; (800635c <USBPD_DPM_SetupNewPower+0x20>)
{
 8006342:	b510      	push	{r4, lr}
  rdoposition = DPM_Ports[PortNum].DPM_RDOPosition;
 8006344:	189b      	adds	r3, r3, r2
 8006346:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006348:	b2d1      	uxtb	r1, r2
    status = USBPD_PWR_IF_SetProfile(PortNum, 0, 0);
 800634a:	1e0a      	subs	r2, r1, #0
  if (rdoposition > 0)
 800634c:	d003      	beq.n	8006356 <USBPD_DPM_SetupNewPower+0x1a>
  previous_rdoposition = DPM_Ports[PortNum].DPM_RDOPositionPrevious;
 800634e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    status = USBPD_PWR_IF_SetProfile(PortNum, rdoposition-1, previous_rdoposition);
 8006350:	3901      	subs	r1, #1
 8006352:	b2d2      	uxtb	r2, r2
 8006354:	b2c9      	uxtb	r1, r1
    status = USBPD_PWR_IF_SetProfile(PortNum, 0, 0);
 8006356:	f000 f991 	bl	800667c <USBPD_PWR_IF_SetProfile>
}
 800635a:	bd10      	pop	{r4, pc}
 800635c:	200002c4 	.word	0x200002c4

08006360 <USBPD_DPM_EvaluatePowerRoleSwap>:
}
 8006360:	200a      	movs	r0, #10
 8006362:	4770      	bx	lr

08006364 <USBPD_DPM_Notification>:
{
 8006364:	b510      	push	{r4, lr}
  switch(EventVal)
 8006366:	2910      	cmp	r1, #16
 8006368:	d104      	bne.n	8006374 <USBPD_DPM_Notification+0x10>
      Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_ON, 0);
 800636a:	2200      	movs	r2, #0
 800636c:	390f      	subs	r1, #15
 800636e:	2002      	movs	r0, #2
 8006370:	f006 faae 	bl	800c8d0 <Led_Set>
}
 8006374:	bd10      	pop	{r4, pc}

08006376 <USBPD_DPM_IsContractStillValid>:
}
 8006376:	2000      	movs	r0, #0
 8006378:	4770      	bx	lr
	...

0800637c <USBPD_DPM_GetDataInfo>:
{
 800637c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800637e:	0005      	movs	r5, r0
 8006380:	0016      	movs	r6, r2
 8006382:	001c      	movs	r4, r3
  switch (DataId)
 8006384:	290d      	cmp	r1, #13
 8006386:	d866      	bhi.n	8006456 <USBPD_DPM_GetDataInfo+0xda>
 8006388:	0008      	movs	r0, r1
 800638a:	f7ff fb13 	bl	80059b4 <__gnu_thumb1_case_uqi>
 800638e:	2424      	.short	0x2424
 8006390:	07162b64 	.word	0x07162b64
 8006394:	64393364 	.word	0x64393364
 8006398:	43646464 	.word	0x43646464
 800639c:	2178      	movs	r1, #120	; 0x78
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO; index++)
 800639e:	2200      	movs	r2, #0
 80063a0:	434d      	muls	r5, r1
 80063a2:	492e      	ldr	r1, [pc, #184]	; (800645c <USBPD_DPM_GetDataInfo+0xe0>)
 80063a4:	1948      	adds	r0, r1, r5
 80063a6:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80063a8:	4293      	cmp	r3, r2
 80063aa:	d918      	bls.n	80063de <USBPD_DPM_GetDataInfo+0x62>
 80063ac:	0097      	lsls	r7, r2, #2
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSNKPDO[index];
 80063ae:	19eb      	adds	r3, r5, r7
 80063b0:	18cb      	adds	r3, r1, r3
 80063b2:	699b      	ldr	r3, [r3, #24]
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO; index++)
 80063b4:	3201      	adds	r2, #1
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSNKPDO[index];
 80063b6:	51f3      	str	r3, [r6, r7]
 80063b8:	e7f5      	b.n	80063a6 <USBPD_DPM_GetDataInfo+0x2a>
 80063ba:	2178      	movs	r1, #120	; 0x78
 80063bc:	4369      	muls	r1, r5
 80063be:	4d27      	ldr	r5, [pc, #156]	; (800645c <USBPD_DPM_GetDataInfo+0xe0>)
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO; index++)
 80063c0:	2200      	movs	r2, #0
 80063c2:	186d      	adds	r5, r5, r1
 80063c4:	0029      	movs	r1, r5
 80063c6:	694b      	ldr	r3, [r1, #20]
 80063c8:	4293      	cmp	r3, r2
 80063ca:	d908      	bls.n	80063de <USBPD_DPM_GetDataInfo+0x62>
 80063cc:	0093      	lsls	r3, r2, #2
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index];
 80063ce:	58e8      	ldr	r0, [r5, r3]
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO; index++)
 80063d0:	3201      	adds	r2, #1
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index];
 80063d2:	50f0      	str	r0, [r6, r3]
 80063d4:	e7f7      	b.n	80063c6 <USBPD_DPM_GetDataInfo+0x4a>
    USBPD_PWR_IF_GetPortPDOs(PortNum, DataId, Ptr, Size);
 80063d6:	0028      	movs	r0, r5
 80063d8:	f000 fa5c 	bl	8006894 <USBPD_PWR_IF_GetPortPDOs>
    *Size *= 4;
 80063dc:	6823      	ldr	r3, [r4, #0]
    *Size = (DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO * 4);
 80063de:	009b      	lsls	r3, r3, #2
    *Size = 0;
 80063e0:	6023      	str	r3, [r4, #0]
}
 80063e2:	e016      	b.n	8006412 <USBPD_DPM_GetDataInfo+0x96>
    *Ptr = DPM_Ports[PortNum].DPM_RequestedVoltage;
 80063e4:	2178      	movs	r1, #120	; 0x78
 80063e6:	4369      	muls	r1, r5
 80063e8:	4d1c      	ldr	r5, [pc, #112]	; (800645c <USBPD_DPM_GetDataInfo+0xe0>)
 80063ea:	186d      	adds	r5, r5, r1
 80063ec:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    *Ptr = DPM_Ports[PortNum].DPM_RequestDOMsg;
 80063ee:	6033      	str	r3, [r6, #0]
    *Size = 4;
 80063f0:	2304      	movs	r3, #4
 80063f2:	e7f5      	b.n	80063e0 <USBPD_DPM_GetDataInfo+0x64>
    *Ptr = DPM_Ports[PortNum].DPM_RequestDOMsg;
 80063f4:	2178      	movs	r1, #120	; 0x78
 80063f6:	4369      	muls	r1, r5
 80063f8:	4d18      	ldr	r5, [pc, #96]	; (800645c <USBPD_DPM_GetDataInfo+0xe0>)
 80063fa:	186d      	adds	r5, r5, r1
 80063fc:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80063fe:	e7f6      	b.n	80063ee <USBPD_DPM_GetDataInfo+0x72>
      memcpy((uint8_t*)Ptr, (uint8_t *)&DPM_USER_Settings[PortNum].DPM_SRCExtendedCapa, *Size);
 8006400:	2138      	movs	r1, #56	; 0x38
      *Size = sizeof(USBPD_SCEDB_TypeDef);
 8006402:	2218      	movs	r2, #24
      memcpy((uint8_t*)Ptr, (uint8_t *)&DPM_USER_Settings[PortNum].DPM_SRCExtendedCapa, *Size);
 8006404:	434d      	muls	r5, r1
 8006406:	4916      	ldr	r1, [pc, #88]	; (8006460 <USBPD_DPM_GetDataInfo+0xe4>)
      *Size = sizeof(USBPD_SCEDB_TypeDef);
 8006408:	601a      	str	r2, [r3, #0]
      memcpy((uint8_t*)Ptr, (uint8_t *)&DPM_USER_Settings[PortNum].DPM_SRCExtendedCapa, *Size);
 800640a:	1869      	adds	r1, r5, r1
      memcpy((uint8_t*)Ptr, (uint8_t *)manu_info, *Size);
 800640c:	0030      	movs	r0, r6
 800640e:	f006 fb4d 	bl	800caac <memcpy>
}
 8006412:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 8006414:	2178      	movs	r1, #120	; 0x78
 8006416:	2338      	movs	r3, #56	; 0x38
 8006418:	4369      	muls	r1, r5
 800641a:	436b      	muls	r3, r5
 800641c:	4d0f      	ldr	r5, [pc, #60]	; (800645c <USBPD_DPM_GetDataInfo+0xe0>)
      manu_info = (USBPD_MIDB_TypeDef*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort;
 800641e:	001f      	movs	r7, r3
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 8006420:	186d      	adds	r5, r5, r1
 8006422:	0029      	movs	r1, r5
 8006424:	3174      	adds	r1, #116	; 0x74
      manu_info = (USBPD_MIDB_TypeDef*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort;
 8006426:	4a0e      	ldr	r2, [pc, #56]	; (8006460 <USBPD_DPM_GetDataInfo+0xe4>)
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 8006428:	7809      	ldrb	r1, [r1, #0]
      manu_info = (USBPD_MIDB_TypeDef*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort;
 800642a:	3718      	adds	r7, #24
 800642c:	18bf      	adds	r7, r7, r2
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 800642e:	2901      	cmp	r1, #1
 8006430:	d803      	bhi.n	800643a <USBPD_DPM_GetDataInfo+0xbe>
      || (DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoRef > USBPD_MANUFINFO_REF_MAX_VALUES))
 8006432:	3575      	adds	r5, #117	; 0x75
 8006434:	7828      	ldrb	r0, [r5, #0]
 8006436:	2807      	cmp	r0, #7
 8006438:	d904      	bls.n	8006444 <USBPD_DPM_GetDataInfo+0xc8>
        *Size = 4; /* VID (2) + .PID(2) */
 800643a:	2304      	movs	r3, #4
 800643c:	6023      	str	r3, [r4, #0]
      memcpy((uint8_t*)Ptr, (uint8_t *)manu_info, *Size);
 800643e:	6822      	ldr	r2, [r4, #0]
 8006440:	0039      	movs	r1, r7
 8006442:	e7e3      	b.n	800640c <USBPD_DPM_GetDataInfo+0x90>
        if (USBPD_MANUFINFO_TARGET_PORT_CABLE_PLUG == DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget)
 8006444:	2900      	cmp	r1, #0
 8006446:	d1f8      	bne.n	800643a <USBPD_DPM_GetDataInfo+0xbe>
          *Size = 4 + strlen((char*)(DPM_USER_Settings[PortNum].DPM_ManuInfoPort.ManuString));
 8006448:	331c      	adds	r3, #28
 800644a:	1898      	adds	r0, r3, r2
 800644c:	f7ff faa0 	bl	8005990 <strlen>
 8006450:	3004      	adds	r0, #4
 8006452:	6020      	str	r0, [r4, #0]
 8006454:	e7f3      	b.n	800643e <USBPD_DPM_GetDataInfo+0xc2>
    *Size = 0;
 8006456:	2300      	movs	r3, #0
 8006458:	e7c2      	b.n	80063e0 <USBPD_DPM_GetDataInfo+0x64>
 800645a:	46c0      	nop			; (mov r8, r8)
 800645c:	200002c4 	.word	0x200002c4
 8006460:	0800ccfc 	.word	0x0800ccfc

08006464 <USBPD_DPM_SetDataInfo>:
{
 8006464:	b570      	push	{r4, r5, r6, lr}
 8006466:	0005      	movs	r5, r0
  switch (DataId)
 8006468:	1e88      	subs	r0, r1, #2
{
 800646a:	0014      	movs	r4, r2
  switch (DataId)
 800646c:	280a      	cmp	r0, #10
 800646e:	d811      	bhi.n	8006494 <USBPD_DPM_SetDataInfo+0x30>
 8006470:	f7ff faa0 	bl	80059b4 <__gnu_thumb1_case_uqi>
 8006474:	341a1106 	.word	0x341a1106
 8006478:	10584f4f 	.word	0x10584f4f
 800647c:	1010      	.short	0x1010
 800647e:	62          	.byte	0x62
 800647f:	00          	.byte	0x00
    if (Size == 4)
 8006480:	2b04      	cmp	r3, #4
 8006482:	d107      	bne.n	8006494 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_RDOPosition = *Ptr;
 8006484:	2078      	movs	r0, #120	; 0x78
 8006486:	4368      	muls	r0, r5
 8006488:	4d31      	ldr	r5, [pc, #196]	; (8006550 <USBPD_DPM_SetDataInfo+0xec>)
 800648a:	6813      	ldr	r3, [r2, #0]
 800648c:	182d      	adds	r5, r5, r0
 800648e:	632b      	str	r3, [r5, #48]	; 0x30
      DPM_Ports[PortNum].DPM_RDOPositionPrevious = *Ptr;
 8006490:	6813      	ldr	r3, [r2, #0]
 8006492:	642b      	str	r3, [r5, #64]	; 0x40
}
 8006494:	bd70      	pop	{r4, r5, r6, pc}
    if (Size == 4)
 8006496:	2b04      	cmp	r3, #4
 8006498:	d1fc      	bne.n	8006494 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_RequestedVoltage = *Ptr;
 800649a:	2078      	movs	r0, #120	; 0x78
 800649c:	4368      	muls	r0, r5
 800649e:	4d2c      	ldr	r5, [pc, #176]	; (8006550 <USBPD_DPM_SetDataInfo+0xec>)
 80064a0:	6813      	ldr	r3, [r2, #0]
 80064a2:	182d      	adds	r5, r5, r0
 80064a4:	636b      	str	r3, [r5, #52]	; 0x34
 80064a6:	e7f5      	b.n	8006494 <USBPD_DPM_SetDataInfo+0x30>
    if (Size <= (USBPD_MAX_NB_PDO * 4))
 80064a8:	2b14      	cmp	r3, #20
 80064aa:	d8f3      	bhi.n	8006494 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO = (Size / 4);
 80064ac:	2078      	movs	r0, #120	; 0x78
      for (index = 0; index < (Size / 4); index++)
 80064ae:	2100      	movs	r1, #0
      DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO = (Size / 4);
 80064b0:	4345      	muls	r5, r0
 80064b2:	4827      	ldr	r0, [pc, #156]	; (8006550 <USBPD_DPM_SetDataInfo+0xec>)
 80064b4:	089b      	lsrs	r3, r3, #2
 80064b6:	1940      	adds	r0, r0, r5
 80064b8:	6143      	str	r3, [r0, #20]
      for (index = 0; index < (Size / 4); index++)
 80064ba:	428b      	cmp	r3, r1
 80064bc:	d0ea      	beq.n	8006494 <USBPD_DPM_SetDataInfo+0x30>
        DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index] = LE32(Ptr + index);
 80064be:	7862      	ldrb	r2, [r4, #1]
 80064c0:	78a6      	ldrb	r6, [r4, #2]
 80064c2:	0212      	lsls	r2, r2, #8
 80064c4:	0436      	lsls	r6, r6, #16
 80064c6:	1992      	adds	r2, r2, r6
 80064c8:	7826      	ldrb	r6, [r4, #0]
 80064ca:	008d      	lsls	r5, r1, #2
 80064cc:	1992      	adds	r2, r2, r6
 80064ce:	78e6      	ldrb	r6, [r4, #3]
      for (index = 0; index < (Size / 4); index++)
 80064d0:	3101      	adds	r1, #1
        DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index] = LE32(Ptr + index);
 80064d2:	0636      	lsls	r6, r6, #24
 80064d4:	1992      	adds	r2, r2, r6
 80064d6:	5142      	str	r2, [r0, r5]
 80064d8:	3404      	adds	r4, #4
 80064da:	e7ee      	b.n	80064ba <USBPD_DPM_SetDataInfo+0x56>
    if (Size <= (USBPD_MAX_NB_PDO * 4))
 80064dc:	2b14      	cmp	r3, #20
 80064de:	d8d9      	bhi.n	8006494 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO = (Size / 4);
 80064e0:	2078      	movs	r0, #120	; 0x78
 80064e2:	4345      	muls	r5, r0
 80064e4:	4a1a      	ldr	r2, [pc, #104]	; (8006550 <USBPD_DPM_SetDataInfo+0xec>)
 80064e6:	089b      	lsrs	r3, r3, #2
 80064e8:	1951      	adds	r1, r2, r5
 80064ea:	62cb      	str	r3, [r1, #44]	; 0x2c
 80064ec:	3518      	adds	r5, #24
 80064ee:	009b      	lsls	r3, r3, #2
 80064f0:	1955      	adds	r5, r2, r5
 80064f2:	18e3      	adds	r3, r4, r3
      for (index = 0; index < (Size / 4); index++)
 80064f4:	429c      	cmp	r4, r3
 80064f6:	d0cd      	beq.n	8006494 <USBPD_DPM_SetDataInfo+0x30>
        DPM_Ports[PortNum].DPM_ListOfRcvSNKPDO[index] = LE32(Ptr + index);
 80064f8:	7860      	ldrb	r0, [r4, #1]
 80064fa:	78a2      	ldrb	r2, [r4, #2]
 80064fc:	0200      	lsls	r0, r0, #8
 80064fe:	0412      	lsls	r2, r2, #16
 8006500:	1880      	adds	r0, r0, r2
 8006502:	7822      	ldrb	r2, [r4, #0]
 8006504:	1880      	adds	r0, r0, r2
 8006506:	78e2      	ldrb	r2, [r4, #3]
 8006508:	3404      	adds	r4, #4
 800650a:	0612      	lsls	r2, r2, #24
 800650c:	1880      	adds	r0, r0, r2
 800650e:	c501      	stmia	r5!, {r0}
 8006510:	e7f0      	b.n	80064f4 <USBPD_DPM_SetDataInfo+0x90>
    if (Size == 4)
 8006512:	2b04      	cmp	r3, #4
 8006514:	d1be      	bne.n	8006494 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_RcvRequestDOMsg = *Ptr;
 8006516:	2078      	movs	r0, #120	; 0x78
 8006518:	4368      	muls	r0, r5
 800651a:	4d0d      	ldr	r5, [pc, #52]	; (8006550 <USBPD_DPM_SetDataInfo+0xec>)
 800651c:	6813      	ldr	r3, [r2, #0]
 800651e:	182d      	adds	r5, r5, r0
 8006520:	64eb      	str	r3, [r5, #76]	; 0x4c
 8006522:	e7b7      	b.n	8006494 <USBPD_DPM_SetDataInfo+0x30>
      ext_capa = (uint8_t*)&DPM_Ports[PortNum].DPM_RcvSRCExtendedCapa;
 8006524:	2078      	movs	r0, #120	; 0x78
 8006526:	4368      	muls	r0, r5
 8006528:	4d09      	ldr	r5, [pc, #36]	; (8006550 <USBPD_DPM_SetDataInfo+0xec>)
 800652a:	305c      	adds	r0, #92	; 0x5c
 800652c:	1828      	adds	r0, r5, r0
      memcpy(ext_capa, Ptr, Size);
 800652e:	001a      	movs	r2, r3
 8006530:	0021      	movs	r1, r4
 8006532:	f006 fabb 	bl	800caac <memcpy>
    break;
 8006536:	e7ad      	b.n	8006494 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget = *temp;
 8006538:	2078      	movs	r0, #120	; 0x78
 800653a:	4368      	muls	r0, r5
 800653c:	4d04      	ldr	r5, [pc, #16]	; (8006550 <USBPD_DPM_SetDataInfo+0xec>)
 800653e:	7812      	ldrb	r2, [r2, #0]
 8006540:	182d      	adds	r5, r5, r0
 8006542:	002b      	movs	r3, r5
 8006544:	3374      	adds	r3, #116	; 0x74
 8006546:	701a      	strb	r2, [r3, #0]
      DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoRef    = *(temp + 1);
 8006548:	7863      	ldrb	r3, [r4, #1]
 800654a:	3575      	adds	r5, #117	; 0x75
 800654c:	702b      	strb	r3, [r5, #0]
}
 800654e:	e7a1      	b.n	8006494 <USBPD_DPM_SetDataInfo+0x30>
 8006550:	200002c4 	.word	0x200002c4

08006554 <USBPD_DPM_EvaluateRequest>:
{
 8006554:	b5f0      	push	{r4, r5, r6, r7, lr}
  rdo.d32 = pdhandle->DPM_RcvRequestDOMsg;
 8006556:	2478      	movs	r4, #120	; 0x78
 8006558:	4344      	muls	r4, r0
 800655a:	4b1a      	ldr	r3, [pc, #104]	; (80065c4 <USBPD_DPM_EvaluateRequest+0x70>)
{
 800655c:	b085      	sub	sp, #20
  rdo.d32 = pdhandle->DPM_RcvRequestDOMsg;
 800655e:	191c      	adds	r4, r3, r4
  pdhandle->DPM_RDOPosition = 0;
 8006560:	2300      	movs	r3, #0
  rdo.d32 = pdhandle->DPM_RcvRequestDOMsg;
 8006562:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
  if (USBPD_PWR_IF_SearchRequestedPDO(PortNum, rdoobjposition, &pdo.d32) != USBPD_OK)
 8006564:	af03      	add	r7, sp, #12
  rdoobjposition  = rdo.GenericRDO.ObjectPosition;
 8006566:	006e      	lsls	r6, r5, #1
 8006568:	0f76      	lsrs	r6, r6, #29
{
 800656a:	9101      	str	r1, [sp, #4]
  pdhandle->DPM_RDOPosition = 0;
 800656c:	6323      	str	r3, [r4, #48]	; 0x30
  if (USBPD_PWR_IF_SearchRequestedPDO(PortNum, rdoobjposition, &pdo.d32) != USBPD_OK)
 800656e:	003a      	movs	r2, r7
 8006570:	0031      	movs	r1, r6
 8006572:	f000 f9ab 	bl	80068cc <USBPD_PWR_IF_SearchRequestedPDO>
 8006576:	2800      	cmp	r0, #0
 8006578:	d001      	beq.n	800657e <USBPD_DPM_EvaluateRequest+0x2a>
      return USBPD_REJECT;
 800657a:	200c      	movs	r0, #12
 800657c:	e01f      	b.n	80065be <USBPD_DPM_EvaluateRequest+0x6a>
  switch(pdo.GenericPDO.PowerObject)
 800657e:	ab02      	add	r3, sp, #8
 8006580:	79da      	ldrb	r2, [r3, #7]
 8006582:	0992      	lsrs	r2, r2, #6
 8006584:	b2d3      	uxtb	r3, r2
 8006586:	2b00      	cmp	r3, #0
 8006588:	d1f7      	bne.n	800657a <USBPD_DPM_EvaluateRequest+0x26>
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 800658a:	200a      	movs	r0, #10
      pdomaxcurrent = pdo.SRCFixedPDO.MaxCurrentIn10mAunits;
 800658c:	883b      	ldrh	r3, [r7, #0]
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 800658e:	0007      	movs	r7, r0
      rdomaxcurrent = rdo.FixedVariableRDO.MaxOperatingCurrent10mAunits;
 8006590:	05a9      	lsls	r1, r5, #22
      rdoopcurrent  = rdo.FixedVariableRDO.OperatingCurrentIn10mAunits;
 8006592:	032d      	lsls	r5, r5, #12
 8006594:	0dad      	lsrs	r5, r5, #22
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 8006596:	436f      	muls	r7, r5
      pdomaxcurrent = pdo.SRCFixedPDO.MaxCurrentIn10mAunits;
 8006598:	059b      	lsls	r3, r3, #22
 800659a:	0d9b      	lsrs	r3, r3, #22
      rdomaxcurrent = rdo.FixedVariableRDO.MaxOperatingCurrent10mAunits;
 800659c:	0d89      	lsrs	r1, r1, #22
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 800659e:	63a7      	str	r7, [r4, #56]	; 0x38
      if(rdoopcurrent > pdomaxcurrent)
 80065a0:	42ab      	cmp	r3, r5
 80065a2:	d3ea      	bcc.n	800657a <USBPD_DPM_EvaluateRequest+0x26>
      if(rdomaxcurrent > pdomaxcurrent)
 80065a4:	428b      	cmp	r3, r1
 80065a6:	d3e8      	bcc.n	800657a <USBPD_DPM_EvaluateRequest+0x26>
  pdhandle->DPM_RequestedVoltage = pdo.SRCFixedPDO.VoltageIn50mVunits * 50;
 80065a8:	2132      	movs	r1, #50	; 0x32
 80065aa:	9b03      	ldr	r3, [sp, #12]
 80065ac:	031b      	lsls	r3, r3, #12
 80065ae:	0d9b      	lsrs	r3, r3, #22
 80065b0:	434b      	muls	r3, r1
 80065b2:	6363      	str	r3, [r4, #52]	; 0x34
  pdhandle->DPM_RDOPositionPrevious = pdhandle->DPM_RDOPosition;
 80065b4:	6b23      	ldr	r3, [r4, #48]	; 0x30
  pdhandle->DPM_RDOPosition = rdoobjposition;
 80065b6:	6326      	str	r6, [r4, #48]	; 0x30
  pdhandle->DPM_RDOPositionPrevious = pdhandle->DPM_RDOPosition;
 80065b8:	6423      	str	r3, [r4, #64]	; 0x40
  *PtrPowerObject = pdo.GenericPDO.PowerObject;
 80065ba:	9b01      	ldr	r3, [sp, #4]
 80065bc:	701a      	strb	r2, [r3, #0]
}
 80065be:	b005      	add	sp, #20
 80065c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80065c2:	46c0      	nop			; (mov r8, r8)
 80065c4:	200002c4 	.word	0x200002c4

080065c8 <USBPD_DPM_ExtendedMessageReceived>:
}
 80065c8:	4770      	bx	lr

080065ca <USBPD_DPM_EnterErrorRecovery>:
{
 80065ca:	b510      	push	{r4, lr}
 80065cc:	0004      	movs	r4, r0
  DPM_TurnOffPower(PortNum, DPM_Params[PortNum].PE_PowerRole);
 80065ce:	f7ff fd71 	bl	80060b4 <DPM_TurnOffPower.isra.0>
  USBPD_CAD_EnterErrorRecovery(PortNum);
 80065d2:	0020      	movs	r0, r4
 80065d4:	f7f9 fe3e 	bl	8000254 <USBPD_CAD_EnterErrorRecovery>
}
 80065d8:	bd10      	pop	{r4, pc}
	...

080065dc <USBPD_DPM_EvaluateDataRoleSwap>:
  if (USBPD_TRUE == DPM_USER_Settings[PortNum].PE_DataSwap)
 80065dc:	2238      	movs	r2, #56	; 0x38
 80065de:	4342      	muls	r2, r0
 80065e0:	4b06      	ldr	r3, [pc, #24]	; (80065fc <USBPD_DPM_EvaluateDataRoleSwap+0x20>)
{
 80065e2:	b510      	push	{r4, lr}
  if (USBPD_TRUE == DPM_USER_Settings[PortNum].PE_DataSwap)
 80065e4:	189b      	adds	r3, r3, r2
 80065e6:	3330      	adds	r3, #48	; 0x30
 80065e8:	789a      	ldrb	r2, [r3, #2]
  USBPD_StatusTypeDef status = USBPD_REJECT;
 80065ea:	230c      	movs	r3, #12
  if (USBPD_TRUE == DPM_USER_Settings[PortNum].PE_DataSwap)
 80065ec:	07d2      	lsls	r2, r2, #31
 80065ee:	d502      	bpl.n	80065f6 <USBPD_DPM_EvaluateDataRoleSwap+0x1a>
    STUSB16xx_HW_IF_DataRoleSwap(PortNum);
 80065f0:	f005 f89a 	bl	800b728 <STUSB16xx_HW_IF_DataRoleSwap>
    status = USBPD_ACCEPT;
 80065f4:	230a      	movs	r3, #10
}
 80065f6:	0018      	movs	r0, r3
 80065f8:	bd10      	pop	{r4, pc}
 80065fa:	46c0      	nop			; (mov r8, r8)
 80065fc:	0800ccfc 	.word	0x0800ccfc

08006600 <USBPD_DPM_IsPowerReady>:
{
 8006600:	b510      	push	{r4, lr}
  return ((USBPD_OK == USBPD_PWR_IF_SupplyReady(PortNum, Vsafe)) ? USBPD_ENABLE : USBPD_DISABLE);
 8006602:	f000 f907 	bl	8006814 <USBPD_PWR_IF_SupplyReady>
 8006606:	4243      	negs	r3, r0
 8006608:	4158      	adcs	r0, r3
 800660a:	b2c0      	uxtb	r0, r0
}
 800660c:	bd10      	pop	{r4, pc}

0800660e <USBPD_DPM_RequestGetSourceCapabilityExt>:
{
 800660e:	b510      	push	{r4, lr}
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_GET_SRC_CAPEXT, USBPD_SOPTYPE_SOP);
 8006610:	2200      	movs	r2, #0
 8006612:	2111      	movs	r1, #17
 8006614:	f7fc fe24 	bl	8003260 <USBPD_PE_Request_CtrlMessage>
}
 8006618:	bd10      	pop	{r4, pc}
	...

0800661c <USBPD_DPM_UserExecute>:
{
 800661c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint32_t _timing = osWaitForever;
 800661e:	2201      	movs	r2, #1
    switch (((DPM_USER_EVENT)event.value.v & 0xF))
 8006620:	250f      	movs	r5, #15
  osMessageQId  queue = *(osMessageQId *)argument;
 8006622:	6804      	ldr	r4, [r0, #0]
  uint32_t _timing = osWaitForever;
 8006624:	4252      	negs	r2, r2
    osEvent event = osMessageGet(queue, _timing);
 8006626:	a801      	add	r0, sp, #4
 8006628:	0021      	movs	r1, r4
 800662a:	f005 f9b1 	bl	800b990 <osMessageGet>
    switch (((DPM_USER_EVENT)event.value.v & 0xF))
 800662e:	9802      	ldr	r0, [sp, #8]
 8006630:	4e09      	ldr	r6, [pc, #36]	; (8006658 <USBPD_DPM_UserExecute+0x3c>)
 8006632:	4028      	ands	r0, r5
 8006634:	d109      	bne.n	800664a <USBPD_DPM_UserExecute+0x2e>
      if (DPM_TIMER_ENABLE_MSK == DPM_Ports[USBPD_PORT_0].DPM_TimerSRCExtendedCapa)
 8006636:	0033      	movs	r3, r6
 8006638:	2280      	movs	r2, #128	; 0x80
 800663a:	335a      	adds	r3, #90	; 0x5a
 800663c:	8819      	ldrh	r1, [r3, #0]
 800663e:	0212      	lsls	r2, r2, #8
 8006640:	4291      	cmp	r1, r2
 8006642:	d102      	bne.n	800664a <USBPD_DPM_UserExecute+0x2e>
        DPM_Ports[USBPD_PORT_0].DPM_TimerSRCExtendedCapa = 0;
 8006644:	8018      	strh	r0, [r3, #0]
        USBPD_DPM_RequestGetSourceCapabilityExt(USBPD_PORT_0);
 8006646:	f7ff ffe2 	bl	800660e <USBPD_DPM_RequestGetSourceCapabilityExt>
{
  uint32_t _timing = osWaitForever;
  uint32_t _current_timing;

  /* Calculate the minimum timers to wake-up DPM tasks */
  _current_timing = DPM_Ports[USBPD_PORT_0].DPM_TimerSRCExtendedCapa & DPM_TIMER_READ_MSK;
 800664a:	365a      	adds	r6, #90	; 0x5a
 800664c:	8832      	ldrh	r2, [r6, #0]
 800664e:	0452      	lsls	r2, r2, #17
 8006650:	0c52      	lsrs	r2, r2, #17
  if(_current_timing > 0)
 8006652:	d1e8      	bne.n	8006626 <USBPD_DPM_UserExecute+0xa>
  uint32_t _timing = osWaitForever;
 8006654:	3a01      	subs	r2, #1
  do{
 8006656:	e7e6      	b.n	8006626 <USBPD_DPM_UserExecute+0xa>
 8006658:	200002c4 	.word	0x200002c4

0800665c <HAL_GPIO_EXTI_Callback>:
{
 800665c:	b510      	push	{r4, lr}
  USBPD_HW_IF_EXTI_Callback(GPIO_Pin);
 800665e:	f003 f8e7 	bl	8009830 <USBPD_HW_IF_EXTI_Callback>
}
 8006662:	bd10      	pop	{r4, pc}

08006664 <USBPD_PWR_IF_Init>:
{

  /* Set links to PDO values and number for Port 0 (defined in PDO arrays in H file).
   */
#if (PORT0_NB_SOURCEPDO > 0)
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.ListOfPDO = (uint32_t *) PORT0_PDO_ListSRC;
 8006664:	4b03      	ldr	r3, [pc, #12]	; (8006674 <USBPD_PWR_IF_Init+0x10>)
 8006666:	4a04      	ldr	r2, [pc, #16]	; (8006678 <USBPD_PWR_IF_Init+0x14>)
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.NumberOfPDO = PORT0_NB_SOURCEPDO;
#endif


  return USBPD_OK;
}
 8006668:	2000      	movs	r0, #0
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.ListOfPDO = (uint32_t *) PORT0_PDO_ListSRC;
 800666a:	601a      	str	r2, [r3, #0]
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.NumberOfPDO = PORT0_NB_SOURCEPDO;
 800666c:	2205      	movs	r2, #5
 800666e:	711a      	strb	r2, [r3, #4]
}
 8006670:	4770      	bx	lr
 8006672:	46c0      	nop			; (mov r8, r8)
 8006674:	20001a48 	.word	0x20001a48
 8006678:	0800cc08 	.word	0x0800cc08

0800667c <USBPD_PWR_IF_SetProfile>:
  * @param  PreviousPowerProfile  Number of the previous required Power Data Objects
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_PWR_IF_SetProfile(uint8_t PortNum, uint8_t Profile, uint8_t PreviousPowerProfile)
{
	set_PortNum=PortNum;
 800667c:	4b60      	ldr	r3, [pc, #384]	; (8006800 <USBPD_PWR_IF_SetProfile+0x184>)
{
 800667e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	set_PortNum=PortNum;
 8006680:	7018      	strb	r0, [r3, #0]
	set_profile=Profile;
 8006682:	7059      	strb	r1, [r3, #1]
	old_profile=PreviousPowerProfile;
 8006684:	709a      	strb	r2, [r3, #2]
  uint32_t timeout_end;
#endif /* (PORT0_NB_SOURCEPDO >= 2)|| (PORT0_NB_SOURCEAPDO > 0) */
  USBPD_StatusTypeDef      ret = USBPD_ERROR;

  /* Check if valid port */
  if ( !USBPD_PORT_IsValid(PortNum) )
 8006686:	2800      	cmp	r0, #0
 8006688:	d15b      	bne.n	8006742 <USBPD_PWR_IF_SetProfile+0xc6>
  }

#if (PORT0_NB_SOURCEPDO >= 2)|| (PORT0_NB_SOURCEAPDO > 0)
  /* Check if profile nb is valid for this port */
  /* SRC Mode */
  if (USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 800668a:	4a5e      	ldr	r2, [pc, #376]	; (8006804 <USBPD_PWR_IF_SetProfile+0x188>)
 800668c:	7812      	ldrb	r2, [r2, #0]
 800668e:	0752      	lsls	r2, r2, #29
 8006690:	d557      	bpl.n	8006742 <USBPD_PWR_IF_SetProfile+0xc6>
  {
    if (Profile >= PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO)
 8006692:	4a5d      	ldr	r2, [pc, #372]	; (8006808 <USBPD_PWR_IF_SetProfile+0x18c>)
 8006694:	7910      	ldrb	r0, [r2, #4]
 8006696:	4288      	cmp	r0, r1
 8006698:	d953      	bls.n	8006742 <USBPD_PWR_IF_SetProfile+0xc6>
    {
      return ret;
    }
    if (0 == PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO)
 800669a:	2800      	cmp	r0, #0
 800669c:	d051      	beq.n	8006742 <USBPD_PWR_IF_SetProfile+0xc6>
    {
      return ret;
    }
    pdo.d32 = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO[Profile];
 800669e:	6812      	ldr	r2, [r2, #0]
 80066a0:	0089      	lsls	r1, r1, #2
 80066a2:	588d      	ldr	r5, [r1, r2]

    {
      /* Case PDO is a fixed type */
      if (pdo.GenericPDO.PowerObject == USBPD_PDO_TYPE_FIXED)
 80066a4:	223f      	movs	r2, #63	; 0x3f
 80066a6:	0e28      	lsrs	r0, r5, #24
 80066a8:	4390      	bics	r0, r2
 80066aa:	d14a      	bne.n	8006742 <USBPD_PWR_IF_SetProfile+0xc6>
      {
        vbusTargetInmv = (pdo.SRCFixedPDO.VoltageIn50mVunits * 50);
 80066ac:	032d      	lsls	r5, r5, #12
 80066ae:	3a0d      	subs	r2, #13
 80066b0:	0dad      	lsrs	r5, r5, #22
 80066b2:	4355      	muls	r5, r2
        bus_target = vbusTargetInmv;
        HW_IF_PWR_SetVoltage(PortNum, vbusTargetInmv);
 80066b4:	b2af      	uxth	r7, r5
 80066b6:	0039      	movs	r1, r7
        bus_target = vbusTargetInmv;
 80066b8:	605d      	str	r5, [r3, #4]
        while  (((  HW_IF_PWR_GetVoltage_from_reg(PortNum)) != vbusTargetInmv))
        {
          /* OS delay used to allow task preemption */
          osDelay(1);
          /* Check if timeout to get voltage expired or not */
          if ((HAL_GetTick() - timeout) > timeout_end)
 80066ba:	24fa      	movs	r4, #250	; 0xfa
        HW_IF_PWR_SetVoltage(PortNum, vbusTargetInmv);
 80066bc:	f004 f818 	bl	800a6f0 <HW_IF_PWR_SetVoltage>
        timeout = HAL_GetTick();
 80066c0:	f000 fd1e 	bl	8007100 <HAL_GetTick>
          if ((HAL_GetTick() - timeout) > timeout_end)
 80066c4:	0064      	lsls	r4, r4, #1
        timeout = HAL_GetTick();
 80066c6:	9001      	str	r0, [sp, #4]
        while  (((  HW_IF_PWR_GetVoltage_from_reg(PortNum)) != vbusTargetInmv))
 80066c8:	2000      	movs	r0, #0
 80066ca:	f004 f887 	bl	800a7dc <HW_IF_PWR_GetVoltage_from_reg>
 80066ce:	0006      	movs	r6, r0
 80066d0:	42a8      	cmp	r0, r5
 80066d2:	d12d      	bne.n	8006730 <USBPD_PWR_IF_SetProfile+0xb4>
  * @retval USBPD_ENABLE or USBPD_DISABLE
  */
USBPD_FunctionalState USBPD_PWR_IF_VBUSIsEnabled(uint8_t PortNum)
{
  /* Get the Status of the port */
  return USBPD_PORT_IsValid(PortNum) ? (USBPD_FunctionalState)HW_IF_PWR_VBUSIsEnabled(PortNum) : USBPD_DISABLE;
 80066d4:	2000      	movs	r0, #0
 80066d6:	f004 f8a5 	bl	800a824 <HW_IF_PWR_VBUSIsEnabled>
    if (USBPD_ENABLE == USBPD_PWR_IF_VBUSIsEnabled(PortNum)) // HW_IF_PWR_IsEnabled(PortNum))
 80066da:	2801      	cmp	r0, #1
 80066dc:	d000      	beq.n	80066e0 <USBPD_PWR_IF_SetProfile+0x64>
 80066de:	e082      	b.n	80067e6 <USBPD_PWR_IF_SetProfile+0x16a>
      origine = (uint32_t) HW_IF_PWR_GetVoltage_from_reg(PortNum); /* store setting of previous step*/
 80066e0:	2000      	movs	r0, #0
 80066e2:	f004 f87b 	bl	800a7dc <HW_IF_PWR_GetVoltage_from_reg>
 80066e6:	0004      	movs	r4, r0
      if (origine != vbusTargetInmv)
 80066e8:	4285      	cmp	r5, r0
 80066ea:	d02a      	beq.n	8006742 <USBPD_PWR_IF_SetProfile+0xc6>
        if (vbusTargetInmv > origine)
 80066ec:	d92b      	bls.n	8006746 <USBPD_PWR_IF_SetProfile+0xca>
          delta_val = vbusTargetInmv - origine;
 80066ee:	1a2d      	subs	r5, r5, r0
        if ( (delta_val > 100) && (pos == 1) )
 80066f0:	2d64      	cmp	r5, #100	; 0x64
 80066f2:	d92b      	bls.n	800674c <USBPD_PWR_IF_SetProfile+0xd0>
            max = (110 * new_val)/100 ;
 80066f4:	206e      	movs	r0, #110	; 0x6e
            new_val = new_val + step;
 80066f6:	3464      	adds	r4, #100	; 0x64
            max = (110 * new_val)/100 ;
 80066f8:	2164      	movs	r1, #100	; 0x64
 80066fa:	4360      	muls	r0, r4
 80066fc:	f7ff f964 	bl	80059c8 <__udivsi3>
 8006700:	0007      	movs	r7, r0
            min = (90 * new_val)/100 ;
 8006702:	205a      	movs	r0, #90	; 0x5a
 8006704:	2164      	movs	r1, #100	; 0x64
 8006706:	4360      	muls	r0, r4
 8006708:	f7ff f95e 	bl	80059c8 <__udivsi3>
            HW_IF_PWR_SetVoltage(PortNum, new_val);
 800670c:	b2a1      	uxth	r1, r4
            min = (90 * new_val)/100 ;
 800670e:	0005      	movs	r5, r0
            HW_IF_PWR_SetVoltage(PortNum, new_val);
 8006710:	2000      	movs	r0, #0
 8006712:	f003 ffed 	bl	800a6f0 <HW_IF_PWR_SetVoltage>
            while  (((  HW_IF_PWR_GetVoltage(PortNum)) > max ) || ((  HW_IF_PWR_GetVoltage(PortNum)) < min ))            
 8006716:	2000      	movs	r0, #0
 8006718:	f004 f854 	bl	800a7c4 <HW_IF_PWR_GetVoltage>
 800671c:	42b8      	cmp	r0, r7
 800671e:	d82c      	bhi.n	800677a <USBPD_PWR_IF_SetProfile+0xfe>
 8006720:	2000      	movs	r0, #0
 8006722:	f004 f84f 	bl	800a7c4 <HW_IF_PWR_GetVoltage>
 8006726:	42a8      	cmp	r0, r5
 8006728:	d327      	bcc.n	800677a <USBPD_PWR_IF_SetProfile+0xfe>
          } while ( new_val < vbusTargetInmv);
 800672a:	42a6      	cmp	r6, r4
 800672c:	d8e2      	bhi.n	80066f4 <USBPD_PWR_IF_SetProfile+0x78>
 800672e:	e008      	b.n	8006742 <USBPD_PWR_IF_SetProfile+0xc6>
          osDelay(1);
 8006730:	2001      	movs	r0, #1
 8006732:	f005 f8f8 	bl	800b926 <osDelay>
          if ((HAL_GetTick() - timeout) > timeout_end)
 8006736:	f000 fce3 	bl	8007100 <HAL_GetTick>
 800673a:	9b01      	ldr	r3, [sp, #4]
 800673c:	1ac0      	subs	r0, r0, r3
 800673e:	42a0      	cmp	r0, r4
 8006740:	d9c2      	bls.n	80066c8 <USBPD_PWR_IF_SetProfile+0x4c>
}
 8006742:	2002      	movs	r0, #2
 8006744:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
          delta_val = origine - vbusTargetInmv;
 8006746:	1b45      	subs	r5, r0, r5
        if ( (delta_val > 100) && (pos == 1) )
 8006748:	2d64      	cmp	r5, #100	; 0x64
 800674a:	d818      	bhi.n	800677e <USBPD_PWR_IF_SetProfile+0x102>
          HW_IF_PWR_SetVoltage(PortNum, vbusTargetInmv);
 800674c:	0039      	movs	r1, r7
 800674e:	2000      	movs	r0, #0
 8006750:	f003 ffce 	bl	800a6f0 <HW_IF_PWR_SetVoltage>
          HW_IF_PWR_GetVoltage_from_reg(PortNum);
 8006754:	2000      	movs	r0, #0
 8006756:	f004 f841 	bl	800a7dc <HW_IF_PWR_GetVoltage_from_reg>
          vbusmin = 90* vbusTargetInmv /100;
 800675a:	205a      	movs	r0, #90	; 0x5a
 800675c:	2164      	movs	r1, #100	; 0x64
 800675e:	4370      	muls	r0, r6
 8006760:	f7ff f932 	bl	80059c8 <__udivsi3>
 8006764:	0004      	movs	r4, r0
          vbusmax = 110* vbusTargetInmv / 100;
 8006766:	206e      	movs	r0, #110	; 0x6e
 8006768:	2164      	movs	r1, #100	; 0x64
 800676a:	4370      	muls	r0, r6
 800676c:	f7ff f92c 	bl	80059c8 <__udivsi3>
 8006770:	0006      	movs	r6, r0
          timeout = HAL_GetTick();
 8006772:	f000 fcc5 	bl	8007100 <HAL_GetTick>
 8006776:	0005      	movs	r5, r0
          while  (((  HW_IF_PWR_GetVoltage_from_reg(PortNum)  ) > vbusmax) || ((  HW_IF_PWR_GetVoltage_from_reg(PortNum) ) < vbusmin))
 8006778:	e02a      	b.n	80067d0 <USBPD_PWR_IF_SetProfile+0x154>
 800677a:	46c0      	nop			; (mov r8, r8)
 800677c:	e7cb      	b.n	8006716 <USBPD_PWR_IF_SetProfile+0x9a>
              max = (110 * new_val)/100 ;
 800677e:	206e      	movs	r0, #110	; 0x6e
              new_val = new_val - step;
 8006780:	3c64      	subs	r4, #100	; 0x64
              max = (110 * new_val)/100 ;
 8006782:	2164      	movs	r1, #100	; 0x64
 8006784:	4360      	muls	r0, r4
 8006786:	f7ff f91f 	bl	80059c8 <__udivsi3>
 800678a:	0007      	movs	r7, r0
              min = (90 * new_val)/100 ;
 800678c:	205a      	movs	r0, #90	; 0x5a
 800678e:	2164      	movs	r1, #100	; 0x64
 8006790:	4360      	muls	r0, r4
 8006792:	f7ff f919 	bl	80059c8 <__udivsi3>
              HW_IF_PWR_SetVoltage(PortNum, new_val);
 8006796:	b2a1      	uxth	r1, r4
              min = (90 * new_val)/100 ;
 8006798:	0005      	movs	r5, r0
              HW_IF_PWR_SetVoltage(PortNum, new_val);
 800679a:	2000      	movs	r0, #0
 800679c:	f003 ffa8 	bl	800a6f0 <HW_IF_PWR_SetVoltage>
              while  (((  HW_IF_PWR_GetVoltage(PortNum)  ) > max ) || ((  HW_IF_PWR_GetVoltage(PortNum)) < min ))
 80067a0:	2000      	movs	r0, #0
 80067a2:	f004 f80f 	bl	800a7c4 <HW_IF_PWR_GetVoltage>
 80067a6:	42b8      	cmp	r0, r7
 80067a8:	d807      	bhi.n	80067ba <USBPD_PWR_IF_SetProfile+0x13e>
 80067aa:	2000      	movs	r0, #0
 80067ac:	f004 f80a 	bl	800a7c4 <HW_IF_PWR_GetVoltage>
 80067b0:	42a8      	cmp	r0, r5
 80067b2:	d302      	bcc.n	80067ba <USBPD_PWR_IF_SetProfile+0x13e>
            } while ( new_val > vbusTargetInmv);
 80067b4:	42a6      	cmp	r6, r4
 80067b6:	d3e2      	bcc.n	800677e <USBPD_PWR_IF_SetProfile+0x102>
 80067b8:	e7c3      	b.n	8006742 <USBPD_PWR_IF_SetProfile+0xc6>
 80067ba:	46c0      	nop			; (mov r8, r8)
 80067bc:	e7f0      	b.n	80067a0 <USBPD_PWR_IF_SetProfile+0x124>
            osDelay(1);
 80067be:	2001      	movs	r0, #1
 80067c0:	f005 f8b1 	bl	800b926 <osDelay>
            if ((HAL_GetTick() - timeout) > timeout_end)
 80067c4:	f000 fc9c 	bl	8007100 <HAL_GetTick>
 80067c8:	9b01      	ldr	r3, [sp, #4]
 80067ca:	1b40      	subs	r0, r0, r5
 80067cc:	4298      	cmp	r0, r3
 80067ce:	d8b8      	bhi.n	8006742 <USBPD_PWR_IF_SetProfile+0xc6>
          while  (((  HW_IF_PWR_GetVoltage_from_reg(PortNum)  ) > vbusmax) || ((  HW_IF_PWR_GetVoltage_from_reg(PortNum) ) < vbusmin))
 80067d0:	2000      	movs	r0, #0
 80067d2:	f004 f803 	bl	800a7dc <HW_IF_PWR_GetVoltage_from_reg>
 80067d6:	42b0      	cmp	r0, r6
 80067d8:	d8f1      	bhi.n	80067be <USBPD_PWR_IF_SetProfile+0x142>
 80067da:	2000      	movs	r0, #0
 80067dc:	f003 fffe 	bl	800a7dc <HW_IF_PWR_GetVoltage_from_reg>
 80067e0:	42a0      	cmp	r0, r4
 80067e2:	d3ec      	bcc.n	80067be <USBPD_PWR_IF_SetProfile+0x142>
 80067e4:	e7ad      	b.n	8006742 <USBPD_PWR_IF_SetProfile+0xc6>
      HW_IF_PWR_SetVoltage(PortNum, 5000);
 80067e6:	4909      	ldr	r1, [pc, #36]	; (800680c <USBPD_PWR_IF_SetProfile+0x190>)
 80067e8:	2000      	movs	r0, #0
 80067ea:	f003 ff81 	bl	800a6f0 <HW_IF_PWR_SetVoltage>
      HW_IF_PWR_GetVoltage(PortNum);
 80067ee:	2000      	movs	r0, #0
 80067f0:	f003 ffe8 	bl	800a7c4 <HW_IF_PWR_GetVoltage>
      HW_IF_PWR_SetVoltage(PortNum, 5000);
 80067f4:	4905      	ldr	r1, [pc, #20]	; (800680c <USBPD_PWR_IF_SetProfile+0x190>)
 80067f6:	2000      	movs	r0, #0
 80067f8:	f003 ff7a 	bl	800a6f0 <HW_IF_PWR_SetVoltage>
 80067fc:	e7a1      	b.n	8006742 <USBPD_PWR_IF_SetProfile+0xc6>
 80067fe:	46c0      	nop			; (mov r8, r8)
 8006800:	2000033c 	.word	0x2000033c
 8006804:	20001c60 	.word	0x20001c60
 8006808:	20001a48 	.word	0x20001a48
 800680c:	00001388 	.word	0x00001388

08006810 <USBPD_PWR_IF_PowerResetGlobal>:
}
 8006810:	2000      	movs	r0, #0
 8006812:	4770      	bx	lr

08006814 <USBPD_PWR_IF_SupplyReady>:
{
 8006814:	b510      	push	{r4, lr}
  if (!USBPD_PORT_IsValid(PortNum))
 8006816:	2800      	cmp	r0, #0
 8006818:	d10f      	bne.n	800683a <USBPD_PWR_IF_SupplyReady+0x26>
  if (USBPD_VSAFE_0V == Vsafe)
 800681a:	2900      	cmp	r1, #0
 800681c:	d107      	bne.n	800682e <USBPD_PWR_IF_SupplyReady+0x1a>
    status = (HW_IF_PWR_GetVoltage(PortNum) < CAD_threshold_VBus? USBPD_OK: USBPD_ERROR);
 800681e:	0008      	movs	r0, r1
 8006820:	f003 ffd0 	bl	800a7c4 <HW_IF_PWR_GetVoltage>
 8006824:	4b06      	ldr	r3, [pc, #24]	; (8006840 <USBPD_PWR_IF_SupplyReady+0x2c>)
 8006826:	4298      	cmp	r0, r3
 8006828:	d807      	bhi.n	800683a <USBPD_PWR_IF_SupplyReady+0x26>
 800682a:	2000      	movs	r0, #0
}
 800682c:	bd10      	pop	{r4, pc}
    status = (HW_IF_PWR_GetVoltage(PortNum) > CAD_threshold_VBus? USBPD_OK: USBPD_ERROR);
 800682e:	f003 ffc9 	bl	800a7c4 <HW_IF_PWR_GetVoltage>
 8006832:	239b      	movs	r3, #155	; 0x9b
 8006834:	009b      	lsls	r3, r3, #2
 8006836:	4298      	cmp	r0, r3
 8006838:	d8f7      	bhi.n	800682a <USBPD_PWR_IF_SupplyReady+0x16>
    status = (HW_IF_PWR_GetVoltage(PortNum) < CAD_threshold_VBus? USBPD_OK: USBPD_ERROR);
 800683a:	2002      	movs	r0, #2
 800683c:	e7f6      	b.n	800682c <USBPD_PWR_IF_SupplyReady+0x18>
 800683e:	46c0      	nop			; (mov r8, r8)
 8006840:	0000026b 	.word	0x0000026b

08006844 <USBPD_PWR_IF_VBUSEnable>:
{
 8006844:	b507      	push	{r0, r1, r2, lr}
  USBPD_StatusTypeDef _status = USBPD_ERROR;
 8006846:	2302      	movs	r3, #2
  if (USBPD_PORT_IsValid(PortNum))
 8006848:	2800      	cmp	r0, #0
 800684a:	d10a      	bne.n	8006862 <USBPD_PWR_IF_VBUSEnable+0x1e>
    _status = (USBPD_StatusTypeDef)HW_IF_PWR_Enable(PortNum, USBPD_ENABLE, DPM_Params[PortNum].VconnCCIs, DPM_Params[PortNum].VconnStatus, USBPD_PORTPOWERROLE_SRC);
 800684c:	2101      	movs	r1, #1
 800684e:	4b06      	ldr	r3, [pc, #24]	; (8006868 <USBPD_PWR_IF_VBUSEnable+0x24>)
 8006850:	789a      	ldrb	r2, [r3, #2]
 8006852:	9100      	str	r1, [sp, #0]
 8006854:	0753      	lsls	r3, r2, #29
 8006856:	0792      	lsls	r2, r2, #30
 8006858:	0fdb      	lsrs	r3, r3, #31
 800685a:	0f92      	lsrs	r2, r2, #30
 800685c:	f003 ffc6 	bl	800a7ec <HW_IF_PWR_Enable>
 8006860:	0003      	movs	r3, r0
}
 8006862:	0018      	movs	r0, r3
 8006864:	bd0e      	pop	{r1, r2, r3, pc}
 8006866:	46c0      	nop			; (mov r8, r8)
 8006868:	20001c60 	.word	0x20001c60

0800686c <USBPD_PWR_IF_VBUSDisable>:
{
 800686c:	b507      	push	{r0, r1, r2, lr}
  USBPD_StatusTypeDef _status = USBPD_ERROR;
 800686e:	2302      	movs	r3, #2
  if (USBPD_PORT_IsValid(PortNum))
 8006870:	2800      	cmp	r0, #0
 8006872:	d10b      	bne.n	800688c <USBPD_PWR_IF_VBUSDisable+0x20>
    _status = (USBPD_StatusTypeDef)HW_IF_PWR_Enable(PortNum, USBPD_DISABLE, DPM_Params[PortNum].VconnCCIs, DPM_Params[PortNum].VconnStatus, USBPD_PORTPOWERROLE_SRC);
 8006874:	2101      	movs	r1, #1
 8006876:	4b06      	ldr	r3, [pc, #24]	; (8006890 <USBPD_PWR_IF_VBUSDisable+0x24>)
 8006878:	789a      	ldrb	r2, [r3, #2]
 800687a:	9100      	str	r1, [sp, #0]
 800687c:	0753      	lsls	r3, r2, #29
 800687e:	0792      	lsls	r2, r2, #30
 8006880:	0fdb      	lsrs	r3, r3, #31
 8006882:	0f92      	lsrs	r2, r2, #30
 8006884:	0001      	movs	r1, r0
 8006886:	f003 ffb1 	bl	800a7ec <HW_IF_PWR_Enable>
 800688a:	0003      	movs	r3, r0
}
 800688c:	0018      	movs	r0, r3
 800688e:	bd0e      	pop	{r1, r2, r3, pc}
 8006890:	20001c60 	.word	0x20001c60

08006894 <USBPD_PWR_IF_GetPortPDOs>:
  * @param  Ptr Pointer on address where PDO values should be written (u32 pointer)
  * @param  Size Pointer on nb of u32 written by PWR_IF (nb of PDOs)
  * @retval None
  */
void USBPD_PWR_IF_GetPortPDOs(uint8_t PortNum, USBPD_CORE_DataInfoType_TypeDef DataId, uint32_t *Ptr, uint32_t *Size)
{
 8006894:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t   nbpdo, index, nb_valid_pdo = 0;
  uint32_t   *ptpdoarray = NULL;

  /* Check if valid port */
  if (USBPD_PORT_IsValid(PortNum))
 8006896:	2800      	cmp	r0, #0
 8006898:	d10a      	bne.n	80068b0 <USBPD_PWR_IF_GetPortPDOs+0x1c>
    case USBPD_CORE_DATATYPE_SRC_PDO:
      nbpdo       = PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO;
      ptpdoarray  = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO;
      break;
    default:
      nbpdo = 0;
 800689a:	0006      	movs	r6, r0
    switch (DataId)
 800689c:	2900      	cmp	r1, #0
 800689e:	d102      	bne.n	80068a6 <USBPD_PWR_IF_GetPortPDOs+0x12>
      nbpdo       = PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO;
 80068a0:	4909      	ldr	r1, [pc, #36]	; (80068c8 <USBPD_PWR_IF_GetPortPDOs+0x34>)
 80068a2:	790e      	ldrb	r6, [r1, #4]
      ptpdoarray  = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO;
 80068a4:	6808      	ldr	r0, [r1, #0]
 80068a6:	00b4      	lsls	r4, r6, #2
 80068a8:	1904      	adds	r4, r0, r4
      break;
    }

    /* Copy PDO data in output buffer */
    for (index = 0; index < nbpdo; index++)
 80068aa:	42a0      	cmp	r0, r4
 80068ac:	d101      	bne.n	80068b2 <USBPD_PWR_IF_GetPortPDOs+0x1e>
        nb_valid_pdo++;
      }
      ptpdoarray++;
    }
    /* Set nb of read PDO (nb of u32 elements); */
    *Size = nb_valid_pdo;
 80068ae:	601e      	str	r6, [r3, #0]
  }
}
 80068b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80068b2:	2100      	movs	r1, #0
        USPBPD_WRITE32((uint32_t *)(Ptr + nb_valid_pdo), *ptpdoarray);
 80068b4:	6807      	ldr	r7, [r0, #0]
 80068b6:	00cd      	lsls	r5, r1, #3
 80068b8:	40ef      	lsrs	r7, r5
 80068ba:	5457      	strb	r7, [r2, r1]
 80068bc:	3101      	adds	r1, #1
 80068be:	2904      	cmp	r1, #4
 80068c0:	d1f8      	bne.n	80068b4 <USBPD_PWR_IF_GetPortPDOs+0x20>
      ptpdoarray++;
 80068c2:	3004      	adds	r0, #4
 80068c4:	3204      	adds	r2, #4
 80068c6:	e7f0      	b.n	80068aa <USBPD_PWR_IF_GetPortPDOs+0x16>
 80068c8:	20001a48 	.word	0x20001a48

080068cc <USBPD_PWR_IF_SearchRequestedPDO>:
  * @retval Status of search
  *         USBPD_OK : Src PDO found for requested DO position (output Pdo parameter is set)
  *         USBPD_FAIL : Position is not compliant with current Src PDO for this port (no corresponding PDO value)
  */
USBPD_StatusTypeDef USBPD_PWR_IF_SearchRequestedPDO(uint8_t PortNum, uint32_t RdoPosition, uint32_t *Pdo)
{
 80068cc:	0003      	movs	r3, r0
 80068ce:	b530      	push	{r4, r5, lr}
  if((RdoPosition == 0) || (RdoPosition > PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO))
  {
    /* Invalid PDO index */
    return USBPD_FAIL;
 80068d0:	2010      	movs	r0, #16
  if((RdoPosition == 0) || (RdoPosition > PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO))
 80068d2:	2900      	cmp	r1, #0
 80068d4:	d00d      	beq.n	80068f2 <USBPD_PWR_IF_SearchRequestedPDO+0x26>
 80068d6:	4c07      	ldr	r4, [pc, #28]	; (80068f4 <USBPD_PWR_IF_SearchRequestedPDO+0x28>)
 80068d8:	00db      	lsls	r3, r3, #3
 80068da:	18e0      	adds	r0, r4, r3
 80068dc:	7905      	ldrb	r5, [r0, #4]
    return USBPD_FAIL;
 80068de:	2010      	movs	r0, #16
  if((RdoPosition == 0) || (RdoPosition > PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO))
 80068e0:	428d      	cmp	r5, r1
 80068e2:	d306      	bcc.n	80068f2 <USBPD_PWR_IF_SearchRequestedPDO+0x26>
  }

  *Pdo = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO[RdoPosition - 1];
 80068e4:	4804      	ldr	r0, [pc, #16]	; (80068f8 <USBPD_PWR_IF_SearchRequestedPDO+0x2c>)
 80068e6:	591b      	ldr	r3, [r3, r4]
 80068e8:	1809      	adds	r1, r1, r0
  return USBPD_OK;
 80068ea:	2000      	movs	r0, #0
  *Pdo = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO[RdoPosition - 1];
 80068ec:	0089      	lsls	r1, r1, #2
 80068ee:	58cb      	ldr	r3, [r1, r3]
 80068f0:	6013      	str	r3, [r2, #0]
}
 80068f2:	bd30      	pop	{r4, r5, pc}
 80068f4:	20001a48 	.word	0x20001a48
 80068f8:	3fffffff 	.word	0x3fffffff

080068fc <STUSB1602_Driver_Init>:
  * @param  PortNum     Port number value
  * @param  I2CxHandle  External I2C handle
  * @retval None
  */
void STUSB1602_Driver_Init(uint8_t PortNum, I2C_HandleTypeDef I2CxHandle)
{
 80068fc:	b084      	sub	sp, #16
 80068fe:	b510      	push	{r4, lr}
 8006900:	9103      	str	r1, [sp, #12]
 8006902:	9204      	str	r2, [sp, #16]
 8006904:	9305      	str	r3, [sp, #20]
  if (0 == PortNum)
  {
    STUSB16xx_I2CxHandle = I2CxHandle;
 8006906:	224c      	movs	r2, #76	; 0x4c
 8006908:	a903      	add	r1, sp, #12
  if (0 == PortNum)
 800690a:	2800      	cmp	r0, #0
 800690c:	d106      	bne.n	800691c <STUSB1602_Driver_Init+0x20>
    STUSB16xx_I2CxHandle = I2CxHandle;
 800690e:	4804      	ldr	r0, [pc, #16]	; (8006920 <STUSB1602_Driver_Init+0x24>)
  }
  else
  {
    STUSB16xx_I2CxHandle_P1 = I2CxHandle;
 8006910:	f006 f8cc 	bl	800caac <memcpy>
  }
}
 8006914:	bc10      	pop	{r4}
 8006916:	bc08      	pop	{r3}
 8006918:	b004      	add	sp, #16
 800691a:	4718      	bx	r3
    STUSB16xx_I2CxHandle_P1 = I2CxHandle;
 800691c:	4801      	ldr	r0, [pc, #4]	; (8006924 <STUSB1602_Driver_Init+0x28>)
 800691e:	e7f7      	b.n	8006910 <STUSB1602_Driver_Init+0x14>
 8006920:	20001a50 	.word	0x20001a50
 8006924:	20001ba0 	.word	0x20001ba0

08006928 <STUSB1602_ReadReg>:
  * @param Reg          Address of first register to be read
  * @param Size         Amount of bytes to be read
  * @retval STUSB1602_StatusTypeDef Allowed values are STUSB1602_OK, STUSB1602_ERROR, STUSB1602_BUSY, STUSB1602_TIMEOUT
  */
STUSB1602_StatusTypeDef STUSB1602_ReadReg(uint8_t* pBuffer, uint8_t Addr, uint8_t Reg, uint16_t Size)
  {
 8006928:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if (Addr == 0x29)
    {
      return STUSB1602_OK;
    }
#endif
    status = (STUSB1602_StatusTypeDef) HAL_I2C_Mem_Read(&STUSB16xx_I2CxHandle, (Addr<<1), (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size, TIMEOUT_MAX);
 800692a:	24fa      	movs	r4, #250	; 0xfa
 800692c:	00e4      	lsls	r4, r4, #3
 800692e:	9301      	str	r3, [sp, #4]
 8006930:	9000      	str	r0, [sp, #0]
 8006932:	b292      	uxth	r2, r2
 8006934:	0049      	lsls	r1, r1, #1
 8006936:	9402      	str	r4, [sp, #8]
 8006938:	2301      	movs	r3, #1
 800693a:	4802      	ldr	r0, [pc, #8]	; (8006944 <STUSB1602_ReadReg+0x1c>)
 800693c:	f001 fb5a 	bl	8007ff4 <HAL_I2C_Mem_Read>
    return status;
  }
 8006940:	b004      	add	sp, #16
 8006942:	bd10      	pop	{r4, pc}
 8006944:	20001a50 	.word	0x20001a50

08006948 <STUSB1602_WriteReg>:
  * @param Reg          Address of first register to be write
  * @param Size         Amount of bytes to be write
  * @retval STUSB1602_StatusTypeDef Allowed values are STUSB1602_OK, STUSB1602_ERROR, STUSB1602_BUSY, STUSB1602_TIMEOUT
  */
STUSB1602_StatusTypeDef STUSB1602_WriteReg(uint8_t* pBuffer, uint8_t Addr, uint8_t Reg, uint16_t Size)
  {
 8006948:	b51f      	push	{r0, r1, r2, r3, r4, lr}
      return STUSB1602_OK;
    }
#endif
    STUSB1602_StatusTypeDef status = STUSB1602_OK;

    status = (STUSB1602_StatusTypeDef)HAL_I2C_Mem_Write(&STUSB16xx_I2CxHandle, (Addr<<1), (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size,
 800694a:	24fa      	movs	r4, #250	; 0xfa
 800694c:	00e4      	lsls	r4, r4, #3
 800694e:	9301      	str	r3, [sp, #4]
 8006950:	9000      	str	r0, [sp, #0]
 8006952:	b292      	uxth	r2, r2
 8006954:	0049      	lsls	r1, r1, #1
 8006956:	9402      	str	r4, [sp, #8]
 8006958:	2301      	movs	r3, #1
 800695a:	4802      	ldr	r0, [pc, #8]	; (8006964 <STUSB1602_WriteReg+0x1c>)
 800695c:	f001 fa90 	bl	8007e80 <HAL_I2C_Mem_Write>
                            TIMEOUT_MAX);
 
    return status;
  }
 8006960:	b004      	add	sp, #16
 8006962:	bd10      	pop	{r4, pc}
 8006964:	20001a50 	.word	0x20001a50

08006968 <STUSB1602_Alert_Monitoring_Get>:
  * @brief  Check registers from 0x0B to 0x12
  * @param  Addr I2C address of port controller device
  * @retval STUSB1602_ALERT_MONITORING_TypeDef 
  */ 
STUSB1602_ALERT_MONITORING_TypeDef STUSB1602_Alert_Monitoring_Get(uint8_t Addr)
{
 8006968:	b513      	push	{r0, r1, r4, lr}
 800696a:	0004      	movs	r4, r0
    STUSB1602_ALERT_MONITORING_TypeDef reg;

    STUSB1602_ReadReg(&reg.reg_0B.d8, Addr, STUSB1602_ALERT_STATUS_REG, 8); 
 800696c:	2308      	movs	r3, #8
 800696e:	220b      	movs	r2, #11
 8006970:	4668      	mov	r0, sp
 8006972:	f7ff ffd9 	bl	8006928 <STUSB1602_ReadReg>

    return (reg);
 8006976:	2208      	movs	r2, #8
 8006978:	4669      	mov	r1, sp
 800697a:	0020      	movs	r0, r4
 800697c:	f006 f896 	bl	800caac <memcpy>
}
 8006980:	0020      	movs	r0, r4
 8006982:	bd16      	pop	{r1, r2, r4, pc}

08006984 <STUSB1602_CC_Detect_Alrt_Int_Mask_Set>:
  * @param  Addr I2C address of port controller device
  * @param  st Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */ 
STUSB1602_StatusTypeDef STUSB1602_CC_Detect_Alrt_Int_Mask_Set(uint8_t Addr, CC_Detect_Alrt_Int_Mask_Status_TypeDef st)
{
 8006984:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  

    STUSB1602_ALERT_STATUS_MASK_reg_TypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_ALERT_STATUS_MASK_REG, 1); 
 8006986:	ac01      	add	r4, sp, #4
{
 8006988:	0005      	movs	r5, r0
 800698a:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_ALERT_STATUS_MASK_REG, 1); 
 800698c:	2301      	movs	r3, #1
 800698e:	0001      	movs	r1, r0
 8006990:	220c      	movs	r2, #12
 8006992:	0020      	movs	r0, r4
 8006994:	f7ff ffc8 	bl	8006928 <STUSB1602_ReadReg>

    reg.b.CC_DETECTION_STATUS_AL_MASK = st;
 8006998:	2301      	movs	r3, #1
 800699a:	2240      	movs	r2, #64	; 0x40
 800699c:	7821      	ldrb	r1, [r4, #0]
 800699e:	401e      	ands	r6, r3
 80069a0:	01b6      	lsls	r6, r6, #6
 80069a2:	4391      	bics	r1, r2
 80069a4:	4331      	orrs	r1, r6
 80069a6:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_ALERT_STATUS_MASK_REG, 1);
 80069a8:	3a34      	subs	r2, #52	; 0x34
 80069aa:	0029      	movs	r1, r5
 80069ac:	0020      	movs	r0, r4
 80069ae:	f7ff ffcb 	bl	8006948 <STUSB1602_WriteReg>

    return status;
}
 80069b2:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

080069b4 <STUSB1602_Attach_State_Trans_Get>:
  * @brief  STUSB1602 Checks Attach State Transition Reg (Bit0 0x0D -- RC)
  * @param  Addr I2C address of port controller device
  * @retval Attach_State_Trans_TypeDef 
  */ 
Attach_State_Trans_TypeDef STUSB1602_Attach_State_Trans_Get(uint8_t Addr)
{
 80069b4:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_DETECTION_STATUS_TRANS_RegTypeDef reg;

    /* Check if a Transition occurred on ATTACH_STATE bit */
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_TRANS_REG, 1); 
 80069b6:	ac01      	add	r4, sp, #4
{
 80069b8:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_TRANS_REG, 1); 
 80069ba:	2301      	movs	r3, #1
 80069bc:	220d      	movs	r2, #13
 80069be:	0020      	movs	r0, r4
 80069c0:	f7ff ffb2 	bl	8006928 <STUSB1602_ReadReg>

    return (Attach_State_Trans_TypeDef)(reg.b.ATTACH_STATE_TRANS);
 80069c4:	7820      	ldrb	r0, [r4, #0]
 80069c6:	07c0      	lsls	r0, r0, #31
 80069c8:	0fc0      	lsrs	r0, r0, #31
}
 80069ca:	bd16      	pop	{r1, r2, r4, pc}

080069cc <STUSB1602_CC_Detection_Status_Get>:
  * @brief  STUSB1602 CC Detection Status  (Register 0x0E -- RO)
  * @param  Addr I2C address of port controller device
  * @retval STUSB1602_CC_DETECTION_STATUS_RegTypeDef
  */ 
STUSB1602_CC_DETECTION_STATUS_RegTypeDef STUSB1602_CC_Detection_Status_Get(uint8_t Addr)
{
 80069cc:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_DETECTION_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_REG, 1); 
 80069ce:	ac01      	add	r4, sp, #4
{
 80069d0:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_REG, 1); 
 80069d2:	2301      	movs	r3, #1
 80069d4:	220e      	movs	r2, #14
 80069d6:	0020      	movs	r0, r4
 80069d8:	f7ff ffa6 	bl	8006928 <STUSB1602_ReadReg>

    return (reg);
 80069dc:	7820      	ldrb	r0, [r4, #0]
}
 80069de:	bd16      	pop	{r1, r2, r4, pc}

080069e0 <STUSB1602_Monitoring_Status_Trans_Reg_Get>:
  * @brief STUSB1602 checks the entire Monitoring_Status_Trans_Reg (bit0-7 0x0F -- RC)
  * @param Addr I2C address of port controller device 
  * @retval STUSB1602_MONITORING_STATUS_TRANS_RegTypeDef
  */ 
STUSB1602_MONITORING_STATUS_TRANS_RegTypeDef STUSB1602_Monitoring_Status_Trans_Reg_Get(uint8_t Addr)
{
 80069e0:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_TRANS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_TRANS_REG, 1); 
 80069e2:	ac01      	add	r4, sp, #4
{
 80069e4:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_TRANS_REG, 1); 
 80069e6:	2301      	movs	r3, #1
 80069e8:	220f      	movs	r2, #15
 80069ea:	0020      	movs	r0, r4
 80069ec:	f7ff ff9c 	bl	8006928 <STUSB1602_ReadReg>

    return (reg);
 80069f0:	7820      	ldrb	r0, [r4, #0]
}
 80069f2:	bd16      	pop	{r1, r2, r4, pc}

080069f4 <STUSB1602_VBUS_Valid_Get>:
  * @brief STUSB1602 checks VBUS_Valid (bit3 0x10 -- RO)
  * @param Addr I2C address of port controller device  
  * @retval @ref VBUS_Valid_TypeDef
  */ 
VBUS_Valid_TypeDef STUSB1602_VBUS_Valid_Get(uint8_t Addr)
{
 80069f4:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 80069f6:	ac01      	add	r4, sp, #4
{
 80069f8:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 80069fa:	2301      	movs	r3, #1
 80069fc:	2210      	movs	r2, #16
 80069fe:	0020      	movs	r0, r4
 8006a00:	f7ff ff92 	bl	8006928 <STUSB1602_ReadReg>

    return (VBUS_Valid_TypeDef)(reg.b.VBUS_VALID);
 8006a04:	7820      	ldrb	r0, [r4, #0]
 8006a06:	0700      	lsls	r0, r0, #28
 8006a08:	0fc0      	lsrs	r0, r0, #31
}
 8006a0a:	bd16      	pop	{r1, r2, r4, pc}

08006a0c <STUSB1602_VBUS_VSAFE0V_Get>:
  * @brief  STUSB1602 checks VBUS_VSAFE0V (bit2 0x10 -- RO)
  * @param Addr I2C address of port controller device   
  * @retval @ref VBUS_VSAFE0V_TypeDef
  */
VBUS_VSAFE0V_TypeDef STUSB1602_VBUS_VSAFE0V_Get(uint8_t Addr)
{
 8006a0c:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 8006a0e:	ac01      	add	r4, sp, #4
{
 8006a10:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 8006a12:	2301      	movs	r3, #1
 8006a14:	2210      	movs	r2, #16
 8006a16:	0020      	movs	r0, r4
 8006a18:	f7ff ff86 	bl	8006928 <STUSB1602_ReadReg>

    return (VBUS_VSAFE0V_TypeDef)(reg.b.VBUS_VSAFE0V);
 8006a1c:	7820      	ldrb	r0, [r4, #0]
 8006a1e:	0740      	lsls	r0, r0, #29
 8006a20:	0fc0      	lsrs	r0, r0, #31
}
 8006a22:	bd16      	pop	{r1, r2, r4, pc}

08006a24 <STUSB1602_VBUS_Presence_Get>:
  * @brief STUSB1602 checks VBUS_Presence (bit1 0x10 -- RO)
  * @param Addr I2C address of port controller device   
  * @retval VBUS_Presence_TypeDef
  */ 
VBUS_Presence_TypeDef STUSB1602_VBUS_Presence_Get(uint8_t Addr)
{
 8006a24:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 8006a26:	ac01      	add	r4, sp, #4
{
 8006a28:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 8006a2a:	2301      	movs	r3, #1
 8006a2c:	2210      	movs	r2, #16
 8006a2e:	0020      	movs	r0, r4
 8006a30:	f7ff ff7a 	bl	8006928 <STUSB1602_ReadReg>

    return (VBUS_Presence_TypeDef)(reg.b.VBUS_PRESENCE);
 8006a34:	7820      	ldrb	r0, [r4, #0]
 8006a36:	0780      	lsls	r0, r0, #30
 8006a38:	0fc0      	lsrs	r0, r0, #31
}
 8006a3a:	bd16      	pop	{r1, r2, r4, pc}

08006a3c <STUSB1602_Sink_Power_State_Get>:
  * @brief STUSB1602 checks the Sink_Power_State mode (bit6-5 0x11 -- RO)
  * @param Addr I2C address of port controller device
  * @retval Sink_Power_State_TypeDef
  */ 
Sink_Power_State_TypeDef STUSB1602_Sink_Power_State_Get(uint8_t Addr)
{
 8006a3c:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_CONNECTION_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 8006a3e:	ac01      	add	r4, sp, #4
{
 8006a40:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 8006a42:	2301      	movs	r3, #1
 8006a44:	2211      	movs	r2, #17
 8006a46:	0020      	movs	r0, r4
 8006a48:	f7ff ff6e 	bl	8006928 <STUSB1602_ReadReg>

    return (Sink_Power_State_TypeDef)(reg.b.SINK_POWER_STATE);
 8006a4c:	7820      	ldrb	r0, [r4, #0]
 8006a4e:	0640      	lsls	r0, r0, #25
 8006a50:	0f80      	lsrs	r0, r0, #30
}
 8006a52:	bd16      	pop	{r1, r2, r4, pc}

08006a54 <STUSB1602_TypeC_FSM_State_Get>:
  * @brief STUSB1602 checks the TypeC_FSM_State (bit4-0 0x11 -- RO)
  * @param Addr I2C address of port controller device
  * @retval TypeC_FSM_State_TypeDef
  */
TypeC_FSM_State_TypeDef STUSB1602_TypeC_FSM_State_Get(uint8_t Addr)
{
 8006a54:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_CONNECTION_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 8006a56:	ac01      	add	r4, sp, #4
{
 8006a58:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 8006a5a:	2301      	movs	r3, #1
 8006a5c:	2211      	movs	r2, #17
 8006a5e:	0020      	movs	r0, r4
 8006a60:	f7ff ff62 	bl	8006928 <STUSB1602_ReadReg>

    return (TypeC_FSM_State_TypeDef)(reg.b.TYPEC_FSM_STATE);
 8006a64:	7820      	ldrb	r0, [r4, #0]
 8006a66:	06c0      	lsls	r0, r0, #27
 8006a68:	0ec0      	lsrs	r0, r0, #27
}
 8006a6a:	bd16      	pop	{r1, r2, r4, pc}

08006a6c <STUSB1602_Hard_Fault_Trans_Status_Get>:
  * @brief STUSB1602 checks the entire HW_FAULT_STATUS_TRANS reg (bit7 0x12 -- RC)
  * @param Addr Address of the used port
  * @retval     STUSB1602_HW_FAULT_STATUS_TRANS_RegTypeDef
  */
STUSB1602_HW_FAULT_STATUS_TRANS_RegTypeDef STUSB1602_Hard_Fault_Trans_Status_Get(uint8_t Addr)
{
 8006a6c:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_HW_FAULT_STATUS_TRANS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_HW_FAULT_STATUS_TRANS_REG, 1); 
 8006a6e:	ac01      	add	r4, sp, #4
{
 8006a70:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_HW_FAULT_STATUS_TRANS_REG, 1); 
 8006a72:	2301      	movs	r3, #1
 8006a74:	2212      	movs	r2, #18
 8006a76:	0020      	movs	r0, r4
 8006a78:	f7ff ff56 	bl	8006928 <STUSB1602_ReadReg>

    return (reg);
 8006a7c:	7820      	ldrb	r0, [r4, #0]
}  
 8006a7e:	bd16      	pop	{r1, r2, r4, pc}

08006a80 <STUSB1602_Current_Advertised_Set>:
  * @param Addr I2C address of port controller device
  * @param curr_cap Current Capability Advertised  of the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_Current_Advertised_Set(uint8_t Addr, Current_Capability_Advertised_TypeDef curr_cap)
{
 8006a80:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006a82:	ac01      	add	r4, sp, #4
{
 8006a84:	0005      	movs	r5, r0
 8006a86:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006a88:	2301      	movs	r3, #1
 8006a8a:	0001      	movs	r1, r0
 8006a8c:	2218      	movs	r2, #24
 8006a8e:	0020      	movs	r0, r4
 8006a90:	f7ff ff4a 	bl	8006928 <STUSB1602_ReadReg>
    
    reg.b.CC_CURRENT_ADVERTISED = curr_cap;
 8006a94:	233f      	movs	r3, #63	; 0x3f
 8006a96:	7821      	ldrb	r1, [r4, #0]
 8006a98:	01b6      	lsls	r6, r6, #6
 8006a9a:	4019      	ands	r1, r3
 8006a9c:	4331      	orrs	r1, r6
 8006a9e:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006aa0:	3b3e      	subs	r3, #62	; 0x3e
 8006aa2:	0029      	movs	r1, r5
 8006aa4:	2218      	movs	r2, #24
 8006aa6:	0020      	movs	r0, r4
 8006aa8:	f7ff ff4e 	bl	8006948 <STUSB1602_WriteReg>
       
    return status;
}
 8006aac:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006aae <STUSB1602_SNK_Disconnect_Mode_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st SNK_DISCONNECT_MODE to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_SNK_Disconnect_Mode_Status_Set(uint8_t Addr, SNK_Disconnect_Mode_TypeDef st)
{
 8006aae:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006ab0:	ac01      	add	r4, sp, #4
{
 8006ab2:	0005      	movs	r5, r0
 8006ab4:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006ab6:	2301      	movs	r3, #1
 8006ab8:	0001      	movs	r1, r0
 8006aba:	2218      	movs	r2, #24
 8006abc:	0020      	movs	r0, r4
 8006abe:	f7ff ff33 	bl	8006928 <STUSB1602_ReadReg>

    reg.b.SNK_DISCONNECT_MODE = st;
 8006ac2:	2301      	movs	r3, #1
 8006ac4:	2220      	movs	r2, #32
 8006ac6:	7821      	ldrb	r1, [r4, #0]
 8006ac8:	401e      	ands	r6, r3
 8006aca:	0176      	lsls	r6, r6, #5
 8006acc:	4391      	bics	r1, r2
 8006ace:	4331      	orrs	r1, r6
 8006ad0:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006ad2:	3a08      	subs	r2, #8
 8006ad4:	0029      	movs	r1, r5
 8006ad6:	0020      	movs	r0, r4
 8006ad8:	f7ff ff36 	bl	8006948 <STUSB1602_WriteReg>

    return status;
}
 8006adc:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006ade <STUSB1602_VCONN_Discharge_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st VCONN_Discharge_Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Discharge_Status_Set(uint8_t Addr, VCONN_Discharge_Status_TypeDef st)
{
 8006ade:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006ae0:	ac01      	add	r4, sp, #4
{
 8006ae2:	0005      	movs	r5, r0
 8006ae4:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006ae6:	2301      	movs	r3, #1
 8006ae8:	0001      	movs	r1, r0
 8006aea:	2218      	movs	r2, #24
 8006aec:	0020      	movs	r0, r4
 8006aee:	f7ff ff1b 	bl	8006928 <STUSB1602_ReadReg>
    
    reg.b.CC_VCONN_DISCHARGE_EN = st;
 8006af2:	2301      	movs	r3, #1
 8006af4:	2210      	movs	r2, #16
 8006af6:	7821      	ldrb	r1, [r4, #0]
 8006af8:	401e      	ands	r6, r3
 8006afa:	0136      	lsls	r6, r6, #4
 8006afc:	4391      	bics	r1, r2
 8006afe:	4331      	orrs	r1, r6
 8006b00:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006b02:	3208      	adds	r2, #8
 8006b04:	0029      	movs	r1, r5
 8006b06:	0020      	movs	r0, r4
 8006b08:	f7ff ff1e 	bl	8006948 <STUSB1602_WriteReg>
       
    return status;
}
 8006b0c:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006b0e <STUSB1602_Data_Role_Swap_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */ 
STUSB1602_StatusTypeDef STUSB1602_Data_Role_Swap_Status_Set(uint8_t Addr, Data_Role_Swap_TypeDef st)
{
 8006b0e:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 8006b10:	ac01      	add	r4, sp, #4
{
 8006b12:	0005      	movs	r5, r0
 8006b14:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 8006b16:	2301      	movs	r3, #1
 8006b18:	0001      	movs	r1, r0
 8006b1a:	2218      	movs	r2, #24
 8006b1c:	0020      	movs	r0, r4
 8006b1e:	f7ff ff03 	bl	8006928 <STUSB1602_ReadReg>
    
    reg.b.DR_SWAP_EN = st;
 8006b22:	2301      	movs	r3, #1
 8006b24:	2208      	movs	r2, #8
 8006b26:	7821      	ldrb	r1, [r4, #0]
 8006b28:	401e      	ands	r6, r3
 8006b2a:	00f6      	lsls	r6, r6, #3
 8006b2c:	4391      	bics	r1, r2
 8006b2e:	4331      	orrs	r1, r6
 8006b30:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006b32:	3210      	adds	r2, #16
 8006b34:	0029      	movs	r1, r5
 8006b36:	0020      	movs	r0, r4
 8006b38:	f7ff ff06 	bl	8006948 <STUSB1602_WriteReg>
    
    return status;
}
 8006b3c:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006b3e <STUSB1602_Power_Role_Swap_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */ 
STUSB1602_StatusTypeDef STUSB1602_Power_Role_Swap_Status_Set(uint8_t Addr, Power_Role_Swap_TypeDef st)
{
 8006b3e:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 8006b40:	ac01      	add	r4, sp, #4
{
 8006b42:	0005      	movs	r5, r0
 8006b44:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 8006b46:	2301      	movs	r3, #1
 8006b48:	0001      	movs	r1, r0
 8006b4a:	2218      	movs	r2, #24
 8006b4c:	0020      	movs	r0, r4
 8006b4e:	f7ff feeb 	bl	8006928 <STUSB1602_ReadReg>
    
    reg.b.PR_SWAP_EN = st;
 8006b52:	2301      	movs	r3, #1
 8006b54:	2204      	movs	r2, #4
 8006b56:	7821      	ldrb	r1, [r4, #0]
 8006b58:	401e      	ands	r6, r3
 8006b5a:	00b6      	lsls	r6, r6, #2
 8006b5c:	4391      	bics	r1, r2
 8006b5e:	4331      	orrs	r1, r6
 8006b60:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006b62:	3214      	adds	r2, #20
 8006b64:	0029      	movs	r1, r5
 8006b66:	0020      	movs	r0, r4
 8006b68:	f7ff feee 	bl	8006948 <STUSB1602_WriteReg>
    
    return status;
}
 8006b6c:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006b6e <STUSB1602_VCONN_Supply_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st VCONN_Supply_Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Supply_Status_Set(uint8_t Addr, VCONN_Supply_Status_TypeDef st)
{
 8006b6e:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006b70:	ac01      	add	r4, sp, #4
{
 8006b72:	0005      	movs	r5, r0
 8006b74:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006b76:	2301      	movs	r3, #1
 8006b78:	0001      	movs	r1, r0
 8006b7a:	2218      	movs	r2, #24
 8006b7c:	0020      	movs	r0, r4
 8006b7e:	f7ff fed3 	bl	8006928 <STUSB1602_ReadReg>
    
    reg.b.CC_VCONN_SUPPLY_EN = st;
 8006b82:	2301      	movs	r3, #1
 8006b84:	7821      	ldrb	r1, [r4, #0]
 8006b86:	401e      	ands	r6, r3
 8006b88:	4399      	bics	r1, r3
 8006b8a:	4331      	orrs	r1, r6
 8006b8c:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006b8e:	2218      	movs	r2, #24
 8006b90:	0029      	movs	r1, r5
 8006b92:	0020      	movs	r0, r4
 8006b94:	f7ff fed8 	bl	8006948 <STUSB1602_WriteReg>
       
    return status;
}
 8006b98:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006b9a <STUSB1602_VCONN_Switch_Current_Limit_Set>:
  * @param Addr I2C address of port controller device
  * @param curr_lim Current limit value to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Switch_Current_Limit_Set(uint8_t Addr, VCONN_Switch_Current_Limit_TypeDef curr_lim)
{
 8006b9a:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_CC_VCONN_SWITCH_CTRL_RegTypeDef reg; 
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_VCONN_SWITCH_CTRL_REG, 1); 
 8006b9c:	ac01      	add	r4, sp, #4
{
 8006b9e:	0005      	movs	r5, r0
 8006ba0:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_VCONN_SWITCH_CTRL_REG, 1); 
 8006ba2:	2301      	movs	r3, #1
 8006ba4:	0001      	movs	r1, r0
 8006ba6:	221e      	movs	r2, #30
 8006ba8:	0020      	movs	r0, r4
 8006baa:	f7ff febd 	bl	8006928 <STUSB1602_ReadReg>
  
    reg.b.CC_VCONN_SWITCH_ILIM = curr_lim;
 8006bae:	230f      	movs	r3, #15
 8006bb0:	7821      	ldrb	r1, [r4, #0]
 8006bb2:	401e      	ands	r6, r3
 8006bb4:	4399      	bics	r1, r3
 8006bb6:	4331      	orrs	r1, r6
 8006bb8:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_VCONN_SWITCH_CTRL_REG, 1);
 8006bba:	3b0e      	subs	r3, #14
 8006bbc:	0029      	movs	r1, r5
 8006bbe:	221e      	movs	r2, #30
 8006bc0:	0020      	movs	r0, r4
 8006bc2:	f7ff fec1 	bl	8006948 <STUSB1602_WriteReg>

    return status;
}
 8006bc6:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006bc8 <STUSB1602_Type_C_Control_Set>:
  * @param Addr I2C address of port controller device
  * @param Ctrl Control to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_Type_C_Control_Set(uint8_t Addr, Type_C_CTRL_TypeDef Ctrl)
{
 8006bc8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_CC_MODE_CTRL_RegTypeDef reg; 
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_MODE_CTRL_REG, 1); 
 8006bca:	ac01      	add	r4, sp, #4
{
 8006bcc:	0005      	movs	r5, r0
 8006bce:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_MODE_CTRL_REG, 1); 
 8006bd0:	2301      	movs	r3, #1
 8006bd2:	0001      	movs	r1, r0
 8006bd4:	221f      	movs	r2, #31
 8006bd6:	0020      	movs	r0, r4
 8006bd8:	f7ff fea6 	bl	8006928 <STUSB1602_ReadReg>
  
    reg.b.TYPEC_CTRL = Ctrl;
 8006bdc:	230f      	movs	r3, #15
 8006bde:	7821      	ldrb	r1, [r4, #0]
 8006be0:	0136      	lsls	r6, r6, #4
 8006be2:	4019      	ands	r1, r3
 8006be4:	4331      	orrs	r1, r6
 8006be6:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_MODE_CTRL_REG, 1);
 8006be8:	3b0e      	subs	r3, #14
 8006bea:	0029      	movs	r1, r5
 8006bec:	221f      	movs	r2, #31
 8006bee:	0020      	movs	r0, r4
 8006bf0:	f7ff feaa 	bl	8006948 <STUSB1602_WriteReg>

    return status;
}
 8006bf4:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006bf6 <STUSB1602_VCONN_Monitor_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st Power mode to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Monitor_Status_Set(uint8_t Addr, VCONN_Monitoring_TypeDef st)
{
 8006bf6:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VCONN_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006bf8:	ac01      	add	r4, sp, #4
{
 8006bfa:	0005      	movs	r5, r0
 8006bfc:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006bfe:	2301      	movs	r3, #1
 8006c00:	0001      	movs	r1, r0
 8006c02:	2220      	movs	r2, #32
 8006c04:	0020      	movs	r0, r4
 8006c06:	f7ff fe8f 	bl	8006928 <STUSB1602_ReadReg>
  
    reg.b.VCONN_MONITORING_EN = st;
 8006c0a:	237f      	movs	r3, #127	; 0x7f
 8006c0c:	7821      	ldrb	r1, [r4, #0]
 8006c0e:	01f6      	lsls	r6, r6, #7
 8006c10:	4019      	ands	r1, r3
 8006c12:	4331      	orrs	r1, r6
 8006c14:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1);
 8006c16:	3b7e      	subs	r3, #126	; 0x7e
 8006c18:	0029      	movs	r1, r5
 8006c1a:	2220      	movs	r2, #32
 8006c1c:	0020      	movs	r0, r4
 8006c1e:	f7ff fe93 	bl	8006948 <STUSB1602_WriteReg>

    return status;
}
 8006c22:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006c24 <STUSB1602_VCONN_UVLO_Thresh_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param thr Power mode to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_UVLO_Thresh_Status_Set(uint8_t Addr, VCONN_UVLO_Threshold_TypeDef thr)
{
 8006c24:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VCONN_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006c26:	ac01      	add	r4, sp, #4
{
 8006c28:	0005      	movs	r5, r0
 8006c2a:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006c2c:	2301      	movs	r3, #1
 8006c2e:	0001      	movs	r1, r0
 8006c30:	2220      	movs	r2, #32
 8006c32:	0020      	movs	r0, r4
 8006c34:	f7ff fe78 	bl	8006928 <STUSB1602_ReadReg>
  
    reg.b.VCONN_UVLO_THRESHOLD = thr;
 8006c38:	2301      	movs	r3, #1
 8006c3a:	2240      	movs	r2, #64	; 0x40
 8006c3c:	7821      	ldrb	r1, [r4, #0]
 8006c3e:	401e      	ands	r6, r3
 8006c40:	01b6      	lsls	r6, r6, #6
 8006c42:	4391      	bics	r1, r2
 8006c44:	4331      	orrs	r1, r6
 8006c46:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1);
 8006c48:	3a20      	subs	r2, #32
 8006c4a:	0029      	movs	r1, r5
 8006c4c:	0020      	movs	r0, r4
 8006c4e:	f7ff fe7b 	bl	8006948 <STUSB1602_WriteReg>

    return status;
}
 8006c52:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006c54 <STUSB1602_VBUS_Select_Status_Get>:
  * @brief STUSB1602 checks the VBUS_SELECT (bit7:0 0x21 -- R/W)
  * @param Addr I2C address of port controller device
  * @retval uint16_t 
  */   
uint16_t STUSB1602_VBUS_Select_Status_Get(uint8_t Addr)
{
 8006c54:	b513      	push	{r0, r1, r4, lr}
    uint8_t reg; /* first default value = 50 */
    uint16_t DAC_mV=0;
#ifndef __VVAR     
    STUSB1602_ReadReg(&reg, Addr, STUSB1602_VBUS_SELECT_REG, 1);
 8006c56:	466b      	mov	r3, sp
 8006c58:	1ddc      	adds	r4, r3, #7
{
 8006c5a:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg, Addr, STUSB1602_VBUS_SELECT_REG, 1);
 8006c5c:	2301      	movs	r3, #1
 8006c5e:	2221      	movs	r2, #33	; 0x21
 8006c60:	0020      	movs	r0, r4
 8006c62:	f7ff fe61 	bl	8006928 <STUSB1602_ReadReg>
#else
    STUSB1602_ReadReg_P1(&reg, Addr+1, STUSB1602_VBUS_SELECT_REG, 1);
#endif
    DAC_mV=(uint16_t)(reg*100);
 8006c66:	2364      	movs	r3, #100	; 0x64
 8006c68:	7820      	ldrb	r0, [r4, #0]
 8006c6a:	4358      	muls	r0, r3
    
    return DAC_mV;
}
 8006c6c:	bd16      	pop	{r1, r2, r4, pc}
	...

08006c70 <STUSB1602_VBUS_Select_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param mV The value (expressed in mV) to set the internal reference DAC
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_Select_Status_Set(uint8_t Addr, uint16_t mV)
{
 8006c70:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8006c72:	0004      	movs	r4, r0
 8006c74:	0008      	movs	r0, r1
    
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    uint8_t reg; /* first default value = 50 */     
    
    reg =(uint8_t)(mV/100);
 8006c76:	2164      	movs	r1, #100	; 0x64
 8006c78:	f7fe fea6 	bl	80059c8 <__udivsi3>
 8006c7c:	466b      	mov	r3, sp
    real_val[k] = reg;
 8006c7e:	4907      	ldr	r1, [pc, #28]	; (8006c9c <STUSB1602_VBUS_Select_Status_Set+0x2c>)
    reg =(uint8_t)(mV/100);
 8006c80:	b2c2      	uxtb	r2, r0
    real_val[k] = reg;
 8006c82:	4d07      	ldr	r5, [pc, #28]	; (8006ca0 <STUSB1602_VBUS_Select_Status_Set+0x30>)
    reg =(uint8_t)(mV/100);
 8006c84:	1dd8      	adds	r0, r3, #7
    real_val[k] = reg;
 8006c86:	780b      	ldrb	r3, [r1, #0]
    reg =(uint8_t)(mV/100);
 8006c88:	7002      	strb	r2, [r0, #0]
    real_val[k] = reg;
 8006c8a:	54ea      	strb	r2, [r5, r3]
      
    k++;
 8006c8c:	3301      	adds	r3, #1
 8006c8e:	700b      	strb	r3, [r1, #0]
#ifdef __VVAR
    STUSB1602_WriteReg_P1(&reg, Addr+1, STUSB1602_VBUS_SELECT_REG, 1);
#endif
    status = STUSB1602_WriteReg(&reg, Addr, STUSB1602_VBUS_SELECT_REG, 1);
 8006c90:	2221      	movs	r2, #33	; 0x21
 8006c92:	2301      	movs	r3, #1
 8006c94:	0021      	movs	r1, r4
 8006c96:	f7ff fe57 	bl	8006948 <STUSB1602_WriteReg>
             
    return status;
}
 8006c9a:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8006c9c:	20001a9c 	.word	0x20001a9c
 8006ca0:	20001a9d 	.word	0x20001a9d

08006ca4 <STUSB1602_VBUS_VShift_High_Set>:
  * @param Addr I2C address of port controller device
  * @param Set The VShift_High value >= 5% (expressed in %) to set the high threshold value  
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_VShift_High_Set(uint8_t Addr, uint8_t Set)
{
 8006ca4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VBUS_RANGE_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006ca6:	ac01      	add	r4, sp, #4
{
 8006ca8:	0005      	movs	r5, r0
 8006caa:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006cac:	2301      	movs	r3, #1
 8006cae:	0001      	movs	r1, r0
 8006cb0:	2222      	movs	r2, #34	; 0x22
 8006cb2:	0020      	movs	r0, r4
 8006cb4:	f7ff fe38 	bl	8006928 <STUSB1602_ReadReg>
  
    reg.b.VBUS_VSHIFT_HIGH = (Set - 5);
 8006cb8:	230f      	movs	r3, #15
 8006cba:	7821      	ldrb	r1, [r4, #0]
 8006cbc:	3e05      	subs	r6, #5
 8006cbe:	0136      	lsls	r6, r6, #4
 8006cc0:	4019      	ands	r1, r3
 8006cc2:	4331      	orrs	r1, r6
 8006cc4:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1);
 8006cc6:	3b0e      	subs	r3, #14
 8006cc8:	0029      	movs	r1, r5
 8006cca:	2222      	movs	r2, #34	; 0x22
 8006ccc:	0020      	movs	r0, r4
 8006cce:	f7ff fe3b 	bl	8006948 <STUSB1602_WriteReg>
        
    return status;
}
 8006cd2:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006cd4 <STUSB1602_VBUS_VShift_Low_Set>:
  * @param Addr I2C address of port controller device
  * @param Set The VShift_Low value <=5% (expressed in %) to set the low threshold value
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_VShift_Low_Set(uint8_t Addr, int8_t Set)
{
 8006cd4:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8006cd6:	000c      	movs	r4, r1
    Set = (Set>0) ? -Set : Set;
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VBUS_RANGE_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006cd8:	ad01      	add	r5, sp, #4
{
 8006cda:	0006      	movs	r6, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006cdc:	0001      	movs	r1, r0
 8006cde:	2301      	movs	r3, #1
 8006ce0:	0028      	movs	r0, r5
 8006ce2:	2222      	movs	r2, #34	; 0x22
 8006ce4:	f7ff fe20 	bl	8006928 <STUSB1602_ReadReg>
  
    reg.b.VBUS_VSHIFT_LOW = (-Set - 5);
 8006ce8:	220f      	movs	r2, #15
    Set = (Set>0) ? -Set : Set;
 8006cea:	17e3      	asrs	r3, r4, #31
 8006cec:	18e4      	adds	r4, r4, r3
 8006cee:	405c      	eors	r4, r3
    reg.b.VBUS_VSHIFT_LOW = (-Set - 5);
 8006cf0:	782b      	ldrb	r3, [r5, #0]
 8006cf2:	3c05      	subs	r4, #5
 8006cf4:	4393      	bics	r3, r2
 8006cf6:	4014      	ands	r4, r2
 8006cf8:	431c      	orrs	r4, r3
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1);
 8006cfa:	0031      	movs	r1, r6
 8006cfc:	0028      	movs	r0, r5
 8006cfe:	2301      	movs	r3, #1
 8006d00:	3213      	adds	r2, #19
    reg.b.VBUS_VSHIFT_LOW = (-Set - 5);
 8006d02:	702c      	strb	r4, [r5, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1);
 8006d04:	f7ff fe20 	bl	8006948 <STUSB1602_WriteReg>
        
    return status;
}
 8006d08:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006d0a <STUSB1602_SW_RESET_Set>:
  * @param Addr I2C address of port controller device
  * @param Rst Enable or Disable of the SW RST function
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_SW_RESET_Set(uint8_t Addr, SW_RESET_TypeDef Rst)
{  
 8006d0a:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
    STUSB1602_RESET_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_RESET_CTRL_REG, 1); 
 8006d0c:	ac01      	add	r4, sp, #4
{  
 8006d0e:	0005      	movs	r5, r0
 8006d10:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_RESET_CTRL_REG, 1); 
 8006d12:	2301      	movs	r3, #1
 8006d14:	0001      	movs	r1, r0
 8006d16:	2223      	movs	r2, #35	; 0x23
 8006d18:	0020      	movs	r0, r4
 8006d1a:	f7ff fe05 	bl	8006928 <STUSB1602_ReadReg>
  
    reg.b.SW_RESET_EN = Rst;
 8006d1e:	2301      	movs	r3, #1
 8006d20:	7821      	ldrb	r1, [r4, #0]
 8006d22:	401e      	ands	r6, r3
 8006d24:	4399      	bics	r1, r3
 8006d26:	4331      	orrs	r1, r6
 8006d28:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_RESET_CTRL_REG, 1);
 8006d2a:	2223      	movs	r2, #35	; 0x23
 8006d2c:	0029      	movs	r1, r5
 8006d2e:	0020      	movs	r0, r4
 8006d30:	f7ff fe0a 	bl	8006948 <STUSB1602_WriteReg>
             
    return status;
}
 8006d34:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006d36 <STUSB1602_Pwr_Acc_Detect_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_Pwr_Acc_Detect_Set(uint8_t Addr, Pwr_Acc_Detect_TypeDef st)
{    
 8006d36:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
   STUSB1602_CC_POWERED_ACCESSORY_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_POWERED_ACCESSORY_CTRL_REG, 1);
 8006d38:	ac01      	add	r4, sp, #4
{    
 8006d3a:	0005      	movs	r5, r0
 8006d3c:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_POWERED_ACCESSORY_CTRL_REG, 1);
 8006d3e:	2301      	movs	r3, #1
 8006d40:	0001      	movs	r1, r0
 8006d42:	2224      	movs	r2, #36	; 0x24
 8006d44:	0020      	movs	r0, r4
 8006d46:	f7ff fdef 	bl	8006928 <STUSB1602_ReadReg>
  
   reg.b.PWR_ACC_DETECT_EN = st;    
 8006d4a:	2301      	movs	r3, #1
 8006d4c:	7821      	ldrb	r1, [r4, #0]
 8006d4e:	401e      	ands	r6, r3
 8006d50:	4399      	bics	r1, r3
 8006d52:	4331      	orrs	r1, r6
 8006d54:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_POWERED_ACCESSORY_CTRL_REG, 1);
 8006d56:	2224      	movs	r2, #36	; 0x24
 8006d58:	0029      	movs	r1, r5
 8006d5a:	0020      	movs	r0, r4
 8006d5c:	f7ff fdf4 	bl	8006948 <STUSB1602_WriteReg>
             
   return status;
}
 8006d60:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006d62 <STUSB1602_VBUS_Discharge_Time_to_0V_Set>:
  * @param Addr I2C address of port controller device
  * @param tim  VBUS discharge time in msec
  * @retval STUSB1602_StatusTypeDef
  */
STUSB1602_StatusTypeDef STUSB1602_VBUS_Discharge_Time_to_0V_Set(uint8_t Addr, uint16_t tim)
{
 8006d62:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8006d64:	000e      	movs	r6, r1
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_DISCHARGE_TIME_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006d66:	ac01      	add	r4, sp, #4
{
 8006d68:	0005      	movs	r5, r0
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006d6a:	2301      	movs	r3, #1
 8006d6c:	2225      	movs	r2, #37	; 0x25
 8006d6e:	0001      	movs	r1, r0
 8006d70:	0020      	movs	r0, r4
 8006d72:	f7ff fdd9 	bl	8006928 <STUSB1602_ReadReg>
   
   reg.b.VBUS_DISCHARGE_TIME_TO_0V = (uint8_t)(tim/84);
 8006d76:	0030      	movs	r0, r6
 8006d78:	2154      	movs	r1, #84	; 0x54
 8006d7a:	f7fe fe25 	bl	80059c8 <__udivsi3>
 8006d7e:	220f      	movs	r2, #15
 8006d80:	0103      	lsls	r3, r0, #4
 8006d82:	7820      	ldrb	r0, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1); 
 8006d84:	0029      	movs	r1, r5
   reg.b.VBUS_DISCHARGE_TIME_TO_0V = (uint8_t)(tim/84);
 8006d86:	4010      	ands	r0, r2
 8006d88:	4318      	orrs	r0, r3
 8006d8a:	7020      	strb	r0, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1); 
 8006d8c:	2301      	movs	r3, #1
 8006d8e:	3216      	adds	r2, #22
 8006d90:	0020      	movs	r0, r4
 8006d92:	f7ff fdd9 	bl	8006948 <STUSB1602_WriteReg>
    
   return status;
}
 8006d96:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006d98 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>:
  * @param Addr I2C address of port controller device
  * @param tim VBUS discharge time in msec
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_Discharge_Time_to_PDO_Set(uint8_t Addr, uint16_t tim)
{
 8006d98:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8006d9a:	000e      	movs	r6, r1
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_DISCHARGE_TIME_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006d9c:	ac01      	add	r4, sp, #4
{
 8006d9e:	0005      	movs	r5, r0
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006da0:	2301      	movs	r3, #1
 8006da2:	2225      	movs	r2, #37	; 0x25
 8006da4:	0001      	movs	r1, r0
 8006da6:	0020      	movs	r0, r4
 8006da8:	f7ff fdbe 	bl	8006928 <STUSB1602_ReadReg>
   
   reg.b.VBUS_DISCHARGE_TIME_TO_PDO = (uint8_t)(tim/20);
 8006dac:	0030      	movs	r0, r6
 8006dae:	2114      	movs	r1, #20
 8006db0:	f7fe fe0a 	bl	80059c8 <__udivsi3>
 8006db4:	220f      	movs	r2, #15
 8006db6:	0003      	movs	r3, r0
 8006db8:	7820      	ldrb	r0, [r4, #0]
 8006dba:	4013      	ands	r3, r2
 8006dbc:	4390      	bics	r0, r2
 8006dbe:	4318      	orrs	r0, r3
 8006dc0:	7020      	strb	r0, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1); 
 8006dc2:	0029      	movs	r1, r5
 8006dc4:	2301      	movs	r3, #1
 8006dc6:	3216      	adds	r2, #22
 8006dc8:	0020      	movs	r0, r4
 8006dca:	f7ff fdbd 	bl	8006948 <STUSB1602_WriteReg>
    
   return status;
}
 8006dce:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006dd0 <STUSB1602_VBUS_Discharge_State_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set
  * @retval STUSB1602_StatusTypeDef 
  */
STUSB1602_StatusTypeDef STUSB1602_VBUS_Discharge_State_Set(uint8_t Addr, VBUS_Discharge_State_TypeDef st)
{    
 8006dd0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_DISCHARGE_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1); 
 8006dd2:	ac01      	add	r4, sp, #4
{    
 8006dd4:	0005      	movs	r5, r0
 8006dd6:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1); 
 8006dd8:	2301      	movs	r3, #1
 8006dda:	0001      	movs	r1, r0
 8006ddc:	2226      	movs	r2, #38	; 0x26
 8006dde:	0020      	movs	r0, r4
 8006de0:	f7ff fda2 	bl	8006928 <STUSB1602_ReadReg>
   
   reg.b.VBUS_DISCHARGE_EN = st;
 8006de4:	237f      	movs	r3, #127	; 0x7f
 8006de6:	7821      	ldrb	r1, [r4, #0]
 8006de8:	01f6      	lsls	r6, r6, #7
 8006dea:	4019      	ands	r1, r3
 8006dec:	4331      	orrs	r1, r6
 8006dee:	7021      	strb	r1, [r4, #0]
#ifdef __VVAR
   STUSB1602_WriteReg_P1(&reg.d8, Addr+1, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1);
#endif
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1);
 8006df0:	3b7e      	subs	r3, #126	; 0x7e
 8006df2:	0029      	movs	r1, r5
 8006df4:	2226      	movs	r2, #38	; 0x26
 8006df6:	0020      	movs	r0, r4
 8006df8:	f7ff fda6 	bl	8006948 <STUSB1602_WriteReg>
   
   return status;   
}
 8006dfc:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006dfe <STUSB1602_Power_Mode_Set>:
  * @param Addr I2C address of port controller device
  * @param Pwr Power mode to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_Power_Mode_Set(uint8_t Addr, Power_Mode_TypeDef Pwr)
{
 8006dfe:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_MODE_CTRL_RegTypeDef reg; 
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MODE_CTRL_REG, 1); 
 8006e00:	ac01      	add	r4, sp, #4
{
 8006e02:	0005      	movs	r5, r0
 8006e04:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MODE_CTRL_REG, 1); 
 8006e06:	2301      	movs	r3, #1
 8006e08:	0001      	movs	r1, r0
 8006e0a:	2228      	movs	r2, #40	; 0x28
 8006e0c:	0020      	movs	r0, r4
 8006e0e:	f7ff fd8b 	bl	8006928 <STUSB1602_ReadReg>
  
    reg.b.POWER_MODE = Pwr;
 8006e12:	2307      	movs	r3, #7
 8006e14:	7821      	ldrb	r1, [r4, #0]
 8006e16:	401e      	ands	r6, r3
 8006e18:	4399      	bics	r1, r3
 8006e1a:	4331      	orrs	r1, r6
 8006e1c:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_MODE_CTRL_REG, 1);
 8006e1e:	3b06      	subs	r3, #6
 8006e20:	0029      	movs	r1, r5
 8006e22:	2228      	movs	r2, #40	; 0x28
 8006e24:	0020      	movs	r0, r4
 8006e26:	f7ff fd8f 	bl	8006948 <STUSB1602_WriteReg>
             
    return status;
}
 8006e2a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006e2c <STUSB1602_NVM_OK_Get>:
  * @brief It checks if NVM is loaded correctly (bit0:1 0x2F -- R)
  * @param Addr I2C address of port controller device
  * @retval NVM_OK_TypeDef 
  */  
NVM_OK_TypeDef STUSB1602_NVM_OK_Get(uint8_t Addr)
{
 8006e2c:	b513      	push	{r0, r1, r4, lr}
   STUSB1602_DEVICE_CUT_RegTypeDef reg;
        
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006e2e:	ac01      	add	r4, sp, #4
{
 8006e30:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006e32:	2301      	movs	r3, #1
 8006e34:	222f      	movs	r2, #47	; 0x2f
 8006e36:	0020      	movs	r0, r4
 8006e38:	f7ff fd76 	bl	8006928 <STUSB1602_ReadReg>
      
    return (NVM_OK_TypeDef)(reg.b.Reserved_0_2);
 8006e3c:	7820      	ldrb	r0, [r4, #0]
 8006e3e:	0780      	lsls	r0, r0, #30
 8006e40:	0f80      	lsrs	r0, r0, #30
}
 8006e42:	bd16      	pop	{r1, r2, r4, pc}

08006e44 <STUSB1602_DEVICE_CUT_Get>:
  * @brief It gets the cut number (bit2:4 0x2F -- R)
  * @param Addr I2C address of port controller device
  * @retval DEVICE_CUT_TypeDef 
  */ 
DEVICE_CUT_TypeDef STUSB1602_DEVICE_CUT_Get(uint8_t Addr)
{
 8006e44:	b513      	push	{r0, r1, r4, lr}
   STUSB1602_DEVICE_CUT_RegTypeDef reg;
        
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006e46:	ac01      	add	r4, sp, #4
{
 8006e48:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006e4a:	2301      	movs	r3, #1
 8006e4c:	222f      	movs	r2, #47	; 0x2f
 8006e4e:	0020      	movs	r0, r4
 8006e50:	f7ff fd6a 	bl	8006928 <STUSB1602_ReadReg>
      
    return (DEVICE_CUT_TypeDef)(reg.b.DEVICE_CUT);
 8006e54:	7820      	ldrb	r0, [r4, #0]
 8006e56:	06c0      	lsls	r0, r0, #27
 8006e58:	0f40      	lsrs	r0, r0, #29
}
 8006e5a:	bd16      	pop	{r1, r2, r4, pc}

08006e5c <STUSB1602_VDD_OVLO_Threshold_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VDD_OVLO_Threshold_Set(uint8_t Addr, VDD_OVLO_Threshold_TypeDef st)
{      
 8006e5c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006e5e:	ac01      	add	r4, sp, #4
{      
 8006e60:	0005      	movs	r5, r0
 8006e62:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006e64:	2301      	movs	r3, #1
 8006e66:	0001      	movs	r1, r0
 8006e68:	222e      	movs	r2, #46	; 0x2e
 8006e6a:	0020      	movs	r0, r4
 8006e6c:	f7ff fd5c 	bl	8006928 <STUSB1602_ReadReg>
   
   reg.b.VDD_OVLO_DISABLE = st;
 8006e70:	2301      	movs	r3, #1
 8006e72:	2240      	movs	r2, #64	; 0x40
 8006e74:	7821      	ldrb	r1, [r4, #0]
 8006e76:	401e      	ands	r6, r3
 8006e78:	01b6      	lsls	r6, r6, #6
 8006e7a:	4391      	bics	r1, r2
 8006e7c:	4331      	orrs	r1, r6
 8006e7e:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006e80:	3a12      	subs	r2, #18
 8006e82:	0029      	movs	r1, r5
 8006e84:	0020      	movs	r0, r4
 8006e86:	f7ff fd5f 	bl	8006948 <STUSB1602_WriteReg>
     
   return status;  
}
 8006e8a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006e8c <STUSB1602_VBUS_Range_State_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_Range_State_Set(uint8_t Addr, VBUS_Range_State_TypeDef st)
{      
 8006e8c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006e8e:	ac01      	add	r4, sp, #4
{      
 8006e90:	0005      	movs	r5, r0
 8006e92:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006e94:	2301      	movs	r3, #1
 8006e96:	0001      	movs	r1, r0
 8006e98:	222e      	movs	r2, #46	; 0x2e
 8006e9a:	0020      	movs	r0, r4
 8006e9c:	f7ff fd44 	bl	8006928 <STUSB1602_ReadReg>
   
   reg.b.VBUS_RANGE_DISABLE = st;
 8006ea0:	2301      	movs	r3, #1
 8006ea2:	2210      	movs	r2, #16
 8006ea4:	7821      	ldrb	r1, [r4, #0]
 8006ea6:	401e      	ands	r6, r3
 8006ea8:	0136      	lsls	r6, r6, #4
 8006eaa:	4391      	bics	r1, r2
 8006eac:	4331      	orrs	r1, r6
 8006eae:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006eb0:	321e      	adds	r2, #30
 8006eb2:	0029      	movs	r1, r5
 8006eb4:	0020      	movs	r0, r4
 8006eb6:	f7ff fd47 	bl	8006948 <STUSB1602_WriteReg>
     
   return status;  
}
 8006eba:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006ebc <STUSB1602_VBUS_VSAFE0V_Threshold_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_VSAFE0V_Threshold_Set(uint8_t Addr, VBUS_VSAFE0V_Threshold_TypeDef st)
{      
 8006ebc:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006ebe:	ac01      	add	r4, sp, #4
{      
 8006ec0:	0005      	movs	r5, r0
 8006ec2:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006ec4:	2301      	movs	r3, #1
 8006ec6:	0001      	movs	r1, r0
 8006ec8:	222e      	movs	r2, #46	; 0x2e
 8006eca:	0020      	movs	r0, r4
 8006ecc:	f7ff fd2c 	bl	8006928 <STUSB1602_ReadReg>
   
   reg.b.VBUS_VSAFE0V_THRESHOLD = st;
 8006ed0:	2103      	movs	r1, #3
 8006ed2:	2306      	movs	r3, #6
 8006ed4:	400e      	ands	r6, r1
 8006ed6:	7821      	ldrb	r1, [r4, #0]
 8006ed8:	0076      	lsls	r6, r6, #1
 8006eda:	4399      	bics	r1, r3
 8006edc:	4331      	orrs	r1, r6
 8006ede:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006ee0:	3b05      	subs	r3, #5
 8006ee2:	0029      	movs	r1, r5
 8006ee4:	222e      	movs	r2, #46	; 0x2e
 8006ee6:	0020      	movs	r0, r4
 8006ee8:	f7ff fd2e 	bl	8006948 <STUSB1602_WriteReg>
     
   return status;  
}
 8006eec:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006eee <STUSB1602_VDD_UVLO_Threshold_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VDD_UVLO_Threshold_Set(uint8_t Addr, VDD_UVLO_Threshold_TypeDef st)
{      
 8006eee:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006ef0:	ac01      	add	r4, sp, #4
{      
 8006ef2:	0005      	movs	r5, r0
 8006ef4:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006ef6:	2301      	movs	r3, #1
 8006ef8:	0001      	movs	r1, r0
 8006efa:	222e      	movs	r2, #46	; 0x2e
 8006efc:	0020      	movs	r0, r4
 8006efe:	f7ff fd13 	bl	8006928 <STUSB1602_ReadReg>
   
   reg.b.VDD_UVLO_DISABLE = st;
 8006f02:	2301      	movs	r3, #1
 8006f04:	7821      	ldrb	r1, [r4, #0]
 8006f06:	401e      	ands	r6, r3
 8006f08:	4399      	bics	r1, r3
 8006f0a:	4331      	orrs	r1, r6
 8006f0c:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006f0e:	222e      	movs	r2, #46	; 0x2e
 8006f10:	0029      	movs	r1, r5
 8006f12:	0020      	movs	r0, r4
 8006f14:	f7ff fd18 	bl	8006948 <STUSB1602_WriteReg>
     
   return status;  
}
 8006f18:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006f1a <STUSB1602_Type_C_Command>:
  * @param Addr I2C address of port controller device
  * @param Ctrl Control to be set
  * @retval STUSB1602_StatusTypeDef
  */
STUSB1602_StatusTypeDef STUSB1602_Type_C_Command(uint8_t Addr, Type_C_CTRL_TypeDef Ctrl)
{
 8006f1a:	b510      	push	{r4, lr}
    STUSB1602_StatusTypeDef ret = STUSB1602_Type_C_Control_Set(Addr, Ctrl); /* register */
 8006f1c:	f7ff fe54 	bl	8006bc8 <STUSB1602_Type_C_Control_Set>
    return timeout > 0 ? ret : STUSB1602_TIMEOUT;
#else
    return ret;
#endif /* _DEBUG_ACK_ENABLE */

}
 8006f20:	bd10      	pop	{r4, pc}
	...

08006f24 <USBPD_BSP_LED_Set>:
  * @param  Value: value to set the led on or off.
  * @retval None
  */
  void USBPD_BSP_LED_Set(USBPD_BSP_Led_TypeDef Led, uint8_t Value)
  {
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, Value ? GPIO_PIN_RESET : GPIO_PIN_SET);
 8006f24:	230c      	movs	r3, #12
 8006f26:	424a      	negs	r2, r1
 8006f28:	414a      	adcs	r2, r1
 8006f2a:	4358      	muls	r0, r3
  {
 8006f2c:	b510      	push	{r4, lr}
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, Value ? GPIO_PIN_RESET : GPIO_PIN_SET);
 8006f2e:	4c04      	ldr	r4, [pc, #16]	; (8006f40 <USBPD_BSP_LED_Set+0x1c>)
 8006f30:	b2d2      	uxtb	r2, r2
 8006f32:	1823      	adds	r3, r4, r0
 8006f34:	8899      	ldrh	r1, [r3, #4]
 8006f36:	5900      	ldr	r0, [r0, r4]
 8006f38:	f000 fdf0 	bl	8007b1c <HAL_GPIO_WritePin>
  }
 8006f3c:	bd10      	pop	{r4, pc}
 8006f3e:	46c0      	nop			; (mov r8, r8)
 8006f40:	20000000 	.word	0x20000000

08006f44 <USBPD_BSP_LED_On>:
  * @retval None
  */  
  
  void USBPD_BSP_LED_On(USBPD_BSP_Led_TypeDef Led)
  {
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_RESET);
 8006f44:	230c      	movs	r3, #12
 8006f46:	4358      	muls	r0, r3
  {
 8006f48:	b510      	push	{r4, lr}
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_RESET);
 8006f4a:	4c04      	ldr	r4, [pc, #16]	; (8006f5c <USBPD_BSP_LED_On+0x18>)
 8006f4c:	2200      	movs	r2, #0
 8006f4e:	1823      	adds	r3, r4, r0
 8006f50:	8899      	ldrh	r1, [r3, #4]
 8006f52:	5900      	ldr	r0, [r0, r4]
 8006f54:	f000 fde2 	bl	8007b1c <HAL_GPIO_WritePin>
  }
 8006f58:	bd10      	pop	{r4, pc}
 8006f5a:	46c0      	nop			; (mov r8, r8)
 8006f5c:	20000000 	.word	0x20000000

08006f60 <USBPD_BSP_LED_Off>:
  * @retval None
  */  
  
  void USBPD_BSP_LED_Off(USBPD_BSP_Led_TypeDef Led)
  {
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_SET);
 8006f60:	230c      	movs	r3, #12
 8006f62:	4358      	muls	r0, r3
  {
 8006f64:	b510      	push	{r4, lr}
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_SET);
 8006f66:	4c04      	ldr	r4, [pc, #16]	; (8006f78 <USBPD_BSP_LED_Off+0x18>)
 8006f68:	2201      	movs	r2, #1
 8006f6a:	1823      	adds	r3, r4, r0
 8006f6c:	8899      	ldrh	r1, [r3, #4]
 8006f6e:	5900      	ldr	r0, [r0, r4]
 8006f70:	f000 fdd4 	bl	8007b1c <HAL_GPIO_WritePin>
  }
 8006f74:	bd10      	pop	{r4, pc}
 8006f76:	46c0      	nop			; (mov r8, r8)
 8006f78:	20000000 	.word	0x20000000

08006f7c <USBPD_BSP_LED_Init>:
  {
 8006f7c:	b530      	push	{r4, r5, lr}
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8006f7e:	2301      	movs	r3, #1
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006f80:	2400      	movs	r4, #0
 8006f82:	250c      	movs	r5, #12
  {
 8006f84:	b087      	sub	sp, #28
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8006f86:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006f88:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;    
 8006f8a:	9404      	str	r4, [sp, #16]
 8006f8c:	002a      	movs	r2, r5
 8006f8e:	4362      	muls	r2, r4
        GPIO_InitStruct.Pin = USBPD_BSP_LEDs[led].GPIO_Pin;
 8006f90:	4b07      	ldr	r3, [pc, #28]	; (8006fb0 <USBPD_BSP_LED_Init+0x34>)
 8006f92:	1899      	adds	r1, r3, r2
 8006f94:	8889      	ldrh	r1, [r1, #4]
        HAL_GPIO_Init(USBPD_BSP_LEDs[led].GPIOx, &GPIO_InitStruct);
 8006f96:	58d0      	ldr	r0, [r2, r3]
        GPIO_InitStruct.Pin = USBPD_BSP_LEDs[led].GPIO_Pin;
 8006f98:	9101      	str	r1, [sp, #4]
        HAL_GPIO_Init(USBPD_BSP_LEDs[led].GPIOx, &GPIO_InitStruct);
 8006f9a:	a901      	add	r1, sp, #4
 8006f9c:	f000 fcfc 	bl	8007998 <HAL_GPIO_Init>
        USBPD_BSP_LED_Off((USBPD_BSP_Led_TypeDef)led);
 8006fa0:	b260      	sxtb	r0, r4
 8006fa2:	3401      	adds	r4, #1
 8006fa4:	f7ff ffdc 	bl	8006f60 <USBPD_BSP_LED_Off>
    for(led=0;led<USBPD_BSP_LEDn;led++)
 8006fa8:	2c04      	cmp	r4, #4
 8006faa:	d1ef      	bne.n	8006f8c <USBPD_BSP_LED_Init+0x10>
  }
 8006fac:	b007      	add	sp, #28
 8006fae:	bd30      	pop	{r4, r5, pc}
 8006fb0:	20000000 	.word	0x20000000

08006fb4 <USBPD_BSP_LED_Toggle>:
  * @retval None
  */ 
  
  void USBPD_BSP_LED_Toggle(USBPD_BSP_Led_TypeDef Led)
  {
    HAL_GPIO_TogglePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin);
 8006fb4:	230c      	movs	r3, #12
 8006fb6:	4358      	muls	r0, r3
  {
 8006fb8:	b510      	push	{r4, lr}
    HAL_GPIO_TogglePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin);
 8006fba:	4a03      	ldr	r2, [pc, #12]	; (8006fc8 <USBPD_BSP_LED_Toggle+0x14>)
 8006fbc:	1813      	adds	r3, r2, r0
 8006fbe:	8899      	ldrh	r1, [r3, #4]
 8006fc0:	5880      	ldr	r0, [r0, r2]
 8006fc2:	f000 fdb1 	bl	8007b28 <HAL_GPIO_TogglePin>
  }
 8006fc6:	bd10      	pop	{r4, pc}
 8006fc8:	20000000 	.word	0x20000000

08006fcc <USBPD_BSP_UART_Init>:
  */

void USBPD_BSP_UART_Init(void)
{
    /* Init huart_usbpdm1 */
    huart_handle.Instance = USBPD_BSP_USART;
 8006fcc:	4809      	ldr	r0, [pc, #36]	; (8006ff4 <USBPD_BSP_UART_Init+0x28>)
 8006fce:	4b0a      	ldr	r3, [pc, #40]	; (8006ff8 <USBPD_BSP_UART_Init+0x2c>)
{
 8006fd0:	b510      	push	{r4, lr}
    huart_handle.Instance = USBPD_BSP_USART;
 8006fd2:	6003      	str	r3, [r0, #0]
    huart_handle.Init.BaudRate = BAUDRATE;
 8006fd4:	23e1      	movs	r3, #225	; 0xe1
 8006fd6:	025b      	lsls	r3, r3, #9
 8006fd8:	6043      	str	r3, [r0, #4]
    huart_handle.Init.WordLength = UART_WORDLENGTH_8B;
    huart_handle.Init.StopBits = UART_STOPBITS_1;
    huart_handle.Init.Parity = UART_PARITY_NONE;
    huart_handle.Init.Mode = UART_MODE_TX_RX;
 8006fda:	220c      	movs	r2, #12
    huart_handle.Init.WordLength = UART_WORDLENGTH_8B;
 8006fdc:	2300      	movs	r3, #0
    huart_handle.Init.Mode = UART_MODE_TX_RX;
 8006fde:	6142      	str	r2, [r0, #20]
    huart_handle.Init.WordLength = UART_WORDLENGTH_8B;
 8006fe0:	6083      	str	r3, [r0, #8]
    huart_handle.Init.StopBits = UART_STOPBITS_1;
 8006fe2:	60c3      	str	r3, [r0, #12]
    huart_handle.Init.Parity = UART_PARITY_NONE;
 8006fe4:	6103      	str	r3, [r0, #16]
    huart_handle.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8006fe6:	6183      	str	r3, [r0, #24]
    huart_handle.Init.OverSampling = UART_OVERSAMPLING_16;
 8006fe8:	61c3      	str	r3, [r0, #28]
    huart_handle.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8006fea:	6203      	str	r3, [r0, #32]
    huart_handle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8006fec:	6243      	str	r3, [r0, #36]	; 0x24

    /* Init of the peripheral */
    HAL_UART_Init(&huart_handle);
 8006fee:	f002 fa3d 	bl	800946c <HAL_UART_Init>
}
 8006ff2:	bd10      	pop	{r4, pc}
 8006ff4:	20001bec 	.word	0x20001bec
 8006ff8:	40004400 	.word	0x40004400

08006ffc <HAL_UART_MspInit>:
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
    GPIO_InitTypeDef GPIO_InitStruct;

    /* Peripheral clock enable */
    USBPD_BSP_USARTCLK_ENABLE();
 8006ffc:	2080      	movs	r0, #128	; 0x80
 8006ffe:	4a12      	ldr	r2, [pc, #72]	; (8007048 <HAL_UART_MspInit+0x4c>)
{
 8007000:	b530      	push	{r4, r5, lr}
    USBPD_BSP_USARTCLK_ENABLE();
 8007002:	69d1      	ldr	r1, [r2, #28]
 8007004:	0280      	lsls	r0, r0, #10
 8007006:	4301      	orrs	r1, r0
 8007008:	61d1      	str	r1, [r2, #28]
 800700a:	69d3      	ldr	r3, [r2, #28]
{
 800700c:	b087      	sub	sp, #28
    USBPD_BSP_USARTCLK_ENABLE();
 800700e:	4003      	ands	r3, r0
 8007010:	9300      	str	r3, [sp, #0]
 8007012:	9b00      	ldr	r3, [sp, #0]

    /* USART GPIO Configuration */
    GPIO_InitStruct.Pin = USART_TX_PIN | USART_RX_PIN;
 8007014:	230c      	movs	r3, #12
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = USART_PIN_GPIOAF;
    HAL_GPIO_Init(USART_TX_PORT, &GPIO_InitStruct);
 8007016:	2090      	movs	r0, #144	; 0x90
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8007018:	2500      	movs	r5, #0
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800701a:	2403      	movs	r4, #3
    GPIO_InitStruct.Pin = USART_TX_PIN | USART_RX_PIN;
 800701c:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800701e:	3b0a      	subs	r3, #10
 8007020:	9302      	str	r3, [sp, #8]
    HAL_GPIO_Init(USART_TX_PORT, &GPIO_InitStruct);
 8007022:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Alternate = USART_PIN_GPIOAF;
 8007024:	3b01      	subs	r3, #1
    HAL_GPIO_Init(USART_TX_PORT, &GPIO_InitStruct);
 8007026:	05c0      	lsls	r0, r0, #23
    GPIO_InitStruct.Alternate = USART_PIN_GPIOAF;
 8007028:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800702a:	9503      	str	r5, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800702c:	9404      	str	r4, [sp, #16]
    HAL_GPIO_Init(USART_TX_PORT, &GPIO_InitStruct);
 800702e:	f000 fcb3 	bl	8007998 <HAL_GPIO_Init>
    
    /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(USART_IRQ, 3, 0);
 8007032:	002a      	movs	r2, r5
 8007034:	0021      	movs	r1, r4
 8007036:	201c      	movs	r0, #28
 8007038:	f000 fad4 	bl	80075e4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART_IRQ);
 800703c:	201c      	movs	r0, #28
 800703e:	f000 fafb 	bl	8007638 <HAL_NVIC_EnableIRQ>
}
 8007042:	b007      	add	sp, #28
 8007044:	bd30      	pop	{r4, r5, pc}
 8007046:	46c0      	nop			; (mov r8, r8)
 8007048:	40021000 	.word	0x40021000

0800704c <SystemInit>:
  */
void SystemInit(void)
{
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001U;
 800704c:	2101      	movs	r1, #1
 800704e:	4b11      	ldr	r3, [pc, #68]	; (8007094 <SystemInit+0x48>)
#if defined (STM32F051x8) || defined (STM32F058x8)
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE and MCOSEL[2:0] bits */
  RCC->CFGR &= (uint32_t)0xF8FFB80CU;
#else
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */
  RCC->CFGR &= (uint32_t)0x08FFB80CU;
 8007050:	4811      	ldr	r0, [pc, #68]	; (8007098 <SystemInit+0x4c>)
  RCC->CR |= (uint32_t)0x00000001U;
 8007052:	681a      	ldr	r2, [r3, #0]
 8007054:	430a      	orrs	r2, r1
 8007056:	601a      	str	r2, [r3, #0]
  RCC->CFGR &= (uint32_t)0x08FFB80CU;
 8007058:	685a      	ldr	r2, [r3, #4]
 800705a:	4002      	ands	r2, r0
 800705c:	605a      	str	r2, [r3, #4]
#endif /* STM32F051x8 or STM32F058x8 */
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFFU;
 800705e:	681a      	ldr	r2, [r3, #0]
 8007060:	480e      	ldr	r0, [pc, #56]	; (800709c <SystemInit+0x50>)
 8007062:	4002      	ands	r2, r0
 8007064:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFFU;
 8007066:	681a      	ldr	r2, [r3, #0]
 8007068:	480d      	ldr	r0, [pc, #52]	; (80070a0 <SystemInit+0x54>)
 800706a:	4002      	ands	r2, r0
 800706c:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  RCC->CFGR &= (uint32_t)0xFFC0FFFFU;
 800706e:	685a      	ldr	r2, [r3, #4]
 8007070:	480c      	ldr	r0, [pc, #48]	; (80070a4 <SystemInit+0x58>)
 8007072:	4002      	ands	r2, r0

  /* Reset PREDIV[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0U;
 8007074:	200f      	movs	r0, #15
  RCC->CFGR &= (uint32_t)0xFFC0FFFFU;
 8007076:	605a      	str	r2, [r3, #4]
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0U;
 8007078:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800707a:	4382      	bics	r2, r0
 800707c:	62da      	str	r2, [r3, #44]	; 0x2c

#if defined (STM32F072xB) || defined (STM32F078xx)
  /* Reset USART2SW[1:0], USART1SW[1:0], I2C1SW, CECSW, USBSW and ADCSW bits */
  RCC->CFGR3 &= (uint32_t)0xFFFCFE2CU;
 800707e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8007080:	4809      	ldr	r0, [pc, #36]	; (80070a8 <SystemInit+0x5c>)
 8007082:	4002      	ands	r2, r0
 8007084:	631a      	str	r2, [r3, #48]	; 0x30
#else
 #warning "No target selected"
#endif

  /* Reset HSI14 bit */
  RCC->CR2 &= (uint32_t)0xFFFFFFFEU;
 8007086:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8007088:	438a      	bics	r2, r1
 800708a:	635a      	str	r2, [r3, #52]	; 0x34

  /* Disable all interrupts */
  RCC->CIR = 0x00000000U;
 800708c:	2200      	movs	r2, #0
 800708e:	609a      	str	r2, [r3, #8]

}
 8007090:	4770      	bx	lr
 8007092:	46c0      	nop			; (mov r8, r8)
 8007094:	40021000 	.word	0x40021000
 8007098:	08ffb80c 	.word	0x08ffb80c
 800709c:	fef6ffff 	.word	0xfef6ffff
 80070a0:	fffbffff 	.word	0xfffbffff
 80070a4:	ffc0ffff 	.word	0xffc0ffff
 80070a8:	fffcfe2c 	.word	0xfffcfe2c

080070ac <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80070ac:	b510      	push	{r4, lr}
 80070ae:	0004      	movs	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000U);
 80070b0:	f001 f8c6 	bl	8008240 <HAL_RCC_GetHCLKFreq>
 80070b4:	21fa      	movs	r1, #250	; 0xfa
 80070b6:	0089      	lsls	r1, r1, #2
 80070b8:	f7fe fc86 	bl	80059c8 <__udivsi3>
 80070bc:	f000 fac6 	bl	800764c <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 80070c0:	2001      	movs	r0, #1
 80070c2:	2200      	movs	r2, #0
 80070c4:	0021      	movs	r1, r4
 80070c6:	4240      	negs	r0, r0
 80070c8:	f000 fa8c 	bl	80075e4 <HAL_NVIC_SetPriority>

   /* Return function status */
  return HAL_OK;
}
 80070cc:	2000      	movs	r0, #0
 80070ce:	bd10      	pop	{r4, pc}

080070d0 <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80070d0:	2310      	movs	r3, #16
 80070d2:	4a06      	ldr	r2, [pc, #24]	; (80070ec <HAL_Init+0x1c>)
{
 80070d4:	b510      	push	{r4, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80070d6:	6811      	ldr	r1, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 80070d8:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80070da:	430b      	orrs	r3, r1
 80070dc:	6013      	str	r3, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 80070de:	f7ff ffe5 	bl	80070ac <HAL_InitTick>
  HAL_MspInit();
 80070e2:	f7fe fe7f 	bl	8005de4 <HAL_MspInit>
}
 80070e6:	2000      	movs	r0, #0
 80070e8:	bd10      	pop	{r4, pc}
 80070ea:	46c0      	nop			; (mov r8, r8)
 80070ec:	40022000 	.word	0x40022000

080070f0 <HAL_IncTick>:
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 80070f0:	4a02      	ldr	r2, [pc, #8]	; (80070fc <HAL_IncTick+0xc>)
 80070f2:	6813      	ldr	r3, [r2, #0]
 80070f4:	3301      	adds	r3, #1
 80070f6:	6013      	str	r3, [r2, #0]
}
 80070f8:	4770      	bx	lr
 80070fa:	46c0      	nop			; (mov r8, r8)
 80070fc:	20001c5c 	.word	0x20001c5c

08007100 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8007100:	4b01      	ldr	r3, [pc, #4]	; (8007108 <HAL_GetTick+0x8>)
 8007102:	6818      	ldr	r0, [r3, #0]
}
 8007104:	4770      	bx	lr
 8007106:	46c0      	nop			; (mov r8, r8)
 8007108:	20001c5c 	.word	0x20001c5c

0800710c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 800710c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800710e:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = HAL_GetTick();
 8007110:	f7ff fff6 	bl	8007100 <HAL_GetTick>
  uint32_t wait = Delay;
 8007114:	9c01      	ldr	r4, [sp, #4]
  uint32_t tickstart = HAL_GetTick();
 8007116:	0005      	movs	r5, r0
  
  /* Add a period to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
  {
     wait++;
 8007118:	1c63      	adds	r3, r4, #1
 800711a:	1e5a      	subs	r2, r3, #1
 800711c:	4193      	sbcs	r3, r2
 800711e:	18e4      	adds	r4, r4, r3
  }
  
  while((HAL_GetTick() - tickstart) < wait)
 8007120:	f7ff ffee 	bl	8007100 <HAL_GetTick>
 8007124:	1b40      	subs	r0, r0, r5
 8007126:	42a0      	cmp	r0, r4
 8007128:	d3fa      	bcc.n	8007120 <HAL_Delay+0x14>
  {
  }
}
 800712a:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

0800712c <ADC_Enable>:
  * @retval HAL status.
  */
static HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
{
  uint32_t tickstart = 0U;
  __IO uint32_t wait_loop_index = 0U;
 800712c:	2300      	movs	r3, #0
{
 800712e:	b573      	push	{r0, r1, r4, r5, r6, lr}
  
  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (ADC_IS_ENABLE(hadc) == RESET)
 8007130:	2103      	movs	r1, #3
  __IO uint32_t wait_loop_index = 0U;
 8007132:	9301      	str	r3, [sp, #4]
  if (ADC_IS_ENABLE(hadc) == RESET)
 8007134:	6803      	ldr	r3, [r0, #0]
{
 8007136:	0004      	movs	r4, r0
  if (ADC_IS_ENABLE(hadc) == RESET)
 8007138:	689a      	ldr	r2, [r3, #8]
 800713a:	400a      	ands	r2, r1
 800713c:	2a01      	cmp	r2, #1
 800713e:	d107      	bne.n	8007150 <ADC_Enable+0x24>
 8007140:	6819      	ldr	r1, [r3, #0]
 8007142:	4211      	tst	r1, r2
 8007144:	d001      	beq.n	800714a <ADC_Enable+0x1e>
    }   
    
  }
   
  /* Return HAL status */
  return HAL_OK;
 8007146:	2000      	movs	r0, #0
}
 8007148:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
  if (ADC_IS_ENABLE(hadc) == RESET)
 800714a:	68da      	ldr	r2, [r3, #12]
 800714c:	0412      	lsls	r2, r2, #16
 800714e:	d4fa      	bmi.n	8007146 <ADC_Enable+0x1a>
    if (ADC_ENABLING_CONDITIONS(hadc) == RESET)
 8007150:	6899      	ldr	r1, [r3, #8]
 8007152:	4a19      	ldr	r2, [pc, #100]	; (80071b8 <ADC_Enable+0x8c>)
 8007154:	4211      	tst	r1, r2
 8007156:	d008      	beq.n	800716a <ADC_Enable+0x3e>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007158:	2310      	movs	r3, #16
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800715a:	2001      	movs	r0, #1
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800715c:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800715e:	4313      	orrs	r3, r2
 8007160:	6463      	str	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007162:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8007164:	4303      	orrs	r3, r0
 8007166:	64a3      	str	r3, [r4, #72]	; 0x48
      return HAL_ERROR;
 8007168:	e7ee      	b.n	8007148 <ADC_Enable+0x1c>
    __HAL_ADC_ENABLE(hadc);
 800716a:	2201      	movs	r2, #1
 800716c:	6899      	ldr	r1, [r3, #8]
 800716e:	430a      	orrs	r2, r1
 8007170:	609a      	str	r2, [r3, #8]
    wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 8007172:	4b12      	ldr	r3, [pc, #72]	; (80071bc <ADC_Enable+0x90>)
 8007174:	4912      	ldr	r1, [pc, #72]	; (80071c0 <ADC_Enable+0x94>)
 8007176:	6818      	ldr	r0, [r3, #0]
 8007178:	f7fe fc26 	bl	80059c8 <__udivsi3>
 800717c:	9001      	str	r0, [sp, #4]
    while(wait_loop_index != 0U)
 800717e:	9b01      	ldr	r3, [sp, #4]
 8007180:	2b00      	cmp	r3, #0
 8007182:	d115      	bne.n	80071b0 <ADC_Enable+0x84>
    tickstart = HAL_GetTick();
 8007184:	f7ff ffbc 	bl	8007100 <HAL_GetTick>
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
 8007188:	2501      	movs	r5, #1
    tickstart = HAL_GetTick();
 800718a:	0006      	movs	r6, r0
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
 800718c:	6823      	ldr	r3, [r4, #0]
 800718e:	681b      	ldr	r3, [r3, #0]
 8007190:	422b      	tst	r3, r5
 8007192:	d1d8      	bne.n	8007146 <ADC_Enable+0x1a>
      if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8007194:	f7ff ffb4 	bl	8007100 <HAL_GetTick>
 8007198:	1b80      	subs	r0, r0, r6
 800719a:	2802      	cmp	r0, #2
 800719c:	d9f6      	bls.n	800718c <ADC_Enable+0x60>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800719e:	2310      	movs	r3, #16
 80071a0:	6c62      	ldr	r2, [r4, #68]	; 0x44
        return HAL_ERROR;
 80071a2:	2001      	movs	r0, #1
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80071a4:	4313      	orrs	r3, r2
 80071a6:	6463      	str	r3, [r4, #68]	; 0x44
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80071a8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80071aa:	432b      	orrs	r3, r5
 80071ac:	64a3      	str	r3, [r4, #72]	; 0x48
        return HAL_ERROR;
 80071ae:	e7cb      	b.n	8007148 <ADC_Enable+0x1c>
      wait_loop_index--;
 80071b0:	9b01      	ldr	r3, [sp, #4]
 80071b2:	3b01      	subs	r3, #1
 80071b4:	9301      	str	r3, [sp, #4]
 80071b6:	e7e2      	b.n	800717e <ADC_Enable+0x52>
 80071b8:	80000017 	.word	0x80000017
 80071bc:	20000030 	.word	0x20000030
 80071c0:	000f4240 	.word	0x000f4240

080071c4 <HAL_ADC_Init>:
{
 80071c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80071c6:	0004      	movs	r4, r0
    return HAL_ERROR;
 80071c8:	2001      	movs	r0, #1
  if(hadc == NULL)
 80071ca:	2c00      	cmp	r4, #0
 80071cc:	d07d      	beq.n	80072ca <HAL_ADC_Init+0x106>
  if (hadc->State == HAL_ADC_STATE_RESET)
 80071ce:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80071d0:	2b00      	cmp	r3, #0
 80071d2:	d106      	bne.n	80071e2 <HAL_ADC_Init+0x1e>
    hadc->Lock = HAL_UNLOCKED;
 80071d4:	0022      	movs	r2, r4
 80071d6:	3240      	adds	r2, #64	; 0x40
    ADC_CLEAR_ERRORCODE(hadc);
 80071d8:	64a3      	str	r3, [r4, #72]	; 0x48
    HAL_ADC_MspInit(hadc);
 80071da:	0020      	movs	r0, r4
    hadc->Lock = HAL_UNLOCKED;
 80071dc:	7013      	strb	r3, [r2, #0]
    HAL_ADC_MspInit(hadc);
 80071de:	f7fe fe3d 	bl	8005e5c <HAL_ADC_MspInit>
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
 80071e2:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80071e4:	06db      	lsls	r3, r3, #27
 80071e6:	d500      	bpl.n	80071ea <HAL_ADC_Init+0x26>
 80071e8:	e084      	b.n	80072f4 <HAL_ADC_Init+0x130>
      (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)          )
 80071ea:	2204      	movs	r2, #4
 80071ec:	6823      	ldr	r3, [r4, #0]
 80071ee:	6898      	ldr	r0, [r3, #8]
 80071f0:	4010      	ands	r0, r2
      (tmp_hal_status == HAL_OK)                                &&
 80071f2:	d000      	beq.n	80071f6 <HAL_ADC_Init+0x32>
 80071f4:	e07e      	b.n	80072f4 <HAL_ADC_Init+0x130>
    ADC_STATE_CLR_SET(hadc->State,
 80071f6:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80071f8:	4941      	ldr	r1, [pc, #260]	; (8007300 <HAL_ADC_Init+0x13c>)
 80071fa:	4011      	ands	r1, r2
 80071fc:	2202      	movs	r2, #2
 80071fe:	430a      	orrs	r2, r1
    if (ADC_IS_ENABLE(hadc) == RESET)
 8007200:	2103      	movs	r1, #3
    ADC_STATE_CLR_SET(hadc->State,
 8007202:	6462      	str	r2, [r4, #68]	; 0x44
    if (ADC_IS_ENABLE(hadc) == RESET)
 8007204:	689a      	ldr	r2, [r3, #8]
 8007206:	400a      	ands	r2, r1
 8007208:	2a01      	cmp	r2, #1
 800720a:	d105      	bne.n	8007218 <HAL_ADC_Init+0x54>
 800720c:	6819      	ldr	r1, [r3, #0]
 800720e:	4211      	tst	r1, r2
 8007210:	d10e      	bne.n	8007230 <HAL_ADC_Init+0x6c>
 8007212:	68da      	ldr	r2, [r3, #12]
 8007214:	0412      	lsls	r2, r2, #16
 8007216:	d40b      	bmi.n	8007230 <HAL_ADC_Init+0x6c>
      MODIFY_REG(hadc->Instance->CFGR1,
 8007218:	2118      	movs	r1, #24
 800721a:	68da      	ldr	r2, [r3, #12]
 800721c:	438a      	bics	r2, r1
 800721e:	68a1      	ldr	r1, [r4, #8]
 8007220:	430a      	orrs	r2, r1
 8007222:	60da      	str	r2, [r3, #12]
      MODIFY_REG(hadc->Instance->CFGR2    ,
 8007224:	6919      	ldr	r1, [r3, #16]
 8007226:	6862      	ldr	r2, [r4, #4]
 8007228:	0089      	lsls	r1, r1, #2
 800722a:	0889      	lsrs	r1, r1, #2
 800722c:	4311      	orrs	r1, r2
 800722e:	6119      	str	r1, [r3, #16]
    hadc->Instance->CFGR1 &= ~( ADC_CFGR1_DISCEN  |
 8007230:	68da      	ldr	r2, [r3, #12]
 8007232:	4934      	ldr	r1, [pc, #208]	; (8007304 <HAL_ADC_Init+0x140>)
                 ADC_CFGR1_CONTINUOUS(hadc->Init.ContinuousConvMode)    |
 8007234:	6a25      	ldr	r5, [r4, #32]
    hadc->Instance->CFGR1 &= ~( ADC_CFGR1_DISCEN  |
 8007236:	400a      	ands	r2, r1
 8007238:	60da      	str	r2, [r3, #12]
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
 800723a:	69a2      	ldr	r2, [r4, #24]
                 ADC_CFGR1_CONTINUOUS(hadc->Init.ContinuousConvMode)    |
 800723c:	036f      	lsls	r7, r5, #13
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
 800723e:	0391      	lsls	r1, r2, #14
                 ADC_CFGR1_AUTOOFF(hadc->Init.LowPowerAutoPowerOff)     |
 8007240:	69e2      	ldr	r2, [r4, #28]
 8007242:	03d2      	lsls	r2, r2, #15
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
 8007244:	4311      	orrs	r1, r2
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                  |
 8007246:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8007248:	3a01      	subs	r2, #1
 800724a:	1e56      	subs	r6, r2, #1
 800724c:	41b2      	sbcs	r2, r6
 800724e:	0316      	lsls	r6, r2, #12
 8007250:	68e2      	ldr	r2, [r4, #12]
 8007252:	4311      	orrs	r1, r2
                 ADC_SCANDIR(hadc->Init.ScanConvMode)                   |
 8007254:	6922      	ldr	r2, [r4, #16]
 8007256:	430f      	orrs	r7, r1
 8007258:	2a02      	cmp	r2, #2
 800725a:	d100      	bne.n	800725e <HAL_ADC_Init+0x9a>
 800725c:	2004      	movs	r0, #4
                 ADC_CFGR1_DMACONTREQ(hadc->Init.DMAContinuousRequests)  );
 800725e:	6b22      	ldr	r2, [r4, #48]	; 0x30
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8007260:	6a61      	ldr	r1, [r4, #36]	; 0x24
                 ADC_CFGR1_DMACONTREQ(hadc->Init.DMAContinuousRequests)  );
 8007262:	0052      	lsls	r2, r2, #1
                 ADC_SCANDIR(hadc->Init.ScanConvMode)                   |
 8007264:	433a      	orrs	r2, r7
 8007266:	4332      	orrs	r2, r6
 8007268:	4302      	orrs	r2, r0
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 800726a:	2901      	cmp	r1, #1
 800726c:	d104      	bne.n	8007278 <HAL_ADC_Init+0xb4>
      if (hadc->Init.ContinuousConvMode == DISABLE)
 800726e:	2d00      	cmp	r5, #0
 8007270:	d12c      	bne.n	80072cc <HAL_ADC_Init+0x108>
        tmpCFGR1 |= ADC_CFGR1_DISCEN;
 8007272:	2180      	movs	r1, #128	; 0x80
 8007274:	0249      	lsls	r1, r1, #9
 8007276:	430a      	orrs	r2, r1
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8007278:	20c2      	movs	r0, #194	; 0xc2
 800727a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800727c:	30ff      	adds	r0, #255	; 0xff
 800727e:	4281      	cmp	r1, r0
 8007280:	d002      	beq.n	8007288 <HAL_ADC_Init+0xc4>
      tmpCFGR1 |= ( hadc->Init.ExternalTrigConv    |
 8007282:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8007284:	4301      	orrs	r1, r0
 8007286:	430a      	orrs	r2, r1
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8007288:	2080      	movs	r0, #128	; 0x80
    hadc->Instance->CFGR1 |= tmpCFGR1;
 800728a:	68d9      	ldr	r1, [r3, #12]
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 800728c:	0540      	lsls	r0, r0, #21
    hadc->Instance->CFGR1 |= tmpCFGR1;
 800728e:	4311      	orrs	r1, r2
 8007290:	60d9      	str	r1, [r3, #12]
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8007292:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8007294:	4281      	cmp	r1, r0
 8007296:	d002      	beq.n	800729e <HAL_ADC_Init+0xda>
 8007298:	1e48      	subs	r0, r1, #1
 800729a:	2806      	cmp	r0, #6
 800729c:	d807      	bhi.n	80072ae <HAL_ADC_Init+0xea>
      hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 800729e:	2507      	movs	r5, #7
 80072a0:	6958      	ldr	r0, [r3, #20]
      hadc->Instance->SMPR |= ADC_SMPR_SET(hadc->Init.SamplingTimeCommon);
 80072a2:	4029      	ands	r1, r5
      hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 80072a4:	43a8      	bics	r0, r5
 80072a6:	6158      	str	r0, [r3, #20]
      hadc->Instance->SMPR |= ADC_SMPR_SET(hadc->Init.SamplingTimeCommon);
 80072a8:	6958      	ldr	r0, [r3, #20]
 80072aa:	4301      	orrs	r1, r0
 80072ac:	6159      	str	r1, [r3, #20]
    if ((hadc->Instance->CFGR1 & ~(ADC_CFGR1_AWDCH | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL | ADC_CFGR1_RES))
 80072ae:	68db      	ldr	r3, [r3, #12]
 80072b0:	4915      	ldr	r1, [pc, #84]	; (8007308 <HAL_ADC_Init+0x144>)
 80072b2:	400b      	ands	r3, r1
 80072b4:	4293      	cmp	r3, r2
 80072b6:	d111      	bne.n	80072dc <HAL_ADC_Init+0x118>
      ADC_CLEAR_ERRORCODE(hadc);
 80072b8:	2000      	movs	r0, #0
      ADC_STATE_CLR_SET(hadc->State,
 80072ba:	2203      	movs	r2, #3
      ADC_CLEAR_ERRORCODE(hadc);
 80072bc:	64a0      	str	r0, [r4, #72]	; 0x48
      ADC_STATE_CLR_SET(hadc->State,
 80072be:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80072c0:	4393      	bics	r3, r2
 80072c2:	001a      	movs	r2, r3
 80072c4:	2301      	movs	r3, #1
 80072c6:	4313      	orrs	r3, r2
 80072c8:	6463      	str	r3, [r4, #68]	; 0x44
}
 80072ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80072cc:	2020      	movs	r0, #32
 80072ce:	6c65      	ldr	r5, [r4, #68]	; 0x44
 80072d0:	4328      	orrs	r0, r5
 80072d2:	6460      	str	r0, [r4, #68]	; 0x44
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80072d4:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 80072d6:	4301      	orrs	r1, r0
 80072d8:	64a1      	str	r1, [r4, #72]	; 0x48
 80072da:	e7cd      	b.n	8007278 <HAL_ADC_Init+0xb4>
      ADC_STATE_CLR_SET(hadc->State,
 80072dc:	2212      	movs	r2, #18
 80072de:	6c63      	ldr	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80072e0:	2001      	movs	r0, #1
      ADC_STATE_CLR_SET(hadc->State,
 80072e2:	4393      	bics	r3, r2
 80072e4:	001a      	movs	r2, r3
 80072e6:	2310      	movs	r3, #16
 80072e8:	4313      	orrs	r3, r2
 80072ea:	6463      	str	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80072ec:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80072ee:	4303      	orrs	r3, r0
 80072f0:	64a3      	str	r3, [r4, #72]	; 0x48
 80072f2:	e7ea      	b.n	80072ca <HAL_ADC_Init+0x106>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80072f4:	2310      	movs	r3, #16
 80072f6:	6c62      	ldr	r2, [r4, #68]	; 0x44
    tmp_hal_status = HAL_ERROR;
 80072f8:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80072fa:	4313      	orrs	r3, r2
 80072fc:	6463      	str	r3, [r4, #68]	; 0x44
 80072fe:	e7e4      	b.n	80072ca <HAL_ADC_Init+0x106>
 8007300:	fffffefd 	.word	0xfffffefd
 8007304:	fffe0219 	.word	0xfffe0219
 8007308:	833fffe7 	.word	0x833fffe7

0800730c <HAL_ADC_Start_DMA>:
{
 800730c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 800730e:	6803      	ldr	r3, [r0, #0]
{
 8007310:	0004      	movs	r4, r0
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8007312:	689b      	ldr	r3, [r3, #8]
{
 8007314:	000f      	movs	r7, r1
 8007316:	9201      	str	r2, [sp, #4]
    tmp_hal_status = HAL_BUSY;
 8007318:	2002      	movs	r0, #2
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 800731a:	075b      	lsls	r3, r3, #29
 800731c:	d430      	bmi.n	8007380 <HAL_ADC_Start_DMA+0x74>
    __HAL_LOCK(hadc);
 800731e:	0026      	movs	r6, r4
 8007320:	3640      	adds	r6, #64	; 0x40
 8007322:	7833      	ldrb	r3, [r6, #0]
 8007324:	2b01      	cmp	r3, #1
 8007326:	d02b      	beq.n	8007380 <HAL_ADC_Start_DMA+0x74>
 8007328:	2301      	movs	r3, #1
 800732a:	7033      	strb	r3, [r6, #0]
    if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
 800732c:	69e3      	ldr	r3, [r4, #28]
 800732e:	2b01      	cmp	r3, #1
 8007330:	d127      	bne.n	8007382 <HAL_ADC_Start_DMA+0x76>
      ADC_STATE_CLR_SET(hadc->State,
 8007332:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007334:	4a16      	ldr	r2, [pc, #88]	; (8007390 <HAL_ADC_Start_DMA+0x84>)
      ADC_CLEAR_ERRORCODE(hadc);
 8007336:	2500      	movs	r5, #0
      ADC_STATE_CLR_SET(hadc->State,
 8007338:	401a      	ands	r2, r3
 800733a:	2380      	movs	r3, #128	; 0x80
 800733c:	005b      	lsls	r3, r3, #1
 800733e:	4313      	orrs	r3, r2
 8007340:	6463      	str	r3, [r4, #68]	; 0x44
      hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 8007342:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8007344:	4b13      	ldr	r3, [pc, #76]	; (8007394 <HAL_ADC_Start_DMA+0x88>)
      ADC_CLEAR_ERRORCODE(hadc);
 8007346:	64a5      	str	r5, [r4, #72]	; 0x48
      __HAL_UNLOCK(hadc);
 8007348:	7035      	strb	r5, [r6, #0]
      hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 800734a:	6283      	str	r3, [r0, #40]	; 0x28
      hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 800734c:	4b12      	ldr	r3, [pc, #72]	; (8007398 <HAL_ADC_Start_DMA+0x8c>)
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 800734e:	6821      	ldr	r1, [r4, #0]
      hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 8007350:	62c3      	str	r3, [r0, #44]	; 0x2c
      hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 8007352:	4b12      	ldr	r3, [pc, #72]	; (800739c <HAL_ADC_Start_DMA+0x90>)
 8007354:	6303      	str	r3, [r0, #48]	; 0x30
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8007356:	231c      	movs	r3, #28
 8007358:	600b      	str	r3, [r1, #0]
      __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 800735a:	684a      	ldr	r2, [r1, #4]
 800735c:	3b0c      	subs	r3, #12
 800735e:	4313      	orrs	r3, r2
 8007360:	604b      	str	r3, [r1, #4]
      hadc->Instance->CFGR1 |= ADC_CFGR1_DMAEN;
 8007362:	2301      	movs	r3, #1
 8007364:	68ca      	ldr	r2, [r1, #12]
 8007366:	4313      	orrs	r3, r2
 8007368:	60cb      	str	r3, [r1, #12]
      HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 800736a:	003a      	movs	r2, r7
 800736c:	3140      	adds	r1, #64	; 0x40
 800736e:	9b01      	ldr	r3, [sp, #4]
 8007370:	f000 fac0 	bl	80078f4 <HAL_DMA_Start_IT>
      hadc->Instance->CR |= ADC_CR_ADSTART;
 8007374:	2304      	movs	r3, #4
 8007376:	0028      	movs	r0, r5
 8007378:	6822      	ldr	r2, [r4, #0]
 800737a:	6891      	ldr	r1, [r2, #8]
 800737c:	430b      	orrs	r3, r1
 800737e:	6093      	str	r3, [r2, #8]
}
 8007380:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      tmp_hal_status = ADC_Enable(hadc);
 8007382:	0020      	movs	r0, r4
 8007384:	f7ff fed2 	bl	800712c <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 8007388:	2800      	cmp	r0, #0
 800738a:	d0d2      	beq.n	8007332 <HAL_ADC_Start_DMA+0x26>
 800738c:	e7f8      	b.n	8007380 <HAL_ADC_Start_DMA+0x74>
 800738e:	46c0      	nop			; (mov r8, r8)
 8007390:	fffff0fe 	.word	0xfffff0fe
 8007394:	080073a5 	.word	0x080073a5
 8007398:	08007417 	.word	0x08007417
 800739c:	08007423 	.word	0x08007423

080073a0 <HAL_ADC_ConvCpltCallback>:
 80073a0:	4770      	bx	lr
	...

080073a4 <ADC_DMAConvCplt>:
{
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Update state machine on conversion status if not in error state */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
 80073a4:	2250      	movs	r2, #80	; 0x50
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 80073a6:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
 80073a8:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
 80073aa:	6c59      	ldr	r1, [r3, #68]	; 0x44
 80073ac:	4211      	tst	r1, r2
 80073ae:	d12a      	bne.n	8007406 <ADC_DMAConvCplt+0x62>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
 80073b0:	6c59      	ldr	r1, [r3, #68]	; 0x44
 80073b2:	32b1      	adds	r2, #177	; 0xb1
 80073b4:	32ff      	adds	r2, #255	; 0xff
 80073b6:	430a      	orrs	r2, r1
    
    /* Determine whether any further conversion upcoming on group regular     */
    /* by external trigger, continuous mode or scan sequence on going.        */
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 80073b8:	21c0      	movs	r1, #192	; 0xc0
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
 80073ba:	645a      	str	r2, [r3, #68]	; 0x44
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 80073bc:	681a      	ldr	r2, [r3, #0]
 80073be:	0109      	lsls	r1, r1, #4
 80073c0:	68d0      	ldr	r0, [r2, #12]
 80073c2:	4208      	tst	r0, r1
 80073c4:	d112      	bne.n	80073ec <ADC_DMAConvCplt+0x48>
 80073c6:	6a19      	ldr	r1, [r3, #32]
 80073c8:	2900      	cmp	r1, #0
 80073ca:	d10f      	bne.n	80073ec <ADC_DMAConvCplt+0x48>
       (hadc->Init.ContinuousConvMode == DISABLE)   )
    {
      /* If End of Sequence is reached, disable interrupts */
      if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )
 80073cc:	6811      	ldr	r1, [r2, #0]
 80073ce:	0709      	lsls	r1, r1, #28
 80073d0:	d50c      	bpl.n	80073ec <ADC_DMAConvCplt+0x48>
      {
        /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit           */
        /* ADSTART==0 (no conversion on going)                                */
        if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 80073d2:	6891      	ldr	r1, [r2, #8]
 80073d4:	0749      	lsls	r1, r1, #29
 80073d6:	d40d      	bmi.n	80073f4 <ADC_DMAConvCplt+0x50>
        {
          /* Disable ADC end of single conversion interrupt on group regular */
          /* Note: Overrun interrupt was enabled with EOC interrupt in        */
          /* HAL_Start_IT(), but is not disabled here because can be used     */
          /* by overrun IRQ process below.                                    */
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 80073d8:	200c      	movs	r0, #12
 80073da:	6851      	ldr	r1, [r2, #4]
 80073dc:	4381      	bics	r1, r0
 80073de:	6051      	str	r1, [r2, #4]
          
          /* Set ADC state */
          ADC_STATE_CLR_SET(hadc->State,
 80073e0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80073e2:	490b      	ldr	r1, [pc, #44]	; (8007410 <ADC_DMAConvCplt+0x6c>)
 80073e4:	4011      	ands	r1, r2
 80073e6:	2201      	movs	r2, #1
 80073e8:	430a      	orrs	r2, r1
 80073ea:	645a      	str	r2, [r3, #68]	; 0x44
        }
      }
    }

    /* Conversion complete callback */
    HAL_ADC_ConvCpltCallback(hadc); 
 80073ec:	0018      	movs	r0, r3
 80073ee:	f7ff ffd7 	bl	80073a0 <HAL_ADC_ConvCpltCallback>
  {
    /* Call DMA error callback */
    hadc->DMA_Handle->XferErrorCallback(hdma);
  }

}
 80073f2:	bd10      	pop	{r4, pc}
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80073f4:	2220      	movs	r2, #32
 80073f6:	6c59      	ldr	r1, [r3, #68]	; 0x44
 80073f8:	430a      	orrs	r2, r1
 80073fa:	645a      	str	r2, [r3, #68]	; 0x44
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80073fc:	2201      	movs	r2, #1
 80073fe:	6c99      	ldr	r1, [r3, #72]	; 0x48
 8007400:	430a      	orrs	r2, r1
 8007402:	649a      	str	r2, [r3, #72]	; 0x48
 8007404:	e7f2      	b.n	80073ec <ADC_DMAConvCplt+0x48>
    hadc->DMA_Handle->XferErrorCallback(hdma);
 8007406:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007408:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800740a:	4798      	blx	r3
}
 800740c:	e7f1      	b.n	80073f2 <ADC_DMAConvCplt+0x4e>
 800740e:	46c0      	nop			; (mov r8, r8)
 8007410:	fffffefe 	.word	0xfffffefe

08007414 <HAL_ADC_ConvHalfCpltCallback>:
 8007414:	4770      	bx	lr

08007416 <ADC_DMAHalfConvCplt>:
  * @brief  DMA half transfer complete callback. 
  * @param  hdma: pointer to DMA handle.
  * @retval None
  */
static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
{
 8007416:	b510      	push	{r4, lr}
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Half conversion callback */
  HAL_ADC_ConvHalfCpltCallback(hadc); 
 8007418:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800741a:	f7ff fffb 	bl	8007414 <HAL_ADC_ConvHalfCpltCallback>
}
 800741e:	bd10      	pop	{r4, pc}

08007420 <HAL_ADC_ErrorCallback>:
 8007420:	4770      	bx	lr

08007422 <ADC_DMAError>:
{
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Set ADC state */
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 8007422:	2340      	movs	r3, #64	; 0x40
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8007424:	6a40      	ldr	r0, [r0, #36]	; 0x24
{
 8007426:	b510      	push	{r4, lr}
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 8007428:	6c42      	ldr	r2, [r0, #68]	; 0x44
 800742a:	4313      	orrs	r3, r2
 800742c:	6443      	str	r3, [r0, #68]	; 0x44
  
  /* Set ADC error code to DMA error */
  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
 800742e:	2304      	movs	r3, #4
 8007430:	6c82      	ldr	r2, [r0, #72]	; 0x48
 8007432:	4313      	orrs	r3, r2
 8007434:	6483      	str	r3, [r0, #72]	; 0x48
  
  /* Error callback */
  HAL_ADC_ErrorCallback(hadc); 
 8007436:	f7ff fff3 	bl	8007420 <HAL_ADC_ErrorCallback>
}
 800743a:	bd10      	pop	{r4, pc}

0800743c <HAL_ADC_ConfigChannel>:
{
 800743c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint32_t wait_loop_index = 0U;
 800743e:	2200      	movs	r2, #0
  __HAL_LOCK(hadc);
 8007440:	0004      	movs	r4, r0
  __IO uint32_t wait_loop_index = 0U;
 8007442:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 8007444:	3440      	adds	r4, #64	; 0x40
 8007446:	7822      	ldrb	r2, [r4, #0]
{
 8007448:	0003      	movs	r3, r0
  __HAL_LOCK(hadc);
 800744a:	2002      	movs	r0, #2
 800744c:	2a01      	cmp	r2, #1
 800744e:	d02b      	beq.n	80074a8 <HAL_ADC_ConfigChannel+0x6c>
 8007450:	2201      	movs	r2, #1
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8007452:	681d      	ldr	r5, [r3, #0]
  if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8007454:	6b9e      	ldr	r6, [r3, #56]	; 0x38
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8007456:	68a8      	ldr	r0, [r5, #8]
  __HAL_LOCK(hadc);
 8007458:	7022      	strb	r2, [r4, #0]
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 800745a:	0740      	lsls	r0, r0, #29
 800745c:	d45a      	bmi.n	8007514 <HAL_ADC_ConfigChannel+0xd8>
 800745e:	680b      	ldr	r3, [r1, #0]
    if (sConfig->Rank != ADC_RANK_NONE)
 8007460:	482f      	ldr	r0, [pc, #188]	; (8007520 <HAL_ADC_ConfigChannel+0xe4>)
 8007462:	001f      	movs	r7, r3
 8007464:	4684      	mov	ip, r0
 8007466:	6848      	ldr	r0, [r1, #4]
 8007468:	409a      	lsls	r2, r3
 800746a:	3f10      	subs	r7, #16
 800746c:	4560      	cmp	r0, ip
 800746e:	d03b      	beq.n	80074e8 <HAL_ADC_ConfigChannel+0xac>
      hadc->Instance->CHSELR |= ADC_CHSELR_CHANNEL(sConfig->Channel);
 8007470:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 8007472:	4310      	orrs	r0, r2
      if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8007474:	2280      	movs	r2, #128	; 0x80
      hadc->Instance->CHSELR |= ADC_CHSELR_CHANNEL(sConfig->Channel);
 8007476:	62a8      	str	r0, [r5, #40]	; 0x28
      if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8007478:	0552      	lsls	r2, r2, #21
 800747a:	4296      	cmp	r6, r2
 800747c:	d00f      	beq.n	800749e <HAL_ADC_ConfigChannel+0x62>
 800747e:	3e01      	subs	r6, #1
 8007480:	2e06      	cmp	r6, #6
 8007482:	d90c      	bls.n	800749e <HAL_ADC_ConfigChannel+0x62>
        if (sConfig->SamplingTime != ADC_GET_SAMPLINGTIME(hadc))
 8007484:	688a      	ldr	r2, [r1, #8]
 8007486:	2107      	movs	r1, #7
 8007488:	6968      	ldr	r0, [r5, #20]
 800748a:	4008      	ands	r0, r1
 800748c:	4282      	cmp	r2, r0
 800748e:	d006      	beq.n	800749e <HAL_ADC_ConfigChannel+0x62>
          hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 8007490:	6968      	ldr	r0, [r5, #20]
          hadc->Instance->SMPR |= ADC_SMPR_SET(sConfig->SamplingTime);
 8007492:	400a      	ands	r2, r1
          hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 8007494:	4388      	bics	r0, r1
 8007496:	6168      	str	r0, [r5, #20]
          hadc->Instance->SMPR |= ADC_SMPR_SET(sConfig->SamplingTime);
 8007498:	6968      	ldr	r0, [r5, #20]
 800749a:	4302      	orrs	r2, r0
 800749c:	616a      	str	r2, [r5, #20]
      if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 800749e:	2f02      	cmp	r7, #2
 80074a0:	d903      	bls.n	80074aa <HAL_ADC_ConfigChannel+0x6e>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80074a2:	2000      	movs	r0, #0
  __HAL_UNLOCK(hadc);
 80074a4:	2300      	movs	r3, #0
 80074a6:	7023      	strb	r3, [r4, #0]
}
 80074a8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        ADC->CCR |= ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 80074aa:	4a1e      	ldr	r2, [pc, #120]	; (8007524 <HAL_ADC_ConfigChannel+0xe8>)
 80074ac:	2080      	movs	r0, #128	; 0x80
 80074ae:	6811      	ldr	r1, [r2, #0]
 80074b0:	2b10      	cmp	r3, #16
 80074b2:	d015      	beq.n	80074e0 <HAL_ADC_ConfigChannel+0xa4>
 80074b4:	2b11      	cmp	r3, #17
 80074b6:	d115      	bne.n	80074e4 <HAL_ADC_ConfigChannel+0xa8>
 80074b8:	03c0      	lsls	r0, r0, #15
 80074ba:	4301      	orrs	r1, r0
 80074bc:	6011      	str	r1, [r2, #0]
        if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80074be:	2b10      	cmp	r3, #16
 80074c0:	d1ef      	bne.n	80074a2 <HAL_ADC_ConfigChannel+0x66>
          wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 80074c2:	4b19      	ldr	r3, [pc, #100]	; (8007528 <HAL_ADC_ConfigChannel+0xec>)
 80074c4:	4919      	ldr	r1, [pc, #100]	; (800752c <HAL_ADC_ConfigChannel+0xf0>)
 80074c6:	6818      	ldr	r0, [r3, #0]
 80074c8:	f7fe fa7e 	bl	80059c8 <__udivsi3>
 80074cc:	230a      	movs	r3, #10
 80074ce:	4358      	muls	r0, r3
 80074d0:	9001      	str	r0, [sp, #4]
          while(wait_loop_index != 0U)
 80074d2:	9b01      	ldr	r3, [sp, #4]
 80074d4:	2b00      	cmp	r3, #0
 80074d6:	d0e4      	beq.n	80074a2 <HAL_ADC_ConfigChannel+0x66>
            wait_loop_index--;
 80074d8:	9b01      	ldr	r3, [sp, #4]
 80074da:	3b01      	subs	r3, #1
 80074dc:	9301      	str	r3, [sp, #4]
 80074de:	e7f8      	b.n	80074d2 <HAL_ADC_ConfigChannel+0x96>
        ADC->CCR |= ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 80074e0:	0400      	lsls	r0, r0, #16
 80074e2:	e7ea      	b.n	80074ba <HAL_ADC_ConfigChannel+0x7e>
 80074e4:	0440      	lsls	r0, r0, #17
 80074e6:	e7e8      	b.n	80074ba <HAL_ADC_ConfigChannel+0x7e>
      hadc->Instance->CHSELR &= ~ADC_CHSELR_CHANNEL(sConfig->Channel);
 80074e8:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 80074ea:	4391      	bics	r1, r2
 80074ec:	62a9      	str	r1, [r5, #40]	; 0x28
      if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 80074ee:	2f02      	cmp	r7, #2
 80074f0:	d8d7      	bhi.n	80074a2 <HAL_ADC_ConfigChannel+0x66>
        ADC->CCR &= ~ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 80074f2:	4a0c      	ldr	r2, [pc, #48]	; (8007524 <HAL_ADC_ConfigChannel+0xe8>)
 80074f4:	6811      	ldr	r1, [r2, #0]
 80074f6:	2b10      	cmp	r3, #16
 80074f8:	d00a      	beq.n	8007510 <HAL_ADC_ConfigChannel+0xd4>
 80074fa:	3b11      	subs	r3, #17
 80074fc:	1e58      	subs	r0, r3, #1
 80074fe:	4183      	sbcs	r3, r0
 8007500:	480b      	ldr	r0, [pc, #44]	; (8007530 <HAL_ADC_ConfigChannel+0xf4>)
 8007502:	425b      	negs	r3, r3
 8007504:	4003      	ands	r3, r0
 8007506:	480b      	ldr	r0, [pc, #44]	; (8007534 <HAL_ADC_ConfigChannel+0xf8>)
 8007508:	181b      	adds	r3, r3, r0
 800750a:	400b      	ands	r3, r1
 800750c:	6013      	str	r3, [r2, #0]
 800750e:	e7c8      	b.n	80074a2 <HAL_ADC_ConfigChannel+0x66>
 8007510:	4b09      	ldr	r3, [pc, #36]	; (8007538 <HAL_ADC_ConfigChannel+0xfc>)
 8007512:	e7fa      	b.n	800750a <HAL_ADC_ConfigChannel+0xce>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8007514:	2120      	movs	r1, #32
 8007516:	6c58      	ldr	r0, [r3, #68]	; 0x44
 8007518:	4301      	orrs	r1, r0
 800751a:	6459      	str	r1, [r3, #68]	; 0x44
    tmp_hal_status = HAL_ERROR;
 800751c:	0010      	movs	r0, r2
 800751e:	e7c1      	b.n	80074a4 <HAL_ADC_ConfigChannel+0x68>
 8007520:	00001001 	.word	0x00001001
 8007524:	40012708 	.word	0x40012708
 8007528:	20000030 	.word	0x20000030
 800752c:	000f4240 	.word	0x000f4240
 8007530:	ff400000 	.word	0xff400000
 8007534:	ffbfffff 	.word	0xffbfffff
 8007538:	ff7fffff 	.word	0xff7fffff

0800753c <HAL_ADCEx_Calibration_Start>:
  *         HAL_ADC_GetValue() (value on 7 bits: from DR[6;0]).
  * @param  hadc: ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef* hadc)
{
 800753c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Process locked */
  __HAL_LOCK(hadc);
 800753e:	0006      	movs	r6, r0
 8007540:	3640      	adds	r6, #64	; 0x40
 8007542:	7833      	ldrb	r3, [r6, #0]
{
 8007544:	0004      	movs	r4, r0
  __HAL_LOCK(hadc);
 8007546:	2002      	movs	r0, #2
 8007548:	2b01      	cmp	r3, #1
 800754a:	d042      	beq.n	80075d2 <HAL_ADCEx_Calibration_Start+0x96>
 800754c:	2301      	movs	r3, #1
  
  /* Calibration prerequisite: ADC must be disabled. */
  if (ADC_IS_ENABLE(hadc) == RESET)
 800754e:	2103      	movs	r1, #3
  __HAL_LOCK(hadc);
 8007550:	7033      	strb	r3, [r6, #0]
  if (ADC_IS_ENABLE(hadc) == RESET)
 8007552:	6823      	ldr	r3, [r4, #0]
 8007554:	689a      	ldr	r2, [r3, #8]
 8007556:	400a      	ands	r2, r1
 8007558:	2a01      	cmp	r2, #1
 800755a:	d105      	bne.n	8007568 <HAL_ADCEx_Calibration_Start+0x2c>
 800755c:	6819      	ldr	r1, [r3, #0]
 800755e:	4211      	tst	r1, r2
 8007560:	d138      	bne.n	80075d4 <HAL_ADCEx_Calibration_Start+0x98>
 8007562:	68da      	ldr	r2, [r3, #12]
 8007564:	0412      	lsls	r2, r2, #16
 8007566:	d435      	bmi.n	80075d4 <HAL_ADCEx_Calibration_Start+0x98>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State, 
 8007568:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800756a:	491d      	ldr	r1, [pc, #116]	; (80075e0 <HAL_ADCEx_Calibration_Start+0xa4>)
 800756c:	4011      	ands	r1, r2
 800756e:	2202      	movs	r2, #2
 8007570:	430a      	orrs	r2, r1
    /*       available in data register and also transfered by DMA.           */
    /*       To not insert ADC calibration factor among ADC conversion data   */
    /*       in array variable, DMA transfer must be disabled during          */
    /*       calibration.                                                     */
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 8007572:	2103      	movs	r1, #3
    ADC_STATE_CLR_SET(hadc->State, 
 8007574:	6462      	str	r2, [r4, #68]	; 0x44
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 8007576:	68dd      	ldr	r5, [r3, #12]
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 8007578:	68da      	ldr	r2, [r3, #12]
 800757a:	438a      	bics	r2, r1
 800757c:	60da      	str	r2, [r3, #12]

    /* Start ADC calibration */
    hadc->Instance->CR |= ADC_CR_ADCAL;
 800757e:	2280      	movs	r2, #128	; 0x80
 8007580:	6899      	ldr	r1, [r3, #8]
 8007582:	0612      	lsls	r2, r2, #24
 8007584:	430a      	orrs	r2, r1
 8007586:	609a      	str	r2, [r3, #8]

    tickstart = HAL_GetTick();  
 8007588:	f7ff fdba 	bl	8007100 <HAL_GetTick>
 800758c:	0007      	movs	r7, r0

    /* Wait for calibration completion */
    while(HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADCAL))
 800758e:	6823      	ldr	r3, [r4, #0]
 8007590:	689a      	ldr	r2, [r3, #8]
 8007592:	2a00      	cmp	r2, #0
 8007594:	db0e      	blt.n	80075b4 <HAL_ADCEx_Calibration_Start+0x78>
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 8007596:	2203      	movs	r2, #3
        return HAL_ERROR;
      }
    }
    
    /* Restore ADC DMA transfer request after calibration */
    SET_BIT(hadc->Instance->CFGR1, backup_setting_adc_dma_transfer);
 8007598:	68d9      	ldr	r1, [r3, #12]
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 800759a:	4015      	ands	r5, r2
    SET_BIT(hadc->Instance->CFGR1, backup_setting_adc_dma_transfer);
 800759c:	430d      	orrs	r5, r1
 800759e:	60dd      	str	r5, [r3, #12]

    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 80075a0:	6c63      	ldr	r3, [r4, #68]	; 0x44
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80075a2:	2000      	movs	r0, #0
    ADC_STATE_CLR_SET(hadc->State,
 80075a4:	4393      	bics	r3, r2
 80075a6:	001a      	movs	r2, r3
 80075a8:	2301      	movs	r3, #1
 80075aa:	4313      	orrs	r3, r2
 80075ac:	6463      	str	r3, [r4, #68]	; 0x44
    
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80075ae:	2300      	movs	r3, #0
 80075b0:	7033      	strb	r3, [r6, #0]
  
  /* Return function status */
  return tmp_hal_status;
 80075b2:	e00e      	b.n	80075d2 <HAL_ADCEx_Calibration_Start+0x96>
      if((HAL_GetTick() - tickstart) > ADC_CALIBRATION_TIMEOUT)
 80075b4:	f7ff fda4 	bl	8007100 <HAL_GetTick>
 80075b8:	1bc0      	subs	r0, r0, r7
 80075ba:	2802      	cmp	r0, #2
 80075bc:	d9e7      	bls.n	800758e <HAL_ADCEx_Calibration_Start+0x52>
        ADC_STATE_CLR_SET(hadc->State,
 80075be:	2212      	movs	r2, #18
 80075c0:	6c63      	ldr	r3, [r4, #68]	; 0x44
        return HAL_ERROR;
 80075c2:	2001      	movs	r0, #1
        ADC_STATE_CLR_SET(hadc->State,
 80075c4:	4393      	bics	r3, r2
 80075c6:	001a      	movs	r2, r3
 80075c8:	2310      	movs	r3, #16
 80075ca:	4313      	orrs	r3, r2
 80075cc:	6463      	str	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hadc);
 80075ce:	2300      	movs	r3, #0
 80075d0:	7033      	strb	r3, [r6, #0]
}
 80075d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80075d4:	2320      	movs	r3, #32
 80075d6:	6c62      	ldr	r2, [r4, #68]	; 0x44
    tmp_hal_status = HAL_ERROR;
 80075d8:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80075da:	4313      	orrs	r3, r2
 80075dc:	6463      	str	r3, [r4, #68]	; 0x44
 80075de:	e7e6      	b.n	80075ae <HAL_ADCEx_Calibration_Start+0x72>
 80075e0:	fffffefd 	.word	0xfffffefd

080075e4 <HAL_NVIC_SetPriority>:
  *         with stm32f0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0 based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80075e4:	b530      	push	{r4, r5, lr}
 80075e6:	25ff      	movs	r5, #255	; 0xff
 80075e8:	2403      	movs	r4, #3
 80075ea:	002a      	movs	r2, r5
 80075ec:	b2c3      	uxtb	r3, r0
 80075ee:	401c      	ands	r4, r3
 80075f0:	00e4      	lsls	r4, r4, #3
 80075f2:	40a2      	lsls	r2, r4
 80075f4:	0189      	lsls	r1, r1, #6
 80075f6:	4029      	ands	r1, r5
 80075f8:	43d2      	mvns	r2, r2
 80075fa:	40a1      	lsls	r1, r4
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 80075fc:	2800      	cmp	r0, #0
 80075fe:	da0b      	bge.n	8007618 <HAL_NVIC_SetPriority+0x34>
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8007600:	200f      	movs	r0, #15
 8007602:	4003      	ands	r3, r0
 8007604:	3b08      	subs	r3, #8
 8007606:	480a      	ldr	r0, [pc, #40]	; (8007630 <HAL_NVIC_SetPriority+0x4c>)
 8007608:	089b      	lsrs	r3, r3, #2
 800760a:	009b      	lsls	r3, r3, #2
 800760c:	181b      	adds	r3, r3, r0
 800760e:	69d8      	ldr	r0, [r3, #28]
 8007610:	4002      	ands	r2, r0
 8007612:	4311      	orrs	r1, r2
 8007614:	61d9      	str	r1, [r3, #28]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
}
 8007616:	bd30      	pop	{r4, r5, pc}
 8007618:	4b06      	ldr	r3, [pc, #24]	; (8007634 <HAL_NVIC_SetPriority+0x50>)
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800761a:	0880      	lsrs	r0, r0, #2
 800761c:	0080      	lsls	r0, r0, #2
 800761e:	18c0      	adds	r0, r0, r3
 8007620:	23c0      	movs	r3, #192	; 0xc0
 8007622:	009b      	lsls	r3, r3, #2
 8007624:	58c4      	ldr	r4, [r0, r3]
 8007626:	4022      	ands	r2, r4
 8007628:	4311      	orrs	r1, r2
 800762a:	50c1      	str	r1, [r0, r3]
 800762c:	e7f3      	b.n	8007616 <HAL_NVIC_SetPriority+0x32>
 800762e:	46c0      	nop			; (mov r8, r8)
 8007630:	e000ed00 	.word	0xe000ed00
 8007634:	e000e100 	.word	0xe000e100

08007638 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8007638:	231f      	movs	r3, #31
 800763a:	4018      	ands	r0, r3
 800763c:	3b1e      	subs	r3, #30
 800763e:	4083      	lsls	r3, r0
 8007640:	4a01      	ldr	r2, [pc, #4]	; (8007648 <HAL_NVIC_EnableIRQ+0x10>)
 8007642:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8007644:	4770      	bx	lr
 8007646:	46c0      	nop			; (mov r8, r8)
 8007648:	e000e100 	.word	0xe000e100

0800764c <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800764c:	4a09      	ldr	r2, [pc, #36]	; (8007674 <HAL_SYSTICK_Config+0x28>)
 800764e:	1e43      	subs	r3, r0, #1
  {
    return (1UL);                                                   /* Reload value impossible */
 8007650:	2001      	movs	r0, #1
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8007652:	4293      	cmp	r3, r2
 8007654:	d80d      	bhi.n	8007672 <HAL_SYSTICK_Config+0x26>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8007656:	21c0      	movs	r1, #192	; 0xc0
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8007658:	4a07      	ldr	r2, [pc, #28]	; (8007678 <HAL_SYSTICK_Config+0x2c>)
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800765a:	4808      	ldr	r0, [pc, #32]	; (800767c <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800765c:	6053      	str	r3, [r2, #4]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800765e:	6a03      	ldr	r3, [r0, #32]
 8007660:	0609      	lsls	r1, r1, #24
 8007662:	021b      	lsls	r3, r3, #8
 8007664:	0a1b      	lsrs	r3, r3, #8
 8007666:	430b      	orrs	r3, r1
 8007668:	6203      	str	r3, [r0, #32]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800766a:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800766c:	2307      	movs	r3, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800766e:	6090      	str	r0, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8007670:	6013      	str	r3, [r2, #0]
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8007672:	4770      	bx	lr
 8007674:	00ffffff 	.word	0x00ffffff
 8007678:	e000e010 	.word	0xe000e010
 800767c:	e000ed00 	.word	0xe000ed00

08007680 <CRC_Handle_8>:
  * @param  pBuffer: pointer to the input data buffer
  * @param  BufferLength: input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 8007680:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8007682:	000e      	movs	r6, r1
  uint32_t i = 0U; /* input data buffer index */
  
   /* Processing time optimization: 4 bytes are entered in a row with a single word write,
    * last bytes must be carefully fed to the CRC calculator to ensure a correct type
    * handling by the IP */
   for(i = 0U; i < (BufferLength/4U); i++)
 8007684:	0895      	lsrs	r5, r2, #2
 8007686:	00ad      	lsls	r5, r5, #2
 8007688:	186b      	adds	r3, r5, r1
 800768a:	9301      	str	r3, [sp, #4]
 800768c:	6803      	ldr	r3, [r0, #0]
 800768e:	9c01      	ldr	r4, [sp, #4]
 8007690:	42a6      	cmp	r6, r4
 8007692:	d107      	bne.n	80076a4 <CRC_Handle_8+0x24>
   {
      hcrc->Instance->DR = ((uint32_t)pBuffer[4U*i]<<24U) | ((uint32_t)pBuffer[4U*i+1]<<16U) | ((uint32_t)pBuffer[4U*i+2]<<8U) | (uint32_t)pBuffer[4U*i+3];      
   }
   /* last bytes specific handling */
   if ((BufferLength%4U) != 0U)
 8007694:	2403      	movs	r4, #3
 8007696:	4022      	ands	r2, r4
 8007698:	d019      	beq.n	80076ce <CRC_Handle_8+0x4e>
   {
     if  (BufferLength%4U == 1U)
 800769a:	2a01      	cmp	r2, #1
 800769c:	d10f      	bne.n	80076be <CRC_Handle_8+0x3e>
     {
       *(uint8_t volatile*) (&hcrc->Instance->DR) = pBuffer[4*i];
 800769e:	5d4a      	ldrb	r2, [r1, r5]
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
     }
     if  (BufferLength%4U == 3U)
     {
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
       *(uint8_t volatile*) (&hcrc->Instance->DR) = pBuffer[4*i+2];       
 80076a0:	701a      	strb	r2, [r3, #0]
 80076a2:	e014      	b.n	80076ce <CRC_Handle_8+0x4e>
      hcrc->Instance->DR = ((uint32_t)pBuffer[4U*i]<<24U) | ((uint32_t)pBuffer[4U*i+1]<<16U) | ((uint32_t)pBuffer[4U*i+2]<<8U) | (uint32_t)pBuffer[4U*i+3];      
 80076a4:	7834      	ldrb	r4, [r6, #0]
 80076a6:	7877      	ldrb	r7, [r6, #1]
 80076a8:	0624      	lsls	r4, r4, #24
 80076aa:	043f      	lsls	r7, r7, #16
 80076ac:	433c      	orrs	r4, r7
 80076ae:	78f7      	ldrb	r7, [r6, #3]
 80076b0:	433c      	orrs	r4, r7
 80076b2:	78b7      	ldrb	r7, [r6, #2]
 80076b4:	3604      	adds	r6, #4
 80076b6:	023f      	lsls	r7, r7, #8
 80076b8:	433c      	orrs	r4, r7
 80076ba:	601c      	str	r4, [r3, #0]
 80076bc:	e7e7      	b.n	800768e <CRC_Handle_8+0xe>
 80076be:	186c      	adds	r4, r5, r1
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
 80076c0:	5d49      	ldrb	r1, [r1, r5]
 80076c2:	0209      	lsls	r1, r1, #8
     if  (BufferLength%4U == 2U)
 80076c4:	2a02      	cmp	r2, #2
 80076c6:	d105      	bne.n	80076d4 <CRC_Handle_8+0x54>
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
 80076c8:	7862      	ldrb	r2, [r4, #1]
 80076ca:	430a      	orrs	r2, r1
 80076cc:	801a      	strh	r2, [r3, #0]
     }
   }
  
  /* Return the CRC computed value */ 
  return hcrc->Instance->DR;
 80076ce:	6803      	ldr	r3, [r0, #0]
 80076d0:	6818      	ldr	r0, [r3, #0]
}
 80076d2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
 80076d4:	7862      	ldrb	r2, [r4, #1]
 80076d6:	430a      	orrs	r2, r1
 80076d8:	801a      	strh	r2, [r3, #0]
       *(uint8_t volatile*) (&hcrc->Instance->DR) = pBuffer[4*i+2];       
 80076da:	78a2      	ldrb	r2, [r4, #2]
 80076dc:	e7e0      	b.n	80076a0 <CRC_Handle_8+0x20>

080076de <CRC_Handle_16>:
  * @param  pBuffer: pointer to the input data buffer
  * @param  BufferLength: input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */  
static uint32_t CRC_Handle_16(CRC_HandleTypeDef *hcrc, uint16_t pBuffer[], uint32_t BufferLength)
{
 80076de:	b5f0      	push	{r4, r5, r6, r7, lr}
 80076e0:	000d      	movs	r5, r1
  uint32_t i = 0U;  /* input data buffer index */
  
  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure 
   * a correct type handling by the IP */
  for(i = 0U; i < (BufferLength/2U); i++)
 80076e2:	2600      	movs	r6, #0
 80076e4:	6800      	ldr	r0, [r0, #0]
 80076e6:	0854      	lsrs	r4, r2, #1
 80076e8:	42b4      	cmp	r4, r6
 80076ea:	d106      	bne.n	80076fa <CRC_Handle_16+0x1c>
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U*i]<<16U) | (uint32_t)pBuffer[2U*i+1];     
  }
  if ((BufferLength%2U) != 0U)
 80076ec:	07d3      	lsls	r3, r2, #31
 80076ee:	d502      	bpl.n	80076f6 <CRC_Handle_16+0x18>
  {
       *(uint16_t volatile*) (&hcrc->Instance->DR) = pBuffer[2*i]; 
 80076f0:	00a4      	lsls	r4, r4, #2
 80076f2:	5a63      	ldrh	r3, [r4, r1]
 80076f4:	8003      	strh	r3, [r0, #0]
  }
   
  /* Return the CRC computed value */ 
  return hcrc->Instance->DR;
 80076f6:	6800      	ldr	r0, [r0, #0]
}
 80076f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U*i]<<16U) | (uint32_t)pBuffer[2U*i+1];     
 80076fa:	882b      	ldrh	r3, [r5, #0]
 80076fc:	886f      	ldrh	r7, [r5, #2]
 80076fe:	041b      	lsls	r3, r3, #16
 8007700:	433b      	orrs	r3, r7
 8007702:	6003      	str	r3, [r0, #0]
  for(i = 0U; i < (BufferLength/2U); i++)
 8007704:	3601      	adds	r6, #1
 8007706:	3504      	adds	r5, #4
 8007708:	e7ee      	b.n	80076e8 <CRC_Handle_16+0xa>

0800770a <HAL_CRC_Init>:
{
 800770a:	b510      	push	{r4, lr}
 800770c:	1e04      	subs	r4, r0, #0
  if(hcrc == NULL)
 800770e:	d101      	bne.n	8007714 <HAL_CRC_Init+0xa>
    return HAL_ERROR;
 8007710:	2001      	movs	r0, #1
}
 8007712:	bd10      	pop	{r4, pc}
  if(hcrc->State == HAL_CRC_STATE_RESET)
 8007714:	7f43      	ldrb	r3, [r0, #29]
 8007716:	b2db      	uxtb	r3, r3
 8007718:	2b00      	cmp	r3, #0
 800771a:	d102      	bne.n	8007722 <HAL_CRC_Init+0x18>
    hcrc->Lock = HAL_UNLOCKED;
 800771c:	7703      	strb	r3, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 800771e:	f7fe fc65 	bl	8005fec <HAL_CRC_MspInit>
  hcrc->State = HAL_CRC_STATE_BUSY; 
 8007722:	2302      	movs	r3, #2
  if (HAL_CRCEx_Init(hcrc) != HAL_OK)
 8007724:	0020      	movs	r0, r4
  hcrc->State = HAL_CRC_STATE_BUSY; 
 8007726:	7763      	strb	r3, [r4, #29]
  if (HAL_CRCEx_Init(hcrc) != HAL_OK)
 8007728:	f000 f870 	bl	800780c <HAL_CRCEx_Init>
 800772c:	2800      	cmp	r0, #0
 800772e:	d1ef      	bne.n	8007710 <HAL_CRC_Init+0x6>
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 8007730:	7962      	ldrb	r2, [r4, #5]
 8007732:	6823      	ldr	r3, [r4, #0]
 8007734:	2a00      	cmp	r2, #0
 8007736:	d110      	bne.n	800775a <HAL_CRC_Init+0x50>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);  
 8007738:	3a01      	subs	r2, #1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 800773a:	2160      	movs	r1, #96	; 0x60
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 800773c:	611a      	str	r2, [r3, #16]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 800773e:	689a      	ldr	r2, [r3, #8]
 8007740:	438a      	bics	r2, r1
 8007742:	6961      	ldr	r1, [r4, #20]
 8007744:	430a      	orrs	r2, r1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);  
 8007746:	2180      	movs	r1, #128	; 0x80
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 8007748:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);  
 800774a:	689a      	ldr	r2, [r3, #8]
 800774c:	438a      	bics	r2, r1
 800774e:	69a1      	ldr	r1, [r4, #24]
 8007750:	430a      	orrs	r2, r1
 8007752:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 8007754:	2301      	movs	r3, #1
 8007756:	7763      	strb	r3, [r4, #29]
  return HAL_OK;
 8007758:	e7db      	b.n	8007712 <HAL_CRC_Init+0x8>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 800775a:	6922      	ldr	r2, [r4, #16]
 800775c:	e7ed      	b.n	800773a <HAL_CRC_Init+0x30>

0800775e <HAL_CRC_Calculate>:
{
 800775e:	b570      	push	{r4, r5, r6, lr}
 8007760:	2502      	movs	r5, #2
  __HAL_LOCK(hcrc); 
 8007762:	7f03      	ldrb	r3, [r0, #28]
{
 8007764:	0004      	movs	r4, r0
  __HAL_LOCK(hcrc); 
 8007766:	0028      	movs	r0, r5
 8007768:	2b01      	cmp	r3, #1
 800776a:	d01b      	beq.n	80077a4 <HAL_CRC_Calculate+0x46>
 800776c:	2301      	movs	r3, #1
  __HAL_CRC_DR_RESET(hcrc);
 800776e:	6820      	ldr	r0, [r4, #0]
  hcrc->State = HAL_CRC_STATE_BUSY;
 8007770:	7765      	strb	r5, [r4, #29]
  __HAL_CRC_DR_RESET(hcrc);
 8007772:	6885      	ldr	r5, [r0, #8]
  __HAL_LOCK(hcrc); 
 8007774:	7723      	strb	r3, [r4, #28]
  __HAL_CRC_DR_RESET(hcrc);
 8007776:	432b      	orrs	r3, r5
 8007778:	6083      	str	r3, [r0, #8]
  switch (hcrc->InputDataFormat)
 800777a:	6a23      	ldr	r3, [r4, #32]
 800777c:	2b02      	cmp	r3, #2
 800777e:	d015      	beq.n	80077ac <HAL_CRC_Calculate+0x4e>
 8007780:	2b03      	cmp	r3, #3
 8007782:	d006      	beq.n	8007792 <HAL_CRC_Calculate+0x34>
  uint32_t temp = 0U;  /* CRC output (read from hcrc->Instance->DR register) */
 8007784:	2000      	movs	r0, #0
  switch (hcrc->InputDataFormat)
 8007786:	2b01      	cmp	r3, #1
 8007788:	d108      	bne.n	800779c <HAL_CRC_Calculate+0x3e>
      temp = CRC_Handle_8(hcrc, (uint8_t*)pBuffer, BufferLength);
 800778a:	0020      	movs	r0, r4
 800778c:	f7ff ff78 	bl	8007680 <CRC_Handle_8>
      break;
 8007790:	e004      	b.n	800779c <HAL_CRC_Calculate+0x3e>
 8007792:	0092      	lsls	r2, r2, #2
 8007794:	188a      	adds	r2, r1, r2
      for(index = 0U; index < BufferLength; index++)
 8007796:	4291      	cmp	r1, r2
 8007798:	d105      	bne.n	80077a6 <HAL_CRC_Calculate+0x48>
      temp = hcrc->Instance->DR;
 800779a:	6800      	ldr	r0, [r0, #0]
  hcrc->State = HAL_CRC_STATE_READY; 
 800779c:	2301      	movs	r3, #1
 800779e:	7763      	strb	r3, [r4, #29]
  __HAL_UNLOCK(hcrc);
 80077a0:	2300      	movs	r3, #0
 80077a2:	7723      	strb	r3, [r4, #28]
}
 80077a4:	bd70      	pop	{r4, r5, r6, pc}
        hcrc->Instance->DR = pBuffer[index];
 80077a6:	c908      	ldmia	r1!, {r3}
 80077a8:	6003      	str	r3, [r0, #0]
 80077aa:	e7f4      	b.n	8007796 <HAL_CRC_Calculate+0x38>
      temp = CRC_Handle_16(hcrc, (uint16_t*)pBuffer, BufferLength);
 80077ac:	0020      	movs	r0, r4
 80077ae:	f7ff ff96 	bl	80076de <CRC_Handle_16>
      break;
 80077b2:	e7f3      	b.n	800779c <HAL_CRC_Calculate+0x3e>

080077b4 <HAL_CRCEx_Polynomial_Set>:
  *          @arg CRC_POLYLENGTH_16B: 16-bit long CRC (generating polynomial of degree 16)
  *          @arg CRC_POLYLENGTH_32B: 32-bit long CRC (generating polynomial of degree 32)                
  * @retval HAL status
  */                                   
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
 80077b4:	b530      	push	{r4, r5, lr}
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 80077b6:	231f      	movs	r3, #31
{
 80077b8:	0004      	movs	r4, r0
   * definition. HAL_ERROR is reported if Pol degree is 
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while (((Pol & (1U << msb)) == 0U) && (msb-- > 0U))
 80077ba:	2001      	movs	r0, #1
 80077bc:	0005      	movs	r5, r0
 80077be:	409d      	lsls	r5, r3
 80077c0:	4229      	tst	r1, r5
 80077c2:	d109      	bne.n	80077d8 <HAL_CRCEx_Polynomial_Set+0x24>
 80077c4:	3b01      	subs	r3, #1
 80077c6:	d2f9      	bcs.n	80077bc <HAL_CRCEx_Polynomial_Set+0x8>
  {}

  switch (PolyLength)
 80077c8:	2a10      	cmp	r2, #16
 80077ca:	d003      	beq.n	80077d4 <HAL_CRCEx_Polynomial_Set+0x20>
 80077cc:	2a18      	cmp	r2, #24
 80077ce:	d001      	beq.n	80077d4 <HAL_CRCEx_Polynomial_Set+0x20>
 80077d0:	2a08      	cmp	r2, #8
 80077d2:	d112      	bne.n	80077fa <HAL_CRCEx_Polynomial_Set+0x46>
  {
    case CRC_POLYLENGTH_7B:
      if (msb >= HAL_CRC_LENGTH_7B)
      {
        return  HAL_ERROR;
 80077d4:	2001      	movs	r0, #1
 80077d6:	e00c      	b.n	80077f2 <HAL_CRCEx_Polynomial_Set+0x3e>
  switch (PolyLength)
 80077d8:	2a10      	cmp	r2, #16
 80077da:	d00b      	beq.n	80077f4 <HAL_CRCEx_Polynomial_Set+0x40>
 80077dc:	2a18      	cmp	r2, #24
 80077de:	d005      	beq.n	80077ec <HAL_CRCEx_Polynomial_Set+0x38>
 80077e0:	2a08      	cmp	r2, #8
 80077e2:	d10a      	bne.n	80077fa <HAL_CRCEx_Polynomial_Set+0x46>
        return  HAL_ERROR;
 80077e4:	2001      	movs	r0, #1
      { 
        return  HAL_ERROR;
      }
      break;
    case CRC_POLYLENGTH_16B:
      if (msb >= HAL_CRC_LENGTH_16B)
 80077e6:	2b0f      	cmp	r3, #15
 80077e8:	d907      	bls.n	80077fa <HAL_CRCEx_Polynomial_Set+0x46>
 80077ea:	e002      	b.n	80077f2 <HAL_CRCEx_Polynomial_Set+0x3e>
        return  HAL_ERROR;
 80077ec:	2001      	movs	r0, #1
      if (msb >= HAL_CRC_LENGTH_7B)
 80077ee:	2b06      	cmp	r3, #6
 80077f0:	d903      	bls.n	80077fa <HAL_CRCEx_Polynomial_Set+0x46>
  /* set generating polynomial size */
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);  
  
  /* Return function status */
  return HAL_OK;
}
 80077f2:	bd30      	pop	{r4, r5, pc}
        return  HAL_ERROR;
 80077f4:	2001      	movs	r0, #1
      if (msb >= HAL_CRC_LENGTH_8B)
 80077f6:	2b07      	cmp	r3, #7
 80077f8:	d8fb      	bhi.n	80077f2 <HAL_CRCEx_Polynomial_Set+0x3e>
  WRITE_REG(hcrc->Instance->POL, Pol);
 80077fa:	6820      	ldr	r0, [r4, #0]
 80077fc:	6141      	str	r1, [r0, #20]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);  
 80077fe:	2118      	movs	r1, #24
 8007800:	6883      	ldr	r3, [r0, #8]
 8007802:	438b      	bics	r3, r1
 8007804:	431a      	orrs	r2, r3
 8007806:	6082      	str	r2, [r0, #8]
 8007808:	2000      	movs	r0, #0
 800780a:	e7f2      	b.n	80077f2 <HAL_CRCEx_Polynomial_Set+0x3e>

0800780c <HAL_CRCEx_Init>:
{
 800780c:	b510      	push	{r4, lr}
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 800780e:	7903      	ldrb	r3, [r0, #4]
 8007810:	2b00      	cmp	r3, #0
 8007812:	d108      	bne.n	8007826 <HAL_CRCEx_Init+0x1a>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);  
 8007814:	6802      	ldr	r2, [r0, #0]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 8007816:	2018      	movs	r0, #24
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);  
 8007818:	4907      	ldr	r1, [pc, #28]	; (8007838 <HAL_CRCEx_Init+0x2c>)
 800781a:	6151      	str	r1, [r2, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 800781c:	6891      	ldr	r1, [r2, #8]
 800781e:	4381      	bics	r1, r0
   return HAL_OK;
 8007820:	0018      	movs	r0, r3
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 8007822:	6091      	str	r1, [r2, #8]
}
 8007824:	bd10      	pop	{r4, pc}
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 8007826:	68c2      	ldr	r2, [r0, #12]
 8007828:	6881      	ldr	r1, [r0, #8]
 800782a:	f7ff ffc3 	bl	80077b4 <HAL_CRCEx_Polynomial_Set>
 800782e:	1e43      	subs	r3, r0, #1
 8007830:	4198      	sbcs	r0, r3
      return HAL_ERROR;
 8007832:	b2c0      	uxtb	r0, r0
 8007834:	e7f6      	b.n	8007824 <HAL_CRCEx_Init+0x18>
 8007836:	46c0      	nop			; (mov r8, r8)
 8007838:	04c11db7 	.word	0x04c11db7

0800783c <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
 800783c:	b570      	push	{r4, r5, r6, lr}
 800783e:	0004      	movs	r4, r0
  uint32_t tmp = 0U;
  
  /* Check the DMA handle allocation */
  if(NULL == hdma)
  {
    return HAL_ERROR;
 8007840:	2501      	movs	r5, #1
  if(NULL == hdma)
 8007842:	2800      	cmp	r0, #0
 8007844:	d028      	beq.n	8007898 <HAL_DMA_Init+0x5c>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
  
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8007846:	2302      	movs	r3, #2
 8007848:	1c86      	adds	r6, r0, #2

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 800784a:	6800      	ldr	r0, [r0, #0]
  hdma->State = HAL_DMA_STATE_BUSY;
 800784c:	77f3      	strb	r3, [r6, #31]
  tmp = hdma->Instance->CCR;
 800784e:	6802      	ldr	r2, [r0, #0]
  
  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8007850:	4b12      	ldr	r3, [pc, #72]	; (800789c <HAL_DMA_Init+0x60>)
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8007852:	68a1      	ldr	r1, [r4, #8]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8007854:	401a      	ands	r2, r3
  tmp |=  hdma->Init.Direction        |
 8007856:	6863      	ldr	r3, [r4, #4]
 8007858:	430b      	orrs	r3, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800785a:	68e1      	ldr	r1, [r4, #12]
 800785c:	430b      	orrs	r3, r1
 800785e:	6921      	ldr	r1, [r4, #16]
 8007860:	430b      	orrs	r3, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8007862:	6961      	ldr	r1, [r4, #20]
 8007864:	430b      	orrs	r3, r1
 8007866:	69a1      	ldr	r1, [r4, #24]
 8007868:	430b      	orrs	r3, r1
          hdma->Init.Mode                | hdma->Init.Priority;
 800786a:	69e1      	ldr	r1, [r4, #28]
 800786c:	430b      	orrs	r3, r1
  tmp |=  hdma->Init.Direction        |
 800786e:	4313      	orrs	r3, r2

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;  
 8007870:	6003      	str	r3, [r0, #0]
    hdma->DmaBaseAddress = DMA2;
  }
#else
  /* calculation of the channel index */
  /* DMA1 */
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 8007872:	4b0b      	ldr	r3, [pc, #44]	; (80078a0 <HAL_DMA_Init+0x64>)
 8007874:	2114      	movs	r1, #20
 8007876:	18c0      	adds	r0, r0, r3
 8007878:	f7fe f8a6 	bl	80059c8 <__udivsi3>
  hdma->DmaBaseAddress = DMA1;
 800787c:	4b09      	ldr	r3, [pc, #36]	; (80078a4 <HAL_DMA_Init+0x68>)
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 800787e:	0080      	lsls	r0, r0, #2
  hdma->DmaBaseAddress = DMA1;
 8007880:	63e3      	str	r3, [r4, #60]	; 0x3c
  hdma->XferCpltCallback = NULL;
 8007882:	2300      	movs	r3, #0
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 8007884:	6420      	str	r0, [r4, #64]	; 0x40
  hdma->XferCpltCallback = NULL;
 8007886:	62a3      	str	r3, [r4, #40]	; 0x28
  hdma->XferHalfCpltCallback = NULL;
 8007888:	62e3      	str	r3, [r4, #44]	; 0x2c
  hdma->XferErrorCallback = NULL;
 800788a:	6323      	str	r3, [r4, #48]	; 0x30
  hdma->XferAbortCallback = NULL;
 800788c:	6363      	str	r3, [r4, #52]	; 0x34
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800788e:	63a3      	str	r3, [r4, #56]	; 0x38
  hdma->State = HAL_DMA_STATE_READY;
 8007890:	77f5      	strb	r5, [r6, #31]
  hdma->Lock = HAL_UNLOCKED;
 8007892:	1964      	adds	r4, r4, r5
  return HAL_OK;
 8007894:	001d      	movs	r5, r3
  hdma->Lock = HAL_UNLOCKED;
 8007896:	77e3      	strb	r3, [r4, #31]
}  
 8007898:	0028      	movs	r0, r5
 800789a:	bd70      	pop	{r4, r5, r6, pc}
 800789c:	ffffc00f 	.word	0xffffc00f
 80078a0:	bffdfff8 	.word	0xbffdfff8
 80078a4:	40020000 	.word	0x40020000

080078a8 <HAL_DMA_DeInit>:
{
 80078a8:	b570      	push	{r4, r5, r6, lr}
 80078aa:	0004      	movs	r4, r0
 80078ac:	2601      	movs	r6, #1
  if(NULL == hdma)
 80078ae:	2800      	cmp	r0, #0
 80078b0:	d019      	beq.n	80078e6 <HAL_DMA_DeInit+0x3e>
  hdma->Instance->CCR  = 0U;
 80078b2:	2500      	movs	r5, #0
  hdma->Instance->CCR &= ~DMA_CCR_EN;
 80078b4:	6800      	ldr	r0, [r0, #0]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80078b6:	2114      	movs	r1, #20
  hdma->Instance->CCR &= ~DMA_CCR_EN;
 80078b8:	6803      	ldr	r3, [r0, #0]
 80078ba:	43b3      	bics	r3, r6
 80078bc:	6003      	str	r3, [r0, #0]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80078be:	4b0b      	ldr	r3, [pc, #44]	; (80078ec <HAL_DMA_DeInit+0x44>)
  hdma->Instance->CCR  = 0U;
 80078c0:	6005      	str	r5, [r0, #0]
  hdma->Instance->CNDTR = 0U;
 80078c2:	6045      	str	r5, [r0, #4]
  hdma->Instance->CPAR  = 0U;
 80078c4:	6085      	str	r5, [r0, #8]
  hdma->Instance->CMAR = 0U;
 80078c6:	60c5      	str	r5, [r0, #12]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80078c8:	18c0      	adds	r0, r0, r3
 80078ca:	f7fe f87d 	bl	80059c8 <__udivsi3>
 80078ce:	0080      	lsls	r0, r0, #2
  hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 80078d0:	4086      	lsls	r6, r0
  hdma->DmaBaseAddress = DMA1;
 80078d2:	4b07      	ldr	r3, [pc, #28]	; (80078f0 <HAL_DMA_DeInit+0x48>)
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80078d4:	6420      	str	r0, [r4, #64]	; 0x40
  hdma->DmaBaseAddress = DMA1;
 80078d6:	63e3      	str	r3, [r4, #60]	; 0x3c
  hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 80078d8:	605e      	str	r6, [r3, #4]
  return HAL_OK;
 80078da:	002e      	movs	r6, r5
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80078dc:	63a5      	str	r5, [r4, #56]	; 0x38
  hdma->State = HAL_DMA_STATE_RESET;
 80078de:	1ca3      	adds	r3, r4, #2
  __HAL_UNLOCK(hdma);
 80078e0:	3401      	adds	r4, #1
  hdma->State = HAL_DMA_STATE_RESET;
 80078e2:	77dd      	strb	r5, [r3, #31]
  __HAL_UNLOCK(hdma);
 80078e4:	77e5      	strb	r5, [r4, #31]
}
 80078e6:	0030      	movs	r0, r6
 80078e8:	bd70      	pop	{r4, r5, r6, pc}
 80078ea:	46c0      	nop			; (mov r8, r8)
 80078ec:	bffdfff8 	.word	0xbffdfff8
 80078f0:	40020000 	.word	0x40020000

080078f4 <HAL_DMA_Start_IT>:
{
 80078f4:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(hdma);
 80078f6:	1c44      	adds	r4, r0, #1
 80078f8:	7fe6      	ldrb	r6, [r4, #31]
{
 80078fa:	0005      	movs	r5, r0
  __HAL_LOCK(hdma);
 80078fc:	2002      	movs	r0, #2
 80078fe:	2e01      	cmp	r6, #1
 8007900:	d027      	beq.n	8007952 <HAL_DMA_Start_IT+0x5e>
 8007902:	3801      	subs	r0, #1
 8007904:	77e0      	strb	r0, [r4, #31]
  if(HAL_DMA_STATE_READY == hdma->State)
 8007906:	1ca8      	adds	r0, r5, #2
 8007908:	7fc6      	ldrb	r6, [r0, #31]
 800790a:	4684      	mov	ip, r0
 800790c:	b2f6      	uxtb	r6, r6
 800790e:	2002      	movs	r0, #2
 8007910:	2700      	movs	r7, #0
 8007912:	2e01      	cmp	r6, #1
 8007914:	d128      	bne.n	8007968 <HAL_DMA_Start_IT+0x74>
  	hdma->State = HAL_DMA_STATE_BUSY;
 8007916:	4664      	mov	r4, ip
 8007918:	77e0      	strb	r0, [r4, #31]
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 800791a:	682c      	ldr	r4, [r5, #0]
  	hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800791c:	63af      	str	r7, [r5, #56]	; 0x38
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 800791e:	6820      	ldr	r0, [r4, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8007920:	6c2f      	ldr	r7, [r5, #64]	; 0x40
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8007922:	43b0      	bics	r0, r6
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8007924:	40be      	lsls	r6, r7
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8007926:	6020      	str	r0, [r4, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8007928:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 800792a:	6046      	str	r6, [r0, #4]
  hdma->Instance->CNDTR = DataLength;
 800792c:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 800792e:	686b      	ldr	r3, [r5, #4]
 8007930:	6828      	ldr	r0, [r5, #0]
 8007932:	2b10      	cmp	r3, #16
 8007934:	d10e      	bne.n	8007954 <HAL_DMA_Start_IT+0x60>
    hdma->Instance->CPAR = DstAddress;
 8007936:	60a2      	str	r2, [r4, #8]
    hdma->Instance->CMAR = SrcAddress;
 8007938:	60e1      	str	r1, [r4, #12]
    if(NULL != hdma->XferHalfCpltCallback )
 800793a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
      hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800793c:	6822      	ldr	r2, [r4, #0]
    if(NULL != hdma->XferHalfCpltCallback )
 800793e:	2b00      	cmp	r3, #0
 8007940:	d00b      	beq.n	800795a <HAL_DMA_Start_IT+0x66>
      hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8007942:	230e      	movs	r3, #14
 8007944:	4313      	orrs	r3, r2
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 8007946:	6023      	str	r3, [r4, #0]
  	hdma->Instance->CCR |= DMA_CCR_EN;
 8007948:	2301      	movs	r3, #1
 800794a:	6802      	ldr	r2, [r0, #0]
 800794c:	4313      	orrs	r3, r2
 800794e:	6003      	str	r3, [r0, #0]
	HAL_StatusTypeDef status = HAL_OK;
 8007950:	2000      	movs	r0, #0
} 
 8007952:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hdma->Instance->CPAR = SrcAddress;
 8007954:	60a1      	str	r1, [r4, #8]
    hdma->Instance->CMAR = DstAddress;
 8007956:	60e2      	str	r2, [r4, #12]
 8007958:	e7ef      	b.n	800793a <HAL_DMA_Start_IT+0x46>
  		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
 800795a:	230a      	movs	r3, #10
 800795c:	4313      	orrs	r3, r2
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 800795e:	2204      	movs	r2, #4
  		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
 8007960:	6023      	str	r3, [r4, #0]
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 8007962:	6823      	ldr	r3, [r4, #0]
 8007964:	4393      	bics	r3, r2
 8007966:	e7ee      	b.n	8007946 <HAL_DMA_Start_IT+0x52>
    __HAL_UNLOCK(hdma); 
 8007968:	77e7      	strb	r7, [r4, #31]
 800796a:	e7f2      	b.n	8007952 <HAL_DMA_Start_IT+0x5e>

0800796c <HAL_DMA_Abort>:
	 hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800796c:	210e      	movs	r1, #14
 800796e:	6803      	ldr	r3, [r0, #0]
{
 8007970:	b510      	push	{r4, lr}
	 hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8007972:	681a      	ldr	r2, [r3, #0]
	hdma->DmaBaseAddress->IFCR = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8007974:	6c04      	ldr	r4, [r0, #64]	; 0x40
	 hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8007976:	438a      	bics	r2, r1
 8007978:	601a      	str	r2, [r3, #0]
	hdma->Instance->CCR &= ~DMA_CCR_EN;
 800797a:	2201      	movs	r2, #1
 800797c:	6819      	ldr	r1, [r3, #0]
 800797e:	4391      	bics	r1, r2
 8007980:	6019      	str	r1, [r3, #0]
	hdma->DmaBaseAddress->IFCR = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8007982:	0011      	movs	r1, r2
 8007984:	40a1      	lsls	r1, r4
 8007986:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8007988:	6059      	str	r1, [r3, #4]
	hdma->State = HAL_DMA_STATE_READY; 
 800798a:	1c83      	adds	r3, r0, #2
 800798c:	77da      	strb	r2, [r3, #31]
	__HAL_UNLOCK(hdma);
 800798e:	1883      	adds	r3, r0, r2
 8007990:	2000      	movs	r0, #0
 8007992:	77d8      	strb	r0, [r3, #31]
}
 8007994:	bd10      	pop	{r4, pc}
	...

08007998 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{ 
 8007998:	b5f0      	push	{r4, r5, r6, r7, lr}
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
  
        temp = SYSCFG->EXTICR[position >> 2];
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 800799a:	4a56      	ldr	r2, [pc, #344]	; (8007af4 <HAL_GPIO_Init+0x15c>)
  while (((GPIO_Init->Pin) >> position) != RESET)
 800799c:	680b      	ldr	r3, [r1, #0]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 800799e:	1882      	adds	r2, r0, r2
 80079a0:	1e54      	subs	r4, r2, #1
 80079a2:	41a2      	sbcs	r2, r4
{ 
 80079a4:	b089      	sub	sp, #36	; 0x24
  while (((GPIO_Init->Pin) >> position) != RESET)
 80079a6:	9303      	str	r3, [sp, #12]
  uint32_t position = 0x00U;
 80079a8:	2300      	movs	r3, #0
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80079aa:	3204      	adds	r2, #4
 80079ac:	9205      	str	r2, [sp, #20]
  while (((GPIO_Init->Pin) >> position) != RESET)
 80079ae:	9a03      	ldr	r2, [sp, #12]
 80079b0:	40da      	lsrs	r2, r3
 80079b2:	d101      	bne.n	80079b8 <HAL_GPIO_Init+0x20>
      }
    }
    
    position++;
  } 
}
 80079b4:	b009      	add	sp, #36	; 0x24
 80079b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 80079b8:	2201      	movs	r2, #1
 80079ba:	409a      	lsls	r2, r3
 80079bc:	4694      	mov	ip, r2
 80079be:	4664      	mov	r4, ip
 80079c0:	9a03      	ldr	r2, [sp, #12]
 80079c2:	4022      	ands	r2, r4
 80079c4:	9202      	str	r2, [sp, #8]
    if(iocurrent)
 80079c6:	d100      	bne.n	80079ca <HAL_GPIO_Init+0x32>
 80079c8:	e092      	b.n	8007af0 <HAL_GPIO_Init+0x158>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
 80079ca:	684a      	ldr	r2, [r1, #4]
 80079cc:	9201      	str	r2, [sp, #4]
 80079ce:	2210      	movs	r2, #16
 80079d0:	9e01      	ldr	r6, [sp, #4]
 80079d2:	4396      	bics	r6, r2
 80079d4:	2e02      	cmp	r6, #2
 80079d6:	d10d      	bne.n	80079f4 <HAL_GPIO_Init+0x5c>
        CLEAR_BIT(temp, 0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;      
 80079d8:	2407      	movs	r4, #7
 80079da:	270f      	movs	r7, #15
 80079dc:	401c      	ands	r4, r3
 80079de:	00a4      	lsls	r4, r4, #2
 80079e0:	40a7      	lsls	r7, r4
        temp = GPIOx->AFR[position >> 3];
 80079e2:	08da      	lsrs	r2, r3, #3
 80079e4:	0092      	lsls	r2, r2, #2
 80079e6:	1882      	adds	r2, r0, r2
 80079e8:	6a15      	ldr	r5, [r2, #32]
        CLEAR_BIT(temp, 0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;      
 80079ea:	43bd      	bics	r5, r7
        SET_BIT(temp, (uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));       
 80079ec:	690f      	ldr	r7, [r1, #16]
 80079ee:	40a7      	lsls	r7, r4
 80079f0:	433d      	orrs	r5, r7
        GPIOx->AFR[position >> 3U] = temp;
 80079f2:	6215      	str	r5, [r2, #32]
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
 80079f4:	2203      	movs	r2, #3
 80079f6:	0014      	movs	r4, r2
 80079f8:	005d      	lsls	r5, r3, #1
 80079fa:	40ac      	lsls	r4, r5
 80079fc:	43e4      	mvns	r4, r4
      temp = GPIOx->MODER;
 80079fe:	6807      	ldr	r7, [r0, #0]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8007a00:	3e01      	subs	r6, #1
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
 8007a02:	4027      	ands	r7, r4
 8007a04:	9704      	str	r7, [sp, #16]
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8007a06:	9f01      	ldr	r7, [sp, #4]
 8007a08:	403a      	ands	r2, r7
 8007a0a:	40aa      	lsls	r2, r5
 8007a0c:	9f04      	ldr	r7, [sp, #16]
 8007a0e:	433a      	orrs	r2, r7
      GPIOx->MODER = temp;
 8007a10:	6002      	str	r2, [r0, #0]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8007a12:	2e01      	cmp	r6, #1
 8007a14:	d80e      	bhi.n	8007a34 <HAL_GPIO_Init+0x9c>
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 8007a16:	68ca      	ldr	r2, [r1, #12]
        temp = GPIOx->OSPEEDR; 
 8007a18:	6886      	ldr	r6, [r0, #8]
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 8007a1a:	40aa      	lsls	r2, r5
        CLEAR_BIT(temp, GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8007a1c:	4026      	ands	r6, r4
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 8007a1e:	4332      	orrs	r2, r6
        GPIOx->OSPEEDR = temp;
 8007a20:	6082      	str	r2, [r0, #8]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 8007a22:	4662      	mov	r2, ip
        temp = GPIOx->OTYPER;
 8007a24:	6846      	ldr	r6, [r0, #4]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 8007a26:	4396      	bics	r6, r2
        SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8007a28:	9a01      	ldr	r2, [sp, #4]
 8007a2a:	06d2      	lsls	r2, r2, #27
 8007a2c:	0fd2      	lsrs	r2, r2, #31
 8007a2e:	409a      	lsls	r2, r3
 8007a30:	4332      	orrs	r2, r6
        GPIOx->OTYPER = temp;
 8007a32:	6042      	str	r2, [r0, #4]
      temp = GPIOx->PUPDR;
 8007a34:	68c2      	ldr	r2, [r0, #12]
      CLEAR_BIT(temp, GPIO_PUPDR_PUPDR0 << (position * 2U));
 8007a36:	4014      	ands	r4, r2
      SET_BIT(temp, (GPIO_Init->Pull) << (position * 2U));
 8007a38:	688a      	ldr	r2, [r1, #8]
 8007a3a:	40aa      	lsls	r2, r5
 8007a3c:	4314      	orrs	r4, r2
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 8007a3e:	9a01      	ldr	r2, [sp, #4]
      GPIOx->PUPDR = temp;
 8007a40:	60c4      	str	r4, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 8007a42:	00d2      	lsls	r2, r2, #3
 8007a44:	d554      	bpl.n	8007af0 <HAL_GPIO_Init+0x158>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8007a46:	2601      	movs	r6, #1
 8007a48:	4a2b      	ldr	r2, [pc, #172]	; (8007af8 <HAL_GPIO_Init+0x160>)
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 8007a4a:	001d      	movs	r5, r3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8007a4c:	6994      	ldr	r4, [r2, #24]
 8007a4e:	4334      	orrs	r4, r6
 8007a50:	6194      	str	r4, [r2, #24]
 8007a52:	6992      	ldr	r2, [r2, #24]
        temp = SYSCFG->EXTICR[position >> 2];
 8007a54:	089c      	lsrs	r4, r3, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8007a56:	4032      	ands	r2, r6
 8007a58:	9207      	str	r2, [sp, #28]
 8007a5a:	9a07      	ldr	r2, [sp, #28]
 8007a5c:	4a27      	ldr	r2, [pc, #156]	; (8007afc <HAL_GPIO_Init+0x164>)
 8007a5e:	00a4      	lsls	r4, r4, #2
 8007a60:	18a4      	adds	r4, r4, r2
        temp = SYSCFG->EXTICR[position >> 2];
 8007a62:	68a2      	ldr	r2, [r4, #8]
 8007a64:	4694      	mov	ip, r2
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 8007a66:	2203      	movs	r2, #3
 8007a68:	4015      	ands	r5, r2
 8007a6a:	00ad      	lsls	r5, r5, #2
 8007a6c:	320c      	adds	r2, #12
 8007a6e:	40aa      	lsls	r2, r5
 8007a70:	4667      	mov	r7, ip
 8007a72:	4397      	bics	r7, r2
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8007a74:	2290      	movs	r2, #144	; 0x90
 8007a76:	05d2      	lsls	r2, r2, #23
 8007a78:	4694      	mov	ip, r2
 8007a7a:	2200      	movs	r2, #0
 8007a7c:	4560      	cmp	r0, ip
 8007a7e:	d00d      	beq.n	8007a9c <HAL_GPIO_Init+0x104>
 8007a80:	4a1f      	ldr	r2, [pc, #124]	; (8007b00 <HAL_GPIO_Init+0x168>)
 8007a82:	4694      	mov	ip, r2
 8007a84:	0032      	movs	r2, r6
 8007a86:	4560      	cmp	r0, ip
 8007a88:	d008      	beq.n	8007a9c <HAL_GPIO_Init+0x104>
 8007a8a:	4e1e      	ldr	r6, [pc, #120]	; (8007b04 <HAL_GPIO_Init+0x16c>)
 8007a8c:	1892      	adds	r2, r2, r2
 8007a8e:	42b0      	cmp	r0, r6
 8007a90:	d004      	beq.n	8007a9c <HAL_GPIO_Init+0x104>
 8007a92:	4e1d      	ldr	r6, [pc, #116]	; (8007b08 <HAL_GPIO_Init+0x170>)
 8007a94:	3201      	adds	r2, #1
 8007a96:	42b0      	cmp	r0, r6
 8007a98:	d000      	beq.n	8007a9c <HAL_GPIO_Init+0x104>
 8007a9a:	9a05      	ldr	r2, [sp, #20]
 8007a9c:	40aa      	lsls	r2, r5
 8007a9e:	433a      	orrs	r2, r7
        SYSCFG->EXTICR[position >> 2] = temp;
 8007aa0:	60a2      	str	r2, [r4, #8]
        temp = EXTI->IMR;
 8007aa2:	4a1a      	ldr	r2, [pc, #104]	; (8007b0c <HAL_GPIO_Init+0x174>)
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 8007aa4:	9c02      	ldr	r4, [sp, #8]
        temp = EXTI->IMR;
 8007aa6:	6816      	ldr	r6, [r2, #0]
          SET_BIT(temp, iocurrent); 
 8007aa8:	9d02      	ldr	r5, [sp, #8]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8007aaa:	9f01      	ldr	r7, [sp, #4]
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 8007aac:	43e4      	mvns	r4, r4
          SET_BIT(temp, iocurrent); 
 8007aae:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8007ab0:	03ff      	lsls	r7, r7, #15
 8007ab2:	d401      	bmi.n	8007ab8 <HAL_GPIO_Init+0x120>
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 8007ab4:	0035      	movs	r5, r6
 8007ab6:	4025      	ands	r5, r4
        EXTI->IMR = temp;
 8007ab8:	6015      	str	r5, [r2, #0]
        temp = EXTI->EMR;
 8007aba:	6856      	ldr	r6, [r2, #4]
          SET_BIT(temp, iocurrent); 
 8007abc:	9d02      	ldr	r5, [sp, #8]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8007abe:	9f01      	ldr	r7, [sp, #4]
          SET_BIT(temp, iocurrent); 
 8007ac0:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8007ac2:	03bf      	lsls	r7, r7, #14
 8007ac4:	d401      	bmi.n	8007aca <HAL_GPIO_Init+0x132>
        CLEAR_BIT(temp, (uint32_t)iocurrent);      
 8007ac6:	0035      	movs	r5, r6
 8007ac8:	4025      	ands	r5, r4
        EXTI->EMR = temp;
 8007aca:	6055      	str	r5, [r2, #4]
        temp = EXTI->RTSR;
 8007acc:	6896      	ldr	r6, [r2, #8]
          SET_BIT(temp, iocurrent); 
 8007ace:	9d02      	ldr	r5, [sp, #8]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8007ad0:	9f01      	ldr	r7, [sp, #4]
          SET_BIT(temp, iocurrent); 
 8007ad2:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8007ad4:	02ff      	lsls	r7, r7, #11
 8007ad6:	d401      	bmi.n	8007adc <HAL_GPIO_Init+0x144>
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 8007ad8:	0035      	movs	r5, r6
 8007ada:	4025      	ands	r5, r4
        EXTI->RTSR = temp;
 8007adc:	6095      	str	r5, [r2, #8]
        temp = EXTI->FTSR;
 8007ade:	68d5      	ldr	r5, [r2, #12]
          SET_BIT(temp, iocurrent); 
 8007ae0:	9e02      	ldr	r6, [sp, #8]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8007ae2:	9f01      	ldr	r7, [sp, #4]
          SET_BIT(temp, iocurrent); 
 8007ae4:	432e      	orrs	r6, r5
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8007ae6:	02bf      	lsls	r7, r7, #10
 8007ae8:	d401      	bmi.n	8007aee <HAL_GPIO_Init+0x156>
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 8007aea:	4025      	ands	r5, r4
 8007aec:	002e      	movs	r6, r5
        EXTI->FTSR = temp;
 8007aee:	60d6      	str	r6, [r2, #12]
    position++;
 8007af0:	3301      	adds	r3, #1
 8007af2:	e75c      	b.n	80079ae <HAL_GPIO_Init+0x16>
 8007af4:	b7fff000 	.word	0xb7fff000
 8007af8:	40021000 	.word	0x40021000
 8007afc:	40010000 	.word	0x40010000
 8007b00:	48000400 	.word	0x48000400
 8007b04:	48000800 	.word	0x48000800
 8007b08:	48000c00 	.word	0x48000c00
 8007b0c:	40010400 	.word	0x40010400

08007b10 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8007b10:	6900      	ldr	r0, [r0, #16]
 8007b12:	4008      	ands	r0, r1
 8007b14:	1e41      	subs	r1, r0, #1
 8007b16:	4188      	sbcs	r0, r1
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
 8007b18:	b2c0      	uxtb	r0, r0
  }
 8007b1a:	4770      	bx	lr

08007b1c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8007b1c:	2a00      	cmp	r2, #0
 8007b1e:	d001      	beq.n	8007b24 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8007b20:	6181      	str	r1, [r0, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 8007b22:	4770      	bx	lr
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8007b24:	6281      	str	r1, [r0, #40]	; 0x28
}
 8007b26:	e7fc      	b.n	8007b22 <HAL_GPIO_WritePin+0x6>

08007b28 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8007b28:	6943      	ldr	r3, [r0, #20]
 8007b2a:	4059      	eors	r1, r3
 8007b2c:	6141      	str	r1, [r0, #20]
}
 8007b2e:	4770      	bx	lr

08007b30 <HAL_GPIO_EXTI_IRQHandler>:
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) 
 8007b30:	4b04      	ldr	r3, [pc, #16]	; (8007b44 <HAL_GPIO_EXTI_IRQHandler+0x14>)
{
 8007b32:	b510      	push	{r4, lr}
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) 
 8007b34:	695a      	ldr	r2, [r3, #20]
 8007b36:	4210      	tst	r0, r2
 8007b38:	d002      	beq.n	8007b40 <HAL_GPIO_EXTI_IRQHandler+0x10>
  { 
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8007b3a:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8007b3c:	f7fe fd8e 	bl	800665c <HAL_GPIO_EXTI_Callback>
  }
}
 8007b40:	bd10      	pop	{r4, pc}
 8007b42:	46c0      	nop			; (mov r8, r8)
 8007b44:	40010400 	.word	0x40010400

08007b48 <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8007b48:	6803      	ldr	r3, [r0, #0]
 8007b4a:	699a      	ldr	r2, [r3, #24]
 8007b4c:	0792      	lsls	r2, r2, #30
 8007b4e:	d501      	bpl.n	8007b54 <I2C_Flush_TXDR+0xc>
  {
     hi2c->Instance->TXDR = 0x00U;
 8007b50:	2200      	movs	r2, #0
 8007b52:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8007b54:	2201      	movs	r2, #1
 8007b56:	6999      	ldr	r1, [r3, #24]
 8007b58:	4211      	tst	r1, r2
 8007b5a:	d102      	bne.n	8007b62 <I2C_Flush_TXDR+0x1a>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8007b5c:	6999      	ldr	r1, [r3, #24]
 8007b5e:	430a      	orrs	r2, r1
 8007b60:	619a      	str	r2, [r3, #24]
  }
}
 8007b62:	4770      	bx	lr

08007b64 <I2C_TransferConfig>:
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8007b64:	6800      	ldr	r0, [r0, #0]
{
 8007b66:	b530      	push	{r4, r5, lr}
  tmpreg = hi2c->Instance->CR2;
 8007b68:	6845      	ldr	r5, [r0, #4]

  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8007b6a:	4c06      	ldr	r4, [pc, #24]	; (8007b84 <I2C_TransferConfig+0x20>)

  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8007b6c:	0412      	lsls	r2, r2, #16
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8007b6e:	402c      	ands	r4, r5
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8007b70:	9d03      	ldr	r5, [sp, #12]
 8007b72:	0589      	lsls	r1, r1, #22
 8007b74:	432b      	orrs	r3, r5
 8007b76:	431a      	orrs	r2, r3
 8007b78:	0d89      	lsrs	r1, r1, #22
 8007b7a:	430a      	orrs	r2, r1
 8007b7c:	4322      	orrs	r2, r4
            (uint32_t)Mode | (uint32_t)Request);

  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;
 8007b7e:	6042      	str	r2, [r0, #4]
}
 8007b80:	bd30      	pop	{r4, r5, pc}
 8007b82:	46c0      	nop			; (mov r8, r8)
 8007b84:	fc009800 	.word	0xfc009800

08007b88 <I2C_WaitOnFlagUntilTimeout>:
{
 8007b88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007b8a:	0004      	movs	r4, r0
 8007b8c:	000e      	movs	r6, r1
 8007b8e:	0017      	movs	r7, r2
 8007b90:	001d      	movs	r5, r3
  while(__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8007b92:	6822      	ldr	r2, [r4, #0]
 8007b94:	6993      	ldr	r3, [r2, #24]
 8007b96:	4033      	ands	r3, r6
 8007b98:	1b9b      	subs	r3, r3, r6
 8007b9a:	4259      	negs	r1, r3
 8007b9c:	414b      	adcs	r3, r1
 8007b9e:	42bb      	cmp	r3, r7
 8007ba0:	d001      	beq.n	8007ba6 <I2C_WaitOnFlagUntilTimeout+0x1e>
  return HAL_OK;
 8007ba2:	2000      	movs	r0, #0
 8007ba4:	e00e      	b.n	8007bc4 <I2C_WaitOnFlagUntilTimeout+0x3c>
    if(Timeout != HAL_MAX_DELAY)
 8007ba6:	1c6b      	adds	r3, r5, #1
 8007ba8:	d0f4      	beq.n	8007b94 <I2C_WaitOnFlagUntilTimeout+0xc>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8007baa:	2d00      	cmp	r5, #0
 8007bac:	d10b      	bne.n	8007bc6 <I2C_WaitOnFlagUntilTimeout+0x3e>
        hi2c->State= HAL_I2C_STATE_READY;
 8007bae:	0023      	movs	r3, r4
 8007bb0:	2220      	movs	r2, #32
 8007bb2:	3341      	adds	r3, #65	; 0x41
 8007bb4:	701a      	strb	r2, [r3, #0]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007bb6:	0022      	movs	r2, r4
 8007bb8:	2300      	movs	r3, #0
        return HAL_TIMEOUT;
 8007bba:	2003      	movs	r0, #3
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007bbc:	3242      	adds	r2, #66	; 0x42
        __HAL_UNLOCK(hi2c);
 8007bbe:	3440      	adds	r4, #64	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007bc0:	7013      	strb	r3, [r2, #0]
        __HAL_UNLOCK(hi2c);
 8007bc2:	7023      	strb	r3, [r4, #0]
}
 8007bc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8007bc6:	f7ff fa9b 	bl	8007100 <HAL_GetTick>
 8007bca:	9b06      	ldr	r3, [sp, #24]
 8007bcc:	1ac0      	subs	r0, r0, r3
 8007bce:	42a8      	cmp	r0, r5
 8007bd0:	d9df      	bls.n	8007b92 <I2C_WaitOnFlagUntilTimeout+0xa>
 8007bd2:	e7ec      	b.n	8007bae <I2C_WaitOnFlagUntilTimeout+0x26>

08007bd4 <I2C_IsAcknowledgeFailed>:
{
 8007bd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007bd6:	6803      	ldr	r3, [r0, #0]
{
 8007bd8:	0004      	movs	r4, r0
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007bda:	6998      	ldr	r0, [r3, #24]
 8007bdc:	2310      	movs	r3, #16
{
 8007bde:	000e      	movs	r6, r1
 8007be0:	0017      	movs	r7, r2
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007be2:	4018      	ands	r0, r3
    while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007be4:	2520      	movs	r5, #32
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007be6:	2800      	cmp	r0, #0
 8007be8:	d115      	bne.n	8007c16 <I2C_IsAcknowledgeFailed+0x42>
}
 8007bea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(Timeout != HAL_MAX_DELAY)
 8007bec:	1c72      	adds	r2, r6, #1
 8007bee:	d013      	beq.n	8007c18 <I2C_IsAcknowledgeFailed+0x44>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007bf0:	2e00      	cmp	r6, #0
 8007bf2:	d004      	beq.n	8007bfe <I2C_IsAcknowledgeFailed+0x2a>
 8007bf4:	f7ff fa84 	bl	8007100 <HAL_GetTick>
 8007bf8:	1bc0      	subs	r0, r0, r7
 8007bfa:	4286      	cmp	r6, r0
 8007bfc:	d20b      	bcs.n	8007c16 <I2C_IsAcknowledgeFailed+0x42>
          hi2c->State= HAL_I2C_STATE_READY;
 8007bfe:	0023      	movs	r3, r4
 8007c00:	2220      	movs	r2, #32
 8007c02:	3341      	adds	r3, #65	; 0x41
 8007c04:	701a      	strb	r2, [r3, #0]
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c06:	0022      	movs	r2, r4
 8007c08:	2300      	movs	r3, #0
 8007c0a:	3242      	adds	r2, #66	; 0x42
          __HAL_UNLOCK(hi2c);
 8007c0c:	3440      	adds	r4, #64	; 0x40
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c0e:	7013      	strb	r3, [r2, #0]
          return HAL_TIMEOUT;
 8007c10:	2003      	movs	r0, #3
          __HAL_UNLOCK(hi2c);
 8007c12:	7023      	strb	r3, [r4, #0]
 8007c14:	e7e9      	b.n	8007bea <I2C_IsAcknowledgeFailed+0x16>
    while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007c16:	6823      	ldr	r3, [r4, #0]
 8007c18:	699a      	ldr	r2, [r3, #24]
 8007c1a:	422a      	tst	r2, r5
 8007c1c:	d0e6      	beq.n	8007bec <I2C_IsAcknowledgeFailed+0x18>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007c1e:	2210      	movs	r2, #16
    I2C_Flush_TXDR(hi2c);
 8007c20:	0020      	movs	r0, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007c22:	61da      	str	r2, [r3, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007c24:	61dd      	str	r5, [r3, #28]
    I2C_Flush_TXDR(hi2c);
 8007c26:	f7ff ff8f 	bl	8007b48 <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
 8007c2a:	6822      	ldr	r2, [r4, #0]
 8007c2c:	4908      	ldr	r1, [pc, #32]	; (8007c50 <I2C_IsAcknowledgeFailed+0x7c>)
 8007c2e:	6853      	ldr	r3, [r2, #4]
    return HAL_ERROR;
 8007c30:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
 8007c32:	400b      	ands	r3, r1
 8007c34:	6053      	str	r3, [r2, #4]
    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8007c36:	2304      	movs	r3, #4
 8007c38:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State= HAL_I2C_STATE_READY;
 8007c3a:	0023      	movs	r3, r4
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c3c:	0022      	movs	r2, r4
    hi2c->State= HAL_I2C_STATE_READY;
 8007c3e:	3341      	adds	r3, #65	; 0x41
 8007c40:	701d      	strb	r5, [r3, #0]
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c42:	2300      	movs	r3, #0
 8007c44:	3242      	adds	r2, #66	; 0x42
    __HAL_UNLOCK(hi2c);
 8007c46:	3440      	adds	r4, #64	; 0x40
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c48:	7013      	strb	r3, [r2, #0]
    __HAL_UNLOCK(hi2c);
 8007c4a:	7023      	strb	r3, [r4, #0]
 8007c4c:	e7cd      	b.n	8007bea <I2C_IsAcknowledgeFailed+0x16>
 8007c4e:	46c0      	nop			; (mov r8, r8)
 8007c50:	fe00e800 	.word	0xfe00e800

08007c54 <I2C_WaitOnTXISFlagUntilTimeout>:
{
 8007c54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007c56:	0004      	movs	r4, r0
 8007c58:	000d      	movs	r5, r1
 8007c5a:	0016      	movs	r6, r2
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8007c5c:	2702      	movs	r7, #2
 8007c5e:	6823      	ldr	r3, [r4, #0]
 8007c60:	699b      	ldr	r3, [r3, #24]
 8007c62:	423b      	tst	r3, r7
 8007c64:	d001      	beq.n	8007c6a <I2C_WaitOnTXISFlagUntilTimeout+0x16>
  return HAL_OK;
 8007c66:	2000      	movs	r0, #0
 8007c68:	e018      	b.n	8007c9c <I2C_WaitOnTXISFlagUntilTimeout+0x48>
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8007c6a:	0032      	movs	r2, r6
 8007c6c:	0029      	movs	r1, r5
 8007c6e:	0020      	movs	r0, r4
 8007c70:	f7ff ffb0 	bl	8007bd4 <I2C_IsAcknowledgeFailed>
 8007c74:	2800      	cmp	r0, #0
 8007c76:	d118      	bne.n	8007caa <I2C_WaitOnTXISFlagUntilTimeout+0x56>
    if(Timeout != HAL_MAX_DELAY)
 8007c78:	1c6b      	adds	r3, r5, #1
 8007c7a:	d0f0      	beq.n	8007c5e <I2C_WaitOnTXISFlagUntilTimeout+0xa>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007c7c:	2d00      	cmp	r5, #0
 8007c7e:	d10e      	bne.n	8007c9e <I2C_WaitOnTXISFlagUntilTimeout+0x4a>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007c80:	2220      	movs	r2, #32
 8007c82:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8007c84:	2003      	movs	r0, #3
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007c86:	4313      	orrs	r3, r2
 8007c88:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State= HAL_I2C_STATE_READY;
 8007c8a:	0023      	movs	r3, r4
 8007c8c:	3341      	adds	r3, #65	; 0x41
 8007c8e:	701a      	strb	r2, [r3, #0]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c90:	0022      	movs	r2, r4
 8007c92:	2300      	movs	r3, #0
 8007c94:	3242      	adds	r2, #66	; 0x42
        __HAL_UNLOCK(hi2c);
 8007c96:	3440      	adds	r4, #64	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c98:	7013      	strb	r3, [r2, #0]
        __HAL_UNLOCK(hi2c);
 8007c9a:	7023      	strb	r3, [r4, #0]
}
 8007c9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007c9e:	f7ff fa2f 	bl	8007100 <HAL_GetTick>
 8007ca2:	1b80      	subs	r0, r0, r6
 8007ca4:	42a8      	cmp	r0, r5
 8007ca6:	d9da      	bls.n	8007c5e <I2C_WaitOnTXISFlagUntilTimeout+0xa>
 8007ca8:	e7ea      	b.n	8007c80 <I2C_WaitOnTXISFlagUntilTimeout+0x2c>
      return HAL_ERROR;
 8007caa:	2001      	movs	r0, #1
 8007cac:	e7f6      	b.n	8007c9c <I2C_WaitOnTXISFlagUntilTimeout+0x48>

08007cae <I2C_RequestMemoryWrite>:
{
 8007cae:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8007cb0:	0015      	movs	r5, r2
 8007cb2:	001e      	movs	r6, r3
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8007cb4:	b2da      	uxtb	r2, r3
 8007cb6:	2380      	movs	r3, #128	; 0x80
 8007cb8:	019b      	lsls	r3, r3, #6
 8007cba:	9300      	str	r3, [sp, #0]
 8007cbc:	2380      	movs	r3, #128	; 0x80
{
 8007cbe:	0004      	movs	r4, r0
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8007cc0:	045b      	lsls	r3, r3, #17
 8007cc2:	f7ff ff4f 	bl	8007b64 <I2C_TransferConfig>
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007cc6:	9a07      	ldr	r2, [sp, #28]
 8007cc8:	9906      	ldr	r1, [sp, #24]
 8007cca:	0020      	movs	r0, r4
 8007ccc:	f7ff ffc2 	bl	8007c54 <I2C_WaitOnTXISFlagUntilTimeout>
 8007cd0:	2800      	cmp	r0, #0
 8007cd2:	d005      	beq.n	8007ce0 <I2C_RequestMemoryWrite+0x32>
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007cd4:	6c63      	ldr	r3, [r4, #68]	; 0x44
      return HAL_ERROR;
 8007cd6:	2001      	movs	r0, #1
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007cd8:	2b04      	cmp	r3, #4
 8007cda:	d000      	beq.n	8007cde <I2C_RequestMemoryWrite+0x30>
      return HAL_TIMEOUT;
 8007cdc:	2003      	movs	r0, #3
}
 8007cde:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 8007ce0:	6823      	ldr	r3, [r4, #0]
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8007ce2:	2e01      	cmp	r6, #1
 8007ce4:	d10c      	bne.n	8007d00 <I2C_RequestMemoryWrite+0x52>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007ce6:	b2ed      	uxtb	r5, r5
 8007ce8:	629d      	str	r5, [r3, #40]	; 0x28
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 8007cea:	9b07      	ldr	r3, [sp, #28]
 8007cec:	2200      	movs	r2, #0
 8007cee:	9300      	str	r3, [sp, #0]
 8007cf0:	2180      	movs	r1, #128	; 0x80
 8007cf2:	9b06      	ldr	r3, [sp, #24]
 8007cf4:	0020      	movs	r0, r4
 8007cf6:	f7ff ff47 	bl	8007b88 <I2C_WaitOnFlagUntilTimeout>
 8007cfa:	2800      	cmp	r0, #0
 8007cfc:	d0ef      	beq.n	8007cde <I2C_RequestMemoryWrite+0x30>
 8007cfe:	e7ed      	b.n	8007cdc <I2C_RequestMemoryWrite+0x2e>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8007d00:	0a2a      	lsrs	r2, r5, #8
 8007d02:	629a      	str	r2, [r3, #40]	; 0x28
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007d04:	9906      	ldr	r1, [sp, #24]
 8007d06:	9a07      	ldr	r2, [sp, #28]
 8007d08:	0020      	movs	r0, r4
 8007d0a:	f7ff ffa3 	bl	8007c54 <I2C_WaitOnTXISFlagUntilTimeout>
 8007d0e:	2800      	cmp	r0, #0
 8007d10:	d1e0      	bne.n	8007cd4 <I2C_RequestMemoryWrite+0x26>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007d12:	6823      	ldr	r3, [r4, #0]
 8007d14:	e7e7      	b.n	8007ce6 <I2C_RequestMemoryWrite+0x38>

08007d16 <I2C_RequestMemoryRead>:
{
 8007d16:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8007d18:	0015      	movs	r5, r2
 8007d1a:	001e      	movs	r6, r3
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8007d1c:	b2da      	uxtb	r2, r3
 8007d1e:	2380      	movs	r3, #128	; 0x80
{
 8007d20:	0004      	movs	r4, r0
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8007d22:	019b      	lsls	r3, r3, #6
 8007d24:	9300      	str	r3, [sp, #0]
 8007d26:	2300      	movs	r3, #0
 8007d28:	f7ff ff1c 	bl	8007b64 <I2C_TransferConfig>
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007d2c:	9a07      	ldr	r2, [sp, #28]
 8007d2e:	9906      	ldr	r1, [sp, #24]
 8007d30:	0020      	movs	r0, r4
 8007d32:	f7ff ff8f 	bl	8007c54 <I2C_WaitOnTXISFlagUntilTimeout>
 8007d36:	2800      	cmp	r0, #0
 8007d38:	d005      	beq.n	8007d46 <I2C_RequestMemoryRead+0x30>
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007d3a:	6c63      	ldr	r3, [r4, #68]	; 0x44
      return HAL_ERROR;
 8007d3c:	2001      	movs	r0, #1
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007d3e:	2b04      	cmp	r3, #4
 8007d40:	d000      	beq.n	8007d44 <I2C_RequestMemoryRead+0x2e>
      return HAL_TIMEOUT;
 8007d42:	2003      	movs	r0, #3
}
 8007d44:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 8007d46:	6823      	ldr	r3, [r4, #0]
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8007d48:	2e01      	cmp	r6, #1
 8007d4a:	d10c      	bne.n	8007d66 <I2C_RequestMemoryRead+0x50>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007d4c:	b2ed      	uxtb	r5, r5
 8007d4e:	629d      	str	r5, [r3, #40]	; 0x28
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 8007d50:	9b07      	ldr	r3, [sp, #28]
 8007d52:	2200      	movs	r2, #0
 8007d54:	9300      	str	r3, [sp, #0]
 8007d56:	2140      	movs	r1, #64	; 0x40
 8007d58:	9b06      	ldr	r3, [sp, #24]
 8007d5a:	0020      	movs	r0, r4
 8007d5c:	f7ff ff14 	bl	8007b88 <I2C_WaitOnFlagUntilTimeout>
 8007d60:	2800      	cmp	r0, #0
 8007d62:	d0ef      	beq.n	8007d44 <I2C_RequestMemoryRead+0x2e>
 8007d64:	e7ed      	b.n	8007d42 <I2C_RequestMemoryRead+0x2c>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8007d66:	0a2a      	lsrs	r2, r5, #8
 8007d68:	629a      	str	r2, [r3, #40]	; 0x28
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007d6a:	9906      	ldr	r1, [sp, #24]
 8007d6c:	9a07      	ldr	r2, [sp, #28]
 8007d6e:	0020      	movs	r0, r4
 8007d70:	f7ff ff70 	bl	8007c54 <I2C_WaitOnTXISFlagUntilTimeout>
 8007d74:	2800      	cmp	r0, #0
 8007d76:	d1e0      	bne.n	8007d3a <I2C_RequestMemoryRead+0x24>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007d78:	6823      	ldr	r3, [r4, #0]
 8007d7a:	e7e7      	b.n	8007d4c <I2C_RequestMemoryRead+0x36>

08007d7c <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 8007d7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007d7e:	0004      	movs	r4, r0
 8007d80:	000d      	movs	r5, r1
 8007d82:	0016      	movs	r6, r2
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007d84:	2720      	movs	r7, #32
 8007d86:	6823      	ldr	r3, [r4, #0]
 8007d88:	699b      	ldr	r3, [r3, #24]
 8007d8a:	423b      	tst	r3, r7
 8007d8c:	d001      	beq.n	8007d92 <I2C_WaitOnSTOPFlagUntilTimeout+0x16>
  return HAL_OK;
 8007d8e:	2000      	movs	r0, #0
 8007d90:	e016      	b.n	8007dc0 <I2C_WaitOnSTOPFlagUntilTimeout+0x44>
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8007d92:	0032      	movs	r2, r6
 8007d94:	0029      	movs	r1, r5
 8007d96:	0020      	movs	r0, r4
 8007d98:	f7ff ff1c 	bl	8007bd4 <I2C_IsAcknowledgeFailed>
 8007d9c:	2800      	cmp	r0, #0
 8007d9e:	d116      	bne.n	8007dce <I2C_WaitOnSTOPFlagUntilTimeout+0x52>
    if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007da0:	2d00      	cmp	r5, #0
 8007da2:	d10e      	bne.n	8007dc2 <I2C_WaitOnSTOPFlagUntilTimeout+0x46>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007da4:	2220      	movs	r2, #32
 8007da6:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8007da8:	2003      	movs	r0, #3
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007daa:	4313      	orrs	r3, r2
 8007dac:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State= HAL_I2C_STATE_READY;
 8007dae:	0023      	movs	r3, r4
 8007db0:	3341      	adds	r3, #65	; 0x41
 8007db2:	701a      	strb	r2, [r3, #0]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007db4:	0022      	movs	r2, r4
 8007db6:	2300      	movs	r3, #0
 8007db8:	3242      	adds	r2, #66	; 0x42
        __HAL_UNLOCK(hi2c);
 8007dba:	3440      	adds	r4, #64	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007dbc:	7013      	strb	r3, [r2, #0]
        __HAL_UNLOCK(hi2c);
 8007dbe:	7023      	strb	r3, [r4, #0]
}
 8007dc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007dc2:	f7ff f99d 	bl	8007100 <HAL_GetTick>
 8007dc6:	1b80      	subs	r0, r0, r6
 8007dc8:	42a8      	cmp	r0, r5
 8007dca:	d9dc      	bls.n	8007d86 <I2C_WaitOnSTOPFlagUntilTimeout+0xa>
 8007dcc:	e7ea      	b.n	8007da4 <I2C_WaitOnSTOPFlagUntilTimeout+0x28>
      return HAL_ERROR;
 8007dce:	2001      	movs	r0, #1
 8007dd0:	e7f6      	b.n	8007dc0 <I2C_WaitOnSTOPFlagUntilTimeout+0x44>
	...

08007dd4 <HAL_I2C_Init>:
{
 8007dd4:	b570      	push	{r4, r5, r6, lr}
 8007dd6:	0004      	movs	r4, r0
    return HAL_ERROR;
 8007dd8:	2001      	movs	r0, #1
  if(hi2c == NULL)
 8007dda:	2c00      	cmp	r4, #0
 8007ddc:	d03f      	beq.n	8007e5e <HAL_I2C_Init+0x8a>
  if(hi2c->State == HAL_I2C_STATE_RESET)
 8007dde:	0025      	movs	r5, r4
 8007de0:	3541      	adds	r5, #65	; 0x41
 8007de2:	782b      	ldrb	r3, [r5, #0]
 8007de4:	b2db      	uxtb	r3, r3
 8007de6:	2b00      	cmp	r3, #0
 8007de8:	d105      	bne.n	8007df6 <HAL_I2C_Init+0x22>
    hi2c->Lock = HAL_UNLOCKED;
 8007dea:	0022      	movs	r2, r4
 8007dec:	3240      	adds	r2, #64	; 0x40
 8007dee:	7013      	strb	r3, [r2, #0]
    HAL_I2C_MspInit(hi2c);
 8007df0:	0020      	movs	r0, r4
 8007df2:	f7fe f8c9 	bl	8005f88 <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8007df6:	2324      	movs	r3, #36	; 0x24
  __HAL_I2C_DISABLE(hi2c);
 8007df8:	2101      	movs	r1, #1
  hi2c->State = HAL_I2C_STATE_BUSY;
 8007dfa:	702b      	strb	r3, [r5, #0]
  __HAL_I2C_DISABLE(hi2c);
 8007dfc:	6823      	ldr	r3, [r4, #0]
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8007dfe:	68e0      	ldr	r0, [r4, #12]
  __HAL_I2C_DISABLE(hi2c);
 8007e00:	681a      	ldr	r2, [r3, #0]
 8007e02:	68a6      	ldr	r6, [r4, #8]
 8007e04:	438a      	bics	r2, r1
 8007e06:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8007e08:	6861      	ldr	r1, [r4, #4]
 8007e0a:	4a1a      	ldr	r2, [pc, #104]	; (8007e74 <HAL_I2C_Init+0xa0>)
 8007e0c:	400a      	ands	r2, r1
 8007e0e:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8007e10:	6899      	ldr	r1, [r3, #8]
 8007e12:	4a19      	ldr	r2, [pc, #100]	; (8007e78 <HAL_I2C_Init+0xa4>)
 8007e14:	4011      	ands	r1, r2
 8007e16:	6099      	str	r1, [r3, #8]
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8007e18:	2801      	cmp	r0, #1
 8007e1a:	d121      	bne.n	8007e60 <HAL_I2C_Init+0x8c>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8007e1c:	2180      	movs	r1, #128	; 0x80
 8007e1e:	0209      	lsls	r1, r1, #8
 8007e20:	4331      	orrs	r1, r6
 8007e22:	6099      	str	r1, [r3, #8]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8007e24:	6858      	ldr	r0, [r3, #4]
 8007e26:	4915      	ldr	r1, [pc, #84]	; (8007e7c <HAL_I2C_Init+0xa8>)
 8007e28:	4301      	orrs	r1, r0
 8007e2a:	6059      	str	r1, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8007e2c:	68d9      	ldr	r1, [r3, #12]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007e2e:	2000      	movs	r0, #0
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8007e30:	400a      	ands	r2, r1
 8007e32:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8007e34:	6961      	ldr	r1, [r4, #20]
 8007e36:	6922      	ldr	r2, [r4, #16]
 8007e38:	430a      	orrs	r2, r1
 8007e3a:	69a1      	ldr	r1, [r4, #24]
 8007e3c:	0209      	lsls	r1, r1, #8
 8007e3e:	430a      	orrs	r2, r1
 8007e40:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8007e42:	6a21      	ldr	r1, [r4, #32]
 8007e44:	69e2      	ldr	r2, [r4, #28]
 8007e46:	430a      	orrs	r2, r1
 8007e48:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 8007e4a:	2201      	movs	r2, #1
 8007e4c:	6819      	ldr	r1, [r3, #0]
 8007e4e:	430a      	orrs	r2, r1
 8007e50:	601a      	str	r2, [r3, #0]
  hi2c->State = HAL_I2C_STATE_READY;
 8007e52:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007e54:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8007e56:	702b      	strb	r3, [r5, #0]
  hi2c->PreviousState = I2C_STATE_NONE;
 8007e58:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007e5a:	3442      	adds	r4, #66	; 0x42
 8007e5c:	7020      	strb	r0, [r4, #0]
}
 8007e5e:	bd70      	pop	{r4, r5, r6, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8007e60:	2184      	movs	r1, #132	; 0x84
 8007e62:	0209      	lsls	r1, r1, #8
 8007e64:	4331      	orrs	r1, r6
 8007e66:	6099      	str	r1, [r3, #8]
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8007e68:	2802      	cmp	r0, #2
 8007e6a:	d1db      	bne.n	8007e24 <HAL_I2C_Init+0x50>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8007e6c:	2180      	movs	r1, #128	; 0x80
 8007e6e:	0109      	lsls	r1, r1, #4
 8007e70:	6059      	str	r1, [r3, #4]
 8007e72:	e7d7      	b.n	8007e24 <HAL_I2C_Init+0x50>
 8007e74:	f0ffffff 	.word	0xf0ffffff
 8007e78:	ffff7fff 	.word	0xffff7fff
 8007e7c:	02008000 	.word	0x02008000

08007e80 <HAL_I2C_Mem_Write>:
{
 8007e80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007e82:	b089      	sub	sp, #36	; 0x24
 8007e84:	9307      	str	r3, [sp, #28]
 8007e86:	ab0e      	add	r3, sp, #56	; 0x38
 8007e88:	9206      	str	r2, [sp, #24]
 8007e8a:	cb04      	ldmia	r3!, {r2}
 8007e8c:	0004      	movs	r4, r0
 8007e8e:	881b      	ldrh	r3, [r3, #0]
 8007e90:	9203      	str	r2, [sp, #12]
 8007e92:	9304      	str	r3, [sp, #16]
  if(hi2c->State == HAL_I2C_STATE_READY)
 8007e94:	0003      	movs	r3, r0
 8007e96:	3341      	adds	r3, #65	; 0x41
 8007e98:	9305      	str	r3, [sp, #20]
 8007e9a:	781b      	ldrb	r3, [r3, #0]
{
 8007e9c:	000d      	movs	r5, r1
    return HAL_BUSY;
 8007e9e:	2002      	movs	r0, #2
  if(hi2c->State == HAL_I2C_STATE_READY)
 8007ea0:	2b20      	cmp	r3, #32
 8007ea2:	d102      	bne.n	8007eaa <HAL_I2C_Mem_Write+0x2a>
    if((pData == NULL) || (Size == 0U))
 8007ea4:	2a00      	cmp	r2, #0
 8007ea6:	d102      	bne.n	8007eae <HAL_I2C_Mem_Write+0x2e>
        return HAL_ERROR;
 8007ea8:	2001      	movs	r0, #1
}
 8007eaa:	b009      	add	sp, #36	; 0x24
 8007eac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((pData == NULL) || (Size == 0U))
 8007eae:	9b04      	ldr	r3, [sp, #16]
 8007eb0:	2b00      	cmp	r3, #0
 8007eb2:	d0f9      	beq.n	8007ea8 <HAL_I2C_Mem_Write+0x28>
    __HAL_LOCK(hi2c);
 8007eb4:	0027      	movs	r7, r4
 8007eb6:	3740      	adds	r7, #64	; 0x40
 8007eb8:	783b      	ldrb	r3, [r7, #0]
 8007eba:	2b01      	cmp	r3, #1
 8007ebc:	d0f5      	beq.n	8007eaa <HAL_I2C_Mem_Write+0x2a>
 8007ebe:	2301      	movs	r3, #1
 8007ec0:	703b      	strb	r3, [r7, #0]
    tickstart = HAL_GetTick();
 8007ec2:	f7ff f91d 	bl	8007100 <HAL_GetTick>
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8007ec6:	2180      	movs	r1, #128	; 0x80
    tickstart = HAL_GetTick();
 8007ec8:	9002      	str	r0, [sp, #8]
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8007eca:	9000      	str	r0, [sp, #0]
 8007ecc:	2319      	movs	r3, #25
 8007ece:	2201      	movs	r2, #1
 8007ed0:	0209      	lsls	r1, r1, #8
 8007ed2:	0020      	movs	r0, r4
 8007ed4:	f7ff fe58 	bl	8007b88 <I2C_WaitOnFlagUntilTimeout>
 8007ed8:	1e06      	subs	r6, r0, #0
 8007eda:	d11e      	bne.n	8007f1a <HAL_I2C_Mem_Write+0x9a>
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8007edc:	2321      	movs	r3, #33	; 0x21
 8007ede:	9a05      	ldr	r2, [sp, #20]
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8007ee0:	0029      	movs	r1, r5
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8007ee2:	7013      	strb	r3, [r2, #0]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8007ee4:	0023      	movs	r3, r4
 8007ee6:	3342      	adds	r3, #66	; 0x42
 8007ee8:	9305      	str	r3, [sp, #20]
 8007eea:	2340      	movs	r3, #64	; 0x40
 8007eec:	9a05      	ldr	r2, [sp, #20]
 8007eee:	7013      	strb	r3, [r2, #0]
    hi2c->pBuffPtr  = pData;
 8007ef0:	9b03      	ldr	r3, [sp, #12]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007ef2:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->pBuffPtr  = pData;
 8007ef4:	6263      	str	r3, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
 8007ef6:	9b04      	ldr	r3, [sp, #16]
    hi2c->XferISR   = NULL;
 8007ef8:	6360      	str	r0, [r4, #52]	; 0x34
    hi2c->XferCount = Size;
 8007efa:	8563      	strh	r3, [r4, #42]	; 0x2a
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8007efc:	9b02      	ldr	r3, [sp, #8]
 8007efe:	9a06      	ldr	r2, [sp, #24]
 8007f00:	9301      	str	r3, [sp, #4]
 8007f02:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007f04:	0020      	movs	r0, r4
 8007f06:	9300      	str	r3, [sp, #0]
 8007f08:	9b07      	ldr	r3, [sp, #28]
 8007f0a:	f7ff fed0 	bl	8007cae <I2C_RequestMemoryWrite>
 8007f0e:	2800      	cmp	r0, #0
 8007f10:	d005      	beq.n	8007f1e <HAL_I2C_Mem_Write+0x9e>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007f12:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8007f14:	703e      	strb	r6, [r7, #0]
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007f16:	2b04      	cmp	r3, #4
 8007f18:	d0c6      	beq.n	8007ea8 <HAL_I2C_Mem_Write+0x28>
          return HAL_TIMEOUT;
 8007f1a:	2003      	movs	r0, #3
 8007f1c:	e7c5      	b.n	8007eaa <HAL_I2C_Mem_Write+0x2a>
    if(hi2c->XferCount > MAX_NBYTE_SIZE)
 8007f1e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007f20:	2bff      	cmp	r3, #255	; 0xff
 8007f22:	d914      	bls.n	8007f4e <HAL_I2C_Mem_Write+0xce>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8007f24:	22ff      	movs	r2, #255	; 0xff
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007f26:	2380      	movs	r3, #128	; 0x80
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8007f28:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007f2a:	045b      	lsls	r3, r3, #17
 8007f2c:	9000      	str	r0, [sp, #0]
 8007f2e:	0029      	movs	r1, r5
 8007f30:	0020      	movs	r0, r4
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f32:	2680      	movs	r6, #128	; 0x80
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007f34:	f7ff fe16 	bl	8007b64 <I2C_TransferConfig>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8007f38:	27ff      	movs	r7, #255	; 0xff
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f3a:	04b6      	lsls	r6, r6, #18
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8007f3c:	9a02      	ldr	r2, [sp, #8]
 8007f3e:	9910      	ldr	r1, [sp, #64]	; 0x40
 8007f40:	0020      	movs	r0, r4
 8007f42:	f7ff fe87 	bl	8007c54 <I2C_WaitOnTXISFlagUntilTimeout>
 8007f46:	2800      	cmp	r0, #0
 8007f48:	d009      	beq.n	8007f5e <HAL_I2C_Mem_Write+0xde>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007f4a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007f4c:	e7e3      	b.n	8007f16 <HAL_I2C_Mem_Write+0x96>
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f4e:	2380      	movs	r3, #128	; 0x80
      hi2c->XferSize = hi2c->XferCount;
 8007f50:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f52:	049b      	lsls	r3, r3, #18
      hi2c->XferSize = hi2c->XferCount;
 8007f54:	b292      	uxth	r2, r2
 8007f56:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f58:	b2d2      	uxtb	r2, r2
 8007f5a:	9000      	str	r0, [sp, #0]
 8007f5c:	e7e7      	b.n	8007f2e <HAL_I2C_Mem_Write+0xae>
      hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
 8007f5e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007f60:	1c5a      	adds	r2, r3, #1
 8007f62:	6262      	str	r2, [r4, #36]	; 0x24
 8007f64:	781b      	ldrb	r3, [r3, #0]
 8007f66:	6822      	ldr	r2, [r4, #0]
 8007f68:	6293      	str	r3, [r2, #40]	; 0x28
      hi2c->XferCount--;
 8007f6a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007f6c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007f6e:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 8007f70:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 8007f72:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8007f74:	b292      	uxth	r2, r2
      hi2c->XferCount--;
 8007f76:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007f78:	8522      	strh	r2, [r4, #40]	; 0x28
      if((hi2c->XferSize == 0U) && (hi2c->XferCount!=0U))
 8007f7a:	2a00      	cmp	r2, #0
 8007f7c:	d117      	bne.n	8007fae <HAL_I2C_Mem_Write+0x12e>
 8007f7e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007f80:	2b00      	cmp	r3, #0
 8007f82:	d014      	beq.n	8007fae <HAL_I2C_Mem_Write+0x12e>
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8007f84:	9b02      	ldr	r3, [sp, #8]
 8007f86:	2180      	movs	r1, #128	; 0x80
 8007f88:	9300      	str	r3, [sp, #0]
 8007f8a:	0020      	movs	r0, r4
 8007f8c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007f8e:	f7ff fdfb 	bl	8007b88 <I2C_WaitOnFlagUntilTimeout>
 8007f92:	2800      	cmp	r0, #0
 8007f94:	d1c1      	bne.n	8007f1a <HAL_I2C_Mem_Write+0x9a>
        if(hi2c->XferCount > MAX_NBYTE_SIZE)
 8007f96:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007f98:	2bff      	cmp	r3, #255	; 0xff
 8007f9a:	d921      	bls.n	8007fe0 <HAL_I2C_Mem_Write+0x160>
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007f9c:	2380      	movs	r3, #128	; 0x80
 8007f9e:	22ff      	movs	r2, #255	; 0xff
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8007fa0:	8527      	strh	r7, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007fa2:	045b      	lsls	r3, r3, #17
 8007fa4:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007fa6:	0029      	movs	r1, r5
 8007fa8:	0020      	movs	r0, r4
 8007faa:	f7ff fddb 	bl	8007b64 <I2C_TransferConfig>
    }while(hi2c->XferCount > 0U);
 8007fae:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007fb0:	2b00      	cmp	r3, #0
 8007fb2:	d1c3      	bne.n	8007f3c <HAL_I2C_Mem_Write+0xbc>
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8007fb4:	9a02      	ldr	r2, [sp, #8]
 8007fb6:	9910      	ldr	r1, [sp, #64]	; 0x40
 8007fb8:	0020      	movs	r0, r4
 8007fba:	f7ff fedf 	bl	8007d7c <I2C_WaitOnSTOPFlagUntilTimeout>
 8007fbe:	2800      	cmp	r0, #0
 8007fc0:	d1c3      	bne.n	8007f4a <HAL_I2C_Mem_Write+0xca>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007fc2:	2120      	movs	r1, #32
 8007fc4:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
 8007fc6:	4d0a      	ldr	r5, [pc, #40]	; (8007ff0 <HAL_I2C_Mem_Write+0x170>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007fc8:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8007fca:	685a      	ldr	r2, [r3, #4]
 8007fcc:	402a      	ands	r2, r5
 8007fce:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8007fd0:	0023      	movs	r3, r4
 8007fd2:	3341      	adds	r3, #65	; 0x41
 8007fd4:	7019      	strb	r1, [r3, #0]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8007fd6:	9b05      	ldr	r3, [sp, #20]
    __HAL_UNLOCK(hi2c);
 8007fd8:	3440      	adds	r4, #64	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8007fda:	7018      	strb	r0, [r3, #0]
    __HAL_UNLOCK(hi2c);
 8007fdc:	7020      	strb	r0, [r4, #0]
    return HAL_OK;
 8007fde:	e764      	b.n	8007eaa <HAL_I2C_Mem_Write+0x2a>
          hi2c->XferSize = hi2c->XferCount;
 8007fe0:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007fe2:	0033      	movs	r3, r6
          hi2c->XferSize = hi2c->XferCount;
 8007fe4:	b292      	uxth	r2, r2
 8007fe6:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007fe8:	b2d2      	uxtb	r2, r2
 8007fea:	9000      	str	r0, [sp, #0]
 8007fec:	e7db      	b.n	8007fa6 <HAL_I2C_Mem_Write+0x126>
 8007fee:	46c0      	nop			; (mov r8, r8)
 8007ff0:	fe00e800 	.word	0xfe00e800

08007ff4 <HAL_I2C_Mem_Read>:
{
 8007ff4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007ff6:	b089      	sub	sp, #36	; 0x24
 8007ff8:	9307      	str	r3, [sp, #28]
 8007ffa:	ab0e      	add	r3, sp, #56	; 0x38
 8007ffc:	9206      	str	r2, [sp, #24]
 8007ffe:	cb04      	ldmia	r3!, {r2}
 8008000:	0004      	movs	r4, r0
 8008002:	881b      	ldrh	r3, [r3, #0]
 8008004:	9203      	str	r2, [sp, #12]
 8008006:	9304      	str	r3, [sp, #16]
  if(hi2c->State == HAL_I2C_STATE_READY)
 8008008:	0003      	movs	r3, r0
 800800a:	3341      	adds	r3, #65	; 0x41
 800800c:	9305      	str	r3, [sp, #20]
 800800e:	781b      	ldrb	r3, [r3, #0]
{
 8008010:	000d      	movs	r5, r1
    return HAL_BUSY;
 8008012:	2002      	movs	r0, #2
  if(hi2c->State == HAL_I2C_STATE_READY)
 8008014:	2b20      	cmp	r3, #32
 8008016:	d102      	bne.n	800801e <HAL_I2C_Mem_Read+0x2a>
    if((pData == NULL) || (Size == 0U))
 8008018:	2a00      	cmp	r2, #0
 800801a:	d102      	bne.n	8008022 <HAL_I2C_Mem_Read+0x2e>
        return HAL_ERROR;
 800801c:	2001      	movs	r0, #1
}
 800801e:	b009      	add	sp, #36	; 0x24
 8008020:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((pData == NULL) || (Size == 0U))
 8008022:	9b04      	ldr	r3, [sp, #16]
 8008024:	2b00      	cmp	r3, #0
 8008026:	d0f9      	beq.n	800801c <HAL_I2C_Mem_Read+0x28>
    __HAL_LOCK(hi2c);
 8008028:	0027      	movs	r7, r4
 800802a:	3740      	adds	r7, #64	; 0x40
 800802c:	783b      	ldrb	r3, [r7, #0]
 800802e:	2b01      	cmp	r3, #1
 8008030:	d0f5      	beq.n	800801e <HAL_I2C_Mem_Read+0x2a>
 8008032:	2301      	movs	r3, #1
 8008034:	703b      	strb	r3, [r7, #0]
    tickstart = HAL_GetTick();
 8008036:	f7ff f863 	bl	8007100 <HAL_GetTick>
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800803a:	2180      	movs	r1, #128	; 0x80
    tickstart = HAL_GetTick();
 800803c:	9002      	str	r0, [sp, #8]
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800803e:	9000      	str	r0, [sp, #0]
 8008040:	2319      	movs	r3, #25
 8008042:	2201      	movs	r2, #1
 8008044:	0209      	lsls	r1, r1, #8
 8008046:	0020      	movs	r0, r4
 8008048:	f7ff fd9e 	bl	8007b88 <I2C_WaitOnFlagUntilTimeout>
 800804c:	1e06      	subs	r6, r0, #0
 800804e:	d11e      	bne.n	800808e <HAL_I2C_Mem_Read+0x9a>
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8008050:	2322      	movs	r3, #34	; 0x22
 8008052:	9a05      	ldr	r2, [sp, #20]
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8008054:	0029      	movs	r1, r5
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8008056:	7013      	strb	r3, [r2, #0]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8008058:	0023      	movs	r3, r4
 800805a:	3342      	adds	r3, #66	; 0x42
 800805c:	9305      	str	r3, [sp, #20]
 800805e:	2340      	movs	r3, #64	; 0x40
 8008060:	9a05      	ldr	r2, [sp, #20]
 8008062:	7013      	strb	r3, [r2, #0]
    hi2c->pBuffPtr  = pData;
 8008064:	9b03      	ldr	r3, [sp, #12]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8008066:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->pBuffPtr  = pData;
 8008068:	6263      	str	r3, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
 800806a:	9b04      	ldr	r3, [sp, #16]
    hi2c->XferISR   = NULL;
 800806c:	6360      	str	r0, [r4, #52]	; 0x34
    hi2c->XferCount = Size;
 800806e:	8563      	strh	r3, [r4, #42]	; 0x2a
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8008070:	9b02      	ldr	r3, [sp, #8]
 8008072:	9a06      	ldr	r2, [sp, #24]
 8008074:	9301      	str	r3, [sp, #4]
 8008076:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8008078:	0020      	movs	r0, r4
 800807a:	9300      	str	r3, [sp, #0]
 800807c:	9b07      	ldr	r3, [sp, #28]
 800807e:	f7ff fe4a 	bl	8007d16 <I2C_RequestMemoryRead>
 8008082:	2800      	cmp	r0, #0
 8008084:	d005      	beq.n	8008092 <HAL_I2C_Mem_Read+0x9e>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8008086:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8008088:	703e      	strb	r6, [r7, #0]
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800808a:	2b04      	cmp	r3, #4
 800808c:	d0c6      	beq.n	800801c <HAL_I2C_Mem_Read+0x28>
        return HAL_TIMEOUT;
 800808e:	2003      	movs	r0, #3
 8008090:	e7c5      	b.n	800801e <HAL_I2C_Mem_Read+0x2a>
 8008092:	2390      	movs	r3, #144	; 0x90
    if(hi2c->XferCount > MAX_NBYTE_SIZE)
 8008094:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8008096:	019b      	lsls	r3, r3, #6
 8008098:	2aff      	cmp	r2, #255	; 0xff
 800809a:	d949      	bls.n	8008130 <HAL_I2C_Mem_Read+0x13c>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800809c:	22ff      	movs	r2, #255	; 0xff
 800809e:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 80080a0:	9300      	str	r3, [sp, #0]
 80080a2:	2380      	movs	r3, #128	; 0x80
 80080a4:	045b      	lsls	r3, r3, #17
 80080a6:	0029      	movs	r1, r5
 80080a8:	0020      	movs	r0, r4
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 80080aa:	2680      	movs	r6, #128	; 0x80
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 80080ac:	f7ff fd5a 	bl	8007b64 <I2C_TransferConfig>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80080b0:	27ff      	movs	r7, #255	; 0xff
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 80080b2:	04b6      	lsls	r6, r6, #18
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 80080b4:	9b02      	ldr	r3, [sp, #8]
 80080b6:	2200      	movs	r2, #0
 80080b8:	9300      	str	r3, [sp, #0]
 80080ba:	2104      	movs	r1, #4
 80080bc:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80080be:	0020      	movs	r0, r4
 80080c0:	f7ff fd62 	bl	8007b88 <I2C_WaitOnFlagUntilTimeout>
 80080c4:	2800      	cmp	r0, #0
 80080c6:	d1e2      	bne.n	800808e <HAL_I2C_Mem_Read+0x9a>
      (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
 80080c8:	6823      	ldr	r3, [r4, #0]
 80080ca:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80080cc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80080ce:	1c59      	adds	r1, r3, #1
 80080d0:	6261      	str	r1, [r4, #36]	; 0x24
 80080d2:	701a      	strb	r2, [r3, #0]
      hi2c->XferSize--;
 80080d4:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 80080d6:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 80080d8:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 80080da:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 80080dc:	b292      	uxth	r2, r2
      hi2c->XferCount--;
 80080de:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 80080e0:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 80080e2:	8563      	strh	r3, [r4, #42]	; 0x2a
      if((hi2c->XferSize == 0U) && (hi2c->XferCount != 0U))
 80080e4:	2a00      	cmp	r2, #0
 80080e6:	d117      	bne.n	8008118 <HAL_I2C_Mem_Read+0x124>
 80080e8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80080ea:	2b00      	cmp	r3, #0
 80080ec:	d014      	beq.n	8008118 <HAL_I2C_Mem_Read+0x124>
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 80080ee:	9b02      	ldr	r3, [sp, #8]
 80080f0:	2180      	movs	r1, #128	; 0x80
 80080f2:	9300      	str	r3, [sp, #0]
 80080f4:	0020      	movs	r0, r4
 80080f6:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80080f8:	f7ff fd46 	bl	8007b88 <I2C_WaitOnFlagUntilTimeout>
 80080fc:	2800      	cmp	r0, #0
 80080fe:	d1c6      	bne.n	800808e <HAL_I2C_Mem_Read+0x9a>
        if(hi2c->XferCount > MAX_NBYTE_SIZE)
 8008100:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8008102:	2bff      	cmp	r3, #255	; 0xff
 8008104:	d91c      	bls.n	8008140 <HAL_I2C_Mem_Read+0x14c>
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8008106:	2380      	movs	r3, #128	; 0x80
 8008108:	22ff      	movs	r2, #255	; 0xff
          hi2c->XferSize = MAX_NBYTE_SIZE;
 800810a:	8527      	strh	r7, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 800810c:	045b      	lsls	r3, r3, #17
 800810e:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8008110:	0029      	movs	r1, r5
 8008112:	0020      	movs	r0, r4
 8008114:	f7ff fd26 	bl	8007b64 <I2C_TransferConfig>
    }while(hi2c->XferCount > 0U);
 8008118:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800811a:	2b00      	cmp	r3, #0
 800811c:	d1ca      	bne.n	80080b4 <HAL_I2C_Mem_Read+0xc0>
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800811e:	9a02      	ldr	r2, [sp, #8]
 8008120:	9910      	ldr	r1, [sp, #64]	; 0x40
 8008122:	0020      	movs	r0, r4
 8008124:	f7ff fe2a 	bl	8007d7c <I2C_WaitOnSTOPFlagUntilTimeout>
 8008128:	2800      	cmp	r0, #0
 800812a:	d010      	beq.n	800814e <HAL_I2C_Mem_Read+0x15a>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800812c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800812e:	e7ac      	b.n	800808a <HAL_I2C_Mem_Read+0x96>
      hi2c->XferSize = hi2c->XferCount;
 8008130:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8008132:	b292      	uxth	r2, r2
 8008134:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 8008136:	9300      	str	r3, [sp, #0]
 8008138:	2380      	movs	r3, #128	; 0x80
 800813a:	b2d2      	uxtb	r2, r2
 800813c:	049b      	lsls	r3, r3, #18
 800813e:	e7b2      	b.n	80080a6 <HAL_I2C_Mem_Read+0xb2>
          hi2c->XferSize = hi2c->XferCount;
 8008140:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8008142:	0033      	movs	r3, r6
          hi2c->XferSize = hi2c->XferCount;
 8008144:	b292      	uxth	r2, r2
 8008146:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8008148:	b2d2      	uxtb	r2, r2
 800814a:	9000      	str	r0, [sp, #0]
 800814c:	e7e0      	b.n	8008110 <HAL_I2C_Mem_Read+0x11c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800814e:	2120      	movs	r1, #32
 8008150:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
 8008152:	4d06      	ldr	r5, [pc, #24]	; (800816c <HAL_I2C_Mem_Read+0x178>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8008154:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8008156:	685a      	ldr	r2, [r3, #4]
 8008158:	402a      	ands	r2, r5
 800815a:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 800815c:	0023      	movs	r3, r4
 800815e:	3341      	adds	r3, #65	; 0x41
 8008160:	7019      	strb	r1, [r3, #0]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8008162:	9b05      	ldr	r3, [sp, #20]
    __HAL_UNLOCK(hi2c);
 8008164:	3440      	adds	r4, #64	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8008166:	7018      	strb	r0, [r3, #0]
    __HAL_UNLOCK(hi2c);
 8008168:	7020      	strb	r0, [r4, #0]
    return HAL_OK;
 800816a:	e758      	b.n	800801e <HAL_I2C_Mem_Read+0x2a>
 800816c:	fe00e800 	.word	0xfe00e800

08008170 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 8008170:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if(hi2c->State == HAL_I2C_STATE_READY)
 8008172:	0004      	movs	r4, r0
 8008174:	3441      	adds	r4, #65	; 0x41
 8008176:	7822      	ldrb	r2, [r4, #0]
{
 8008178:	0003      	movs	r3, r0
  if(hi2c->State == HAL_I2C_STATE_READY)
 800817a:	b2d2      	uxtb	r2, r2

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 800817c:	2002      	movs	r0, #2
  if(hi2c->State == HAL_I2C_STATE_READY)
 800817e:	2a20      	cmp	r2, #32
 8008180:	d118      	bne.n	80081b4 <HAL_I2CEx_ConfigAnalogFilter+0x44>
    __HAL_LOCK(hi2c);
 8008182:	001d      	movs	r5, r3
 8008184:	3540      	adds	r5, #64	; 0x40
 8008186:	782e      	ldrb	r6, [r5, #0]
 8008188:	2e01      	cmp	r6, #1
 800818a:	d013      	beq.n	80081b4 <HAL_I2CEx_ConfigAnalogFilter+0x44>
    __HAL_I2C_DISABLE(hi2c);
 800818c:	681b      	ldr	r3, [r3, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 800818e:	3022      	adds	r0, #34	; 0x22
 8008190:	7020      	strb	r0, [r4, #0]
    __HAL_I2C_DISABLE(hi2c);
 8008192:	681e      	ldr	r6, [r3, #0]
 8008194:	3823      	subs	r0, #35	; 0x23
 8008196:	4386      	bics	r6, r0
 8008198:	601e      	str	r6, [r3, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 800819a:	681e      	ldr	r6, [r3, #0]
 800819c:	4f06      	ldr	r7, [pc, #24]	; (80081b8 <HAL_I2CEx_ConfigAnalogFilter+0x48>)
 800819e:	403e      	ands	r6, r7
 80081a0:	601e      	str	r6, [r3, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
 80081a2:	681e      	ldr	r6, [r3, #0]
 80081a4:	4331      	orrs	r1, r6
 80081a6:	6019      	str	r1, [r3, #0]
    __HAL_I2C_ENABLE(hi2c);
 80081a8:	6819      	ldr	r1, [r3, #0]
 80081aa:	4308      	orrs	r0, r1
 80081ac:	6018      	str	r0, [r3, #0]
    __HAL_UNLOCK(hi2c);
 80081ae:	2000      	movs	r0, #0
    hi2c->State = HAL_I2C_STATE_READY;
 80081b0:	7022      	strb	r2, [r4, #0]
    __HAL_UNLOCK(hi2c);
 80081b2:	7028      	strb	r0, [r5, #0]
  }
}
 80081b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80081b6:	46c0      	nop			; (mov r8, r8)
 80081b8:	ffffefff 	.word	0xffffefff

080081bc <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80081bc:	b530      	push	{r4, r5, lr}
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 80081be:	4c1b      	ldr	r4, [pc, #108]	; (800822c <HAL_RCC_GetSysClockFreq+0x70>)
{
 80081c0:	b089      	sub	sp, #36	; 0x24
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 80081c2:	2210      	movs	r2, #16
 80081c4:	0021      	movs	r1, r4
 80081c6:	4668      	mov	r0, sp
 80081c8:	f004 fc70 	bl	800caac <memcpy>
                                         10U, 11U, 12U, 13U, 14U, 15U, 16U, 16U};
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 80081cc:	0021      	movs	r1, r4
 80081ce:	ad04      	add	r5, sp, #16
 80081d0:	2210      	movs	r2, #16
 80081d2:	3110      	adds	r1, #16
 80081d4:	0028      	movs	r0, r5
 80081d6:	f004 fc69 	bl	800caac <memcpy>
  uint32_t sysclockfreq = 0U;
  
  tmpreg = RCC->CFGR;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 80081da:	200c      	movs	r0, #12
  tmpreg = RCC->CFGR;
 80081dc:	4a14      	ldr	r2, [pc, #80]	; (8008230 <HAL_RCC_GetSysClockFreq+0x74>)
 80081de:	6853      	ldr	r3, [r2, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 80081e0:	4018      	ands	r0, r3
 80081e2:	2808      	cmp	r0, #8
 80081e4:	d009      	beq.n	80081fa <HAL_RCC_GetSysClockFreq+0x3e>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 80081e6:	380c      	subs	r0, #12
 80081e8:	4243      	negs	r3, r0
 80081ea:	4158      	adcs	r0, r3
 80081ec:	4b11      	ldr	r3, [pc, #68]	; (8008234 <HAL_RCC_GetSysClockFreq+0x78>)
 80081ee:	4240      	negs	r0, r0
 80081f0:	4018      	ands	r0, r3
 80081f2:	4b11      	ldr	r3, [pc, #68]	; (8008238 <HAL_RCC_GetSysClockFreq+0x7c>)
 80081f4:	18c0      	adds	r0, r0, r3
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 80081f6:	b009      	add	sp, #36	; 0x24
 80081f8:	bd30      	pop	{r4, r5, pc}
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 80081fa:	200f      	movs	r0, #15
 80081fc:	466c      	mov	r4, sp
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 80081fe:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 8008200:	0c99      	lsrs	r1, r3, #18
 8008202:	4001      	ands	r1, r0
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 8008204:	4002      	ands	r2, r0
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 8008206:	5c64      	ldrb	r4, [r4, r1]
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 8008208:	5ca9      	ldrb	r1, [r5, r2]
      if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 800820a:	22c0      	movs	r2, #192	; 0xc0
 800820c:	2080      	movs	r0, #128	; 0x80
 800820e:	0252      	lsls	r2, r2, #9
 8008210:	4013      	ands	r3, r2
 8008212:	0240      	lsls	r0, r0, #9
 8008214:	4283      	cmp	r3, r0
 8008216:	d101      	bne.n	800821c <HAL_RCC_GetSysClockFreq+0x60>
        pllclk = (HSI_VALUE / prediv) * pllmul;
 8008218:	4807      	ldr	r0, [pc, #28]	; (8008238 <HAL_RCC_GetSysClockFreq+0x7c>)
 800821a:	e002      	b.n	8008222 <HAL_RCC_GetSysClockFreq+0x66>
      else if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSI48)
 800821c:	4293      	cmp	r3, r2
 800821e:	d1fb      	bne.n	8008218 <HAL_RCC_GetSysClockFreq+0x5c>
        pllclk = (HSI48_VALUE / prediv) * pllmul;
 8008220:	4806      	ldr	r0, [pc, #24]	; (800823c <HAL_RCC_GetSysClockFreq+0x80>)
        pllclk = (HSI_VALUE / prediv) * pllmul;
 8008222:	f7fd fbd1 	bl	80059c8 <__udivsi3>
 8008226:	4360      	muls	r0, r4
 8008228:	e7e5      	b.n	80081f6 <HAL_RCC_GetSysClockFreq+0x3a>
 800822a:	46c0      	nop			; (mov r8, r8)
 800822c:	0800cc34 	.word	0x0800cc34
 8008230:	40021000 	.word	0x40021000
 8008234:	02625a00 	.word	0x02625a00
 8008238:	007a1200 	.word	0x007a1200
 800823c:	02dc6c00 	.word	0x02dc6c00

08008240 <HAL_RCC_GetHCLKFreq>:
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
 8008240:	4b01      	ldr	r3, [pc, #4]	; (8008248 <HAL_RCC_GetHCLKFreq+0x8>)
 8008242:	6818      	ldr	r0, [r3, #0]
}
 8008244:	4770      	bx	lr
 8008246:	46c0      	nop			; (mov r8, r8)
 8008248:	20000030 	.word	0x20000030

0800824c <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE) >> RCC_CFGR_PPRE_BITNUMBER]);
 800824c:	4b04      	ldr	r3, [pc, #16]	; (8008260 <HAL_RCC_GetPCLK1Freq+0x14>)
 800824e:	4a05      	ldr	r2, [pc, #20]	; (8008264 <HAL_RCC_GetPCLK1Freq+0x18>)
 8008250:	685b      	ldr	r3, [r3, #4]
 8008252:	055b      	lsls	r3, r3, #21
 8008254:	0f5b      	lsrs	r3, r3, #29
 8008256:	5cd3      	ldrb	r3, [r2, r3]
 8008258:	4a03      	ldr	r2, [pc, #12]	; (8008268 <HAL_RCC_GetPCLK1Freq+0x1c>)
 800825a:	6810      	ldr	r0, [r2, #0]
 800825c:	40d8      	lsrs	r0, r3
}    
 800825e:	4770      	bx	lr
 8008260:	40021000 	.word	0x40021000
 8008264:	0800cc2c 	.word	0x0800cc2c
 8008268:	20000030 	.word	0x20000030

0800826c <SPI_WaitFifoStateUntilTimeout.part.1>:
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800826c:	21e0      	movs	r1, #224	; 0xe0
 800826e:	6803      	ldr	r3, [r0, #0]
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State,
 8008270:	b510      	push	{r4, lr}
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8008272:	685a      	ldr	r2, [r3, #4]
 8008274:	438a      	bics	r2, r1
 8008276:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8008278:	2282      	movs	r2, #130	; 0x82
 800827a:	6841      	ldr	r1, [r0, #4]
 800827c:	0052      	lsls	r2, r2, #1
 800827e:	4291      	cmp	r1, r2
 8008280:	d10c      	bne.n	800829c <SPI_WaitFifoStateUntilTimeout.part.1+0x30>
 8008282:	2180      	movs	r1, #128	; 0x80
 8008284:	6882      	ldr	r2, [r0, #8]
 8008286:	0209      	lsls	r1, r1, #8
 8008288:	428a      	cmp	r2, r1
 800828a:	d003      	beq.n	8008294 <SPI_WaitFifoStateUntilTimeout.part.1+0x28>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800828c:	2180      	movs	r1, #128	; 0x80
 800828e:	00c9      	lsls	r1, r1, #3
 8008290:	428a      	cmp	r2, r1
 8008292:	d103      	bne.n	800829c <SPI_WaitFifoStateUntilTimeout.part.1+0x30>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 8008294:	2140      	movs	r1, #64	; 0x40
 8008296:	681a      	ldr	r2, [r3, #0]
 8008298:	438a      	bics	r2, r1
 800829a:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800829c:	2180      	movs	r1, #128	; 0x80
 800829e:	6a82      	ldr	r2, [r0, #40]	; 0x28
 80082a0:	0189      	lsls	r1, r1, #6
 80082a2:	428a      	cmp	r2, r1
 80082a4:	d106      	bne.n	80082b4 <SPI_WaitFifoStateUntilTimeout.part.1+0x48>
        {
          SPI_RESET_CRC(hspi);
 80082a6:	6819      	ldr	r1, [r3, #0]
 80082a8:	4c07      	ldr	r4, [pc, #28]	; (80082c8 <SPI_WaitFifoStateUntilTimeout.part.1+0x5c>)
 80082aa:	4021      	ands	r1, r4
 80082ac:	6019      	str	r1, [r3, #0]
 80082ae:	6819      	ldr	r1, [r3, #0]
 80082b0:	430a      	orrs	r2, r1
 80082b2:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 80082b4:	0003      	movs	r3, r0
 80082b6:	2201      	movs	r2, #1
 80082b8:	335d      	adds	r3, #93	; 0x5d
 80082ba:	701a      	strb	r2, [r3, #0]

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 80082bc:	2300      	movs	r3, #0
 80082be:	305c      	adds	r0, #92	; 0x5c
 80082c0:	7003      	strb	r3, [r0, #0]
      }
    }
  }

  return HAL_OK;
}
 80082c2:	2003      	movs	r0, #3
 80082c4:	bd10      	pop	{r4, pc}
 80082c6:	46c0      	nop			; (mov r8, r8)
 80082c8:	ffffdfff 	.word	0xffffdfff

080082cc <SPI_WaitFlagStateUntilTimeout>:
{
 80082cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80082ce:	0006      	movs	r6, r0
 80082d0:	000d      	movs	r5, r1
 80082d2:	0017      	movs	r7, r2
 80082d4:	001c      	movs	r4, r3
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 80082d6:	6832      	ldr	r2, [r6, #0]
 80082d8:	6893      	ldr	r3, [r2, #8]
 80082da:	402b      	ands	r3, r5
 80082dc:	1b5b      	subs	r3, r3, r5
 80082de:	4259      	negs	r1, r3
 80082e0:	414b      	adcs	r3, r1
 80082e2:	429f      	cmp	r7, r3
 80082e4:	d101      	bne.n	80082ea <SPI_WaitFlagStateUntilTimeout+0x1e>
  return HAL_OK;
 80082e6:	2000      	movs	r0, #0
 80082e8:	e006      	b.n	80082f8 <SPI_WaitFlagStateUntilTimeout+0x2c>
    if (Timeout != HAL_MAX_DELAY)
 80082ea:	1c63      	adds	r3, r4, #1
 80082ec:	d0f4      	beq.n	80082d8 <SPI_WaitFlagStateUntilTimeout+0xc>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 80082ee:	2c00      	cmp	r4, #0
 80082f0:	d103      	bne.n	80082fa <SPI_WaitFlagStateUntilTimeout+0x2e>
 80082f2:	0030      	movs	r0, r6
 80082f4:	f7ff ffba 	bl	800826c <SPI_WaitFifoStateUntilTimeout.part.1>
}
 80082f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 80082fa:	f7fe ff01 	bl	8007100 <HAL_GetTick>
 80082fe:	9b06      	ldr	r3, [sp, #24]
 8008300:	1ac0      	subs	r0, r0, r3
 8008302:	42a0      	cmp	r0, r4
 8008304:	d3e7      	bcc.n	80082d6 <SPI_WaitFlagStateUntilTimeout+0xa>
 8008306:	e7f4      	b.n	80082f2 <SPI_WaitFlagStateUntilTimeout+0x26>

08008308 <SPI_WaitFifoStateUntilTimeout>:
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8008308:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800830a:	0007      	movs	r7, r0
 800830c:	000e      	movs	r6, r1
 800830e:	0015      	movs	r5, r2
 8008310:	001c      	movs	r4, r3

  while ((hspi->Instance->SR & Fifo) != State)
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
    {
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 8008312:	466b      	mov	r3, sp
  while ((hspi->Instance->SR & Fifo) != State)
 8008314:	6839      	ldr	r1, [r7, #0]
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 8008316:	1dda      	adds	r2, r3, #7
  while ((hspi->Instance->SR & Fifo) != State)
 8008318:	688b      	ldr	r3, [r1, #8]
 800831a:	4033      	ands	r3, r6
 800831c:	42ab      	cmp	r3, r5
 800831e:	d101      	bne.n	8008324 <SPI_WaitFifoStateUntilTimeout+0x1c>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 8008320:	2000      	movs	r0, #0
 8008322:	e010      	b.n	8008346 <SPI_WaitFifoStateUntilTimeout+0x3e>
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 8008324:	23c0      	movs	r3, #192	; 0xc0
 8008326:	00db      	lsls	r3, r3, #3
 8008328:	429e      	cmp	r6, r3
 800832a:	d105      	bne.n	8008338 <SPI_WaitFifoStateUntilTimeout+0x30>
 800832c:	2d00      	cmp	r5, #0
 800832e:	d103      	bne.n	8008338 <SPI_WaitFifoStateUntilTimeout+0x30>
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 8008330:	7b0b      	ldrb	r3, [r1, #12]
 8008332:	b2db      	uxtb	r3, r3
 8008334:	7013      	strb	r3, [r2, #0]
      UNUSED(tmpreg);
 8008336:	7813      	ldrb	r3, [r2, #0]
    if (Timeout != HAL_MAX_DELAY)
 8008338:	1c63      	adds	r3, r4, #1
 800833a:	d0ed      	beq.n	8008318 <SPI_WaitFifoStateUntilTimeout+0x10>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 800833c:	2c00      	cmp	r4, #0
 800833e:	d103      	bne.n	8008348 <SPI_WaitFifoStateUntilTimeout+0x40>
 8008340:	0038      	movs	r0, r7
 8008342:	f7ff ff93 	bl	800826c <SPI_WaitFifoStateUntilTimeout.part.1>
}
 8008346:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 8008348:	f7fe feda 	bl	8007100 <HAL_GetTick>
 800834c:	9b08      	ldr	r3, [sp, #32]
 800834e:	1ac0      	subs	r0, r0, r3
 8008350:	42a0      	cmp	r0, r4
 8008352:	d3de      	bcc.n	8008312 <SPI_WaitFifoStateUntilTimeout+0xa>
 8008354:	e7f4      	b.n	8008340 <SPI_WaitFifoStateUntilTimeout+0x38>

08008356 <SPI_EndRxTransaction>:
  * @param  Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
{
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8008356:	2382      	movs	r3, #130	; 0x82
{
 8008358:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800835a:	0017      	movs	r7, r2
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800835c:	6842      	ldr	r2, [r0, #4]
{
 800835e:	0004      	movs	r4, r0
 8008360:	000e      	movs	r6, r1
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8008362:	005b      	lsls	r3, r3, #1
 8008364:	429a      	cmp	r2, r3
 8008366:	d10d      	bne.n	8008384 <SPI_EndRxTransaction+0x2e>
 8008368:	2280      	movs	r2, #128	; 0x80
 800836a:	6883      	ldr	r3, [r0, #8]
 800836c:	0212      	lsls	r2, r2, #8
 800836e:	4293      	cmp	r3, r2
 8008370:	d003      	beq.n	800837a <SPI_EndRxTransaction+0x24>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8008372:	2280      	movs	r2, #128	; 0x80
 8008374:	00d2      	lsls	r2, r2, #3
 8008376:	4293      	cmp	r3, r2
 8008378:	d104      	bne.n	8008384 <SPI_EndRxTransaction+0x2e>
  {
    /* Disable SPI peripheral */
    __HAL_SPI_DISABLE(hspi);
 800837a:	2140      	movs	r1, #64	; 0x40
 800837c:	6822      	ldr	r2, [r4, #0]
 800837e:	6813      	ldr	r3, [r2, #0]
 8008380:	438b      	bics	r3, r1
 8008382:	6013      	str	r3, [r2, #0]
  }

  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8008384:	9700      	str	r7, [sp, #0]
 8008386:	0033      	movs	r3, r6
 8008388:	2200      	movs	r2, #0
 800838a:	2180      	movs	r1, #128	; 0x80
 800838c:	0020      	movs	r0, r4
 800838e:	f7ff ff9d 	bl	80082cc <SPI_WaitFlagStateUntilTimeout>
 8008392:	1e05      	subs	r5, r0, #0
 8008394:	d005      	beq.n	80083a2 <SPI_EndRxTransaction+0x4c>
  }

  /* Control if the RX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8008396:	2320      	movs	r3, #32
 8008398:	6e22      	ldr	r2, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 800839a:	2503      	movs	r5, #3
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800839c:	4313      	orrs	r3, r2
 800839e:	6623      	str	r3, [r4, #96]	; 0x60
 80083a0:	e017      	b.n	80083d2 <SPI_EndRxTransaction+0x7c>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80083a2:	2382      	movs	r3, #130	; 0x82
 80083a4:	6862      	ldr	r2, [r4, #4]
 80083a6:	005b      	lsls	r3, r3, #1
 80083a8:	429a      	cmp	r2, r3
 80083aa:	d112      	bne.n	80083d2 <SPI_EndRxTransaction+0x7c>
 80083ac:	2280      	movs	r2, #128	; 0x80
 80083ae:	68a3      	ldr	r3, [r4, #8]
 80083b0:	0212      	lsls	r2, r2, #8
 80083b2:	4293      	cmp	r3, r2
 80083b4:	d003      	beq.n	80083be <SPI_EndRxTransaction+0x68>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80083b6:	2280      	movs	r2, #128	; 0x80
 80083b8:	00d2      	lsls	r2, r2, #3
 80083ba:	4293      	cmp	r3, r2
 80083bc:	d109      	bne.n	80083d2 <SPI_EndRxTransaction+0x7c>
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80083be:	21c0      	movs	r1, #192	; 0xc0
 80083c0:	9700      	str	r7, [sp, #0]
 80083c2:	0033      	movs	r3, r6
 80083c4:	2200      	movs	r2, #0
 80083c6:	00c9      	lsls	r1, r1, #3
 80083c8:	0020      	movs	r0, r4
 80083ca:	f7ff ff9d 	bl	8008308 <SPI_WaitFifoStateUntilTimeout>
 80083ce:	2800      	cmp	r0, #0
 80083d0:	d1e1      	bne.n	8008396 <SPI_EndRxTransaction+0x40>
}
 80083d2:	0028      	movs	r0, r5
 80083d4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

080083d6 <SPI_EndRxTxTransaction>:
{
 80083d6:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80083d8:	000b      	movs	r3, r1
{
 80083da:	000d      	movs	r5, r1
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80083dc:	21c0      	movs	r1, #192	; 0xc0
 80083de:	9200      	str	r2, [sp, #0]
{
 80083e0:	0016      	movs	r6, r2
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80083e2:	0149      	lsls	r1, r1, #5
 80083e4:	2200      	movs	r2, #0
{
 80083e6:	0004      	movs	r4, r0
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80083e8:	f7ff ff8e 	bl	8008308 <SPI_WaitFifoStateUntilTimeout>
 80083ec:	1e02      	subs	r2, r0, #0
 80083ee:	d005      	beq.n	80083fc <SPI_EndRxTxTransaction+0x26>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80083f0:	2320      	movs	r3, #32
 80083f2:	6e22      	ldr	r2, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 80083f4:	2003      	movs	r0, #3
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80083f6:	4313      	orrs	r3, r2
 80083f8:	6623      	str	r3, [r4, #96]	; 0x60
 80083fa:	e010      	b.n	800841e <SPI_EndRxTxTransaction+0x48>
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 80083fc:	9600      	str	r6, [sp, #0]
 80083fe:	002b      	movs	r3, r5
 8008400:	2180      	movs	r1, #128	; 0x80
 8008402:	0020      	movs	r0, r4
 8008404:	f7ff ff62 	bl	80082cc <SPI_WaitFlagStateUntilTimeout>
 8008408:	1e02      	subs	r2, r0, #0
 800840a:	d1f1      	bne.n	80083f0 <SPI_EndRxTxTransaction+0x1a>
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 800840c:	21c0      	movs	r1, #192	; 0xc0
 800840e:	9600      	str	r6, [sp, #0]
 8008410:	002b      	movs	r3, r5
 8008412:	00c9      	lsls	r1, r1, #3
 8008414:	0020      	movs	r0, r4
 8008416:	f7ff ff77 	bl	8008308 <SPI_WaitFifoStateUntilTimeout>
 800841a:	2800      	cmp	r0, #0
 800841c:	d1e8      	bne.n	80083f0 <SPI_EndRxTxTransaction+0x1a>
  }
  return HAL_OK;
}
 800841e:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08008420 <HAL_SPI_Init>:
{
 8008420:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8008422:	0004      	movs	r4, r0
    return HAL_ERROR;
 8008424:	2001      	movs	r0, #1
  if (hspi == NULL)
 8008426:	2c00      	cmp	r4, #0
 8008428:	d05f      	beq.n	80084ea <HAL_SPI_Init+0xca>
  if (hspi->State == HAL_SPI_STATE_RESET)
 800842a:	0025      	movs	r5, r4
 800842c:	355d      	adds	r5, #93	; 0x5d
 800842e:	782b      	ldrb	r3, [r5, #0]
 8008430:	b2db      	uxtb	r3, r3
 8008432:	2b00      	cmp	r3, #0
 8008434:	d105      	bne.n	8008442 <HAL_SPI_Init+0x22>
    hspi->Lock = HAL_UNLOCKED;
 8008436:	0022      	movs	r2, r4
 8008438:	325c      	adds	r2, #92	; 0x5c
 800843a:	7013      	strb	r3, [r2, #0]
    HAL_SPI_MspInit(hspi);
 800843c:	0020      	movs	r0, r4
 800843e:	f7fd fd27 	bl	8005e90 <HAL_SPI_MspInit>
  hspi->State = HAL_SPI_STATE_BUSY;
 8008442:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);
 8008444:	2140      	movs	r1, #64	; 0x40
 8008446:	6822      	ldr	r2, [r4, #0]
  hspi->State = HAL_SPI_STATE_BUSY;
 8008448:	702b      	strb	r3, [r5, #0]
  __HAL_SPI_DISABLE(hspi);
 800844a:	6813      	ldr	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800844c:	68e0      	ldr	r0, [r4, #12]
  __HAL_SPI_DISABLE(hspi);
 800844e:	438b      	bics	r3, r1
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008450:	21e0      	movs	r1, #224	; 0xe0
  __HAL_SPI_DISABLE(hspi);
 8008452:	6013      	str	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008454:	00c9      	lsls	r1, r1, #3
 8008456:	2300      	movs	r3, #0
 8008458:	4288      	cmp	r0, r1
 800845a:	d847      	bhi.n	80084ec <HAL_SPI_Init+0xcc>
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 800845c:	2680      	movs	r6, #128	; 0x80
 800845e:	0176      	lsls	r6, r6, #5
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8008460:	4288      	cmp	r0, r1
 8008462:	d101      	bne.n	8008468 <HAL_SPI_Init+0x48>
 8008464:	e001      	b.n	800846a <HAL_SPI_Init+0x4a>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8008466:	001e      	movs	r6, r3
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8008468:	62a3      	str	r3, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 800846a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800846c:	2b00      	cmp	r3, #0
 800846e:	d104      	bne.n	800847a <HAL_SPI_Init+0x5a>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 8008470:	3302      	adds	r3, #2
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008472:	4288      	cmp	r0, r1
 8008474:	d800      	bhi.n	8008478 <HAL_SPI_Init+0x58>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 8008476:	2301      	movs	r3, #1
 8008478:	6323      	str	r3, [r4, #48]	; 0x30
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 800847a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800847c:	68a7      	ldr	r7, [r4, #8]
 800847e:	9301      	str	r3, [sp, #4]
 8008480:	6863      	ldr	r3, [r4, #4]
 8008482:	69a1      	ldr	r1, [r4, #24]
 8008484:	433b      	orrs	r3, r7
 8008486:	6927      	ldr	r7, [r4, #16]
 8008488:	433b      	orrs	r3, r7
 800848a:	6967      	ldr	r7, [r4, #20]
 800848c:	433b      	orrs	r3, r7
 800848e:	69e7      	ldr	r7, [r4, #28]
 8008490:	433b      	orrs	r3, r7
 8008492:	6a27      	ldr	r7, [r4, #32]
 8008494:	433b      	orrs	r3, r7
 8008496:	9f01      	ldr	r7, [sp, #4]
 8008498:	433b      	orrs	r3, r7
 800849a:	2780      	movs	r7, #128	; 0x80
 800849c:	00bf      	lsls	r7, r7, #2
 800849e:	400f      	ands	r7, r1
 80084a0:	433b      	orrs	r3, r7
 80084a2:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 80084a4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80084a6:	2b02      	cmp	r3, #2
 80084a8:	d106      	bne.n	80084b8 <HAL_SPI_Init+0x98>
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
 80084aa:	6813      	ldr	r3, [r2, #0]
 80084ac:	469c      	mov	ip, r3
 80084ae:	2380      	movs	r3, #128	; 0x80
 80084b0:	4667      	mov	r7, ip
 80084b2:	011b      	lsls	r3, r3, #4
 80084b4:	433b      	orrs	r3, r7
 80084b6:	6013      	str	r3, [r2, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 80084b8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80084ba:	0c09      	lsrs	r1, r1, #16
 80084bc:	4318      	orrs	r0, r3
 80084be:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80084c0:	4318      	orrs	r0, r3
 80084c2:	2304      	movs	r3, #4
 80084c4:	4019      	ands	r1, r3
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80084c6:	2380      	movs	r3, #128	; 0x80
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 80084c8:	4301      	orrs	r1, r0
 80084ca:	430e      	orrs	r6, r1
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80084cc:	9901      	ldr	r1, [sp, #4]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 80084ce:	6056      	str	r6, [r2, #4]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80084d0:	019b      	lsls	r3, r3, #6
 80084d2:	4299      	cmp	r1, r3
 80084d4:	d101      	bne.n	80084da <HAL_SPI_Init+0xba>
    WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
 80084d6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80084d8:	6113      	str	r3, [r2, #16]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80084da:	69d3      	ldr	r3, [r2, #28]
 80084dc:	4906      	ldr	r1, [pc, #24]	; (80084f8 <HAL_SPI_Init+0xd8>)
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80084de:	2000      	movs	r0, #0
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80084e0:	400b      	ands	r3, r1
 80084e2:	61d3      	str	r3, [r2, #28]
  hspi->State     = HAL_SPI_STATE_READY;
 80084e4:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80084e6:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 80084e8:	702b      	strb	r3, [r5, #0]
}
 80084ea:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 80084ec:	26f0      	movs	r6, #240	; 0xf0
 80084ee:	0136      	lsls	r6, r6, #4
 80084f0:	42b0      	cmp	r0, r6
 80084f2:	d1b8      	bne.n	8008466 <HAL_SPI_Init+0x46>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 80084f4:	001e      	movs	r6, r3
 80084f6:	e7b8      	b.n	800846a <HAL_SPI_Init+0x4a>
 80084f8:	fffff7ff 	.word	0xfffff7ff

080084fc <HAL_SPI_Transmit_DMA>:
{
 80084fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hspi);
 80084fe:	0005      	movs	r5, r0
 8008500:	355c      	adds	r5, #92	; 0x5c
 8008502:	782b      	ldrb	r3, [r5, #0]
{
 8008504:	0004      	movs	r4, r0
  __HAL_LOCK(hspi);
 8008506:	2002      	movs	r0, #2
 8008508:	2b01      	cmp	r3, #1
 800850a:	d069      	beq.n	80085e0 <HAL_SPI_Transmit_DMA+0xe4>
 800850c:	2301      	movs	r3, #1
  if (hspi->State != HAL_SPI_STATE_READY)
 800850e:	0026      	movs	r6, r4
  __HAL_LOCK(hspi);
 8008510:	702b      	strb	r3, [r5, #0]
  if (hspi->State != HAL_SPI_STATE_READY)
 8008512:	365d      	adds	r6, #93	; 0x5d
 8008514:	7833      	ldrb	r3, [r6, #0]
 8008516:	b2db      	uxtb	r3, r3
 8008518:	2b01      	cmp	r3, #1
 800851a:	d15f      	bne.n	80085dc <HAL_SPI_Transmit_DMA+0xe0>
    errorcode = HAL_ERROR;
 800851c:	0018      	movs	r0, r3
  if ((pData == NULL) || (Size == 0U))
 800851e:	2900      	cmp	r1, #0
 8008520:	d05c      	beq.n	80085dc <HAL_SPI_Transmit_DMA+0xe0>
 8008522:	2a00      	cmp	r2, #0
 8008524:	d05a      	beq.n	80085dc <HAL_SPI_Transmit_DMA+0xe0>
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8008526:	3302      	adds	r3, #2
 8008528:	7033      	strb	r3, [r6, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800852a:	2300      	movs	r3, #0
  hspi->TxXferSize  = Size;
 800852c:	87a2      	strh	r2, [r4, #60]	; 0x3c
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800852e:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->TxXferCount = Size;
 8008530:	87e2      	strh	r2, [r4, #62]	; 0x3e
  hspi->RxXferSize  = 0U;
 8008532:	1da2      	adds	r2, r4, #6
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8008534:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->TxISR       = NULL;
 8008536:	6523      	str	r3, [r4, #80]	; 0x50
  hspi->RxISR       = NULL;
 8008538:	64e3      	str	r3, [r4, #76]	; 0x4c
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 800853a:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->RxXferCount = 0U;
 800853c:	3202      	adds	r2, #2
  hspi->RxXferSize  = 0U;
 800853e:	8793      	strh	r3, [r2, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 8008540:	87d3      	strh	r3, [r2, #62]	; 0x3e
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8008542:	2380      	movs	r3, #128	; 0x80
 8008544:	68a0      	ldr	r0, [r4, #8]
 8008546:	6822      	ldr	r2, [r4, #0]
 8008548:	021b      	lsls	r3, r3, #8
 800854a:	4298      	cmp	r0, r3
 800854c:	d104      	bne.n	8008558 <HAL_SPI_Transmit_DMA+0x5c>
    SPI_1LINE_TX(hspi);
 800854e:	2380      	movs	r3, #128	; 0x80
 8008550:	6810      	ldr	r0, [r2, #0]
 8008552:	01db      	lsls	r3, r3, #7
 8008554:	4303      	orrs	r3, r0
 8008556:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008558:	2080      	movs	r0, #128	; 0x80
 800855a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800855c:	0180      	lsls	r0, r0, #6
 800855e:	4283      	cmp	r3, r0
 8008560:	d106      	bne.n	8008570 <HAL_SPI_Transmit_DMA+0x74>
    SPI_RESET_CRC(hspi);
 8008562:	6810      	ldr	r0, [r2, #0]
 8008564:	4e23      	ldr	r6, [pc, #140]	; (80085f4 <HAL_SPI_Transmit_DMA+0xf8>)
 8008566:	4030      	ands	r0, r6
 8008568:	6010      	str	r0, [r2, #0]
 800856a:	6810      	ldr	r0, [r2, #0]
 800856c:	4303      	orrs	r3, r0
 800856e:	6013      	str	r3, [r2, #0]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 8008570:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8008572:	4b21      	ldr	r3, [pc, #132]	; (80085f8 <HAL_SPI_Transmit_DMA+0xfc>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8008574:	6856      	ldr	r6, [r2, #4]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 8008576:	62c3      	str	r3, [r0, #44]	; 0x2c
  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
 8008578:	4b20      	ldr	r3, [pc, #128]	; (80085fc <HAL_SPI_Transmit_DMA+0x100>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 800857a:	4f21      	ldr	r7, [pc, #132]	; (8008600 <HAL_SPI_Transmit_DMA+0x104>)
  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
 800857c:	6283      	str	r3, [r0, #40]	; 0x28
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 800857e:	4b21      	ldr	r3, [pc, #132]	; (8008604 <HAL_SPI_Transmit_DMA+0x108>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8008580:	403e      	ands	r6, r7
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 8008582:	6303      	str	r3, [r0, #48]	; 0x30
  hspi->hdmatx->XferAbortCallback = NULL;
 8008584:	2300      	movs	r3, #0
 8008586:	6343      	str	r3, [r0, #52]	; 0x34
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 8008588:	23e0      	movs	r3, #224	; 0xe0
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 800858a:	6056      	str	r6, [r2, #4]
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 800858c:	68e6      	ldr	r6, [r4, #12]
 800858e:	00db      	lsls	r3, r3, #3
 8008590:	429e      	cmp	r6, r3
 8008592:	d80d      	bhi.n	80085b0 <HAL_SPI_Transmit_DMA+0xb4>
 8008594:	2380      	movs	r3, #128	; 0x80
 8008596:	6946      	ldr	r6, [r0, #20]
 8008598:	00db      	lsls	r3, r3, #3
 800859a:	429e      	cmp	r6, r3
 800859c:	d108      	bne.n	80085b0 <HAL_SPI_Transmit_DMA+0xb4>
    if ((hspi->TxXferCount & 0x1U) == 0U)
 800859e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80085a0:	07db      	lsls	r3, r3, #31
 80085a2:	d41e      	bmi.n	80085e2 <HAL_SPI_Transmit_DMA+0xe6>
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80085a4:	6853      	ldr	r3, [r2, #4]
 80085a6:	403b      	ands	r3, r7
 80085a8:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U);
 80085aa:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80085ac:	085b      	lsrs	r3, r3, #1
      hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 80085ae:	87e3      	strh	r3, [r4, #62]	; 0x3e
  HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
 80085b0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80085b2:	320c      	adds	r2, #12
 80085b4:	b29b      	uxth	r3, r3
 80085b6:	f7ff f99d 	bl	80078f4 <HAL_DMA_Start_IT>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80085ba:	2240      	movs	r2, #64	; 0x40
 80085bc:	6823      	ldr	r3, [r4, #0]
 80085be:	6819      	ldr	r1, [r3, #0]
 80085c0:	4211      	tst	r1, r2
 80085c2:	d102      	bne.n	80085ca <HAL_SPI_Transmit_DMA+0xce>
    __HAL_SPI_ENABLE(hspi);
 80085c4:	6819      	ldr	r1, [r3, #0]
 80085c6:	430a      	orrs	r2, r1
 80085c8:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 80085ca:	2220      	movs	r2, #32
 80085cc:	6859      	ldr	r1, [r3, #4]
  HAL_StatusTypeDef errorcode = HAL_OK;
 80085ce:	2000      	movs	r0, #0
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 80085d0:	430a      	orrs	r2, r1
 80085d2:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 80085d4:	2202      	movs	r2, #2
 80085d6:	6859      	ldr	r1, [r3, #4]
 80085d8:	430a      	orrs	r2, r1
 80085da:	605a      	str	r2, [r3, #4]
  __HAL_UNLOCK(hspi);
 80085dc:	2300      	movs	r3, #0
 80085de:	702b      	strb	r3, [r5, #0]
}
 80085e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80085e2:	2380      	movs	r3, #128	; 0x80
 80085e4:	6856      	ldr	r6, [r2, #4]
 80085e6:	01db      	lsls	r3, r3, #7
 80085e8:	4333      	orrs	r3, r6
 80085ea:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 80085ec:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80085ee:	085b      	lsrs	r3, r3, #1
 80085f0:	3301      	adds	r3, #1
 80085f2:	e7dc      	b.n	80085ae <HAL_SPI_Transmit_DMA+0xb2>
 80085f4:	ffffdfff 	.word	0xffffdfff
 80085f8:	08008955 	.word	0x08008955
 80085fc:	0800899d 	.word	0x0800899d
 8008600:	ffffbfff 	.word	0xffffbfff
 8008604:	08008979 	.word	0x08008979

08008608 <HAL_SPI_TransmitReceive_DMA>:
{
 8008608:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __HAL_LOCK(hspi);
 800860a:	0006      	movs	r6, r0
 800860c:	365c      	adds	r6, #92	; 0x5c
 800860e:	9601      	str	r6, [sp, #4]
 8008610:	7835      	ldrb	r5, [r6, #0]
{
 8008612:	0004      	movs	r4, r0
  __HAL_LOCK(hspi);
 8008614:	2002      	movs	r0, #2
 8008616:	2d01      	cmp	r5, #1
 8008618:	d07d      	beq.n	8008716 <HAL_SPI_TransmitReceive_DMA+0x10e>
 800861a:	0035      	movs	r5, r6
 800861c:	3801      	subs	r0, #1
 800861e:	7030      	strb	r0, [r6, #0]
  tmp  = hspi->State;
 8008620:	3501      	adds	r5, #1
 8008622:	782f      	ldrb	r7, [r5, #0]
 8008624:	b2ff      	uxtb	r7, r7
  if (!((tmp == HAL_SPI_STATE_READY) ||
 8008626:	4287      	cmp	r7, r0
 8008628:	d00c      	beq.n	8008644 <HAL_SPI_TransmitReceive_DMA+0x3c>
 800862a:	3004      	adds	r0, #4
 800862c:	30ff      	adds	r0, #255	; 0xff
 800862e:	4684      	mov	ip, r0
 8008630:	6866      	ldr	r6, [r4, #4]
    errorcode = HAL_BUSY;
 8008632:	3803      	subs	r0, #3
 8008634:	38ff      	subs	r0, #255	; 0xff
  if (!((tmp == HAL_SPI_STATE_READY) ||
 8008636:	4566      	cmp	r6, ip
 8008638:	d16a      	bne.n	8008710 <HAL_SPI_TransmitReceive_DMA+0x108>
        ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
 800863a:	68a6      	ldr	r6, [r4, #8]
 800863c:	2e00      	cmp	r6, #0
 800863e:	d167      	bne.n	8008710 <HAL_SPI_TransmitReceive_DMA+0x108>
 8008640:	2f04      	cmp	r7, #4
 8008642:	d165      	bne.n	8008710 <HAL_SPI_TransmitReceive_DMA+0x108>
    errorcode = HAL_ERROR;
 8008644:	2001      	movs	r0, #1
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 8008646:	2900      	cmp	r1, #0
 8008648:	d062      	beq.n	8008710 <HAL_SPI_TransmitReceive_DMA+0x108>
 800864a:	2a00      	cmp	r2, #0
 800864c:	d060      	beq.n	8008710 <HAL_SPI_TransmitReceive_DMA+0x108>
 800864e:	2b00      	cmp	r3, #0
 8008650:	d05e      	beq.n	8008710 <HAL_SPI_TransmitReceive_DMA+0x108>
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8008652:	7828      	ldrb	r0, [r5, #0]
 8008654:	2804      	cmp	r0, #4
 8008656:	d001      	beq.n	800865c <HAL_SPI_TransmitReceive_DMA+0x54>
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8008658:	2005      	movs	r0, #5
 800865a:	7028      	strb	r0, [r5, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800865c:	2000      	movs	r0, #0
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800865e:	2780      	movs	r7, #128	; 0x80
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8008660:	6422      	str	r2, [r4, #64]	; 0x40
  hspi->RxXferSize  = Size;
 8008662:	1da2      	adds	r2, r4, #6
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8008664:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8008666:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->TxXferSize  = Size;
 8008668:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
 800866a:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->RxXferCount = Size;
 800866c:	3202      	adds	r2, #2
  hspi->RxXferSize  = Size;
 800866e:	8793      	strh	r3, [r2, #60]	; 0x3c
  hspi->RxXferCount = Size;
 8008670:	87d3      	strh	r3, [r2, #62]	; 0x3e
  hspi->RxISR       = NULL;
 8008672:	64e0      	str	r0, [r4, #76]	; 0x4c
  hspi->TxISR       = NULL;
 8008674:	6520      	str	r0, [r4, #80]	; 0x50
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008676:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8008678:	6821      	ldr	r1, [r4, #0]
 800867a:	01bf      	lsls	r7, r7, #6
 800867c:	42b8      	cmp	r0, r7
 800867e:	d106      	bne.n	800868e <HAL_SPI_TransmitReceive_DMA+0x86>
    SPI_RESET_CRC(hspi);
 8008680:	680f      	ldr	r7, [r1, #0]
 8008682:	4e45      	ldr	r6, [pc, #276]	; (8008798 <HAL_SPI_TransmitReceive_DMA+0x190>)
 8008684:	4037      	ands	r7, r6
 8008686:	600f      	str	r7, [r1, #0]
 8008688:	680f      	ldr	r7, [r1, #0]
 800868a:	4338      	orrs	r0, r7
 800868c:	6008      	str	r0, [r1, #0]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
 800868e:	6848      	ldr	r0, [r1, #4]
 8008690:	4f42      	ldr	r7, [pc, #264]	; (800879c <HAL_SPI_TransmitReceive_DMA+0x194>)
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008692:	68e6      	ldr	r6, [r4, #12]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
 8008694:	4038      	ands	r0, r7
 8008696:	6048      	str	r0, [r1, #4]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008698:	20e0      	movs	r0, #224	; 0xe0
 800869a:	00c0      	lsls	r0, r0, #3
 800869c:	4286      	cmp	r6, r0
 800869e:	d93b      	bls.n	8008718 <HAL_SPI_TransmitReceive_DMA+0x110>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80086a0:	684b      	ldr	r3, [r1, #4]
 80086a2:	483f      	ldr	r0, [pc, #252]	; (80087a0 <HAL_SPI_TransmitReceive_DMA+0x198>)
 80086a4:	4003      	ands	r3, r0
 80086a6:	604b      	str	r3, [r1, #4]
  if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 80086a8:	782b      	ldrb	r3, [r5, #0]
 80086aa:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80086ac:	2b04      	cmp	r3, #4
 80086ae:	d000      	beq.n	80086b2 <HAL_SPI_TransmitReceive_DMA+0xaa>
 80086b0:	e06d      	b.n	800878e <HAL_SPI_TransmitReceive_DMA+0x186>
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 80086b2:	4b3c      	ldr	r3, [pc, #240]	; (80087a4 <HAL_SPI_TransmitReceive_DMA+0x19c>)
 80086b4:	62c3      	str	r3, [r0, #44]	; 0x2c
    hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
 80086b6:	4b3c      	ldr	r3, [pc, #240]	; (80087a8 <HAL_SPI_TransmitReceive_DMA+0x1a0>)
  hspi->hdmarx->XferAbortCallback = NULL;
 80086b8:	2500      	movs	r5, #0
    hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
 80086ba:	6283      	str	r3, [r0, #40]	; 0x28
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 80086bc:	4b3b      	ldr	r3, [pc, #236]	; (80087ac <HAL_SPI_TransmitReceive_DMA+0x1a4>)
  hspi->hdmarx->XferAbortCallback = NULL;
 80086be:	6345      	str	r5, [r0, #52]	; 0x34
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 80086c0:	6303      	str	r3, [r0, #48]	; 0x30
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 80086c2:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 80086c4:	310c      	adds	r1, #12
 80086c6:	b29b      	uxth	r3, r3
 80086c8:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80086ca:	f7ff f913 	bl	80078f4 <HAL_DMA_Start_IT>
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 80086ce:	2301      	movs	r3, #1
 80086d0:	6822      	ldr	r2, [r4, #0]
  hspi->hdmatx->XferHalfCpltCallback = NULL;
 80086d2:	6d60      	ldr	r0, [r4, #84]	; 0x54
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 80086d4:	6851      	ldr	r1, [r2, #4]
 80086d6:	430b      	orrs	r3, r1
 80086d8:	6053      	str	r3, [r2, #4]
  hspi->hdmatx->XferHalfCpltCallback = NULL;
 80086da:	62c5      	str	r5, [r0, #44]	; 0x2c
  hspi->hdmatx->XferCpltCallback     = NULL;
 80086dc:	6285      	str	r5, [r0, #40]	; 0x28
  hspi->hdmatx->XferErrorCallback    = NULL;
 80086de:	6305      	str	r5, [r0, #48]	; 0x30
  hspi->hdmatx->XferAbortCallback    = NULL;
 80086e0:	6345      	str	r5, [r0, #52]	; 0x34
  HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
 80086e2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80086e4:	320c      	adds	r2, #12
 80086e6:	b29b      	uxth	r3, r3
 80086e8:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80086ea:	f7ff f903 	bl	80078f4 <HAL_DMA_Start_IT>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80086ee:	2240      	movs	r2, #64	; 0x40
 80086f0:	6823      	ldr	r3, [r4, #0]
 80086f2:	6819      	ldr	r1, [r3, #0]
 80086f4:	4211      	tst	r1, r2
 80086f6:	d102      	bne.n	80086fe <HAL_SPI_TransmitReceive_DMA+0xf6>
    __HAL_SPI_ENABLE(hspi);
 80086f8:	6819      	ldr	r1, [r3, #0]
 80086fa:	430a      	orrs	r2, r1
 80086fc:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 80086fe:	2220      	movs	r2, #32
 8008700:	6859      	ldr	r1, [r3, #4]
  HAL_StatusTypeDef errorcode = HAL_OK;
 8008702:	2000      	movs	r0, #0
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 8008704:	430a      	orrs	r2, r1
 8008706:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8008708:	2202      	movs	r2, #2
 800870a:	6859      	ldr	r1, [r3, #4]
 800870c:	430a      	orrs	r2, r1
 800870e:	605a      	str	r2, [r3, #4]
  __HAL_UNLOCK(hspi);
 8008710:	2300      	movs	r3, #0
 8008712:	9a01      	ldr	r2, [sp, #4]
 8008714:	7013      	strb	r3, [r2, #0]
}
 8008716:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8008718:	2080      	movs	r0, #128	; 0x80
 800871a:	684f      	ldr	r7, [r1, #4]
 800871c:	0140      	lsls	r0, r0, #5
 800871e:	4338      	orrs	r0, r7
 8008720:	6048      	str	r0, [r1, #4]
    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8008722:	2080      	movs	r0, #128	; 0x80
 8008724:	6d67      	ldr	r7, [r4, #84]	; 0x54
 8008726:	00c0      	lsls	r0, r0, #3
 8008728:	697f      	ldr	r7, [r7, #20]
 800872a:	4287      	cmp	r7, r0
 800872c:	d108      	bne.n	8008740 <HAL_SPI_TransmitReceive_DMA+0x138>
      if ((hspi->TxXferSize & 0x1U) == 0x0U)
 800872e:	07db      	lsls	r3, r3, #31
 8008730:	d41b      	bmi.n	800876a <HAL_SPI_TransmitReceive_DMA+0x162>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8008732:	684b      	ldr	r3, [r1, #4]
 8008734:	481e      	ldr	r0, [pc, #120]	; (80087b0 <HAL_SPI_TransmitReceive_DMA+0x1a8>)
 8008736:	4003      	ands	r3, r0
 8008738:	604b      	str	r3, [r1, #4]
        hspi->TxXferCount = hspi->TxXferCount >> 1U;
 800873a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800873c:	085b      	lsrs	r3, r3, #1
        hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 800873e:	87e3      	strh	r3, [r4, #62]	; 0x3e
    if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8008740:	2380      	movs	r3, #128	; 0x80
 8008742:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8008744:	00db      	lsls	r3, r3, #3
 8008746:	6940      	ldr	r0, [r0, #20]
 8008748:	4298      	cmp	r0, r3
 800874a:	d1ad      	bne.n	80086a8 <HAL_SPI_TransmitReceive_DMA+0xa0>
      CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800874c:	684b      	ldr	r3, [r1, #4]
 800874e:	4814      	ldr	r0, [pc, #80]	; (80087a0 <HAL_SPI_TransmitReceive_DMA+0x198>)
 8008750:	4003      	ands	r3, r0
 8008752:	604b      	str	r3, [r1, #4]
      if ((hspi->RxXferCount & 0x1U) == 0x0U)
 8008754:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 8008756:	07db      	lsls	r3, r3, #31
 8008758:	d410      	bmi.n	800877c <HAL_SPI_TransmitReceive_DMA+0x174>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 800875a:	684b      	ldr	r3, [r1, #4]
 800875c:	480e      	ldr	r0, [pc, #56]	; (8008798 <HAL_SPI_TransmitReceive_DMA+0x190>)
 800875e:	4003      	ands	r3, r0
 8008760:	604b      	str	r3, [r1, #4]
        hspi->RxXferCount = hspi->RxXferCount >> 1U;
 8008762:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 8008764:	085b      	lsrs	r3, r3, #1
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 8008766:	87d3      	strh	r3, [r2, #62]	; 0x3e
 8008768:	e79e      	b.n	80086a8 <HAL_SPI_TransmitReceive_DMA+0xa0>
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 800876a:	2380      	movs	r3, #128	; 0x80
 800876c:	6848      	ldr	r0, [r1, #4]
 800876e:	01db      	lsls	r3, r3, #7
 8008770:	4303      	orrs	r3, r0
 8008772:	604b      	str	r3, [r1, #4]
        hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 8008774:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8008776:	085b      	lsrs	r3, r3, #1
 8008778:	3301      	adds	r3, #1
 800877a:	e7e0      	b.n	800873e <HAL_SPI_TransmitReceive_DMA+0x136>
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 800877c:	2380      	movs	r3, #128	; 0x80
 800877e:	6848      	ldr	r0, [r1, #4]
 8008780:	019b      	lsls	r3, r3, #6
 8008782:	4303      	orrs	r3, r0
 8008784:	604b      	str	r3, [r1, #4]
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 8008786:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 8008788:	085b      	lsrs	r3, r3, #1
 800878a:	3301      	adds	r3, #1
 800878c:	e7eb      	b.n	8008766 <HAL_SPI_TransmitReceive_DMA+0x15e>
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
 800878e:	4b09      	ldr	r3, [pc, #36]	; (80087b4 <HAL_SPI_TransmitReceive_DMA+0x1ac>)
 8008790:	62c3      	str	r3, [r0, #44]	; 0x2c
    hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
 8008792:	4b09      	ldr	r3, [pc, #36]	; (80087b8 <HAL_SPI_TransmitReceive_DMA+0x1b0>)
 8008794:	e790      	b.n	80086b8 <HAL_SPI_TransmitReceive_DMA+0xb0>
 8008796:	46c0      	nop			; (mov r8, r8)
 8008798:	ffffdfff 	.word	0xffffdfff
 800879c:	ffff9fff 	.word	0xffff9fff
 80087a0:	ffffefff 	.word	0xffffefff
 80087a4:	08008961 	.word	0x08008961
 80087a8:	08008a0d 	.word	0x08008a0d
 80087ac:	08008979 	.word	0x08008979
 80087b0:	ffffbfff 	.word	0xffffbfff
 80087b4:	0800896d 	.word	0x0800896d
 80087b8:	08008af1 	.word	0x08008af1

080087bc <HAL_SPI_Receive_DMA>:
  if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 80087bc:	6883      	ldr	r3, [r0, #8]
{
 80087be:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80087c0:	0005      	movs	r5, r0
  if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 80087c2:	2b00      	cmp	r3, #0
 80087c4:	d10f      	bne.n	80087e6 <HAL_SPI_Receive_DMA+0x2a>
 80087c6:	2082      	movs	r0, #130	; 0x82
 80087c8:	686c      	ldr	r4, [r5, #4]
 80087ca:	0040      	lsls	r0, r0, #1
 80087cc:	4284      	cmp	r4, r0
 80087ce:	d10a      	bne.n	80087e6 <HAL_SPI_Receive_DMA+0x2a>
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 80087d0:	002b      	movs	r3, r5
 80087d2:	3801      	subs	r0, #1
 80087d4:	335d      	adds	r3, #93	; 0x5d
 80087d6:	38ff      	subs	r0, #255	; 0xff
 80087d8:	7018      	strb	r0, [r3, #0]
    return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
 80087da:	0013      	movs	r3, r2
 80087dc:	0028      	movs	r0, r5
 80087de:	000a      	movs	r2, r1
 80087e0:	f7ff ff12 	bl	8008608 <HAL_SPI_TransmitReceive_DMA>
}
 80087e4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(hspi);
 80087e6:	002e      	movs	r6, r5
 80087e8:	365c      	adds	r6, #92	; 0x5c
 80087ea:	7834      	ldrb	r4, [r6, #0]
 80087ec:	2002      	movs	r0, #2
 80087ee:	2c01      	cmp	r4, #1
 80087f0:	d0f8      	beq.n	80087e4 <HAL_SPI_Receive_DMA+0x28>
  if (hspi->State != HAL_SPI_STATE_READY)
 80087f2:	002f      	movs	r7, r5
  __HAL_LOCK(hspi);
 80087f4:	3801      	subs	r0, #1
 80087f6:	7030      	strb	r0, [r6, #0]
  if (hspi->State != HAL_SPI_STATE_READY)
 80087f8:	375d      	adds	r7, #93	; 0x5d
 80087fa:	783c      	ldrb	r4, [r7, #0]
    errorcode = HAL_BUSY;
 80087fc:	3001      	adds	r0, #1
  if (hspi->State != HAL_SPI_STATE_READY)
 80087fe:	b2e4      	uxtb	r4, r4
 8008800:	2c01      	cmp	r4, #1
 8008802:	d156      	bne.n	80088b2 <HAL_SPI_Receive_DMA+0xf6>
    errorcode = HAL_ERROR;
 8008804:	0020      	movs	r0, r4
  if ((pData == NULL) || (Size == 0U))
 8008806:	2900      	cmp	r1, #0
 8008808:	d053      	beq.n	80088b2 <HAL_SPI_Receive_DMA+0xf6>
 800880a:	2a00      	cmp	r2, #0
 800880c:	d051      	beq.n	80088b2 <HAL_SPI_Receive_DMA+0xf6>
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 800880e:	3003      	adds	r0, #3
 8008810:	7038      	strb	r0, [r7, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8008812:	2000      	movs	r0, #0
  hspi->RxXferCount = Size;
 8008814:	3f55      	subs	r7, #85	; 0x55
  hspi->RxXferSize  = Size;
 8008816:	1dac      	adds	r4, r5, #6
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8008818:	6628      	str	r0, [r5, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 800881a:	6429      	str	r1, [r5, #64]	; 0x40
  hspi->RxXferSize  = Size;
 800881c:	87e2      	strh	r2, [r4, #62]	; 0x3e
  hspi->RxXferCount = Size;
 800881e:	87fa      	strh	r2, [r7, #62]	; 0x3e
  hspi->RxISR       = NULL;
 8008820:	64e8      	str	r0, [r5, #76]	; 0x4c
  hspi->TxISR       = NULL;
 8008822:	6528      	str	r0, [r5, #80]	; 0x50
  hspi->TxXferSize  = 0U;
 8008824:	87a8      	strh	r0, [r5, #60]	; 0x3c
  hspi->TxXferCount = 0U;
 8008826:	87e8      	strh	r0, [r5, #62]	; 0x3e
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8008828:	2080      	movs	r0, #128	; 0x80
  hspi->RxXferCount = Size;
 800882a:	9701      	str	r7, [sp, #4]
 800882c:	682a      	ldr	r2, [r5, #0]
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800882e:	0200      	lsls	r0, r0, #8
 8008830:	4283      	cmp	r3, r0
 8008832:	d103      	bne.n	800883c <HAL_SPI_Receive_DMA+0x80>
    SPI_1LINE_RX(hspi);
 8008834:	6813      	ldr	r3, [r2, #0]
 8008836:	4834      	ldr	r0, [pc, #208]	; (8008908 <HAL_SPI_Receive_DMA+0x14c>)
 8008838:	4003      	ands	r3, r0
 800883a:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800883c:	2080      	movs	r0, #128	; 0x80
 800883e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8008840:	0180      	lsls	r0, r0, #6
 8008842:	4c32      	ldr	r4, [pc, #200]	; (800890c <HAL_SPI_Receive_DMA+0x150>)
 8008844:	4283      	cmp	r3, r0
 8008846:	d105      	bne.n	8008854 <HAL_SPI_Receive_DMA+0x98>
    SPI_RESET_CRC(hspi);
 8008848:	6810      	ldr	r0, [r2, #0]
 800884a:	4020      	ands	r0, r4
 800884c:	6010      	str	r0, [r2, #0]
 800884e:	6810      	ldr	r0, [r2, #0]
 8008850:	4303      	orrs	r3, r0
 8008852:	6013      	str	r3, [r2, #0]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 8008854:	6853      	ldr	r3, [r2, #4]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008856:	68ef      	ldr	r7, [r5, #12]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 8008858:	4023      	ands	r3, r4
 800885a:	6053      	str	r3, [r2, #4]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800885c:	23e0      	movs	r3, #224	; 0xe0
 800885e:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8008860:	00db      	lsls	r3, r3, #3
 8008862:	429f      	cmp	r7, r3
 8008864:	d928      	bls.n	80088b8 <HAL_SPI_Receive_DMA+0xfc>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8008866:	6853      	ldr	r3, [r2, #4]
 8008868:	4c29      	ldr	r4, [pc, #164]	; (8008910 <HAL_SPI_Receive_DMA+0x154>)
 800886a:	4023      	ands	r3, r4
 800886c:	6053      	str	r3, [r2, #4]
  hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 800886e:	4b29      	ldr	r3, [pc, #164]	; (8008914 <HAL_SPI_Receive_DMA+0x158>)
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 8008870:	320c      	adds	r2, #12
  hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 8008872:	62c3      	str	r3, [r0, #44]	; 0x2c
  hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
 8008874:	4b28      	ldr	r3, [pc, #160]	; (8008918 <HAL_SPI_Receive_DMA+0x15c>)
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 8008876:	0014      	movs	r4, r2
  hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
 8008878:	6283      	str	r3, [r0, #40]	; 0x28
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 800887a:	4b28      	ldr	r3, [pc, #160]	; (800891c <HAL_SPI_Receive_DMA+0x160>)
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 800887c:	000a      	movs	r2, r1
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 800887e:	6303      	str	r3, [r0, #48]	; 0x30
  hspi->hdmarx->XferAbortCallback = NULL;
 8008880:	2300      	movs	r3, #0
 8008882:	6343      	str	r3, [r0, #52]	; 0x34
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 8008884:	9b01      	ldr	r3, [sp, #4]
 8008886:	0021      	movs	r1, r4
 8008888:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800888a:	b29b      	uxth	r3, r3
 800888c:	f7ff f832 	bl	80078f4 <HAL_DMA_Start_IT>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8008890:	2240      	movs	r2, #64	; 0x40
 8008892:	682b      	ldr	r3, [r5, #0]
 8008894:	6819      	ldr	r1, [r3, #0]
 8008896:	4211      	tst	r1, r2
 8008898:	d102      	bne.n	80088a0 <HAL_SPI_Receive_DMA+0xe4>
    __HAL_SPI_ENABLE(hspi);
 800889a:	6819      	ldr	r1, [r3, #0]
 800889c:	430a      	orrs	r2, r1
 800889e:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 80088a0:	2220      	movs	r2, #32
 80088a2:	6859      	ldr	r1, [r3, #4]
  HAL_StatusTypeDef errorcode = HAL_OK;
 80088a4:	2000      	movs	r0, #0
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 80088a6:	430a      	orrs	r2, r1
 80088a8:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 80088aa:	2201      	movs	r2, #1
 80088ac:	6859      	ldr	r1, [r3, #4]
 80088ae:	430a      	orrs	r2, r1
 80088b0:	605a      	str	r2, [r3, #4]
  __HAL_UNLOCK(hspi);
 80088b2:	2300      	movs	r3, #0
 80088b4:	7033      	strb	r3, [r6, #0]
  return errorcode;
 80088b6:	e795      	b.n	80087e4 <HAL_SPI_Receive_DMA+0x28>
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80088b8:	6853      	ldr	r3, [r2, #4]
 80088ba:	469c      	mov	ip, r3
 80088bc:	2380      	movs	r3, #128	; 0x80
 80088be:	4667      	mov	r7, ip
 80088c0:	015b      	lsls	r3, r3, #5
 80088c2:	433b      	orrs	r3, r7
 80088c4:	6053      	str	r3, [r2, #4]
    if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 80088c6:	2380      	movs	r3, #128	; 0x80
 80088c8:	6947      	ldr	r7, [r0, #20]
 80088ca:	00db      	lsls	r3, r3, #3
 80088cc:	429f      	cmp	r7, r3
 80088ce:	d1ce      	bne.n	800886e <HAL_SPI_Receive_DMA+0xb2>
      CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80088d0:	6853      	ldr	r3, [r2, #4]
 80088d2:	4f0f      	ldr	r7, [pc, #60]	; (8008910 <HAL_SPI_Receive_DMA+0x154>)
 80088d4:	403b      	ands	r3, r7
 80088d6:	6053      	str	r3, [r2, #4]
      if ((hspi->RxXferCount & 0x1U) == 0x0U)
 80088d8:	002b      	movs	r3, r5
 80088da:	3308      	adds	r3, #8
 80088dc:	8fdf      	ldrh	r7, [r3, #62]	; 0x3e
 80088de:	07ff      	lsls	r7, r7, #31
 80088e0:	d406      	bmi.n	80088f0 <HAL_SPI_Receive_DMA+0x134>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 80088e2:	6857      	ldr	r7, [r2, #4]
 80088e4:	403c      	ands	r4, r7
 80088e6:	6054      	str	r4, [r2, #4]
        hspi->RxXferCount = hspi->RxXferCount >> 1U;
 80088e8:	8fdc      	ldrh	r4, [r3, #62]	; 0x3e
 80088ea:	0864      	lsrs	r4, r4, #1
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 80088ec:	87dc      	strh	r4, [r3, #62]	; 0x3e
 80088ee:	e7be      	b.n	800886e <HAL_SPI_Receive_DMA+0xb2>
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 80088f0:	6854      	ldr	r4, [r2, #4]
 80088f2:	46a4      	mov	ip, r4
 80088f4:	2480      	movs	r4, #128	; 0x80
 80088f6:	4667      	mov	r7, ip
 80088f8:	01a4      	lsls	r4, r4, #6
 80088fa:	433c      	orrs	r4, r7
 80088fc:	6054      	str	r4, [r2, #4]
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 80088fe:	8fdc      	ldrh	r4, [r3, #62]	; 0x3e
 8008900:	0864      	lsrs	r4, r4, #1
 8008902:	3401      	adds	r4, #1
 8008904:	e7f2      	b.n	80088ec <HAL_SPI_Receive_DMA+0x130>
 8008906:	46c0      	nop			; (mov r8, r8)
 8008908:	ffffbfff 	.word	0xffffbfff
 800890c:	ffffdfff 	.word	0xffffdfff
 8008910:	ffffefff 	.word	0xffffefff
 8008914:	08008961 	.word	0x08008961
 8008918:	08008a0d 	.word	0x08008a0d
 800891c:	08008979 	.word	0x08008979

08008920 <HAL_SPI_DMAStop>:
{
 8008920:	b510      	push	{r4, lr}
 8008922:	0004      	movs	r4, r0
  if (hspi->hdmatx != NULL)
 8008924:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8008926:	2800      	cmp	r0, #0
 8008928:	d001      	beq.n	800892e <HAL_SPI_DMAStop+0xe>
    HAL_DMA_Abort(hspi->hdmatx);
 800892a:	f7ff f81f 	bl	800796c <HAL_DMA_Abort>
  if (hspi->hdmarx != NULL)
 800892e:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8008930:	2800      	cmp	r0, #0
 8008932:	d001      	beq.n	8008938 <HAL_SPI_DMAStop+0x18>
    HAL_DMA_Abort(hspi->hdmarx);
 8008934:	f7ff f81a 	bl	800796c <HAL_DMA_Abort>
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008938:	2103      	movs	r1, #3
 800893a:	6822      	ldr	r2, [r4, #0]
  hspi->State = HAL_SPI_STATE_READY;
 800893c:	345d      	adds	r4, #93	; 0x5d
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800893e:	6853      	ldr	r3, [r2, #4]
}
 8008940:	2000      	movs	r0, #0
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008942:	438b      	bics	r3, r1
 8008944:	6053      	str	r3, [r2, #4]
  hspi->State = HAL_SPI_STATE_READY;
 8008946:	2301      	movs	r3, #1
 8008948:	7023      	strb	r3, [r4, #0]
}
 800894a:	bd10      	pop	{r4, pc}

0800894c <HAL_SPI_TxCpltCallback>:
 800894c:	4770      	bx	lr

0800894e <HAL_SPI_RxCpltCallback>:
 800894e:	4770      	bx	lr

08008950 <HAL_SPI_TxRxCpltCallback>:
 8008950:	4770      	bx	lr

08008952 <HAL_SPI_TxHalfCpltCallback>:
 8008952:	4770      	bx	lr

08008954 <SPI_DMAHalfTransmitCplt>:
{
 8008954:	b510      	push	{r4, lr}
  HAL_SPI_TxHalfCpltCallback(hspi);
 8008956:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8008958:	f7ff fffb 	bl	8008952 <HAL_SPI_TxHalfCpltCallback>
}
 800895c:	bd10      	pop	{r4, pc}

0800895e <HAL_SPI_RxHalfCpltCallback>:
 800895e:	4770      	bx	lr

08008960 <SPI_DMAHalfReceiveCplt>:
{
 8008960:	b510      	push	{r4, lr}
  HAL_SPI_RxHalfCpltCallback(hspi);
 8008962:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8008964:	f7ff fffb 	bl	800895e <HAL_SPI_RxHalfCpltCallback>
}
 8008968:	bd10      	pop	{r4, pc}

0800896a <HAL_SPI_TxRxHalfCpltCallback>:
 800896a:	4770      	bx	lr

0800896c <SPI_DMAHalfTransmitReceiveCplt>:
{
 800896c:	b510      	push	{r4, lr}
  HAL_SPI_TxRxHalfCpltCallback(hspi);
 800896e:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8008970:	f7ff fffb 	bl	800896a <HAL_SPI_TxRxHalfCpltCallback>
}
 8008974:	bd10      	pop	{r4, pc}

08008976 <HAL_SPI_ErrorCallback>:
 8008976:	4770      	bx	lr

08008978 <SPI_DMAError>:
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008978:	2103      	movs	r1, #3
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800897a:	6a40      	ldr	r0, [r0, #36]	; 0x24
{
 800897c:	b510      	push	{r4, lr}
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800897e:	6802      	ldr	r2, [r0, #0]
 8008980:	6853      	ldr	r3, [r2, #4]
 8008982:	438b      	bics	r3, r1
 8008984:	6053      	str	r3, [r2, #4]
  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 8008986:	2310      	movs	r3, #16
 8008988:	6e02      	ldr	r2, [r0, #96]	; 0x60
 800898a:	4313      	orrs	r3, r2
 800898c:	6603      	str	r3, [r0, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_READY;
 800898e:	0003      	movs	r3, r0
 8008990:	2201      	movs	r2, #1
 8008992:	335d      	adds	r3, #93	; 0x5d
 8008994:	701a      	strb	r2, [r3, #0]
  HAL_SPI_ErrorCallback(hspi);
 8008996:	f7ff ffee 	bl	8008976 <HAL_SPI_ErrorCallback>
}
 800899a:	bd10      	pop	{r4, pc}

0800899c <SPI_DMATransmitCplt>:
{
 800899c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800899e:	0005      	movs	r5, r0
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80089a0:	6a44      	ldr	r4, [r0, #36]	; 0x24
  tickstart = HAL_GetTick();
 80089a2:	f7fe fbad 	bl	8007100 <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 80089a6:	682b      	ldr	r3, [r5, #0]
 80089a8:	2520      	movs	r5, #32
 80089aa:	681b      	ldr	r3, [r3, #0]
  tickstart = HAL_GetTick();
 80089ac:	0002      	movs	r2, r0
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 80089ae:	422b      	tst	r3, r5
 80089b0:	d127      	bne.n	8008a02 <SPI_DMATransmitCplt+0x66>
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 80089b2:	2002      	movs	r0, #2
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 80089b4:	6823      	ldr	r3, [r4, #0]
 80089b6:	6859      	ldr	r1, [r3, #4]
 80089b8:	43a9      	bics	r1, r5
 80089ba:	6059      	str	r1, [r3, #4]
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 80089bc:	6859      	ldr	r1, [r3, #4]
 80089be:	4381      	bics	r1, r0
 80089c0:	6059      	str	r1, [r3, #4]
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 80089c2:	0020      	movs	r0, r4
 80089c4:	2164      	movs	r1, #100	; 0x64
 80089c6:	f7ff fd06 	bl	80083d6 <SPI_EndRxTxTransaction>
 80089ca:	2800      	cmp	r0, #0
 80089cc:	d002      	beq.n	80089d4 <SPI_DMATransmitCplt+0x38>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80089ce:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80089d0:	431d      	orrs	r5, r3
 80089d2:	6625      	str	r5, [r4, #96]	; 0x60
    if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 80089d4:	68a3      	ldr	r3, [r4, #8]
 80089d6:	2b00      	cmp	r3, #0
 80089d8:	d106      	bne.n	80089e8 <SPI_DMATransmitCplt+0x4c>
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80089da:	9301      	str	r3, [sp, #4]
 80089dc:	6823      	ldr	r3, [r4, #0]
 80089de:	68da      	ldr	r2, [r3, #12]
 80089e0:	9201      	str	r2, [sp, #4]
 80089e2:	689b      	ldr	r3, [r3, #8]
 80089e4:	9301      	str	r3, [sp, #4]
 80089e6:	9b01      	ldr	r3, [sp, #4]
    hspi->TxXferCount = 0U;
 80089e8:	2300      	movs	r3, #0
 80089ea:	87e3      	strh	r3, [r4, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 80089ec:	0023      	movs	r3, r4
 80089ee:	2201      	movs	r2, #1
 80089f0:	335d      	adds	r3, #93	; 0x5d
 80089f2:	701a      	strb	r2, [r3, #0]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80089f4:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80089f6:	2b00      	cmp	r3, #0
 80089f8:	d003      	beq.n	8008a02 <SPI_DMATransmitCplt+0x66>
      HAL_SPI_ErrorCallback(hspi);
 80089fa:	0020      	movs	r0, r4
 80089fc:	f7ff ffbb 	bl	8008976 <HAL_SPI_ErrorCallback>
}
 8008a00:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
  HAL_SPI_TxCpltCallback(hspi);
 8008a02:	0020      	movs	r0, r4
 8008a04:	f7ff ffa2 	bl	800894c <HAL_SPI_TxCpltCallback>
 8008a08:	e7fa      	b.n	8008a00 <SPI_DMATransmitCplt+0x64>
	...

08008a0c <SPI_DMAReceiveCplt>:
{
 8008a0c:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO uint16_t tmpreg = 0U;
 8008a0e:	250e      	movs	r5, #14
 8008a10:	2300      	movs	r3, #0
{
 8008a12:	0006      	movs	r6, r0
 8008a14:	b085      	sub	sp, #20
  __IO uint16_t tmpreg = 0U;
 8008a16:	446d      	add	r5, sp
 8008a18:	802b      	strh	r3, [r5, #0]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008a1a:	6a44      	ldr	r4, [r0, #36]	; 0x24
  tickstart = HAL_GetTick();
 8008a1c:	f7fe fb70 	bl	8007100 <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8008a20:	2120      	movs	r1, #32
 8008a22:	6833      	ldr	r3, [r6, #0]
  tickstart = HAL_GetTick();
 8008a24:	0007      	movs	r7, r0
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8008a26:	681b      	ldr	r3, [r3, #0]
 8008a28:	420b      	tst	r3, r1
 8008a2a:	d15b      	bne.n	8008ae4 <SPI_DMAReceiveCplt+0xd8>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 8008a2c:	6822      	ldr	r2, [r4, #0]
 8008a2e:	6853      	ldr	r3, [r2, #4]
 8008a30:	438b      	bics	r3, r1
 8008a32:	6053      	str	r3, [r2, #4]
    if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008a34:	2380      	movs	r3, #128	; 0x80
 8008a36:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8008a38:	019b      	lsls	r3, r3, #6
 8008a3a:	429a      	cmp	r2, r3
 8008a3c:	d116      	bne.n	8008a6c <SPI_DMAReceiveCplt+0x60>
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008a3e:	2201      	movs	r2, #1
 8008a40:	9000      	str	r0, [sp, #0]
 8008a42:	2364      	movs	r3, #100	; 0x64
 8008a44:	0011      	movs	r1, r2
 8008a46:	0020      	movs	r0, r4
 8008a48:	f7ff fc40 	bl	80082cc <SPI_WaitFlagStateUntilTimeout>
 8008a4c:	2800      	cmp	r0, #0
 8008a4e:	d003      	beq.n	8008a58 <SPI_DMAReceiveCplt+0x4c>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008a50:	2302      	movs	r3, #2
 8008a52:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8008a54:	4313      	orrs	r3, r2
 8008a56:	6623      	str	r3, [r4, #96]	; 0x60
      if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008a58:	22e0      	movs	r2, #224	; 0xe0
 8008a5a:	68e1      	ldr	r1, [r4, #12]
 8008a5c:	6823      	ldr	r3, [r4, #0]
 8008a5e:	00d2      	lsls	r2, r2, #3
 8008a60:	4291      	cmp	r1, r2
 8008a62:	d92a      	bls.n	8008aba <SPI_DMAReceiveCplt+0xae>
        tmpreg = hspi->Instance->DR;
 8008a64:	68db      	ldr	r3, [r3, #12]
 8008a66:	b29b      	uxth	r3, r3
          tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8008a68:	802b      	strh	r3, [r5, #0]
          UNUSED(tmpreg);
 8008a6a:	882b      	ldrh	r3, [r5, #0]
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008a6c:	2103      	movs	r1, #3
 8008a6e:	6822      	ldr	r2, [r4, #0]
    if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008a70:	0020      	movs	r0, r4
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008a72:	6853      	ldr	r3, [r2, #4]
 8008a74:	438b      	bics	r3, r1
 8008a76:	6053      	str	r3, [r2, #4]
    if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008a78:	3161      	adds	r1, #97	; 0x61
 8008a7a:	003a      	movs	r2, r7
 8008a7c:	f7ff fc6b 	bl	8008356 <SPI_EndRxTransaction>
 8008a80:	2800      	cmp	r0, #0
 8008a82:	d001      	beq.n	8008a88 <SPI_DMAReceiveCplt+0x7c>
      hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8008a84:	2320      	movs	r3, #32
 8008a86:	6623      	str	r3, [r4, #96]	; 0x60
    hspi->RxXferCount = 0U;
 8008a88:	0023      	movs	r3, r4
 8008a8a:	2200      	movs	r2, #0
 8008a8c:	3308      	adds	r3, #8
 8008a8e:	87da      	strh	r2, [r3, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 8008a90:	3201      	adds	r2, #1
 8008a92:	3355      	adds	r3, #85	; 0x55
 8008a94:	701a      	strb	r2, [r3, #0]
    if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 8008a96:	6822      	ldr	r2, [r4, #0]
 8008a98:	6893      	ldr	r3, [r2, #8]
 8008a9a:	06db      	lsls	r3, r3, #27
 8008a9c:	d505      	bpl.n	8008aaa <SPI_DMAReceiveCplt+0x9e>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008a9e:	2302      	movs	r3, #2
 8008aa0:	6e21      	ldr	r1, [r4, #96]	; 0x60
 8008aa2:	430b      	orrs	r3, r1
 8008aa4:	6623      	str	r3, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 8008aa6:	4b11      	ldr	r3, [pc, #68]	; (8008aec <SPI_DMAReceiveCplt+0xe0>)
 8008aa8:	6093      	str	r3, [r2, #8]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8008aaa:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8008aac:	2b00      	cmp	r3, #0
 8008aae:	d019      	beq.n	8008ae4 <SPI_DMAReceiveCplt+0xd8>
      HAL_SPI_ErrorCallback(hspi);
 8008ab0:	0020      	movs	r0, r4
 8008ab2:	f7ff ff60 	bl	8008976 <HAL_SPI_ErrorCallback>
}
 8008ab6:	b005      	add	sp, #20
 8008ab8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8008aba:	7b1b      	ldrb	r3, [r3, #12]
        if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8008abc:	6b26      	ldr	r6, [r4, #48]	; 0x30
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8008abe:	802b      	strh	r3, [r5, #0]
        UNUSED(tmpreg);
 8008ac0:	882b      	ldrh	r3, [r5, #0]
        if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8008ac2:	2e02      	cmp	r6, #2
 8008ac4:	d1d2      	bne.n	8008a6c <SPI_DMAReceiveCplt+0x60>
          if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008ac6:	2201      	movs	r2, #1
 8008ac8:	9700      	str	r7, [sp, #0]
 8008aca:	2364      	movs	r3, #100	; 0x64
 8008acc:	0011      	movs	r1, r2
 8008ace:	0020      	movs	r0, r4
 8008ad0:	f7ff fbfc 	bl	80082cc <SPI_WaitFlagStateUntilTimeout>
 8008ad4:	2800      	cmp	r0, #0
 8008ad6:	d002      	beq.n	8008ade <SPI_DMAReceiveCplt+0xd2>
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008ad8:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8008ada:	431e      	orrs	r6, r3
 8008adc:	6626      	str	r6, [r4, #96]	; 0x60
          tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8008ade:	6823      	ldr	r3, [r4, #0]
 8008ae0:	7b1b      	ldrb	r3, [r3, #12]
 8008ae2:	e7c1      	b.n	8008a68 <SPI_DMAReceiveCplt+0x5c>
  HAL_SPI_RxCpltCallback(hspi);
 8008ae4:	0020      	movs	r0, r4
 8008ae6:	f7ff ff32 	bl	800894e <HAL_SPI_RxCpltCallback>
 8008aea:	e7e4      	b.n	8008ab6 <SPI_DMAReceiveCplt+0xaa>
 8008aec:	0000ffef 	.word	0x0000ffef

08008af0 <SPI_DMATransmitReceiveCplt>:
{
 8008af0:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO int16_t tmpreg = 0U;
 8008af2:	250e      	movs	r5, #14
 8008af4:	2300      	movs	r3, #0
{
 8008af6:	0007      	movs	r7, r0
 8008af8:	b085      	sub	sp, #20
  __IO int16_t tmpreg = 0U;
 8008afa:	446d      	add	r5, sp
 8008afc:	802b      	strh	r3, [r5, #0]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008afe:	6a44      	ldr	r4, [r0, #36]	; 0x24
  tickstart = HAL_GetTick();
 8008b00:	f7fe fafe 	bl	8007100 <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8008b04:	2120      	movs	r1, #32
 8008b06:	683b      	ldr	r3, [r7, #0]
  tickstart = HAL_GetTick();
 8008b08:	0006      	movs	r6, r0
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8008b0a:	681b      	ldr	r3, [r3, #0]
 8008b0c:	420b      	tst	r3, r1
 8008b0e:	d160      	bne.n	8008bd2 <SPI_DMATransmitReceiveCplt+0xe2>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 8008b10:	6822      	ldr	r2, [r4, #0]
 8008b12:	6853      	ldr	r3, [r2, #4]
 8008b14:	438b      	bics	r3, r1
 8008b16:	6053      	str	r3, [r2, #4]
    if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008b18:	2380      	movs	r3, #128	; 0x80
 8008b1a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8008b1c:	019b      	lsls	r3, r3, #6
 8008b1e:	429a      	cmp	r2, r3
 8008b20:	d11a      	bne.n	8008b58 <SPI_DMATransmitReceiveCplt+0x68>
      if ((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_8BIT))
 8008b22:	23e0      	movs	r3, #224	; 0xe0
 8008b24:	68e2      	ldr	r2, [r4, #12]
 8008b26:	00db      	lsls	r3, r3, #3
 8008b28:	429a      	cmp	r2, r3
 8008b2a:	d13f      	bne.n	8008bac <SPI_DMATransmitReceiveCplt+0xbc>
 8008b2c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8008b2e:	2b01      	cmp	r3, #1
 8008b30:	d13c      	bne.n	8008bac <SPI_DMATransmitReceiveCplt+0xbc>
        if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_QUARTER_FULL, SPI_DEFAULT_TIMEOUT,
 8008b32:	2280      	movs	r2, #128	; 0x80
 8008b34:	21c0      	movs	r1, #192	; 0xc0
 8008b36:	9000      	str	r0, [sp, #0]
 8008b38:	3363      	adds	r3, #99	; 0x63
 8008b3a:	0092      	lsls	r2, r2, #2
 8008b3c:	00c9      	lsls	r1, r1, #3
 8008b3e:	0020      	movs	r0, r4
 8008b40:	f7ff fbe2 	bl	8008308 <SPI_WaitFifoStateUntilTimeout>
 8008b44:	2800      	cmp	r0, #0
 8008b46:	d003      	beq.n	8008b50 <SPI_DMATransmitReceiveCplt+0x60>
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008b48:	2302      	movs	r3, #2
 8008b4a:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8008b4c:	4313      	orrs	r3, r2
 8008b4e:	6623      	str	r3, [r4, #96]	; 0x60
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8008b50:	6823      	ldr	r3, [r4, #0]
 8008b52:	7b1b      	ldrb	r3, [r3, #12]
        tmpreg = hspi->Instance->DR;
 8008b54:	802b      	strh	r3, [r5, #0]
        UNUSED(tmpreg);
 8008b56:	882b      	ldrh	r3, [r5, #0]
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008b58:	0032      	movs	r2, r6
 8008b5a:	2164      	movs	r1, #100	; 0x64
 8008b5c:	0020      	movs	r0, r4
 8008b5e:	f7ff fc3a 	bl	80083d6 <SPI_EndRxTxTransaction>
 8008b62:	2800      	cmp	r0, #0
 8008b64:	d003      	beq.n	8008b6e <SPI_DMATransmitReceiveCplt+0x7e>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8008b66:	2320      	movs	r3, #32
 8008b68:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8008b6a:	4313      	orrs	r3, r2
 8008b6c:	6623      	str	r3, [r4, #96]	; 0x60
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008b6e:	2103      	movs	r1, #3
 8008b70:	6823      	ldr	r3, [r4, #0]
 8008b72:	685a      	ldr	r2, [r3, #4]
 8008b74:	438a      	bics	r2, r1
    hspi->RxXferCount = 0U;
 8008b76:	0021      	movs	r1, r4
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008b78:	605a      	str	r2, [r3, #4]
    hspi->TxXferCount = 0U;
 8008b7a:	2200      	movs	r2, #0
    hspi->RxXferCount = 0U;
 8008b7c:	3108      	adds	r1, #8
    hspi->TxXferCount = 0U;
 8008b7e:	87e2      	strh	r2, [r4, #62]	; 0x3e
    hspi->RxXferCount = 0U;
 8008b80:	87ca      	strh	r2, [r1, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 8008b82:	0022      	movs	r2, r4
 8008b84:	2101      	movs	r1, #1
 8008b86:	325d      	adds	r2, #93	; 0x5d
 8008b88:	7011      	strb	r1, [r2, #0]
    if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 8008b8a:	689a      	ldr	r2, [r3, #8]
 8008b8c:	06d2      	lsls	r2, r2, #27
 8008b8e:	d505      	bpl.n	8008b9c <SPI_DMATransmitReceiveCplt+0xac>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008b90:	2202      	movs	r2, #2
 8008b92:	6e21      	ldr	r1, [r4, #96]	; 0x60
 8008b94:	430a      	orrs	r2, r1
 8008b96:	6622      	str	r2, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 8008b98:	4a10      	ldr	r2, [pc, #64]	; (8008bdc <SPI_DMATransmitReceiveCplt+0xec>)
 8008b9a:	609a      	str	r2, [r3, #8]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8008b9c:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8008b9e:	2b00      	cmp	r3, #0
 8008ba0:	d017      	beq.n	8008bd2 <SPI_DMATransmitReceiveCplt+0xe2>
      HAL_SPI_ErrorCallback(hspi);
 8008ba2:	0020      	movs	r0, r4
 8008ba4:	f7ff fee7 	bl	8008976 <HAL_SPI_ErrorCallback>
}
 8008ba8:	b005      	add	sp, #20
 8008baa:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_HALF_FULL, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008bac:	2280      	movs	r2, #128	; 0x80
 8008bae:	21c0      	movs	r1, #192	; 0xc0
 8008bb0:	9600      	str	r6, [sp, #0]
 8008bb2:	2364      	movs	r3, #100	; 0x64
 8008bb4:	00d2      	lsls	r2, r2, #3
 8008bb6:	00c9      	lsls	r1, r1, #3
 8008bb8:	0020      	movs	r0, r4
 8008bba:	f7ff fba5 	bl	8008308 <SPI_WaitFifoStateUntilTimeout>
 8008bbe:	2800      	cmp	r0, #0
 8008bc0:	d003      	beq.n	8008bca <SPI_DMATransmitReceiveCplt+0xda>
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008bc2:	2302      	movs	r3, #2
 8008bc4:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8008bc6:	4313      	orrs	r3, r2
 8008bc8:	6623      	str	r3, [r4, #96]	; 0x60
        tmpreg = hspi->Instance->DR;
 8008bca:	6823      	ldr	r3, [r4, #0]
 8008bcc:	68db      	ldr	r3, [r3, #12]
 8008bce:	b21b      	sxth	r3, r3
 8008bd0:	e7c0      	b.n	8008b54 <SPI_DMATransmitReceiveCplt+0x64>
  HAL_SPI_TxRxCpltCallback(hspi);
 8008bd2:	0020      	movs	r0, r4
 8008bd4:	f7ff febc 	bl	8008950 <HAL_SPI_TxRxCpltCallback>
 8008bd8:	e7e6      	b.n	8008ba8 <SPI_DMATransmitReceiveCplt+0xb8>
 8008bda:	46c0      	nop			; (mov r8, r8)
 8008bdc:	0000ffef 	.word	0x0000ffef

08008be0 <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx = 0U;
  uint32_t tmpccer = 0U;
  uint32_t tmpcr2 = 0U;

   /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8008be0:	2201      	movs	r2, #1
 8008be2:	6a03      	ldr	r3, [r0, #32]
{
 8008be4:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8008be6:	4393      	bics	r3, r2
 8008be8:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8008bea:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8008bec:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8008bee:	6985      	ldr	r5, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8008bf0:	3272      	adds	r2, #114	; 0x72
 8008bf2:	4395      	bics	r5, r2
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8008bf4:	680a      	ldr	r2, [r1, #0]
 8008bf6:	4315      	orrs	r5, r2

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 8008bf8:	2202      	movs	r2, #2
 8008bfa:	4393      	bics	r3, r2
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8008bfc:	688a      	ldr	r2, [r1, #8]
 8008bfe:	4313      	orrs	r3, r2

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8008c00:	4a14      	ldr	r2, [pc, #80]	; (8008c54 <TIM_OC1_SetConfig+0x74>)
 8008c02:	4290      	cmp	r0, r2
 8008c04:	d008      	beq.n	8008c18 <TIM_OC1_SetConfig+0x38>
 8008c06:	4e14      	ldr	r6, [pc, #80]	; (8008c58 <TIM_OC1_SetConfig+0x78>)
 8008c08:	42b0      	cmp	r0, r6
 8008c0a:	d005      	beq.n	8008c18 <TIM_OC1_SetConfig+0x38>
 8008c0c:	4e13      	ldr	r6, [pc, #76]	; (8008c5c <TIM_OC1_SetConfig+0x7c>)
 8008c0e:	42b0      	cmp	r0, r6
 8008c10:	d002      	beq.n	8008c18 <TIM_OC1_SetConfig+0x38>
 8008c12:	4e13      	ldr	r6, [pc, #76]	; (8008c60 <TIM_OC1_SetConfig+0x80>)
 8008c14:	42b0      	cmp	r0, r6
 8008c16:	d116      	bne.n	8008c46 <TIM_OC1_SetConfig+0x66>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 8008c18:	2608      	movs	r6, #8
 8008c1a:	43b3      	bics	r3, r6
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8008c1c:	68ce      	ldr	r6, [r1, #12]
 8008c1e:	4333      	orrs	r3, r6
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 8008c20:	2604      	movs	r6, #4
 8008c22:	43b3      	bics	r3, r6
  }

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8008c24:	4290      	cmp	r0, r2
 8008c26:	d008      	beq.n	8008c3a <TIM_OC1_SetConfig+0x5a>
 8008c28:	4a0b      	ldr	r2, [pc, #44]	; (8008c58 <TIM_OC1_SetConfig+0x78>)
 8008c2a:	4290      	cmp	r0, r2
 8008c2c:	d005      	beq.n	8008c3a <TIM_OC1_SetConfig+0x5a>
 8008c2e:	4a0b      	ldr	r2, [pc, #44]	; (8008c5c <TIM_OC1_SetConfig+0x7c>)
 8008c30:	4290      	cmp	r0, r2
 8008c32:	d002      	beq.n	8008c3a <TIM_OC1_SetConfig+0x5a>
 8008c34:	4a0a      	ldr	r2, [pc, #40]	; (8008c60 <TIM_OC1_SetConfig+0x80>)
 8008c36:	4290      	cmp	r0, r2
 8008c38:	d105      	bne.n	8008c46 <TIM_OC1_SetConfig+0x66>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8008c3a:	4a0a      	ldr	r2, [pc, #40]	; (8008c64 <TIM_OC1_SetConfig+0x84>)
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8008c3c:	698e      	ldr	r6, [r1, #24]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8008c3e:	4022      	ands	r2, r4
    tmpcr2 |= OC_Config->OCNIdleState;
 8008c40:	694c      	ldr	r4, [r1, #20]
 8008c42:	4334      	orrs	r4, r6
 8008c44:	4314      	orrs	r4, r2

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8008c46:	684a      	ldr	r2, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8008c48:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 8008c4a:	6185      	str	r5, [r0, #24]
  TIMx->CCR1 = OC_Config->Pulse;
 8008c4c:	6342      	str	r2, [r0, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8008c4e:	6203      	str	r3, [r0, #32]
}
 8008c50:	bd70      	pop	{r4, r5, r6, pc}
 8008c52:	46c0      	nop			; (mov r8, r8)
 8008c54:	40012c00 	.word	0x40012c00
 8008c58:	40014000 	.word	0x40014000
 8008c5c:	40014400 	.word	0x40014400
 8008c60:	40014800 	.word	0x40014800
 8008c64:	fffffcff 	.word	0xfffffcff

08008c68 <TIM_OC3_SetConfig>:
  * @param  TIMx  to select the TIM peripheral
  * @param  OC_Config : The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8008c68:	b570      	push	{r4, r5, r6, lr}
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8008c6a:	2573      	movs	r5, #115	; 0x73
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8008c6c:	6a03      	ldr	r3, [r0, #32]
 8008c6e:	4a17      	ldr	r2, [pc, #92]	; (8008ccc <TIM_OC3_SetConfig+0x64>)
 8008c70:	4013      	ands	r3, r2
 8008c72:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8008c74:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 8008c76:	6842      	ldr	r2, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
 8008c78:	69c4      	ldr	r4, [r0, #28]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8008c7a:	43ac      	bics	r4, r5
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8008c7c:	680d      	ldr	r5, [r1, #0]
 8008c7e:	432c      	orrs	r4, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8008c80:	4d13      	ldr	r5, [pc, #76]	; (8008cd0 <TIM_OC3_SetConfig+0x68>)
 8008c82:	402b      	ands	r3, r5
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8008c84:	688d      	ldr	r5, [r1, #8]
 8008c86:	022d      	lsls	r5, r5, #8
 8008c88:	432b      	orrs	r3, r5

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8008c8a:	4d12      	ldr	r5, [pc, #72]	; (8008cd4 <TIM_OC3_SetConfig+0x6c>)
 8008c8c:	42a8      	cmp	r0, r5
 8008c8e:	d10e      	bne.n	8008cae <TIM_OC3_SetConfig+0x46>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 8008c90:	4d11      	ldr	r5, [pc, #68]	; (8008cd8 <TIM_OC3_SetConfig+0x70>)
 8008c92:	401d      	ands	r5, r3
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8008c94:	68cb      	ldr	r3, [r1, #12]
 8008c96:	021b      	lsls	r3, r3, #8
 8008c98:	432b      	orrs	r3, r5
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 8008c9a:	4d10      	ldr	r5, [pc, #64]	; (8008cdc <TIM_OC3_SetConfig+0x74>)
 8008c9c:	402b      	ands	r3, r5
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8008c9e:	4d10      	ldr	r5, [pc, #64]	; (8008ce0 <TIM_OC3_SetConfig+0x78>)
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8008ca0:	694e      	ldr	r6, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8008ca2:	4015      	ands	r5, r2
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8008ca4:	698a      	ldr	r2, [r1, #24]
 8008ca6:	4332      	orrs	r2, r6
 8008ca8:	0112      	lsls	r2, r2, #4
 8008caa:	432a      	orrs	r2, r5
 8008cac:	e008      	b.n	8008cc0 <TIM_OC3_SetConfig+0x58>
  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8008cae:	4d0d      	ldr	r5, [pc, #52]	; (8008ce4 <TIM_OC3_SetConfig+0x7c>)
 8008cb0:	42a8      	cmp	r0, r5
 8008cb2:	d0f4      	beq.n	8008c9e <TIM_OC3_SetConfig+0x36>
 8008cb4:	4d0c      	ldr	r5, [pc, #48]	; (8008ce8 <TIM_OC3_SetConfig+0x80>)
 8008cb6:	42a8      	cmp	r0, r5
 8008cb8:	d0f1      	beq.n	8008c9e <TIM_OC3_SetConfig+0x36>
 8008cba:	4d0c      	ldr	r5, [pc, #48]	; (8008cec <TIM_OC3_SetConfig+0x84>)
 8008cbc:	42a8      	cmp	r0, r5
 8008cbe:	d0ee      	beq.n	8008c9e <TIM_OC3_SetConfig+0x36>
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8008cc0:	6042      	str	r2, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8008cc2:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 8008cc4:	61c4      	str	r4, [r0, #28]
  TIMx->CCR3 = OC_Config->Pulse;
 8008cc6:	63c2      	str	r2, [r0, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8008cc8:	6203      	str	r3, [r0, #32]
}
 8008cca:	bd70      	pop	{r4, r5, r6, pc}
 8008ccc:	fffffeff 	.word	0xfffffeff
 8008cd0:	fffffdff 	.word	0xfffffdff
 8008cd4:	40012c00 	.word	0x40012c00
 8008cd8:	fffff7ff 	.word	0xfffff7ff
 8008cdc:	fffffbff 	.word	0xfffffbff
 8008ce0:	ffffcfff 	.word	0xffffcfff
 8008ce4:	40014000 	.word	0x40014000
 8008ce8:	40014400 	.word	0x40014400
 8008cec:	40014800 	.word	0x40014800

08008cf0 <TIM_OC4_SetConfig>:
  uint32_t tmpccmrx = 0U;
  uint32_t tmpccer = 0U;
  uint32_t tmpcr2 = 0U;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8008cf0:	6a03      	ldr	r3, [r0, #32]
 8008cf2:	4a14      	ldr	r2, [pc, #80]	; (8008d44 <TIM_OC4_SetConfig+0x54>)
{
 8008cf4:	b530      	push	{r4, r5, lr}
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8008cf6:	4013      	ands	r3, r2
 8008cf8:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8008cfa:	6a02      	ldr	r2, [r0, #32]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8008cfc:	4c12      	ldr	r4, [pc, #72]	; (8008d48 <TIM_OC4_SetConfig+0x58>)
  tmpcr2 =  TIMx->CR2;
 8008cfe:	6843      	ldr	r3, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
 8008d00:	69c5      	ldr	r5, [r0, #28]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8008d02:	4025      	ands	r5, r4

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8008d04:	680c      	ldr	r4, [r1, #0]
 8008d06:	0224      	lsls	r4, r4, #8
 8008d08:	4325      	orrs	r5, r4

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8008d0a:	4c10      	ldr	r4, [pc, #64]	; (8008d4c <TIM_OC4_SetConfig+0x5c>)
 8008d0c:	4022      	ands	r2, r4
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8008d0e:	688c      	ldr	r4, [r1, #8]
 8008d10:	0324      	lsls	r4, r4, #12
 8008d12:	4322      	orrs	r2, r4

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8008d14:	4c0e      	ldr	r4, [pc, #56]	; (8008d50 <TIM_OC4_SetConfig+0x60>)
 8008d16:	42a0      	cmp	r0, r4
 8008d18:	d008      	beq.n	8008d2c <TIM_OC4_SetConfig+0x3c>
 8008d1a:	4c0e      	ldr	r4, [pc, #56]	; (8008d54 <TIM_OC4_SetConfig+0x64>)
 8008d1c:	42a0      	cmp	r0, r4
 8008d1e:	d005      	beq.n	8008d2c <TIM_OC4_SetConfig+0x3c>
 8008d20:	4c0d      	ldr	r4, [pc, #52]	; (8008d58 <TIM_OC4_SetConfig+0x68>)
 8008d22:	42a0      	cmp	r0, r4
 8008d24:	d002      	beq.n	8008d2c <TIM_OC4_SetConfig+0x3c>
 8008d26:	4c0d      	ldr	r4, [pc, #52]	; (8008d5c <TIM_OC4_SetConfig+0x6c>)
 8008d28:	42a0      	cmp	r0, r4
 8008d2a:	d104      	bne.n	8008d36 <TIM_OC4_SetConfig+0x46>
  {
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

   /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 8008d2c:	4c0c      	ldr	r4, [pc, #48]	; (8008d60 <TIM_OC4_SetConfig+0x70>)
 8008d2e:	4023      	ands	r3, r4
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8008d30:	694c      	ldr	r4, [r1, #20]
 8008d32:	01a4      	lsls	r4, r4, #6
 8008d34:	4323      	orrs	r3, r4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8008d36:	6043      	str	r3, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8008d38:	684b      	ldr	r3, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 8008d3a:	61c5      	str	r5, [r0, #28]
  TIMx->CCR4 = OC_Config->Pulse;
 8008d3c:	6403      	str	r3, [r0, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8008d3e:	6202      	str	r2, [r0, #32]
}
 8008d40:	bd30      	pop	{r4, r5, pc}
 8008d42:	46c0      	nop			; (mov r8, r8)
 8008d44:	ffffefff 	.word	0xffffefff
 8008d48:	ffff8cff 	.word	0xffff8cff
 8008d4c:	ffffdfff 	.word	0xffffdfff
 8008d50:	40012c00 	.word	0x40012c00
 8008d54:	40014000 	.word	0x40014000
 8008d58:	40014400 	.word	0x40014400
 8008d5c:	40014800 	.word	0x40014800
 8008d60:	ffffbfff 	.word	0xffffbfff

08008d64 <HAL_TIM_Base_Stop_IT>:
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 8008d64:	2101      	movs	r1, #1
 8008d66:	6803      	ldr	r3, [r0, #0]
 8008d68:	68da      	ldr	r2, [r3, #12]
 8008d6a:	438a      	bics	r2, r1
 8008d6c:	60da      	str	r2, [r3, #12]
  __HAL_TIM_DISABLE(htim);
 8008d6e:	6a18      	ldr	r0, [r3, #32]
 8008d70:	4a05      	ldr	r2, [pc, #20]	; (8008d88 <HAL_TIM_Base_Stop_IT+0x24>)
 8008d72:	4210      	tst	r0, r2
 8008d74:	d106      	bne.n	8008d84 <HAL_TIM_Base_Stop_IT+0x20>
 8008d76:	6a18      	ldr	r0, [r3, #32]
 8008d78:	4a04      	ldr	r2, [pc, #16]	; (8008d8c <HAL_TIM_Base_Stop_IT+0x28>)
 8008d7a:	4210      	tst	r0, r2
 8008d7c:	d102      	bne.n	8008d84 <HAL_TIM_Base_Stop_IT+0x20>
 8008d7e:	681a      	ldr	r2, [r3, #0]
 8008d80:	438a      	bics	r2, r1
 8008d82:	601a      	str	r2, [r3, #0]
}
 8008d84:	2000      	movs	r0, #0
 8008d86:	4770      	bx	lr
 8008d88:	00001111 	.word	0x00001111
 8008d8c:	00000444 	.word	0x00000444

08008d90 <HAL_TIM_OC_MspInit>:
 8008d90:	4770      	bx	lr
	...

08008d94 <TIM_Base_SetConfig>:
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8008d94:	4a20      	ldr	r2, [pc, #128]	; (8008e18 <TIM_Base_SetConfig+0x84>)
{
 8008d96:	b510      	push	{r4, lr}
  tmpcr1 = TIMx->CR1;
 8008d98:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8008d9a:	4290      	cmp	r0, r2
 8008d9c:	d006      	beq.n	8008dac <TIM_Base_SetConfig+0x18>
 8008d9e:	2480      	movs	r4, #128	; 0x80
 8008da0:	05e4      	lsls	r4, r4, #23
 8008da2:	42a0      	cmp	r0, r4
 8008da4:	d002      	beq.n	8008dac <TIM_Base_SetConfig+0x18>
 8008da6:	4c1d      	ldr	r4, [pc, #116]	; (8008e1c <TIM_Base_SetConfig+0x88>)
 8008da8:	42a0      	cmp	r0, r4
 8008daa:	d10c      	bne.n	8008dc6 <TIM_Base_SetConfig+0x32>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8008dac:	2470      	movs	r4, #112	; 0x70
 8008dae:	43a3      	bics	r3, r4
    tmpcr1 |= Structure->CounterMode;
 8008db0:	684c      	ldr	r4, [r1, #4]
 8008db2:	4323      	orrs	r3, r4
  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8008db4:	4290      	cmp	r0, r2
 8008db6:	d012      	beq.n	8008dde <TIM_Base_SetConfig+0x4a>
 8008db8:	2480      	movs	r4, #128	; 0x80
 8008dba:	05e4      	lsls	r4, r4, #23
 8008dbc:	42a0      	cmp	r0, r4
 8008dbe:	d00e      	beq.n	8008dde <TIM_Base_SetConfig+0x4a>
 8008dc0:	4c16      	ldr	r4, [pc, #88]	; (8008e1c <TIM_Base_SetConfig+0x88>)
 8008dc2:	42a0      	cmp	r0, r4
 8008dc4:	d00b      	beq.n	8008dde <TIM_Base_SetConfig+0x4a>
 8008dc6:	4c16      	ldr	r4, [pc, #88]	; (8008e20 <TIM_Base_SetConfig+0x8c>)
 8008dc8:	42a0      	cmp	r0, r4
 8008dca:	d008      	beq.n	8008dde <TIM_Base_SetConfig+0x4a>
 8008dcc:	4c15      	ldr	r4, [pc, #84]	; (8008e24 <TIM_Base_SetConfig+0x90>)
 8008dce:	42a0      	cmp	r0, r4
 8008dd0:	d005      	beq.n	8008dde <TIM_Base_SetConfig+0x4a>
 8008dd2:	4c15      	ldr	r4, [pc, #84]	; (8008e28 <TIM_Base_SetConfig+0x94>)
 8008dd4:	42a0      	cmp	r0, r4
 8008dd6:	d002      	beq.n	8008dde <TIM_Base_SetConfig+0x4a>
 8008dd8:	4c14      	ldr	r4, [pc, #80]	; (8008e2c <TIM_Base_SetConfig+0x98>)
 8008dda:	42a0      	cmp	r0, r4
 8008ddc:	d103      	bne.n	8008de6 <TIM_Base_SetConfig+0x52>
    tmpcr1 &= ~TIM_CR1_CKD;
 8008dde:	4c14      	ldr	r4, [pc, #80]	; (8008e30 <TIM_Base_SetConfig+0x9c>)
 8008de0:	4023      	ands	r3, r4
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8008de2:	68cc      	ldr	r4, [r1, #12]
 8008de4:	4323      	orrs	r3, r4
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8008de6:	2480      	movs	r4, #128	; 0x80
 8008de8:	43a3      	bics	r3, r4
 8008dea:	694c      	ldr	r4, [r1, #20]
 8008dec:	4323      	orrs	r3, r4
  TIMx->CR1 = tmpcr1;
 8008dee:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8008df0:	688b      	ldr	r3, [r1, #8]
 8008df2:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8008df4:	680b      	ldr	r3, [r1, #0]
 8008df6:	6283      	str	r3, [r0, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8008df8:	4290      	cmp	r0, r2
 8008dfa:	d008      	beq.n	8008e0e <TIM_Base_SetConfig+0x7a>
 8008dfc:	4b09      	ldr	r3, [pc, #36]	; (8008e24 <TIM_Base_SetConfig+0x90>)
 8008dfe:	4298      	cmp	r0, r3
 8008e00:	d005      	beq.n	8008e0e <TIM_Base_SetConfig+0x7a>
 8008e02:	4b09      	ldr	r3, [pc, #36]	; (8008e28 <TIM_Base_SetConfig+0x94>)
 8008e04:	4298      	cmp	r0, r3
 8008e06:	d002      	beq.n	8008e0e <TIM_Base_SetConfig+0x7a>
 8008e08:	4b08      	ldr	r3, [pc, #32]	; (8008e2c <TIM_Base_SetConfig+0x98>)
 8008e0a:	4298      	cmp	r0, r3
 8008e0c:	d101      	bne.n	8008e12 <TIM_Base_SetConfig+0x7e>
    TIMx->RCR = Structure->RepetitionCounter;
 8008e0e:	690b      	ldr	r3, [r1, #16]
 8008e10:	6303      	str	r3, [r0, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 8008e12:	2301      	movs	r3, #1
 8008e14:	6143      	str	r3, [r0, #20]
}
 8008e16:	bd10      	pop	{r4, pc}
 8008e18:	40012c00 	.word	0x40012c00
 8008e1c:	40000400 	.word	0x40000400
 8008e20:	40002000 	.word	0x40002000
 8008e24:	40014000 	.word	0x40014000
 8008e28:	40014400 	.word	0x40014400
 8008e2c:	40014800 	.word	0x40014800
 8008e30:	fffffcff 	.word	0xfffffcff

08008e34 <HAL_TIM_Base_Init>:
{
 8008e34:	b570      	push	{r4, r5, r6, lr}
 8008e36:	0004      	movs	r4, r0
    return HAL_ERROR;
 8008e38:	2001      	movs	r0, #1
  if(htim == NULL)
 8008e3a:	2c00      	cmp	r4, #0
 8008e3c:	d014      	beq.n	8008e68 <HAL_TIM_Base_Init+0x34>
  if(htim->State == HAL_TIM_STATE_RESET)
 8008e3e:	0025      	movs	r5, r4
 8008e40:	353d      	adds	r5, #61	; 0x3d
 8008e42:	782b      	ldrb	r3, [r5, #0]
 8008e44:	b2db      	uxtb	r3, r3
 8008e46:	2b00      	cmp	r3, #0
 8008e48:	d105      	bne.n	8008e56 <HAL_TIM_Base_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 8008e4a:	0022      	movs	r2, r4
 8008e4c:	323c      	adds	r2, #60	; 0x3c
 8008e4e:	7013      	strb	r3, [r2, #0]
    HAL_TIM_Base_MspInit(htim);
 8008e50:	0020      	movs	r0, r4
 8008e52:	f7fd f8d9 	bl	8006008 <HAL_TIM_Base_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 8008e56:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8008e58:	6820      	ldr	r0, [r4, #0]
  htim->State= HAL_TIM_STATE_BUSY;
 8008e5a:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8008e5c:	1d21      	adds	r1, r4, #4
 8008e5e:	f7ff ff99 	bl	8008d94 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8008e62:	2301      	movs	r3, #1
  return HAL_OK;
 8008e64:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 8008e66:	702b      	strb	r3, [r5, #0]
}
 8008e68:	bd70      	pop	{r4, r5, r6, pc}

08008e6a <HAL_TIM_OC_Init>:
{
 8008e6a:	b570      	push	{r4, r5, r6, lr}
 8008e6c:	0004      	movs	r4, r0
    return HAL_ERROR;
 8008e6e:	2001      	movs	r0, #1
  if(htim == NULL)
 8008e70:	2c00      	cmp	r4, #0
 8008e72:	d014      	beq.n	8008e9e <HAL_TIM_OC_Init+0x34>
  if(htim->State == HAL_TIM_STATE_RESET)
 8008e74:	0025      	movs	r5, r4
 8008e76:	353d      	adds	r5, #61	; 0x3d
 8008e78:	782b      	ldrb	r3, [r5, #0]
 8008e7a:	b2db      	uxtb	r3, r3
 8008e7c:	2b00      	cmp	r3, #0
 8008e7e:	d105      	bne.n	8008e8c <HAL_TIM_OC_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 8008e80:	0022      	movs	r2, r4
 8008e82:	323c      	adds	r2, #60	; 0x3c
 8008e84:	7013      	strb	r3, [r2, #0]
    HAL_TIM_OC_MspInit(htim);
 8008e86:	0020      	movs	r0, r4
 8008e88:	f7ff ff82 	bl	8008d90 <HAL_TIM_OC_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 8008e8c:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 8008e8e:	6820      	ldr	r0, [r4, #0]
  htim->State= HAL_TIM_STATE_BUSY;
 8008e90:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 8008e92:	1d21      	adds	r1, r4, #4
 8008e94:	f7ff ff7e 	bl	8008d94 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8008e98:	2301      	movs	r3, #1
  return HAL_OK;
 8008e9a:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 8008e9c:	702b      	strb	r3, [r5, #0]
}
 8008e9e:	bd70      	pop	{r4, r5, r6, pc}

08008ea0 <TIM_OC2_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8008ea0:	2210      	movs	r2, #16
 8008ea2:	6a03      	ldr	r3, [r0, #32]
{
 8008ea4:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8008ea6:	4393      	bics	r3, r2
 8008ea8:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8008eaa:	6a02      	ldr	r2, [r0, #32]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8008eac:	4d16      	ldr	r5, [pc, #88]	; (8008f08 <TIM_OC2_SetConfig+0x68>)
  tmpcr2 =  TIMx->CR2;
 8008eae:	6843      	ldr	r3, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 8008eb0:	6984      	ldr	r4, [r0, #24]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8008eb2:	402c      	ands	r4, r5
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8008eb4:	680d      	ldr	r5, [r1, #0]
 8008eb6:	022d      	lsls	r5, r5, #8
 8008eb8:	432c      	orrs	r4, r5
  tmpccer &= ~TIM_CCER_CC2P;
 8008eba:	2520      	movs	r5, #32
 8008ebc:	43aa      	bics	r2, r5
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8008ebe:	688d      	ldr	r5, [r1, #8]
 8008ec0:	012d      	lsls	r5, r5, #4
 8008ec2:	432a      	orrs	r2, r5
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8008ec4:	4d11      	ldr	r5, [pc, #68]	; (8008f0c <TIM_OC2_SetConfig+0x6c>)
 8008ec6:	42a8      	cmp	r0, r5
 8008ec8:	d10f      	bne.n	8008eea <TIM_OC2_SetConfig+0x4a>
    tmpccer &= ~TIM_CCER_CC2NP;
 8008eca:	2580      	movs	r5, #128	; 0x80
 8008ecc:	43aa      	bics	r2, r5
 8008ece:	0015      	movs	r5, r2
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8008ed0:	68ca      	ldr	r2, [r1, #12]
 8008ed2:	0112      	lsls	r2, r2, #4
 8008ed4:	432a      	orrs	r2, r5
    tmpccer &= ~TIM_CCER_CC2NE;
 8008ed6:	2540      	movs	r5, #64	; 0x40
 8008ed8:	43aa      	bics	r2, r5
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8008eda:	4d0d      	ldr	r5, [pc, #52]	; (8008f10 <TIM_OC2_SetConfig+0x70>)
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8008edc:	694e      	ldr	r6, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8008ede:	401d      	ands	r5, r3
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8008ee0:	698b      	ldr	r3, [r1, #24]
 8008ee2:	4333      	orrs	r3, r6
 8008ee4:	009b      	lsls	r3, r3, #2
 8008ee6:	432b      	orrs	r3, r5
 8008ee8:	e008      	b.n	8008efc <TIM_OC2_SetConfig+0x5c>
  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8008eea:	4d0a      	ldr	r5, [pc, #40]	; (8008f14 <TIM_OC2_SetConfig+0x74>)
 8008eec:	42a8      	cmp	r0, r5
 8008eee:	d0f4      	beq.n	8008eda <TIM_OC2_SetConfig+0x3a>
 8008ef0:	4d09      	ldr	r5, [pc, #36]	; (8008f18 <TIM_OC2_SetConfig+0x78>)
 8008ef2:	42a8      	cmp	r0, r5
 8008ef4:	d0f1      	beq.n	8008eda <TIM_OC2_SetConfig+0x3a>
 8008ef6:	4d09      	ldr	r5, [pc, #36]	; (8008f1c <TIM_OC2_SetConfig+0x7c>)
 8008ef8:	42a8      	cmp	r0, r5
 8008efa:	d0ee      	beq.n	8008eda <TIM_OC2_SetConfig+0x3a>
  TIMx->CR2 = tmpcr2;
 8008efc:	6043      	str	r3, [r0, #4]
  TIMx->CCR2 = OC_Config->Pulse;
 8008efe:	684b      	ldr	r3, [r1, #4]
  TIMx->CCMR1 = tmpccmrx;
 8008f00:	6184      	str	r4, [r0, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8008f02:	6383      	str	r3, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
 8008f04:	6202      	str	r2, [r0, #32]
}
 8008f06:	bd70      	pop	{r4, r5, r6, pc}
 8008f08:	ffff8cff 	.word	0xffff8cff
 8008f0c:	40012c00 	.word	0x40012c00
 8008f10:	fffff3ff 	.word	0xfffff3ff
 8008f14:	40014000 	.word	0x40014000
 8008f18:	40014400 	.word	0x40014400
 8008f1c:	40014800 	.word	0x40014800

08008f20 <HAL_TIM_OC_ConfigChannel>:
{
 8008f20:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(htim);
 8008f22:	0004      	movs	r4, r0
 8008f24:	2602      	movs	r6, #2
 8008f26:	343c      	adds	r4, #60	; 0x3c
 8008f28:	7825      	ldrb	r5, [r4, #0]
{
 8008f2a:	0003      	movs	r3, r0
  __HAL_LOCK(htim);
 8008f2c:	0030      	movs	r0, r6
 8008f2e:	2d01      	cmp	r5, #1
 8008f30:	d017      	beq.n	8008f62 <HAL_TIM_OC_ConfigChannel+0x42>
  htim->State = HAL_TIM_STATE_BUSY;
 8008f32:	001d      	movs	r5, r3
  __HAL_LOCK(htim);
 8008f34:	3801      	subs	r0, #1
  htim->State = HAL_TIM_STATE_BUSY;
 8008f36:	353d      	adds	r5, #61	; 0x3d
  __HAL_LOCK(htim);
 8008f38:	7020      	strb	r0, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8008f3a:	702e      	strb	r6, [r5, #0]
  switch (Channel)
 8008f3c:	2a0c      	cmp	r2, #12
 8008f3e:	d80c      	bhi.n	8008f5a <HAL_TIM_OC_ConfigChannel+0x3a>
 8008f40:	0010      	movs	r0, r2
 8008f42:	f7fc fd37 	bl	80059b4 <__gnu_thumb1_case_uqi>
 8008f46:	0a07      	.short	0x0a07
 8008f48:	0a0f0a0a 	.word	0x0a0f0a0a
 8008f4c:	0a130a0a 	.word	0x0a130a0a
 8008f50:	0a0a      	.short	0x0a0a
 8008f52:	17          	.byte	0x17
 8008f53:	00          	.byte	0x00
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8008f54:	6818      	ldr	r0, [r3, #0]
 8008f56:	f7ff fe43 	bl	8008be0 <TIM_OC1_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
 8008f5a:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
 8008f5c:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8008f5e:	702b      	strb	r3, [r5, #0]
  __HAL_UNLOCK(htim);
 8008f60:	7020      	strb	r0, [r4, #0]
}
 8008f62:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8008f64:	6818      	ldr	r0, [r3, #0]
 8008f66:	f7ff ff9b 	bl	8008ea0 <TIM_OC2_SetConfig>
    break;
 8008f6a:	e7f6      	b.n	8008f5a <HAL_TIM_OC_ConfigChannel+0x3a>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8008f6c:	6818      	ldr	r0, [r3, #0]
 8008f6e:	f7ff fe7b 	bl	8008c68 <TIM_OC3_SetConfig>
    break;
 8008f72:	e7f2      	b.n	8008f5a <HAL_TIM_OC_ConfigChannel+0x3a>
       TIM_OC4_SetConfig(htim->Instance, sConfig);
 8008f74:	6818      	ldr	r0, [r3, #0]
 8008f76:	f7ff febb 	bl	8008cf0 <TIM_OC4_SetConfig>
    break;
 8008f7a:	e7ee      	b.n	8008f5a <HAL_TIM_OC_ConfigChannel+0x3a>

08008f7c <TIM_CCxChannelCmd>:
  * @param  ChannelState : specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
{
 8008f7c:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << Channel;
 8008f7e:	2401      	movs	r4, #1
 8008f80:	408c      	lsls	r4, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;

  /* Set or reset the CCxE Bit */
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 8008f82:	408a      	lsls	r2, r1
  TIMx->CCER &= ~tmp;
 8008f84:	6a03      	ldr	r3, [r0, #32]
 8008f86:	43a3      	bics	r3, r4
 8008f88:	6203      	str	r3, [r0, #32]
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 8008f8a:	6a03      	ldr	r3, [r0, #32]
 8008f8c:	431a      	orrs	r2, r3
 8008f8e:	6202      	str	r2, [r0, #32]
}
 8008f90:	bd10      	pop	{r4, pc}
	...

08008f94 <HAL_TIM_OC_Start_IT>:
{
 8008f94:	b510      	push	{r4, lr}
 8008f96:	6803      	ldr	r3, [r0, #0]
 8008f98:	0004      	movs	r4, r0
  switch (Channel)
 8008f9a:	290c      	cmp	r1, #12
 8008f9c:	d80d      	bhi.n	8008fba <HAL_TIM_OC_Start_IT+0x26>
 8008f9e:	0008      	movs	r0, r1
 8008fa0:	f7fc fd08 	bl	80059b4 <__gnu_thumb1_case_uqi>
 8008fa4:	0b0b0b07 	.word	0x0b0b0b07
 8008fa8:	0b0b0b27 	.word	0x0b0b0b27
 8008fac:	0b0b0b2a 	.word	0x0b0b0b2a
 8008fb0:	2d          	.byte	0x2d
 8008fb1:	00          	.byte	0x00
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 8008fb2:	2202      	movs	r2, #2
 8008fb4:	68d8      	ldr	r0, [r3, #12]
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 8008fb6:	4302      	orrs	r2, r0
 8008fb8:	60da      	str	r2, [r3, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8008fba:	2201      	movs	r2, #1
 8008fbc:	0018      	movs	r0, r3
 8008fbe:	f7ff ffdd 	bl	8008f7c <TIM_CCxChannelCmd>
  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8008fc2:	6823      	ldr	r3, [r4, #0]
 8008fc4:	4a0f      	ldr	r2, [pc, #60]	; (8009004 <HAL_TIM_OC_Start_IT+0x70>)
 8008fc6:	4293      	cmp	r3, r2
 8008fc8:	d008      	beq.n	8008fdc <HAL_TIM_OC_Start_IT+0x48>
 8008fca:	4a0f      	ldr	r2, [pc, #60]	; (8009008 <HAL_TIM_OC_Start_IT+0x74>)
 8008fcc:	4293      	cmp	r3, r2
 8008fce:	d005      	beq.n	8008fdc <HAL_TIM_OC_Start_IT+0x48>
 8008fd0:	4a0e      	ldr	r2, [pc, #56]	; (800900c <HAL_TIM_OC_Start_IT+0x78>)
 8008fd2:	4293      	cmp	r3, r2
 8008fd4:	d002      	beq.n	8008fdc <HAL_TIM_OC_Start_IT+0x48>
 8008fd6:	4a0e      	ldr	r2, [pc, #56]	; (8009010 <HAL_TIM_OC_Start_IT+0x7c>)
 8008fd8:	4293      	cmp	r3, r2
 8008fda:	d104      	bne.n	8008fe6 <HAL_TIM_OC_Start_IT+0x52>
    __HAL_TIM_MOE_ENABLE(htim);
 8008fdc:	2280      	movs	r2, #128	; 0x80
 8008fde:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8008fe0:	0212      	lsls	r2, r2, #8
 8008fe2:	430a      	orrs	r2, r1
 8008fe4:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_ENABLE(htim);
 8008fe6:	2201      	movs	r2, #1
 8008fe8:	6819      	ldr	r1, [r3, #0]
}
 8008fea:	2000      	movs	r0, #0
  __HAL_TIM_ENABLE(htim);
 8008fec:	430a      	orrs	r2, r1
 8008fee:	601a      	str	r2, [r3, #0]
}
 8008ff0:	bd10      	pop	{r4, pc}
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 8008ff2:	68d8      	ldr	r0, [r3, #12]
 8008ff4:	2204      	movs	r2, #4
 8008ff6:	e7de      	b.n	8008fb6 <HAL_TIM_OC_Start_IT+0x22>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 8008ff8:	68d8      	ldr	r0, [r3, #12]
 8008ffa:	2208      	movs	r2, #8
 8008ffc:	e7db      	b.n	8008fb6 <HAL_TIM_OC_Start_IT+0x22>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 8008ffe:	68d8      	ldr	r0, [r3, #12]
 8009000:	2210      	movs	r2, #16
 8009002:	e7d8      	b.n	8008fb6 <HAL_TIM_OC_Start_IT+0x22>
 8009004:	40012c00 	.word	0x40012c00
 8009008:	40014000 	.word	0x40014000
 800900c:	40014400 	.word	0x40014400
 8009010:	40014800 	.word	0x40014800

08009014 <HAL_TIM_OC_Stop_IT>:
{
 8009014:	b510      	push	{r4, lr}
 8009016:	6803      	ldr	r3, [r0, #0]
 8009018:	0004      	movs	r4, r0
  switch (Channel)
 800901a:	290c      	cmp	r1, #12
 800901c:	d80d      	bhi.n	800903a <HAL_TIM_OC_Stop_IT+0x26>
 800901e:	0008      	movs	r0, r1
 8009020:	f7fc fcc8 	bl	80059b4 <__gnu_thumb1_case_uqi>
 8009024:	0b0b0b07 	.word	0x0b0b0b07
 8009028:	0b0b0b35 	.word	0x0b0b0b35
 800902c:	0b0b0b38 	.word	0x0b0b0b38
 8009030:	3b          	.byte	0x3b
 8009031:	00          	.byte	0x00
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 8009032:	2002      	movs	r0, #2
 8009034:	68da      	ldr	r2, [r3, #12]
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 8009036:	4382      	bics	r2, r0
 8009038:	60da      	str	r2, [r3, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 800903a:	2200      	movs	r2, #0
 800903c:	0018      	movs	r0, r3
 800903e:	f7ff ff9d 	bl	8008f7c <TIM_CCxChannelCmd>
  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8009042:	6823      	ldr	r3, [r4, #0]
 8009044:	4a16      	ldr	r2, [pc, #88]	; (80090a0 <HAL_TIM_OC_Stop_IT+0x8c>)
 8009046:	4917      	ldr	r1, [pc, #92]	; (80090a4 <HAL_TIM_OC_Stop_IT+0x90>)
 8009048:	4293      	cmp	r3, r2
 800904a:	d008      	beq.n	800905e <HAL_TIM_OC_Stop_IT+0x4a>
 800904c:	4a16      	ldr	r2, [pc, #88]	; (80090a8 <HAL_TIM_OC_Stop_IT+0x94>)
 800904e:	4293      	cmp	r3, r2
 8009050:	d005      	beq.n	800905e <HAL_TIM_OC_Stop_IT+0x4a>
 8009052:	4a16      	ldr	r2, [pc, #88]	; (80090ac <HAL_TIM_OC_Stop_IT+0x98>)
 8009054:	4293      	cmp	r3, r2
 8009056:	d002      	beq.n	800905e <HAL_TIM_OC_Stop_IT+0x4a>
 8009058:	4a15      	ldr	r2, [pc, #84]	; (80090b0 <HAL_TIM_OC_Stop_IT+0x9c>)
 800905a:	4293      	cmp	r3, r2
 800905c:	d10a      	bne.n	8009074 <HAL_TIM_OC_Stop_IT+0x60>
    __HAL_TIM_MOE_DISABLE(htim);
 800905e:	6a1a      	ldr	r2, [r3, #32]
 8009060:	420a      	tst	r2, r1
 8009062:	d107      	bne.n	8009074 <HAL_TIM_OC_Stop_IT+0x60>
 8009064:	6a18      	ldr	r0, [r3, #32]
 8009066:	4a13      	ldr	r2, [pc, #76]	; (80090b4 <HAL_TIM_OC_Stop_IT+0xa0>)
 8009068:	4210      	tst	r0, r2
 800906a:	d103      	bne.n	8009074 <HAL_TIM_OC_Stop_IT+0x60>
 800906c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800906e:	4812      	ldr	r0, [pc, #72]	; (80090b8 <HAL_TIM_OC_Stop_IT+0xa4>)
 8009070:	4002      	ands	r2, r0
 8009072:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_DISABLE(htim);
 8009074:	6a1a      	ldr	r2, [r3, #32]
 8009076:	420a      	tst	r2, r1
 8009078:	d107      	bne.n	800908a <HAL_TIM_OC_Stop_IT+0x76>
 800907a:	6a19      	ldr	r1, [r3, #32]
 800907c:	4a0d      	ldr	r2, [pc, #52]	; (80090b4 <HAL_TIM_OC_Stop_IT+0xa0>)
 800907e:	4211      	tst	r1, r2
 8009080:	d103      	bne.n	800908a <HAL_TIM_OC_Stop_IT+0x76>
 8009082:	2101      	movs	r1, #1
 8009084:	681a      	ldr	r2, [r3, #0]
 8009086:	438a      	bics	r2, r1
 8009088:	601a      	str	r2, [r3, #0]
}
 800908a:	2000      	movs	r0, #0
 800908c:	bd10      	pop	{r4, pc}
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 800908e:	68da      	ldr	r2, [r3, #12]
 8009090:	2004      	movs	r0, #4
 8009092:	e7d0      	b.n	8009036 <HAL_TIM_OC_Stop_IT+0x22>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
 8009094:	68da      	ldr	r2, [r3, #12]
 8009096:	2008      	movs	r0, #8
 8009098:	e7cd      	b.n	8009036 <HAL_TIM_OC_Stop_IT+0x22>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 800909a:	68da      	ldr	r2, [r3, #12]
 800909c:	2010      	movs	r0, #16
 800909e:	e7ca      	b.n	8009036 <HAL_TIM_OC_Stop_IT+0x22>
 80090a0:	40012c00 	.word	0x40012c00
 80090a4:	00001111 	.word	0x00001111
 80090a8:	40014000 	.word	0x40014000
 80090ac:	40014400 	.word	0x40014400
 80090b0:	40014800 	.word	0x40014800
 80090b4:	00000444 	.word	0x00000444
 80090b8:	ffff7fff 	.word	0xffff7fff

080090bc <HAL_TIMEx_ConfigBreakDeadTime>:
  *         contains the BDTR Register configuration  information for the TIM peripheral.
  * @retval HAL status
  */    
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
                                                TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
{
 80090bc:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));

  /* Process Locked */
  __HAL_LOCK(htim);
 80090be:	0004      	movs	r4, r0
 80090c0:	2302      	movs	r3, #2
 80090c2:	343c      	adds	r4, #60	; 0x3c
 80090c4:	7825      	ldrb	r5, [r4, #0]
{
 80090c6:	0002      	movs	r2, r0
  __HAL_LOCK(htim);
 80090c8:	0018      	movs	r0, r3
 80090ca:	2d01      	cmp	r5, #1
 80090cc:	d024      	beq.n	8009118 <HAL_TIMEx_ConfigBreakDeadTime+0x5c>

  htim->State = HAL_TIM_STATE_BUSY;
 80090ce:	0010      	movs	r0, r2
 80090d0:	303d      	adds	r0, #61	; 0x3d
  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  
  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 80090d2:	68cd      	ldr	r5, [r1, #12]
  htim->State = HAL_TIM_STATE_BUSY;
 80090d4:	7003      	strb	r3, [r0, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 80090d6:	4b11      	ldr	r3, [pc, #68]	; (800911c <HAL_TIMEx_ConfigBreakDeadTime+0x60>)
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
  
  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
 80090d8:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 80090da:	402b      	ands	r3, r5
 80090dc:	688d      	ldr	r5, [r1, #8]
 80090de:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 80090e0:	4d0f      	ldr	r5, [pc, #60]	; (8009120 <HAL_TIMEx_ConfigBreakDeadTime+0x64>)
 80090e2:	402b      	ands	r3, r5
 80090e4:	684d      	ldr	r5, [r1, #4]
 80090e6:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 80090e8:	4d0e      	ldr	r5, [pc, #56]	; (8009124 <HAL_TIMEx_ConfigBreakDeadTime+0x68>)
 80090ea:	402b      	ands	r3, r5
 80090ec:	680d      	ldr	r5, [r1, #0]
 80090ee:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 80090f0:	4d0d      	ldr	r5, [pc, #52]	; (8009128 <HAL_TIMEx_ConfigBreakDeadTime+0x6c>)
 80090f2:	402b      	ands	r3, r5
 80090f4:	690d      	ldr	r5, [r1, #16]
 80090f6:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 80090f8:	4d0c      	ldr	r5, [pc, #48]	; (800912c <HAL_TIMEx_ConfigBreakDeadTime+0x70>)
 80090fa:	402b      	ands	r3, r5
 80090fc:	694d      	ldr	r5, [r1, #20]
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 80090fe:	6989      	ldr	r1, [r1, #24]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8009100:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8009102:	4d0b      	ldr	r5, [pc, #44]	; (8009130 <HAL_TIMEx_ConfigBreakDeadTime+0x74>)
 8009104:	402b      	ands	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
 8009106:	4d0b      	ldr	r5, [pc, #44]	; (8009134 <HAL_TIMEx_ConfigBreakDeadTime+0x78>)
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8009108:	430b      	orrs	r3, r1
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
 800910a:	402b      	ands	r3, r5
 800910c:	430b      	orrs	r3, r1
  htim->Instance->BDTR = tmpbdtr;
 800910e:	6453      	str	r3, [r2, #68]	; 0x44
  
  htim->State = HAL_TIM_STATE_READY;
 8009110:	2301      	movs	r3, #1
 8009112:	7003      	strb	r3, [r0, #0]

  __HAL_UNLOCK(htim);
 8009114:	2000      	movs	r0, #0
 8009116:	7020      	strb	r0, [r4, #0]

  return HAL_OK;
}
 8009118:	bd30      	pop	{r4, r5, pc}
 800911a:	46c0      	nop			; (mov r8, r8)
 800911c:	fffffcff 	.word	0xfffffcff
 8009120:	fffffbff 	.word	0xfffffbff
 8009124:	fffff7ff 	.word	0xfffff7ff
 8009128:	ffffefff 	.word	0xffffefff
 800912c:	ffffdfff 	.word	0xffffdfff
 8009130:	ffffbfff 	.word	0xffffbfff
 8009134:	ffff7fff 	.word	0xffff7fff

08009138 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart: UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8009138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800913a:	0004      	movs	r4, r0
   *  set the M bits according to huart->Init.WordLength value
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 800913c:	6805      	ldr	r5, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800913e:	69c2      	ldr	r2, [r0, #28]
 8009140:	6883      	ldr	r3, [r0, #8]
 8009142:	6900      	ldr	r0, [r0, #16]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8009144:	6829      	ldr	r1, [r5, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8009146:	4303      	orrs	r3, r0
 8009148:	6960      	ldr	r0, [r4, #20]
 800914a:	4303      	orrs	r3, r0
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 800914c:	4850      	ldr	r0, [pc, #320]	; (8009290 <UART_SetConfig+0x158>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800914e:	4313      	orrs	r3, r2
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8009150:	4001      	ands	r1, r0
 8009152:	430b      	orrs	r3, r1
 8009154:	602b      	str	r3, [r5, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8009156:	686b      	ldr	r3, [r5, #4]
 8009158:	494e      	ldr	r1, [pc, #312]	; (8009294 <UART_SetConfig+0x15c>)
  /* Configure
   * - UART HardWare Flow Control: set CTSE and RTSE bits according
   *   to huart->Init.HwFlowCtl value
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 800915a:	6a20      	ldr	r0, [r4, #32]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800915c:	400b      	ands	r3, r1
 800915e:	68e1      	ldr	r1, [r4, #12]
 8009160:	430b      	orrs	r3, r1
 8009162:	606b      	str	r3, [r5, #4]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 8009164:	69a3      	ldr	r3, [r4, #24]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 8009166:	68a9      	ldr	r1, [r5, #8]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 8009168:	4303      	orrs	r3, r0
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 800916a:	484b      	ldr	r0, [pc, #300]	; (8009298 <UART_SetConfig+0x160>)
 800916c:	4001      	ands	r1, r0
 800916e:	430b      	orrs	r3, r1
 8009170:	60ab      	str	r3, [r5, #8]

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8009172:	4b4a      	ldr	r3, [pc, #296]	; (800929c <UART_SetConfig+0x164>)
 8009174:	429d      	cmp	r5, r3
 8009176:	d113      	bne.n	80091a0 <UART_SetConfig+0x68>
 8009178:	2103      	movs	r1, #3
 800917a:	4b49      	ldr	r3, [pc, #292]	; (80092a0 <UART_SetConfig+0x168>)
 800917c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800917e:	400b      	ands	r3, r1
 8009180:	4948      	ldr	r1, [pc, #288]	; (80092a4 <UART_SetConfig+0x16c>)
 8009182:	5cc8      	ldrb	r0, [r1, r3]
  
  /* Check UART Over Sampling to set Baud Rate Register */
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8009184:	2380      	movs	r3, #128	; 0x80
 8009186:	021b      	lsls	r3, r3, #8
 8009188:	429a      	cmp	r2, r3
 800918a:	d14a      	bne.n	8009222 <UART_SetConfig+0xea>
  {
    switch (clocksource)
 800918c:	2808      	cmp	r0, #8
 800918e:	d900      	bls.n	8009192 <UART_SetConfig+0x5a>
 8009190:	e07b      	b.n	800928a <UART_SetConfig+0x152>
 8009192:	f7fc fc0f 	bl	80059b4 <__gnu_thumb1_case_uqi>
 8009196:	7a40      	.short	0x7a40
 8009198:	7a6e7a25 	.word	0x7a6e7a25
 800919c:	7a7a      	.short	0x7a7a
 800919e:	73          	.byte	0x73
 800919f:	00          	.byte	0x00
 80091a0:	2180      	movs	r1, #128	; 0x80
  UART_GETCLOCKSOURCE(huart, clocksource);
 80091a2:	4b41      	ldr	r3, [pc, #260]	; (80092a8 <UART_SetConfig+0x170>)
 80091a4:	0209      	lsls	r1, r1, #8
 80091a6:	429d      	cmp	r5, r3
 80091a8:	d12d      	bne.n	8009206 <UART_SetConfig+0xce>
 80091aa:	20c0      	movs	r0, #192	; 0xc0
 80091ac:	2680      	movs	r6, #128	; 0x80
 80091ae:	4b3c      	ldr	r3, [pc, #240]	; (80092a0 <UART_SetConfig+0x168>)
 80091b0:	0280      	lsls	r0, r0, #10
 80091b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80091b4:	0276      	lsls	r6, r6, #9
 80091b6:	4003      	ands	r3, r0
 80091b8:	42b3      	cmp	r3, r6
 80091ba:	d058      	beq.n	800926e <UART_SetConfig+0x136>
 80091bc:	000f      	movs	r7, r1
 80091be:	42b3      	cmp	r3, r6
 80091c0:	d806      	bhi.n	80091d0 <UART_SetConfig+0x98>
 80091c2:	2000      	movs	r0, #0
 80091c4:	4283      	cmp	r3, r0
 80091c6:	d0dd      	beq.n	8009184 <UART_SetConfig+0x4c>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80091c8:	42ba      	cmp	r2, r7
 80091ca:	d05e      	beq.n	800928a <UART_SetConfig+0x152>
      case UART_CLOCKSOURCE_LSE:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
        break;
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 80091cc:	2001      	movs	r0, #1
        break;
    }
  }

  return ret;
 80091ce:	e019      	b.n	8009204 <UART_SetConfig+0xcc>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80091d0:	2680      	movs	r6, #128	; 0x80
 80091d2:	02b6      	lsls	r6, r6, #10
 80091d4:	42b3      	cmp	r3, r6
 80091d6:	d04f      	beq.n	8009278 <UART_SetConfig+0x140>
 80091d8:	4283      	cmp	r3, r0
 80091da:	d1f5      	bne.n	80091c8 <UART_SetConfig+0x90>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80091dc:	428a      	cmp	r2, r1
 80091de:	d135      	bne.n	800924c <UART_SetConfig+0x114>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 80091e0:	6863      	ldr	r3, [r4, #4]
 80091e2:	0858      	lsrs	r0, r3, #1
 80091e4:	4b31      	ldr	r3, [pc, #196]	; (80092ac <UART_SetConfig+0x174>)
 80091e6:	18c0      	adds	r0, r0, r3
 80091e8:	6861      	ldr	r1, [r4, #4]
 80091ea:	f7fc fbed 	bl	80059c8 <__udivsi3>
 80091ee:	b283      	uxth	r3, r0
  HAL_StatusTypeDef ret               = HAL_OK;
 80091f0:	2000      	movs	r0, #0
    brrtemp = usartdiv & 0xFFF0U;
 80091f2:	220f      	movs	r2, #15
 80091f4:	0019      	movs	r1, r3
 80091f6:	4391      	bics	r1, r2
 80091f8:	000a      	movs	r2, r1
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 80091fa:	071b      	lsls	r3, r3, #28
    huart->Instance->BRR = brrtemp;
 80091fc:	6821      	ldr	r1, [r4, #0]
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 80091fe:	0f5b      	lsrs	r3, r3, #29
    huart->Instance->BRR = brrtemp;
 8009200:	4313      	orrs	r3, r2
 8009202:	60cb      	str	r3, [r1, #12]

}
 8009204:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 8009206:	4b2a      	ldr	r3, [pc, #168]	; (80092b0 <UART_SetConfig+0x178>)
 8009208:	429d      	cmp	r5, r3
 800920a:	d002      	beq.n	8009212 <UART_SetConfig+0xda>
 800920c:	4b29      	ldr	r3, [pc, #164]	; (80092b4 <UART_SetConfig+0x17c>)
 800920e:	429d      	cmp	r5, r3
 8009210:	d139      	bne.n	8009286 <UART_SetConfig+0x14e>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8009212:	428a      	cmp	r2, r1
 8009214:	d10e      	bne.n	8009234 <UART_SetConfig+0xfc>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8009216:	f7ff f819 	bl	800824c <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800921a:	6863      	ldr	r3, [r4, #4]
 800921c:	0040      	lsls	r0, r0, #1
 800921e:	085b      	lsrs	r3, r3, #1
 8009220:	e7e1      	b.n	80091e6 <UART_SetConfig+0xae>
    switch (clocksource)
 8009222:	2808      	cmp	r0, #8
 8009224:	d8d2      	bhi.n	80091cc <UART_SetConfig+0x94>
 8009226:	f7fc fbbb 	bl	80059a0 <__gnu_thumb1_case_sqi>
 800922a:	d105      	.short	0xd105
 800922c:	d11ad111 	.word	0xd11ad111
 8009230:	d1d1      	.short	0xd1d1
 8009232:	1d          	.byte	0x1d
 8009233:	00          	.byte	0x00
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8009234:	f7ff f80a 	bl	800824c <HAL_RCC_GetPCLK1Freq>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8009238:	6861      	ldr	r1, [r4, #4]
 800923a:	6824      	ldr	r4, [r4, #0]
 800923c:	084b      	lsrs	r3, r1, #1
 800923e:	1818      	adds	r0, r3, r0
 8009240:	f7fc fbc2 	bl	80059c8 <__udivsi3>
 8009244:	b280      	uxth	r0, r0
 8009246:	60e0      	str	r0, [r4, #12]
  HAL_StatusTypeDef ret               = HAL_OK;
 8009248:	2000      	movs	r0, #0
        break;
 800924a:	e7db      	b.n	8009204 <UART_SetConfig+0xcc>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 800924c:	6861      	ldr	r1, [r4, #4]
 800924e:	4b1a      	ldr	r3, [pc, #104]	; (80092b8 <UART_SetConfig+0x180>)
 8009250:	0848      	lsrs	r0, r1, #1
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8009252:	18c0      	adds	r0, r0, r3
 8009254:	f7fc fbb8 	bl	80059c8 <__udivsi3>
 8009258:	b280      	uxth	r0, r0
 800925a:	60e8      	str	r0, [r5, #12]
 800925c:	e7f4      	b.n	8009248 <UART_SetConfig+0x110>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800925e:	f7fe ffad 	bl	80081bc <HAL_RCC_GetSysClockFreq>
 8009262:	e7e9      	b.n	8009238 <UART_SetConfig+0x100>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8009264:	2380      	movs	r3, #128	; 0x80
 8009266:	6861      	ldr	r1, [r4, #4]
 8009268:	021b      	lsls	r3, r3, #8
 800926a:	0848      	lsrs	r0, r1, #1
 800926c:	e7f1      	b.n	8009252 <UART_SetConfig+0x11a>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800926e:	428a      	cmp	r2, r1
 8009270:	d1f5      	bne.n	800925e <UART_SetConfig+0x126>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8009272:	f7fe ffa3 	bl	80081bc <HAL_RCC_GetSysClockFreq>
 8009276:	e7d0      	b.n	800921a <UART_SetConfig+0xe2>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8009278:	428a      	cmp	r2, r1
 800927a:	d1f3      	bne.n	8009264 <UART_SetConfig+0x12c>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 800927c:	6863      	ldr	r3, [r4, #4]
 800927e:	0858      	lsrs	r0, r3, #1
 8009280:	2380      	movs	r3, #128	; 0x80
 8009282:	025b      	lsls	r3, r3, #9
 8009284:	e7af      	b.n	80091e6 <UART_SetConfig+0xae>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8009286:	428a      	cmp	r2, r1
 8009288:	d1a0      	bne.n	80091cc <UART_SetConfig+0x94>
        ret = HAL_ERROR;
 800928a:	2001      	movs	r0, #1
  uint16_t usartdiv                   = 0x0000U;
 800928c:	2300      	movs	r3, #0
 800928e:	e7b0      	b.n	80091f2 <UART_SetConfig+0xba>
 8009290:	efff69f3 	.word	0xefff69f3
 8009294:	ffffcfff 	.word	0xffffcfff
 8009298:	fffff4ff 	.word	0xfffff4ff
 800929c:	40013800 	.word	0x40013800
 80092a0:	40021000 	.word	0x40021000
 80092a4:	0800cc54 	.word	0x0800cc54
 80092a8:	40004400 	.word	0x40004400
 80092ac:	00f42400 	.word	0x00f42400
 80092b0:	40004800 	.word	0x40004800
 80092b4:	40004c00 	.word	0x40004c00
 80092b8:	007a1200 	.word	0x007a1200

080092bc <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80092bc:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
 80092be:	b530      	push	{r4, r5, lr}
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80092c0:	07da      	lsls	r2, r3, #31
 80092c2:	d506      	bpl.n	80092d2 <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80092c4:	6801      	ldr	r1, [r0, #0]
 80092c6:	4c28      	ldr	r4, [pc, #160]	; (8009368 <UART_AdvFeatureConfig+0xac>)
 80092c8:	684a      	ldr	r2, [r1, #4]
 80092ca:	4022      	ands	r2, r4
 80092cc:	6a84      	ldr	r4, [r0, #40]	; 0x28
 80092ce:	4322      	orrs	r2, r4
 80092d0:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 80092d2:	079a      	lsls	r2, r3, #30
 80092d4:	d506      	bpl.n	80092e4 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80092d6:	6801      	ldr	r1, [r0, #0]
 80092d8:	4c24      	ldr	r4, [pc, #144]	; (800936c <UART_AdvFeatureConfig+0xb0>)
 80092da:	684a      	ldr	r2, [r1, #4]
 80092dc:	4022      	ands	r2, r4
 80092de:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80092e0:	4322      	orrs	r2, r4
 80092e2:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 80092e4:	075a      	lsls	r2, r3, #29
 80092e6:	d506      	bpl.n	80092f6 <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 80092e8:	6801      	ldr	r1, [r0, #0]
 80092ea:	4c21      	ldr	r4, [pc, #132]	; (8009370 <UART_AdvFeatureConfig+0xb4>)
 80092ec:	684a      	ldr	r2, [r1, #4]
 80092ee:	4022      	ands	r2, r4
 80092f0:	6b04      	ldr	r4, [r0, #48]	; 0x30
 80092f2:	4322      	orrs	r2, r4
 80092f4:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 80092f6:	071a      	lsls	r2, r3, #28
 80092f8:	d506      	bpl.n	8009308 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 80092fa:	6801      	ldr	r1, [r0, #0]
 80092fc:	4c1d      	ldr	r4, [pc, #116]	; (8009374 <UART_AdvFeatureConfig+0xb8>)
 80092fe:	684a      	ldr	r2, [r1, #4]
 8009300:	4022      	ands	r2, r4
 8009302:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8009304:	4322      	orrs	r2, r4
 8009306:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8009308:	06da      	lsls	r2, r3, #27
 800930a:	d506      	bpl.n	800931a <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800930c:	6801      	ldr	r1, [r0, #0]
 800930e:	4c1a      	ldr	r4, [pc, #104]	; (8009378 <UART_AdvFeatureConfig+0xbc>)
 8009310:	688a      	ldr	r2, [r1, #8]
 8009312:	4022      	ands	r2, r4
 8009314:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8009316:	4322      	orrs	r2, r4
 8009318:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800931a:	069a      	lsls	r2, r3, #26
 800931c:	d506      	bpl.n	800932c <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800931e:	6801      	ldr	r1, [r0, #0]
 8009320:	4c16      	ldr	r4, [pc, #88]	; (800937c <UART_AdvFeatureConfig+0xc0>)
 8009322:	688a      	ldr	r2, [r1, #8]
 8009324:	4022      	ands	r2, r4
 8009326:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 8009328:	4322      	orrs	r2, r4
 800932a:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800932c:	065a      	lsls	r2, r3, #25
 800932e:	d510      	bpl.n	8009352 <UART_AdvFeatureConfig+0x96>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8009330:	6801      	ldr	r1, [r0, #0]
 8009332:	4d13      	ldr	r5, [pc, #76]	; (8009380 <UART_AdvFeatureConfig+0xc4>)
 8009334:	684a      	ldr	r2, [r1, #4]
 8009336:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8009338:	402a      	ands	r2, r5
 800933a:	4322      	orrs	r2, r4
 800933c:	604a      	str	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800933e:	2280      	movs	r2, #128	; 0x80
 8009340:	0352      	lsls	r2, r2, #13
 8009342:	4294      	cmp	r4, r2
 8009344:	d105      	bne.n	8009352 <UART_AdvFeatureConfig+0x96>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8009346:	684a      	ldr	r2, [r1, #4]
 8009348:	4c0e      	ldr	r4, [pc, #56]	; (8009384 <UART_AdvFeatureConfig+0xc8>)
 800934a:	4022      	ands	r2, r4
 800934c:	6c44      	ldr	r4, [r0, #68]	; 0x44
 800934e:	4322      	orrs	r2, r4
 8009350:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8009352:	061b      	lsls	r3, r3, #24
 8009354:	d506      	bpl.n	8009364 <UART_AdvFeatureConfig+0xa8>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8009356:	6802      	ldr	r2, [r0, #0]
 8009358:	490b      	ldr	r1, [pc, #44]	; (8009388 <UART_AdvFeatureConfig+0xcc>)
 800935a:	6853      	ldr	r3, [r2, #4]
 800935c:	400b      	ands	r3, r1
 800935e:	6c81      	ldr	r1, [r0, #72]	; 0x48
 8009360:	430b      	orrs	r3, r1
 8009362:	6053      	str	r3, [r2, #4]
  }
}
 8009364:	bd30      	pop	{r4, r5, pc}
 8009366:	46c0      	nop			; (mov r8, r8)
 8009368:	fffdffff 	.word	0xfffdffff
 800936c:	fffeffff 	.word	0xfffeffff
 8009370:	fffbffff 	.word	0xfffbffff
 8009374:	ffff7fff 	.word	0xffff7fff
 8009378:	ffffefff 	.word	0xffffefff
 800937c:	ffffdfff 	.word	0xffffdfff
 8009380:	ffefffff 	.word	0xffefffff
 8009384:	ff9fffff 	.word	0xff9fffff
 8009388:	fff7ffff 	.word	0xfff7ffff

0800938c <UART_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 800938c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800938e:	0004      	movs	r4, r0
 8009390:	000e      	movs	r6, r1
 8009392:	0015      	movs	r5, r2
 8009394:	001f      	movs	r7, r3
  /* Wait until flag is set */
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8009396:	6822      	ldr	r2, [r4, #0]
 8009398:	69d3      	ldr	r3, [r2, #28]
 800939a:	4033      	ands	r3, r6
 800939c:	1b9b      	subs	r3, r3, r6
 800939e:	4259      	negs	r1, r3
 80093a0:	414b      	adcs	r3, r1
 80093a2:	42ab      	cmp	r3, r5
 80093a4:	d001      	beq.n	80093aa <UART_WaitOnFlagUntilTimeout+0x1e>
        __HAL_UNLOCK(huart);
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 80093a6:	2000      	movs	r0, #0
 80093a8:	e018      	b.n	80093dc <UART_WaitOnFlagUntilTimeout+0x50>
    if(Timeout != HAL_MAX_DELAY)
 80093aa:	9b06      	ldr	r3, [sp, #24]
 80093ac:	3301      	adds	r3, #1
 80093ae:	d0f3      	beq.n	8009398 <UART_WaitOnFlagUntilTimeout+0xc>
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 80093b0:	9b06      	ldr	r3, [sp, #24]
 80093b2:	2b00      	cmp	r3, #0
 80093b4:	d113      	bne.n	80093de <UART_WaitOnFlagUntilTimeout+0x52>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80093b6:	6823      	ldr	r3, [r4, #0]
 80093b8:	490c      	ldr	r1, [pc, #48]	; (80093ec <UART_WaitOnFlagUntilTimeout+0x60>)
 80093ba:	681a      	ldr	r2, [r3, #0]
        __HAL_UNLOCK(huart);
 80093bc:	2003      	movs	r0, #3
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80093be:	400a      	ands	r2, r1
 80093c0:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80093c2:	689a      	ldr	r2, [r3, #8]
 80093c4:	31a3      	adds	r1, #163	; 0xa3
 80093c6:	31ff      	adds	r1, #255	; 0xff
 80093c8:	438a      	bics	r2, r1
 80093ca:	609a      	str	r2, [r3, #8]
        huart->gState  = HAL_UART_STATE_READY;
 80093cc:	0022      	movs	r2, r4
 80093ce:	2320      	movs	r3, #32
 80093d0:	3269      	adds	r2, #105	; 0x69
 80093d2:	7013      	strb	r3, [r2, #0]
        huart->RxState = HAL_UART_STATE_READY;
 80093d4:	7053      	strb	r3, [r2, #1]
        __HAL_UNLOCK(huart);
 80093d6:	2300      	movs	r3, #0
 80093d8:	3468      	adds	r4, #104	; 0x68
 80093da:	7023      	strb	r3, [r4, #0]
}
 80093dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 80093de:	f7fd fe8f 	bl	8007100 <HAL_GetTick>
 80093e2:	9b06      	ldr	r3, [sp, #24]
 80093e4:	1bc0      	subs	r0, r0, r7
 80093e6:	4298      	cmp	r0, r3
 80093e8:	d9d5      	bls.n	8009396 <UART_WaitOnFlagUntilTimeout+0xa>
 80093ea:	e7e4      	b.n	80093b6 <UART_WaitOnFlagUntilTimeout+0x2a>
 80093ec:	fffffe5f 	.word	0xfffffe5f

080093f0 <UART_CheckIdleState>:
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80093f0:	2300      	movs	r3, #0
{
 80093f2:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80093f4:	0004      	movs	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80093f6:	66c3      	str	r3, [r0, #108]	; 0x6c
  tickstart = HAL_GetTick();
 80093f8:	f7fd fe82 	bl	8007100 <HAL_GetTick>
  if (IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance))
 80093fc:	6823      	ldr	r3, [r4, #0]
 80093fe:	4a18      	ldr	r2, [pc, #96]	; (8009460 <UART_CheckIdleState+0x70>)
  tickstart = HAL_GetTick();
 8009400:	0005      	movs	r5, r0
  if (IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance))
 8009402:	4293      	cmp	r3, r2
 8009404:	d00b      	beq.n	800941e <UART_CheckIdleState+0x2e>
 8009406:	4a17      	ldr	r2, [pc, #92]	; (8009464 <UART_CheckIdleState+0x74>)
 8009408:	4293      	cmp	r3, r2
 800940a:	d008      	beq.n	800941e <UART_CheckIdleState+0x2e>
  huart->gState  = HAL_UART_STATE_READY;
 800940c:	0022      	movs	r2, r4
 800940e:	2320      	movs	r3, #32
  __HAL_UNLOCK(huart);
 8009410:	2000      	movs	r0, #0
  huart->gState  = HAL_UART_STATE_READY;
 8009412:	3269      	adds	r2, #105	; 0x69
  __HAL_UNLOCK(huart);
 8009414:	3468      	adds	r4, #104	; 0x68
  huart->gState  = HAL_UART_STATE_READY;
 8009416:	7013      	strb	r3, [r2, #0]
  huart->RxState = HAL_UART_STATE_READY;
 8009418:	7053      	strb	r3, [r2, #1]
  __HAL_UNLOCK(huart);
 800941a:	7020      	strb	r0, [r4, #0]
}
 800941c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800941e:	681b      	ldr	r3, [r3, #0]
 8009420:	071b      	lsls	r3, r3, #28
 8009422:	d40f      	bmi.n	8009444 <UART_CheckIdleState+0x54>
    if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8009424:	6823      	ldr	r3, [r4, #0]
 8009426:	681b      	ldr	r3, [r3, #0]
 8009428:	075b      	lsls	r3, r3, #29
 800942a:	d5ef      	bpl.n	800940c <UART_CheckIdleState+0x1c>
      if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800942c:	2180      	movs	r1, #128	; 0x80
 800942e:	4b0e      	ldr	r3, [pc, #56]	; (8009468 <UART_CheckIdleState+0x78>)
 8009430:	2200      	movs	r2, #0
 8009432:	9300      	str	r3, [sp, #0]
 8009434:	03c9      	lsls	r1, r1, #15
 8009436:	002b      	movs	r3, r5
 8009438:	0020      	movs	r0, r4
 800943a:	f7ff ffa7 	bl	800938c <UART_WaitOnFlagUntilTimeout>
 800943e:	2800      	cmp	r0, #0
 8009440:	d0e4      	beq.n	800940c <UART_CheckIdleState+0x1c>
 8009442:	e00a      	b.n	800945a <UART_CheckIdleState+0x6a>
      if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8009444:	2180      	movs	r1, #128	; 0x80
 8009446:	4b08      	ldr	r3, [pc, #32]	; (8009468 <UART_CheckIdleState+0x78>)
 8009448:	2200      	movs	r2, #0
 800944a:	9300      	str	r3, [sp, #0]
 800944c:	0389      	lsls	r1, r1, #14
 800944e:	002b      	movs	r3, r5
 8009450:	0020      	movs	r0, r4
 8009452:	f7ff ff9b 	bl	800938c <UART_WaitOnFlagUntilTimeout>
 8009456:	2800      	cmp	r0, #0
 8009458:	d0e4      	beq.n	8009424 <UART_CheckIdleState+0x34>
        return HAL_TIMEOUT;
 800945a:	2003      	movs	r0, #3
 800945c:	e7de      	b.n	800941c <UART_CheckIdleState+0x2c>
 800945e:	46c0      	nop			; (mov r8, r8)
 8009460:	40013800 	.word	0x40013800
 8009464:	40004400 	.word	0x40004400
 8009468:	01ffffff 	.word	0x01ffffff

0800946c <HAL_UART_Init>:
{
 800946c:	b570      	push	{r4, r5, r6, lr}
 800946e:	1e04      	subs	r4, r0, #0
  if(huart == NULL)
 8009470:	d101      	bne.n	8009476 <HAL_UART_Init+0xa>
    return HAL_ERROR;
 8009472:	2001      	movs	r0, #1
}
 8009474:	bd70      	pop	{r4, r5, r6, pc}
  if(huart->gState == HAL_UART_STATE_RESET)
 8009476:	0005      	movs	r5, r0
 8009478:	3569      	adds	r5, #105	; 0x69
 800947a:	782b      	ldrb	r3, [r5, #0]
 800947c:	b2db      	uxtb	r3, r3
 800947e:	2b00      	cmp	r3, #0
 8009480:	d104      	bne.n	800948c <HAL_UART_Init+0x20>
    huart->Lock = HAL_UNLOCKED;
 8009482:	0002      	movs	r2, r0
 8009484:	3268      	adds	r2, #104	; 0x68
 8009486:	7013      	strb	r3, [r2, #0]
    HAL_UART_MspInit(huart);
 8009488:	f7fd fdb8 	bl	8006ffc <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 800948c:	2324      	movs	r3, #36	; 0x24
  __HAL_UART_DISABLE(huart);
 800948e:	2101      	movs	r1, #1
 8009490:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8009492:	702b      	strb	r3, [r5, #0]
  __HAL_UART_DISABLE(huart);
 8009494:	6813      	ldr	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8009496:	0020      	movs	r0, r4
  __HAL_UART_DISABLE(huart);
 8009498:	438b      	bics	r3, r1
 800949a:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 800949c:	f7ff fe4c 	bl	8009138 <UART_SetConfig>
 80094a0:	2801      	cmp	r0, #1
 80094a2:	d0e6      	beq.n	8009472 <HAL_UART_Init+0x6>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80094a4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80094a6:	2b00      	cmp	r3, #0
 80094a8:	d002      	beq.n	80094b0 <HAL_UART_Init+0x44>
    UART_AdvFeatureConfig(huart);
 80094aa:	0020      	movs	r0, r4
 80094ac:	f7ff ff06 	bl	80092bc <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80094b0:	6823      	ldr	r3, [r4, #0]
 80094b2:	4908      	ldr	r1, [pc, #32]	; (80094d4 <HAL_UART_Init+0x68>)
 80094b4:	685a      	ldr	r2, [r3, #4]
  return (UART_CheckIdleState(huart));
 80094b6:	0020      	movs	r0, r4
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80094b8:	400a      	ands	r2, r1
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80094ba:	212a      	movs	r1, #42	; 0x2a
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80094bc:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80094be:	689a      	ldr	r2, [r3, #8]
 80094c0:	438a      	bics	r2, r1
 80094c2:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 80094c4:	2201      	movs	r2, #1
 80094c6:	6819      	ldr	r1, [r3, #0]
 80094c8:	430a      	orrs	r2, r1
 80094ca:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 80094cc:	f7ff ff90 	bl	80093f0 <UART_CheckIdleState>
 80094d0:	e7d0      	b.n	8009474 <HAL_UART_Init+0x8>
 80094d2:	46c0      	nop			; (mov r8, r8)
 80094d4:	ffffb7ff 	.word	0xffffb7ff

080094d8 <LL_EXTI_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: EXTI registers are initialized
  *          - ERROR: not applicable
  */
uint32_t LL_EXTI_Init(LL_EXTI_InitTypeDef *EXTI_InitStruct)
{
 80094d8:	b510      	push	{r4, lr}
  assert_param(IS_LL_EXTI_LINE_0_31(EXTI_InitStruct->Line_0_31));
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->LineCommand));
  assert_param(IS_LL_EXTI_MODE(EXTI_InitStruct->Mode));

  /* ENABLE LineCommand */
  if (EXTI_InitStruct->LineCommand != DISABLE)
 80094da:	7902      	ldrb	r2, [r0, #4]
 80094dc:	6803      	ldr	r3, [r0, #0]
 80094de:	2a00      	cmp	r2, #0
 80094e0:	d03c      	beq.n	800955c <LL_EXTI_Init+0x84>
  ErrorStatus status = SUCCESS;
 80094e2:	2201      	movs	r2, #1
  {
    assert_param(IS_LL_EXTI_TRIGGER(EXTI_InitStruct->Trigger));

    /* Configure EXTI Lines in range from 0 to 31 */
    if (EXTI_InitStruct->Line_0_31 != LL_EXTI_LINE_NONE)
 80094e4:	2b00      	cmp	r3, #0
 80094e6:	d01f      	beq.n	8009528 <LL_EXTI_Init+0x50>
    {
      switch (EXTI_InitStruct->Mode)
 80094e8:	7941      	ldrb	r1, [r0, #5]
 80094ea:	4291      	cmp	r1, r2
 80094ec:	d01e      	beq.n	800952c <LL_EXTI_Init+0x54>
 80094ee:	2900      	cmp	r1, #0
 80094f0:	d003      	beq.n	80094fa <LL_EXTI_Init+0x22>
 80094f2:	2902      	cmp	r1, #2
 80094f4:	d022      	beq.n	800953c <LL_EXTI_Init+0x64>
          /* Directly Enable IT & Event on provided Lines */
          LL_EXTI_EnableIT_0_31(EXTI_InitStruct->Line_0_31);
          LL_EXTI_EnableEvent_0_31(EXTI_InitStruct->Line_0_31);
          break;
        default:
          status = ERROR;
 80094f6:	2200      	movs	r2, #0
 80094f8:	e006      	b.n	8009508 <LL_EXTI_Init+0x30>
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableEvent_0_31(uint32_t ExtiLine)
{
  CLEAR_BIT(EXTI->EMR, ExtiLine);
 80094fa:	491e      	ldr	r1, [pc, #120]	; (8009574 <LL_EXTI_Init+0x9c>)
 80094fc:	684c      	ldr	r4, [r1, #4]
 80094fe:	439c      	bics	r4, r3
 8009500:	604c      	str	r4, [r1, #4]
  SET_BIT(EXTI->IMR, ExtiLine);
 8009502:	680c      	ldr	r4, [r1, #0]
 8009504:	431c      	orrs	r4, r3
 8009506:	600c      	str	r4, [r1, #0]
          break;
      }
      if (EXTI_InitStruct->Trigger != LL_EXTI_TRIGGER_NONE)
 8009508:	7981      	ldrb	r1, [r0, #6]
 800950a:	2900      	cmp	r1, #0
 800950c:	d00c      	beq.n	8009528 <LL_EXTI_Init+0x50>
      {
        switch (EXTI_InitStruct->Trigger)
 800950e:	2902      	cmp	r1, #2
 8009510:	d018      	beq.n	8009544 <LL_EXTI_Init+0x6c>
 8009512:	2903      	cmp	r1, #3
 8009514:	d01e      	beq.n	8009554 <LL_EXTI_Init+0x7c>
 8009516:	2901      	cmp	r1, #1
 8009518:	d12a      	bne.n	8009570 <LL_EXTI_Init+0x98>
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableFallingTrig_0_31(uint32_t ExtiLine)
{
  CLEAR_BIT(EXTI->FTSR, ExtiLine);
 800951a:	4916      	ldr	r1, [pc, #88]	; (8009574 <LL_EXTI_Init+0x9c>)
 800951c:	68c8      	ldr	r0, [r1, #12]
 800951e:	4398      	bics	r0, r3
 8009520:	60c8      	str	r0, [r1, #12]
  SET_BIT(EXTI->RTSR, ExtiLine);
 8009522:	6888      	ldr	r0, [r1, #8]
 8009524:	4303      	orrs	r3, r0
 8009526:	608b      	str	r3, [r1, #8]
    /* De-configure EXTI Lines in range from 0 to 31 */
    LL_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);
    LL_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);
  }
  return status;
}
 8009528:	0010      	movs	r0, r2
 800952a:	bd10      	pop	{r4, pc}
  CLEAR_BIT(EXTI->IMR, ExtiLine);
 800952c:	4911      	ldr	r1, [pc, #68]	; (8009574 <LL_EXTI_Init+0x9c>)
 800952e:	680c      	ldr	r4, [r1, #0]
 8009530:	439c      	bics	r4, r3
  SET_BIT(EXTI->IMR, ExtiLine);
 8009532:	600c      	str	r4, [r1, #0]
  SET_BIT(EXTI->EMR, ExtiLine);
 8009534:	684c      	ldr	r4, [r1, #4]
 8009536:	431c      	orrs	r4, r3
 8009538:	604c      	str	r4, [r1, #4]
 800953a:	e7e5      	b.n	8009508 <LL_EXTI_Init+0x30>
  SET_BIT(EXTI->IMR, ExtiLine);
 800953c:	490d      	ldr	r1, [pc, #52]	; (8009574 <LL_EXTI_Init+0x9c>)
 800953e:	680c      	ldr	r4, [r1, #0]
 8009540:	431c      	orrs	r4, r3
 8009542:	e7f6      	b.n	8009532 <LL_EXTI_Init+0x5a>
  CLEAR_BIT(EXTI->RTSR, ExtiLine);
 8009544:	490b      	ldr	r1, [pc, #44]	; (8009574 <LL_EXTI_Init+0x9c>)
 8009546:	6888      	ldr	r0, [r1, #8]
 8009548:	4398      	bics	r0, r3
  SET_BIT(EXTI->RTSR, ExtiLine);
 800954a:	6088      	str	r0, [r1, #8]
  SET_BIT(EXTI->FTSR, ExtiLine);
 800954c:	68c8      	ldr	r0, [r1, #12]
 800954e:	4303      	orrs	r3, r0
 8009550:	60cb      	str	r3, [r1, #12]
 8009552:	e7e9      	b.n	8009528 <LL_EXTI_Init+0x50>
  SET_BIT(EXTI->RTSR, ExtiLine);
 8009554:	4907      	ldr	r1, [pc, #28]	; (8009574 <LL_EXTI_Init+0x9c>)
 8009556:	6888      	ldr	r0, [r1, #8]
 8009558:	4318      	orrs	r0, r3
 800955a:	e7f6      	b.n	800954a <LL_EXTI_Init+0x72>
  CLEAR_BIT(EXTI->IMR, ExtiLine);
 800955c:	43db      	mvns	r3, r3
 800955e:	4a05      	ldr	r2, [pc, #20]	; (8009574 <LL_EXTI_Init+0x9c>)
 8009560:	6811      	ldr	r1, [r2, #0]
 8009562:	4019      	ands	r1, r3
 8009564:	6011      	str	r1, [r2, #0]
  CLEAR_BIT(EXTI->EMR, ExtiLine);
 8009566:	6851      	ldr	r1, [r2, #4]
 8009568:	400b      	ands	r3, r1
 800956a:	6053      	str	r3, [r2, #4]
  ErrorStatus status = SUCCESS;
 800956c:	2201      	movs	r2, #1
 800956e:	e7db      	b.n	8009528 <LL_EXTI_Init+0x50>
            status = ERROR;
 8009570:	2200      	movs	r2, #0
 8009572:	e7d9      	b.n	8009528 <LL_EXTI_Init+0x50>
 8009574:	40010400 	.word	0x40010400

08009578 <LL_Init1msTick>:
  * @retval None
  */
__STATIC_INLINE void LL_InitTick(uint32_t HCLKFrequency, uint32_t Ticks)
{
  /* Configure the SysTick to have interrupt in 1ms time base */
  SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
 8009578:	21fa      	movs	r1, #250	; 0xfa
  * @param  HCLKFrequency HCLK frequency in Hz
  * @note   HCLK frequency can be calculated thanks to RCC helper macro or function @ref LL_RCC_GetSystemClocksFreq
  * @retval None
  */
void LL_Init1msTick(uint32_t HCLKFrequency)
{
 800957a:	b510      	push	{r4, lr}
 800957c:	0089      	lsls	r1, r1, #2
 800957e:	f7fc fa23 	bl	80059c8 <__udivsi3>
  SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
 8009582:	2200      	movs	r2, #0
  SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
 8009584:	4b03      	ldr	r3, [pc, #12]	; (8009594 <LL_Init1msTick+0x1c>)
 8009586:	3801      	subs	r0, #1
 8009588:	6058      	str	r0, [r3, #4]
  SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
 800958a:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800958c:	3205      	adds	r2, #5
 800958e:	601a      	str	r2, [r3, #0]
  /* Use frequency provided in argument */
  LL_InitTick(HCLKFrequency, 1000U);
}
 8009590:	bd10      	pop	{r4, pc}
 8009592:	46c0      	nop			; (mov r8, r8)
 8009594:	e000e010 	.word	0xe000e010

08009598 <LL_SetSystemCoreClock>:
  * @retval None
  */
void LL_SetSystemCoreClock(uint32_t HCLKFrequency)
{
  /* HCLK clock frequency */
  SystemCoreClock = HCLKFrequency;
 8009598:	4b01      	ldr	r3, [pc, #4]	; (80095a0 <LL_SetSystemCoreClock+0x8>)
 800959a:	6018      	str	r0, [r3, #0]
}
 800959c:	4770      	bx	lr
 800959e:	46c0      	nop			; (mov r8, r8)
 80095a0:	20000030 	.word	0x20000030

080095a4 <USBPD_PE_TaskWakeUp>:
  * @retval None
  */
static void USBPD_PE_TaskWakeUp(uint8_t PortNum)
{
#ifdef _RTOS
  osMessagePut(PEQueueId[PortNum], 0xFFFF, osWaitForever);
 80095a4:	2201      	movs	r2, #1
{
 80095a6:	b510      	push	{r4, lr}
  osMessagePut(PEQueueId[PortNum], 0xFFFF, osWaitForever);
 80095a8:	4b03      	ldr	r3, [pc, #12]	; (80095b8 <USBPD_PE_TaskWakeUp+0x14>)
 80095aa:	0080      	lsls	r0, r0, #2
 80095ac:	4252      	negs	r2, r2
 80095ae:	4903      	ldr	r1, [pc, #12]	; (80095bc <USBPD_PE_TaskWakeUp+0x18>)
 80095b0:	58c0      	ldr	r0, [r0, r3]
 80095b2:	f002 f9c7 	bl	800b944 <osMessagePut>
#endif
}
 80095b6:	bd10      	pop	{r4, pc}
 80095b8:	20000344 	.word	0x20000344
 80095bc:	0000ffff 	.word	0x0000ffff

080095c0 <USBPD_DPM_CADTaskWakeUp>:
  * @retval None
  */
static void USBPD_DPM_CADTaskWakeUp(void)
{
#ifdef _RTOS
  osMessagePut(CADQueueId, 0xFFFF, osWaitForever);
 80095c0:	2201      	movs	r2, #1
{
 80095c2:	b510      	push	{r4, lr}
  osMessagePut(CADQueueId, 0xFFFF, osWaitForever);
 80095c4:	4b03      	ldr	r3, [pc, #12]	; (80095d4 <USBPD_DPM_CADTaskWakeUp+0x14>)
 80095c6:	4252      	negs	r2, r2
 80095c8:	4903      	ldr	r1, [pc, #12]	; (80095d8 <USBPD_DPM_CADTaskWakeUp+0x18>)
 80095ca:	6858      	ldr	r0, [r3, #4]
 80095cc:	f002 f9ba 	bl	800b944 <osMessagePut>
#endif
}
 80095d0:	bd10      	pop	{r4, pc}
 80095d2:	46c0      	nop			; (mov r8, r8)
 80095d4:	20000344 	.word	0x20000344
 80095d8:	0000ffff 	.word	0x0000ffff

080095dc <USBPD_PE_Task>:
  * @brief  Main task for PE layer
  * @param  argument Not used
  * @retval None
  */
void USBPD_PE_Task(void const *argument)
{
 80095dc:	b530      	push	{r4, r5, lr}
#elif defined(_SRC)
    USBPD_PE_StateMachine_SRC(_port);
#elif defined(_SNK)
    USBPD_PE_StateMachine_SNK(_port);
#endif
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 80095de:	b2c4      	uxtb	r4, r0
{
 80095e0:	b085      	sub	sp, #20
  uint8_t _port = (uint32_t)argument;
 80095e2:	b2c5      	uxtb	r5, r0
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 80095e4:	00a4      	lsls	r4, r4, #2
    USBPD_PE_StateMachine_SRC(_port);
 80095e6:	0028      	movs	r0, r5
 80095e8:	f7f6 ff90 	bl	800050c <USBPD_PE_StateMachine_SRC>
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 80095ec:	4b03      	ldr	r3, [pc, #12]	; (80095fc <USBPD_PE_Task+0x20>)
    USBPD_PE_StateMachine_SRC(_port);
 80095ee:	0002      	movs	r2, r0
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 80095f0:	58e1      	ldr	r1, [r4, r3]
 80095f2:	4668      	mov	r0, sp
 80095f4:	f002 f9cc 	bl	800b990 <osMessageGet>
 80095f8:	e7f5      	b.n	80095e6 <USBPD_PE_Task+0xa>
 80095fa:	46c0      	nop			; (mov r8, r8)
 80095fc:	20000344 	.word	0x20000344

08009600 <USBPD_CAD_Task>:
  * @brief  Main task for CAD layer
  * @param  argument Not used
  * @retval None
  */
void USBPD_CAD_Task(void const *argument)
{
 8009600:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  for(;;)
  {
    DPM_Sleep_time[USBPD_THREAD_CAD] = USBPD_CAD_Process();
 8009602:	f7f6 fdc3 	bl	800018c <USBPD_CAD_Process>
    osMessageGet(CADQueueId, DPM_Sleep_time[USBPD_THREAD_CAD]);
 8009606:	4b03      	ldr	r3, [pc, #12]	; (8009614 <USBPD_CAD_Task+0x14>)
    DPM_Sleep_time[USBPD_THREAD_CAD] = USBPD_CAD_Process();
 8009608:	0002      	movs	r2, r0
    osMessageGet(CADQueueId, DPM_Sleep_time[USBPD_THREAD_CAD]);
 800960a:	6859      	ldr	r1, [r3, #4]
 800960c:	4668      	mov	r0, sp
 800960e:	f002 f9bf 	bl	800b990 <osMessageGet>
 8009612:	e7f6      	b.n	8009602 <USBPD_CAD_Task+0x2>
 8009614:	20000344 	.word	0x20000344

08009618 <USBPD_DPM_CADCallback>:
  * @param  State     CAD state
  * @param  Cc        The Communication Channel for the USBPD communication
  * @retval None
  */
void USBPD_DPM_CADCallback(uint8_t PortNum, USBPD_CAD_EVENT State, CCxPin_TypeDef Cc)
{
 8009618:	b570      	push	{r4, r5, r6, lr}
 800961a:	0004      	movs	r4, r0
#ifdef _TRACE
  USBPD_TRACE_Add(USBPD_TRACE_CADEVENT, PortNum, State, NULL, 0);
#endif /* _TRACE */

  switch(State)
 800961c:	1e48      	subs	r0, r1, #1
{
 800961e:	000d      	movs	r5, r1
  switch(State)
 8009620:	2806      	cmp	r0, #6
 8009622:	d827      	bhi.n	8009674 <USBPD_DPM_CADCallback+0x5c>
 8009624:	f7fc f9c6 	bl	80059b4 <__gnu_thumb1_case_uqi>
 8009628:	04280428 	.word	0x04280428
 800962c:	2626      	.short	0x2626
 800962e:	42          	.byte	0x42
 800962f:	00          	.byte	0x00
  case USBPD_CAD_EVENT_ATTACHED :
#ifdef _VCONN_SUPPORT
    if(CC1 == Cc) DPM_Params[PortNum].VconnCCIs = CC2;
    if(CC2 == Cc) DPM_Params[PortNum].VconnCCIs = CC1;
#endif /* _VCONN_SUPPORT */
    DPM_Params[PortNum].ActiveCCIs = Cc;
 8009630:	2003      	movs	r0, #3
 8009632:	4928      	ldr	r1, [pc, #160]	; (80096d4 <USBPD_DPM_CADCallback+0xbc>)
 8009634:	00e3      	lsls	r3, r4, #3
 8009636:	18c9      	adds	r1, r1, r3
 8009638:	784b      	ldrb	r3, [r1, #1]
 800963a:	4002      	ands	r2, r0
 800963c:	4383      	bics	r3, r0
 800963e:	431a      	orrs	r2, r3
 8009640:	704a      	strb	r2, [r1, #1]
    USBPD_PE_IsCableConnected(PortNum, 1);
 8009642:	0020      	movs	r0, r4
 8009644:	2101      	movs	r1, #1
 8009646:	f7f6 ff38 	bl	80004ba <USBPD_PE_IsCableConnected>

    USBPD_DPM_UserCableDetection(PortNum, State);
 800964a:	0029      	movs	r1, r5
 800964c:	0020      	movs	r0, r4
 800964e:	f7fc fd87 	bl	8006160 <USBPD_DPM_UserCableDetection>
    USBPD_DPM_WaitForTime(6);
#endif /* USBPD_TCPM_MODULE_ENABLED */

#ifdef _RTOS
    /* Create PE task */
    if (DPM_Thread_Table[PortNum] == NULL)
 8009652:	4d21      	ldr	r5, [pc, #132]	; (80096d8 <USBPD_DPM_CADCallback+0xc0>)
 8009654:	00a6      	lsls	r6, r4, #2
 8009656:	19ab      	adds	r3, r5, r6
 8009658:	689b      	ldr	r3, [r3, #8]
 800965a:	2b00      	cmp	r3, #0
 800965c:	d10a      	bne.n	8009674 <USBPD_DPM_CADCallback+0x5c>
 800965e:	481f      	ldr	r0, [pc, #124]	; (80096dc <USBPD_DPM_CADCallback+0xc4>)
    {
      DPM_Thread_Table[PortNum] = osThreadCreate(OSTHREAD_PE(PortNum), (void *)((uint32_t)PortNum));
 8009660:	2c00      	cmp	r4, #0
 8009662:	d000      	beq.n	8009666 <USBPD_DPM_CADCallback+0x4e>
 8009664:	3014      	adds	r0, #20
 8009666:	0021      	movs	r1, r4
 8009668:	f002 f93f 	bl	800b8ea <osThreadCreate>
      if (DPM_Thread_Table[PortNum] == NULL)
 800966c:	2800      	cmp	r0, #0
 800966e:	d002      	beq.n	8009676 <USBPD_DPM_CADCallback+0x5e>
      DPM_Thread_Table[PortNum] = osThreadCreate(OSTHREAD_PE(PortNum), (void *)((uint32_t)PortNum));
 8009670:	19ad      	adds	r5, r5, r6
 8009672:	60a8      	str	r0, [r5, #8]
    break;
  default :
    /* nothing to do */
    break;
  }
}
 8009674:	bd70      	pop	{r4, r5, r6, pc}
 8009676:	e7fe      	b.n	8009676 <USBPD_DPM_CADCallback+0x5e>
    USBPD_PE_IsCableConnected(PortNum, 0);
 8009678:	2100      	movs	r1, #0
 800967a:	0020      	movs	r0, r4
 800967c:	f7f6 ff1d 	bl	80004ba <USBPD_PE_IsCableConnected>
    if (DPM_Thread_Table[PortNum] != NULL)
 8009680:	4e15      	ldr	r6, [pc, #84]	; (80096d8 <USBPD_DPM_CADCallback+0xc0>)
 8009682:	00a3      	lsls	r3, r4, #2
 8009684:	18f6      	adds	r6, r6, r3
 8009686:	68b0      	ldr	r0, [r6, #8]
 8009688:	2800      	cmp	r0, #0
 800968a:	d003      	beq.n	8009694 <USBPD_DPM_CADCallback+0x7c>
      osThreadTerminate(DPM_Thread_Table[PortNum]);
 800968c:	f002 f946 	bl	800b91c <osThreadTerminate>
      DPM_Thread_Table[PortNum] = NULL;
 8009690:	2300      	movs	r3, #0
 8009692:	60b3      	str	r3, [r6, #8]
    USBPD_DPM_UserCableDetection(PortNum, State);
 8009694:	0020      	movs	r0, r4
 8009696:	0029      	movs	r1, r5
 8009698:	f7fc fd62 	bl	8006160 <USBPD_DPM_UserCableDetection>
    DPM_Params[PortNum].PE_Power   = USBPD_POWER_NO;
 800969c:	228c      	movs	r2, #140	; 0x8c
    DPM_Params[PortNum].ActiveCCIs = CCNONE;
 800969e:	4b0d      	ldr	r3, [pc, #52]	; (80096d4 <USBPD_DPM_CADCallback+0xbc>)
 80096a0:	00e4      	lsls	r4, r4, #3
 80096a2:	191c      	adds	r4, r3, r4
 80096a4:	7863      	ldrb	r3, [r4, #1]
    DPM_Params[PortNum].PE_Power   = USBPD_POWER_NO;
 80096a6:	4013      	ands	r3, r2
 80096a8:	7063      	strb	r3, [r4, #1]
    break;
 80096aa:	e7e3      	b.n	8009674 <USBPD_DPM_CADCallback+0x5c>
    DPM_Params[PortNum].ActiveCCIs  = Cc;
 80096ac:	4909      	ldr	r1, [pc, #36]	; (80096d4 <USBPD_DPM_CADCallback+0xbc>)
 80096ae:	00e3      	lsls	r3, r4, #3
 80096b0:	18c9      	adds	r1, r1, r3
 80096b2:	2003      	movs	r0, #3
 80096b4:	0013      	movs	r3, r2
 80096b6:	784a      	ldrb	r2, [r1, #1]
 80096b8:	4003      	ands	r3, r0
 80096ba:	4382      	bics	r2, r0
    DPM_Params[PortNum].PE_Power    = USBPD_POWER_DEFAULT5V;
 80096bc:	431a      	orrs	r2, r3
 80096be:	2370      	movs	r3, #112	; 0x70
 80096c0:	439a      	bics	r2, r3
 80096c2:	3b60      	subs	r3, #96	; 0x60
 80096c4:	431a      	orrs	r2, r3
 80096c6:	704a      	strb	r2, [r1, #1]
    USBPD_DPM_UserCableDetection(PortNum, State);
 80096c8:	0020      	movs	r0, r4
 80096ca:	2107      	movs	r1, #7
 80096cc:	f7fc fd48 	bl	8006160 <USBPD_DPM_UserCableDetection>
}
 80096d0:	e7d0      	b.n	8009674 <USBPD_DPM_CADCallback+0x5c>
 80096d2:	46c0      	nop			; (mov r8, r8)
 80096d4:	20001c60 	.word	0x20001c60
 80096d8:	20000344 	.word	0x20000344
 80096dc:	0800cc58 	.word	0x0800cc58

080096e0 <USBPD_DPM_Init>:
{
 80096e0:	b5f0      	push	{r4, r5, r6, r7, lr}
  if( USBPD_TRUE != USBPD_PE_CheckLIB(_LIB_ID))
 80096e2:	482e      	ldr	r0, [pc, #184]	; (800979c <USBPD_DPM_Init+0xbc>)
{
 80096e4:	b089      	sub	sp, #36	; 0x24
  if( USBPD_TRUE != USBPD_PE_CheckLIB(_LIB_ID))
 80096e6:	f7f6 fe57 	bl	8000398 <USBPD_PE_CheckLIB>
 80096ea:	9001      	str	r0, [sp, #4]
 80096ec:	2801      	cmp	r0, #1
 80096ee:	d003      	beq.n	80096f8 <USBPD_DPM_Init+0x18>
    return USBPD_ERROR;
 80096f0:	2602      	movs	r6, #2
}
 80096f2:	0030      	movs	r0, r6
 80096f4:	b009      	add	sp, #36	; 0x24
 80096f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  stack_dynamemsize = USBPD_PE_GetMemoryConsumption();
 80096f8:	f7f6 fe55 	bl	80003a6 <USBPD_PE_GetMemoryConsumption>
  DPM_Params[USBPD_PORT_0].PE_SpecRevision  = DPM_Settings[USBPD_PORT_0].PE_SpecRevision;
 80096fc:	2203      	movs	r2, #3
  DPM_Params[USBPD_PORT_0].PE_PowerRole     = DPM_Settings[USBPD_PORT_0].PE_DefaultRole;
 80096fe:	2302      	movs	r3, #2
  DPM_Params[USBPD_PORT_0].DPM_Initialized = USBPD_FALSE;
 8009700:	4c27      	ldr	r4, [pc, #156]	; (80097a0 <USBPD_DPM_Init+0xc0>)
 8009702:	2504      	movs	r5, #4
  DPM_Params[USBPD_PORT_0].PE_SpecRevision  = DPM_Settings[USBPD_PORT_0].PE_SpecRevision;
 8009704:	7820      	ldrb	r0, [r4, #0]
  DPM_Params[USBPD_PORT_0].DPM_Initialized = USBPD_FALSE;
 8009706:	7861      	ldrb	r1, [r4, #1]
  DPM_Params[USBPD_PORT_0].PE_SpecRevision  = DPM_Settings[USBPD_PORT_0].PE_SpecRevision;
 8009708:	4390      	bics	r0, r2
  DPM_Params[USBPD_PORT_0].PE_PowerRole     = DPM_Settings[USBPD_PORT_0].PE_DefaultRole;
 800970a:	4303      	orrs	r3, r0
  DPM_Params[USBPD_PORT_0].PE_SwapOngoing   = 0;
 800970c:	2010      	movs	r0, #16
 800970e:	432b      	orrs	r3, r5
 8009710:	4383      	bics	r3, r0
 8009712:	7023      	strb	r3, [r4, #0]
  DPM_Params[USBPD_PORT_0].ActiveCCIs       = CCNONE;
 8009714:	000b      	movs	r3, r1
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 8009716:	4e23      	ldr	r6, [pc, #140]	; (80097a4 <USBPD_DPM_Init+0xc4>)
  DPM_Params[USBPD_PORT_0].ActiveCCIs       = CCNONE;
 8009718:	43ab      	bics	r3, r5
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 800971a:	0037      	movs	r7, r6
 800971c:	0031      	movs	r1, r6
  DPM_Params[USBPD_PORT_0].ActiveCCIs       = CCNONE;
 800971e:	4393      	bics	r3, r2
 8009720:	7063      	strb	r3, [r4, #1]
  DPM_Params[USBPD_PORT_0].VconnCCIs        = CCNONE;
 8009722:	78a3      	ldrb	r3, [r4, #2]
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 8009724:	3728      	adds	r7, #40	; 0x28
  DPM_Params[USBPD_PORT_0].VconnStatus      = USBPD_FALSE;
 8009726:	4393      	bics	r3, r2
 8009728:	43ab      	bics	r3, r5
 800972a:	70a3      	strb	r3, [r4, #2]
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 800972c:	3134      	adds	r1, #52	; 0x34
 800972e:	0023      	movs	r3, r4
 8009730:	003a      	movs	r2, r7
 8009732:	2000      	movs	r0, #0
 8009734:	f7f6 fce8 	bl	8000108 <USBPD_CAD_Init>
 8009738:	2800      	cmp	r0, #0
 800973a:	d1d9      	bne.n	80096f0 <USBPD_DPM_Init+0x10>
  CHECK_PE_FUNCTION_CALL(USBPD_PE_Init(USBPD_PORT_0, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0], &dpmCallbacks));
 800973c:	0033      	movs	r3, r6
 800973e:	0022      	movs	r2, r4
 8009740:	333c      	adds	r3, #60	; 0x3c
 8009742:	0039      	movs	r1, r7
 8009744:	f7f6 fd90 	bl	8000268 <USBPD_PE_Init>
 8009748:	1e06      	subs	r6, r0, #0
 800974a:	d1d1      	bne.n	80096f0 <USBPD_DPM_Init+0x10>
  DPM_Params[USBPD_PORT_0].DPM_Initialized = USBPD_TRUE;
 800974c:	7863      	ldrb	r3, [r4, #1]
 800974e:	431d      	orrs	r5, r3
 8009750:	7065      	strb	r5, [r4, #1]
  USBPD_DPM_UserInit();
 8009752:	f7fc fcbb 	bl	80060cc <USBPD_DPM_UserInit>
  USBPD_CAD_PortEnable(USBPD_PORT_0, USBPD_CAD_ENABLE);
 8009756:	9901      	ldr	r1, [sp, #4]
 8009758:	0030      	movs	r0, r6
 800975a:	f7f6 fd0f 	bl	800017c <USBPD_CAD_PortEnable>
  osThreadDef(CAD, USBPD_CAD_Task, osPriorityNormal, 0, 150);
 800975e:	4c12      	ldr	r4, [pc, #72]	; (80097a8 <USBPD_DPM_Init+0xc8>)
 8009760:	a803      	add	r0, sp, #12
 8009762:	0003      	movs	r3, r0
 8009764:	0022      	movs	r2, r4
 8009766:	caa2      	ldmia	r2!, {r1, r5, r7}
 8009768:	c3a2      	stmia	r3!, {r1, r5, r7}
 800976a:	ca22      	ldmia	r2!, {r1, r5}
 800976c:	c322      	stmia	r3!, {r1, r5}
  if((DPM_Thread_Table[USBPD_THREAD_CAD] = osThreadCreate(osThread(CAD), NULL)) == NULL)
 800976e:	0031      	movs	r1, r6
 8009770:	f002 f8bb 	bl	800b8ea <osThreadCreate>
 8009774:	4d0d      	ldr	r5, [pc, #52]	; (80097ac <USBPD_DPM_Init+0xcc>)
 8009776:	60e8      	str	r0, [r5, #12]
 8009778:	2800      	cmp	r0, #0
 800977a:	d0b9      	beq.n	80096f0 <USBPD_DPM_Init+0x10>
  CADQueueId = osMessageCreate(osMessageQ(queueCAD), NULL);
 800977c:	0020      	movs	r0, r4
 800977e:	0031      	movs	r1, r6
 8009780:	3014      	adds	r0, #20
 8009782:	f002 f8d8 	bl	800b936 <osMessageCreate>
 8009786:	6068      	str	r0, [r5, #4]
  PEQueueId[0] = osMessageCreate(osMessageQ(queuePE), NULL);
 8009788:	0020      	movs	r0, r4
 800978a:	0031      	movs	r1, r6
 800978c:	301c      	adds	r0, #28
 800978e:	f002 f8d2 	bl	800b936 <osMessageCreate>
  DPM_Thread_Table[USBPD_THREAD_PORT_0] = NULL;
 8009792:	60ae      	str	r6, [r5, #8]
  PEQueueId[0] = osMessageCreate(osMessageQ(queuePE), NULL);
 8009794:	6028      	str	r0, [r5, #0]
  osKernelStart();
 8009796:	f002 f8a3 	bl	800b8e0 <osKernelStart>
  return USBPD_OK;
 800979a:	e7aa      	b.n	80096f2 <USBPD_DPM_Init+0x12>
 800979c:	30210001 	.word	0x30210001
 80097a0:	20001c60 	.word	0x20001c60
 80097a4:	0800cc58 	.word	0x0800cc58
 80097a8:	0800ccd8 	.word	0x0800ccd8
 80097ac:	20000344 	.word	0x20000344

080097b0 <USBPD_DPM_TimerCounter>:
  if (USBPD_TRUE == DPM_Params[USBPD_PORT_0].DPM_Initialized)
 80097b0:	4b0a      	ldr	r3, [pc, #40]	; (80097dc <USBPD_DPM_TimerCounter+0x2c>)
{
 80097b2:	b510      	push	{r4, lr}
  if (USBPD_TRUE == DPM_Params[USBPD_PORT_0].DPM_Initialized)
 80097b4:	785b      	ldrb	r3, [r3, #1]
 80097b6:	075b      	lsls	r3, r3, #29
 80097b8:	d508      	bpl.n	80097cc <USBPD_DPM_TimerCounter+0x1c>
    USBPD_DPM_UserTimerCounter(USBPD_PORT_0);
 80097ba:	2000      	movs	r0, #0
 80097bc:	f7fc fcc0 	bl	8006140 <USBPD_DPM_UserTimerCounter>
    USBPD_PE_TimerCounter(USBPD_PORT_0);
 80097c0:	2000      	movs	r0, #0
 80097c2:	f7f6 fdfb 	bl	80003bc <USBPD_PE_TimerCounter>
    USBPD_PRL_TimerCounter(USBPD_PORT_0);
 80097c6:	2000      	movs	r0, #0
 80097c8:	f7fb fb28 	bl	8004e1c <USBPD_PRL_TimerCounter>
  if (uxTaskGetNumberOfTasks() != 0)
 80097cc:	f002 fd1e 	bl	800c20c <uxTaskGetNumberOfTasks>
 80097d0:	2800      	cmp	r0, #0
 80097d2:	d001      	beq.n	80097d8 <USBPD_DPM_TimerCounter+0x28>
    osSystickHandler();
 80097d4:	f002 f916 	bl	800ba04 <osSystickHandler>
}
 80097d8:	bd10      	pop	{r4, pc}
 80097da:	46c0      	nop			; (mov r8, r8)
 80097dc:	20001c60 	.word	0x20001c60

080097e0 <CAD_Init>:
void CAD_Init(uint8_t PortNum, USBPD_SettingsTypeDef *Settings, USBPD_ParamsTypeDef *Params,  void (*WakeUp)(void))
{
  CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
  
  /* store the settings and parameters */
  _handle->params = Params;
 80097e0:	2318      	movs	r3, #24
 80097e2:	4343      	muls	r3, r0
{
 80097e4:	b570      	push	{r4, r5, r6, lr}
  _handle->params = Params;
 80097e6:	4d0e      	ldr	r5, [pc, #56]	; (8009820 <CAD_Init+0x40>)
{
 80097e8:	0004      	movs	r4, r0
  _handle->settings = Settings;
 80097ea:	5159      	str	r1, [r3, r5]
  _handle->params = Params;
 80097ec:	18e8      	adds	r0, r5, r3
  _handle->state = USBPD_CAD_STATE_RESET;
  _handle->cc = CCNONE;
 80097ee:	25c0      	movs	r5, #192	; 0xc0
  _handle->state = USBPD_CAD_STATE_RESET;
 80097f0:	7c01      	ldrb	r1, [r0, #16]
  _handle->params = Params;
 80097f2:	6042      	str	r2, [r0, #4]
  _handle->cc = CCNONE;
 80097f4:	4029      	ands	r1, r5
 80097f6:	7401      	strb	r1, [r0, #16]
  _handle->CurrentHWcondition = _handle->OldHWCondtion = HW_Detachment;
 80097f8:	490a      	ldr	r1, [pc, #40]	; (8009824 <CAD_Init+0x44>)
  _handle->SNK_Source_Current_Adv = vRd_Undefined;
  
  if(_handle->params->PE_PowerRole == USBPD_PORTPOWERROLE_SRC)
  {
    USBPDM1_DeAssertRd(PortNum);
 80097fa:	0020      	movs	r0, r4
  _handle->CurrentHWcondition = _handle->OldHWCondtion = HW_Detachment;
 80097fc:	185b      	adds	r3, r3, r1
 80097fe:	2100      	movs	r1, #0
 8009800:	7059      	strb	r1, [r3, #1]
  if(_handle->params->PE_PowerRole == USBPD_PORTPOWERROLE_SRC)
 8009802:	7813      	ldrb	r3, [r2, #0]
 8009804:	075b      	lsls	r3, r3, #29
 8009806:	d505      	bpl.n	8009814 <CAD_Init+0x34>
    USBPDM1_DeAssertRd(PortNum);
 8009808:	f001 f85d 	bl	800a8c6 <USBPDM1_DeAssertRd>
    USBPDM1_AssertRp(PortNum);
 800980c:	0020      	movs	r0, r4
 800980e:	f001 f857 	bl	800a8c0 <USBPDM1_AssertRp>
  else
  {
    USBPDM1_DeAssertRp(PortNum);
    USBPDM1_AssertRd(PortNum);
  }
}
 8009812:	bd70      	pop	{r4, r5, r6, pc}
    USBPDM1_DeAssertRp(PortNum);
 8009814:	f001 f855 	bl	800a8c2 <USBPDM1_DeAssertRp>
    USBPDM1_AssertRd(PortNum);
 8009818:	0020      	movs	r0, r4
 800981a:	f001 f853 	bl	800a8c4 <USBPDM1_AssertRd>
}
 800981e:	e7f8      	b.n	8009812 <CAD_Init+0x32>
 8009820:	20001c68 	.word	0x20001c68
 8009824:	20001c78 	.word	0x20001c78

08009828 <CAD_Enter_ErrorRecovery>:
  * @brief  CAD enters in error recovery mode 
  * @param  PortNum  Number of the port
  * @retval None
  */ 
void CAD_Enter_ErrorRecovery(uint8_t PortNum)
{
 8009828:	b510      	push	{r4, lr}
  /* remove resistor terminaison 
     switch CAD_StateMachine to Error Recovery state
     wakeup CAD task */
  USBPD_HW_IF_ErrorRecovery(PortNum);
 800982a:	f001 f8d3 	bl	800a9d4 <USBPD_HW_IF_ErrorRecovery>
}
 800982e:	bd10      	pop	{r4, pc}

08009830 <USBPD_HW_IF_EXTI_Callback>:
  * @arg     ALERT_GPIO_PIN(1)    ** Defined in usbpd_porthandle.h **
  * @arg     SPI_NSS_PIN(1)       ** Defined in usbpd_porthandle.h **
  * @retval None
  */
void USBPD_HW_IF_EXTI_Callback(uint16_t GPIO_Pin)
{
 8009830:	b570      	push	{r4, r5, r6, lr}
 8009832:	0001      	movs	r1, r0
  uint8_t PortNum=0;
  GPIO_PinState NSSCurrentState;
  switch (GPIO_Pin)
 8009834:	2802      	cmp	r0, #2
 8009836:	d005      	beq.n	8009844 <USBPD_HW_IF_EXTI_Callback+0x14>
 8009838:	2380      	movs	r3, #128	; 0x80
 800983a:	015b      	lsls	r3, r3, #5
 800983c:	4298      	cmp	r0, r3
 800983e:	d005      	beq.n	800984c <USBPD_HW_IF_EXTI_Callback+0x1c>
 8009840:	46c0      	nop			; (mov r8, r8)
    
  default:
    __NOP();
    break;
  }
}
 8009842:	e002      	b.n	800984a <USBPD_HW_IF_EXTI_Callback+0x1a>
    STUSB16xx_HW_IF_Alert_Check(ALERT_PORT_INDEX(0));
 8009844:	2000      	movs	r0, #0
 8009846:	f001 fd81 	bl	800b34c <STUSB16xx_HW_IF_Alert_Check>
}
 800984a:	bd70      	pop	{r4, r5, r6, pc}
    NSSCurrentState = HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum));
 800984c:	4809      	ldr	r0, [pc, #36]	; (8009874 <USBPD_HW_IF_EXTI_Callback+0x44>)
 800984e:	f7fe f95f 	bl	8007b10 <HAL_GPIO_ReadPin>
 8009852:	4d09      	ldr	r5, [pc, #36]	; (8009878 <USBPD_HW_IF_EXTI_Callback+0x48>)
 8009854:	0004      	movs	r4, r0
    if( NSSCurrentState == GPIO_PIN_SET || RxNSSStatus[PortNum] == GPIO_PIN_RESET) 
 8009856:	2801      	cmp	r0, #1
 8009858:	d002      	beq.n	8009860 <USBPD_HW_IF_EXTI_Callback+0x30>
 800985a:	782b      	ldrb	r3, [r5, #0]
 800985c:	2b00      	cmp	r3, #0
 800985e:	d102      	bne.n	8009866 <USBPD_HW_IF_EXTI_Callback+0x36>
      PHY_HW_IF_RX_Stop(PortNum);
 8009860:	2000      	movs	r0, #0
 8009862:	f000 fc0f 	bl	800a084 <PHY_HW_IF_RX_Stop>
    if( NSSCurrentState == GPIO_PIN_RESET )
 8009866:	2c00      	cmp	r4, #0
 8009868:	d102      	bne.n	8009870 <USBPD_HW_IF_EXTI_Callback+0x40>
      PHY_HW_IF_RX_Start(PortNum);
 800986a:	0020      	movs	r0, r4
 800986c:	f000 fec8 	bl	800a600 <PHY_HW_IF_RX_Start>
    RxNSSStatus[PortNum] = NSSCurrentState;
 8009870:	702c      	strb	r4, [r5, #0]
    break;    
 8009872:	e7ea      	b.n	800984a <USBPD_HW_IF_EXTI_Callback+0x1a>
 8009874:	48000400 	.word	0x48000400
 8009878:	20000034 	.word	0x20000034

0800987c <USBPD_DMA_PORT0_IRQHandler>:
/**
  * @brief   This function handles DMA interrupts on channels 4, 5, 6 and 7
  * @retval  None
  */
void USBPD_DMA_PORT0_IRQHandler(void)
{
 800987c:	b570      	push	{r4, r5, r6, lr}
  uint8_t *end;
  
  /* Handler DMA TX PORT 0  */
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmatx)) != RESET)
 800987e:	4d39      	ldr	r5, [pc, #228]	; (8009964 <USBPD_DMA_PORT0_IRQHandler+0xe8>)
 8009880:	4c39      	ldr	r4, [pc, #228]	; (8009968 <USBPD_DMA_PORT0_IRQHandler+0xec>)
 8009882:	002b      	movs	r3, r5
 8009884:	33a4      	adds	r3, #164	; 0xa4
 8009886:	681a      	ldr	r2, [r3, #0]
 8009888:	4838      	ldr	r0, [pc, #224]	; (800996c <USBPD_DMA_PORT0_IRQHandler+0xf0>)
 800988a:	6821      	ldr	r1, [r4, #0]
 800988c:	2302      	movs	r3, #2
 800988e:	4282      	cmp	r2, r0
 8009890:	d016      	beq.n	80098c0 <USBPD_DMA_PORT0_IRQHandler+0x44>
 8009892:	4e37      	ldr	r6, [pc, #220]	; (8009970 <USBPD_DMA_PORT0_IRQHandler+0xf4>)
 8009894:	331e      	adds	r3, #30
 8009896:	42b2      	cmp	r2, r6
 8009898:	d012      	beq.n	80098c0 <USBPD_DMA_PORT0_IRQHandler+0x44>
 800989a:	4b36      	ldr	r3, [pc, #216]	; (8009974 <USBPD_DMA_PORT0_IRQHandler+0xf8>)
 800989c:	429a      	cmp	r2, r3
 800989e:	d01a      	beq.n	80098d6 <USBPD_DMA_PORT0_IRQHandler+0x5a>
 80098a0:	4b35      	ldr	r3, [pc, #212]	; (8009978 <USBPD_DMA_PORT0_IRQHandler+0xfc>)
 80098a2:	429a      	cmp	r2, r3
 80098a4:	d01a      	beq.n	80098dc <USBPD_DMA_PORT0_IRQHandler+0x60>
 80098a6:	4b35      	ldr	r3, [pc, #212]	; (800997c <USBPD_DMA_PORT0_IRQHandler+0x100>)
 80098a8:	429a      	cmp	r2, r3
 80098aa:	d01a      	beq.n	80098e2 <USBPD_DMA_PORT0_IRQHandler+0x66>
 80098ac:	4b34      	ldr	r3, [pc, #208]	; (8009980 <USBPD_DMA_PORT0_IRQHandler+0x104>)
 80098ae:	18d2      	adds	r2, r2, r3
 80098b0:	4253      	negs	r3, r2
 80098b2:	4153      	adcs	r3, r2
 80098b4:	4a33      	ldr	r2, [pc, #204]	; (8009984 <USBPD_DMA_PORT0_IRQHandler+0x108>)
 80098b6:	425b      	negs	r3, r3
 80098b8:	4013      	ands	r3, r2
 80098ba:	2280      	movs	r2, #128	; 0x80
 80098bc:	0492      	lsls	r2, r2, #18
 80098be:	189b      	adds	r3, r3, r2
 80098c0:	420b      	tst	r3, r1
 80098c2:	d025      	beq.n	8009910 <USBPD_DMA_PORT0_IRQHandler+0x94>
  {
    /* Transfer complete interrupt is used to end the transmission */
    if (Ports[0].State!=HAL_USBPD_PORT_STATE_BIST)
 80098c4:	7e6b      	ldrb	r3, [r5, #25]
 80098c6:	2b08      	cmp	r3, #8
 80098c8:	d00e      	beq.n	80098e8 <USBPD_DMA_PORT0_IRQHandler+0x6c>
    {
      PHY_HW_IF_TX_Done(0);
 80098ca:	2000      	movs	r0, #0
 80098cc:	f000 fd4e 	bl	800a36c <PHY_HW_IF_TX_Done>
  else if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmarx)) != RESET)
  {
    __NOP();
  }
  
  __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 80098d0:	4b2d      	ldr	r3, [pc, #180]	; (8009988 <USBPD_DMA_PORT0_IRQHandler+0x10c>)
 80098d2:	6063      	str	r3, [r4, #4]
}
 80098d4:	bd70      	pop	{r4, r5, r6, pc}
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmatx)) != RESET)
 80098d6:	2380      	movs	r3, #128	; 0x80
 80098d8:	009b      	lsls	r3, r3, #2
 80098da:	e7f1      	b.n	80098c0 <USBPD_DMA_PORT0_IRQHandler+0x44>
 80098dc:	2380      	movs	r3, #128	; 0x80
 80098de:	019b      	lsls	r3, r3, #6
 80098e0:	e7ee      	b.n	80098c0 <USBPD_DMA_PORT0_IRQHandler+0x44>
 80098e2:	2380      	movs	r3, #128	; 0x80
 80098e4:	029b      	lsls	r3, r3, #10
 80098e6:	e7eb      	b.n	80098c0 <USBPD_DMA_PORT0_IRQHandler+0x44>
      Ports[0].BIST_index+=1;
 80098e8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80098ea:	3301      	adds	r3, #1
 80098ec:	626b      	str	r3, [r5, #36]	; 0x24
      if(Ports[0].BIST_index == BIST_MAX_LENGTH) 
 80098ee:	2b1e      	cmp	r3, #30
 80098f0:	d105      	bne.n	80098fe <USBPD_DMA_PORT0_IRQHandler+0x82>
        end[(TX_BUFFER_LEN)*2 - 1] = 0;
 80098f2:	2000      	movs	r0, #0
 80098f4:	686b      	ldr	r3, [r5, #4]
 80098f6:	3337      	adds	r3, #55	; 0x37
 80098f8:	7018      	strb	r0, [r3, #0]
        STUSB16xx_HW_IF_Set_DMA_Normal_Mode(0); 
 80098fa:	f001 fc51 	bl	800b1a0 <STUSB16xx_HW_IF_Set_DMA_Normal_Mode>
      if(Ports[0].BIST_index > BIST_MAX_LENGTH) 
 80098fe:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8009900:	2b1e      	cmp	r3, #30
 8009902:	d9e5      	bls.n	80098d0 <USBPD_DMA_PORT0_IRQHandler+0x54>
        PHY_HW_IF_TX_Done(0);
 8009904:	2000      	movs	r0, #0
 8009906:	f000 fd31 	bl	800a36c <PHY_HW_IF_TX_Done>
        Ports[0].BIST_index=0;
 800990a:	2300      	movs	r3, #0
 800990c:	626b      	str	r3, [r5, #36]	; 0x24
 800990e:	e7df      	b.n	80098d0 <USBPD_DMA_PORT0_IRQHandler+0x54>
  else if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmarx)) != RESET)
 8009910:	35e8      	adds	r5, #232	; 0xe8
 8009912:	682a      	ldr	r2, [r5, #0]
 8009914:	6821      	ldr	r1, [r4, #0]
 8009916:	2302      	movs	r3, #2
 8009918:	4282      	cmp	r2, r0
 800991a:	d016      	beq.n	800994a <USBPD_DMA_PORT0_IRQHandler+0xce>
 800991c:	4814      	ldr	r0, [pc, #80]	; (8009970 <USBPD_DMA_PORT0_IRQHandler+0xf4>)
 800991e:	331e      	adds	r3, #30
 8009920:	4282      	cmp	r2, r0
 8009922:	d012      	beq.n	800994a <USBPD_DMA_PORT0_IRQHandler+0xce>
 8009924:	4b13      	ldr	r3, [pc, #76]	; (8009974 <USBPD_DMA_PORT0_IRQHandler+0xf8>)
 8009926:	429a      	cmp	r2, r3
 8009928:	d013      	beq.n	8009952 <USBPD_DMA_PORT0_IRQHandler+0xd6>
 800992a:	4b13      	ldr	r3, [pc, #76]	; (8009978 <USBPD_DMA_PORT0_IRQHandler+0xfc>)
 800992c:	429a      	cmp	r2, r3
 800992e:	d013      	beq.n	8009958 <USBPD_DMA_PORT0_IRQHandler+0xdc>
 8009930:	4b12      	ldr	r3, [pc, #72]	; (800997c <USBPD_DMA_PORT0_IRQHandler+0x100>)
 8009932:	429a      	cmp	r2, r3
 8009934:	d013      	beq.n	800995e <USBPD_DMA_PORT0_IRQHandler+0xe2>
 8009936:	4b12      	ldr	r3, [pc, #72]	; (8009980 <USBPD_DMA_PORT0_IRQHandler+0x104>)
 8009938:	18d2      	adds	r2, r2, r3
 800993a:	4253      	negs	r3, r2
 800993c:	4153      	adcs	r3, r2
 800993e:	4a11      	ldr	r2, [pc, #68]	; (8009984 <USBPD_DMA_PORT0_IRQHandler+0x108>)
 8009940:	425b      	negs	r3, r3
 8009942:	4013      	ands	r3, r2
 8009944:	2280      	movs	r2, #128	; 0x80
 8009946:	0492      	lsls	r2, r2, #18
 8009948:	189b      	adds	r3, r3, r2
 800994a:	420b      	tst	r3, r1
 800994c:	d0c0      	beq.n	80098d0 <USBPD_DMA_PORT0_IRQHandler+0x54>
 800994e:	46c0      	nop			; (mov r8, r8)
 8009950:	e7be      	b.n	80098d0 <USBPD_DMA_PORT0_IRQHandler+0x54>
 8009952:	2380      	movs	r3, #128	; 0x80
 8009954:	009b      	lsls	r3, r3, #2
 8009956:	e7f8      	b.n	800994a <USBPD_DMA_PORT0_IRQHandler+0xce>
 8009958:	2380      	movs	r3, #128	; 0x80
 800995a:	019b      	lsls	r3, r3, #6
 800995c:	e7f5      	b.n	800994a <USBPD_DMA_PORT0_IRQHandler+0xce>
 800995e:	2380      	movs	r3, #128	; 0x80
 8009960:	029b      	lsls	r3, r3, #10
 8009962:	e7f2      	b.n	800994a <USBPD_DMA_PORT0_IRQHandler+0xce>
 8009964:	20000058 	.word	0x20000058
 8009968:	40020000 	.word	0x40020000
 800996c:	40020008 	.word	0x40020008
 8009970:	4002001c 	.word	0x4002001c
 8009974:	40020030 	.word	0x40020030
 8009978:	40020044 	.word	0x40020044
 800997c:	40020058 	.word	0x40020058
 8009980:	bffdff94 	.word	0xbffdff94
 8009984:	fe200000 	.word	0xfe200000
 8009988:	0fffffff 	.word	0x0fffffff

0800998c <USBPD_RX_PORT0_COUNTTIM_IRQHandler>:
  * @brief   This function handles interrupts of RX timer associated to port 0
  * @details This timer is used to trigger the data decoding procedure on port 0
  * @retval  None
  */
void USBPD_RX_PORT0_COUNTTIM_IRQHandler(void)
{
 800998c:	b570      	push	{r4, r5, r6, lr}
  * @retval None
  */
static inline void SINGLE_TIM_IRQHandler(TIM_HandleTypeDef *htim, uint32_t Flag, uint32_t Timit)
{
  /* Capture compare event */
  if(__HAL_TIM_GET_FLAG(htim, Flag) != RESET)
 800998e:	4c0b      	ldr	r4, [pc, #44]	; (80099bc <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x30>)
 8009990:	2202      	movs	r2, #2
 8009992:	0023      	movs	r3, r4
 8009994:	33fc      	adds	r3, #252	; 0xfc
 8009996:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009998:	6919      	ldr	r1, [r3, #16]
 800999a:	4211      	tst	r1, r2
 800999c:	d00d      	beq.n	80099ba <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x2e>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, Timit) != RESET)
 800999e:	68d9      	ldr	r1, [r3, #12]
 80099a0:	4211      	tst	r1, r2
 80099a2:	d00a      	beq.n	80099ba <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x2e>
    {
        __HAL_TIM_CLEAR_IT(htim, Timit);
 80099a4:	3a05      	subs	r2, #5
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80099a6:	25ca      	movs	r5, #202	; 0xca
        __HAL_TIM_CLEAR_IT(htim, Timit);
 80099a8:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80099aa:	2301      	movs	r3, #1
 80099ac:	006d      	lsls	r5, r5, #1
 80099ae:	5563      	strb	r3, [r4, r5]
        /* Output compare event */
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80099b0:	4803      	ldr	r0, [pc, #12]	; (80099c0 <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x34>)
 80099b2:	f000 fc0b 	bl	800a1cc <HAL_TIM_OC_DelayElapsedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80099b6:	2300      	movs	r3, #0
 80099b8:	5563      	strb	r3, [r4, r5]
}
 80099ba:	bd70      	pop	{r4, r5, r6, pc}
 80099bc:	20000058 	.word	0x20000058
 80099c0:	200001d0 	.word	0x200001d0

080099c4 <PHY_BistCompleted>:
 * @param  bistmode  Modality of the BIST
 * @retval none.
 */
void PHY_BistCompleted(uint8_t PortNum, USBPD_BISTMsg_TypeDef bistmode)
{
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_BistCompleted)
 80099c4:	237c      	movs	r3, #124	; 0x7c
 80099c6:	4343      	muls	r3, r0
 80099c8:	4a03      	ldr	r2, [pc, #12]	; (80099d8 <PHY_BistCompleted+0x14>)
{
 80099ca:	b510      	push	{r4, lr}
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_BistCompleted)
 80099cc:	589b      	ldr	r3, [r3, r2]
 80099ce:	691b      	ldr	r3, [r3, #16]
 80099d0:	2b00      	cmp	r3, #0
 80099d2:	d000      	beq.n	80099d6 <PHY_BistCompleted+0x12>
  {
    PHY_Ports[PortNum].cbs->USBPD_PHY_BistCompleted(PortNum,bistmode);
 80099d4:	4798      	blx	r3
  }
}
 80099d6:	bd10      	pop	{r4, pc}
 80099d8:	20000354 	.word	0x20000354

080099dc <PHY_TxCompleted>:
 * @param  PortNum  Number of the port.
 * @retval none.
 */
void PHY_TxCompleted(uint8_t PortNum)
{
  PHY_Ports[PortNum].State = PHY_StateNone;
 80099dc:	237c      	movs	r3, #124	; 0x7c
{
 80099de:	b510      	push	{r4, lr}
  PHY_Ports[PortNum].State = PHY_StateNone;
 80099e0:	2400      	movs	r4, #0
 80099e2:	4343      	muls	r3, r0
 80099e4:	4a04      	ldr	r2, [pc, #16]	; (80099f8 <PHY_TxCompleted+0x1c>)
 80099e6:	18d1      	adds	r1, r2, r3
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_TxCompleted)
 80099e8:	589b      	ldr	r3, [r3, r2]
  PHY_Ports[PortNum].State = PHY_StateNone;
 80099ea:	720c      	strb	r4, [r1, #8]
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_TxCompleted)
 80099ec:	695b      	ldr	r3, [r3, #20]
 80099ee:	42a3      	cmp	r3, r4
 80099f0:	d000      	beq.n	80099f4 <PHY_TxCompleted+0x18>
  {
    PHY_Ports[PortNum].cbs->USBPD_PHY_TxCompleted(PortNum);
 80099f2:	4798      	blx	r3
  }
}
 80099f4:	bd10      	pop	{r4, pc}
 80099f6:	46c0      	nop			; (mov r8, r8)
 80099f8:	20000354 	.word	0x20000354

080099fc <PHY_Rx_Reset>:
{
  /* Get the pointer to the decoding structure */
  PHY_RxDecodingTypeDef *pRxData = (PHY_RxDecodingTypeDef *)&PHY_Ports[PortNum].RxDec;

  /* reset the status of the RX process */
  pRxData->Status = USBPD_PHY_RX_STATUS_NONE;
 80099fc:	237c      	movs	r3, #124	; 0x7c
 80099fe:	4358      	muls	r0, r3
 8009a00:	4a0a      	ldr	r2, [pc, #40]	; (8009a2c <PHY_Rx_Reset+0x30>)
{
 8009a02:	b570      	push	{r4, r5, r6, lr}
  pRxData->Status = USBPD_PHY_RX_STATUS_NONE;
 8009a04:	1814      	adds	r4, r2, r0
 8009a06:	0026      	movs	r6, r4
 8009a08:	2500      	movs	r5, #0
 8009a0a:	3640      	adds	r6, #64	; 0x40

  /* reset the variable of count and memory */
  pRxData->DataCount = 0;
  memset(pRxData->Data, 0, __RX_DATA_LEN);
 8009a0c:	3049      	adds	r0, #73	; 0x49
  pRxData->Status = USBPD_PHY_RX_STATUS_NONE;
 8009a0e:	7035      	strb	r5, [r6, #0]
  pRxData->DataCount = 0;
 8009a10:	6765      	str	r5, [r4, #116]	; 0x74
  memset(pRxData->Data, 0, __RX_DATA_LEN);
 8009a12:	0029      	movs	r1, r5
 8009a14:	1810      	adds	r0, r2, r0
 8009a16:	2228      	movs	r2, #40	; 0x28
 8009a18:	f003 f851 	bl	800cabe <memset>

  /* reset the type of SOP */
  pRxData->MsgType = USBPD_SOPTYPE_INVALID;
 8009a1c:	0023      	movs	r3, r4
 8009a1e:	22ff      	movs	r2, #255	; 0xff
 8009a20:	3348      	adds	r3, #72	; 0x48

  /* reset the type of OrderSet received */
  pRxData->OrderSet = 0x00;
 8009a22:	6465      	str	r5, [r4, #68]	; 0x44
  pRxData->MsgType = USBPD_SOPTYPE_INVALID;
 8009a24:	701a      	strb	r2, [r3, #0]

  return pRxData->Status;
 8009a26:	7830      	ldrb	r0, [r6, #0]
}
 8009a28:	bd70      	pop	{r4, r5, r6, pc}
 8009a2a:	46c0      	nop			; (mov r8, r8)
 8009a2c:	20000354 	.word	0x20000354

08009a30 <PHY_Rx_Completed>:
  * @brief  Callback to notify the end of the current reception
  * @param  PortNum  Number of the port
  * @retval Status of current reception
  */
USBPD_PHY_RX_Status_TypeDef PHY_Rx_Completed(uint8_t PortNum)
{
 8009a30:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t crc_read,crc_calc;
  PHY_RxDecodingTypeDef * pRxData = (PHY_RxDecodingTypeDef *)&PHY_Ports[PortNum].RxDec;
  if (pRxData->Status != USBPD_PHY_RX_STATUS_MESSAGE_READY)
 8009a32:	257c      	movs	r5, #124	; 0x7c
 8009a34:	4345      	muls	r5, r0
 8009a36:	4e2b      	ldr	r6, [pc, #172]	; (8009ae4 <PHY_Rx_Completed+0xb4>)
{
 8009a38:	0007      	movs	r7, r0
  if (pRxData->Status != USBPD_PHY_RX_STATUS_MESSAGE_READY)
 8009a3a:	1974      	adds	r4, r6, r5
 8009a3c:	0023      	movs	r3, r4
 8009a3e:	3340      	adds	r3, #64	; 0x40
 8009a40:	7818      	ldrb	r0, [r3, #0]
{
 8009a42:	b085      	sub	sp, #20
  if (pRxData->Status != USBPD_PHY_RX_STATUS_MESSAGE_READY)
 8009a44:	9301      	str	r3, [sp, #4]
 8009a46:	2804      	cmp	r0, #4
 8009a48:	d111      	bne.n	8009a6e <PHY_Rx_Completed+0x3e>
  {
    return pRxData->Status;
  }

  if (pRxData->MsgType == USBPD_SOPTYPE_HARD_RESET || pRxData->MsgType == USBPD_SOPTYPE_CABLE_RESET)
 8009a4a:	3308      	adds	r3, #8
 8009a4c:	7819      	ldrb	r1, [r3, #0]
 8009a4e:	9302      	str	r3, [sp, #8]
 8009a50:	1f4b      	subs	r3, r1, #5
 8009a52:	2b01      	cmp	r3, #1
 8009a54:	d80d      	bhi.n	8009a72 <PHY_Rx_Completed+0x42>
  {
    /* received a hard reset, call the callback, no other checks */
    if (PHY_Ports[PortNum].cbs->USBPD_PHY_ResetIndication != NULL)
 8009a56:	59ab      	ldr	r3, [r5, r6]
 8009a58:	685b      	ldr	r3, [r3, #4]
 8009a5a:	2b00      	cmp	r3, #0
 8009a5c:	d001      	beq.n	8009a62 <PHY_Rx_Completed+0x32>
    {
      PHY_Ports[PortNum].cbs->USBPD_PHY_ResetIndication(PortNum, pRxData->MsgType);
 8009a5e:	0038      	movs	r0, r7
 8009a60:	4798      	blx	r3
    }
    return pRxData->Status = USBPD_PHY_RX_STATUS_OK;
 8009a62:	237c      	movs	r3, #124	; 0x7c
 8009a64:	2001      	movs	r0, #1
 8009a66:	435f      	muls	r7, r3
 8009a68:	19f6      	adds	r6, r6, r7
 8009a6a:	3640      	adds	r6, #64	; 0x40
 8009a6c:	7030      	strb	r0, [r6, #0]
  {
    PHY_Ports[PortNum].cbs->USBPD_PHY_MessageReceived(PortNum, pRxData->MsgType);
  }

  return pRxData->Status = USBPD_PHY_RX_STATUS_OK;
}
 8009a6e:	b005      	add	sp, #20
 8009a70:	bdf0      	pop	{r4, r5, r6, r7, pc}
  uint8_t *pRxBuffer = PHY_Ports[PortNum].pRxBuffer;
 8009a72:	6863      	ldr	r3, [r4, #4]
 8009a74:	9303      	str	r3, [sp, #12]
  crc_calc = USBPD_HW_IF_CRC_Calculate(pRxData->Data, pRxData->DataCount - 4);
 8009a76:	002b      	movs	r3, r5
 8009a78:	3349      	adds	r3, #73	; 0x49
 8009a7a:	18f3      	adds	r3, r6, r3
 8009a7c:	9300      	str	r3, [sp, #0]
 8009a7e:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8009a80:	9800      	ldr	r0, [sp, #0]
 8009a82:	1f19      	subs	r1, r3, #4
 8009a84:	b2c9      	uxtb	r1, r1
 8009a86:	f000 fa3d 	bl	8009f04 <USBPD_HW_IF_CRC_Calculate>
 8009a8a:	4684      	mov	ip, r0
  uint8_t *pCrcField = &pRxData->Data[pRxData->DataCount - 4];
 8009a8c:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8009a8e:	1f1a      	subs	r2, r3, #4
 8009a90:	1951      	adds	r1, r2, r5
 8009a92:	3149      	adds	r1, #73	; 0x49
 8009a94:	1871      	adds	r1, r6, r1
  crc_read = *pCrcField;
 8009a96:	18a4      	adds	r4, r4, r2
  crc_read |= ((*pCrcField) << 8);
 8009a98:	784b      	ldrb	r3, [r1, #1]
  crc_read |= ((*pCrcField) << 16);
 8009a9a:	7888      	ldrb	r0, [r1, #2]
  crc_read = *pCrcField;
 8009a9c:	3449      	adds	r4, #73	; 0x49
 8009a9e:	7824      	ldrb	r4, [r4, #0]
  crc_read |= ((*pCrcField) << 8);
 8009aa0:	021b      	lsls	r3, r3, #8
  crc_read |= ((*pCrcField) << 16);
 8009aa2:	0400      	lsls	r0, r0, #16
 8009aa4:	4303      	orrs	r3, r0
 8009aa6:	4323      	orrs	r3, r4
  crc_read |= ((*pCrcField) << 24);
 8009aa8:	78cc      	ldrb	r4, [r1, #3]
 8009aaa:	0624      	lsls	r4, r4, #24
 8009aac:	431c      	orrs	r4, r3
  if (crc_read != crc_calc)
 8009aae:	45a4      	cmp	ip, r4
 8009ab0:	d003      	beq.n	8009aba <PHY_Rx_Completed+0x8a>
    return pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_CRC_FAILED;
 8009ab2:	200a      	movs	r0, #10
 8009ab4:	9b01      	ldr	r3, [sp, #4]
 8009ab6:	7018      	strb	r0, [r3, #0]
 8009ab8:	e7d9      	b.n	8009a6e <PHY_Rx_Completed+0x3e>
  memcpy(pRxBuffer, pRxData->Data, pRxData->DataCount - 4);
 8009aba:	9900      	ldr	r1, [sp, #0]
 8009abc:	9803      	ldr	r0, [sp, #12]
 8009abe:	f002 fff5 	bl	800caac <memcpy>
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_MessageReceived != NULL)
 8009ac2:	59ab      	ldr	r3, [r5, r6]
 8009ac4:	681b      	ldr	r3, [r3, #0]
 8009ac6:	2b00      	cmp	r3, #0
 8009ac8:	d003      	beq.n	8009ad2 <PHY_Rx_Completed+0xa2>
    PHY_Ports[PortNum].cbs->USBPD_PHY_MessageReceived(PortNum, pRxData->MsgType);
 8009aca:	9a02      	ldr	r2, [sp, #8]
 8009acc:	0038      	movs	r0, r7
 8009ace:	7811      	ldrb	r1, [r2, #0]
 8009ad0:	4798      	blx	r3
  return pRxData->Status = USBPD_PHY_RX_STATUS_OK;
 8009ad2:	267c      	movs	r6, #124	; 0x7c
 8009ad4:	2001      	movs	r0, #1
 8009ad6:	437e      	muls	r6, r7
 8009ad8:	4f02      	ldr	r7, [pc, #8]	; (8009ae4 <PHY_Rx_Completed+0xb4>)
 8009ada:	19bf      	adds	r7, r7, r6
 8009adc:	3740      	adds	r7, #64	; 0x40
 8009ade:	7038      	strb	r0, [r7, #0]
 8009ae0:	e7c5      	b.n	8009a6e <PHY_Rx_Completed+0x3e>
 8009ae2:	46c0      	nop			; (mov r8, r8)
 8009ae4:	20000354 	.word	0x20000354

08009ae8 <PHY_Encode5b_Short>:
{
 8009ae8:	b510      	push	{r4, lr}
  return coding4b5b[val & 0x0F] | (coding4b5b[(val >> 4) & 0x0F] << 5);
 8009aea:	240f      	movs	r4, #15
 8009aec:	4908      	ldr	r1, [pc, #32]	; (8009b10 <PHY_Encode5b_Short+0x28>)
  return PHY_Encode5b_Byte(val & 0x00FF) | (PHY_Encode5b_Byte((val >> 8) & 0x00FF) << 10);
 8009aee:	b2c2      	uxtb	r2, r0
 8009af0:	0a00      	lsrs	r0, r0, #8
  return coding4b5b[val & 0x0F] | (coding4b5b[(val >> 4) & 0x0F] << 5);
 8009af2:	0903      	lsrs	r3, r0, #4
 8009af4:	5ccb      	ldrb	r3, [r1, r3]
 8009af6:	4020      	ands	r0, r4
 8009af8:	5c08      	ldrb	r0, [r1, r0]
 8009afa:	015b      	lsls	r3, r3, #5
 8009afc:	4303      	orrs	r3, r0
 8009afe:	0910      	lsrs	r0, r2, #4
 8009b00:	5c08      	ldrb	r0, [r1, r0]
 8009b02:	4022      	ands	r2, r4
 8009b04:	5c8a      	ldrb	r2, [r1, r2]
 8009b06:	0140      	lsls	r0, r0, #5
  return PHY_Encode5b_Byte(val & 0x00FF) | (PHY_Encode5b_Byte((val >> 8) & 0x00FF) << 10);
 8009b08:	029b      	lsls	r3, r3, #10
  return coding4b5b[val & 0x0F] | (coding4b5b[(val >> 4) & 0x0F] << 5);
 8009b0a:	4310      	orrs	r0, r2
  return PHY_Encode5b_Byte(val & 0x00FF) | (PHY_Encode5b_Byte((val >> 8) & 0x00FF) << 10);
 8009b0c:	4318      	orrs	r0, r3
}
 8009b0e:	bd10      	pop	{r4, pc}
 8009b10:	0800cd34 	.word	0x0800cd34

08009b14 <USBPD_PHY_GetRetryTimerValue>:
  return 920u;
 8009b14:	20e6      	movs	r0, #230	; 0xe6
}
 8009b16:	0080      	lsls	r0, r0, #2
 8009b18:	4770      	bx	lr
	...

08009b1c <USBPD_PHY_Send_BIST_Pattern>:
  PHY_Ports[PortNum].State = PHY_StateBusyBIST_Tx;
 8009b1c:	237c      	movs	r3, #124	; 0x7c
 8009b1e:	4343      	muls	r3, r0
{
 8009b20:	b510      	push	{r4, lr}
  PHY_Ports[PortNum].State = PHY_StateBusyBIST_Tx;
 8009b22:	4c04      	ldr	r4, [pc, #16]	; (8009b34 <USBPD_PHY_Send_BIST_Pattern+0x18>)
 8009b24:	18e4      	adds	r4, r4, r3
 8009b26:	2305      	movs	r3, #5
 8009b28:	7223      	strb	r3, [r4, #8]
  USBPD_HW_IF_Send_BIST_Pattern(PortNum);
 8009b2a:	f000 fa2b 	bl	8009f84 <USBPD_HW_IF_Send_BIST_Pattern>
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009b2e:	2000      	movs	r0, #0
 8009b30:	7220      	strb	r0, [r4, #8]
}
 8009b32:	bd10      	pop	{r4, pc}
 8009b34:	20000354 	.word	0x20000354

08009b38 <USBPD_PHY_ExitTransmit>:
}
 8009b38:	2000      	movs	r0, #0
 8009b3a:	4770      	bx	lr

08009b3c <USBPD_PHY_SetResistor_SinkTxNG>:
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_1_5_A);
 8009b3c:	1e43      	subs	r3, r0, #1
 8009b3e:	4198      	sbcs	r0, r3
{
 8009b40:	b510      	push	{r4, lr}
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_1_5_A);
 8009b42:	3028      	adds	r0, #40	; 0x28
 8009b44:	2101      	movs	r1, #1
 8009b46:	f7fc ff9b 	bl	8006a80 <STUSB1602_Current_Advertised_Set>
}
 8009b4a:	bd10      	pop	{r4, pc}

08009b4c <USBPD_PHY_SetResistor_SinkTxOK>:
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 8009b4c:	1e43      	subs	r3, r0, #1
 8009b4e:	4198      	sbcs	r0, r3
{
 8009b50:	b510      	push	{r4, lr}
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 8009b52:	3028      	adds	r0, #40	; 0x28
 8009b54:	2102      	movs	r1, #2
 8009b56:	f7fc ff93 	bl	8006a80 <STUSB1602_Current_Advertised_Set>
}
 8009b5a:	bd10      	pop	{r4, pc}

08009b5c <USBPD_PHY_SOPSupported>:
}
 8009b5c:	4770      	bx	lr

08009b5e <USBPD_PHY_IsResistor_SinkTxOk>:
{
 8009b5e:	b510      	push	{r4, lr}
  return USBPD_16xx_IsResistor_SinkTxOk(PortNum);
 8009b60:	f001 fe00 	bl	800b764 <USBPD_16xx_IsResistor_SinkTxOk>
}
 8009b64:	bd10      	pop	{r4, pc}

08009b66 <USBPD_PHY_FastRoleSwapSignalling>:
 8009b66:	4770      	bx	lr

08009b68 <PHY_TxBuffer_Reset>:
{
 8009b68:	b570      	push	{r4, r5, r6, lr}
  memset((void *)PHY_Ports[PortNum].TxBuffer, 0, __TX_BUFF_SIZE);
 8009b6a:	257c      	movs	r5, #124	; 0x7c
 8009b6c:	4345      	muls	r5, r0
 8009b6e:	0028      	movs	r0, r5
 8009b70:	4c05      	ldr	r4, [pc, #20]	; (8009b88 <PHY_TxBuffer_Reset+0x20>)
 8009b72:	300c      	adds	r0, #12
 8009b74:	1820      	adds	r0, r4, r0
 8009b76:	2230      	movs	r2, #48	; 0x30
 8009b78:	2100      	movs	r1, #0
 8009b7a:	f002 ffa0 	bl	800cabe <memset>
  PHY_Ports[PortNum].TxDatabitLen = 0;
 8009b7e:	2300      	movs	r3, #0
 8009b80:	1964      	adds	r4, r4, r5
 8009b82:	63e3      	str	r3, [r4, #60]	; 0x3c
}
 8009b84:	bd70      	pop	{r4, r5, r6, pc}
 8009b86:	46c0      	nop			; (mov r8, r8)
 8009b88:	20000354 	.word	0x20000354

08009b8c <USBPD_PHY_Reset>:
{
 8009b8c:	b510      	push	{r4, lr}
  PHY_TxBuffer_Reset(PortNum);
 8009b8e:	f7ff ffeb 	bl	8009b68 <PHY_TxBuffer_Reset>
}
 8009b92:	bd10      	pop	{r4, pc}

08009b94 <USBPD_PHY_Init>:
{
 8009b94:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009b96:	0016      	movs	r6, r2
  hwif_cbs.USBPD_HW_IF_RX_Reset       = PHY_Rx_Reset;
 8009b98:	4a11      	ldr	r2, [pc, #68]	; (8009be0 <USBPD_PHY_Init+0x4c>)
{
 8009b9a:	b08b      	sub	sp, #44	; 0x2c
  hwif_cbs.USBPD_HW_IF_RX_Reset       = PHY_Rx_Reset;
 8009b9c:	9207      	str	r2, [sp, #28]
  hwif_cbs.USBPD_HW_IF_RX_Accumulate  = PHY_Rx_Accumulate;
 8009b9e:	4a11      	ldr	r2, [pc, #68]	; (8009be4 <USBPD_PHY_Init+0x50>)
{
 8009ba0:	0004      	movs	r4, r0
  hwif_cbs.USBPD_HW_IF_RX_Accumulate  = PHY_Rx_Accumulate;
 8009ba2:	9208      	str	r2, [sp, #32]
  hwif_cbs.USBPD_HW_IF_RX_Completed   = PHY_Rx_Completed;
 8009ba4:	4a10      	ldr	r2, [pc, #64]	; (8009be8 <USBPD_PHY_Init+0x54>)
  USBPD_HW_IF_PortHwInit(PortNum, hwif_cbs, PowerRole);
 8009ba6:	9303      	str	r3, [sp, #12]
  hwif_cbs.USBPD_HW_IF_RX_Completed   = PHY_Rx_Completed;
 8009ba8:	9209      	str	r2, [sp, #36]	; 0x24
  USBPD_HW_IF_PortHwInit(PortNum, hwif_cbs, PowerRole);
 8009baa:	466a      	mov	r2, sp
 8009bac:	ab07      	add	r3, sp, #28
{
 8009bae:	000d      	movs	r5, r1
  USBPD_HW_IF_PortHwInit(PortNum, hwif_cbs, PowerRole);
 8009bb0:	cb83      	ldmia	r3!, {r0, r1, r7}
 8009bb2:	c283      	stmia	r2!, {r0, r1, r7}
 8009bb4:	4a0d      	ldr	r2, [pc, #52]	; (8009bec <USBPD_PHY_Init+0x58>)
 8009bb6:	9904      	ldr	r1, [sp, #16]
 8009bb8:	4b0d      	ldr	r3, [pc, #52]	; (8009bf0 <USBPD_PHY_Init+0x5c>)
 8009bba:	0020      	movs	r0, r4
 8009bbc:	f001 fb5a 	bl	800b274 <USBPD_HW_IF_PortHwInit>
  PHY_Ports[PortNum].pRxBuffer    = pRxBuffer;
 8009bc0:	237c      	movs	r3, #124	; 0x7c
 8009bc2:	4363      	muls	r3, r4
 8009bc4:	4a0b      	ldr	r2, [pc, #44]	; (8009bf4 <USBPD_PHY_Init+0x60>)
  PHY_Ports[PortNum].SupportedSOP = SupportedSOP;
 8009bc6:	9910      	ldr	r1, [sp, #64]	; 0x40
  PHY_Ports[PortNum].pRxBuffer    = pRxBuffer;
 8009bc8:	18d7      	adds	r7, r2, r3
  PHY_TxBuffer_Reset(PortNum);
 8009bca:	0020      	movs	r0, r4
  PHY_Ports[PortNum].pRxBuffer    = pRxBuffer;
 8009bcc:	607e      	str	r6, [r7, #4]
  PHY_Ports[PortNum].SupportedSOP = SupportedSOP;
 8009bce:	67b9      	str	r1, [r7, #120]	; 0x78
  PHY_Ports[PortNum].cbs = pCallback;
 8009bd0:	509d      	str	r5, [r3, r2]
  PHY_TxBuffer_Reset(PortNum);
 8009bd2:	f7ff ffc9 	bl	8009b68 <PHY_TxBuffer_Reset>
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009bd6:	2000      	movs	r0, #0
 8009bd8:	7238      	strb	r0, [r7, #8]
}
 8009bda:	b00b      	add	sp, #44	; 0x2c
 8009bdc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009bde:	46c0      	nop			; (mov r8, r8)
 8009be0:	080099fd 	.word	0x080099fd
 8009be4:	08009e29 	.word	0x08009e29
 8009be8:	08009a31 	.word	0x08009a31
 8009bec:	080099dd 	.word	0x080099dd
 8009bf0:	080099c5 	.word	0x080099c5
 8009bf4:	20000354 	.word	0x20000354

08009bf8 <PHY_TxBuffer_Append>:
{
 8009bf8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009bfa:	247c      	movs	r4, #124	; 0x7c
  uint32_t map = __BITMASK(nbit);
 8009bfc:	2601      	movs	r6, #1
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009bfe:	4344      	muls	r4, r0
  uint32_t bit = *pOffset % __SIZEBIT;
 8009c00:	271f      	movs	r7, #31
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009c02:	0023      	movs	r3, r4
  uint32_t map = __BITMASK(nbit);
 8009c04:	4096      	lsls	r6, r2
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009c06:	4d16      	ldr	r5, [pc, #88]	; (8009c60 <PHY_TxBuffer_Append+0x68>)
 8009c08:	330c      	adds	r3, #12
  uint32_t pos = *pOffset / __SIZEBIT;
 8009c0a:	192c      	adds	r4, r5, r4
 8009c0c:	6be4      	ldr	r4, [r4, #60]	; 0x3c
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009c0e:	18eb      	adds	r3, r5, r3
  uint32_t bit = *pOffset % __SIZEBIT;
 8009c10:	4027      	ands	r7, r4
  uint32_t pos = *pOffset / __SIZEBIT;
 8009c12:	0964      	lsrs	r4, r4, #5
  uint32_t map = __BITMASK(nbit);
 8009c14:	3e01      	subs	r6, #1
  pBuffer[pos] |= (value << bit);
 8009c16:	00a4      	lsls	r4, r4, #2
  uint32_t value = val & map;
 8009c18:	4031      	ands	r1, r6
  pBuffer[pos] |= (value << bit);
 8009c1a:	191e      	adds	r6, r3, r4
 8009c1c:	46b4      	mov	ip, r6
 8009c1e:	000e      	movs	r6, r1
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009c20:	9301      	str	r3, [sp, #4]
  pBuffer[pos] |= (value << bit);
 8009c22:	4663      	mov	r3, ip
 8009c24:	40be      	lsls	r6, r7
 8009c26:	681b      	ldr	r3, [r3, #0]
 8009c28:	431e      	orrs	r6, r3
 8009c2a:	4663      	mov	r3, ip
 8009c2c:	601e      	str	r6, [r3, #0]
  if (bit > (__SIZEBIT - MIN(nbit, __SIZEBIT)))
 8009c2e:	1c16      	adds	r6, r2, #0
 8009c30:	2a20      	cmp	r2, #32
 8009c32:	d900      	bls.n	8009c36 <PHY_TxBuffer_Append+0x3e>
 8009c34:	2620      	movs	r6, #32
 8009c36:	b2f3      	uxtb	r3, r6
 8009c38:	2620      	movs	r6, #32
 8009c3a:	1af3      	subs	r3, r6, r3
 8009c3c:	42bb      	cmp	r3, r7
 8009c3e:	d207      	bcs.n	8009c50 <PHY_TxBuffer_Append+0x58>
    pBuffer[pos + 1] |= (value >> (__SIZEBIT - bit));
 8009c40:	1bf7      	subs	r7, r6, r7
 8009c42:	40f9      	lsrs	r1, r7
 8009c44:	9b01      	ldr	r3, [sp, #4]
 8009c46:	3404      	adds	r4, #4
 8009c48:	191b      	adds	r3, r3, r4
 8009c4a:	681c      	ldr	r4, [r3, #0]
 8009c4c:	4321      	orrs	r1, r4
 8009c4e:	6019      	str	r1, [r3, #0]
  *pOffset += nbit;
 8009c50:	237c      	movs	r3, #124	; 0x7c
 8009c52:	4358      	muls	r0, r3
 8009c54:	182d      	adds	r5, r5, r0
 8009c56:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8009c58:	189a      	adds	r2, r3, r2
 8009c5a:	63ea      	str	r2, [r5, #60]	; 0x3c
}
 8009c5c:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8009c5e:	46c0      	nop			; (mov r8, r8)
 8009c60:	20000354 	.word	0x20000354

08009c64 <PHY_PreparePacket>:
{
 8009c64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint8_t resetRequired = Type == USBPD_SOPTYPE_HARD_RESET || Type == USBPD_SOPTYPE_CABLE_RESET;
 8009c66:	1f4c      	subs	r4, r1, #5
 8009c68:	b2e4      	uxtb	r4, r4
{
 8009c6a:	000f      	movs	r7, r1
 8009c6c:	0015      	movs	r5, r2
 8009c6e:	001e      	movs	r6, r3
  if (!resetRequired  && ((Size < 2) || (Size > 30) || (( (Size - 2) % __SIZE) != 0))) 
 8009c70:	2c01      	cmp	r4, #1
 8009c72:	d95f      	bls.n	8009d34 <PHY_PreparePacket+0xd0>
 8009c74:	3b02      	subs	r3, #2
 8009c76:	b2da      	uxtb	r2, r3
 8009c78:	2a1c      	cmp	r2, #28
 8009c7a:	d801      	bhi.n	8009c80 <PHY_PreparePacket+0x1c>
 8009c7c:	079b      	lsls	r3, r3, #30
 8009c7e:	d00e      	beq.n	8009c9e <PHY_PreparePacket+0x3a>
  return FRAME_5B_BitSizeIsValid(*pOffset) ? USBPD_OK : USBPD_ERROR;
 8009c80:	2002      	movs	r0, #2
 8009c82:	e056      	b.n	8009d32 <PHY_PreparePacket+0xce>
      val16 = pBuffer[i] | (pBuffer[i + 1] << 8);
 8009c84:	7863      	ldrb	r3, [r4, #1]
 8009c86:	7820      	ldrb	r0, [r4, #0]
 8009c88:	021b      	lsls	r3, r3, #8
      value = PHY_Encode5b_Short(val16);
 8009c8a:	4318      	orrs	r0, r3
 8009c8c:	f7ff ff2c 	bl	8009ae8 <PHY_Encode5b_Short>
      PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 8009c90:	2214      	movs	r2, #20
      value = PHY_Encode5b_Short(val16);
 8009c92:	0001      	movs	r1, r0
      PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 8009c94:	2000      	movs	r0, #0
 8009c96:	f7ff ffaf 	bl	8009bf8 <PHY_TxBuffer_Append>
 8009c9a:	3402      	adds	r4, #2
 8009c9c:	e016      	b.n	8009ccc <PHY_PreparePacket+0x68>
  if (!USBPD_PORT_IsValid(PortNum) || (!resetRequired && pBuffer == NULL))
 8009c9e:	2800      	cmp	r0, #0
 8009ca0:	d1ee      	bne.n	8009c80 <PHY_PreparePacket+0x1c>
 8009ca2:	2d00      	cmp	r5, #0
 8009ca4:	d0ec      	beq.n	8009c80 <PHY_PreparePacket+0x1c>
  PHY_TxBuffer_Reset(PortNum);
 8009ca6:	2000      	movs	r0, #0
 8009ca8:	f7ff ff5e 	bl	8009b68 <PHY_TxBuffer_Reset>
  PHY_TxBuffer_Append(PortNum, OrderSets[(uint8_t)Type], OS_BITSIZE);
 8009cac:	4b23      	ldr	r3, [pc, #140]	; (8009d3c <PHY_PreparePacket+0xd8>)
 8009cae:	00bf      	lsls	r7, r7, #2
 8009cb0:	19df      	adds	r7, r3, r7
 8009cb2:	2214      	movs	r2, #20
 8009cb4:	6939      	ldr	r1, [r7, #16]
 8009cb6:	2000      	movs	r0, #0
 8009cb8:	f7ff ff9e 	bl	8009bf8 <PHY_TxBuffer_Append>
  if (!resetRequired)
 8009cbc:	2c01      	cmp	r4, #1
 8009cbe:	d91d      	bls.n	8009cfc <PHY_PreparePacket+0x98>
    crc_value = USBPD_HW_IF_CRC_Calculate(pBuffer, Size);
 8009cc0:	0031      	movs	r1, r6
 8009cc2:	0028      	movs	r0, r5
 8009cc4:	f000 f91e 	bl	8009f04 <USBPD_HW_IF_CRC_Calculate>
    for (i = 0; i < Size; i += 2)
 8009cc8:	002c      	movs	r4, r5
    crc_value = USBPD_HW_IF_CRC_Calculate(pBuffer, Size);
 8009cca:	0007      	movs	r7, r0
    for (i = 0; i < Size; i += 2)
 8009ccc:	1b63      	subs	r3, r4, r5
 8009cce:	429e      	cmp	r6, r3
 8009cd0:	d8d8      	bhi.n	8009c84 <PHY_PreparePacket+0x20>
    value = PHY_Encode5b_Short(crc_value & 0x0000FFFF);
 8009cd2:	b2b8      	uxth	r0, r7
 8009cd4:	f7ff ff08 	bl	8009ae8 <PHY_Encode5b_Short>
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 8009cd8:	2214      	movs	r2, #20
    value = PHY_Encode5b_Short(crc_value & 0x0000FFFF);
 8009cda:	0001      	movs	r1, r0
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 8009cdc:	2000      	movs	r0, #0
 8009cde:	f7ff ff8b 	bl	8009bf8 <PHY_TxBuffer_Append>
    value = PHY_Encode5b_Short((crc_value >> 16) & 0x0000FFFF);
 8009ce2:	0c38      	lsrs	r0, r7, #16
 8009ce4:	f7ff ff00 	bl	8009ae8 <PHY_Encode5b_Short>
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 8009ce8:	2214      	movs	r2, #20
    value = PHY_Encode5b_Short((crc_value >> 16) & 0x0000FFFF);
 8009cea:	0001      	movs	r1, r0
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 8009cec:	2000      	movs	r0, #0
 8009cee:	f7ff ff83 	bl	8009bf8 <PHY_TxBuffer_Append>
    PHY_TxBuffer_Append(PortNum, KC_S_EOP, CODE_5B_ITEM1_BITSIZE);
 8009cf2:	2205      	movs	r2, #5
 8009cf4:	210d      	movs	r1, #13
 8009cf6:	2000      	movs	r0, #0
 8009cf8:	f7ff ff7e 	bl	8009bf8 <PHY_TxBuffer_Append>
  return FRAME_5B_BitSizeIsValid(*pOffset) ? USBPD_OK : USBPD_ERROR;
 8009cfc:	4b10      	ldr	r3, [pc, #64]	; (8009d40 <PHY_PreparePacket+0xdc>)
 8009cfe:	2000      	movs	r0, #0
 8009d00:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009d02:	2b14      	cmp	r3, #20
 8009d04:	d015      	beq.n	8009d32 <PHY_PreparePacket+0xce>
 8009d06:	2b55      	cmp	r3, #85	; 0x55
 8009d08:	d013      	beq.n	8009d32 <PHY_PreparePacket+0xce>
 8009d0a:	2b7d      	cmp	r3, #125	; 0x7d
 8009d0c:	d011      	beq.n	8009d32 <PHY_PreparePacket+0xce>
 8009d0e:	2ba5      	cmp	r3, #165	; 0xa5
 8009d10:	d00f      	beq.n	8009d32 <PHY_PreparePacket+0xce>
 8009d12:	2bcd      	cmp	r3, #205	; 0xcd
 8009d14:	d00d      	beq.n	8009d32 <PHY_PreparePacket+0xce>
 8009d16:	2bf5      	cmp	r3, #245	; 0xf5
 8009d18:	d00b      	beq.n	8009d32 <PHY_PreparePacket+0xce>
 8009d1a:	221e      	movs	r2, #30
 8009d1c:	32ff      	adds	r2, #255	; 0xff
 8009d1e:	4293      	cmp	r3, r2
 8009d20:	d007      	beq.n	8009d32 <PHY_PreparePacket+0xce>
 8009d22:	2246      	movs	r2, #70	; 0x46
 8009d24:	32ff      	adds	r2, #255	; 0xff
 8009d26:	4293      	cmp	r3, r2
 8009d28:	d003      	beq.n	8009d32 <PHY_PreparePacket+0xce>
 8009d2a:	226e      	movs	r2, #110	; 0x6e
 8009d2c:	32ff      	adds	r2, #255	; 0xff
 8009d2e:	4293      	cmp	r3, r2
 8009d30:	d1a6      	bne.n	8009c80 <PHY_PreparePacket+0x1c>
}
 8009d32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (!USBPD_PORT_IsValid(PortNum) || (!resetRequired && pBuffer == NULL))
 8009d34:	2800      	cmp	r0, #0
 8009d36:	d1a3      	bne.n	8009c80 <PHY_PreparePacket+0x1c>
 8009d38:	e7b5      	b.n	8009ca6 <PHY_PreparePacket+0x42>
 8009d3a:	46c0      	nop			; (mov r8, r8)
 8009d3c:	0800cd34 	.word	0x0800cd34
 8009d40:	20000354 	.word	0x20000354

08009d44 <USBPD_PHY_SendMessage>:
{
 8009d44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (PHY_Ports[PortNum].State != PHY_StateNone)
 8009d46:	247c      	movs	r4, #124	; 0x7c
 8009d48:	4344      	muls	r4, r0
{
 8009d4a:	0006      	movs	r6, r0
  if (PHY_Ports[PortNum].State != PHY_StateNone)
 8009d4c:	480c      	ldr	r0, [pc, #48]	; (8009d80 <USBPD_PHY_SendMessage+0x3c>)
 8009d4e:	1905      	adds	r5, r0, r4
 8009d50:	7a2f      	ldrb	r7, [r5, #8]
    return USBPD_BUSY;
 8009d52:	2003      	movs	r0, #3
  if (PHY_Ports[PortNum].State != PHY_StateNone)
 8009d54:	2f00      	cmp	r7, #0
 8009d56:	d112      	bne.n	8009d7e <USBPD_PHY_SendMessage+0x3a>
  res = PHY_PreparePacket(PortNum, Type, pBuffer, Size);
 8009d58:	b2db      	uxtb	r3, r3
 8009d5a:	0030      	movs	r0, r6
 8009d5c:	f7ff ff82 	bl	8009c64 <PHY_PreparePacket>
 8009d60:	0007      	movs	r7, r0
    return USBPD_ERROR;
 8009d62:	2002      	movs	r0, #2
  if (res == USBPD_OK)
 8009d64:	2f00      	cmp	r7, #0
 8009d66:	d10a      	bne.n	8009d7e <USBPD_PHY_SendMessage+0x3a>
    PHY_Ports[PortNum].State = PHY_StateBusyTxStart;
 8009d68:	2303      	movs	r3, #3
    res = USBPD_HW_IF_SendBuffer(PortNum, (uint8_t *)PHY_Ports[PortNum].TxBuffer,  PHY_Ports[PortNum].TxDatabitLen);
 8009d6a:	0021      	movs	r1, r4
    PHY_Ports[PortNum].State = PHY_StateBusyTxStart;
 8009d6c:	722b      	strb	r3, [r5, #8]
    res = USBPD_HW_IF_SendBuffer(PortNum, (uint8_t *)PHY_Ports[PortNum].TxBuffer,  PHY_Ports[PortNum].TxDatabitLen);
 8009d6e:	4b04      	ldr	r3, [pc, #16]	; (8009d80 <USBPD_PHY_SendMessage+0x3c>)
 8009d70:	310c      	adds	r1, #12
 8009d72:	1859      	adds	r1, r3, r1
 8009d74:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 8009d76:	0030      	movs	r0, r6
 8009d78:	f000 f8ce 	bl	8009f18 <USBPD_HW_IF_SendBuffer>
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009d7c:	722f      	strb	r7, [r5, #8]
}
 8009d7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009d80:	20000354 	.word	0x20000354

08009d84 <USBPD_PHY_ResetRequest>:
  if (USBPD_PHY_SendMessage(PortNum, Type, NULL, 0) != USBPD_OK)
 8009d84:	2300      	movs	r3, #0
{
 8009d86:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (USBPD_PHY_SendMessage(PortNum, Type, NULL, 0) != USBPD_OK)
 8009d88:	001a      	movs	r2, r3
{
 8009d8a:	0004      	movs	r4, r0
 8009d8c:	9101      	str	r1, [sp, #4]
  if (USBPD_PHY_SendMessage(PortNum, Type, NULL, 0) != USBPD_OK)
 8009d8e:	f7ff ffd9 	bl	8009d44 <USBPD_PHY_SendMessage>
 8009d92:	1e06      	subs	r6, r0, #0
 8009d94:	d116      	bne.n	8009dc4 <USBPD_PHY_ResetRequest+0x40>
  PHY_Ports[PortNum].State = PHY_StateBusy;
 8009d96:	257c      	movs	r5, #124	; 0x7c
 8009d98:	2202      	movs	r2, #2
 8009d9a:	4365      	muls	r5, r4
 8009d9c:	4f0a      	ldr	r7, [pc, #40]	; (8009dc8 <USBPD_PHY_ResetRequest+0x44>)
  PHY_TxBuffer_Reset(PortNum);
 8009d9e:	0020      	movs	r0, r4
  PHY_Ports[PortNum].State = PHY_StateBusy;
 8009da0:	197b      	adds	r3, r7, r5
 8009da2:	721a      	strb	r2, [r3, #8]
  PHY_TxBuffer_Reset(PortNum);
 8009da4:	f7ff fee0 	bl	8009b68 <PHY_TxBuffer_Reset>
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_ResetCompleted != NULL)
 8009da8:	59eb      	ldr	r3, [r5, r7]
 8009daa:	689b      	ldr	r3, [r3, #8]
 8009dac:	2b00      	cmp	r3, #0
 8009dae:	d002      	beq.n	8009db6 <USBPD_PHY_ResetRequest+0x32>
    PHY_Ports[PortNum].cbs->USBPD_PHY_ResetCompleted(PortNum, Type);
 8009db0:	9901      	ldr	r1, [sp, #4]
 8009db2:	0020      	movs	r0, r4
 8009db4:	4798      	blx	r3
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009db6:	237c      	movs	r3, #124	; 0x7c
 8009db8:	435c      	muls	r4, r3
 8009dba:	2300      	movs	r3, #0
 8009dbc:	193c      	adds	r4, r7, r4
 8009dbe:	7223      	strb	r3, [r4, #8]
}
 8009dc0:	0030      	movs	r0, r6
 8009dc2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    return USBPD_ERROR;
 8009dc4:	2602      	movs	r6, #2
 8009dc6:	e7fb      	b.n	8009dc0 <USBPD_PHY_ResetRequest+0x3c>
 8009dc8:	20000354 	.word	0x20000354

08009dcc <PHY_SopDetect>:
    temp = OrderSets[index] ^ OrderSet;
 8009dcc:	4b15      	ldr	r3, [pc, #84]	; (8009e24 <PHY_SopDetect+0x58>)
{
 8009dce:	b5f0      	push	{r4, r5, r6, r7, lr}
    temp = OrderSets[index] ^ OrderSet;
 8009dd0:	3310      	adds	r3, #16
      if (temp & 0x00007C00)
 8009dd2:	26f8      	movs	r6, #248	; 0xf8
      if (temp & 0x000003E0)
 8009dd4:	27f8      	movs	r7, #248	; 0xf8
  for (index = 0; index < OS_NUM; index++)
 8009dd6:	2000      	movs	r0, #0
    temp = OrderSets[index] ^ OrderSet;
 8009dd8:	469c      	mov	ip, r3
      if (temp & 0x00007C00)
 8009dda:	01f6      	lsls	r6, r6, #7
      if (temp & 0x000003E0)
 8009ddc:	00bf      	lsls	r7, r7, #2
    temp = OrderSets[index] ^ OrderSet;
 8009dde:	4662      	mov	r2, ip
 8009de0:	0083      	lsls	r3, r0, #2
 8009de2:	589b      	ldr	r3, [r3, r2]
 8009de4:	001a      	movs	r2, r3
 8009de6:	404a      	eors	r2, r1
    if (temp)
 8009de8:	428b      	cmp	r3, r1
 8009dea:	d014      	beq.n	8009e16 <PHY_SopDetect+0x4a>
      if (temp & 0x000F8000)
 8009dec:	23f8      	movs	r3, #248	; 0xf8
 8009dee:	0014      	movs	r4, r2
 8009df0:	031b      	lsls	r3, r3, #12
 8009df2:	401c      	ands	r4, r3
    count = 0;
 8009df4:	0023      	movs	r3, r4
 8009df6:	1e5d      	subs	r5, r3, #1
 8009df8:	41ab      	sbcs	r3, r5
      if (temp & 0x00007C00)
 8009dfa:	4232      	tst	r2, r6
 8009dfc:	d002      	beq.n	8009e04 <PHY_SopDetect+0x38>
      if (count > 1)
 8009dfe:	2c00      	cmp	r4, #0
 8009e00:	d10b      	bne.n	8009e1a <PHY_SopDetect+0x4e>
 8009e02:	2301      	movs	r3, #1
      if (temp & 0x000003E0)
 8009e04:	423a      	tst	r2, r7
 8009e06:	d002      	beq.n	8009e0e <PHY_SopDetect+0x42>
      if (count > 1)
 8009e08:	2b01      	cmp	r3, #1
 8009e0a:	d006      	beq.n	8009e1a <PHY_SopDetect+0x4e>
 8009e0c:	2301      	movs	r3, #1
      if (temp & 0x0000001F)
 8009e0e:	06d2      	lsls	r2, r2, #27
 8009e10:	d001      	beq.n	8009e16 <PHY_SopDetect+0x4a>
      if (count > 1)
 8009e12:	2b01      	cmp	r3, #1
 8009e14:	d001      	beq.n	8009e1a <PHY_SopDetect+0x4e>
    type = (USBPD_SOPType_TypeDef)index;
 8009e16:	b2c0      	uxtb	r0, r0
}
 8009e18:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (index = 0; index < OS_NUM; index++)
 8009e1a:	3001      	adds	r0, #1
 8009e1c:	2807      	cmp	r0, #7
 8009e1e:	d1de      	bne.n	8009dde <PHY_SopDetect+0x12>
  USBPD_SOPType_TypeDef type = USBPD_SOPTYPE_INVALID;
 8009e20:	30f8      	adds	r0, #248	; 0xf8
 8009e22:	e7f9      	b.n	8009e18 <PHY_SopDetect+0x4c>
 8009e24:	0800cd34 	.word	0x0800cd34

08009e28 <PHY_Rx_Accumulate>:
{
 8009e28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009e2a:	0006      	movs	r6, r0
  switch (pRxData->Status)
 8009e2c:	207c      	movs	r0, #124	; 0x7c
 8009e2e:	4370      	muls	r0, r6
 8009e30:	4c32      	ldr	r4, [pc, #200]	; (8009efc <PHY_Rx_Accumulate+0xd4>)
 8009e32:	1825      	adds	r5, r4, r0
 8009e34:	002f      	movs	r7, r5
 8009e36:	3740      	adds	r7, #64	; 0x40
 8009e38:	783b      	ldrb	r3, [r7, #0]
 8009e3a:	2b02      	cmp	r3, #2
 8009e3c:	d00c      	beq.n	8009e58 <PHY_Rx_Accumulate+0x30>
 8009e3e:	2b03      	cmp	r3, #3
 8009e40:	d034      	beq.n	8009eac <PHY_Rx_Accumulate+0x84>
 8009e42:	2b00      	cmp	r3, #0
 8009e44:	d151      	bne.n	8009eea <PHY_Rx_Accumulate+0xc2>
    pRxData->OrderSet = data;
 8009e46:	6469      	str	r1, [r5, #68]	; 0x44
    pRxData->Status = USBPD_PHY_RX_STATUS_SOP_DETECTING;
 8009e48:	3302      	adds	r3, #2
      pRxData->Status = USBPD_PHY_RX_STATUS_MESSAGE_READY;
 8009e4a:	703b      	strb	r3, [r7, #0]
  return pRxData->Status;
 8009e4c:	237c      	movs	r3, #124	; 0x7c
 8009e4e:	435e      	muls	r6, r3
 8009e50:	19a4      	adds	r4, r4, r6
 8009e52:	3440      	adds	r4, #64	; 0x40
 8009e54:	7820      	ldrb	r0, [r4, #0]
}
 8009e56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pRxData->OrderSet |= data<<10;
 8009e58:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8009e5a:	0289      	lsls	r1, r1, #10
 8009e5c:	4319      	orrs	r1, r3
 8009e5e:	6469      	str	r1, [r5, #68]	; 0x44
    pRxData->MsgType = PHY_SopDetect(PortNum, pRxData->OrderSet);
 8009e60:	0030      	movs	r0, r6
 8009e62:	f7ff ffb3 	bl	8009dcc <PHY_SopDetect>
 8009e66:	3548      	adds	r5, #72	; 0x48
 8009e68:	7028      	strb	r0, [r5, #0]
    switch(pRxData->MsgType)
 8009e6a:	2806      	cmp	r0, #6
 8009e6c:	d81c      	bhi.n	8009ea8 <PHY_Rx_Accumulate+0x80>
 8009e6e:	237c      	movs	r3, #124	; 0x7c
      if(PHY_Ports[PortNum].SupportedSOP & 0x1E)
 8009e70:	4373      	muls	r3, r6
 8009e72:	18e3      	adds	r3, r4, r3
    switch(pRxData->MsgType)
 8009e74:	f7fb fd9e 	bl	80059b4 <__gnu_thumb1_case_uqi>
 8009e78:	0f0f0f0f 	.word	0x0f0f0f0f
 8009e7c:	040f      	.short	0x040f
 8009e7e:	08          	.byte	0x08
 8009e7f:	00          	.byte	0x00
      pRxData->Status = USBPD_PHY_RX_STATUS_MESSAGE_READY;
 8009e80:	3340      	adds	r3, #64	; 0x40
 8009e82:	2204      	movs	r2, #4
        pRxData->Data[pRxData->DataCount++] = data4b_temp;
 8009e84:	701a      	strb	r2, [r3, #0]
 8009e86:	e7e1      	b.n	8009e4c <PHY_Rx_Accumulate+0x24>
      if(PHY_Ports[PortNum].SupportedSOP & 0x1E)
 8009e88:	221e      	movs	r2, #30
 8009e8a:	6f99      	ldr	r1, [r3, #120]	; 0x78
 8009e8c:	3340      	adds	r3, #64	; 0x40
 8009e8e:	4211      	tst	r1, r2
 8009e90:	d1f7      	bne.n	8009e82 <PHY_Rx_Accumulate+0x5a>
        pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_UNSUPPORTED_SOP;
 8009e92:	2206      	movs	r2, #6
 8009e94:	e7f6      	b.n	8009e84 <PHY_Rx_Accumulate+0x5c>
      if(PHY_Ports[PortNum].SupportedSOP & (0x1 << pRxData->MsgType))
 8009e96:	2101      	movs	r1, #1
 8009e98:	4081      	lsls	r1, r0
 8009e9a:	000a      	movs	r2, r1
 8009e9c:	6f99      	ldr	r1, [r3, #120]	; 0x78
 8009e9e:	3340      	adds	r3, #64	; 0x40
 8009ea0:	4211      	tst	r1, r2
 8009ea2:	d0f6      	beq.n	8009e92 <PHY_Rx_Accumulate+0x6a>
        pRxData->Status = USBPD_PHY_RX_STATUS_DATA;
 8009ea4:	2203      	movs	r2, #3
 8009ea6:	e7ed      	b.n	8009e84 <PHY_Rx_Accumulate+0x5c>
      pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_INVALID_SOP;
 8009ea8:	2307      	movs	r3, #7
 8009eaa:	e7ce      	b.n	8009e4a <PHY_Rx_Accumulate+0x22>
    if ((data & CODE_5B_ITEM1_MASK) == KC_S_EOP)
 8009eac:	201f      	movs	r0, #31
 8009eae:	000a      	movs	r2, r1
 8009eb0:	4002      	ands	r2, r0
 8009eb2:	2a0d      	cmp	r2, #13
 8009eb4:	d101      	bne.n	8009eba <PHY_Rx_Accumulate+0x92>
      pRxData->Status = USBPD_PHY_RX_STATUS_MESSAGE_READY;
 8009eb6:	2304      	movs	r3, #4
 8009eb8:	e7c7      	b.n	8009e4a <PHY_Rx_Accumulate+0x22>
  v0 = decoding5b4b[(value >>  0) & 0x1F]; /* decoding first nibble */
 8009eba:	4b11      	ldr	r3, [pc, #68]	; (8009f00 <PHY_Rx_Accumulate+0xd8>)
  v1 = decoding5b4b[(value >>  5) & 0x1F]; /* decoding second nibble */
 8009ebc:	0949      	lsrs	r1, r1, #5
  v0 = decoding5b4b[(value >>  0) & 0x1F]; /* decoding first nibble */
 8009ebe:	332c      	adds	r3, #44	; 0x2c
 8009ec0:	5c9a      	ldrb	r2, [r3, r2]
  v1 = decoding5b4b[(value >>  5) & 0x1F]; /* decoding second nibble */
 8009ec2:	4001      	ands	r1, r0
 8009ec4:	5c59      	ldrb	r1, [r3, r1]
  if (v0 == CODE_5B_INVALID || v1 == CODE_5B_INVALID) 
 8009ec6:	2aff      	cmp	r2, #255	; 0xff
 8009ec8:	d009      	beq.n	8009ede <PHY_Rx_Accumulate+0xb6>
 8009eca:	29ff      	cmp	r1, #255	; 0xff
 8009ecc:	d007      	beq.n	8009ede <PHY_Rx_Accumulate+0xb6>
        pRxData->Data[pRxData->DataCount++] = data4b_temp;
 8009ece:	6f6b      	ldr	r3, [r5, #116]	; 0x74
  return v0 | (v1<<4);
 8009ed0:	0109      	lsls	r1, r1, #4
        pRxData->Data[pRxData->DataCount++] = data4b_temp;
 8009ed2:	1c58      	adds	r0, r3, #1
 8009ed4:	18eb      	adds	r3, r5, r3
 8009ed6:	6768      	str	r0, [r5, #116]	; 0x74
 8009ed8:	3349      	adds	r3, #73	; 0x49
  return v0 | (v1<<4);
 8009eda:	430a      	orrs	r2, r1
 8009edc:	e7d2      	b.n	8009e84 <PHY_Rx_Accumulate+0x5c>
        pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_INVALID_SYMBOL;
 8009ede:	237c      	movs	r3, #124	; 0x7c
 8009ee0:	4373      	muls	r3, r6
 8009ee2:	18e3      	adds	r3, r4, r3
 8009ee4:	3340      	adds	r3, #64	; 0x40
 8009ee6:	2208      	movs	r2, #8
 8009ee8:	e7cc      	b.n	8009e84 <PHY_Rx_Accumulate+0x5c>
    pRxData->DataCount = 0;
 8009eea:	2100      	movs	r1, #0
    memset(pRxData->Data, 0, __RX_DATA_LEN);
 8009eec:	3049      	adds	r0, #73	; 0x49
    pRxData->DataCount = 0;
 8009eee:	6769      	str	r1, [r5, #116]	; 0x74
    memset(pRxData->Data, 0, __RX_DATA_LEN);
 8009ef0:	1820      	adds	r0, r4, r0
 8009ef2:	2228      	movs	r2, #40	; 0x28
 8009ef4:	f002 fde3 	bl	800cabe <memset>
    break;
 8009ef8:	e7a8      	b.n	8009e4c <PHY_Rx_Accumulate+0x24>
 8009efa:	46c0      	nop			; (mov r8, r8)
 8009efc:	20000354 	.word	0x20000354
 8009f00:	0800cd34 	.word	0x0800cd34

08009f04 <USBPD_HW_IF_CRC_Calculate>:
  * @param  *pBuffer    Pointer to the input data buffer
  * @param  len         Input data buffer length
  * @retval uint32_t    CRC value
  */
uint32_t USBPD_HW_IF_CRC_Calculate(uint8_t *pBuffer, uint8_t len)
{
 8009f04:	b510      	push	{r4, lr}
 8009f06:	000a      	movs	r2, r1
  uint32_t crc;

  crc = HAL_CRC_Calculate(&hcrc, (uint32_t *)pBuffer, len);
 8009f08:	0001      	movs	r1, r0
 8009f0a:	4802      	ldr	r0, [pc, #8]	; (8009f14 <USBPD_HW_IF_CRC_Calculate+0x10>)
 8009f0c:	f7fd fc27 	bl	800775e <HAL_CRC_Calculate>
  crc ^= 0xFFFFFFFF;
 8009f10:	43c0      	mvns	r0, r0
  return crc;
}
 8009f12:	bd10      	pop	{r4, pc}
 8009f14:	20001cdc 	.word	0x20001cdc

08009f18 <USBPD_HW_IF_SendBuffer>:
* @param  *pBuffer      Pointer to the TX data buffer
* @param  Bitsize:      Amount of bits to be transmitted
* @retval USBPD status
*/
USBPD_StatusTypeDef USBPD_HW_IF_SendBuffer(uint8_t PortNum, uint8_t *pBuffer, uint32_t Bitsize)
{
 8009f18:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check if the port is still receiving */
  if (Ports[PortNum].State == HAL_USBPD_PORT_STATE_BUSY_RX)
 8009f1a:	24f0      	movs	r4, #240	; 0xf0
 8009f1c:	0064      	lsls	r4, r4, #1
 8009f1e:	4344      	muls	r4, r0
 8009f20:	4b17      	ldr	r3, [pc, #92]	; (8009f80 <USBPD_HW_IF_SendBuffer+0x68>)
{
 8009f22:	b085      	sub	sp, #20
  if (Ports[PortNum].State == HAL_USBPD_PORT_STATE_BUSY_RX)
 8009f24:	191c      	adds	r4, r3, r4
 8009f26:	7e63      	ldrb	r3, [r4, #25]
{
 8009f28:	0006      	movs	r6, r0
 8009f2a:	9103      	str	r1, [sp, #12]
 8009f2c:	9202      	str	r2, [sp, #8]
    return USBPD_BUSY;
 8009f2e:	2003      	movs	r0, #3
  if (Ports[PortNum].State == HAL_USBPD_PORT_STATE_BUSY_RX)
 8009f30:	2b04      	cmp	r3, #4
 8009f32:	d022      	beq.n	8009f7a <USBPD_HW_IF_SendBuffer+0x62>

  uint8_t *pTxBuffer = (uint8_t *)Ports[PortNum].pTxBuffPtr;
  uint16_t size = DIV_ROUND_UP(Bitsize, 8)+TX_PREAMBLE_SIZE;
 8009f34:	0013      	movs	r3, r2
  uint8_t *pTxBuffer = (uint8_t *)Ports[PortNum].pTxBuffPtr;
 8009f36:	6865      	ldr	r5, [r4, #4]
  uint16_t size = DIV_ROUND_UP(Bitsize, 8)+TX_PREAMBLE_SIZE;
 8009f38:	3307      	adds	r3, #7
 8009f3a:	40c3      	lsrs	r3, r0
 8009f3c:	002f      	movs	r7, r5
 8009f3e:	3308      	adds	r3, #8
 8009f40:	3708      	adds	r7, #8
 8009f42:	b29b      	uxth	r3, r3

  memset((uint8_t *)pTxBuffer, 0x00, TX_BUFFER_SIZE);
 8009f44:	2230      	movs	r2, #48	; 0x30
 8009f46:	2100      	movs	r1, #0
 8009f48:	0038      	movs	r0, r7
  uint16_t size = DIV_ROUND_UP(Bitsize, 8)+TX_PREAMBLE_SIZE;
 8009f4a:	9301      	str	r3, [sp, #4]
  memset((uint8_t *)pTxBuffer, 0x00, TX_BUFFER_SIZE);
 8009f4c:	f002 fdb7 	bl	800cabe <memset>
  memset((uint8_t *)pTxBuffer, TX_PREAMBLE, TX_PREAMBLE_SIZE);                          /* preamble is added */
 8009f50:	2208      	movs	r2, #8
 8009f52:	21aa      	movs	r1, #170	; 0xaa
 8009f54:	0028      	movs	r0, r5
 8009f56:	f002 fdb2 	bl	800cabe <memset>
  memcpy((uint8_t *)(pTxBuffer+TX_PREAMBLE_SIZE), pBuffer, (size-TX_PREAMBLE_SIZE));    /* data are added */
 8009f5a:	9a01      	ldr	r2, [sp, #4]
 8009f5c:	9903      	ldr	r1, [sp, #12]
 8009f5e:	3a08      	subs	r2, #8
 8009f60:	0038      	movs	r0, r7
 8009f62:	f002 fda3 	bl	800caac <memcpy>

  /* Spare clock cycles at the end of transmission are calculated */
  Ports[PortNum].TxSpareBits = (Bitsize % 8);
 8009f66:	2307      	movs	r3, #7
 8009f68:	9a02      	ldr	r2, [sp, #8]
 8009f6a:	342a      	adds	r4, #42	; 0x2a
 8009f6c:	4013      	ands	r3, r2
 8009f6e:	7023      	strb	r3, [r4, #0]

  /* Packet is ready to be sent to SPI */
  USBPD_StatusTypeDef ret = USBPD_OK;
  ret = STUSB16xx_HW_IF_Send_Packet(PortNum, pTxBuffer, size);
 8009f70:	9a01      	ldr	r2, [sp, #4]
 8009f72:	0029      	movs	r1, r5
 8009f74:	0030      	movs	r0, r6
 8009f76:	f001 fba9 	bl	800b6cc <STUSB16xx_HW_IF_Send_Packet>
  return ret;
}
 8009f7a:	b005      	add	sp, #20
 8009f7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009f7e:	46c0      	nop			; (mov r8, r8)
 8009f80:	20000058 	.word	0x20000058

08009f84 <USBPD_HW_IF_Send_BIST_Pattern>:
* @brief  It sends BIST pattern  
* @param  PortNum       The port index
* @retval USBPD status
*/
USBPD_StatusTypeDef USBPD_HW_IF_Send_BIST_Pattern(uint8_t PortNum)
{
 8009f84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USBPD_StatusTypeDef ret = USBPD_ERROR;
  
  /* BIST Carrier mode flag set */
  Ports[PortNum].State=HAL_USBPD_PORT_STATE_BIST;
 8009f86:	24f0      	movs	r4, #240	; 0xf0
 8009f88:	0064      	lsls	r4, r4, #1
 8009f8a:	4344      	muls	r4, r0
 8009f8c:	4b15      	ldr	r3, [pc, #84]	; (8009fe4 <USBPD_HW_IF_Send_BIST_Pattern+0x60>)
{
 8009f8e:	0005      	movs	r5, r0
  Ports[PortNum].State=HAL_USBPD_PORT_STATE_BIST;
 8009f90:	191f      	adds	r7, r3, r4
 8009f92:	2308      	movs	r3, #8
  STUSB16xx_HW_IF_Set_DMA_Circular_Mode(PortNum);
  
  /* Set the SPI in TX mode */
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
  
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 8009f94:	0026      	movs	r6, r4
  Ports[PortNum].State=HAL_USBPD_PORT_STATE_BIST;
 8009f96:	767b      	strb	r3, [r7, #25]
  memset(Ports[PortNum].pTxBuffPtr, 0xAA, TX_BUFFER_LEN*2);
 8009f98:	2238      	movs	r2, #56	; 0x38
 8009f9a:	21aa      	movs	r1, #170	; 0xaa
 8009f9c:	6878      	ldr	r0, [r7, #4]
 8009f9e:	f002 fd8e 	bl	800cabe <memset>
  STUSB16xx_HW_IF_Set_DMA_Circular_Mode(PortNum);
 8009fa2:	0028      	movs	r0, r5
 8009fa4:	f001 f916 	bl	800b1d4 <STUSB16xx_HW_IF_Set_DMA_Circular_Mode>
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 8009fa8:	2100      	movs	r1, #0
 8009faa:	0028      	movs	r0, r5
 8009fac:	f001 f936 	bl	800b21c <STUSB16xx_HW_IF_Switch_Mode>
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 8009fb0:	4b0c      	ldr	r3, [pc, #48]	; (8009fe4 <USBPD_HW_IF_Send_BIST_Pattern+0x60>)
 8009fb2:	3640      	adds	r6, #64	; 0x40
 8009fb4:	18f6      	adds	r6, r6, r3
 8009fb6:	0030      	movs	r0, r6
 8009fb8:	f7fe fcb2 	bl	8008920 <HAL_SPI_DMAStop>
  HAL_DMA_Abort(&Ports[PortNum].hdmarx);
 8009fbc:	0020      	movs	r0, r4
 8009fbe:	4b09      	ldr	r3, [pc, #36]	; (8009fe4 <USBPD_HW_IF_Send_BIST_Pattern+0x60>)
 8009fc0:	30e8      	adds	r0, #232	; 0xe8
 8009fc2:	18c0      	adds	r0, r0, r3
 8009fc4:	f7fd fcd2 	bl	800796c <HAL_DMA_Abort>
  __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 8009fc8:	4b07      	ldr	r3, [pc, #28]	; (8009fe8 <USBPD_HW_IF_Send_BIST_Pattern+0x64>)
 8009fca:	4a08      	ldr	r2, [pc, #32]	; (8009fec <USBPD_HW_IF_Send_BIST_Pattern+0x68>)
  
  /* Send TX Buffer by SPI DMA */
  HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, (uint8_t*)(Ports[PortNum].pTxBuffPtr), TX_BUFFER_LEN*2);
 8009fcc:	6879      	ldr	r1, [r7, #4]
  __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 8009fce:	605a      	str	r2, [r3, #4]
  HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, (uint8_t*)(Ports[PortNum].pTxBuffPtr), TX_BUFFER_LEN*2);
 8009fd0:	0030      	movs	r0, r6
 8009fd2:	2238      	movs	r2, #56	; 0x38
 8009fd4:	f7fe fa92 	bl	80084fc <HAL_SPI_Transmit_DMA>
  
  /* Start transmission */
  STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_SET);
 8009fd8:	0028      	movs	r0, r5
 8009fda:	2101      	movs	r1, #1
 8009fdc:	f001 f92c 	bl	800b238 <STUSB16xx_HW_IF_TX_EN_Status>
  
  ret = USBPD_OK;
  return ret;
}
 8009fe0:	2000      	movs	r0, #0
 8009fe2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009fe4:	20000058 	.word	0x20000058
 8009fe8:	40020000 	.word	0x40020000
 8009fec:	0fffffff 	.word	0x0fffffff

08009ff0 <USBPD_HW_IF_GPIO_Off>:
 * @brief   It resets the state of GPIO pin
 * @param   gpio The GPIO structure
 * @retval  None
 */
void USBPD_HW_IF_GPIO_Off(USBPD_BSP_GPIOPins_TypeDef gpio)
{
 8009ff0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  HAL_GPIO_WritePin(gpio.GPIOx, gpio.GPIO_Pin, PinState);
 8009ff2:	b289      	uxth	r1, r1
 8009ff4:	2200      	movs	r2, #0
 8009ff6:	f7fd fd91 	bl	8007b1c <HAL_GPIO_WritePin>
  /* Resets the pin */
  USBPD_HW_IF_GPIO_Set(gpio, GPIO_PIN_RESET);
}
 8009ffa:	b005      	add	sp, #20
 8009ffc:	bd00      	pop	{pc}
	...

0800a000 <PHY_HW_IF_ADCAnalogGPIO_Init>:
{
  GPIO_InitTypeDef      GPIO_InitStruct;
  uint8_t ch = 0;

  /* Configure all GPIO port pins in Analog mode */
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800a000:	2303      	movs	r3, #3
{
 800a002:	b510      	push	{r4, lr}
 800a004:	b086      	sub	sp, #24
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800a006:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a008:	2300      	movs	r3, #0

  for(ch=0;ch<USBPD_ADCn;ch++)
  {
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a00a:	4c0b      	ldr	r4, [pc, #44]	; (800a038 <PHY_HW_IF_ADCAnalogGPIO_Init+0x38>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a00c:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a00e:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 800a010:	3310      	adds	r3, #16
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a012:	0020      	movs	r0, r4
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 800a014:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a016:	f7fd fcbf 	bl	8007998 <HAL_GPIO_Init>
 800a01a:	2090      	movs	r0, #144	; 0x90
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 800a01c:	2380      	movs	r3, #128	; 0x80
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a01e:	a901      	add	r1, sp, #4
 800a020:	05c0      	lsls	r0, r0, #23
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 800a022:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a024:	f7fd fcb8 	bl	8007998 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 800a028:	2301      	movs	r3, #1
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a02a:	a901      	add	r1, sp, #4
 800a02c:	0020      	movs	r0, r4
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 800a02e:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a030:	f7fd fcb2 	bl	8007998 <HAL_GPIO_Init>
  }
}
 800a034:	b006      	add	sp, #24
 800a036:	bd10      	pop	{r4, pc}
 800a038:	48000800 	.word	0x48000800

0800a03c <PHY_HW_IF_ADCDMA_Init>:
/**
  * @brief  Initialization of the ADC DMA
  * @retval None
  */
void PHY_HW_IF_ADCDMA_Init(void)
{
 800a03c:	b510      	push	{r4, lr}
  /* Configuration of DMA parameters */
  DmaHandle.Instance = ADCx_DMA;
 800a03e:	4b0e      	ldr	r3, [pc, #56]	; (800a078 <PHY_HW_IF_ADCDMA_Init+0x3c>)
 800a040:	4c0e      	ldr	r4, [pc, #56]	; (800a07c <PHY_HW_IF_ADCDMA_Init+0x40>)
 800a042:	6023      	str	r3, [r4, #0]

  DmaHandle.Init.Direction           = DMA_PERIPH_TO_MEMORY;
 800a044:	2300      	movs	r3, #0
 800a046:	6063      	str	r3, [r4, #4]
  DmaHandle.Init.PeriphInc           = DMA_PINC_DISABLE;
 800a048:	60a3      	str	r3, [r4, #8]
  DmaHandle.Init.MemInc              = DMA_MINC_ENABLE;
 800a04a:	3380      	adds	r3, #128	; 0x80
 800a04c:	60e3      	str	r3, [r4, #12]
  DmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;   /* Transfer from ADC by half-word to match with ADC configuration: ADC resolution 10 or 12 bits */
 800a04e:	3380      	adds	r3, #128	; 0x80
 800a050:	6123      	str	r3, [r4, #16]
  DmaHandle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;       /* Transfer to memory by half-word to match with buffer variable type: half-word */
 800a052:	2380      	movs	r3, #128	; 0x80
 800a054:	011b      	lsls	r3, r3, #4
 800a056:	6163      	str	r3, [r4, #20]
  DmaHandle.Init.Mode                = DMA_CIRCULAR;              /* DMA in circular mode to match with ADC configuration: DMA continuous requests */
 800a058:	2320      	movs	r3, #32
 800a05a:	61a3      	str	r3, [r4, #24]
  DmaHandle.Init.Priority            = DMA_PRIORITY_HIGH;
 800a05c:	2380      	movs	r3, #128	; 0x80

  /* Initialization of the DMA associated to the peripheral */
  HAL_DMA_DeInit(&DmaHandle);
 800a05e:	0020      	movs	r0, r4
  DmaHandle.Init.Priority            = DMA_PRIORITY_HIGH;
 800a060:	019b      	lsls	r3, r3, #6
 800a062:	61e3      	str	r3, [r4, #28]
  HAL_DMA_DeInit(&DmaHandle);
 800a064:	f7fd fc20 	bl	80078a8 <HAL_DMA_DeInit>
  HAL_DMA_Init(&DmaHandle);
 800a068:	0020      	movs	r0, r4
 800a06a:	f7fd fbe7 	bl	800783c <HAL_DMA_Init>

  /* Association of the initialized DMA handle to the ADC handle */
  __HAL_LINKDMA(&usbpdm1_hadc, DMA_Handle, DmaHandle);
 800a06e:	4b04      	ldr	r3, [pc, #16]	; (800a080 <PHY_HW_IF_ADCDMA_Init+0x44>)
 800a070:	63dc      	str	r4, [r3, #60]	; 0x3c
 800a072:	6263      	str	r3, [r4, #36]	; 0x24
}
 800a074:	bd10      	pop	{r4, pc}
 800a076:	46c0      	nop			; (mov r8, r8)
 800a078:	40020008 	.word	0x40020008
 800a07c:	20001d3c 	.word	0x20001d3c
 800a080:	20001c84 	.word	0x20001c84

0800a084 <PHY_HW_IF_RX_Stop>:
  * @brief  PHY accomplishes the data receiving phase
  * @param  PortNum The port index
  * @retval None
  */
void PHY_HW_IF_RX_Stop(uint8_t PortNum)
{
 800a084:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a086:	0005      	movs	r5, r0
   * 3 - PHY_HW_IF_RX_Stop function is ongoing
   */

  UnwrapData_TypeDef* ud = &(Ports[PortNum].unwrapdata);
  
  if (ud->exed_flag == 3)
 800a088:	20f0      	movs	r0, #240	; 0xf0
 800a08a:	0040      	lsls	r0, r0, #1
 800a08c:	4368      	muls	r0, r5
 800a08e:	4c49      	ldr	r4, [pc, #292]	; (800a1b4 <PHY_HW_IF_RX_Stop+0x130>)
 800a090:	0002      	movs	r2, r0
 800a092:	1826      	adds	r6, r4, r0
 800a094:	0033      	movs	r3, r6
 800a096:	3279      	adds	r2, #121	; 0x79
 800a098:	332c      	adds	r3, #44	; 0x2c
 800a09a:	32ff      	adds	r2, #255	; 0xff
 800a09c:	781f      	ldrb	r7, [r3, #0]
{
 800a09e:	b089      	sub	sp, #36	; 0x24
 800a0a0:	1912      	adds	r2, r2, r4
  if (ud->exed_flag == 3)
 800a0a2:	9001      	str	r0, [sp, #4]
 800a0a4:	9202      	str	r2, [sp, #8]
 800a0a6:	2f03      	cmp	r7, #3
 800a0a8:	d105      	bne.n	800a0b6 <PHY_HW_IF_RX_Stop+0x32>
  {
    HAL_TIM_OC_Stop_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a0aa:	2100      	movs	r1, #0
 800a0ac:	0010      	movs	r0, r2
 800a0ae:	f7fe ffb1 	bl	8009014 <HAL_TIM_OC_Stop_IT>
  /* Callback core phy completed */
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed != NULL)
  {
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed(PortNum);
  }
}
 800a0b2:	b009      	add	sp, #36	; 0x24
 800a0b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  ud->exed_flag = 3;
 800a0b6:	2203      	movs	r2, #3
{
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Disable the TIM Capture/Compare 1 interrupt */
  __HAL_TIM_DISABLE_IT(htim, tim_it);
 800a0b8:	36fc      	adds	r6, #252	; 0xfc
 800a0ba:	6ff0      	ldr	r0, [r6, #124]	; 0x7c
  ud->exed_flag = 3;
 800a0bc:	701a      	strb	r2, [r3, #0]
  __HAL_TIM_DISABLE_IT(htim, tim_it);
 800a0be:	68c3      	ldr	r3, [r0, #12]
 800a0c0:	3a01      	subs	r2, #1
 800a0c2:	4393      	bics	r3, r2

  /* Disable the Output compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 800a0c4:	2200      	movs	r2, #0
  __HAL_TIM_DISABLE_IT(htim, tim_it);
 800a0c6:	60c3      	str	r3, [r0, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 800a0c8:	0011      	movs	r1, r2
 800a0ca:	f7fe ff57 	bl	8008f7c <TIM_CCxChannelCmd>

  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800a0ce:	6ff3      	ldr	r3, [r6, #124]	; 0x7c
 800a0d0:	4a39      	ldr	r2, [pc, #228]	; (800a1b8 <PHY_HW_IF_RX_Stop+0x134>)
 800a0d2:	483a      	ldr	r0, [pc, #232]	; (800a1bc <PHY_HW_IF_RX_Stop+0x138>)
 800a0d4:	4293      	cmp	r3, r2
 800a0d6:	d008      	beq.n	800a0ea <PHY_HW_IF_RX_Stop+0x66>
 800a0d8:	4a39      	ldr	r2, [pc, #228]	; (800a1c0 <PHY_HW_IF_RX_Stop+0x13c>)
 800a0da:	4293      	cmp	r3, r2
 800a0dc:	d005      	beq.n	800a0ea <PHY_HW_IF_RX_Stop+0x66>
 800a0de:	4a39      	ldr	r2, [pc, #228]	; (800a1c4 <PHY_HW_IF_RX_Stop+0x140>)
 800a0e0:	4293      	cmp	r3, r2
 800a0e2:	d002      	beq.n	800a0ea <PHY_HW_IF_RX_Stop+0x66>
 800a0e4:	4a38      	ldr	r2, [pc, #224]	; (800a1c8 <PHY_HW_IF_RX_Stop+0x144>)
 800a0e6:	4293      	cmp	r3, r2
 800a0e8:	d102      	bne.n	800a0f0 <PHY_HW_IF_RX_Stop+0x6c>
  {
    /* Disable the Main Ouput */
    htim->Instance->BDTR &= ~(TIM_BDTR_MOE);
 800a0ea:	6c59      	ldr	r1, [r3, #68]	; 0x44
 800a0ec:	4001      	ands	r1, r0
 800a0ee:	6459      	str	r1, [r3, #68]	; 0x44
  }
  /* Disable the Peripheral */
  htim->Instance->BDTR &= ~(TIM_BDTR_MOE);
 800a0f0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a0f2:	4002      	ands	r2, r0
 800a0f4:	645a      	str	r2, [r3, #68]	; 0x44
  if (ud_ef == 0)
 800a0f6:	2f00      	cmp	r7, #0
 800a0f8:	d13f      	bne.n	800a17a <PHY_HW_IF_RX_Stop+0xf6>
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 800a0fa:	23f0      	movs	r3, #240	; 0xf0
 800a0fc:	005b      	lsls	r3, r3, #1
 800a0fe:	436b      	muls	r3, r5
 800a100:	18e4      	adds	r4, r4, r3
 800a102:	68e2      	ldr	r2, [r4, #12]
  uint32_t temp_data = 0;
 800a104:	9707      	str	r7, [sp, #28]
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 800a106:	9203      	str	r2, [sp, #12]
  uint16_t lastindex = (RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR);
 800a108:	0022      	movs	r2, r4
 800a10a:	32e8      	adds	r2, #232	; 0xe8
 800a10c:	6812      	ldr	r2, [r2, #0]
 800a10e:	6852      	ldr	r2, [r2, #4]
 800a110:	9204      	str	r2, [sp, #16]
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate == NULL)
 800a112:	0022      	movs	r2, r4
 800a114:	32c9      	adds	r2, #201	; 0xc9
 800a116:	32ff      	adds	r2, #255	; 0xff
 800a118:	6812      	ldr	r2, [r2, #0]
 800a11a:	2a00      	cmp	r2, #0
 800a11c:	d02c      	beq.n	800a178 <PHY_HW_IF_RX_Stop+0xf4>
  while(ud->index <= lastindex)
 800a11e:	9305      	str	r3, [sp, #20]
  uint16_t lastindex = (RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR);
 800a120:	233c      	movs	r3, #60	; 0x3c
 800a122:	9a04      	ldr	r2, [sp, #16]
  while(ud->index <= lastindex)
 800a124:	6ba6      	ldr	r6, [r4, #56]	; 0x38
  uint16_t lastindex = (RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR);
 800a126:	1a9b      	subs	r3, r3, r2
  while(ud->index <= lastindex)
 800a128:	b29b      	uxth	r3, r3
 800a12a:	429e      	cmp	r6, r3
 800a12c:	d825      	bhi.n	800a17a <PHY_HW_IF_RX_Stop+0xf6>
    memcpy(&temp_data, &pbuff_in[ud->index], 3);
 800a12e:	9b03      	ldr	r3, [sp, #12]
 800a130:	2203      	movs	r2, #3
 800a132:	1999      	adds	r1, r3, r6
 800a134:	a807      	add	r0, sp, #28
 800a136:	f002 fcb9 	bl	800caac <memcpy>
    ud->index += ud->offset <= 5 ? 1 : 2;
 800a13a:	2305      	movs	r3, #5
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a13c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800a13e:	9f07      	ldr	r7, [sp, #28]
    ud->index += ud->offset <= 5 ? 1 : 2;
 800a140:	4293      	cmp	r3, r2
 800a142:	419b      	sbcs	r3, r3
 800a144:	425b      	negs	r3, r3
 800a146:	3301      	adds	r3, #1
 800a148:	469c      	mov	ip, r3
 800a14a:	481a      	ldr	r0, [pc, #104]	; (800a1b4 <PHY_HW_IF_RX_Stop+0x130>)
 800a14c:	9b05      	ldr	r3, [sp, #20]
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a14e:	40d7      	lsrs	r7, r2
    ud->index += ud->offset <= 5 ? 1 : 2;
 800a150:	18c0      	adds	r0, r0, r3
    ud->offset = (ud->offset + 2) & 7;
 800a152:	2307      	movs	r3, #7
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a154:	05b9      	lsls	r1, r7, #22
    ud->offset = (ud->offset + 2) & 7;
 800a156:	3202      	adds	r2, #2
 800a158:	401a      	ands	r2, r3
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a15a:	0d89      	lsrs	r1, r1, #22
    ud->index += ud->offset <= 5 ? 1 : 2;
 800a15c:	4466      	add	r6, ip
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a15e:	9107      	str	r1, [sp, #28]
    ud->index += ud->offset <= 5 ? 1 : 2;
 800a160:	6386      	str	r6, [r0, #56]	; 0x38
    ud->offset = (ud->offset + 2) & 7;
 800a162:	63c2      	str	r2, [r0, #60]	; 0x3c
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate(PortNum, temp_data);
 800a164:	30c9      	adds	r0, #201	; 0xc9
 800a166:	30ff      	adds	r0, #255	; 0xff
 800a168:	6803      	ldr	r3, [r0, #0]
 800a16a:	0028      	movs	r0, r5
 800a16c:	4798      	blx	r3
    if ((temp_data & 0x1F) == 0x0D)
 800a16e:	231f      	movs	r3, #31
 800a170:	401f      	ands	r7, r3
 800a172:	2f0d      	cmp	r7, #13
 800a174:	d1d4      	bne.n	800a120 <PHY_HW_IF_RX_Stop+0x9c>
 800a176:	e000      	b.n	800a17a <PHY_HW_IF_RX_Stop+0xf6>
 800a178:	46c0      	nop			; (mov r8, r8)
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800a17a:	24f0      	movs	r4, #240	; 0xf0
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a17c:	9801      	ldr	r0, [sp, #4]
 800a17e:	4e0d      	ldr	r6, [pc, #52]	; (800a1b4 <PHY_HW_IF_RX_Stop+0x130>)
 800a180:	3040      	adds	r0, #64	; 0x40
 800a182:	1980      	adds	r0, r0, r6
 800a184:	f7fe fbcc 	bl	8008920 <HAL_SPI_DMAStop>
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800a188:	2301      	movs	r3, #1
 800a18a:	0064      	lsls	r4, r4, #1
 800a18c:	436c      	muls	r4, r5
 800a18e:	1934      	adds	r4, r6, r4
 800a190:	7663      	strb	r3, [r4, #25]
  HAL_TIM_Base_Stop_IT(&(Ports[PortNum].htimcountrx));
 800a192:	9802      	ldr	r0, [sp, #8]
 800a194:	f7fe fde6 	bl	8008d64 <HAL_TIM_Base_Stop_IT>
  Ports[PortNum].htimcountrx.Instance->CNT = 0;
 800a198:	0023      	movs	r3, r4
 800a19a:	2200      	movs	r2, #0
 800a19c:	33fc      	adds	r3, #252	; 0xfc
 800a19e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed != NULL)
 800a1a0:	34cd      	adds	r4, #205	; 0xcd
 800a1a2:	34ff      	adds	r4, #255	; 0xff
  Ports[PortNum].htimcountrx.Instance->CNT = 0;
 800a1a4:	625a      	str	r2, [r3, #36]	; 0x24
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed != NULL)
 800a1a6:	6823      	ldr	r3, [r4, #0]
 800a1a8:	4293      	cmp	r3, r2
 800a1aa:	d100      	bne.n	800a1ae <PHY_HW_IF_RX_Stop+0x12a>
 800a1ac:	e781      	b.n	800a0b2 <PHY_HW_IF_RX_Stop+0x2e>
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed(PortNum);
 800a1ae:	0028      	movs	r0, r5
 800a1b0:	4798      	blx	r3
 800a1b2:	e77e      	b.n	800a0b2 <PHY_HW_IF_RX_Stop+0x2e>
 800a1b4:	20000058 	.word	0x20000058
 800a1b8:	40012c00 	.word	0x40012c00
 800a1bc:	ffff7fff 	.word	0xffff7fff
 800a1c0:	40014000 	.word	0x40014000
 800a1c4:	40014400 	.word	0x40014400
 800a1c8:	40014800 	.word	0x40014800

0800a1cc <HAL_TIM_OC_DelayElapsedCallback>:
  uint32_t temp_data = 0;
 800a1cc:	2300      	movs	r3, #0
{
 800a1ce:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 800a1d0:	4c62      	ldr	r4, [pc, #392]	; (800a35c <HAL_TIM_OC_DelayElapsedCallback+0x190>)
{
 800a1d2:	b085      	sub	sp, #20
  uint32_t temp_data = 0;
 800a1d4:	9303      	str	r3, [sp, #12]
  uint32_t tim_count = Ports[PortNum].htimcountrx.Instance->CNT;
 800a1d6:	0023      	movs	r3, r4
 800a1d8:	33fc      	adds	r3, #252	; 0xfc
 800a1da:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 800a1dc:	68e6      	ldr	r6, [r4, #12]
  uint32_t tim_count = Ports[PortNum].htimcountrx.Instance->CNT;
 800a1de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a1e0:	9301      	str	r3, [sp, #4]
         (ud->exed_flag == 0) &&
 800a1e2:	0022      	movs	r2, r4
 800a1e4:	322c      	adds	r2, #44	; 0x2c
  while (
 800a1e6:	7812      	ldrb	r2, [r2, #0]
 800a1e8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a1ea:	2a00      	cmp	r2, #0
 800a1ec:	d100      	bne.n	800a1f0 <HAL_TIM_OC_DelayElapsedCallback+0x24>
 800a1ee:	e084      	b.n	800a2fa <HAL_TIM_OC_DelayElapsedCallback+0x12e>
  Ports[PortNum].ud_index_current[Ports[PortNum].modulo] = ud->index ;
 800a1f0:	27ee      	movs	r7, #238	; 0xee
 800a1f2:	007f      	lsls	r7, r7, #1
 800a1f4:	5de0      	ldrb	r0, [r4, r7]
 800a1f6:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 800a1f8:	1823      	adds	r3, r4, r0
 800a1fa:	33da      	adds	r3, #218	; 0xda
 800a1fc:	33ff      	adds	r3, #255	; 0xff
  Ports[PortNum].modulo++;
 800a1fe:	3001      	adds	r0, #1
  Ports[PortNum].ud_index_current[Ports[PortNum].modulo] = ud->index ;
 800a200:	701e      	strb	r6, [r3, #0]
  Ports[PortNum].modulo = Ports[PortNum].modulo%3;
 800a202:	b2c0      	uxtb	r0, r0
 800a204:	2103      	movs	r1, #3
 800a206:	f7fb fc65 	bl	8005ad4 <__aeabi_uidivmod>
 800a20a:	b2cd      	uxtb	r5, r1
      (Ports[PortNum].ud_index_current[Ports[PortNum].modulo] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3]) &&
 800a20c:	1963      	adds	r3, r4, r5
 800a20e:	33da      	adds	r3, #218	; 0xda
  Ports[PortNum].modulo = Ports[PortNum].modulo%3;
 800a210:	55e5      	strb	r5, [r4, r7]
      (Ports[PortNum].ud_index_current[Ports[PortNum].modulo] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3]) &&
 800a212:	33ff      	adds	r3, #255	; 0xff
 800a214:	781b      	ldrb	r3, [r3, #0]
 800a216:	1c68      	adds	r0, r5, #1
 800a218:	2103      	movs	r1, #3
 800a21a:	9301      	str	r3, [sp, #4]
 800a21c:	f7fb fd44 	bl	8005ca8 <__aeabi_idivmod>
 800a220:	1861      	adds	r1, r4, r1
 800a222:	31da      	adds	r1, #218	; 0xda
 800a224:	31ff      	adds	r1, #255	; 0xff
  if (
 800a226:	780f      	ldrb	r7, [r1, #0]
 800a228:	9b01      	ldr	r3, [sp, #4]
 800a22a:	429f      	cmp	r7, r3
 800a22c:	d10f      	bne.n	800a24e <HAL_TIM_OC_DelayElapsedCallback+0x82>
        (Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+2)%3]) &&
 800a22e:	1ca8      	adds	r0, r5, #2
 800a230:	2103      	movs	r1, #3
 800a232:	f7fb fd39 	bl	8005ca8 <__aeabi_idivmod>
 800a236:	1861      	adds	r1, r4, r1
 800a238:	31da      	adds	r1, #218	; 0xda
 800a23a:	31ff      	adds	r1, #255	; 0xff
      (Ports[PortNum].ud_index_current[Ports[PortNum].modulo] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3]) &&
 800a23c:	780b      	ldrb	r3, [r1, #0]
 800a23e:	42bb      	cmp	r3, r7
 800a240:	d105      	bne.n	800a24e <HAL_TIM_OC_DelayElapsedCallback+0x82>
        (Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+2)%3]) &&
 800a242:	2e05      	cmp	r6, #5
 800a244:	d903      	bls.n	800a24e <HAL_TIM_OC_DelayElapsedCallback+0x82>
    ud->exed_flag = 3;
 800a246:	0023      	movs	r3, r4
 800a248:	2203      	movs	r2, #3
 800a24a:	332c      	adds	r3, #44	; 0x2c
 800a24c:	701a      	strb	r2, [r3, #0]
  if (ud->exed_flag == 2)
 800a24e:	342c      	adds	r4, #44	; 0x2c
 800a250:	7823      	ldrb	r3, [r4, #0]
 800a252:	2b02      	cmp	r3, #2
 800a254:	d102      	bne.n	800a25c <HAL_TIM_OC_DelayElapsedCallback+0x90>
    PHY_HW_IF_RX_Stop(PortNum);
 800a256:	2000      	movs	r0, #0
 800a258:	f7ff ff14 	bl	800a084 <PHY_HW_IF_RX_Stop>
}
 800a25c:	b005      	add	sp, #20
 800a25e:	bdf0      	pop	{r4, r5, r6, r7, pc}
          curr_bit = (pbuff_in[ud->index]>>ud->offset) & 0x01;
 800a260:	2701      	movs	r7, #1
        prev_bit = (pbuff_in[ud->index-1]>>7) & 0x01;
 800a262:	3a01      	subs	r2, #1
 800a264:	5cb0      	ldrb	r0, [r6, r2]
 800a266:	09c0      	lsrs	r0, r0, #7
        while (ud->offset < 8)
 800a268:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800a26a:	2b07      	cmp	r3, #7
 800a26c:	d8b9      	bhi.n	800a1e2 <HAL_TIM_OC_DelayElapsedCallback+0x16>
          curr_bit = (pbuff_in[ud->index]>>ud->offset) & 0x01;
 800a26e:	7829      	ldrb	r1, [r5, #0]
 800a270:	4119      	asrs	r1, r3
 800a272:	4039      	ands	r1, r7
          if (prev_bit == curr_bit)
 800a274:	4288      	cmp	r0, r1
 800a276:	d114      	bne.n	800a2a2 <HAL_TIM_OC_DelayElapsedCallback+0xd6>
            if (curr_bit == 0)
 800a278:	2800      	cmp	r0, #0
 800a27a:	d104      	bne.n	800a286 <HAL_TIM_OC_DelayElapsedCallback+0xba>
              if (ud->offset == 0)
 800a27c:	2b00      	cmp	r3, #0
 800a27e:	d10d      	bne.n	800a29c <HAL_TIM_OC_DelayElapsedCallback+0xd0>
                ud->offset = 7;
 800a280:	3307      	adds	r3, #7
 800a282:	63e3      	str	r3, [r4, #60]	; 0x3c
                ud->index--;
 800a284:	63a2      	str	r2, [r4, #56]	; 0x38
            ud->preamble = 1;
 800a286:	0023      	movs	r3, r4
 800a288:	2201      	movs	r2, #1
 800a28a:	332d      	adds	r3, #45	; 0x2d
 800a28c:	701a      	strb	r2, [r3, #0]
            preamble_offset = ud->offset;
 800a28e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800a290:	4b33      	ldr	r3, [pc, #204]	; (800a360 <HAL_TIM_OC_DelayElapsedCallback+0x194>)
 800a292:	701a      	strb	r2, [r3, #0]
            preamble_index = ud->index;
 800a294:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800a296:	4b33      	ldr	r3, [pc, #204]	; (800a364 <HAL_TIM_OC_DelayElapsedCallback+0x198>)
        ud->exed_flag = 2;
 800a298:	701a      	strb	r2, [r3, #0]
 800a29a:	e7a2      	b.n	800a1e2 <HAL_TIM_OC_DelayElapsedCallback+0x16>
                ud->offset--;
 800a29c:	3b01      	subs	r3, #1
 800a29e:	63e3      	str	r3, [r4, #60]	; 0x3c
 800a2a0:	e7f1      	b.n	800a286 <HAL_TIM_OC_DelayElapsedCallback+0xba>
          ud->offset++;
 800a2a2:	3301      	adds	r3, #1
 800a2a4:	63e3      	str	r3, [r4, #60]	; 0x3c
 800a2a6:	0008      	movs	r0, r1
 800a2a8:	e7de      	b.n	800a268 <HAL_TIM_OC_DelayElapsedCallback+0x9c>
 800a2aa:	46c0      	nop			; (mov r8, r8)
      memcpy(&temp_data, &pbuff_in[ud->index], 3);
 800a2ac:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 800a2ae:	2203      	movs	r2, #3
 800a2b0:	19f1      	adds	r1, r6, r7
 800a2b2:	a803      	add	r0, sp, #12
 800a2b4:	f002 fbfa 	bl	800caac <memcpy>
      ud->index += ud->offset <= 5 ? 1 : 2;
 800a2b8:	2205      	movs	r2, #5
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a2ba:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800a2bc:	9d03      	ldr	r5, [sp, #12]
      ud->index += ud->offset <= 5 ? 1 : 2;
 800a2be:	429a      	cmp	r2, r3
 800a2c0:	4192      	sbcs	r2, r2
 800a2c2:	4252      	negs	r2, r2
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a2c4:	40dd      	lsrs	r5, r3
      ud->index += ud->offset <= 5 ? 1 : 2;
 800a2c6:	3201      	adds	r2, #1
 800a2c8:	18bf      	adds	r7, r7, r2
      ud->offset = (ud->offset + 2) & 7;
 800a2ca:	2207      	movs	r2, #7
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a2cc:	05a9      	lsls	r1, r5, #22
      ud->offset = (ud->offset + 2) & 7;
 800a2ce:	3302      	adds	r3, #2
 800a2d0:	4013      	ands	r3, r2
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a2d2:	0d89      	lsrs	r1, r1, #22
 800a2d4:	9103      	str	r1, [sp, #12]
      ud->offset = (ud->offset + 2) & 7;
 800a2d6:	63e3      	str	r3, [r4, #60]	; 0x3c
      if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate != NULL)
 800a2d8:	23e4      	movs	r3, #228	; 0xe4
 800a2da:	005b      	lsls	r3, r3, #1
 800a2dc:	58e3      	ldr	r3, [r4, r3]
      ud->index += ud->offset <= 5 ? 1 : 2;
 800a2de:	63a7      	str	r7, [r4, #56]	; 0x38
      if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate != NULL)
 800a2e0:	2b00      	cmp	r3, #0
 800a2e2:	d001      	beq.n	800a2e8 <HAL_TIM_OC_DelayElapsedCallback+0x11c>
        Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate(PortNum, temp_data);
 800a2e4:	2000      	movs	r0, #0
 800a2e6:	4798      	blx	r3
      if ((temp_data & 0x1F) == 0x0D) /* EOP */
 800a2e8:	231f      	movs	r3, #31
 800a2ea:	401d      	ands	r5, r3
 800a2ec:	2d0d      	cmp	r5, #13
 800a2ee:	d000      	beq.n	800a2f2 <HAL_TIM_OC_DelayElapsedCallback+0x126>
 800a2f0:	e777      	b.n	800a1e2 <HAL_TIM_OC_DelayElapsedCallback+0x16>
        ud->exed_flag = 2;
 800a2f2:	0023      	movs	r3, r4
 800a2f4:	2202      	movs	r2, #2
 800a2f6:	332c      	adds	r3, #44	; 0x2c
 800a2f8:	e7ce      	b.n	800a298 <HAL_TIM_OC_DelayElapsedCallback+0xcc>
           ((RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR)>(ud->index + 2)) &&                /* checking if in the buffer the are enough data */
 800a2fa:	0022      	movs	r2, r4
 800a2fc:	213c      	movs	r1, #60	; 0x3c
 800a2fe:	32e8      	adds	r2, #232	; 0xe8
 800a300:	6812      	ldr	r2, [r2, #0]
 800a302:	3302      	adds	r3, #2
 800a304:	6852      	ldr	r2, [r2, #4]
 800a306:	1a8a      	subs	r2, r1, r2
         (ud->exed_flag == 0) &&
 800a308:	429a      	cmp	r2, r3
 800a30a:	d800      	bhi.n	800a30e <HAL_TIM_OC_DelayElapsedCallback+0x142>
 800a30c:	e770      	b.n	800a1f0 <HAL_TIM_OC_DelayElapsedCallback+0x24>
             (Ports[PortNum].htimcountrx.Instance->CNT < tim_count + DMA_TIME_TASK) &&
 800a30e:	0023      	movs	r3, r4
 800a310:	33fc      	adds	r3, #252	; 0xfc
 800a312:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800a314:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a316:	9b01      	ldr	r3, [sp, #4]
 800a318:	3314      	adds	r3, #20
           ((RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR)>(ud->index + 2)) &&                /* checking if in the buffer the are enough data */
 800a31a:	429a      	cmp	r2, r3
 800a31c:	d300      	bcc.n	800a320 <HAL_TIM_OC_DelayElapsedCallback+0x154>
 800a31e:	e767      	b.n	800a1f0 <HAL_TIM_OC_DelayElapsedCallback+0x24>
               (HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET)        /* stopping the decoding in case of NSS is high */
 800a320:	2180      	movs	r1, #128	; 0x80
 800a322:	4811      	ldr	r0, [pc, #68]	; (800a368 <HAL_TIM_OC_DelayElapsedCallback+0x19c>)
 800a324:	0149      	lsls	r1, r1, #5
 800a326:	f7fd fbf3 	bl	8007b10 <HAL_GPIO_ReadPin>
             (Ports[PortNum].htimcountrx.Instance->CNT < tim_count + DMA_TIME_TASK) &&
 800a32a:	2800      	cmp	r0, #0
 800a32c:	d000      	beq.n	800a330 <HAL_TIM_OC_DelayElapsedCallback+0x164>
 800a32e:	e75f      	b.n	800a1f0 <HAL_TIM_OC_DelayElapsedCallback+0x24>
    if (pbuff_in[ud->index]==0xFF)
 800a330:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a332:	5cf3      	ldrb	r3, [r6, r3]
 800a334:	2bff      	cmp	r3, #255	; 0xff
 800a336:	d100      	bne.n	800a33a <HAL_TIM_OC_DelayElapsedCallback+0x16e>
 800a338:	46c0      	nop			; (mov r8, r8)
    if (!ud->preamble)                  /* The end of preamble hasn't identified yet */ 
 800a33a:	0023      	movs	r3, r4
 800a33c:	332d      	adds	r3, #45	; 0x2d
 800a33e:	781b      	ldrb	r3, [r3, #0]
 800a340:	2b00      	cmp	r3, #0
 800a342:	d1b2      	bne.n	800a2aa <HAL_TIM_OC_DelayElapsedCallback+0xde>
      r = pbuff_in[ud->index]^0xAA;
 800a344:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800a346:	3b56      	subs	r3, #86	; 0x56
 800a348:	18b5      	adds	r5, r6, r2
 800a34a:	7829      	ldrb	r1, [r5, #0]
 800a34c:	404b      	eors	r3, r1
      if (r == 0x00 || r == 0xFF)       /* The end of preamble is not part of the received data */ 
 800a34e:	3b01      	subs	r3, #1
 800a350:	b2db      	uxtb	r3, r3
 800a352:	2bfd      	cmp	r3, #253	; 0xfd
 800a354:	d984      	bls.n	800a260 <HAL_TIM_OC_DelayElapsedCallback+0x94>
        ud->index++;
 800a356:	3201      	adds	r2, #1
 800a358:	63a2      	str	r2, [r4, #56]	; 0x38
 800a35a:	e742      	b.n	800a1e2 <HAL_TIM_OC_DelayElapsedCallback+0x16>
 800a35c:	20000058 	.word	0x20000058
 800a360:	20001c80 	.word	0x20001c80
 800a364:	20001d80 	.word	0x20001d80
 800a368:	48000400 	.word	0x48000400

0800a36c <PHY_HW_IF_TX_Done>:
  if (Ports[PortNum].TxSpareBits == 0)
 800a36c:	23f0      	movs	r3, #240	; 0xf0
 800a36e:	005b      	lsls	r3, r3, #1
 800a370:	4343      	muls	r3, r0
{
 800a372:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (Ports[PortNum].TxSpareBits == 0)
 800a374:	4d5e      	ldr	r5, [pc, #376]	; (800a4f0 <PHY_HW_IF_TX_Done+0x184>)
{
 800a376:	0004      	movs	r4, r0
  if (Ports[PortNum].TxSpareBits == 0)
 800a378:	18eb      	adds	r3, r5, r3
 800a37a:	001a      	movs	r2, r3
 800a37c:	322a      	adds	r2, #42	; 0x2a
 800a37e:	7812      	ldrb	r2, [r2, #0]
    while (((((Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL)) >> SPI_SR_FTLVL_Pos) & 0x03) > 1)
 800a380:	2103      	movs	r1, #3
  if (Ports[PortNum].TxSpareBits == 0)
 800a382:	2a00      	cmp	r2, #0
 800a384:	d143      	bne.n	800a40e <PHY_HW_IF_TX_Done+0xa2>
 800a386:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    if (Ports[PortNum].Device_cut == Cut_1)
 800a388:	33d9      	adds	r3, #217	; 0xd9
 800a38a:	33ff      	adds	r3, #255	; 0xff
 800a38c:	7819      	ldrb	r1, [r3, #0]
 800a38e:	2903      	cmp	r1, #3
 800a390:	d005      	beq.n	800a39e <PHY_HW_IF_TX_Done+0x32>
      while ( (Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL) != 0);  /* != 0x0800 */
 800a392:	23c0      	movs	r3, #192	; 0xc0
 800a394:	015b      	lsls	r3, r3, #5
 800a396:	6891      	ldr	r1, [r2, #8]
 800a398:	4219      	tst	r1, r3
 800a39a:	d1fc      	bne.n	800a396 <PHY_HW_IF_TX_Done+0x2a>
 800a39c:	e004      	b.n	800a3a8 <PHY_HW_IF_TX_Done+0x3c>
      while (((((Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL)) >> SPI_SR_FTLVL_Pos) & 0x03) > 1);
 800a39e:	6893      	ldr	r3, [r2, #8]
 800a3a0:	0adb      	lsrs	r3, r3, #11
 800a3a2:	400b      	ands	r3, r1
 800a3a4:	2b01      	cmp	r3, #1
 800a3a6:	d8fa      	bhi.n	800a39e <PHY_HW_IF_TX_Done+0x32>
  while ( (Ports[PortNum].hspi.Instance->SR & SPI_SR_BSY) > 0);
 800a3a8:	23f0      	movs	r3, #240	; 0xf0
 800a3aa:	005b      	lsls	r3, r3, #1
 800a3ac:	001a      	movs	r2, r3
 800a3ae:	4362      	muls	r2, r4
 800a3b0:	18aa      	adds	r2, r5, r2
 800a3b2:	6c10      	ldr	r0, [r2, #64]	; 0x40
 800a3b4:	2280      	movs	r2, #128	; 0x80
 800a3b6:	6881      	ldr	r1, [r0, #8]
 800a3b8:	4211      	tst	r1, r2
 800a3ba:	d1fc      	bne.n	800a3b6 <PHY_HW_IF_TX_Done+0x4a>
  if (Ports[PortNum].Device_cut == Cut_1)
 800a3bc:	4363      	muls	r3, r4
 800a3be:	18eb      	adds	r3, r5, r3
 800a3c0:	001a      	movs	r2, r3
 800a3c2:	32d9      	adds	r2, #217	; 0xd9
 800a3c4:	32ff      	adds	r2, #255	; 0xff
 800a3c6:	7812      	ldrb	r2, [r2, #0]
 800a3c8:	2a03      	cmp	r2, #3
 800a3ca:	d027      	beq.n	800a41c <PHY_HW_IF_TX_Done+0xb0>
 800a3cc:	2708      	movs	r7, #8
 800a3ce:	2c00      	cmp	r4, #0
 800a3d0:	d101      	bne.n	800a3d6 <PHY_HW_IF_TX_Done+0x6a>
 800a3d2:	4b48      	ldr	r3, [pc, #288]	; (800a4f4 <PHY_HW_IF_TX_Done+0x188>)
 800a3d4:	881f      	ldrh	r7, [r3, #0]
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 800a3d6:	23f0      	movs	r3, #240	; 0xf0
 800a3d8:	2600      	movs	r6, #0
 800a3da:	005b      	lsls	r3, r3, #1
 800a3dc:	4363      	muls	r3, r4
 800a3de:	18eb      	adds	r3, r5, r3
 800a3e0:	332a      	adds	r3, #42	; 0x2a
 800a3e2:	b2bf      	uxth	r7, r7
 800a3e4:	9301      	str	r3, [sp, #4]
 800a3e6:	9b01      	ldr	r3, [sp, #4]
 800a3e8:	781b      	ldrb	r3, [r3, #0]
 800a3ea:	42b3      	cmp	r3, r6
 800a3ec:	d933      	bls.n	800a456 <PHY_HW_IF_TX_Done+0xea>
      while (!HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 800a3ee:	0039      	movs	r1, r7
 800a3f0:	4841      	ldr	r0, [pc, #260]	; (800a4f8 <PHY_HW_IF_TX_Done+0x18c>)
 800a3f2:	f7fd fb8d 	bl	8007b10 <HAL_GPIO_ReadPin>
 800a3f6:	2800      	cmp	r0, #0
 800a3f8:	d0f9      	beq.n	800a3ee <PHY_HW_IF_TX_Done+0x82>
      while (HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 800a3fa:	0039      	movs	r1, r7
 800a3fc:	483e      	ldr	r0, [pc, #248]	; (800a4f8 <PHY_HW_IF_TX_Done+0x18c>)
 800a3fe:	f7fd fb87 	bl	8007b10 <HAL_GPIO_ReadPin>
 800a402:	2800      	cmp	r0, #0
 800a404:	d1f9      	bne.n	800a3fa <PHY_HW_IF_TX_Done+0x8e>
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 800a406:	3601      	adds	r6, #1
 800a408:	b2f6      	uxtb	r6, r6
 800a40a:	e7ec      	b.n	800a3e6 <PHY_HW_IF_TX_Done+0x7a>
 800a40c:	46c0      	nop			; (mov r8, r8)
    while (((((Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL)) >> SPI_SR_FTLVL_Pos) & 0x03) > 1)
 800a40e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800a410:	6892      	ldr	r2, [r2, #8]
 800a412:	0ad2      	lsrs	r2, r2, #11
 800a414:	400a      	ands	r2, r1
 800a416:	2a01      	cmp	r2, #1
 800a418:	d8f8      	bhi.n	800a40c <PHY_HW_IF_TX_Done+0xa0>
 800a41a:	e7c5      	b.n	800a3a8 <PHY_HW_IF_TX_Done+0x3c>
 800a41c:	332a      	adds	r3, #42	; 0x2a
 800a41e:	781a      	ldrb	r2, [r3, #0]
    if (Ports[PortNum].TxSpareBits == 0)
 800a420:	2a00      	cmp	r2, #0
 800a422:	d14f      	bne.n	800a4c4 <PHY_HW_IF_TX_Done+0x158>
      Ports[PortNum].TxSpareBits = 7;
 800a424:	3207      	adds	r2, #7
      Ports[PortNum].TxSpareBits = (Ports[PortNum].TxSpareBits - 1);
 800a426:	701a      	strb	r2, [r3, #0]
 800a428:	2608      	movs	r6, #8
 800a42a:	2c00      	cmp	r4, #0
 800a42c:	d101      	bne.n	800a432 <PHY_HW_IF_TX_Done+0xc6>
 800a42e:	4b31      	ldr	r3, [pc, #196]	; (800a4f4 <PHY_HW_IF_TX_Done+0x188>)
 800a430:	881e      	ldrh	r6, [r3, #0]
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 800a432:	23f0      	movs	r3, #240	; 0xf0
{
 800a434:	2700      	movs	r7, #0
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 800a436:	005b      	lsls	r3, r3, #1
 800a438:	4363      	muls	r3, r4
 800a43a:	18eb      	adds	r3, r5, r3
 800a43c:	332a      	adds	r3, #42	; 0x2a
 800a43e:	b2b6      	uxth	r6, r6
 800a440:	9301      	str	r3, [sp, #4]
 800a442:	9b01      	ldr	r3, [sp, #4]
 800a444:	781b      	ldrb	r3, [r3, #0]
 800a446:	42bb      	cmp	r3, r7
 800a448:	d83e      	bhi.n	800a4c8 <PHY_HW_IF_TX_Done+0x15c>
    while (HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 800a44a:	0031      	movs	r1, r6
 800a44c:	482a      	ldr	r0, [pc, #168]	; (800a4f8 <PHY_HW_IF_TX_Done+0x18c>)
 800a44e:	f7fd fb5f 	bl	8007b10 <HAL_GPIO_ReadPin>
 800a452:	2800      	cmp	r0, #0
 800a454:	d1f9      	bne.n	800a44a <PHY_HW_IF_TX_Done+0xde>
  STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_RESET);
 800a456:	2100      	movs	r1, #0
 800a458:	0020      	movs	r0, r4
 800a45a:	f000 feed 	bl	800b238 <STUSB16xx_HW_IF_TX_EN_Status>
  __HAL_SPI_DISABLE(&Ports[PortNum].hspi);
 800a45e:	23f0      	movs	r3, #240	; 0xf0
 800a460:	005b      	lsls	r3, r3, #1
 800a462:	001a      	movs	r2, r3
 800a464:	2040      	movs	r0, #64	; 0x40
 800a466:	4362      	muls	r2, r4
 800a468:	18aa      	adds	r2, r5, r2
 800a46a:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a46c:	6811      	ldr	r1, [r2, #0]
 800a46e:	4381      	bics	r1, r0
 800a470:	6011      	str	r1, [r2, #0]
  while ((Ports[PortNum].hspi.Instance->SR & SPI_SR_FRLVL) != 0)
 800a472:	21c0      	movs	r1, #192	; 0xc0
 800a474:	00c9      	lsls	r1, r1, #3
 800a476:	6896      	ldr	r6, [r2, #8]
 800a478:	400e      	ands	r6, r1
 800a47a:	d134      	bne.n	800a4e6 <PHY_HW_IF_TX_Done+0x17a>
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a47c:	4363      	muls	r3, r4
 800a47e:	0018      	movs	r0, r3
 800a480:	001f      	movs	r7, r3
 800a482:	3040      	adds	r0, #64	; 0x40
 800a484:	1828      	adds	r0, r5, r0
  if(Ports[PortNum].State==HAL_USBPD_PORT_STATE_BIST)
 800a486:	19ef      	adds	r7, r5, r7
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a488:	f7fe fa4a 	bl	8008920 <HAL_SPI_DMAStop>
  if(Ports[PortNum].State==HAL_USBPD_PORT_STATE_BIST)
 800a48c:	7e7a      	ldrb	r2, [r7, #25]
 800a48e:	2a08      	cmp	r2, #8
 800a490:	d12b      	bne.n	800a4ea <PHY_HW_IF_TX_Done+0x17e>
    Ports[PortNum].State=HAL_USBPD_PORT_STATE_RESET;
 800a492:	767e      	strb	r6, [r7, #25]
    if ((Ports[PortNum].cbs.USBPD_HW_IF_BistCompleted != NULL) )
 800a494:	37c1      	adds	r7, #193	; 0xc1
 800a496:	37ff      	adds	r7, #255	; 0xff
 800a498:	683b      	ldr	r3, [r7, #0]
 800a49a:	2b00      	cmp	r3, #0
 800a49c:	d002      	beq.n	800a4a4 <PHY_HW_IF_TX_Done+0x138>
      Ports[PortNum].cbs.USBPD_HW_IF_BistCompleted(PortNum,USBPD_BIST_CARRIER_MODE2);
 800a49e:	2105      	movs	r1, #5
 800a4a0:	0020      	movs	r0, r4
 800a4a2:	4798      	blx	r3
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_RX);
 800a4a4:	2101      	movs	r1, #1
 800a4a6:	0020      	movs	r0, r4
 800a4a8:	f000 feb8 	bl	800b21c <STUSB16xx_HW_IF_Switch_Mode>
  if (Ports[PortNum].cbs.USBPD_HW_IF_TxCompleted != NULL)
 800a4ac:	23f0      	movs	r3, #240	; 0xf0
 800a4ae:	005b      	lsls	r3, r3, #1
 800a4b0:	4363      	muls	r3, r4
 800a4b2:	18ed      	adds	r5, r5, r3
 800a4b4:	35bd      	adds	r5, #189	; 0xbd
 800a4b6:	35ff      	adds	r5, #255	; 0xff
 800a4b8:	682b      	ldr	r3, [r5, #0]
 800a4ba:	2b00      	cmp	r3, #0
 800a4bc:	d001      	beq.n	800a4c2 <PHY_HW_IF_TX_Done+0x156>
    Ports[PortNum].cbs.USBPD_HW_IF_TxCompleted(PortNum);
 800a4be:	0020      	movs	r0, r4
 800a4c0:	4798      	blx	r3
}
 800a4c2:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
      Ports[PortNum].TxSpareBits = (Ports[PortNum].TxSpareBits - 1);
 800a4c4:	3a01      	subs	r2, #1
 800a4c6:	e7ae      	b.n	800a426 <PHY_HW_IF_TX_Done+0xba>
      while (HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 800a4c8:	0031      	movs	r1, r6
 800a4ca:	480b      	ldr	r0, [pc, #44]	; (800a4f8 <PHY_HW_IF_TX_Done+0x18c>)
 800a4cc:	f7fd fb20 	bl	8007b10 <HAL_GPIO_ReadPin>
 800a4d0:	2800      	cmp	r0, #0
 800a4d2:	d1f9      	bne.n	800a4c8 <PHY_HW_IF_TX_Done+0x15c>
      while (!HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 800a4d4:	0031      	movs	r1, r6
 800a4d6:	4808      	ldr	r0, [pc, #32]	; (800a4f8 <PHY_HW_IF_TX_Done+0x18c>)
 800a4d8:	f7fd fb1a 	bl	8007b10 <HAL_GPIO_ReadPin>
 800a4dc:	2800      	cmp	r0, #0
 800a4de:	d0f9      	beq.n	800a4d4 <PHY_HW_IF_TX_Done+0x168>
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 800a4e0:	3701      	adds	r7, #1
 800a4e2:	b2ff      	uxtb	r7, r7
 800a4e4:	e7ad      	b.n	800a442 <PHY_HW_IF_TX_Done+0xd6>
    dummyDR= *(__IO uint8_t *)&Ports[PortNum].hspi.Instance->DR;
 800a4e6:	7b10      	ldrb	r0, [r2, #12]
 800a4e8:	e7c5      	b.n	800a476 <PHY_HW_IF_TX_Done+0x10a>
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_WAITING;
 800a4ea:	2205      	movs	r2, #5
 800a4ec:	767a      	strb	r2, [r7, #25]
 800a4ee:	e7d9      	b.n	800a4a4 <PHY_HW_IF_TX_Done+0x138>
 800a4f0:	20000058 	.word	0x20000058
 800a4f4:	0800cdd8 	.word	0x0800cdd8
 800a4f8:	48000400 	.word	0x48000400

0800a4fc <HW_IF_CRC_Init>:
  hcrc.Instance = CRC;
 800a4fc:	4807      	ldr	r0, [pc, #28]	; (800a51c <HW_IF_CRC_Init+0x20>)
 800a4fe:	4b08      	ldr	r3, [pc, #32]	; (800a520 <HW_IF_CRC_Init+0x24>)
{
 800a500:	b510      	push	{r4, lr}
  hcrc.Instance = CRC;
 800a502:	6003      	str	r3, [r0, #0]
 800a504:	2300      	movs	r3, #0
 800a506:	8083      	strh	r3, [r0, #4]
  hcrc.Init.InputDataInversionMode =   CRC_INPUTDATA_INVERSION_BYTE;           /* The input data are inverted by WORD */
 800a508:	3320      	adds	r3, #32
 800a50a:	6143      	str	r3, [r0, #20]
  hcrc.Init.OutputDataInversionMode =   CRC_OUTPUTDATA_INVERSION_ENABLE;        /* The output data are Bit-reversed format */
 800a50c:	3360      	adds	r3, #96	; 0x60
 800a50e:	6183      	str	r3, [r0, #24]
  hcrc.InputDataFormat =           CRC_INPUTDATA_FORMAT_BYTES;             /* The input data are 32 bits lenght */
 800a510:	3b7f      	subs	r3, #127	; 0x7f
 800a512:	6203      	str	r3, [r0, #32]
  HAL_CRC_Init(&hcrc);
 800a514:	f7fd f8f9 	bl	800770a <HAL_CRC_Init>
}
 800a518:	bd10      	pop	{r4, pc}
 800a51a:	46c0      	nop			; (mov r8, r8)
 800a51c:	20001cdc 	.word	0x20001cdc
 800a520:	40023000 	.word	0x40023000

0800a524 <HW_IF_ADC_Init>:
{
 800a524:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  usbpdm1_hadc.Instance = HW_IF_ADC;
 800a526:	4c17      	ldr	r4, [pc, #92]	; (800a584 <HW_IF_ADC_Init+0x60>)
 800a528:	4b17      	ldr	r3, [pc, #92]	; (800a588 <HW_IF_ADC_Init+0x64>)
  usbpdm1_hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 800a52a:	2201      	movs	r2, #1
  usbpdm1_hadc.Instance = HW_IF_ADC;
 800a52c:	6023      	str	r3, [r4, #0]
  usbpdm1_hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 800a52e:	2104      	movs	r1, #4
  usbpdm1_hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 800a530:	2300      	movs	r3, #0
  HAL_ADC_Init(&usbpdm1_hadc);
 800a532:	0020      	movs	r0, r4
  usbpdm1_hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 800a534:	6122      	str	r2, [r4, #16]
  usbpdm1_hadc.Init.ContinuousConvMode = ENABLE;
 800a536:	6222      	str	r2, [r4, #32]
  usbpdm1_hadc.Init.DMAContinuousRequests = ENABLE;
 800a538:	6322      	str	r2, [r4, #48]	; 0x30
  usbpdm1_hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 800a53a:	6362      	str	r2, [r4, #52]	; 0x34
  usbpdm1_hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 800a53c:	6063      	str	r3, [r4, #4]
  usbpdm1_hadc.Init.Resolution = ADC_RESOLUTION_12B;
 800a53e:	60a3      	str	r3, [r4, #8]
  usbpdm1_hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 800a540:	60e3      	str	r3, [r4, #12]
  usbpdm1_hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 800a542:	6161      	str	r1, [r4, #20]
  usbpdm1_hadc.Init.LowPowerAutoWait = DISABLE;
 800a544:	61a3      	str	r3, [r4, #24]
  usbpdm1_hadc.Init.LowPowerAutoPowerOff = DISABLE;
 800a546:	61e3      	str	r3, [r4, #28]
  usbpdm1_hadc.Init.DiscontinuousConvMode = DISABLE;
 800a548:	6263      	str	r3, [r4, #36]	; 0x24
  usbpdm1_hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 800a54a:	62e3      	str	r3, [r4, #44]	; 0x2c
  HAL_ADC_Init(&usbpdm1_hadc);
 800a54c:	f7fc fe3a 	bl	80071c4 <HAL_ADC_Init>
  sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 800a550:	2380      	movs	r3, #128	; 0x80
 800a552:	015b      	lsls	r3, r3, #5
 800a554:	9302      	str	r3, [sp, #8]
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 800a556:	2380      	movs	r3, #128	; 0x80
 800a558:	055b      	lsls	r3, r3, #21
 800a55a:	9303      	str	r3, [sp, #12]
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a55c:	230e      	movs	r3, #14
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a55e:	a901      	add	r1, sp, #4
 800a560:	0020      	movs	r0, r4
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a562:	9301      	str	r3, [sp, #4]
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a564:	f7fc ff6a 	bl	800743c <HAL_ADC_ConfigChannel>
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a568:	2307      	movs	r3, #7
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a56a:	a901      	add	r1, sp, #4
 800a56c:	0020      	movs	r0, r4
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a56e:	9301      	str	r3, [sp, #4]
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a570:	f7fc ff64 	bl	800743c <HAL_ADC_ConfigChannel>
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a574:	230a      	movs	r3, #10
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a576:	a901      	add	r1, sp, #4
 800a578:	0020      	movs	r0, r4
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a57a:	9301      	str	r3, [sp, #4]
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a57c:	f7fc ff5e 	bl	800743c <HAL_ADC_ConfigChannel>
}
 800a580:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 800a582:	46c0      	nop			; (mov r8, r8)
 800a584:	20001c84 	.word	0x20001c84
 800a588:	40012400 	.word	0x40012400

0800a58c <USBPD_HW_IF_GlobalHwInit>:
{
 800a58c:	b510      	push	{r4, lr}
  HW_IF_ADC_Init();
 800a58e:	f7ff ffc9 	bl	800a524 <HW_IF_ADC_Init>
  HAL_ADCEx_Calibration_Start(&usbpdm1_hadc);
 800a592:	4c08      	ldr	r4, [pc, #32]	; (800a5b4 <USBPD_HW_IF_GlobalHwInit+0x28>)
 800a594:	0020      	movs	r0, r4
 800a596:	f7fc ffd1 	bl	800753c <HAL_ADCEx_Calibration_Start>
  HAL_ADC_Start_DMA(&usbpdm1_hadc, ADCxConvertedValues, ADCCONVERTEDVALUES_BUFFER_SIZE);
 800a59a:	2203      	movs	r2, #3
 800a59c:	4906      	ldr	r1, [pc, #24]	; (800a5b8 <USBPD_HW_IF_GlobalHwInit+0x2c>)
 800a59e:	0020      	movs	r0, r4
 800a5a0:	f7fc feb4 	bl	800730c <HAL_ADC_Start_DMA>
  HW_IF_CRC_Init();
 800a5a4:	f7ff ffaa 	bl	800a4fc <HW_IF_CRC_Init>
  HW_IF_PWR_DigitalGPIO_Init();
 800a5a8:	f000 f87a 	bl	800a6a0 <HW_IF_PWR_DigitalGPIO_Init>
  USBPD_TIM_Init();
 800a5ac:	f001 f8f2 	bl	800b794 <USBPD_TIM_Init>
}
 800a5b0:	bd10      	pop	{r4, pc}
 800a5b2:	46c0      	nop			; (mov r8, r8)
 800a5b4:	20001c84 	.word	0x20001c84
 800a5b8:	20001cd0 	.word	0x20001cd0

0800a5bc <HW_IF_UnwrapData_Init>:
  ud->exed_flag =       0;
 800a5bc:	22f0      	movs	r2, #240	; 0xf0
 800a5be:	0052      	lsls	r2, r2, #1
 800a5c0:	4342      	muls	r2, r0
 800a5c2:	490a      	ldr	r1, [pc, #40]	; (800a5ec <HW_IF_UnwrapData_Init+0x30>)
  ud->dataindex =       0;
 800a5c4:	480a      	ldr	r0, [pc, #40]	; (800a5f0 <HW_IF_UnwrapData_Init+0x34>)
  ud->exed_flag =       0;
 800a5c6:	2300      	movs	r3, #0
  ud->dataindex =       0;
 800a5c8:	1880      	adds	r0, r0, r2
  ud->exed_flag =       0;
 800a5ca:	1851      	adds	r1, r2, r1
  ud->index =           2;      /* It discards first two bytes */
 800a5cc:	2202      	movs	r2, #2
  ud->exed_flag =       0;
 800a5ce:	808b      	strh	r3, [r1, #4]
  ud->index =           2;      /* It discards first two bytes */
 800a5d0:	6382      	str	r2, [r0, #56]	; 0x38
  preamble_offset = 0;
 800a5d2:	4a08      	ldr	r2, [pc, #32]	; (800a5f4 <HW_IF_UnwrapData_Init+0x38>)
  ud->dataindex =       0;
 800a5d4:	6303      	str	r3, [r0, #48]	; 0x30
  ud->dataoffset =      0;
 800a5d6:	6343      	str	r3, [r0, #52]	; 0x34
  ud->offset =          0;
 800a5d8:	63c3      	str	r3, [r0, #60]	; 0x3c
  preamble_offset = 0;
 800a5da:	7013      	strb	r3, [r2, #0]
  preamble_index = 0;
 800a5dc:	4a06      	ldr	r2, [pc, #24]	; (800a5f8 <HW_IF_UnwrapData_Init+0x3c>)
 800a5de:	7013      	strb	r3, [r2, #0]
  preamble_counter++;
 800a5e0:	4a06      	ldr	r2, [pc, #24]	; (800a5fc <HW_IF_UnwrapData_Init+0x40>)
 800a5e2:	6813      	ldr	r3, [r2, #0]
 800a5e4:	3301      	adds	r3, #1
 800a5e6:	6013      	str	r3, [r2, #0]
}
 800a5e8:	4770      	bx	lr
 800a5ea:	46c0      	nop			; (mov r8, r8)
 800a5ec:	20000080 	.word	0x20000080
 800a5f0:	20000058 	.word	0x20000058
 800a5f4:	20001c80 	.word	0x20001c80
 800a5f8:	20001d80 	.word	0x20001d80
 800a5fc:	200003d0 	.word	0x200003d0

0800a600 <PHY_HW_IF_RX_Start>:
{
 800a600:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset != NULL)
 800a602:	25f0      	movs	r5, #240	; 0xf0
 800a604:	006d      	lsls	r5, r5, #1
 800a606:	002b      	movs	r3, r5
 800a608:	4343      	muls	r3, r0
 800a60a:	4e24      	ldr	r6, [pc, #144]	; (800a69c <PHY_HW_IF_RX_Start+0x9c>)
{
 800a60c:	b085      	sub	sp, #20
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset != NULL)
 800a60e:	18f3      	adds	r3, r6, r3
 800a610:	33c5      	adds	r3, #197	; 0xc5
 800a612:	33ff      	adds	r3, #255	; 0xff
 800a614:	681b      	ldr	r3, [r3, #0]
{
 800a616:	0004      	movs	r4, r0
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset != NULL)
 800a618:	2b00      	cmp	r3, #0
 800a61a:	d000      	beq.n	800a61e <PHY_HW_IF_RX_Start+0x1e>
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset(PortNum);
 800a61c:	4798      	blx	r3
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_RX;
 800a61e:	2304      	movs	r3, #4
 800a620:	4365      	muls	r5, r4
 800a622:	9501      	str	r5, [sp, #4]
 800a624:	1975      	adds	r5, r6, r5
 800a626:	766b      	strb	r3, [r5, #25]
  HW_IF_UnwrapData_Init(PortNum);
 800a628:	0020      	movs	r0, r4
 800a62a:	f7ff ffc7 	bl	800a5bc <HW_IF_UnwrapData_Init>
    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a62e:	9f01      	ldr	r7, [sp, #4]
 800a630:	3740      	adds	r7, #64	; 0x40
 800a632:	19f7      	adds	r7, r6, r7
 800a634:	0038      	movs	r0, r7
 800a636:	f7fe f973 	bl	8008920 <HAL_SPI_DMAStop>
  __IO uint32_t a = 0x0;
 800a63a:	2300      	movs	r3, #0
 800a63c:	9303      	str	r3, [sp, #12]
  while(local_hspi->Instance->SR & 0x01)
 800a63e:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800a640:	2201      	movs	r2, #1
 800a642:	689d      	ldr	r5, [r3, #8]
 800a644:	4015      	ands	r5, r2
 800a646:	d125      	bne.n	800a694 <PHY_HW_IF_RX_Start+0x94>
  memset(Ports[PortNum].pRxBuffPtr, 0x00, RX_BUFFER_SIZE);
 800a648:	23f0      	movs	r3, #240	; 0xf0
 800a64a:	005b      	lsls	r3, r3, #1
 800a64c:	435c      	muls	r4, r3
 800a64e:	1934      	adds	r4, r6, r4
 800a650:	0029      	movs	r1, r5
 800a652:	323b      	adds	r2, #59	; 0x3b
 800a654:	68e0      	ldr	r0, [r4, #12]
 800a656:	f002 fa32 	bl	800cabe <memset>
  HAL_SPI_Receive_DMA(&Ports[PortNum].hspi, (uint8_t*)Ports[PortNum].pRxBuffPtr, RX_BUFFER_SIZE);
 800a65a:	68e1      	ldr	r1, [r4, #12]
 800a65c:	223c      	movs	r2, #60	; 0x3c
 800a65e:	0038      	movs	r0, r7
 800a660:	f7fe f8ac 	bl	80087bc <HAL_SPI_Receive_DMA>
  Ports[PortNum].modulo = 0;
 800a664:	0023      	movs	r3, r4
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a666:	2101      	movs	r1, #1
  Ports[PortNum].modulo = 0;
 800a668:	33dd      	adds	r3, #221	; 0xdd
 800a66a:	33ff      	adds	r3, #255	; 0xff
 800a66c:	701d      	strb	r5, [r3, #0]
  Ports[PortNum].ud_index_current[0]=0;
 800a66e:	3b03      	subs	r3, #3
 800a670:	701d      	strb	r5, [r3, #0]
  Ports[PortNum].ud_index_current[1]=0;
 800a672:	705d      	strb	r5, [r3, #1]
  Ports[PortNum].ud_index_current[2]=0;
 800a674:	709d      	strb	r5, [r3, #2]
  (Ports[PortNum].htimcountrx).Instance->CNT = 0;
 800a676:	34fc      	adds	r4, #252	; 0xfc
 800a678:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a67a:	9801      	ldr	r0, [sp, #4]
  (Ports[PortNum].htimcountrx).Instance->CNT = 0;
 800a67c:	6255      	str	r5, [r2, #36]	; 0x24
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a67e:	6953      	ldr	r3, [r2, #20]
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a680:	3079      	adds	r0, #121	; 0x79
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a682:	430b      	orrs	r3, r1
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a684:	30ff      	adds	r0, #255	; 0xff
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a686:	6153      	str	r3, [r2, #20]
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a688:	1830      	adds	r0, r6, r0
 800a68a:	0029      	movs	r1, r5
 800a68c:	f7fe fc82 	bl	8008f94 <HAL_TIM_OC_Start_IT>
}
 800a690:	b005      	add	sp, #20
 800a692:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a = local_hspi->Instance->DR;
 800a694:	68da      	ldr	r2, [r3, #12]
 800a696:	9203      	str	r2, [sp, #12]
    UNUSED(a);
 800a698:	9a03      	ldr	r2, [sp, #12]
 800a69a:	e7d1      	b.n	800a640 <PHY_HW_IF_RX_Start+0x40>
 800a69c:	20000058 	.word	0x20000058

0800a6a0 <HW_IF_PWR_DigitalGPIO_Init>:
/**
  * @brief  Inititialization of the Power Pins.
  * @retval HAL Status
  */
HAL_StatusTypeDef HW_IF_PWR_DigitalGPIO_Init()
{
 800a6a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a6a2:	2500      	movs	r5, #0
 800a6a4:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef  GPIO_InitStruct;
  uint8_t index = 0;
  for(index=0;index<USBPD_POWSELn;index++)
  {
    USBPD_BSP_GPIOPins_TypeDef gpio = USBPD_POWSELs[index];
 800a6a6:	ac02      	add	r4, sp, #8
 800a6a8:	0021      	movs	r1, r4
 800a6aa:	4b10      	ldr	r3, [pc, #64]	; (800a6ec <HW_IF_PWR_DigitalGPIO_Init+0x4c>)
 800a6ac:	195a      	adds	r2, r3, r5
 800a6ae:	cac1      	ldmia	r2!, {r0, r6, r7}
 800a6b0:	c1c1      	stmia	r1!, {r0, r6, r7}
 800a6b2:	58ee      	ldr	r6, [r5, r3]
 800a6b4:	195b      	adds	r3, r3, r5
 800a6b6:	889b      	ldrh	r3, [r3, #4]

    /* Configure the powsels pin */
    GPIO_InitStruct.Pin = gpio.GPIO_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a6b8:	2700      	movs	r7, #0
    USBPD_BSP_GPIOPins_TypeDef gpio = USBPD_POWSELs[index];
 800a6ba:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pin = gpio.GPIO_Pin;
 800a6bc:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a6be:	2301      	movs	r3, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;

    HAL_GPIO_Init(gpio.GPIOx, &GPIO_InitStruct);
 800a6c0:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a6c2:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(gpio.GPIOx, &GPIO_InitStruct);
 800a6c4:	0030      	movs	r0, r6
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800a6c6:	3302      	adds	r3, #2
 800a6c8:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a6ca:	9707      	str	r7, [sp, #28]
    HAL_GPIO_Init(gpio.GPIOx, &GPIO_InitStruct);
 800a6cc:	f7fd f964 	bl	8007998 <HAL_GPIO_Init>

    /* Turn the pin off */
    USBPD_HW_IF_GPIO_Off(gpio);
 800a6d0:	9b01      	ldr	r3, [sp, #4]
 800a6d2:	0030      	movs	r0, r6
 800a6d4:	80a3      	strh	r3, [r4, #4]
 800a6d6:	6861      	ldr	r1, [r4, #4]
 800a6d8:	68a2      	ldr	r2, [r4, #8]
 800a6da:	350c      	adds	r5, #12
 800a6dc:	9602      	str	r6, [sp, #8]
 800a6de:	f7ff fc87 	bl	8009ff0 <USBPD_HW_IF_GPIO_Off>
  for(index=0;index<USBPD_POWSELn;index++)
 800a6e2:	2d30      	cmp	r5, #48	; 0x30
 800a6e4:	d1df      	bne.n	800a6a6 <HW_IF_PWR_DigitalGPIO_Init+0x6>
  }

  return HAL_OK;
}
 800a6e6:	0038      	movs	r0, r7
 800a6e8:	b00b      	add	sp, #44	; 0x2c
 800a6ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a6ec:	0800cd80 	.word	0x0800cd80

0800a6f0 <HW_IF_PWR_SetVoltage>:
USBPD_StatusTypeDef HW_IF_PWR_SetVoltage(uint8_t PortNum, uint16_t voltage)
{
 USBPD_StatusTypeDef ret = USBPD_OK;
#if _PPS==USBPD_FALSE

 set_voltage=voltage;
 800a6f0:	4b2f      	ldr	r3, [pc, #188]	; (800a7b0 <HW_IF_PWR_SetVoltage+0xc0>)
{
 800a6f2:	b510      	push	{r4, lr}
 set_voltage=voltage;
 800a6f4:	8019      	strh	r1, [r3, #0]
   * |  0   |  1   |  0   |  0   | 15V  |
   * |  1   |  0   |  0   |  0   | 20V  |
   * +------+------+------+------+------+
   */

 switch (voltage)
 800a6f6:	4b2f      	ldr	r3, [pc, #188]	; (800a7b4 <HW_IF_PWR_SetVoltage+0xc4>)
 800a6f8:	4299      	cmp	r1, r3
 800a6fa:	d032      	beq.n	800a762 <HW_IF_PWR_SetVoltage+0x72>
 800a6fc:	d804      	bhi.n	800a708 <HW_IF_PWR_SetVoltage+0x18>
 800a6fe:	4b2e      	ldr	r3, [pc, #184]	; (800a7b8 <HW_IF_PWR_SetVoltage+0xc8>)
 800a700:	4299      	cmp	r1, r3
 800a702:	d010      	beq.n	800a726 <HW_IF_PWR_SetVoltage+0x36>
 {
   case 5000:
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a704:	2200      	movs	r2, #0
 800a706:	e006      	b.n	800a716 <HW_IF_PWR_SetVoltage+0x26>
 switch (voltage)
 800a708:	4b2c      	ldr	r3, [pc, #176]	; (800a7bc <HW_IF_PWR_SetVoltage+0xcc>)
 800a70a:	4299      	cmp	r1, r3
 800a70c:	d040      	beq.n	800a790 <HW_IF_PWR_SetVoltage+0xa0>
 800a70e:	4b2c      	ldr	r3, [pc, #176]	; (800a7c0 <HW_IF_PWR_SetVoltage+0xd0>)
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  1);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 0);
       break;
   case 20000:
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  1);
 800a710:	2201      	movs	r2, #1
 switch (voltage)
 800a712:	4299      	cmp	r1, r3
 800a714:	d1f6      	bne.n	800a704 <HW_IF_PWR_SetVoltage+0x14>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  1);
 800a716:	2180      	movs	r1, #128	; 0x80
 800a718:	2090      	movs	r0, #144	; 0x90
 800a71a:	0049      	lsls	r1, r1, #1
 800a71c:	05c0      	lsls	r0, r0, #23
 800a71e:	f7fd f9fd 	bl	8007b1c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
 800a722:	2200      	movs	r2, #0
 800a724:	e03c      	b.n	800a7a0 <HW_IF_PWR_SetVoltage+0xb0>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a726:	2180      	movs	r1, #128	; 0x80
 800a728:	2090      	movs	r0, #144	; 0x90
 800a72a:	2200      	movs	r2, #0
 800a72c:	0049      	lsls	r1, r1, #1
 800a72e:	05c0      	lsls	r0, r0, #23
 800a730:	f7fd f9f4 	bl	8007b1c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
 800a734:	2180      	movs	r1, #128	; 0x80
 800a736:	2090      	movs	r0, #144	; 0x90
 800a738:	2200      	movs	r2, #0
 800a73a:	0089      	lsls	r1, r1, #2
 800a73c:	05c0      	lsls	r0, r0, #23
 800a73e:	f7fd f9ed 	bl	8007b1c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
 800a742:	2180      	movs	r1, #128	; 0x80
 800a744:	2090      	movs	r0, #144	; 0x90
 800a746:	2200      	movs	r2, #0
 800a748:	00c9      	lsls	r1, r1, #3
 800a74a:	05c0      	lsls	r0, r0, #23
 800a74c:	f7fd f9e6 	bl	8007b1c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 1);
 800a750:	2201      	movs	r2, #1
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 0);
 800a752:	2180      	movs	r1, #128	; 0x80
 800a754:	2090      	movs	r0, #144	; 0x90
 800a756:	0109      	lsls	r1, r1, #4
 800a758:	05c0      	lsls	r0, r0, #23
 800a75a:	f7fd f9df 	bl	8007b1c <HAL_GPIO_WritePin>

  ret=(USBPD_StatusTypeDef)STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum),voltage);

#endif
  return USBPD_OK;//ret;
}
 800a75e:	2000      	movs	r0, #0
 800a760:	bd10      	pop	{r4, pc}
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a762:	2180      	movs	r1, #128	; 0x80
 800a764:	2090      	movs	r0, #144	; 0x90
 800a766:	2200      	movs	r2, #0
 800a768:	0049      	lsls	r1, r1, #1
 800a76a:	05c0      	lsls	r0, r0, #23
 800a76c:	f7fd f9d6 	bl	8007b1c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
 800a770:	2180      	movs	r1, #128	; 0x80
 800a772:	2090      	movs	r0, #144	; 0x90
 800a774:	2200      	movs	r2, #0
 800a776:	0089      	lsls	r1, r1, #2
 800a778:	05c0      	lsls	r0, r0, #23
 800a77a:	f7fd f9cf 	bl	8007b1c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 1);
 800a77e:	2201      	movs	r2, #1
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
 800a780:	2180      	movs	r1, #128	; 0x80
 800a782:	2090      	movs	r0, #144	; 0x90
 800a784:	00c9      	lsls	r1, r1, #3
 800a786:	05c0      	lsls	r0, r0, #23
 800a788:	f7fd f9c8 	bl	8007b1c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 0);
 800a78c:	2200      	movs	r2, #0
 800a78e:	e7e0      	b.n	800a752 <HW_IF_PWR_SetVoltage+0x62>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a790:	2180      	movs	r1, #128	; 0x80
 800a792:	2090      	movs	r0, #144	; 0x90
 800a794:	2200      	movs	r2, #0
 800a796:	0049      	lsls	r1, r1, #1
 800a798:	05c0      	lsls	r0, r0, #23
 800a79a:	f7fd f9bf 	bl	8007b1c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  1);
 800a79e:	2201      	movs	r2, #1
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
 800a7a0:	2180      	movs	r1, #128	; 0x80
 800a7a2:	2090      	movs	r0, #144	; 0x90
 800a7a4:	0089      	lsls	r1, r1, #2
 800a7a6:	05c0      	lsls	r0, r0, #23
 800a7a8:	f7fd f9b8 	bl	8007b1c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
 800a7ac:	2200      	movs	r2, #0
 800a7ae:	e7e7      	b.n	800a780 <HW_IF_PWR_SetVoltage+0x90>
 800a7b0:	200003d8 	.word	0x200003d8
 800a7b4:	00002ee0 	.word	0x00002ee0
 800a7b8:	00002328 	.word	0x00002328
 800a7bc:	00003a98 	.word	0x00003a98
 800a7c0:	00004e20 	.word	0x00004e20

0800a7c4 <HW_IF_PWR_GetVoltage>:
uint16_t HW_IF_PWR_GetVoltage(uint8_t PortNum)
{
#ifdef __VVAR
   return (uint16_t)MVOLT(ADCxConvertedValues[VBUS_INDEX(PortNum)]);
#else
   get_voltage = (uint16_t)(STUSB1602_VBUS_Select_Status_Get(STUSB1602_I2C_Add(PortNum)));
 800a7c4:	1e43      	subs	r3, r0, #1
 800a7c6:	4198      	sbcs	r0, r3
{
 800a7c8:	b510      	push	{r4, lr}
   get_voltage = (uint16_t)(STUSB1602_VBUS_Select_Status_Get(STUSB1602_I2C_Add(PortNum)));
 800a7ca:	3028      	adds	r0, #40	; 0x28
 800a7cc:	f7fc fa42 	bl	8006c54 <STUSB1602_VBUS_Select_Status_Get>
 800a7d0:	4b01      	ldr	r3, [pc, #4]	; (800a7d8 <HW_IF_PWR_GetVoltage+0x14>)
 800a7d2:	8058      	strh	r0, [r3, #2]
   return get_voltage;
#endif
}
 800a7d4:	bd10      	pop	{r4, pc}
 800a7d6:	46c0      	nop			; (mov r8, r8)
 800a7d8:	200003d8 	.word	0x200003d8

0800a7dc <HW_IF_PWR_GetVoltage_from_reg>:
  * @param  PortNum port index
  * @retval The voltage value
  */
uint16_t HW_IF_PWR_GetVoltage_from_reg(uint8_t PortNum)
{
  return (uint16_t)(STUSB1602_VBUS_Select_Status_Get(STUSB1602_I2C_Add(PortNum)));
 800a7dc:	1e43      	subs	r3, r0, #1
 800a7de:	4198      	sbcs	r0, r3
{
 800a7e0:	b510      	push	{r4, lr}
  return (uint16_t)(STUSB1602_VBUS_Select_Status_Get(STUSB1602_I2C_Add(PortNum)));
 800a7e2:	3028      	adds	r0, #40	; 0x28
 800a7e4:	f7fc fa36 	bl	8006c54 <STUSB1602_VBUS_Select_Status_Get>
}
 800a7e8:	bd10      	pop	{r4, pc}
	...

0800a7ec <HW_IF_PWR_Enable>:
  * @param  VconnState VCONN state
  * @param  role       Power role
  * @retval USBPD status
  */
HAL_StatusTypeDef HW_IF_PWR_Enable(uint8_t PortNum, USBPD_FunctionalState state, CCxPin_TypeDef Cc, uint32_t VconnState, USBPD_PortPowerRole_TypeDef role)
{
 800a7ec:	b570      	push	{r4, r5, r6, lr}
  HAL_StatusTypeDef ret = HAL_ERROR;
#if defined(CONF_NORMAL) || defined(CONF_DEMO_FPGA)
  uint32_t offset_port = (PortNum == 0) ? 0 : 2;
 800a7ee:	0004      	movs	r4, r0
    ret = HAL_OK; /* To allow compatibility with other type-c controllers */
  }

#ifdef CONF_NORMAL
  /* both pin are set off */
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a7f0:	260c      	movs	r6, #12
  uint32_t offset_port = (PortNum == 0) ? 0 : 2;
 800a7f2:	1e60      	subs	r0, r4, #1
 800a7f4:	4184      	sbcs	r4, r0
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a7f6:	0033      	movs	r3, r6
  uint32_t offset_port = (PortNum == 0) ? 0 : 2;
 800a7f8:	0064      	lsls	r4, r4, #1
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a7fa:	4363      	muls	r3, r4
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
 800a7fc:	3401      	adds	r4, #1
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a7fe:	4d08      	ldr	r5, [pc, #32]	; (800a820 <HW_IF_PWR_Enable+0x34>)
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
 800a800:	4366      	muls	r6, r4
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a802:	5958      	ldr	r0, [r3, r5]
 800a804:	18eb      	adds	r3, r5, r3
 800a806:	6859      	ldr	r1, [r3, #4]
 800a808:	689a      	ldr	r2, [r3, #8]
 800a80a:	f7ff fbf1 	bl	8009ff0 <USBPD_HW_IF_GPIO_Off>
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
 800a80e:	5970      	ldr	r0, [r6, r5]
 800a810:	19ad      	adds	r5, r5, r6
 800a812:	6869      	ldr	r1, [r5, #4]
 800a814:	68aa      	ldr	r2, [r5, #8]
 800a816:	f7ff fbeb 	bl	8009ff0 <USBPD_HW_IF_GPIO_Off>
  /* set SEL1 according to the selected voltage and the table STCH2 Voltage Output */
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
#endif

  return ret;
}
 800a81a:	2000      	movs	r0, #0
 800a81c:	bd70      	pop	{r4, r5, r6, pc}
 800a81e:	46c0      	nop			; (mov r8, r8)
 800a820:	0800cd80 	.word	0x0800cd80

0800a824 <HW_IF_PWR_VBUSIsEnabled>:
//  {
//    ret = (HAL_GPIO_ReadPin(USBPDM1_GPIOs[PWREN_P1].GPIOx, USBPDM1_GPIOs[PWREN_P1].GPIO_Pin) == GPIO_PIN_SET) ? USBPD_ENABLE : USBPD_DISABLE ;
//  }
//#endif
  return ret;
}
 800a824:	2000      	movs	r0, #0
 800a826:	4770      	bx	lr

0800a828 <LL_SYSCFG_SetEXTISource>:
{
 800a828:	b510      	push	{r4, lr}
  MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], SYSCFG_EXTICR1_EXTI0 << (Line >> 16), Port << (Line >> 16));
 800a82a:	240f      	movs	r4, #15
 800a82c:	b2cb      	uxtb	r3, r1
 800a82e:	0c09      	lsrs	r1, r1, #16
 800a830:	408c      	lsls	r4, r1
 800a832:	4088      	lsls	r0, r1
 800a834:	4a03      	ldr	r2, [pc, #12]	; (800a844 <LL_SYSCFG_SetEXTISource+0x1c>)
 800a836:	009b      	lsls	r3, r3, #2
 800a838:	189b      	adds	r3, r3, r2
 800a83a:	689a      	ldr	r2, [r3, #8]
 800a83c:	43a2      	bics	r2, r4
 800a83e:	4310      	orrs	r0, r2
 800a840:	6098      	str	r0, [r3, #8]
}
 800a842:	bd10      	pop	{r4, pc}
 800a844:	40010000 	.word	0x40010000

0800a848 <HW_IF_COMM_WAIT>:
{
  USBPD_StatusTypeDef ret = USBPD_ERROR;
  int16_t timeout = Timeout;
  while (1)
  {
    if (Ports[PortNum].CommLock == 0)
 800a848:	23f0      	movs	r3, #240	; 0xf0
 800a84a:	005b      	lsls	r3, r3, #1
 800a84c:	001a      	movs	r2, r3
 800a84e:	4342      	muls	r2, r0
{
 800a850:	b510      	push	{r4, lr}
    if (Ports[PortNum].CommLock == 0)
 800a852:	4c0b      	ldr	r4, [pc, #44]	; (800a880 <HW_IF_COMM_WAIT+0x38>)
 800a854:	18a2      	adds	r2, r4, r2
 800a856:	32d2      	adds	r2, #210	; 0xd2
 800a858:	32ff      	adds	r2, #255	; 0xff
 800a85a:	7812      	ldrb	r2, [r2, #0]
 800a85c:	2a00      	cmp	r2, #0
 800a85e:	d107      	bne.n	800a870 <HW_IF_COMM_WAIT+0x28>
    {
      /* the resource is free */
      Ports[PortNum].CommLock = 1;
 800a860:	2101      	movs	r1, #1
 800a862:	4343      	muls	r3, r0
      ret = USBPD_OK;
 800a864:	0010      	movs	r0, r2
      Ports[PortNum].CommLock = 1;
 800a866:	18e3      	adds	r3, r4, r3
 800a868:	33d2      	adds	r3, #210	; 0xd2
 800a86a:	33ff      	adds	r3, #255	; 0xff
 800a86c:	7019      	strb	r1, [r3, #0]
    {
      timeout--;
    }
  }
  return ret;
}
 800a86e:	bd10      	pop	{r4, pc}
    if (timeout == 0)
 800a870:	2900      	cmp	r1, #0
 800a872:	d002      	beq.n	800a87a <HW_IF_COMM_WAIT+0x32>
 800a874:	3901      	subs	r1, #1
 800a876:	b209      	sxth	r1, r1
 800a878:	e7f0      	b.n	800a85c <HW_IF_COMM_WAIT+0x14>
      ret = USBPD_TIMEOUT;
 800a87a:	2004      	movs	r0, #4
 800a87c:	e7f7      	b.n	800a86e <HW_IF_COMM_WAIT+0x26>
 800a87e:	46c0      	nop			; (mov r8, r8)
 800a880:	20000058 	.word	0x20000058

0800a884 <HW_IF_COMM_RELEASE>:
  * @param   PortNum The port index
  * @retval  USBPD status 
*/
static USBPD_StatusTypeDef HW_IF_COMM_RELEASE(uint8_t PortNum)
{
  if (Ports[PortNum].CommLock == 0)
 800a884:	23f0      	movs	r3, #240	; 0xf0
 800a886:	005b      	lsls	r3, r3, #1
 800a888:	4358      	muls	r0, r3
 800a88a:	4b05      	ldr	r3, [pc, #20]	; (800a8a0 <HW_IF_COMM_RELEASE+0x1c>)
 800a88c:	181b      	adds	r3, r3, r0
 800a88e:	33d2      	adds	r3, #210	; 0xd2
 800a890:	33ff      	adds	r3, #255	; 0xff
 800a892:	781a      	ldrb	r2, [r3, #0]
  {
    /* no change, the resource is already free */
    return USBPD_ERROR;
 800a894:	2002      	movs	r0, #2
  if (Ports[PortNum].CommLock == 0)
 800a896:	2a00      	cmp	r2, #0
 800a898:	d001      	beq.n	800a89e <HW_IF_COMM_RELEASE+0x1a>
  }

  /* release the resource */
  Ports[PortNum].CommLock = 0;
 800a89a:	2000      	movs	r0, #0
 800a89c:	7018      	strb	r0, [r3, #0]
  return USBPD_OK;
}
 800a89e:	4770      	bx	lr
 800a8a0:	20000058 	.word	0x20000058

0800a8a4 <LL_APB1_GRP2_EnableClock.constprop.7>:
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP2_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 800a8a4:	2001      	movs	r0, #1
 800a8a6:	4a05      	ldr	r2, [pc, #20]	; (800a8bc <LL_APB1_GRP2_EnableClock.constprop.7+0x18>)
__STATIC_INLINE void LL_APB1_GRP2_EnableClock(uint32_t Periphs)
 800a8a8:	b082      	sub	sp, #8
  SET_BIT(RCC->APB2ENR, Periphs);
 800a8aa:	6991      	ldr	r1, [r2, #24]
 800a8ac:	4301      	orrs	r1, r0
 800a8ae:	6191      	str	r1, [r2, #24]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 800a8b0:	6993      	ldr	r3, [r2, #24]
 800a8b2:	4003      	ands	r3, r0
 800a8b4:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 800a8b6:	9b01      	ldr	r3, [sp, #4]
}
 800a8b8:	b002      	add	sp, #8
 800a8ba:	4770      	bx	lr
 800a8bc:	40021000 	.word	0x40021000

0800a8c0 <USBPDM1_AssertRp>:
}
 800a8c0:	4770      	bx	lr

0800a8c2 <USBPDM1_DeAssertRp>:
 800a8c2:	4770      	bx	lr

0800a8c4 <USBPDM1_AssertRd>:
 800a8c4:	4770      	bx	lr

0800a8c6 <USBPDM1_DeAssertRd>:
 800a8c6:	4770      	bx	lr

0800a8c8 <USBPD_HW_IF_HR_Start>:
{
 800a8c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800a8ca:	2164      	movs	r1, #100	; 0x64
{
 800a8cc:	0006      	movs	r6, r0
 800a8ce:	0017      	movs	r7, r2
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800a8d0:	f7ff ffba 	bl	800a848 <HW_IF_COMM_WAIT>
 800a8d4:	1e05      	subs	r5, r0, #0
  if (ret != USBPD_OK)
 800a8d6:	d144      	bne.n	800a962 <USBPD_HW_IF_HR_Start+0x9a>
  if (Ports[PortNum].Device_cut == Cut_1)
 800a8d8:	22f0      	movs	r2, #240	; 0xf0
 800a8da:	0052      	lsls	r2, r2, #1
 800a8dc:	4372      	muls	r2, r6
 800a8de:	4b22      	ldr	r3, [pc, #136]	; (800a968 <USBPD_HW_IF_HR_Start+0xa0>)
 800a8e0:	189b      	adds	r3, r3, r2
 800a8e2:	33d9      	adds	r3, #217	; 0xd9
 800a8e4:	33ff      	adds	r3, #255	; 0xff
 800a8e6:	781b      	ldrb	r3, [r3, #0]
 800a8e8:	2b03      	cmp	r3, #3
 800a8ea:	d106      	bne.n	800a8fa <USBPD_HW_IF_HR_Start+0x32>
    STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Disable);
 800a8ec:	0030      	movs	r0, r6
 800a8ee:	1e43      	subs	r3, r0, #1
 800a8f0:	4198      	sbcs	r0, r3
 800a8f2:	2101      	movs	r1, #1
 800a8f4:	3028      	adds	r0, #40	; 0x28
 800a8f6:	f7fc fac9 	bl	8006e8c <STUSB1602_VBUS_Range_State_Set>
  STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000);
 800a8fa:	0034      	movs	r4, r6
 800a8fc:	1e63      	subs	r3, r4, #1
 800a8fe:	419c      	sbcs	r4, r3
 800a900:	3428      	adds	r4, #40	; 0x28
 800a902:	491a      	ldr	r1, [pc, #104]	; (800a96c <USBPD_HW_IF_HR_Start+0xa4>)
 800a904:	0020      	movs	r0, r4
 800a906:	f7fc f9b3 	bl	8006c70 <STUSB1602_VBUS_Select_Status_Set>
  ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), Mode == ACKNOWLEDGE ? PD_HARD_RESET_RECEIVED_REQ : PD_HARD_RESET_SEND_REQ);
 800a90a:	0039      	movs	r1, r7
 800a90c:	1e4b      	subs	r3, r1, #1
 800a90e:	4199      	sbcs	r1, r3
 800a910:	0020      	movs	r0, r4
 800a912:	310e      	adds	r1, #14
 800a914:	f7fc fb01 	bl	8006f1a <STUSB1602_Type_C_Command>
 800a918:	0005      	movs	r5, r0
  if (Mode == ACKNOWLEDGE)
 800a91a:	2f00      	cmp	r7, #0
 800a91c:	d105      	bne.n	800a92a <USBPD_HW_IF_HR_Start+0x62>
 800a91e:	23c8      	movs	r3, #200	; 0xc8
 800a920:	46c0      	nop			; (mov r8, r8)
 800a922:	3b01      	subs	r3, #1
 800a924:	b29b      	uxth	r3, r3
    for(uint16_t i=0;i<200;i++)
 800a926:	2b00      	cmp	r3, #0
 800a928:	d1fa      	bne.n	800a920 <USBPD_HW_IF_HR_Start+0x58>
  if (ret == USBPD_OK)
 800a92a:	2800      	cmp	r0, #0
 800a92c:	d116      	bne.n	800a95c <USBPD_HW_IF_HR_Start+0x94>
  STUSB1602_CC_DETECTION_STATUS_Value = STUSB1602_CC_Detection_Status_Get(STUSB1602_I2C_Add(PortNum));
 800a92e:	0020      	movs	r0, r4
 800a930:	f7fc f84c 	bl	80069cc <STUSB1602_CC_Detection_Status_Get>
  if (STUSB1602_CC_DETECTION_STATUS_Value.b.CC_VCONN_SUPPLY_STATE == VCONN_supplied_on_unused_CC_pin)
 800a934:	2102      	movs	r1, #2
 800a936:	b2c7      	uxtb	r7, r0
 800a938:	420f      	tst	r7, r1
 800a93a:	d003      	beq.n	800a944 <USBPD_HW_IF_HR_Start+0x7c>
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_TURN_OFF_VCONN_REQ);
 800a93c:	0020      	movs	r0, r4
 800a93e:	f7fc faec 	bl	8006f1a <STUSB1602_Type_C_Command>
 800a942:	0005      	movs	r5, r0
      (((Power_Role_TypeDef)STUSB1602_CC_DETECTION_STATUS_Value.b.CC_POWER_ROLE == Source) &&
 800a944:	210c      	movs	r1, #12
 800a946:	4039      	ands	r1, r7
  if (
 800a948:	2908      	cmp	r1, #8
 800a94a:	d105      	bne.n	800a958 <USBPD_HW_IF_HR_Start+0x90>
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_PORT_CHANGE_2_DFP_REQ);
 800a94c:	3905      	subs	r1, #5
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_PORT_CHANGE_2_UFP_REQ);
 800a94e:	0020      	movs	r0, r4
 800a950:	f7fc fae3 	bl	8006f1a <STUSB1602_Type_C_Command>
 800a954:	0005      	movs	r5, r0
 800a956:	e001      	b.n	800a95c <USBPD_HW_IF_HR_Start+0x94>
  if (
 800a958:	2904      	cmp	r1, #4
 800a95a:	d0f8      	beq.n	800a94e <USBPD_HW_IF_HR_Start+0x86>
  HW_IF_COMM_RELEASE(PortNum);
 800a95c:	0030      	movs	r0, r6
 800a95e:	f7ff ff91 	bl	800a884 <HW_IF_COMM_RELEASE>
}
 800a962:	0028      	movs	r0, r5
 800a964:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a966:	46c0      	nop			; (mov r8, r8)
 800a968:	20000058 	.word	0x20000058
 800a96c:	00001388 	.word	0x00001388

0800a970 <USBPD_HW_IF_HR_CheckVbusVSafe0V>:
{
 800a970:	b510      	push	{r4, lr}
  if (CurrentRole == USBPD_PORTPOWERROLE_SRC)
 800a972:	2901      	cmp	r1, #1
 800a974:	d102      	bne.n	800a97c <USBPD_HW_IF_HR_CheckVbusVSafe0V+0xc>
    return USBPD_OK;
 800a976:	2300      	movs	r3, #0
}
 800a978:	0018      	movs	r0, r3
 800a97a:	bd10      	pop	{r4, pc}
  return USBPD_ERROR;
 800a97c:	2302      	movs	r3, #2
  if (CurrentRole == USBPD_PORTPOWERROLE_SNK)
 800a97e:	2900      	cmp	r1, #0
 800a980:	d1fa      	bne.n	800a978 <USBPD_HW_IF_HR_CheckVbusVSafe0V+0x8>
    return STUSB1602_VBUS_Presence_Get(STUSB1602_I2C_Add(PortNum)) == VBUS_below_UVLO_threshold ? USBPD_OK : USBPD_BUSY;
 800a982:	1e43      	subs	r3, r0, #1
 800a984:	4198      	sbcs	r0, r3
 800a986:	3028      	adds	r0, #40	; 0x28
 800a988:	f7fc f84c 	bl	8006a24 <STUSB1602_VBUS_Presence_Get>
 800a98c:	2800      	cmp	r0, #0
 800a98e:	d0f2      	beq.n	800a976 <USBPD_HW_IF_HR_CheckVbusVSafe0V+0x6>
 800a990:	2303      	movs	r3, #3
 800a992:	e7f1      	b.n	800a978 <USBPD_HW_IF_HR_CheckVbusVSafe0V+0x8>

0800a994 <USBPD_HW_IF_HR_End>:
{
 800a994:	b570      	push	{r4, r5, r6, lr}
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800a996:	2164      	movs	r1, #100	; 0x64
{
 800a998:	0006      	movs	r6, r0
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800a99a:	f7ff ff55 	bl	800a848 <HW_IF_COMM_WAIT>
 800a99e:	1e05      	subs	r5, r0, #0
  if (ret != USBPD_OK)
 800a9a0:	d113      	bne.n	800a9ca <USBPD_HW_IF_HR_End+0x36>
  ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_COMPLETE_REQ);    
 800a9a2:	0034      	movs	r4, r6
 800a9a4:	1e63      	subs	r3, r4, #1
 800a9a6:	419c      	sbcs	r4, r3
 800a9a8:	3428      	adds	r4, #40	; 0x28
 800a9aa:	2101      	movs	r1, #1
 800a9ac:	0020      	movs	r0, r4
 800a9ae:	f7fc fab4 	bl	8006f1a <STUSB1602_Type_C_Command>
  ret = (USBPD_StatusTypeDef)STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000);
 800a9b2:	4907      	ldr	r1, [pc, #28]	; (800a9d0 <USBPD_HW_IF_HR_End+0x3c>)
 800a9b4:	0020      	movs	r0, r4
 800a9b6:	f7fc f95b 	bl	8006c70 <STUSB1602_VBUS_Select_Status_Set>
  STUSB1602_CC_Detect_Alrt_Int_Mask_Set(STUSB1602_I2C_Add(PortNum), CC_Detect_Int_UNMASKED);
 800a9ba:	2100      	movs	r1, #0
  ret = (USBPD_StatusTypeDef)STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000);
 800a9bc:	0005      	movs	r5, r0
  STUSB1602_CC_Detect_Alrt_Int_Mask_Set(STUSB1602_I2C_Add(PortNum), CC_Detect_Int_UNMASKED);
 800a9be:	0020      	movs	r0, r4
 800a9c0:	f7fb ffe0 	bl	8006984 <STUSB1602_CC_Detect_Alrt_Int_Mask_Set>
  HW_IF_COMM_RELEASE(PortNum);
 800a9c4:	0030      	movs	r0, r6
 800a9c6:	f7ff ff5d 	bl	800a884 <HW_IF_COMM_RELEASE>
}
 800a9ca:	0028      	movs	r0, r5
 800a9cc:	bd70      	pop	{r4, r5, r6, pc}
 800a9ce:	46c0      	nop			; (mov r8, r8)
 800a9d0:	00001388 	.word	0x00001388

0800a9d4 <USBPD_HW_IF_ErrorRecovery>:
{
 800a9d4:	b510      	push	{r4, lr}
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), SW_RST);
 800a9d6:	1e44      	subs	r4, r0, #1
 800a9d8:	41a0      	sbcs	r0, r4
 800a9da:	3028      	adds	r0, #40	; 0x28
 800a9dc:	0004      	movs	r4, r0
 800a9de:	2101      	movs	r1, #1
 800a9e0:	f7fc f993 	bl	8006d0a <STUSB1602_SW_RESET_Set>
  HAL_Delay(27); // need to be 25ms min
 800a9e4:	201b      	movs	r0, #27
 800a9e6:	f7fc fb91 	bl	800710c <HAL_Delay>
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), No_SW_RST);
 800a9ea:	2100      	movs	r1, #0
 800a9ec:	0020      	movs	r0, r4
 800a9ee:	f7fc f98c 	bl	8006d0a <STUSB1602_SW_RESET_Set>
}
 800a9f2:	2000      	movs	r0, #0
 800a9f4:	bd10      	pop	{r4, pc}
	...

0800a9f8 <HW_IF_SPI_Init>:
  * @retval None
  */ 
void HW_IF_SPI_Init(uint8_t PortNum)
{
  /* Get the peripheral handler variable */
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800a9f8:	21f0      	movs	r1, #240	; 0xf0
 800a9fa:	0049      	lsls	r1, r1, #1
 800a9fc:	4341      	muls	r1, r0
{
 800a9fe:	0002      	movs	r2, r0
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800aa00:	0008      	movs	r0, r1
 800aa02:	4b11      	ldr	r3, [pc, #68]	; (800aa48 <HW_IF_SPI_Init+0x50>)
{
 800aa04:	b510      	push	{r4, lr}
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800aa06:	3040      	adds	r0, #64	; 0x40
  
  phspi->Instance =           SPI_Instance(PortNum);
 800aa08:	4254      	negs	r4, r2
 800aa0a:	4162      	adcs	r2, r4
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800aa0c:	18c0      	adds	r0, r0, r3
  phspi->Instance =           SPI_Instance(PortNum);
 800aa0e:	185b      	adds	r3, r3, r1
  phspi->Init.Mode =           SPI_MODE_SLAVE;
  phspi->Init.Direction =  SPI_DIRECTION_2LINES;
  phspi->Init.DataSize =   SPI_DATASIZE_8BIT;
 800aa10:	21e0      	movs	r1, #224	; 0xe0
  phspi->Instance =           SPI_Instance(PortNum);
 800aa12:	4c0e      	ldr	r4, [pc, #56]	; (800aa4c <HW_IF_SPI_Init+0x54>)
 800aa14:	4252      	negs	r2, r2
 800aa16:	4022      	ands	r2, r4
  phspi->Init.DataSize =   SPI_DATASIZE_8BIT;
 800aa18:	00c9      	lsls	r1, r1, #3
  phspi->Instance =           SPI_Instance(PortNum);
 800aa1a:	4c0d      	ldr	r4, [pc, #52]	; (800aa50 <HW_IF_SPI_Init+0x58>)
  phspi->Init.DataSize =   SPI_DATASIZE_8BIT;
 800aa1c:	64d9      	str	r1, [r3, #76]	; 0x4c
  phspi->Init.CLKPolarity =     SPI_POLARITY_HIGH;
 800aa1e:	2102      	movs	r1, #2
  phspi->Instance =           SPI_Instance(PortNum);
 800aa20:	1912      	adds	r2, r2, r4
 800aa22:	641a      	str	r2, [r3, #64]	; 0x40
  phspi->Init.Mode =           SPI_MODE_SLAVE;
 800aa24:	2200      	movs	r2, #0
  phspi->Init.CLKPolarity =     SPI_POLARITY_HIGH;
 800aa26:	6519      	str	r1, [r3, #80]	; 0x50
  phspi->Init.CLKPhase =   SPI_PHASE_1EDGE;
  phspi->Init.NSS =     SPI_NSS_HARD_INPUT;
  phspi->Init.FirstBit =   SPI_FIRSTBIT_LSB;
 800aa28:	317e      	adds	r1, #126	; 0x7e
 800aa2a:	6619      	str	r1, [r3, #96]	; 0x60
  phspi->Init.TIMode =     SPI_TIMODE_DISABLE;
  phspi->Init.CRCCalculation =  SPI_CRCCALCULATION_DISABLE;
  phspi->Init.CRCPolynomial =   7;
 800aa2c:	3979      	subs	r1, #121	; 0x79
  phspi->Init.Mode =           SPI_MODE_SLAVE;
 800aa2e:	645a      	str	r2, [r3, #68]	; 0x44
  phspi->Init.Direction =  SPI_DIRECTION_2LINES;
 800aa30:	649a      	str	r2, [r3, #72]	; 0x48
  phspi->Init.CLKPhase =   SPI_PHASE_1EDGE;
 800aa32:	655a      	str	r2, [r3, #84]	; 0x54
  phspi->Init.NSS =     SPI_NSS_HARD_INPUT;
 800aa34:	659a      	str	r2, [r3, #88]	; 0x58
  phspi->Init.TIMode =     SPI_TIMODE_DISABLE;
 800aa36:	665a      	str	r2, [r3, #100]	; 0x64
  phspi->Init.CRCCalculation =  SPI_CRCCALCULATION_DISABLE;
 800aa38:	669a      	str	r2, [r3, #104]	; 0x68
  phspi->Init.CRCPolynomial =   7;
 800aa3a:	66d9      	str	r1, [r3, #108]	; 0x6c
  phspi->Init.CRCLength =   SPI_CRC_LENGTH_DATASIZE;
 800aa3c:	671a      	str	r2, [r3, #112]	; 0x70
  phspi->Init.NSSPMode =   SPI_NSS_PULSE_DISABLE;
 800aa3e:	675a      	str	r2, [r3, #116]	; 0x74
  
  HAL_SPI_Init(phspi);
 800aa40:	f7fd fcee 	bl	8008420 <HAL_SPI_Init>
}
 800aa44:	bd10      	pop	{r4, pc}
 800aa46:	46c0      	nop			; (mov r8, r8)
 800aa48:	20000058 	.word	0x20000058
 800aa4c:	ffff0800 	.word	0xffff0800
 800aa50:	40013000 	.word	0x40013000

0800aa54 <HW_IF_SPI_Mode>:
  * @param  PortNum The port index
  * @param  mode Two allowed values: STUSB16xx_SPI_Mode_TX or STUSB16xx_SPI_Mode_RX
  * @retval None
  */ 
void HW_IF_SPI_Mode(uint8_t PortNum, STUSB1602_SPI_Mode_TypeDef mode)
{
 800aa54:	b570      	push	{r4, r5, r6, lr}
  /* Stop the SPI DMA before changing SPI mode */
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800aa56:	25f0      	movs	r5, #240	; 0xf0
 800aa58:	006d      	lsls	r5, r5, #1
 800aa5a:	4345      	muls	r5, r0
 800aa5c:	0028      	movs	r0, r5
 800aa5e:	4e1d      	ldr	r6, [pc, #116]	; (800aad4 <HW_IF_SPI_Mode+0x80>)
 800aa60:	3040      	adds	r0, #64	; 0x40
 800aa62:	1980      	adds	r0, r0, r6
{
 800aa64:	000c      	movs	r4, r1
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800aa66:	f7fd ff5b 	bl	8008920 <HAL_SPI_DMAStop>
  
  /* Disable SPI peripheral */
  __HAL_SPI_DISABLE(&Ports[PortNum].hspi);
 800aa6a:	2140      	movs	r1, #64	; 0x40
 800aa6c:	1970      	adds	r0, r6, r5
 800aa6e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800aa70:	681a      	ldr	r2, [r3, #0]
 800aa72:	438a      	bics	r2, r1
 800aa74:	601a      	str	r2, [r3, #0]
  
  CR1Value = phspi->Instance->CR1;
  
  /* If cut 1.2 is used, SPI is configured to sample data
     on rising edge on TX phase as well as on falling edge on RX phase */
  if (Ports[PortNum].Device_cut== Cut_1)
 800aa76:	0002      	movs	r2, r0
 800aa78:	32d9      	adds	r2, #217	; 0xd9
 800aa7a:	32ff      	adds	r2, #255	; 0xff
 800aa7c:	7812      	ldrb	r2, [r2, #0]
  CR1Value = phspi->Instance->CR1;
 800aa7e:	6819      	ldr	r1, [r3, #0]
  if (Ports[PortNum].Device_cut== Cut_1)
 800aa80:	2a03      	cmp	r2, #3
 800aa82:	d110      	bne.n	800aaa6 <HW_IF_SPI_Mode+0x52>
  {  
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^mode)&1;
 800aa84:	2501      	movs	r5, #1
 800aa86:	0849      	lsrs	r1, r1, #1
    phspi->Instance->CR1 &= ~1;
 800aa88:	681a      	ldr	r2, [r3, #0]
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^mode)&1;
 800aa8a:	4029      	ands	r1, r5
 800aa8c:	4061      	eors	r1, r4
    phspi->Instance->CR1 &= ~1;
 800aa8e:	43aa      	bics	r2, r5
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^mode)&1;
 800aa90:	4029      	ands	r1, r5
 800aa92:	6541      	str	r1, [r0, #84]	; 0x54
    phspi->Instance->CR1 &= ~1;
 800aa94:	601a      	str	r2, [r3, #0]
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^mode)&1;
 800aa96:	681a      	ldr	r2, [r3, #0]
    phspi->Instance->CR1 &= ~1;
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^1)&1;

    /* SPI NSS software or hardware according to the mode value */
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800aa98:	4311      	orrs	r1, r2
 800aa9a:	6019      	str	r1, [r3, #0]
  }
  
  /* Enable SPI peripheral */
  __HAL_SPI_ENABLE(&Ports[PortNum].hspi);
 800aa9c:	2240      	movs	r2, #64	; 0x40
 800aa9e:	6819      	ldr	r1, [r3, #0]
 800aaa0:	430a      	orrs	r2, r1
 800aaa2:	601a      	str	r2, [r3, #0]
}
 800aaa4:	bd70      	pop	{r4, r5, r6, pc}
  if (Ports[PortNum].Device_cut == Cut_1_A)
 800aaa6:	2a04      	cmp	r2, #4
 800aaa8:	d1f8      	bne.n	800aa9c <HW_IF_SPI_Mode+0x48>
 800aaaa:	2501      	movs	r5, #1
 800aaac:	002e      	movs	r6, r5
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^1)&1;
 800aaae:	0849      	lsrs	r1, r1, #1
 800aab0:	438e      	bics	r6, r1
    phspi->Instance->CR1 &= ~1;
 800aab2:	6819      	ldr	r1, [r3, #0]
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^1)&1;
 800aab4:	6546      	str	r6, [r0, #84]	; 0x54
    phspi->Instance->CR1 &= ~1;
 800aab6:	43a9      	bics	r1, r5
 800aab8:	6019      	str	r1, [r3, #0]
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^1)&1;
 800aaba:	681a      	ldr	r2, [r3, #0]
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800aabc:	4906      	ldr	r1, [pc, #24]	; (800aad8 <HW_IF_SPI_Mode+0x84>)
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^1)&1;
 800aabe:	4332      	orrs	r2, r6
 800aac0:	601a      	str	r2, [r3, #0]
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800aac2:	681a      	ldr	r2, [r3, #0]
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800aac4:	402c      	ands	r4, r5
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800aac6:	400a      	ands	r2, r1
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800aac8:	4261      	negs	r1, r4
 800aaca:	4161      	adcs	r1, r4
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800aacc:	601a      	str	r2, [r3, #0]
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800aace:	681a      	ldr	r2, [r3, #0]
 800aad0:	0249      	lsls	r1, r1, #9
 800aad2:	e7e1      	b.n	800aa98 <HW_IF_SPI_Mode+0x44>
 800aad4:	20000058 	.word	0x20000058
 800aad8:	fffffdff 	.word	0xfffffdff

0800aadc <HW_IF_DMA_Init>:
  * @brief  DMA init function
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_DMA_Init(uint8_t PortNum)
{
 800aadc:	b507      	push	{r0, r1, r2, lr}
 800aade:	2201      	movs	r2, #1
 800aae0:	4b09      	ldr	r3, [pc, #36]	; (800ab08 <HW_IF_DMA_Init+0x2c>)
  /* DMA controller clock enable */
  DMA_CLK_ENABLE(PortNum);
 800aae2:	6959      	ldr	r1, [r3, #20]
 800aae4:	4311      	orrs	r1, r2
 800aae6:	6159      	str	r1, [r3, #20]
 800aae8:	695b      	ldr	r3, [r3, #20]
 800aaea:	401a      	ands	r2, r3
 800aaec:	2800      	cmp	r0, #0
 800aaee:	d107      	bne.n	800ab00 <HW_IF_DMA_Init+0x24>
 800aaf0:	9200      	str	r2, [sp, #0]
 800aaf2:	9b00      	ldr	r3, [sp, #0]

  /* NVIC configuration for DMA */
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800aaf4:	300b      	adds	r0, #11
 800aaf6:	2200      	movs	r2, #0
 800aaf8:	0011      	movs	r1, r2
 800aafa:	f7fc fd73 	bl	80075e4 <HAL_NVIC_SetPriority>
}
 800aafe:	bd07      	pop	{r0, r1, r2, pc}
  DMA_CLK_ENABLE(PortNum);
 800ab00:	9201      	str	r2, [sp, #4]
 800ab02:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800ab04:	200a      	movs	r0, #10
 800ab06:	e7f6      	b.n	800aaf6 <HW_IF_DMA_Init+0x1a>
 800ab08:	40021000 	.word	0x40021000

0800ab0c <HW_IF_STUSB16xx_I2C_Init>:
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_STUSB16xx_I2C_Init(uint8_t PortNum)
{
  I2C_HandleTypeDef*           phi2c = &(Ports[PortNum].hi2c);
 800ab0c:	23f0      	movs	r3, #240	; 0xf0
 800ab0e:	005b      	lsls	r3, r3, #1
 800ab10:	4358      	muls	r0, r3
{
 800ab12:	b570      	push	{r4, r5, r6, lr}
  I2C_HandleTypeDef*           phi2c = &(Ports[PortNum].hi2c);
 800ab14:	0004      	movs	r4, r0
 800ab16:	4b0d      	ldr	r3, [pc, #52]	; (800ab4c <HW_IF_STUSB16xx_I2C_Init+0x40>)
 800ab18:	342d      	adds	r4, #45	; 0x2d
 800ab1a:	34ff      	adds	r4, #255	; 0xff
 800ab1c:	18e4      	adds	r4, r4, r3
  
  phi2c->Instance = I2C_INSTANCE(PortNum);
 800ab1e:	1818      	adds	r0, r3, r0
 800ab20:	4b0b      	ldr	r3, [pc, #44]	; (800ab50 <HW_IF_STUSB16xx_I2C_Init+0x44>)
 800ab22:	30fc      	adds	r0, #252	; 0xfc
 800ab24:	6303      	str	r3, [r0, #48]	; 0x30
  phi2c->Init.Timing =  I2C_TIMING(PortNum); 
 800ab26:	4b0b      	ldr	r3, [pc, #44]	; (800ab54 <HW_IF_STUSB16xx_I2C_Init+0x48>)
  phi2c->Init.OwnAddress1 = 0;
 800ab28:	2500      	movs	r5, #0
  phi2c->Init.Timing =  I2C_TIMING(PortNum); 
 800ab2a:	6343      	str	r3, [r0, #52]	; 0x34
  phi2c->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800ab2c:	2301      	movs	r3, #1
  phi2c->Init.OwnAddress1 = 0;
 800ab2e:	6385      	str	r5, [r0, #56]	; 0x38
  phi2c->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800ab30:	63c3      	str	r3, [r0, #60]	; 0x3c
  phi2c->Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 800ab32:	6405      	str	r5, [r0, #64]	; 0x40
  phi2c->Init.OwnAddress2 = 0;
 800ab34:	6445      	str	r5, [r0, #68]	; 0x44
  phi2c->Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 800ab36:	6485      	str	r5, [r0, #72]	; 0x48
  phi2c->Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 800ab38:	64c5      	str	r5, [r0, #76]	; 0x4c
  phi2c->Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 800ab3a:	6505      	str	r5, [r0, #80]	; 0x50

  HAL_I2C_Init(phi2c);
 800ab3c:	0020      	movs	r0, r4
 800ab3e:	f7fd f949 	bl	8007dd4 <HAL_I2C_Init>
  
  HAL_I2CEx_ConfigAnalogFilter(phi2c, I2C_ANALOGFILTER_ENABLE);
 800ab42:	0029      	movs	r1, r5
 800ab44:	0020      	movs	r0, r4
 800ab46:	f7fd fb13 	bl	8008170 <HAL_I2CEx_ConfigAnalogFilter>
}
 800ab4a:	bd70      	pop	{r4, r5, r6, pc}
 800ab4c:	20000058 	.word	0x20000058
 800ab50:	40005800 	.word	0x40005800
 800ab54:	20100917 	.word	0x20100917

0800ab58 <HW_IF_STUSB1602_IO_Init>:
  * @brief  Configuration of STUSB1602 GPIO pins
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_STUSB1602_IO_Init(uint8_t PortNum)
{
 800ab58:	b530      	push	{r4, r5, lr}
  GPIO_InitTypeDef GPIO_InitStruct;

  /* Configure GPIO pin : ALERT */
  GPIO_InitStruct.Pin = ALERT_GPIO_PIN(PortNum);
 800ab5a:	2302      	movs	r3, #2
{
 800ab5c:	b087      	sub	sp, #28
 800ab5e:	1e04      	subs	r4, r0, #0
  GPIO_InitStruct.Pin = ALERT_GPIO_PIN(PortNum);
 800ab60:	d000      	beq.n	800ab64 <HW_IF_STUSB1602_IO_Init+0xc>
 800ab62:	18db      	adds	r3, r3, r3
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(ALERT_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800ab64:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ab66:	2500      	movs	r5, #0
  GPIO_InitStruct.Pin = ALERT_GPIO_PIN(PortNum);
 800ab68:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800ab6a:	4b2a      	ldr	r3, [pc, #168]	; (800ac14 <HW_IF_STUSB1602_IO_Init+0xbc>)
  HAL_GPIO_Init(ALERT_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800ab6c:	a901      	add	r1, sp, #4
 800ab6e:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800ab70:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ab72:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(ALERT_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800ab74:	f7fc ff10 	bl	8007998 <HAL_GPIO_Init>
  
  /* Configure GPIO pin : A_B_SIDE */
  GPIO_InitStruct.Pin = A_B_Side_GPIO_PIN(PortNum);
 800ab78:	2301      	movs	r3, #1
 800ab7a:	42ac      	cmp	r4, r5
 800ab7c:	d000      	beq.n	800ab80 <HW_IF_STUSB1602_IO_Init+0x28>
 800ab7e:	3307      	adds	r3, #7
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(A_B_Side_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800ab80:	2090      	movs	r0, #144	; 0x90
 800ab82:	a901      	add	r1, sp, #4
 800ab84:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = A_B_Side_GPIO_PIN(PortNum);
 800ab86:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800ab88:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ab8a:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(A_B_Side_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800ab8c:	f7fc ff04 	bl	8007998 <HAL_GPIO_Init>

  /* Configure GPIO pin : TX_EN */
  GPIO_InitStruct.Pin = TX_EN_GPIO_PIN(PortNum);
 800ab90:	2304      	movs	r3, #4
 800ab92:	2c00      	cmp	r4, #0
 800ab94:	d000      	beq.n	800ab98 <HW_IF_STUSB1602_IO_Init+0x40>
 800ab96:	18db      	adds	r3, r3, r3
 800ab98:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800ab9a:	2501      	movs	r5, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ab9c:	2300      	movs	r3, #0
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(TX_EN_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800ab9e:	a901      	add	r1, sp, #4
 800aba0:	481d      	ldr	r0, [pc, #116]	; (800ac18 <HW_IF_STUSB1602_IO_Init+0xc0>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800aba2:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800aba4:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800aba6:	9502      	str	r5, [sp, #8]
  HAL_GPIO_Init(TX_EN_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800aba8:	f7fc fef6 	bl	8007998 <HAL_GPIO_Init>
  
  /* Configure GPIO pins : RESET */
  GPIO_InitStruct.Pin = RESET_GPIO_PIN(PortNum);
 800abac:	2340      	movs	r3, #64	; 0x40
 800abae:	2c00      	cmp	r4, #0
 800abb0:	d000      	beq.n	800abb4 <HW_IF_STUSB1602_IO_Init+0x5c>
 800abb2:	18db      	adds	r3, r3, r3
 800abb4:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(RESET_GPIO_PORT(PortNum), &GPIO_InitStruct);

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(ALERT_GPIO_IRQHANDLER(PortNum), ALERT_GPIO_IRQPRIORITY(PortNum), 0);
 800abb6:	1e63      	subs	r3, r4, #1
 800abb8:	419c      	sbcs	r4, r3
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800abba:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800abbc:	2500      	movs	r5, #0
  HAL_GPIO_Init(RESET_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800abbe:	a901      	add	r1, sp, #4
  HAL_NVIC_SetPriority(ALERT_GPIO_IRQHANDLER(PortNum), ALERT_GPIO_IRQPRIORITY(PortNum), 0);
 800abc0:	3405      	adds	r4, #5
  HAL_GPIO_Init(RESET_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800abc2:	4815      	ldr	r0, [pc, #84]	; (800ac18 <HW_IF_STUSB1602_IO_Init+0xc0>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800abc4:	9503      	str	r5, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800abc6:	9504      	str	r5, [sp, #16]
  HAL_GPIO_Init(RESET_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800abc8:	f7fc fee6 	bl	8007998 <HAL_GPIO_Init>
  HAL_NVIC_SetPriority(ALERT_GPIO_IRQHANDLER(PortNum), ALERT_GPIO_IRQPRIORITY(PortNum), 0);
 800abcc:	002a      	movs	r2, r5
 800abce:	2101      	movs	r1, #1
 800abd0:	0020      	movs	r0, r4
 800abd2:	f7fc fd07 	bl	80075e4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(ALERT_GPIO_IRQHANDLER(PortNum));
 800abd6:	0020      	movs	r0, r4
 800abd8:	f7fc fd2e 	bl	8007638 <HAL_NVIC_EnableIRQ>
 
  /* pin for ADC*/
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_4;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800abdc:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800abde:	2403      	movs	r4, #3
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_4;
 800abe0:	2390      	movs	r3, #144	; 0x90
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800abe2:	a901      	add	r1, sp, #4
 800abe4:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_4;
 800abe6:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800abe8:	9402      	str	r4, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800abea:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800abec:	f7fc fed4 	bl	8007998 <HAL_GPIO_Init>
  
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
 800abf0:	2311      	movs	r3, #17
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800abf2:	a901      	add	r1, sp, #4
 800abf4:	4808      	ldr	r0, [pc, #32]	; (800ac18 <HW_IF_STUSB1602_IO_Init+0xc0>)
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
 800abf6:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800abf8:	9402      	str	r4, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800abfa:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800abfc:	f7fc fecc 	bl	8007998 <HAL_GPIO_Init>
  
  GPIO_InitStruct.Pin = GPIO_PIN_0;
 800ac00:	2301      	movs	r3, #1
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800ac02:	a901      	add	r1, sp, #4
 800ac04:	4805      	ldr	r0, [pc, #20]	; (800ac1c <HW_IF_STUSB1602_IO_Init+0xc4>)
  GPIO_InitStruct.Pin = GPIO_PIN_0;
 800ac06:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800ac08:	9402      	str	r4, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ac0a:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800ac0c:	f7fc fec4 	bl	8007998 <HAL_GPIO_Init>
//    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
//    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
//    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
//    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
//  }
}
 800ac10:	b007      	add	sp, #28
 800ac12:	bd30      	pop	{r4, r5, pc}
 800ac14:	10210000 	.word	0x10210000
 800ac18:	48000800 	.word	0x48000800
 800ac1c:	48000400 	.word	0x48000400

0800ac20 <HW_IF_RESET_CTRL>:
  * @brief  STUSB16xx software reset
  * @param  PortNum The port index
  * @retval None
*/ 
void HW_IF_RESET_CTRL(uint8_t PortNum)
{
 800ac20:	b510      	push	{r4, lr}
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), SW_RST);
 800ac22:	1e44      	subs	r4, r0, #1
 800ac24:	41a0      	sbcs	r0, r4
 800ac26:	2101      	movs	r1, #1
 800ac28:	3028      	adds	r0, #40	; 0x28
 800ac2a:	0004      	movs	r4, r0
 800ac2c:	f7fc f86d 	bl	8006d0a <STUSB1602_SW_RESET_Set>
 800ac30:	2164      	movs	r1, #100	; 0x64
 800ac32:	46c0      	nop			; (mov r8, r8)
 800ac34:	3901      	subs	r1, #1
 800ac36:	b289      	uxth	r1, r1
  for(uint16_t i=0; i<100; i++)
 800ac38:	2900      	cmp	r1, #0
 800ac3a:	d1fa      	bne.n	800ac32 <HW_IF_RESET_CTRL+0x12>
  {
    __NOP();
  }  
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), No_SW_RST);
 800ac3c:	0020      	movs	r0, r4
 800ac3e:	f7fc f864 	bl	8006d0a <STUSB1602_SW_RESET_Set>
}
 800ac42:	bd10      	pop	{r4, pc}

0800ac44 <HW_IF_RESET_Assert>:
  * @brief  Assert STUSB16xx hardware reset
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_RESET_Assert(uint8_t PortNum)
{
 800ac44:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(RESET_GPIO_PORT(PortNum), RESET_GPIO_PIN(PortNum), GPIO_PIN_SET);
 800ac46:	2140      	movs	r1, #64	; 0x40
 800ac48:	2800      	cmp	r0, #0
 800ac4a:	d000      	beq.n	800ac4e <HW_IF_RESET_Assert+0xa>
 800ac4c:	1849      	adds	r1, r1, r1
 800ac4e:	2201      	movs	r2, #1
 800ac50:	4801      	ldr	r0, [pc, #4]	; (800ac58 <HW_IF_RESET_Assert+0x14>)
 800ac52:	f7fc ff63 	bl	8007b1c <HAL_GPIO_WritePin>
}
 800ac56:	bd10      	pop	{r4, pc}
 800ac58:	48000800 	.word	0x48000800

0800ac5c <HW_IF_RESET_Deassert>:
  * @brief  Desert STUSB16xx hardware reset
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_RESET_Deassert(uint8_t PortNum)
{
 800ac5c:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(RESET_GPIO_PORT(PortNum), RESET_GPIO_PIN(PortNum), GPIO_PIN_RESET);
 800ac5e:	2140      	movs	r1, #64	; 0x40
 800ac60:	2800      	cmp	r0, #0
 800ac62:	d000      	beq.n	800ac66 <HW_IF_RESET_Deassert+0xa>
 800ac64:	1849      	adds	r1, r1, r1
 800ac66:	2200      	movs	r2, #0
 800ac68:	4801      	ldr	r0, [pc, #4]	; (800ac70 <HW_IF_RESET_Deassert+0x14>)
 800ac6a:	f7fc ff57 	bl	8007b1c <HAL_GPIO_WritePin>
}
 800ac6e:	bd10      	pop	{r4, pc}
 800ac70:	48000800 	.word	0x48000800

0800ac74 <HW_IF_RX_Enable>:
  * @retval None
  */
void HW_IF_RX_Enable(uint8_t PortNum)
{
  /* Set the port state to waiting */
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_WAITING;
 800ac74:	23f0      	movs	r3, #240	; 0xf0
 800ac76:	005b      	lsls	r3, r3, #1
 800ac78:	4343      	muls	r3, r0
 800ac7a:	4805      	ldr	r0, [pc, #20]	; (800ac90 <HW_IF_RX_Enable+0x1c>)
 800ac7c:	18c0      	adds	r0, r0, r3
 800ac7e:	2305      	movs	r3, #5
 800ac80:	7643      	strb	r3, [r0, #25]

  if (Ports[PortNum].cbs.USBPD_HW_IF_ReceiveMessage != NULL)
 800ac82:	30b9      	adds	r0, #185	; 0xb9
 800ac84:	30ff      	adds	r0, #255	; 0xff
 800ac86:	6803      	ldr	r3, [r0, #0]
 800ac88:	2b00      	cmp	r3, #0
 800ac8a:	d000      	beq.n	800ac8e <HW_IF_RX_Enable+0x1a>
 800ac8c:	46c0      	nop			; (mov r8, r8)
  {
    __NOP();
  }
}
 800ac8e:	4770      	bx	lr
 800ac90:	20000058 	.word	0x20000058

0800ac94 <HW_IF_RX_Disable>:
  * @retval None
  */
void HW_IF_RX_Disable(uint8_t PortNum)
{
  /* The port is ready to transmit */
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800ac94:	23f0      	movs	r3, #240	; 0xf0
 800ac96:	005b      	lsls	r3, r3, #1
 800ac98:	4343      	muls	r3, r0
 800ac9a:	4805      	ldr	r0, [pc, #20]	; (800acb0 <HW_IF_RX_Disable+0x1c>)
 800ac9c:	18c0      	adds	r0, r0, r3
 800ac9e:	2301      	movs	r3, #1
 800aca0:	7643      	strb	r3, [r0, #25]
  
  if (Ports[PortNum].cbs.USBPD_HW_IF_ReceiveMessage != NULL)
 800aca2:	30b9      	adds	r0, #185	; 0xb9
 800aca4:	30ff      	adds	r0, #255	; 0xff
 800aca6:	6803      	ldr	r3, [r0, #0]
 800aca8:	2b00      	cmp	r3, #0
 800acaa:	d000      	beq.n	800acae <HW_IF_RX_Disable+0x1a>
 800acac:	46c0      	nop			; (mov r8, r8)
  {
    __NOP();
  }
}
 800acae:	4770      	bx	lr
 800acb0:	20000058 	.word	0x20000058

0800acb4 <HW_IF_Port_SetInitialRole>:
  * @param  PortNum The port index
  * @param  role
  * @retval None
  */ 
void HW_IF_Port_SetInitialRole(uint8_t PortNum,USBPD_PortPowerRole_TypeDef role)
{
 800acb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
  
  if (USBPD_TRUE == _handle->settings->CAD_RoleToggle)
 800acb6:	2318      	movs	r3, #24
 800acb8:	2601      	movs	r6, #1
 800acba:	4343      	muls	r3, r0
 800acbc:	4a98      	ldr	r2, [pc, #608]	; (800af20 <HW_IF_Port_SetInitialRole+0x26c>)
{
 800acbe:	000f      	movs	r7, r1
  if (USBPD_TRUE == _handle->settings->CAD_RoleToggle)
 800acc0:	589b      	ldr	r3, [r3, r2]
 800acc2:	7a9d      	ldrb	r5, [r3, #10]
 800acc4:	4035      	ands	r5, r6
 800acc6:	d04a      	beq.n	800ad5e <HW_IF_Port_SetInitialRole+0xaa>
    /* Dual Role */
    /*0x18*/  
#if defined(CONF_DEMO)
    STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_1_5_A);
#else
    STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 800acc8:	1e44      	subs	r4, r0, #1
 800acca:	41a0      	sbcs	r0, r4
 800accc:	3028      	adds	r0, #40	; 0x28
 800acce:	0004      	movs	r4, r0
 800acd0:	2102      	movs	r1, #2
 800acd2:	f7fb fed5 	bl	8006a80 <STUSB1602_Current_Advertised_Set>
#endif
    STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800acd6:	0031      	movs	r1, r6
 800acd8:	0020      	movs	r0, r4
 800acda:	f7fb ff00 	bl	8006ade <STUSB1602_VCONN_Discharge_Status_Set>
#ifdef _APPLI_VCONN_SUPPORT
    STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Enable_on_CC_pin);    
#else
    STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800acde:	2100      	movs	r1, #0
 800ace0:	0020      	movs	r0, r4
 800ace2:	f7fb ff44 	bl	8006b6e <STUSB1602_VCONN_Supply_Status_Set>
#endif
    STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);    
 800ace6:	2100      	movs	r1, #0
 800ace8:	0020      	movs	r0, r4
 800acea:	f7fb ff10 	bl	8006b0e <STUSB1602_Data_Role_Swap_Status_Set>
    STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);    
 800acee:	2100      	movs	r1, #0
 800acf0:	0020      	movs	r0, r4
 800acf2:	f7fb ff24 	bl	8006b3e <STUSB1602_Power_Role_Swap_Status_Set>

    /*0x1E*/
    STUSB1602_VCONN_Switch_Current_Limit_Set(STUSB1602_I2C_Add(PortNum), ILIM_350_ma);
 800acf6:	2100      	movs	r1, #0
 800acf8:	0020      	movs	r0, r4
 800acfa:	f7fb ff4e 	bl	8006b9a <STUSB1602_VCONN_Switch_Current_Limit_Set>

    /*0x1F*/
    STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), DRP_w_accessory_supp);  
 800acfe:	2103      	movs	r1, #3
 800ad00:	0020      	movs	r0, r4
 800ad02:	f7fc f87c 	bl	8006dfe <STUSB1602_Power_Mode_Set>

    /*0x20*/
    STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800ad06:	2100      	movs	r1, #0
 800ad08:	0020      	movs	r0, r4
 800ad0a:	f7fb ff74 	bl	8006bf6 <STUSB1602_VCONN_Monitor_Status_Set>
    STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800ad0e:	2100      	movs	r1, #0
 800ad10:	0020      	movs	r0, r4
 800ad12:	f7fb ff87 	bl	8006c24 <STUSB1602_VCONN_UVLO_Thresh_Status_Set>

    /*0x21*/
    STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800ad16:	4983      	ldr	r1, [pc, #524]	; (800af24 <HW_IF_Port_SetInitialRole+0x270>)
 800ad18:	0020      	movs	r0, r4
 800ad1a:	f7fb ffa9 	bl	8006c70 <STUSB1602_VBUS_Select_Status_Set>

    /*0x22*/
    STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20); 
 800ad1e:	2114      	movs	r1, #20
 800ad20:	0020      	movs	r0, r4
 800ad22:	f7fb ffbf 	bl	8006ca4 <STUSB1602_VBUS_VShift_High_Set>
    STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800ad26:	2114      	movs	r1, #20
 800ad28:	0020      	movs	r0, r4
 800ad2a:	4249      	negs	r1, r1
 800ad2c:	f7fb ffd2 	bl	8006cd4 <STUSB1602_VBUS_VShift_Low_Set>

    /*0x25*/
    STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800ad30:	2193      	movs	r1, #147	; 0x93
 800ad32:	0020      	movs	r0, r4
 800ad34:	0089      	lsls	r1, r1, #2
 800ad36:	f7fc f814 	bl	8006d62 <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
    STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800ad3a:	21c8      	movs	r1, #200	; 0xc8
 800ad3c:	0020      	movs	r0, r4
 800ad3e:	f7fc f82b 	bl	8006d98 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>

    /*0x2E*/
    STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
 800ad42:	2100      	movs	r1, #0
 800ad44:	0020      	movs	r0, r4
 800ad46:	f7fc f889 	bl	8006e5c <STUSB1602_VDD_OVLO_Threshold_Set>

#if defined(CONF_DEMO)
    STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Disable);
#else
 //   STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
    STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Disable);
 800ad4a:	0031      	movs	r1, r6
 800ad4c:	0020      	movs	r0, r4
 800ad4e:	f7fc f89d 	bl	8006e8c <STUSB1602_VBUS_Range_State_Set>
#endif

    STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V); /* default value is VBUS_vSafe0V_Thr_0_6V, VBUS_vSafe0V_Thr_1_8V */
 800ad52:	2100      	movs	r1, #0

      /*0x2E*/
      STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);

      STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V); /* default value is VBUS_vSafe0V_Thr_0_6V, VBUS_vSafe0V_Thr_1_8V */
 800ad54:	0020      	movs	r0, r4
 800ad56:	f7fc f8b1 	bl	8006ebc <STUSB1602_VBUS_VSAFE0V_Threshold_Set>
      STUSB1602_VDD_UVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_UVLO_Disable);
 800ad5a:	0031      	movs	r1, r6
 800ad5c:	e0db      	b.n	800af16 <HW_IF_Port_SetInitialRole+0x262>
    switch (role)
 800ad5e:	2900      	cmp	r1, #0
 800ad60:	d04d      	beq.n	800adfe <HW_IF_Port_SetInitialRole+0x14a>
 800ad62:	2901      	cmp	r1, #1
 800ad64:	d100      	bne.n	800ad68 <HW_IF_Port_SetInitialRole+0xb4>
 800ad66:	e088      	b.n	800ae7a <HW_IF_Port_SetInitialRole+0x1c6>
      STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 800ad68:	1e44      	subs	r4, r0, #1
 800ad6a:	41a0      	sbcs	r0, r4
 800ad6c:	3028      	adds	r0, #40	; 0x28
 800ad6e:	0004      	movs	r4, r0
 800ad70:	2102      	movs	r1, #2
 800ad72:	f7fb fe85 	bl	8006a80 <STUSB1602_Current_Advertised_Set>
      STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800ad76:	0031      	movs	r1, r6
 800ad78:	0020      	movs	r0, r4
 800ad7a:	f7fb feb0 	bl	8006ade <STUSB1602_VCONN_Discharge_Status_Set>
      STUSB1602_SNK_Disconnect_Mode_Status_Set(STUSB1602_I2C_Add(PortNum), VBUS_or_SRC_removed);
 800ad7e:	0029      	movs	r1, r5
 800ad80:	0020      	movs	r0, r4
 800ad82:	f7fb fe94 	bl	8006aae <STUSB1602_SNK_Disconnect_Mode_Status_Set>
      STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800ad86:	0029      	movs	r1, r5
 800ad88:	0020      	movs	r0, r4
 800ad8a:	f7fb fef0 	bl	8006b6e <STUSB1602_VCONN_Supply_Status_Set>
      STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);
 800ad8e:	0029      	movs	r1, r5
 800ad90:	0020      	movs	r0, r4
 800ad92:	f7fb febc 	bl	8006b0e <STUSB1602_Data_Role_Swap_Status_Set>
      STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);
 800ad96:	0029      	movs	r1, r5
 800ad98:	0020      	movs	r0, r4
 800ad9a:	f7fb fed0 	bl	8006b3e <STUSB1602_Power_Role_Swap_Status_Set>
      STUSB1602_VCONN_Switch_Current_Limit_Set(STUSB1602_I2C_Add(PortNum), ILIM_350_ma);
 800ad9e:	0029      	movs	r1, r5
 800ada0:	0020      	movs	r0, r4
 800ada2:	f7fb fefa 	bl	8006b9a <STUSB1602_VCONN_Switch_Current_Limit_Set>
      STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), DRP_w_accessory_supp);  
 800ada6:	2103      	movs	r1, #3
 800ada8:	0020      	movs	r0, r4
 800adaa:	f7fc f828 	bl	8006dfe <STUSB1602_Power_Mode_Set>
      STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800adae:	0029      	movs	r1, r5
 800adb0:	0020      	movs	r0, r4
 800adb2:	f7fb ff20 	bl	8006bf6 <STUSB1602_VCONN_Monitor_Status_Set>
      STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800adb6:	0029      	movs	r1, r5
 800adb8:	0020      	movs	r0, r4
 800adba:	f7fb ff33 	bl	8006c24 <STUSB1602_VCONN_UVLO_Thresh_Status_Set>
      STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800adbe:	4959      	ldr	r1, [pc, #356]	; (800af24 <HW_IF_Port_SetInitialRole+0x270>)
 800adc0:	0020      	movs	r0, r4
 800adc2:	f7fb ff55 	bl	8006c70 <STUSB1602_VBUS_Select_Status_Set>
      STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20); 
 800adc6:	2114      	movs	r1, #20
 800adc8:	0020      	movs	r0, r4
 800adca:	f7fb ff6b 	bl	8006ca4 <STUSB1602_VBUS_VShift_High_Set>
      STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800adce:	2114      	movs	r1, #20
 800add0:	0020      	movs	r0, r4
 800add2:	4249      	negs	r1, r1
 800add4:	f7fb ff7e 	bl	8006cd4 <STUSB1602_VBUS_VShift_Low_Set>
      STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800add8:	2193      	movs	r1, #147	; 0x93
 800adda:	0020      	movs	r0, r4
 800addc:	0089      	lsls	r1, r1, #2
 800adde:	f7fb ffc0 	bl	8006d62 <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
      STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800ade2:	21c8      	movs	r1, #200	; 0xc8
 800ade4:	0020      	movs	r0, r4
 800ade6:	f7fb ffd7 	bl	8006d98 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>
      STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
 800adea:	0029      	movs	r1, r5
 800adec:	0020      	movs	r0, r4
 800adee:	f7fc f835 	bl	8006e5c <STUSB1602_VDD_OVLO_Threshold_Set>
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
 800adf2:	0029      	movs	r1, r5
 800adf4:	0020      	movs	r0, r4
 800adf6:	f7fc f849 	bl	8006e8c <STUSB1602_VBUS_Range_State_Set>
      STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V); /* default value is VBUS_vSafe0V_Thr_0_6V, VBUS_vSafe0V_Thr_1_8V */
 800adfa:	0029      	movs	r1, r5
 800adfc:	e7aa      	b.n	800ad54 <HW_IF_Port_SetInitialRole+0xa0>
      STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);
 800adfe:	1e44      	subs	r4, r0, #1
 800ae00:	41a0      	sbcs	r0, r4
 800ae02:	3028      	adds	r0, #40	; 0x28
 800ae04:	0004      	movs	r4, r0
 800ae06:	f7fb fe82 	bl	8006b0e <STUSB1602_Data_Role_Swap_Status_Set>
      STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);
 800ae0a:	0039      	movs	r1, r7
 800ae0c:	0020      	movs	r0, r4
 800ae0e:	f7fb fe96 	bl	8006b3e <STUSB1602_Power_Role_Swap_Status_Set>
      STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800ae12:	0031      	movs	r1, r6
 800ae14:	0020      	movs	r0, r4
 800ae16:	f7fb fe62 	bl	8006ade <STUSB1602_VCONN_Discharge_Status_Set>
      STUSB1602_SNK_Disconnect_Mode_Status_Set(STUSB1602_I2C_Add(PortNum), VBUS_or_SRC_removed);
 800ae1a:	0039      	movs	r1, r7
 800ae1c:	0020      	movs	r0, r4
 800ae1e:	f7fb fe46 	bl	8006aae <STUSB1602_SNK_Disconnect_Mode_Status_Set>
      STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800ae22:	0039      	movs	r1, r7
 800ae24:	0020      	movs	r0, r4
 800ae26:	f7fb fea2 	bl	8006b6e <STUSB1602_VCONN_Supply_Status_Set>
      STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), SNK_without_accessory_supp);  
 800ae2a:	2102      	movs	r1, #2
 800ae2c:	0020      	movs	r0, r4
 800ae2e:	f7fb ffe6 	bl	8006dfe <STUSB1602_Power_Mode_Set>
      STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800ae32:	0039      	movs	r1, r7
 800ae34:	0020      	movs	r0, r4
 800ae36:	f7fb fede 	bl	8006bf6 <STUSB1602_VCONN_Monitor_Status_Set>
      STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800ae3a:	0039      	movs	r1, r7
 800ae3c:	0020      	movs	r0, r4
 800ae3e:	f7fb fef1 	bl	8006c24 <STUSB1602_VCONN_UVLO_Thresh_Status_Set>
      STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800ae42:	4938      	ldr	r1, [pc, #224]	; (800af24 <HW_IF_Port_SetInitialRole+0x270>)
 800ae44:	0020      	movs	r0, r4
 800ae46:	f7fb ff13 	bl	8006c70 <STUSB1602_VBUS_Select_Status_Set>
      STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20); 
 800ae4a:	2114      	movs	r1, #20
 800ae4c:	0020      	movs	r0, r4
 800ae4e:	f7fb ff29 	bl	8006ca4 <STUSB1602_VBUS_VShift_High_Set>
      STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800ae52:	2114      	movs	r1, #20
 800ae54:	0020      	movs	r0, r4
 800ae56:	4249      	negs	r1, r1
 800ae58:	f7fb ff3c 	bl	8006cd4 <STUSB1602_VBUS_VShift_Low_Set>
      STUSB1602_Pwr_Acc_Detect_Set(STUSB1602_I2C_Add(PortNum), Pwr_Acc_Detect_Disable); 
 800ae5c:	0039      	movs	r1, r7
 800ae5e:	0020      	movs	r0, r4
 800ae60:	f7fb ff69 	bl	8006d36 <STUSB1602_Pwr_Acc_Detect_Set>
      STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800ae64:	2193      	movs	r1, #147	; 0x93
 800ae66:	0020      	movs	r0, r4
 800ae68:	0089      	lsls	r1, r1, #2
 800ae6a:	f7fb ff7a 	bl	8006d62 <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
      STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800ae6e:	21c8      	movs	r1, #200	; 0xc8
 800ae70:	0020      	movs	r0, r4
 800ae72:	f7fb ff91 	bl	8006d98 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
 800ae76:	0039      	movs	r1, r7
 800ae78:	e768      	b.n	800ad4c <HW_IF_Port_SetInitialRole+0x98>
      STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A); /* USB_C_Current_3_A */
 800ae7a:	1e44      	subs	r4, r0, #1
 800ae7c:	41a0      	sbcs	r0, r4
 800ae7e:	3028      	adds	r0, #40	; 0x28
 800ae80:	0004      	movs	r4, r0
 800ae82:	2102      	movs	r1, #2
 800ae84:	f7fb fdfc 	bl	8006a80 <STUSB1602_Current_Advertised_Set>
      STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800ae88:	0039      	movs	r1, r7
 800ae8a:	0020      	movs	r0, r4
 800ae8c:	f7fb fe27 	bl	8006ade <STUSB1602_VCONN_Discharge_Status_Set>
      STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800ae90:	0029      	movs	r1, r5
 800ae92:	0020      	movs	r0, r4
 800ae94:	f7fb fe6b 	bl	8006b6e <STUSB1602_VCONN_Supply_Status_Set>
      STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);
 800ae98:	0029      	movs	r1, r5
 800ae9a:	0020      	movs	r0, r4
 800ae9c:	f7fb fe37 	bl	8006b0e <STUSB1602_Data_Role_Swap_Status_Set>
      STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);
 800aea0:	0029      	movs	r1, r5
 800aea2:	0020      	movs	r0, r4
 800aea4:	f7fb fe4b 	bl	8006b3e <STUSB1602_Power_Role_Swap_Status_Set>
      STUSB1602_VCONN_Switch_Current_Limit_Set(STUSB1602_I2C_Add(PortNum), ILIM_350_ma);
 800aea8:	0029      	movs	r1, r5
 800aeaa:	0020      	movs	r0, r4
 800aeac:	f7fb fe75 	bl	8006b9a <STUSB1602_VCONN_Switch_Current_Limit_Set>
      STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), SRC_with_accessory_supp);  
 800aeb0:	0029      	movs	r1, r5
 800aeb2:	0020      	movs	r0, r4
 800aeb4:	f7fb ffa3 	bl	8006dfe <STUSB1602_Power_Mode_Set>
      STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800aeb8:	0029      	movs	r1, r5
 800aeba:	0020      	movs	r0, r4
 800aebc:	f7fb fe9b 	bl	8006bf6 <STUSB1602_VCONN_Monitor_Status_Set>
      STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800aec0:	0029      	movs	r1, r5
 800aec2:	0020      	movs	r0, r4
 800aec4:	f7fb feae 	bl	8006c24 <STUSB1602_VCONN_UVLO_Thresh_Status_Set>
      STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800aec8:	4916      	ldr	r1, [pc, #88]	; (800af24 <HW_IF_Port_SetInitialRole+0x270>)
 800aeca:	0020      	movs	r0, r4
 800aecc:	f7fb fed0 	bl	8006c70 <STUSB1602_VBUS_Select_Status_Set>
      STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20);
 800aed0:	2114      	movs	r1, #20
 800aed2:	0020      	movs	r0, r4
 800aed4:	f7fb fee6 	bl	8006ca4 <STUSB1602_VBUS_VShift_High_Set>
      STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800aed8:	2114      	movs	r1, #20
 800aeda:	0020      	movs	r0, r4
 800aedc:	4249      	negs	r1, r1
 800aede:	f7fb fef9 	bl	8006cd4 <STUSB1602_VBUS_VShift_Low_Set>
      STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800aee2:	2193      	movs	r1, #147	; 0x93
 800aee4:	0020      	movs	r0, r4
 800aee6:	0089      	lsls	r1, r1, #2
 800aee8:	f7fb ff3b 	bl	8006d62 <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
      STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800aeec:	21c8      	movs	r1, #200	; 0xc8
 800aeee:	0020      	movs	r0, r4
 800aef0:	f7fb ff52 	bl	8006d98 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>
      STUSB1602_VBUS_Discharge_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Discharge_Path_Enable); 
 800aef4:	0039      	movs	r1, r7
 800aef6:	0020      	movs	r0, r4
 800aef8:	f7fb ff6a 	bl	8006dd0 <STUSB1602_VBUS_Discharge_State_Set>
      STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
 800aefc:	0029      	movs	r1, r5
 800aefe:	0020      	movs	r0, r4
 800af00:	f7fb ffac 	bl	8006e5c <STUSB1602_VDD_OVLO_Threshold_Set>
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
 800af04:	0029      	movs	r1, r5
 800af06:	0020      	movs	r0, r4
 800af08:	f7fb ffc0 	bl	8006e8c <STUSB1602_VBUS_Range_State_Set>
      STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V);
 800af0c:	0029      	movs	r1, r5
 800af0e:	0020      	movs	r0, r4
 800af10:	f7fb ffd4 	bl	8006ebc <STUSB1602_VBUS_VSAFE0V_Threshold_Set>
      STUSB1602_VDD_UVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_UVLO_Disable);
 800af14:	0039      	movs	r1, r7
      STUSB1602_VDD_UVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_UVLO_Disable);
 800af16:	0020      	movs	r0, r4
 800af18:	f7fb ffe9 	bl	8006eee <STUSB1602_VDD_UVLO_Threshold_Set>
    break;
    }
  }
}
 800af1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800af1e:	46c0      	nop			; (mov r8, r8)
 800af20:	20001c68 	.word	0x20001c68
 800af24:	00001388 	.word	0x00001388

0800af28 <HW_IF_check_bus_idle>:
  * @param  PortNum The port index
  * @retval USBPD_StatusTypeDef
  */
USBPD_StatusTypeDef HW_IF_check_bus_idle(uint8_t PortNum)
{
  return (((Ports[PortNum].CCx == CCNONE) || ((HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET))) ? USBPD_BUSY : USBPD_OK);
 800af28:	22f0      	movs	r2, #240	; 0xf0
 800af2a:	0052      	lsls	r2, r2, #1
 800af2c:	4342      	muls	r2, r0
 800af2e:	4b0c      	ldr	r3, [pc, #48]	; (800af60 <HW_IF_check_bus_idle+0x38>)
{
 800af30:	b510      	push	{r4, lr}
  return (((Ports[PortNum].CCx == CCNONE) || ((HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET))) ? USBPD_BUSY : USBPD_OK);
 800af32:	189b      	adds	r3, r3, r2
 800af34:	7d9b      	ldrb	r3, [r3, #22]
 800af36:	2b00      	cmp	r3, #0
 800af38:	d00a      	beq.n	800af50 <HW_IF_check_bus_idle+0x28>
 800af3a:	2800      	cmp	r0, #0
 800af3c:	d00b      	beq.n	800af56 <HW_IF_check_bus_idle+0x2e>
 800af3e:	2090      	movs	r0, #144	; 0x90
 800af40:	2180      	movs	r1, #128	; 0x80
 800af42:	05c0      	lsls	r0, r0, #23
 800af44:	0209      	lsls	r1, r1, #8
 800af46:	f7fc fde3 	bl	8007b10 <HAL_GPIO_ReadPin>
 800af4a:	2300      	movs	r3, #0
 800af4c:	4298      	cmp	r0, r3
 800af4e:	d100      	bne.n	800af52 <HW_IF_check_bus_idle+0x2a>
 800af50:	2303      	movs	r3, #3
}
 800af52:	0018      	movs	r0, r3
 800af54:	bd10      	pop	{r4, pc}
  return (((Ports[PortNum].CCx == CCNONE) || ((HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET))) ? USBPD_BUSY : USBPD_OK);
 800af56:	2180      	movs	r1, #128	; 0x80
 800af58:	4802      	ldr	r0, [pc, #8]	; (800af64 <HW_IF_check_bus_idle+0x3c>)
 800af5a:	0149      	lsls	r1, r1, #5
 800af5c:	e7f3      	b.n	800af46 <HW_IF_check_bus_idle+0x1e>
 800af5e:	46c0      	nop			; (mov r8, r8)
 800af60:	20000058 	.word	0x20000058
 800af64:	48000400 	.word	0x48000400

0800af68 <HW_IF_NSS_RisingFalling_Interrupt>:
  * @param  PortNum The port index
  * @param  status Two allowed values: ENABLE or DISABLE
  * @retval None
  */ 
void HW_IF_NSS_RisingFalling_Interrupt (uint8_t PortNum ,FunctionalState status)
{
 800af68:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800af6a:	0004      	movs	r4, r0
 800af6c:	000d      	movs	r5, r1
  LL_EXTI_InitTypeDef EXTI_InitStruct;

  if (status == ENABLE)
 800af6e:	2901      	cmp	r1, #1
 800af70:	d12a      	bne.n	800afc8 <HW_IF_NSS_RisingFalling_Interrupt+0x60>
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800af72:	2380      	movs	r3, #128	; 0x80
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800af74:	20c1      	movs	r0, #193	; 0xc1
 800af76:	2180      	movs	r1, #128	; 0x80
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800af78:	4a20      	ldr	r2, [pc, #128]	; (800affc <HW_IF_NSS_RisingFalling_Interrupt+0x94>)
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800af7a:	0080      	lsls	r0, r0, #2
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800af7c:	6013      	str	r3, [r2, #0]
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800af7e:	5813      	ldr	r3, [r2, r0]
 800af80:	0609      	lsls	r1, r1, #24
 800af82:	021b      	lsls	r3, r3, #8
 800af84:	0a1b      	lsrs	r3, r3, #8
 800af86:	430b      	orrs	r3, r1
 800af88:	5013      	str	r3, [r2, r0]
    /* NVIC configuration*/
    NVIC_EnableIRQ(SPI_NSS_LL_IRQHANDLER(PortNum));
    NVIC_SetPriority(SPI_NSS_LL_IRQHANDLER(PortNum),SPI_NSS_LL_IRQPRIORITY(PortNum));

    /* External Line initialization */
    LL_APB1_GRP2_EnableClock(SPI_NSS_LL_APB(PortNum));
 800af8a:	f7ff fc8b 	bl	800a8a4 <LL_APB1_GRP2_EnableClock.constprop.7>
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800af8e:	2c00      	cmp	r4, #0
 800af90:	d117      	bne.n	800afc2 <HW_IF_NSS_RisingFalling_Interrupt+0x5a>
 800af92:	0028      	movs	r0, r5
 800af94:	2103      	movs	r1, #3

    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800af96:	4263      	negs	r3, r4
 800af98:	415c      	adcs	r4, r3
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800af9a:	f7ff fc45 	bl	800a828 <LL_SYSCFG_SetEXTISource>
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800af9e:	4b18      	ldr	r3, [pc, #96]	; (800b000 <HW_IF_NSS_RisingFalling_Interrupt+0x98>)
 800afa0:	4264      	negs	r4, r4
 800afa2:	401c      	ands	r4, r3
 800afa4:	2380      	movs	r3, #128	; 0x80
 800afa6:	021b      	lsls	r3, r3, #8
 800afa8:	18e4      	adds	r4, r4, r3
    EXTI_InitStruct.LineCommand = ENABLE;
 800afaa:	466a      	mov	r2, sp
 800afac:	2301      	movs	r3, #1
 800afae:	7113      	strb	r3, [r2, #4]
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 800afb0:	2300      	movs	r3, #0
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800afb2:	9400      	str	r4, [sp, #0]
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 800afb4:	7153      	strb	r3, [r2, #5]
    EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_RISING_FALLING;
 800afb6:	3303      	adds	r3, #3
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));

    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
    EXTI_InitStruct.LineCommand = DISABLE;
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
    EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_NONE;
 800afb8:	7193      	strb	r3, [r2, #6]
    LL_EXTI_Init(&EXTI_InitStruct);
 800afba:	4668      	mov	r0, sp
 800afbc:	f7fe fa8c 	bl	80094d8 <LL_EXTI_Init>
  }  
}
 800afc0:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800afc2:	2000      	movs	r0, #0
 800afc4:	490f      	ldr	r1, [pc, #60]	; (800b004 <HW_IF_NSS_RisingFalling_Interrupt+0x9c>)
 800afc6:	e7e6      	b.n	800af96 <HW_IF_NSS_RisingFalling_Interrupt+0x2e>
  *         (*) value not defined in all devices.
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP2_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB2ENR, Periphs);
 800afc8:	2001      	movs	r0, #1
 800afca:	4a0f      	ldr	r2, [pc, #60]	; (800b008 <HW_IF_NSS_RisingFalling_Interrupt+0xa0>)
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800afcc:	2103      	movs	r1, #3
 800afce:	6993      	ldr	r3, [r2, #24]
 800afd0:	4383      	bics	r3, r0
 800afd2:	6193      	str	r3, [r2, #24]
 800afd4:	2c00      	cmp	r4, #0
 800afd6:	d001      	beq.n	800afdc <HW_IF_NSS_RisingFalling_Interrupt+0x74>
 800afd8:	2000      	movs	r0, #0
 800afda:	490a      	ldr	r1, [pc, #40]	; (800b004 <HW_IF_NSS_RisingFalling_Interrupt+0x9c>)
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800afdc:	4263      	negs	r3, r4
 800afde:	415c      	adcs	r4, r3
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800afe0:	f7ff fc22 	bl	800a828 <LL_SYSCFG_SetEXTISource>
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800afe4:	4b06      	ldr	r3, [pc, #24]	; (800b000 <HW_IF_NSS_RisingFalling_Interrupt+0x98>)
 800afe6:	4264      	negs	r4, r4
 800afe8:	401c      	ands	r4, r3
 800afea:	2380      	movs	r3, #128	; 0x80
 800afec:	021b      	lsls	r3, r3, #8
 800afee:	18e4      	adds	r4, r4, r3
    EXTI_InitStruct.LineCommand = DISABLE;
 800aff0:	466a      	mov	r2, sp
 800aff2:	2300      	movs	r3, #0
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800aff4:	9400      	str	r4, [sp, #0]
    EXTI_InitStruct.LineCommand = DISABLE;
 800aff6:	7113      	strb	r3, [r2, #4]
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 800aff8:	7153      	strb	r3, [r2, #5]
 800affa:	e7dd      	b.n	800afb8 <HW_IF_NSS_RisingFalling_Interrupt+0x50>
 800affc:	e000e100 	.word	0xe000e100
 800b000:	ffff9000 	.word	0xffff9000
 800b004:	000c0003 	.word	0x000c0003
 800b008:	40021000 	.word	0x40021000

0800b00c <HW_IF_COUNTER_TIM_Init>:
  * @brief  Initialization of counter
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_COUNTER_TIM_Init(uint8_t PortNum)
{
 800b00c:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Get the peripheral handler variable */
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800b00e:	25f0      	movs	r5, #240	; 0xf0
 800b010:	006d      	lsls	r5, r5, #1
 800b012:	4345      	muls	r5, r0
 800b014:	4b25      	ldr	r3, [pc, #148]	; (800b0ac <HW_IF_COUNTER_TIM_Init+0xa0>)
  
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig;
  TIM_OC_InitTypeDef sConfigOC;
  
  htimcountrx->Instance =                       RX_COUNTTIM(PortNum);
 800b016:	4242      	negs	r2, r0
 800b018:	4150      	adcs	r0, r2
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800b01a:	002e      	movs	r6, r5
  htimcountrx->Instance =                       RX_COUNTTIM(PortNum);
 800b01c:	195d      	adds	r5, r3, r5
 800b01e:	002f      	movs	r7, r5
 800b020:	4a23      	ldr	r2, [pc, #140]	; (800b0b0 <HW_IF_COUNTER_TIM_Init+0xa4>)
 800b022:	4240      	negs	r0, r0
 800b024:	0280      	lsls	r0, r0, #10
 800b026:	1880      	adds	r0, r0, r2
 800b028:	37fc      	adds	r7, #252	; 0xfc
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800b02a:	3679      	adds	r6, #121	; 0x79
{
 800b02c:	b08f      	sub	sp, #60	; 0x3c
  htimcountrx->Instance =                       RX_COUNTTIM(PortNum);
 800b02e:	67f8      	str	r0, [r7, #124]	; 0x7c
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800b030:	36ff      	adds	r6, #255	; 0xff
 800b032:	18f6      	adds	r6, r6, r3
  htimcountrx->Init.Prescaler =                 ( HAL_RCC_GetHCLKFreq() / 1000000 ) - 1; // 1us Resolution
 800b034:	002c      	movs	r4, r5
 800b036:	f7fd f903 	bl	8008240 <HAL_RCC_GetHCLKFreq>
 800b03a:	491e      	ldr	r1, [pc, #120]	; (800b0b4 <HW_IF_COUNTER_TIM_Init+0xa8>)
 800b03c:	f7fa fcc4 	bl	80059c8 <__udivsi3>
 800b040:	347d      	adds	r4, #125	; 0x7d
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800b042:	002b      	movs	r3, r5
  htimcountrx->Init.Prescaler =                 ( HAL_RCC_GetHCLKFreq() / 1000000 ) - 1; // 1us Resolution
 800b044:	34ff      	adds	r4, #255	; 0xff
 800b046:	3801      	subs	r0, #1
  htimcountrx->Init.Period =                    DMA_TIME_ELAPSED;
 800b048:	223c      	movs	r2, #60	; 0x3c
  htimcountrx->Init.Prescaler =                 ( HAL_RCC_GetHCLKFreq() / 1000000 ) - 1; // 1us Resolution
 800b04a:	6020      	str	r0, [r4, #0]
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800b04c:	2400      	movs	r4, #0
 800b04e:	3381      	adds	r3, #129	; 0x81
  htimcountrx->Init.ClockDivision =             TIM_CLOCKDIVISION_DIV1;
  htimcountrx->Init.RepetitionCounter =         0;
 800b050:	358d      	adds	r5, #141	; 0x8d
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800b052:	33ff      	adds	r3, #255	; 0xff
  htimcountrx->Init.RepetitionCounter =         0;
 800b054:	35ff      	adds	r5, #255	; 0xff
  htimcountrx->Init.Period =                    DMA_TIME_ELAPSED;
 800b056:	605a      	str	r2, [r3, #4]
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800b058:	601c      	str	r4, [r3, #0]
  htimcountrx->Init.ClockDivision =             TIM_CLOCKDIVISION_DIV1;
 800b05a:	609c      	str	r4, [r3, #8]
  htimcountrx->Init.RepetitionCounter =         0;
 800b05c:	602c      	str	r4, [r5, #0]
  HAL_TIM_Base_Init(htimcountrx);
 800b05e:	0030      	movs	r0, r6
 800b060:	f7fd fee8 	bl	8008e34 <HAL_TIM_Base_Init>
  
  HAL_TIM_OC_Init(htimcountrx);
 800b064:	0030      	movs	r0, r6
 800b066:	f7fd ff00 	bl	8008e6a <HAL_TIM_OC_Init>
  sBreakDeadTimeConfig.OffStateRunMode =        TIM_OSSR_DISABLE;
  sBreakDeadTimeConfig.OffStateIDLEMode =       TIM_OSSI_DISABLE;
  sBreakDeadTimeConfig.LockLevel =              TIM_LOCKLEVEL_OFF;
  sBreakDeadTimeConfig.DeadTime =               0;
  sBreakDeadTimeConfig.BreakState =             TIM_BREAK_DISABLE;
  sBreakDeadTimeConfig.BreakPolarity =          TIM_BREAKPOLARITY_HIGH;
 800b06a:	2380      	movs	r3, #128	; 0x80
  sBreakDeadTimeConfig.AutomaticOutput =        TIM_AUTOMATICOUTPUT_DISABLE;
  HAL_TIMEx_ConfigBreakDeadTime(htimcountrx, &sBreakDeadTimeConfig);
 800b06c:	4669      	mov	r1, sp
  sBreakDeadTimeConfig.BreakPolarity =          TIM_BREAKPOLARITY_HIGH;
 800b06e:	019b      	lsls	r3, r3, #6
  HAL_TIMEx_ConfigBreakDeadTime(htimcountrx, &sBreakDeadTimeConfig);
 800b070:	0030      	movs	r0, r6
  sBreakDeadTimeConfig.BreakPolarity =          TIM_BREAKPOLARITY_HIGH;
 800b072:	9305      	str	r3, [sp, #20]
  sBreakDeadTimeConfig.OffStateRunMode =        TIM_OSSR_DISABLE;
 800b074:	9400      	str	r4, [sp, #0]
  sBreakDeadTimeConfig.OffStateIDLEMode =       TIM_OSSI_DISABLE;
 800b076:	9401      	str	r4, [sp, #4]
  sBreakDeadTimeConfig.LockLevel =              TIM_LOCKLEVEL_OFF;
 800b078:	9402      	str	r4, [sp, #8]
  sBreakDeadTimeConfig.DeadTime =               0;
 800b07a:	9403      	str	r4, [sp, #12]
  sBreakDeadTimeConfig.BreakState =             TIM_BREAK_DISABLE;
 800b07c:	9404      	str	r4, [sp, #16]
  sBreakDeadTimeConfig.AutomaticOutput =        TIM_AUTOMATICOUTPUT_DISABLE;
 800b07e:	9406      	str	r4, [sp, #24]
  HAL_TIMEx_ConfigBreakDeadTime(htimcountrx, &sBreakDeadTimeConfig);
 800b080:	f7fe f81c 	bl	80090bc <HAL_TIMEx_ConfigBreakDeadTime>
  
  sConfigOC.OCMode =                            TIM_OCMODE_TIMING;
  sConfigOC.Pulse =                             DMA_TIME_COUNT_COMPARE;
 800b084:	230a      	movs	r3, #10
  sConfigOC.OCPolarity =                        TIM_OCPOLARITY_HIGH;
  sConfigOC.OCNPolarity =                       TIM_OCNPOLARITY_HIGH;
  sConfigOC.OCFastMode =                        TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState =                       TIM_OCIDLESTATE_RESET;
  sConfigOC.OCNIdleState =                      TIM_OCNIDLESTATE_RESET;
  HAL_TIM_OC_ConfigChannel(htimcountrx, &sConfigOC, RX_COUNTTIMCH(PortNum));
 800b086:	0022      	movs	r2, r4
 800b088:	a907      	add	r1, sp, #28
 800b08a:	0030      	movs	r0, r6
  sConfigOC.Pulse =                             DMA_TIME_COUNT_COMPARE;
 800b08c:	9308      	str	r3, [sp, #32]
  sConfigOC.OCMode =                            TIM_OCMODE_TIMING;
 800b08e:	9407      	str	r4, [sp, #28]
  sConfigOC.OCPolarity =                        TIM_OCPOLARITY_HIGH;
 800b090:	9409      	str	r4, [sp, #36]	; 0x24
  sConfigOC.OCNPolarity =                       TIM_OCNPOLARITY_HIGH;
 800b092:	940a      	str	r4, [sp, #40]	; 0x28
  sConfigOC.OCFastMode =                        TIM_OCFAST_DISABLE;
 800b094:	940b      	str	r4, [sp, #44]	; 0x2c
  sConfigOC.OCIdleState =                       TIM_OCIDLESTATE_RESET;
 800b096:	940c      	str	r4, [sp, #48]	; 0x30
  sConfigOC.OCNIdleState =                      TIM_OCNIDLESTATE_RESET;
 800b098:	940d      	str	r4, [sp, #52]	; 0x34
  HAL_TIM_OC_ConfigChannel(htimcountrx, &sConfigOC, RX_COUNTTIMCH(PortNum));
 800b09a:	f7fd ff41 	bl	8008f20 <HAL_TIM_OC_ConfigChannel>
  
  __HAL_TIM_CLEAR_IT(htimcountrx, TIM_IT_UPDATE);
 800b09e:	2202      	movs	r2, #2
 800b0a0:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800b0a2:	4252      	negs	r2, r2
 800b0a4:	611a      	str	r2, [r3, #16]
}
 800b0a6:	b00f      	add	sp, #60	; 0x3c
 800b0a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b0aa:	46c0      	nop			; (mov r8, r8)
 800b0ac:	20000058 	.word	0x20000058
 800b0b0:	40014800 	.word	0x40014800
 800b0b4:	000f4240 	.word	0x000f4240

0800b0b8 <STUSB16xx_HW_IF_TX_DMA_Init>:
  * @brief  Initialization of DMA for transmission
  * @param  PortNum The port index
  * @retval None
  */ 
void STUSB16xx_HW_IF_TX_DMA_Init(uint8_t PortNum)
{
 800b0b8:	23f0      	movs	r3, #240	; 0xf0
 800b0ba:	005b      	lsls	r3, r3, #1
 800b0bc:	4343      	muls	r3, r0
 800b0be:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800b0c0:	001e      	movs	r6, r3
 800b0c2:	9301      	str	r3, [sp, #4]
  
  /* Set the DMA handler of the peripheral handler */
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800b0c4:	9a01      	ldr	r2, [sp, #4]
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800b0c6:	4b18      	ldr	r3, [pc, #96]	; (800b128 <STUSB16xx_HW_IF_TX_DMA_Init+0x70>)
 800b0c8:	36a4      	adds	r6, #164	; 0xa4
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800b0ca:	189c      	adds	r4, r3, r2
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800b0cc:	18f6      	adds	r6, r6, r3
  
  /* Peripheral DMA init*/
  hdma_tx_spi->Instance =                   TX_DMACH(PortNum);
 800b0ce:	0003      	movs	r3, r0
 800b0d0:	1e5a      	subs	r2, r3, #1
 800b0d2:	4193      	sbcs	r3, r2
 800b0d4:	2227      	movs	r2, #39	; 0x27
 800b0d6:	425b      	negs	r3, r3
 800b0d8:	4393      	bics	r3, r2
 800b0da:	4a14      	ldr	r2, [pc, #80]	; (800b12c <STUSB16xx_HW_IF_TX_DMA_Init+0x74>)
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800b0dc:	0027      	movs	r7, r4
  hdma_tx_spi->Instance =                   TX_DMACH(PortNum);
 800b0de:	189b      	adds	r3, r3, r2
 800b0e0:	0022      	movs	r2, r4
 800b0e2:	32a4      	adds	r2, #164	; 0xa4
 800b0e4:	6013      	str	r3, [r2, #0]
  hdma_tx_spi->Init.Direction =             DMA_MEMORY_TO_PERIPH;
 800b0e6:	0023      	movs	r3, r4
 800b0e8:	2210      	movs	r2, #16
 800b0ea:	33a8      	adds	r3, #168	; 0xa8
 800b0ec:	601a      	str	r2, [r3, #0]
  hdma_tx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800b0ee:	0022      	movs	r2, r4
 800b0f0:	2300      	movs	r3, #0
  hdma_tx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800b0f2:	2180      	movs	r1, #128	; 0x80
{
 800b0f4:	0005      	movs	r5, r0
  hdma_tx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800b0f6:	32ac      	adds	r2, #172	; 0xac
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800b0f8:	3794      	adds	r7, #148	; 0x94
 800b0fa:	603e      	str	r6, [r7, #0]
  hdma_tx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800b0fc:	6051      	str	r1, [r2, #4]
  hdma_tx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800b0fe:	6013      	str	r3, [r2, #0]
  hdma_tx_spi->Init.PeriphDataAlignment =   DMA_PDATAALIGN_BYTE;
 800b100:	6093      	str	r3, [r2, #8]
  hdma_tx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800b102:	60d3      	str	r3, [r2, #12]
  hdma_tx_spi->Init.Mode =                  DMA_NORMAL;
 800b104:	6113      	str	r3, [r2, #16]
  hdma_tx_spi->Init.Priority =              DMACHIRQ_PRIO(PortNum);
 800b106:	6153      	str	r3, [r2, #20]
  HAL_DMA_Init(hdma_tx_spi);
 800b108:	0030      	movs	r0, r6
 800b10a:	f7fc fb97 	bl	800783c <HAL_DMA_Init>
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
  
  /* Enable IRQ DMA */
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800b10e:	4268      	negs	r0, r5
 800b110:	4168      	adcs	r0, r5
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800b112:	9b01      	ldr	r3, [sp, #4]
 800b114:	4a04      	ldr	r2, [pc, #16]	; (800b128 <STUSB16xx_HW_IF_TX_DMA_Init+0x70>)
 800b116:	3340      	adds	r3, #64	; 0x40
 800b118:	18d3      	adds	r3, r2, r3
 800b11a:	34c8      	adds	r4, #200	; 0xc8
 800b11c:	603e      	str	r6, [r7, #0]
 800b11e:	6023      	str	r3, [r4, #0]
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800b120:	300a      	adds	r0, #10
 800b122:	f7fc fa89 	bl	8007638 <HAL_NVIC_EnableIRQ>
}
 800b126:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800b128:	20000058 	.word	0x20000058
 800b12c:	40020058 	.word	0x40020058

0800b130 <STUSB16xx_HW_IF_RX_DMA_Init>:
  * @brief  Initialization DMA for reception
  * @param  PortNum The port index
  * @retval None
  */ 
void STUSB16xx_HW_IF_RX_DMA_Init(uint8_t PortNum)
{
 800b130:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800b132:	26f0      	movs	r6, #240	; 0xf0
 800b134:	0076      	lsls	r6, r6, #1
 800b136:	4346      	muls	r6, r0
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_rx_spi = &(Ports[PortNum].hdmarx);
 800b138:	0033      	movs	r3, r6
 800b13a:	4a17      	ldr	r2, [pc, #92]	; (800b198 <STUSB16xx_HW_IF_RX_DMA_Init+0x68>)
 800b13c:	33e8      	adds	r3, #232	; 0xe8
 800b13e:	189b      	adds	r3, r3, r2
 800b140:	9301      	str	r3, [sp, #4]
 
  /* Peripheral DMA init*/
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800b142:	0003      	movs	r3, r0
 800b144:	1e5a      	subs	r2, r3, #1
 800b146:	4193      	sbcs	r3, r2
 800b148:	2227      	movs	r2, #39	; 0x27
 800b14a:	425b      	negs	r3, r3
 800b14c:	4393      	bics	r3, r2
 800b14e:	4a13      	ldr	r2, [pc, #76]	; (800b19c <STUSB16xx_HW_IF_RX_DMA_Init+0x6c>)
  hdma_rx_spi->Init.Direction =             DMA_PERIPH_TO_MEMORY;
  hdma_rx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
  hdma_rx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800b150:	2180      	movs	r1, #128	; 0x80
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800b152:	189b      	adds	r3, r3, r2
 800b154:	4a10      	ldr	r2, [pc, #64]	; (800b198 <STUSB16xx_HW_IF_RX_DMA_Init+0x68>)
{
 800b156:	0005      	movs	r5, r0
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800b158:	1994      	adds	r4, r2, r6
 800b15a:	0022      	movs	r2, r4
  hdma_rx_spi->Init.PeriphDataAlignment =   DMA_PDATAALIGN_BYTE;
  hdma_rx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800b15c:	0027      	movs	r7, r4
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800b15e:	32e8      	adds	r2, #232	; 0xe8
 800b160:	6013      	str	r3, [r2, #0]
  hdma_rx_spi->Init.Direction =             DMA_PERIPH_TO_MEMORY;
 800b162:	2300      	movs	r3, #0
  hdma_rx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800b164:	37fc      	adds	r7, #252	; 0xfc
  hdma_rx_spi->Init.Direction =             DMA_PERIPH_TO_MEMORY;
 800b166:	6053      	str	r3, [r2, #4]
  hdma_rx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800b168:	6093      	str	r3, [r2, #8]
  hdma_rx_spi->Init.PeriphDataAlignment =   DMA_PDATAALIGN_BYTE;
 800b16a:	6113      	str	r3, [r2, #16]
  hdma_rx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800b16c:	603b      	str	r3, [r7, #0]
  hdma_rx_spi->Init.Mode =                  DMA_NORMAL;
 800b16e:	607b      	str	r3, [r7, #4]
  hdma_rx_spi->Init.Priority =              DMA_PRIORITY_VERY_HIGH;
 800b170:	23c0      	movs	r3, #192	; 0xc0
 800b172:	019b      	lsls	r3, r3, #6
 800b174:	60bb      	str	r3, [r7, #8]
  hdma_rx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800b176:	60d1      	str	r1, [r2, #12]
  HAL_DMA_Init(hdma_rx_spi);
 800b178:	9801      	ldr	r0, [sp, #4]
 800b17a:	f7fc fb5f 	bl	800783c <HAL_DMA_Init>
  Ports[PortNum].hspi.hdmarx = hdma_rx_spi; 
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmarx,(*hdma_rx_spi));

  /* Enable IRQ DMA */
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800b17e:	4268      	negs	r0, r5
 800b180:	4168      	adcs	r0, r5
  Ports[PortNum].hspi.hdmarx = hdma_rx_spi; 
 800b182:	9b01      	ldr	r3, [sp, #4]
 800b184:	3498      	adds	r4, #152	; 0x98
 800b186:	6023      	str	r3, [r4, #0]
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmarx,(*hdma_rx_spi));
 800b188:	4b03      	ldr	r3, [pc, #12]	; (800b198 <STUSB16xx_HW_IF_RX_DMA_Init+0x68>)
 800b18a:	3640      	adds	r6, #64	; 0x40
 800b18c:	199e      	adds	r6, r3, r6
 800b18e:	613e      	str	r6, [r7, #16]
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800b190:	300a      	adds	r0, #10
 800b192:	f7fc fa51 	bl	8007638 <HAL_NVIC_EnableIRQ>
  
}
 800b196:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800b198:	20000058 	.word	0x20000058
 800b19c:	40020044 	.word	0x40020044

0800b1a0 <STUSB16xx_HW_IF_Set_DMA_Normal_Mode>:
  * @brief  It switches SPI DMA in normal mode
  * @param  PortNum The port index
  * @retval None
  */
void STUSB16xx_HW_IF_Set_DMA_Normal_Mode(uint8_t PortNum)
{
 800b1a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b1a2:	24f0      	movs	r4, #240	; 0xf0
 800b1a4:	0064      	lsls	r4, r4, #1
 800b1a6:	4344      	muls	r4, r0
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800b1a8:	4e09      	ldr	r6, [pc, #36]	; (800b1d0 <STUSB16xx_HW_IF_Set_DMA_Normal_Mode+0x30>)
 800b1aa:	0027      	movs	r7, r4
  
  hdma_tx_spi->Init.Mode =                  DMA_NORMAL;
 800b1ac:	1935      	adds	r5, r6, r4
 800b1ae:	002b      	movs	r3, r5
 800b1b0:	2200      	movs	r2, #0
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800b1b2:	37a4      	adds	r7, #164	; 0xa4
 800b1b4:	19bf      	adds	r7, r7, r6
  hdma_tx_spi->Init.Mode =                  DMA_NORMAL;
 800b1b6:	33bc      	adds	r3, #188	; 0xbc
 800b1b8:	601a      	str	r2, [r3, #0]
  HAL_DMA_Init(hdma_tx_spi);
 800b1ba:	0038      	movs	r0, r7
 800b1bc:	f7fc fb3e 	bl	800783c <HAL_DMA_Init>
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800b1c0:	002b      	movs	r3, r5
 800b1c2:	3440      	adds	r4, #64	; 0x40
 800b1c4:	35c8      	adds	r5, #200	; 0xc8
 800b1c6:	19a4      	adds	r4, r4, r6
 800b1c8:	3394      	adds	r3, #148	; 0x94
 800b1ca:	601f      	str	r7, [r3, #0]
 800b1cc:	602c      	str	r4, [r5, #0]
}
 800b1ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b1d0:	20000058 	.word	0x20000058

0800b1d4 <STUSB16xx_HW_IF_Set_DMA_Circular_Mode>:
  * @brief  It switches SPI DMA in circular mode
  * @param  PortNum The port index
  * @retval None
  */
void STUSB16xx_HW_IF_Set_DMA_Circular_Mode(uint8_t PortNum)
{
 800b1d4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800b1d6:	24f0      	movs	r4, #240	; 0xf0
 800b1d8:	0064      	lsls	r4, r4, #1
 800b1da:	4344      	muls	r4, r0
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800b1dc:	0023      	movs	r3, r4
 800b1de:	4f0e      	ldr	r7, [pc, #56]	; (800b218 <STUSB16xx_HW_IF_Set_DMA_Circular_Mode+0x44>)
 800b1e0:	33a4      	adds	r3, #164	; 0xa4
  
  hdma_tx_spi->Init.Mode =                  DMA_CIRCULAR;
 800b1e2:	193e      	adds	r6, r7, r4
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800b1e4:	19db      	adds	r3, r3, r7
 800b1e6:	9301      	str	r3, [sp, #4]
  hdma_tx_spi->Init.Mode =                  DMA_CIRCULAR;
 800b1e8:	0033      	movs	r3, r6
 800b1ea:	2220      	movs	r2, #32
 800b1ec:	33bc      	adds	r3, #188	; 0xbc
{
 800b1ee:	0005      	movs	r5, r0
  hdma_tx_spi->Init.Mode =                  DMA_CIRCULAR;
 800b1f0:	601a      	str	r2, [r3, #0]
  HAL_DMA_Init(hdma_tx_spi);
 800b1f2:	9801      	ldr	r0, [sp, #4]
 800b1f4:	f7fc fb22 	bl	800783c <HAL_DMA_Init>
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800b1f8:	0033      	movs	r3, r6
 800b1fa:	9a01      	ldr	r2, [sp, #4]
 800b1fc:	3394      	adds	r3, #148	; 0x94
 800b1fe:	601a      	str	r2, [r3, #0]
  
  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800b200:	4268      	negs	r0, r5
 800b202:	4168      	adcs	r0, r5
 800b204:	2200      	movs	r2, #0
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800b206:	3440      	adds	r4, #64	; 0x40
 800b208:	36c8      	adds	r6, #200	; 0xc8
 800b20a:	19e7      	adds	r7, r4, r7
 800b20c:	6037      	str	r7, [r6, #0]
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800b20e:	300a      	adds	r0, #10
 800b210:	0011      	movs	r1, r2
 800b212:	f7fc f9e7 	bl	80075e4 <HAL_NVIC_SetPriority>
}
 800b216:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800b218:	20000058 	.word	0x20000058

0800b21c <STUSB16xx_HW_IF_Switch_Mode>:
  * @param  PortNum The port index
  * @param  mode Two allowed values:  STUSB16xx_SPI_Mode_TX or STUSB16xx_SPI_Mode_RX
  * @retval None
  */ 
void STUSB16xx_HW_IF_Switch_Mode(uint8_t PortNum, STUSB1602_SPI_Mode_TypeDef mode)
{
 800b21c:	b570      	push	{r4, r5, r6, lr}
 800b21e:	000c      	movs	r4, r1

  /* Set the data sampling edge according to mode */
  HW_IF_SPI_Mode(PortNum, mode);  
  
  /* Enable/Disable RX NSS EXT Interrupt */
  HW_IF_NSS_RisingFalling_Interrupt (PortNum, mode == STUSB16xx_SPI_Mode_RX ? ENABLE : DISABLE);
 800b220:	3c01      	subs	r4, #1
{
 800b222:	0005      	movs	r5, r0
  HW_IF_SPI_Mode(PortNum, mode);  
 800b224:	f7ff fc16 	bl	800aa54 <HW_IF_SPI_Mode>
  HW_IF_NSS_RisingFalling_Interrupt (PortNum, mode == STUSB16xx_SPI_Mode_RX ? ENABLE : DISABLE);
 800b228:	4261      	negs	r1, r4
 800b22a:	4161      	adcs	r1, r4
 800b22c:	0028      	movs	r0, r5
 800b22e:	b2c9      	uxtb	r1, r1
 800b230:	f7ff fe9a 	bl	800af68 <HW_IF_NSS_RisingFalling_Interrupt>
}
 800b234:	bd70      	pop	{r4, r5, r6, pc}
	...

0800b238 <STUSB16xx_HW_IF_TX_EN_Status>:
  * @param  PortNum The port index
  * @param  status Two allowed values: GPIO_PIN_SET or GPIO_PIN_RESET
  * @retval None
  */ 
void STUSB16xx_HW_IF_TX_EN_Status(uint8_t PortNum, GPIO_PinState status)
{
 800b238:	000a      	movs	r2, r1
 800b23a:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(TX_EN_GPIO_PORT(PortNum), TX_EN_GPIO_PIN(PortNum), status);
 800b23c:	2104      	movs	r1, #4
 800b23e:	2800      	cmp	r0, #0
 800b240:	d000      	beq.n	800b244 <STUSB16xx_HW_IF_TX_EN_Status+0xc>
 800b242:	1849      	adds	r1, r1, r1
 800b244:	4801      	ldr	r0, [pc, #4]	; (800b24c <STUSB16xx_HW_IF_TX_EN_Status+0x14>)
 800b246:	f7fc fc69 	bl	8007b1c <HAL_GPIO_WritePin>
}
 800b24a:	bd10      	pop	{r4, pc}
 800b24c:	48000800 	.word	0x48000800

0800b250 <HW_IF_STUSB16xx_Reset>:
{
 800b250:	b570      	push	{r4, r5, r6, lr}
 800b252:	0005      	movs	r5, r0
  HW_IF_RESET_Assert(PortNum);
 800b254:	2478      	movs	r4, #120	; 0x78
 800b256:	f7ff fcf5 	bl	800ac44 <HW_IF_RESET_Assert>
 800b25a:	46c0      	nop			; (mov r8, r8)
 800b25c:	3c01      	subs	r4, #1
 800b25e:	b2a4      	uxth	r4, r4
  for(uint16_t i=0;i<120;i++) 
 800b260:	2c00      	cmp	r4, #0
 800b262:	d1fa      	bne.n	800b25a <HW_IF_STUSB16xx_Reset+0xa>
  HW_IF_RESET_Deassert(PortNum);
 800b264:	0028      	movs	r0, r5
 800b266:	f7ff fcf9 	bl	800ac5c <HW_IF_RESET_Deassert>
  STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_RESET);
 800b26a:	0028      	movs	r0, r5
 800b26c:	0021      	movs	r1, r4
 800b26e:	f7ff ffe3 	bl	800b238 <STUSB16xx_HW_IF_TX_EN_Status>
}
 800b272:	bd70      	pop	{r4, r5, r6, pc}

0800b274 <USBPD_HW_IF_PortHwInit>:
{
 800b274:	b084      	sub	sp, #16
 800b276:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b278:	b093      	sub	sp, #76	; 0x4c
 800b27a:	ac19      	add	r4, sp, #100	; 0x64
 800b27c:	60a3      	str	r3, [r4, #8]
 800b27e:	ab1f      	add	r3, sp, #124	; 0x7c
 800b280:	781b      	ldrb	r3, [r3, #0]
 800b282:	0005      	movs	r5, r0
 800b284:	9311      	str	r3, [sp, #68]	; 0x44
  nvm_read = 0;
 800b286:	2300      	movs	r3, #0
 800b288:	4f2e      	ldr	r7, [pc, #184]	; (800b344 <USBPD_HW_IF_PortHwInit+0xd0>)
{
 800b28a:	9119      	str	r1, [sp, #100]	; 0x64
 800b28c:	6062      	str	r2, [r4, #4]
  nvm_read = 0;
 800b28e:	703b      	strb	r3, [r7, #0]
  HW_IF_STUSB1602_IO_Init(PortNum);
 800b290:	f7ff fc62 	bl	800ab58 <HW_IF_STUSB1602_IO_Init>
  HW_IF_STUSB16xx_Reset(PortNum);
 800b294:	0028      	movs	r0, r5
 800b296:	f7ff ffdb 	bl	800b250 <HW_IF_STUSB16xx_Reset>
  HW_IF_STUSB16xx_I2C_Init(PortNum);
 800b29a:	0028      	movs	r0, r5
 800b29c:	f7ff fc36 	bl	800ab0c <HW_IF_STUSB16xx_I2C_Init>
  STUSB1602_Driver_Init(PortNum, Ports[PortNum].hi2c);
 800b2a0:	21f0      	movs	r1, #240	; 0xf0
 800b2a2:	0049      	lsls	r1, r1, #1
 800b2a4:	4369      	muls	r1, r5
 800b2a6:	4b28      	ldr	r3, [pc, #160]	; (800b348 <USBPD_HW_IF_PortHwInit+0xd4>)
 800b2a8:	2240      	movs	r2, #64	; 0x40
 800b2aa:	1859      	adds	r1, r3, r1
 800b2ac:	000e      	movs	r6, r1
 800b2ae:	3629      	adds	r6, #41	; 0x29
 800b2b0:	36ff      	adds	r6, #255	; 0xff
 800b2b2:	3139      	adds	r1, #57	; 0x39
 800b2b4:	31ff      	adds	r1, #255	; 0xff
 800b2b6:	4668      	mov	r0, sp
 800b2b8:	3604      	adds	r6, #4
 800b2ba:	f001 fbf7 	bl	800caac <memcpy>
 800b2be:	ce0e      	ldmia	r6!, {r1, r2, r3}
  nvm_read = STUSB1602_NVM_OK_Get(STUSB1602_I2C_Add(PortNum));
 800b2c0:	002e      	movs	r6, r5
  STUSB1602_Driver_Init(PortNum, Ports[PortNum].hi2c);
 800b2c2:	0028      	movs	r0, r5
 800b2c4:	f7fb fb1a 	bl	80068fc <STUSB1602_Driver_Init>
  nvm_read = STUSB1602_NVM_OK_Get(STUSB1602_I2C_Add(PortNum));
 800b2c8:	1e73      	subs	r3, r6, #1
 800b2ca:	419e      	sbcs	r6, r3
 800b2cc:	3628      	adds	r6, #40	; 0x28
    nvm_read = STUSB1602_NVM_OK_Get(STUSB1602_I2C_Add(PortNum));
 800b2ce:	0030      	movs	r0, r6
 800b2d0:	f7fb fdac 	bl	8006e2c <STUSB1602_NVM_OK_Get>
 800b2d4:	7038      	strb	r0, [r7, #0]
  while (nvm_read != 2)
 800b2d6:	783b      	ldrb	r3, [r7, #0]
 800b2d8:	2b02      	cmp	r3, #2
 800b2da:	d1f8      	bne.n	800b2ce <USBPD_HW_IF_PortHwInit+0x5a>
  Ports[PortNum].Device_cut = STUSB1602_DEVICE_CUT_Get(STUSB1602_I2C_Add(PortNum));
 800b2dc:	27f0      	movs	r7, #240	; 0xf0
 800b2de:	007f      	lsls	r7, r7, #1
 800b2e0:	436f      	muls	r7, r5
 800b2e2:	0030      	movs	r0, r6
 800b2e4:	f7fb fdae 	bl	8006e44 <STUSB1602_DEVICE_CUT_Get>
 800b2e8:	4b17      	ldr	r3, [pc, #92]	; (800b348 <USBPD_HW_IF_PortHwInit+0xd4>)
 800b2ea:	19df      	adds	r7, r3, r7
 800b2ec:	003b      	movs	r3, r7
 800b2ee:	33d9      	adds	r3, #217	; 0xd9
 800b2f0:	33ff      	adds	r3, #255	; 0xff
 800b2f2:	7018      	strb	r0, [r3, #0]
  HW_IF_DMA_Init(PortNum);
 800b2f4:	0028      	movs	r0, r5
 800b2f6:	f7ff fbf1 	bl	800aadc <HW_IF_DMA_Init>
  HW_IF_SPI_Init(PortNum);
 800b2fa:	0028      	movs	r0, r5
 800b2fc:	f7ff fb7c 	bl	800a9f8 <HW_IF_SPI_Init>
  HW_IF_COUNTER_TIM_Init(PortNum);
 800b300:	0028      	movs	r0, r5
 800b302:	f7ff fe83 	bl	800b00c <HW_IF_COUNTER_TIM_Init>
  HW_IF_Port_SetInitialRole(PortNum,role);
 800b306:	9911      	ldr	r1, [sp, #68]	; 0x44
 800b308:	0028      	movs	r0, r5
 800b30a:	f7ff fcd3 	bl	800acb4 <HW_IF_Port_SetInitialRole>
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_RX);
 800b30e:	0028      	movs	r0, r5
 800b310:	2101      	movs	r1, #1
 800b312:	f7ff ff83 	bl	800b21c <STUSB16xx_HW_IF_Switch_Mode>
    STUSB1602_CC_Detect_Alrt_Int_Mask_Set(STUSB1602_I2C_Add(PortNum), CC_Detect_Int_UNMASKED);
 800b316:	2100      	movs	r1, #0
 800b318:	0030      	movs	r0, r6
 800b31a:	f7fb fb33 	bl	8006984 <STUSB1602_CC_Detect_Alrt_Int_Mask_Set>
  Ports[PortNum].cbs = cbs;
 800b31e:	003a      	movs	r2, r7
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800b320:	2301      	movs	r3, #1
  Ports[PortNum].cbs = cbs;
 800b322:	32b9      	adds	r2, #185	; 0xb9
 800b324:	32ff      	adds	r2, #255	; 0xff
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800b326:	767b      	strb	r3, [r7, #25]
  Ports[PortNum].cbs = cbs;
 800b328:	0013      	movs	r3, r2
 800b32a:	cc07      	ldmia	r4!, {r0, r1, r2}
 800b32c:	c307      	stmia	r3!, {r0, r1, r2}
 800b32e:	cc07      	ldmia	r4!, {r0, r1, r2}
 800b330:	c307      	stmia	r3!, {r0, r1, r2}
}
 800b332:	2000      	movs	r0, #0
  Ports[PortNum].role = role;
 800b334:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800b336:	3701      	adds	r7, #1
 800b338:	77fb      	strb	r3, [r7, #31]
}
 800b33a:	b013      	add	sp, #76	; 0x4c
 800b33c:	bcf0      	pop	{r4, r5, r6, r7}
 800b33e:	bc08      	pop	{r3}
 800b340:	b004      	add	sp, #16
 800b342:	4718      	bx	r3
 800b344:	200003dc 	.word	0x200003dc
 800b348:	20000058 	.word	0x20000058

0800b34c <STUSB16xx_HW_IF_Alert_Check>:
  * @param  PortNum The port index
  * @retval None
  */ 
void STUSB16xx_HW_IF_Alert_Check(uint8_t PortNum)
{
  Ports[PortNum].AlertEventCount++;
 800b34c:	23f0      	movs	r3, #240	; 0xf0
 800b34e:	005b      	lsls	r3, r3, #1
 800b350:	4343      	muls	r3, r0
 800b352:	4804      	ldr	r0, [pc, #16]	; (800b364 <STUSB16xx_HW_IF_Alert_Check+0x18>)
 800b354:	18c0      	adds	r0, r0, r3
 800b356:	30d1      	adds	r0, #209	; 0xd1
 800b358:	30ff      	adds	r0, #255	; 0xff
 800b35a:	7803      	ldrb	r3, [r0, #0]
 800b35c:	3301      	adds	r3, #1
 800b35e:	7003      	strb	r3, [r0, #0]
}
 800b360:	4770      	bx	lr
 800b362:	46c0      	nop			; (mov r8, r8)
 800b364:	20000058 	.word	0x20000058

0800b368 <STUSB16xx_HW_IF_Alert_Manager>:
  * @brief  It manages registers related to STUSB1602 ALERT interrupts
  * @param  PortNum The port index
  * @retval USBPD_StatusTypeDef
  */ 
USBPD_StatusTypeDef STUSB16xx_HW_IF_Alert_Manager(uint8_t PortNum)
{
 800b368:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b36a:	0004      	movs	r4, r0
 800b36c:	26c8      	movs	r6, #200	; 0xc8
 800b36e:	b085      	sub	sp, #20
 800b370:	46c0      	nop			; (mov r8, r8)
 800b372:	3e01      	subs	r6, #1
  uint8_t AlertAttempts;
  uint8_t AlertAccomplished;
  uint32_t i;

  /* Delay of few us in order to be sure that registers are updated*/
  for(i=0; i<200; i++)
 800b374:	2e00      	cmp	r6, #0
 800b376:	d1fb      	bne.n	800b370 <STUSB16xx_HW_IF_Alert_Manager+0x8>
  AlertAttempts = 10;
  
  while(1)
  {
    /* Registers from 0x0B to 0x12 are read */
    STUSB1602_AlertMonitoring_Value = STUSB1602_Alert_Monitoring_Get(STUSB1602_I2C_Add(PortNum));
 800b378:	0025      	movs	r5, r4
 800b37a:	1e6b      	subs	r3, r5, #1
 800b37c:	419d      	sbcs	r5, r3
 800b37e:	3528      	adds	r5, #40	; 0x28
 800b380:	0029      	movs	r1, r5
 800b382:	a802      	add	r0, sp, #8
 800b384:	f7fb faf0 	bl	8006968 <STUSB1602_Alert_Monitoring_Get>
    
    /* Check ALERT due to a change occurred on CC */
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.CC_DETECTION_STATUS_AL) && \
 800b388:	2240      	movs	r2, #64	; 0x40
 800b38a:	ab02      	add	r3, sp, #8
 800b38c:	781b      	ldrb	r3, [r3, #0]
 800b38e:	9301      	str	r3, [sp, #4]
 800b390:	9901      	ldr	r1, [sp, #4]
  AlertAccomplished = 0;
 800b392:	0033      	movs	r3, r6
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.CC_DETECTION_STATUS_AL) && \
 800b394:	4211      	tst	r1, r2
 800b396:	d03e      	beq.n	800b416 <STUSB16xx_HW_IF_Alert_Manager+0xae>
        (!STUSB1602_AlertMonitoring_Value.reg_0C.b.CC_DETECTION_STATUS_AL_MASK) && \
 800b398:	ab02      	add	r3, sp, #8
 800b39a:	7859      	ldrb	r1, [r3, #1]
  AlertAccomplished = 0;
 800b39c:	0033      	movs	r3, r6
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.CC_DETECTION_STATUS_AL) && \
 800b39e:	4211      	tst	r1, r2
 800b3a0:	d139      	bne.n	800b416 <STUSB16xx_HW_IF_Alert_Manager+0xae>
        (!STUSB1602_AlertMonitoring_Value.reg_0C.b.CC_DETECTION_STATUS_AL_MASK) && \
 800b3a2:	2701      	movs	r7, #1
 800b3a4:	ab02      	add	r3, sp, #8
 800b3a6:	789a      	ldrb	r2, [r3, #2]
  AlertAccomplished = 0;
 800b3a8:	0033      	movs	r3, r6
        (!STUSB1602_AlertMonitoring_Value.reg_0C.b.CC_DETECTION_STATUS_AL_MASK) && \
 800b3aa:	423a      	tst	r2, r7
 800b3ac:	d033      	beq.n	800b416 <STUSB16xx_HW_IF_Alert_Manager+0xae>
        (STUSB1602_AlertMonitoring_Value.reg_0D.b.ATTACH_STATE_TRANS))
    {
      if (STUSB1602_AlertMonitoring_Value.reg_0E.b.CC_ATTACH_STATE)     /* CC line is ATTACHED */
 800b3ae:	ab02      	add	r3, sp, #8
 800b3b0:	78d8      	ldrb	r0, [r3, #3]
 800b3b2:	496a      	ldr	r1, [pc, #424]	; (800b55c <STUSB16xx_HW_IF_Alert_Manager+0x1f4>)
 800b3b4:	4238      	tst	r0, r7
 800b3b6:	d100      	bne.n	800b3ba <STUSB16xx_HW_IF_Alert_Manager+0x52>
 800b3b8:	e093      	b.n	800b4e2 <STUSB16xx_HW_IF_Alert_Manager+0x17a>
      {
        /* Check the CC attach mode */
        switch (STUSB1602_AlertMonitoring_Value.reg_0E.b.CC_ATTACH_MODE)
 800b3ba:	0940      	lsrs	r0, r0, #5
 800b3bc:	3801      	subs	r0, #1
 800b3be:	2318      	movs	r3, #24
 800b3c0:	2804      	cmp	r0, #4
 800b3c2:	d900      	bls.n	800b3c6 <STUSB16xx_HW_IF_Alert_Manager+0x5e>
 800b3c4:	e085      	b.n	800b4d2 <STUSB16xx_HW_IF_Alert_Manager+0x16a>
 800b3c6:	f7fa faf5 	bl	80059b4 <__gnu_thumb1_case_uqi>
 800b3ca:	6c03      	.short	0x6c03
 800b3cc:	747c      	.short	0x747c
 800b3ce:	0c          	.byte	0x0c
 800b3cf:	00          	.byte	0x00
        {
        case Sink_Attached:
          /* USBPD_CAD_STATE_ATTACHED */
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_SWITCH_TO_SRC;
 800b3d0:	4363      	muls	r3, r4
 800b3d2:	18cb      	adds	r3, r1, r3
 800b3d4:	210f      	movs	r1, #15
 800b3d6:	7c1a      	ldrb	r2, [r3, #16]
 800b3d8:	438a      	bics	r2, r1
 800b3da:	0011      	movs	r1, r2
 800b3dc:	2209      	movs	r2, #9
          /*  */
          break;

        default:
          /* USPPD_CAD_STATE_UNKNOWN */
          CAD_HW_Handles[PortNum].state = USPPD_CAD_STATE_UNKNOW;
 800b3de:	430a      	orrs	r2, r1
 800b3e0:	741a      	strb	r2, [r3, #16]
          break;
        }

        /* CAD handle is updated */
        CAD_HW_Handles[PortNum].cc = CCXHANDLE(STUSB1602_AlertMonitoring_Value.reg_11.b.CC_ATTACHED);
 800b3e2:	2118      	movs	r1, #24
 800b3e4:	2630      	movs	r6, #48	; 0x30
 800b3e6:	4361      	muls	r1, r4
 800b3e8:	4a5c      	ldr	r2, [pc, #368]	; (800b55c <STUSB16xx_HW_IF_Alert_Manager+0x1f4>)
 800b3ea:	ab02      	add	r3, sp, #8
 800b3ec:	799b      	ldrb	r3, [r3, #6]
 800b3ee:	1851      	adds	r1, r2, r1
 800b3f0:	7c0a      	ldrb	r2, [r1, #16]
 800b3f2:	09db      	lsrs	r3, r3, #7
 800b3f4:	3301      	adds	r3, #1
 800b3f6:	0118      	lsls	r0, r3, #4
 800b3f8:	43b2      	bics	r2, r6
 800b3fa:	4302      	orrs	r2, r0
 800b3fc:	740a      	strb	r2, [r1, #16]
  Ports[PortNum].CCx = cc;
 800b3fe:	21f0      	movs	r1, #240	; 0xf0
 800b400:	0049      	lsls	r1, r1, #1
 800b402:	4361      	muls	r1, r4
 800b404:	4a56      	ldr	r2, [pc, #344]	; (800b560 <STUSB16xx_HW_IF_Alert_Manager+0x1f8>)
  Ports[PortNum].CCxChange = SET;
 800b406:	3e2f      	subs	r6, #47	; 0x2f
  Ports[PortNum].CCx = cc;
 800b408:	1852      	adds	r2, r2, r1
 800b40a:	7593      	strb	r3, [r2, #22]
  Ports[PortNum].CCxChange = SET;
 800b40c:	75d6      	strb	r6, [r2, #23]

        /* Port handle is updated */
        HW_IF_Port_Set_CC(PortNum, CAD_HW_Handles[PortNum].cc);

        /* RX mode is enabled */
        HW_IF_RX_Enable(PortNum);
 800b40e:	0020      	movs	r0, r4
 800b410:	f7ff fc30 	bl	800ac74 <HW_IF_RX_Enable>
        /* TX mode is enabled */
        HW_IF_RX_Disable(PortNum);
      }

      /* Exit from the alert check procedure */
      AlertAccomplished = 1;
 800b414:	0033      	movs	r3, r6
    }

    /* Check if a MONITORING STATUS ALERT detected */
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.MONITORING_STATUS_AL) && \
 800b416:	2220      	movs	r2, #32
 800b418:	9901      	ldr	r1, [sp, #4]
 800b41a:	4211      	tst	r1, r2
 800b41c:	d00b      	beq.n	800b436 <STUSB16xx_HW_IF_Alert_Manager+0xce>
      (!STUSB1602_AlertMonitoring_Value.reg_0C.b.MONITORING_STATUS_AL_MASK)) 
 800b41e:	a902      	add	r1, sp, #8
 800b420:	7849      	ldrb	r1, [r1, #1]
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.MONITORING_STATUS_AL) && \
 800b422:	4211      	tst	r1, r2
 800b424:	d107      	bne.n	800b436 <STUSB16xx_HW_IF_Alert_Manager+0xce>
    {
      /* Check changes occurred in MONITORING STATUS register and restore the ALERT pin */
      STUSB1602_Monitoring_Status_Trans_Value = STUSB1602_Monitoring_Status_Trans_Reg_Get(STUSB1602_I2C_Add(PortNum));
 800b426:	0028      	movs	r0, r5
 800b428:	f7fb fada 	bl	80069e0 <STUSB1602_Monitoring_Status_Trans_Reg_Get>

      /* Exit from the alert check procedure */
      AlertAccomplished = 1;

      /* If the alert due to a monitoring event is unmasked remove the if statement and put your code */
      if (STUSB1602_Monitoring_Status_Trans_Value.d8 >0)
 800b42c:	b2c0      	uxtb	r0, r0
      AlertAccomplished = 1;
 800b42e:	2301      	movs	r3, #1
      if (STUSB1602_Monitoring_Status_Trans_Value.d8 >0)
 800b430:	2800      	cmp	r0, #0
 800b432:	d000      	beq.n	800b436 <STUSB16xx_HW_IF_Alert_Manager+0xce>
 800b434:	46c0      	nop			; (mov r8, r8)
        __NOP();
      }
    }

    /* Check if a HW FAULT STATUS ALERT detected */
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.HW_FAULT_STATUS_AL) && \
 800b436:	aa02      	add	r2, sp, #8
 800b438:	7811      	ldrb	r1, [r2, #0]
 800b43a:	2210      	movs	r2, #16
 800b43c:	4211      	tst	r1, r2
 800b43e:	d066      	beq.n	800b50e <STUSB16xx_HW_IF_Alert_Manager+0x1a6>
      (!STUSB1602_AlertMonitoring_Value.reg_0C.b.HW_FAULT_STATUS_AL_MASK)) 
 800b440:	a902      	add	r1, sp, #8
 800b442:	7849      	ldrb	r1, [r1, #1]
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.HW_FAULT_STATUS_AL) && \
 800b444:	4211      	tst	r1, r2
 800b446:	d162      	bne.n	800b50e <STUSB16xx_HW_IF_Alert_Manager+0x1a6>
    {
      /* Check changes occurred in HW FAULT STATUS register and restore the ALERT pin */
      STUSB1602_HW_Fault_Status_Trans_Value = STUSB1602_Hard_Fault_Trans_Status_Get(STUSB1602_I2C_Add(PortNum));
 800b448:	0028      	movs	r0, r5
 800b44a:	f7fb fb0f 	bl	8006a6c <STUSB1602_Hard_Fault_Trans_Status_Get>

      /* Exit from the alert check procedure */
      AlertAccomplished = 1;

      /* If the alert due to a hardware fault event is unmasked remove then if statement and put your code*/
      if (STUSB1602_HW_Fault_Status_Trans_Value.d8 >0)
 800b44e:	b2c0      	uxtb	r0, r0
 800b450:	2800      	cmp	r0, #0
 800b452:	d000      	beq.n	800b456 <STUSB16xx_HW_IF_Alert_Manager+0xee>
 800b454:	46c0      	nop			; (mov r8, r8)
 800b456:	2604      	movs	r6, #4
 800b458:	2c00      	cmp	r4, #0
 800b45a:	d100      	bne.n	800b45e <STUSB16xx_HW_IF_Alert_Manager+0xf6>
 800b45c:	2602      	movs	r6, #2
 800b45e:	270a      	movs	r7, #10
 800b460:	b2b6      	uxth	r6, r6
  /* reset alert signal */
  uint8_t count = 10;
  uint8_t cleared_alert_flag = 0;
  while (1)
  {
    cleared_alert_flag = (HAL_GPIO_ReadPin(ALERT_GPIO_PORT(PortNum), ALERT_GPIO_PIN(PortNum)) != GPIO_PIN_RESET);
 800b462:	2090      	movs	r0, #144	; 0x90
 800b464:	0031      	movs	r1, r6
 800b466:	05c0      	lsls	r0, r0, #23
 800b468:	f7fc fb52 	bl	8007b10 <HAL_GPIO_ReadPin>
 800b46c:	1e04      	subs	r4, r0, #0
    /* check if the alert pin is reset */
    if (cleared_alert_flag || count == 0) 
 800b46e:	d158      	bne.n	800b522 <STUSB16xx_HW_IF_Alert_Manager+0x1ba>
 800b470:	2f00      	cmp	r7, #0
 800b472:	d056      	beq.n	800b522 <STUSB16xx_HW_IF_Alert_Manager+0x1ba>
    {
      break;
    }
    if (STUSB16xx_I2CxHandle.Lock != HAL_LOCKED)
 800b474:	4b3b      	ldr	r3, [pc, #236]	; (800b564 <STUSB16xx_HW_IF_Alert_Manager+0x1fc>)
 800b476:	3340      	adds	r3, #64	; 0x40
 800b478:	781b      	ldrb	r3, [r3, #0]
 800b47a:	2b01      	cmp	r3, #1
 800b47c:	d0f1      	beq.n	800b462 <STUSB16xx_HW_IF_Alert_Manager+0xfa>
    {
      /* Restore the CC_DETECTION_STATUS_TRANS register*/
      STUSB1602_Attach_State_Trans_Get(STUSB1602_I2C_Add(PortNum));
 800b47e:	0028      	movs	r0, r5
 800b480:	f7fb fa98 	bl	80069b4 <STUSB1602_Attach_State_Trans_Get>

      /* Restore the MONITORING_STATUS_TRANS register */
      STUSB1602_Monitoring_Status_Trans_Reg_Get(STUSB1602_I2C_Add(PortNum));
 800b484:	0028      	movs	r0, r5
 800b486:	f7fb faab 	bl	80069e0 <STUSB1602_Monitoring_Status_Trans_Reg_Get>

      /* Restore the HARD_FAULT_TRANS register */
      STUSB1602_Hard_Fault_Trans_Status_Get(STUSB1602_I2C_Add(PortNum));
 800b48a:	0028      	movs	r0, r5
 800b48c:	f7fb faee 	bl	8006a6c <STUSB1602_Hard_Fault_Trans_Status_Get>

      /* Decrement the counter to implement a TO */
      count--;
 800b490:	23fa      	movs	r3, #250	; 0xfa
 800b492:	3f01      	subs	r7, #1
 800b494:	b2ff      	uxtb	r7, r7
 800b496:	009b      	lsls	r3, r3, #2
 800b498:	46c0      	nop			; (mov r8, r8)
 800b49a:	3b01      	subs	r3, #1

      /* wait a bit time */
      for(i=0; i<1000; i++)
 800b49c:	2b00      	cmp	r3, #0
 800b49e:	d1fb      	bne.n	800b498 <STUSB16xx_HW_IF_Alert_Manager+0x130>
 800b4a0:	e7df      	b.n	800b462 <STUSB16xx_HW_IF_Alert_Manager+0xfa>
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_SWITCH_TO_SNK;
 800b4a2:	4363      	muls	r3, r4
 800b4a4:	18cb      	adds	r3, r1, r3
 800b4a6:	210f      	movs	r1, #15
 800b4a8:	7c1a      	ldrb	r2, [r3, #16]
 800b4aa:	438a      	bics	r2, r1
 800b4ac:	0011      	movs	r1, r2
 800b4ae:	220a      	movs	r2, #10
 800b4b0:	e795      	b.n	800b3de <STUSB16xx_HW_IF_Alert_Manager+0x76>
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_ACCESSORY;
 800b4b2:	4363      	muls	r3, r4
 800b4b4:	18cb      	adds	r3, r1, r3
 800b4b6:	210f      	movs	r1, #15
 800b4b8:	7c1a      	ldrb	r2, [r3, #16]
 800b4ba:	438a      	bics	r2, r1
 800b4bc:	0011      	movs	r1, r2
 800b4be:	2207      	movs	r2, #7
 800b4c0:	e78d      	b.n	800b3de <STUSB16xx_HW_IF_Alert_Manager+0x76>
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_DEBUG;
 800b4c2:	4363      	muls	r3, r4
 800b4c4:	18cb      	adds	r3, r1, r3
 800b4c6:	210f      	movs	r1, #15
 800b4c8:	7c1a      	ldrb	r2, [r3, #16]
 800b4ca:	438a      	bics	r2, r1
 800b4cc:	0011      	movs	r1, r2
 800b4ce:	2208      	movs	r2, #8
 800b4d0:	e785      	b.n	800b3de <STUSB16xx_HW_IF_Alert_Manager+0x76>
          CAD_HW_Handles[PortNum].state = USPPD_CAD_STATE_UNKNOW;
 800b4d2:	4363      	muls	r3, r4
 800b4d4:	18cb      	adds	r3, r1, r3
 800b4d6:	210f      	movs	r1, #15
 800b4d8:	7c1a      	ldrb	r2, [r3, #16]
 800b4da:	438a      	bics	r2, r1
 800b4dc:	0011      	movs	r1, r2
 800b4de:	220c      	movs	r2, #12
 800b4e0:	e77d      	b.n	800b3de <STUSB16xx_HW_IF_Alert_Manager+0x76>
        CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_DETACHED;
 800b4e2:	2318      	movs	r3, #24
 800b4e4:	4363      	muls	r3, r4
 800b4e6:	18cb      	adds	r3, r1, r3
 800b4e8:	210f      	movs	r1, #15
 800b4ea:	7c1a      	ldrb	r2, [r3, #16]
        HW_IF_RX_Disable(PortNum);
 800b4ec:	0020      	movs	r0, r4
        CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_DETACHED;
 800b4ee:	438a      	bics	r2, r1
        CAD_HW_Handles[PortNum].cc = CCNONE;
 800b4f0:	433a      	orrs	r2, r7
 800b4f2:	3121      	adds	r1, #33	; 0x21
 800b4f4:	438a      	bics	r2, r1
 800b4f6:	741a      	strb	r2, [r3, #16]
  Ports[PortNum].CCx = cc;
 800b4f8:	22f0      	movs	r2, #240	; 0xf0
 800b4fa:	0052      	lsls	r2, r2, #1
 800b4fc:	4362      	muls	r2, r4
 800b4fe:	4b18      	ldr	r3, [pc, #96]	; (800b560 <STUSB16xx_HW_IF_Alert_Manager+0x1f8>)
 800b500:	189b      	adds	r3, r3, r2
 800b502:	759e      	strb	r6, [r3, #22]
  Ports[PortNum].CCxChange = SET;
 800b504:	75df      	strb	r7, [r3, #23]
        HW_IF_RX_Disable(PortNum);
 800b506:	f7ff fbc5 	bl	800ac94 <HW_IF_RX_Disable>
      AlertAccomplished = 1;
 800b50a:	003b      	movs	r3, r7
 800b50c:	e783      	b.n	800b416 <STUSB16xx_HW_IF_Alert_Manager+0xae>
    if (AlertAttempts == 0 || AlertAccomplished)
 800b50e:	2b00      	cmp	r3, #0
 800b510:	d1a1      	bne.n	800b456 <STUSB16xx_HW_IF_Alert_Manager+0xee>
 800b512:	330a      	adds	r3, #10
 800b514:	46c0      	nop			; (mov r8, r8)
 800b516:	3b01      	subs	r3, #1
    for(i=0; i<10; i++)
 800b518:	2b00      	cmp	r3, #0
 800b51a:	d1fb      	bne.n	800b514 <STUSB16xx_HW_IF_Alert_Manager+0x1ac>
      for(i=0; i<400000; i++) __NOP();
    }

  }
  return USBPD_OK;
} 
 800b51c:	2000      	movs	r0, #0
 800b51e:	b005      	add	sp, #20
 800b520:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cleared_alert_flag |= (HAL_GPIO_ReadPin(ALERT_GPIO_PORT(PortNum), ALERT_GPIO_PIN(PortNum)) != GPIO_PIN_RESET);
 800b522:	2090      	movs	r0, #144	; 0x90
 800b524:	0031      	movs	r1, r6
 800b526:	05c0      	lsls	r0, r0, #23
 800b528:	f7fc faf2 	bl	8007b10 <HAL_GPIO_ReadPin>
  if (!cleared_alert_flag) {
 800b52c:	4320      	orrs	r0, r4
 800b52e:	b2c0      	uxtb	r0, r0
 800b530:	2800      	cmp	r0, #0
 800b532:	d1f3      	bne.n	800b51c <STUSB16xx_HW_IF_Alert_Manager+0x1b4>
    USBPD_BSP_LED_Off(GREEN_USER_LED);
 800b534:	f7fb fd14 	bl	8006f60 <USBPD_BSP_LED_Off>
    USBPD_BSP_LED_Off(LED_PORT0_CC);
 800b538:	2003      	movs	r0, #3
 800b53a:	f7fb fd11 	bl	8006f60 <USBPD_BSP_LED_Off>
    USBPD_BSP_LED_Off(LED_PORT0_VBUS);
 800b53e:	2002      	movs	r0, #2
 800b540:	f7fb fd0e 	bl	8006f60 <USBPD_BSP_LED_Off>
    USBPD_BSP_LED_Off(LED_PORT0_ROLE);
 800b544:	2001      	movs	r0, #1
 800b546:	f7fb fd0b 	bl	8006f60 <USBPD_BSP_LED_Off>
      USBPD_BSP_LED_Toggle(PortNum == 0 ? LED_PORT0_CC : LED_PORT0_CC);
 800b54a:	2003      	movs	r0, #3
 800b54c:	f7fb fd32 	bl	8006fb4 <USBPD_BSP_LED_Toggle>
 800b550:	4b05      	ldr	r3, [pc, #20]	; (800b568 <STUSB16xx_HW_IF_Alert_Manager+0x200>)
 800b552:	46c0      	nop			; (mov r8, r8)
 800b554:	3b01      	subs	r3, #1
      for(i=0; i<400000; i++) __NOP();
 800b556:	2b00      	cmp	r3, #0
 800b558:	d1fb      	bne.n	800b552 <STUSB16xx_HW_IF_Alert_Manager+0x1ea>
 800b55a:	e7f6      	b.n	800b54a <STUSB16xx_HW_IF_Alert_Manager+0x1e2>
 800b55c:	20001c68 	.word	0x20001c68
 800b560:	20000058 	.word	0x20000058
 800b564:	20001a50 	.word	0x20001a50
 800b568:	00061a80 	.word	0x00061a80

0800b56c <CAD_StateMachine>:
{
 800b56c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (hhw_handle->AlertEventCount > 0)
 800b56e:	27f0      	movs	r7, #240	; 0xf0
{
 800b570:	000d      	movs	r5, r1
  *Event = USBPD_CAD_EVENT_NONE;
 800b572:	2100      	movs	r1, #0
  if (hhw_handle->AlertEventCount > 0)
 800b574:	007f      	lsls	r7, r7, #1
 800b576:	4347      	muls	r7, r0
 800b578:	4e51      	ldr	r6, [pc, #324]	; (800b6c0 <CAD_StateMachine+0x154>)
{
 800b57a:	0004      	movs	r4, r0
  if (hhw_handle->AlertEventCount > 0)
 800b57c:	19f7      	adds	r7, r6, r7
 800b57e:	37d1      	adds	r7, #209	; 0xd1
 800b580:	37ff      	adds	r7, #255	; 0xff
 800b582:	783b      	ldrb	r3, [r7, #0]
{
 800b584:	9201      	str	r2, [sp, #4]
  *Event = USBPD_CAD_EVENT_NONE;
 800b586:	7029      	strb	r1, [r5, #0]
  if (hhw_handle->AlertEventCount > 0)
 800b588:	428b      	cmp	r3, r1
 800b58a:	d00c      	beq.n	800b5a6 <CAD_StateMachine+0x3a>
    ret = HW_IF_COMM_WAIT(PortNum, 0);
 800b58c:	f7ff f95c 	bl	800a848 <HW_IF_COMM_WAIT>
    if (ret == USBPD_OK)
 800b590:	2800      	cmp	r0, #0
 800b592:	d108      	bne.n	800b5a6 <CAD_StateMachine+0x3a>
      if (STUSB16xx_HW_IF_Alert_Manager(PortNum) == USBPD_OK)
 800b594:	0020      	movs	r0, r4
 800b596:	f7ff fee7 	bl	800b368 <STUSB16xx_HW_IF_Alert_Manager>
 800b59a:	2800      	cmp	r0, #0
 800b59c:	d100      	bne.n	800b5a0 <CAD_StateMachine+0x34>
        hhw_handle->AlertEventCount = 0;
 800b59e:	7038      	strb	r0, [r7, #0]
      HW_IF_COMM_RELEASE(PortNum);
 800b5a0:	0020      	movs	r0, r4
 800b5a2:	f7ff f96f 	bl	800a884 <HW_IF_COMM_RELEASE>
  switch(_handle->state)
 800b5a6:	2218      	movs	r2, #24
 800b5a8:	0013      	movs	r3, r2
 800b5aa:	4363      	muls	r3, r4
 800b5ac:	4945      	ldr	r1, [pc, #276]	; (800b6c4 <CAD_StateMachine+0x158>)
 800b5ae:	18cb      	adds	r3, r1, r3
 800b5b0:	7c18      	ldrb	r0, [r3, #16]
 800b5b2:	23f0      	movs	r3, #240	; 0xf0
 800b5b4:	0700      	lsls	r0, r0, #28
 800b5b6:	0f00      	lsrs	r0, r0, #28
 800b5b8:	005b      	lsls	r3, r3, #1
 800b5ba:	280a      	cmp	r0, #10
 800b5bc:	d900      	bls.n	800b5c0 <CAD_StateMachine+0x54>
 800b5be:	e06b      	b.n	800b698 <CAD_StateMachine+0x12c>
 800b5c0:	f7fa f9f8 	bl	80059b4 <__gnu_thumb1_case_uqi>
 800b5c4:	6a6a0619 	.word	0x6a6a0619
 800b5c8:	6a6a6a6a 	.word	0x6a6a6a6a
 800b5cc:	566a      	.short	0x566a
 800b5ce:	71          	.byte	0x71
 800b5cf:	00          	.byte	0x00
    if (Ports[PortNum].NbDetach == 0)
 800b5d0:	4363      	muls	r3, r4
 800b5d2:	18f3      	adds	r3, r6, r3
 800b5d4:	33d3      	adds	r3, #211	; 0xd3
 800b5d6:	33ff      	adds	r3, #255	; 0xff
 800b5d8:	9300      	str	r3, [sp, #0]
 800b5da:	781b      	ldrb	r3, [r3, #0]
 800b5dc:	2b00      	cmp	r3, #0
 800b5de:	d10a      	bne.n	800b5f6 <CAD_StateMachine+0x8a>
      if ((STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum))) == VBUS_below_VSAFE0V_threshold)
 800b5e0:	0027      	movs	r7, r4
 800b5e2:	1e7b      	subs	r3, r7, #1
 800b5e4:	419f      	sbcs	r7, r3
 800b5e6:	3728      	adds	r7, #40	; 0x28
 800b5e8:	0038      	movs	r0, r7
 800b5ea:	f7fb fa0f 	bl	8006a0c <STUSB1602_VBUS_VSAFE0V_Get>
 800b5ee:	2801      	cmp	r0, #1
 800b5f0:	d126      	bne.n	800b640 <CAD_StateMachine+0xd4>
        Ports[PortNum].NbDetach = 1;
 800b5f2:	9b00      	ldr	r3, [sp, #0]
 800b5f4:	7018      	strb	r0, [r3, #0]
    *Event = USBPD_CAD_EVENT_DETACHED;
 800b5f6:	2301      	movs	r3, #1
 800b5f8:	702b      	strb	r3, [r5, #0]
  if ((hhw_handle->CCxChange == SET) && (_handle->state != USBPD_CAD_STATE_SWITCH_TO_SRC) && (_handle->state != USBPD_CAD_STATE_SWITCH_TO_SNK))
 800b5fa:	23f0      	movs	r3, #240	; 0xf0
 800b5fc:	005b      	lsls	r3, r3, #1
 800b5fe:	4363      	muls	r3, r4
 800b600:	18f6      	adds	r6, r6, r3
 800b602:	7df3      	ldrb	r3, [r6, #23]
 800b604:	2b01      	cmp	r3, #1
 800b606:	d10f      	bne.n	800b628 <CAD_StateMachine+0xbc>
 800b608:	3317      	adds	r3, #23
 800b60a:	4363      	muls	r3, r4
 800b60c:	4a2d      	ldr	r2, [pc, #180]	; (800b6c4 <CAD_StateMachine+0x158>)
 800b60e:	18d3      	adds	r3, r2, r3
 800b610:	220f      	movs	r2, #15
 800b612:	7c1b      	ldrb	r3, [r3, #16]
 800b614:	401a      	ands	r2, r3
 800b616:	3a09      	subs	r2, #9
 800b618:	2a01      	cmp	r2, #1
 800b61a:	d905      	bls.n	800b628 <CAD_StateMachine+0xbc>
    *CCXX  = _handle->cc;
 800b61c:	069b      	lsls	r3, r3, #26
 800b61e:	9a01      	ldr	r2, [sp, #4]
 800b620:	0f9b      	lsrs	r3, r3, #30
 800b622:	7013      	strb	r3, [r2, #0]
    hhw_handle->CCxChange = RESET;
 800b624:	2300      	movs	r3, #0
 800b626:	75f3      	strb	r3, [r6, #23]
  if ((*Event != USBPD_CAD_EVENT_DETACHED) || (previous_event[PortNum] != USBPD_CAD_EVENT_DETACHED))
 800b628:	782a      	ldrb	r2, [r5, #0]
 800b62a:	4b27      	ldr	r3, [pc, #156]	; (800b6c8 <CAD_StateMachine+0x15c>)
 800b62c:	2a01      	cmp	r2, #1
 800b62e:	d103      	bne.n	800b638 <CAD_StateMachine+0xcc>
 800b630:	1919      	adds	r1, r3, r4
 800b632:	7849      	ldrb	r1, [r1, #1]
 800b634:	2901      	cmp	r1, #1
 800b636:	d03f      	beq.n	800b6b8 <CAD_StateMachine+0x14c>
    previous_event[PortNum] = *Event;
 800b638:	191c      	adds	r4, r3, r4
 800b63a:	7062      	strb	r2, [r4, #1]
}
 800b63c:	2002      	movs	r0, #2
 800b63e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        if  (STUSB1602_TypeC_FSM_State_Get(STUSB1602_I2C_Add(PortNum)) == Unattached_SNK)
 800b640:	0038      	movs	r0, r7
 800b642:	f7fb fa07 	bl	8006a54 <STUSB1602_TypeC_FSM_State_Get>
 800b646:	2800      	cmp	r0, #0
 800b648:	d1d5      	bne.n	800b5f6 <CAD_StateMachine+0x8a>
          if ((STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum))) != VBUS_below_VSAFE0V_threshold)
 800b64a:	0038      	movs	r0, r7
 800b64c:	f7fb f9de 	bl	8006a0c <STUSB1602_VBUS_VSAFE0V_Get>
 800b650:	2801      	cmp	r0, #1
 800b652:	d0d0      	beq.n	800b5f6 <CAD_StateMachine+0x8a>
            if ((STUSB1602_TypeC_FSM_State_Get(STUSB1602_I2C_Add(PortNum)) == AttachWait_SRC) && 
 800b654:	0038      	movs	r0, r7
 800b656:	f7fb f9fd 	bl	8006a54 <STUSB1602_TypeC_FSM_State_Get>
 800b65a:	2809      	cmp	r0, #9
 800b65c:	d1cb      	bne.n	800b5f6 <CAD_StateMachine+0x8a>
                (STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_below_VSAFE0V_threshold))
 800b65e:	0038      	movs	r0, r7
 800b660:	f7fb f9d4 	bl	8006a0c <STUSB1602_VBUS_VSAFE0V_Get>
            if ((STUSB1602_TypeC_FSM_State_Get(STUSB1602_I2C_Add(PortNum)) == AttachWait_SRC) && 
 800b664:	2801      	cmp	r0, #1
 800b666:	d0c6      	beq.n	800b5f6 <CAD_StateMachine+0x8a>
              HW_IF_RESET_CTRL(PortNum);
 800b668:	0020      	movs	r0, r4
 800b66a:	f7ff fad9 	bl	800ac20 <HW_IF_RESET_CTRL>
 800b66e:	e7c2      	b.n	800b5f6 <CAD_StateMachine+0x8a>
    _handle->params->PE_PowerRole = USBPD_PORTPOWERROLE_SRC;
 800b670:	0013      	movs	r3, r2
 800b672:	4363      	muls	r3, r4
 800b674:	4a13      	ldr	r2, [pc, #76]	; (800b6c4 <CAD_StateMachine+0x158>)
 800b676:	18d3      	adds	r3, r2, r3
 800b678:	2204      	movs	r2, #4
 800b67a:	6859      	ldr	r1, [r3, #4]
 800b67c:	7808      	ldrb	r0, [r1, #0]
 800b67e:	4302      	orrs	r2, r0
    _handle->params->PE_PowerRole = USBPD_PORTPOWERROLE_SNK;
 800b680:	700a      	strb	r2, [r1, #0]
    _handle->state = USBPD_CAD_STATE_ATTACHED;
 800b682:	210f      	movs	r1, #15
 800b684:	7c1a      	ldrb	r2, [r3, #16]
 800b686:	438a      	bics	r2, r1
 800b688:	0011      	movs	r1, r2
 800b68a:	2203      	movs	r2, #3
 800b68c:	430a      	orrs	r2, r1
 800b68e:	741a      	strb	r2, [r3, #16]
    *Event = USBPD_CAD_EVENT_ATTACHED;
 800b690:	2302      	movs	r3, #2
 800b692:	702b      	strb	r3, [r5, #0]
    Ports[PortNum].NbDetach =0;
 800b694:	33df      	adds	r3, #223	; 0xdf
 800b696:	33ff      	adds	r3, #255	; 0xff
    Ports[PortNum].NbDetach =0;
 800b698:	2200      	movs	r2, #0
 800b69a:	4363      	muls	r3, r4
 800b69c:	18f3      	adds	r3, r6, r3
 800b69e:	33d3      	adds	r3, #211	; 0xd3
 800b6a0:	33ff      	adds	r3, #255	; 0xff
 800b6a2:	701a      	strb	r2, [r3, #0]
    break;
 800b6a4:	e7a9      	b.n	800b5fa <CAD_StateMachine+0x8e>
    _handle->params->PE_PowerRole = USBPD_PORTPOWERROLE_SNK;
 800b6a6:	0013      	movs	r3, r2
 800b6a8:	2004      	movs	r0, #4
 800b6aa:	4363      	muls	r3, r4
 800b6ac:	4a05      	ldr	r2, [pc, #20]	; (800b6c4 <CAD_StateMachine+0x158>)
 800b6ae:	18d3      	adds	r3, r2, r3
 800b6b0:	6859      	ldr	r1, [r3, #4]
 800b6b2:	780a      	ldrb	r2, [r1, #0]
 800b6b4:	4382      	bics	r2, r0
 800b6b6:	e7e3      	b.n	800b680 <CAD_StateMachine+0x114>
    *Event = USBPD_CAD_EVENT_NONE;
 800b6b8:	2300      	movs	r3, #0
 800b6ba:	702b      	strb	r3, [r5, #0]
 800b6bc:	e7be      	b.n	800b63c <CAD_StateMachine+0xd0>
 800b6be:	46c0      	nop			; (mov r8, r8)
 800b6c0:	20000058 	.word	0x20000058
 800b6c4:	20001c68 	.word	0x20001c68
 800b6c8:	200003dc 	.word	0x200003dc

0800b6cc <STUSB16xx_HW_IF_Send_Packet>:
  * @param  pData The pointer to data buffer
  * @param  Size The amount of data to be sent
  * @retval USBPD status
  */
USBPD_StatusTypeDef STUSB16xx_HW_IF_Send_Packet(uint8_t PortNum, uint8_t *pData, uint16_t Size)
{
 800b6cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800b6ce:	0005      	movs	r5, r0
 800b6d0:	9100      	str	r1, [sp, #0]
 800b6d2:	9201      	str	r2, [sp, #4]
  USBPD_StatusTypeDef ret = USBPD_ERROR;
  
  /* Check if the bus is idle */
  ret = HW_IF_check_bus_idle(PortNum);
 800b6d4:	f7ff fc28 	bl	800af28 <HW_IF_check_bus_idle>
 800b6d8:	1e06      	subs	r6, r0, #0
  if (ret == USBPD_OK && 1 /* tx ready */)
 800b6da:	d11d      	bne.n	800b718 <STUSB16xx_HW_IF_Send_Packet+0x4c>
  {
    /* Set the state to busy*/
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_TX;
 800b6dc:	24f0      	movs	r4, #240	; 0xf0
 800b6de:	2203      	movs	r2, #3
 800b6e0:	0064      	lsls	r4, r4, #1
 800b6e2:	436c      	muls	r4, r5
 800b6e4:	4f0d      	ldr	r7, [pc, #52]	; (800b71c <STUSB16xx_HW_IF_Send_Packet+0x50>)

    /* Set the SPI in TX mode */
    STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 800b6e6:	0001      	movs	r1, r0
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_TX;
 800b6e8:	193b      	adds	r3, r7, r4

    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800b6ea:	3440      	adds	r4, #64	; 0x40
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_TX;
 800b6ec:	765a      	strb	r2, [r3, #25]
    STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 800b6ee:	0028      	movs	r0, r5
    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800b6f0:	19e4      	adds	r4, r4, r7
    STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 800b6f2:	f7ff fd93 	bl	800b21c <STUSB16xx_HW_IF_Switch_Mode>
    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800b6f6:	0020      	movs	r0, r4
 800b6f8:	f7fd f912 	bl	8008920 <HAL_SPI_DMAStop>
    __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 800b6fc:	4b08      	ldr	r3, [pc, #32]	; (800b720 <STUSB16xx_HW_IF_Send_Packet+0x54>)
 800b6fe:	4a09      	ldr	r2, [pc, #36]	; (800b724 <STUSB16xx_HW_IF_Send_Packet+0x58>)

    /* Send TX Buffer by SPI DMA */
    HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, pData, Size);
 800b700:	9900      	ldr	r1, [sp, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 800b702:	605a      	str	r2, [r3, #4]
    HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, pData, Size);
 800b704:	0020      	movs	r0, r4
 800b706:	9a01      	ldr	r2, [sp, #4]
 800b708:	f7fc fef8 	bl	80084fc <HAL_SPI_Transmit_DMA>

    /* Set TX_EN GPIO */
    STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_SET);
 800b70c:	2101      	movs	r1, #1
 800b70e:	0028      	movs	r0, r5
 800b710:	f7ff fd92 	bl	800b238 <STUSB16xx_HW_IF_TX_EN_Status>
  else
  {
    __NOP();
  }
  return ret;
}
 800b714:	0030      	movs	r0, r6
 800b716:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800b718:	46c0      	nop			; (mov r8, r8)
 800b71a:	e7fb      	b.n	800b714 <STUSB16xx_HW_IF_Send_Packet+0x48>
 800b71c:	20000058 	.word	0x20000058
 800b720:	40020000 	.word	0x40020000
 800b724:	0fffffff 	.word	0x0fffffff

0800b728 <STUSB16xx_HW_IF_DataRoleSwap>:
USBPD_StatusTypeDef STUSB16xx_HW_IF_DataRoleSwap(uint8_t PortNum)
{
  uint32_t STUSB16xx_ACK_timeout = 0xFFFF;
  USBPD_StatusTypeDef ret = USBPD_ERROR;

  if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_DFP)
 800b728:	21f0      	movs	r1, #240	; 0xf0
 800b72a:	0049      	lsls	r1, r1, #1
 800b72c:	4341      	muls	r1, r0
 800b72e:	4a0c      	ldr	r2, [pc, #48]	; (800b760 <STUSB16xx_HW_IF_DataRoleSwap+0x38>)
{
 800b730:	b510      	push	{r4, lr}
  if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_DFP)
 800b732:	1852      	adds	r2, r2, r1
 800b734:	3229      	adds	r2, #41	; 0x29
 800b736:	7812      	ldrb	r2, [r2, #0]
{
 800b738:	0003      	movs	r3, r0
  if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_DFP)
 800b73a:	2a01      	cmp	r2, #1
 800b73c:	d107      	bne.n	800b74e <STUSB16xx_HW_IF_DataRoleSwap+0x26>
  {
    /* i2c_dr_swap_port_change_2_ufp_req command */
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Control_Set(STUSB1602_I2C_Add(PortNum), PD_DR_SWAP_PORT_CHANGE_2_UFP_REQ);    
 800b73e:	1e58      	subs	r0, r3, #1
 800b740:	4183      	sbcs	r3, r0
 800b742:	3328      	adds	r3, #40	; 0x28
 800b744:	0018      	movs	r0, r3
 800b746:	210a      	movs	r1, #10
//    }
  }
  else if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_UFP)
  {
    /* i2c_dr_swap_port_change_2_dfp_req command */
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Control_Set(STUSB1602_I2C_Add(PortNum), PD_DR_SWAP_PORT_CHANGE_2_DFP_REQ);    
 800b748:	f7fb fa3e 	bl	8006bc8 <STUSB1602_Type_C_Control_Set>

  if (STUSB16xx_ACK_timeout == 0)
    ret = USBPD_ERROR;

  return ret;
}
 800b74c:	bd10      	pop	{r4, pc}
    ret = USBPD_ERROR;
 800b74e:	2002      	movs	r0, #2
  else if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_UFP)
 800b750:	2a00      	cmp	r2, #0
 800b752:	d1fb      	bne.n	800b74c <STUSB16xx_HW_IF_DataRoleSwap+0x24>
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Control_Set(STUSB1602_I2C_Add(PortNum), PD_DR_SWAP_PORT_CHANGE_2_DFP_REQ);    
 800b754:	1e58      	subs	r0, r3, #1
 800b756:	4183      	sbcs	r3, r0
 800b758:	3328      	adds	r3, #40	; 0x28
 800b75a:	0018      	movs	r0, r3
 800b75c:	2109      	movs	r1, #9
 800b75e:	e7f3      	b.n	800b748 <STUSB16xx_HW_IF_DataRoleSwap+0x20>
 800b760:	20000058 	.word	0x20000058

0800b764 <USBPD_16xx_IsResistor_SinkTxOk>:
  * @brief  Get Sink Resistors State
  * @param  PortNum The port index
  * @retval USBPD_FALSE of USBPD_TRUE
  */
uint8_t USBPD_16xx_IsResistor_SinkTxOk(uint8_t PortNum)
{
 800b764:	b570      	push	{r4, r5, r6, lr}
  uint8_t TX_OK;

  USBPD_StatusTypeDef ret = USBPD_ERROR;
  /* try to acquire the communication resource to avoid the conflict */
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800b766:	2164      	movs	r1, #100	; 0x64
{
 800b768:	0005      	movs	r5, r0
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800b76a:	f7ff f86d 	bl	800a848 <HW_IF_COMM_WAIT>
  if (ret != USBPD_OK)
  {
    return USBPD_FALSE;
 800b76e:	2300      	movs	r3, #0
  if (ret != USBPD_OK)
 800b770:	4298      	cmp	r0, r3
 800b772:	d10d      	bne.n	800b790 <USBPD_16xx_IsResistor_SinkTxOk+0x2c>
  }
  TX_OK = STUSB1602_Sink_Power_State_Get(STUSB1602_I2C_Add(PortNum));
 800b774:	0028      	movs	r0, r5
 800b776:	1e43      	subs	r3, r0, #1
 800b778:	4198      	sbcs	r0, r3
 800b77a:	3028      	adds	r0, #40	; 0x28
 800b77c:	f7fb f95e 	bl	8006a3c <STUSB1602_Sink_Power_State_Get>
 800b780:	0004      	movs	r4, r0
  HW_IF_COMM_RELEASE(PortNum);
 800b782:	0028      	movs	r0, r5

  if ( TX_OK == Pwr_3_0_SNK)
 800b784:	3c02      	subs	r4, #2
  HW_IF_COMM_RELEASE(PortNum);
 800b786:	f7ff f87d 	bl	800a884 <HW_IF_COMM_RELEASE>
  if ( TX_OK == Pwr_3_0_SNK)
 800b78a:	4263      	negs	r3, r4
 800b78c:	4163      	adcs	r3, r4
    return USBPD_FALSE;
 800b78e:	b2db      	uxtb	r3, r3
  }
  else
  {
    return USBPD_FALSE;
  }
}
 800b790:	0018      	movs	r0, r3
 800b792:	bd70      	pop	{r4, r5, r6, pc}

0800b794 <USBPD_TIM_Init>:
/**
  * @brief  Initialization of TIMERSERVER, used for CRC and RETRY operations
  * @retval None
  */
void USBPD_TIM_Init(void)
{
 800b794:	b537      	push	{r0, r1, r2, r4, r5, lr}
  TIMx_CLK_ENABLE;
 800b796:	2001      	movs	r0, #1
 800b798:	4a26      	ldr	r2, [pc, #152]	; (800b834 <USBPD_TIM_Init+0xa0>)
  *         @arg @ref LL_TIM_COUNTERMODE_CENTER_UP_DOWN
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetCounterMode(TIM_TypeDef *TIMx, uint32_t CounterMode)
{
  MODIFY_REG(TIMx->CR1, TIM_CR1_DIR | TIM_CR1_CMS, CounterMode);
 800b79a:	2480      	movs	r4, #128	; 0x80
 800b79c:	69d1      	ldr	r1, [r2, #28]
 800b79e:	05e4      	lsls	r4, r4, #23
 800b7a0:	4301      	orrs	r1, r0
 800b7a2:	61d1      	str	r1, [r2, #28]
 800b7a4:	69d3      	ldr	r3, [r2, #28]
 800b7a6:	2270      	movs	r2, #112	; 0x70
 800b7a8:	4003      	ands	r3, r0
 800b7aa:	9301      	str	r3, [sp, #4]
 800b7ac:	9b01      	ldr	r3, [sp, #4]
 800b7ae:	6823      	ldr	r3, [r4, #0]

  /* Counter mode: select up-counting mode */
  LL_TIM_SetCounterMode(TIMx, LL_TIM_COUNTERMODE_UP);

  /* Set the pre-scaler value to have TIMx counter clock equal to 1 MHz */
  LL_TIM_SetPrescaler(TIMx, __LL_TIM_CALC_PSC(SystemCoreClock, 1000000));
 800b7b0:	2000      	movs	r0, #0
 800b7b2:	4393      	bics	r3, r2
 800b7b4:	6023      	str	r3, [r4, #0]
 800b7b6:	4b20      	ldr	r3, [pc, #128]	; (800b838 <USBPD_TIM_Init+0xa4>)
 800b7b8:	681d      	ldr	r5, [r3, #0]
 800b7ba:	4b20      	ldr	r3, [pc, #128]	; (800b83c <USBPD_TIM_Init+0xa8>)
 800b7bc:	429d      	cmp	r5, r3
 800b7be:	d904      	bls.n	800b7ca <USBPD_TIM_Init+0x36>
 800b7c0:	491f      	ldr	r1, [pc, #124]	; (800b840 <USBPD_TIM_Init+0xac>)
 800b7c2:	0028      	movs	r0, r5
 800b7c4:	f7fa f900 	bl	80059c8 <__udivsi3>
 800b7c8:	3801      	subs	r0, #1
  * @param  Prescaler between Min_Data=0 and Max_Data=65535
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
{
  WRITE_REG(TIMx->PSC, Prescaler);
 800b7ca:	62a0      	str	r0, [r4, #40]	; 0x28
  * @param  TIMx Timer instance
  * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
  */
__STATIC_INLINE uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
{
  return (uint32_t)(READ_REG(TIMx->PSC));
 800b7cc:	6aa1      	ldr	r1, [r4, #40]	; 0x28

  /* Set the auto-reload value to have a counter frequency of 250Hz */
  LL_TIM_SetAutoReload(TIMx, __LL_TIM_CALC_ARR(SystemCoreClock, LL_TIM_GetPrescaler(TIMx), 250));
 800b7ce:	0028      	movs	r0, r5
 800b7d0:	3101      	adds	r1, #1
 800b7d2:	f7fa f8f9 	bl	80059c8 <__udivsi3>
 800b7d6:	2200      	movs	r2, #0
 800b7d8:	28f9      	cmp	r0, #249	; 0xf9
 800b7da:	d907      	bls.n	800b7ec <USBPD_TIM_Init+0x58>
 800b7dc:	21fa      	movs	r1, #250	; 0xfa
 800b7de:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800b7e0:	0028      	movs	r0, r5
 800b7e2:	3301      	adds	r3, #1
 800b7e4:	4359      	muls	r1, r3
 800b7e6:	f7fa f8ef 	bl	80059c8 <__udivsi3>
 800b7ea:	1e42      	subs	r2, r0, #1
  * @param  AutoReload between Min_Data=0 and Max_Data=65535
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
{
  WRITE_REG(TIMx->ARR, AutoReload);
 800b7ec:	2380      	movs	r3, #128	; 0x80
 800b7ee:	05db      	lsls	r3, r3, #23
 800b7f0:	62da      	str	r2, [r3, #44]	; 0x2c
  */
__STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
{
  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
 800b7f2:	4c14      	ldr	r4, [pc, #80]	; (800b844 <USBPD_TIM_Init+0xb0>)
 800b7f4:	699a      	ldr	r2, [r3, #24]
 800b7f6:	4914      	ldr	r1, [pc, #80]	; (800b848 <USBPD_TIM_Init+0xb4>)
 800b7f8:	4022      	ands	r2, r4
 800b7fa:	430a      	orrs	r2, r1
  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
 800b7fc:	4813      	ldr	r0, [pc, #76]	; (800b84c <USBPD_TIM_Init+0xb8>)
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
 800b7fe:	619a      	str	r2, [r3, #24]
 800b800:	6842      	ldr	r2, [r0, #4]
 800b802:	4014      	ands	r4, r2
 800b804:	4321      	orrs	r1, r4
 800b806:	6041      	str	r1, [r0, #4]
  * @retval None
  */
__STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
{
  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
  MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
 800b808:	2102      	movs	r1, #2
 800b80a:	6a1a      	ldr	r2, [r3, #32]
 800b80c:	438a      	bics	r2, r1
 800b80e:	621a      	str	r2, [r3, #32]
 800b810:	6a1a      	ldr	r2, [r3, #32]
 800b812:	311e      	adds	r1, #30
 800b814:	438a      	bics	r2, r1
 800b816:	621a      	str	r2, [r3, #32]
 800b818:	6a1a      	ldr	r2, [r3, #32]
 800b81a:	490d      	ldr	r1, [pc, #52]	; (800b850 <USBPD_TIM_Init+0xbc>)
 800b81c:	400a      	ands	r2, r1
 800b81e:	621a      	str	r2, [r3, #32]
 800b820:	6a1a      	ldr	r2, [r3, #32]
 800b822:	490c      	ldr	r1, [pc, #48]	; (800b854 <USBPD_TIM_Init+0xc0>)
 800b824:	400a      	ands	r2, r1
 800b826:	621a      	str	r2, [r3, #32]
  SET_BIT(TIMx->CR1, TIM_CR1_CEN);
 800b828:	2201      	movs	r2, #1
 800b82a:	6819      	ldr	r1, [r3, #0]
 800b82c:	430a      	orrs	r2, r1
 800b82e:	601a      	str	r2, [r3, #0]
  LL_TIM_OC_SetPolarity(TIMx, LL_TIM_CHANNEL_CH3, LL_TIM_OCPOLARITY_HIGH);
  LL_TIM_OC_SetPolarity(TIMx, LL_TIM_CHANNEL_CH4, LL_TIM_OCPOLARITY_HIGH);

  /* Enable counter */
  LL_TIM_EnableCounter(TIMx);
}
 800b830:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
 800b832:	46c0      	nop			; (mov r8, r8)
 800b834:	40021000 	.word	0x40021000
 800b838:	20000030 	.word	0x20000030
 800b83c:	000f423f 	.word	0x000f423f
 800b840:	000f4240 	.word	0x000f4240
 800b844:	ffff8c8c 	.word	0xffff8c8c
 800b848:	00003030 	.word	0x00003030
 800b84c:	40000018 	.word	0x40000018
 800b850:	fffffdff 	.word	0xfffffdff
 800b854:	ffffdfff 	.word	0xffffdfff

0800b858 <USBPD_TIM_Start>:
  * @param  id Timer Operation Identifier
  * @param  us_time time in micro-seconds
  * @retval None
  */
void USBPD_TIM_Start(TIM_identifier id, uint16_t us_time)
{
 800b858:	b510      	push	{r4, lr}
  switch (id)
 800b85a:	2803      	cmp	r0, #3
 800b85c:	d80f      	bhi.n	800b87e <USBPD_TIM_Start+0x26>
 800b85e:	2480      	movs	r4, #128	; 0x80
 800b860:	05e4      	lsls	r4, r4, #23
 800b862:	f7fa f8a7 	bl	80059b4 <__gnu_thumb1_case_uqi>
 800b866:	0d02      	.short	0x0d02
 800b868:	1f16      	.short	0x1f16
  {
    case TIM_PORT0_CRC:
      LL_TIM_OC_SetCompareCH1(TIMx, (us_time + TIMx->CNT) % 4000);
 800b86a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b86c:	1808      	adds	r0, r1, r0
 800b86e:	21fa      	movs	r1, #250	; 0xfa
 800b870:	0109      	lsls	r1, r1, #4
 800b872:	f7fa f92f 	bl	8005ad4 <__aeabi_uidivmod>
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx)
{
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
 800b876:	2303      	movs	r3, #3
  WRITE_REG(TIMx->CCR1, CompareValue);
 800b878:	6361      	str	r1, [r4, #52]	; 0x34
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx)
{
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
 800b87a:	425b      	negs	r3, r3
 800b87c:	6123      	str	r3, [r4, #16]
      LL_TIM_ClearFlag_CC4(TIMx);
      break;
    default:
      break;
  }
}
 800b87e:	bd10      	pop	{r4, pc}
      LL_TIM_OC_SetCompareCH2(TIMx, (us_time + TIMx->CNT) % 4000);
 800b880:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b882:	1808      	adds	r0, r1, r0
 800b884:	21fa      	movs	r1, #250	; 0xfa
 800b886:	0109      	lsls	r1, r1, #4
 800b888:	f7fa f924 	bl	8005ad4 <__aeabi_uidivmod>
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC2IF));
 800b88c:	2305      	movs	r3, #5
  WRITE_REG(TIMx->CCR2, CompareValue);
 800b88e:	63a1      	str	r1, [r4, #56]	; 0x38
 800b890:	e7f3      	b.n	800b87a <USBPD_TIM_Start+0x22>
      LL_TIM_OC_SetCompareCH3(TIMx, (us_time + TIMx->CNT) % 4000);
 800b892:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b894:	1808      	adds	r0, r1, r0
 800b896:	21fa      	movs	r1, #250	; 0xfa
 800b898:	0109      	lsls	r1, r1, #4
 800b89a:	f7fa f91b 	bl	8005ad4 <__aeabi_uidivmod>
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC3IF));
 800b89e:	2309      	movs	r3, #9
  WRITE_REG(TIMx->CCR3, CompareValue);
 800b8a0:	63e1      	str	r1, [r4, #60]	; 0x3c
 800b8a2:	e7ea      	b.n	800b87a <USBPD_TIM_Start+0x22>
      LL_TIM_OC_SetCompareCH4(TIMx, (us_time + TIMx->CNT) % 4000);
 800b8a4:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b8a6:	1808      	adds	r0, r1, r0
 800b8a8:	21fa      	movs	r1, #250	; 0xfa
 800b8aa:	0109      	lsls	r1, r1, #4
 800b8ac:	f7fa f912 	bl	8005ad4 <__aeabi_uidivmod>
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
 800b8b0:	2311      	movs	r3, #17
  WRITE_REG(TIMx->CCR4, CompareValue);
 800b8b2:	6421      	str	r1, [r4, #64]	; 0x40
 800b8b4:	e7e1      	b.n	800b87a <USBPD_TIM_Start+0x22>

0800b8b6 <USBPD_TIM_IsExpired>:
  * @brief  Retrieve the TIMERSERVER status for a specified id
  * @param  id Timer Operation Identifier
  * @retval State of bit (1 or 0).
  */
uint8_t USBPD_TIM_IsExpired(TIM_identifier id)
{
 800b8b6:	b500      	push	{lr}
    case TIM_PORT1_RETRY:
      return LL_TIM_IsActiveFlag_CC4(TIMx);
    default:
      break;
  }
  return 1;
 800b8b8:	2301      	movs	r3, #1
  switch (id)
 800b8ba:	2803      	cmp	r0, #3
 800b8bc:	d808      	bhi.n	800b8d0 <USBPD_TIM_IsExpired+0x1a>
 800b8be:	2280      	movs	r2, #128	; 0x80
 800b8c0:	05d2      	lsls	r2, r2, #23
  * @param  TIMx Timer instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx)
{
  return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
 800b8c2:	6912      	ldr	r2, [r2, #16]
 800b8c4:	f7fa f876 	bl	80059b4 <__gnu_thumb1_case_uqi>
 800b8c8:	0a080602 	.word	0x0a080602
  return (READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF));
 800b8cc:	0852      	lsrs	r2, r2, #1
      return LL_TIM_IsActiveFlag_CC4(TIMx);
 800b8ce:	4013      	ands	r3, r2
}
 800b8d0:	0018      	movs	r0, r3
 800b8d2:	bd00      	pop	{pc}
  return (READ_BIT(TIMx->SR, TIM_SR_CC2IF) == (TIM_SR_CC2IF));
 800b8d4:	0892      	lsrs	r2, r2, #2
 800b8d6:	e7fa      	b.n	800b8ce <USBPD_TIM_IsExpired+0x18>
  return (READ_BIT(TIMx->SR, TIM_SR_CC3IF) == (TIM_SR_CC3IF));
 800b8d8:	08d2      	lsrs	r2, r2, #3
 800b8da:	e7f8      	b.n	800b8ce <USBPD_TIM_IsExpired+0x18>
  return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
 800b8dc:	0912      	lsrs	r2, r2, #4
 800b8de:	e7f6      	b.n	800b8ce <USBPD_TIM_IsExpired+0x18>

0800b8e0 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 800b8e0:	b510      	push	{r4, lr}
  vTaskStartScheduler();
 800b8e2:	f000 fc67 	bl	800c1b4 <vTaskStartScheduler>
  
  return osOK;
}
 800b8e6:	2000      	movs	r0, #0
 800b8e8:	bd10      	pop	{r4, pc}

0800b8ea <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 800b8ea:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b8ec:	6902      	ldr	r2, [r0, #16]
{
 800b8ee:	000b      	movs	r3, r1
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b8f0:	6846      	ldr	r6, [r0, #4]
 800b8f2:	6801      	ldr	r1, [r0, #0]
 800b8f4:	2508      	movs	r5, #8
 800b8f6:	5f45      	ldrsh	r5, [r0, r5]
 800b8f8:	b292      	uxth	r2, r2
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 800b8fa:	2400      	movs	r4, #0
  if (priority != osPriorityError) {
 800b8fc:	2d84      	cmp	r5, #132	; 0x84
 800b8fe:	d000      	beq.n	800b902 <osThreadCreate+0x18>
    fpriority += (priority - osPriorityIdle);
 800b900:	1cec      	adds	r4, r5, #3
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b902:	a803      	add	r0, sp, #12
 800b904:	9001      	str	r0, [sp, #4]
 800b906:	9400      	str	r4, [sp, #0]
 800b908:	0030      	movs	r0, r6
 800b90a:	f000 fb63 	bl	800bfd4 <xTaskCreate>
                   thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
                   &handle) != pdPASS)  {
    return NULL;
 800b90e:	2300      	movs	r3, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b910:	2801      	cmp	r0, #1
 800b912:	d100      	bne.n	800b916 <osThreadCreate+0x2c>
  }     
#endif
  
  return handle;
 800b914:	9b03      	ldr	r3, [sp, #12]
}
 800b916:	0018      	movs	r0, r3
 800b918:	b004      	add	sp, #16
 800b91a:	bd70      	pop	{r4, r5, r6, pc}

0800b91c <osThreadTerminate>:
* @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osThreadTerminate shall be consistent in every CMSIS-RTOS.
*/
osStatus osThreadTerminate (osThreadId thread_id)
{
 800b91c:	b510      	push	{r4, lr}
#if (INCLUDE_vTaskDelete == 1)
  vTaskDelete(thread_id);
 800b91e:	f000 fc07 	bl	800c130 <vTaskDelete>
  return osOK;
#else
  return osErrorOS;
#endif
}
 800b922:	2000      	movs	r0, #0
 800b924:	bd10      	pop	{r4, pc}

0800b926 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 800b926:	b510      	push	{r4, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 800b928:	2800      	cmp	r0, #0
 800b92a:	d100      	bne.n	800b92e <osDelay+0x8>
 800b92c:	3001      	adds	r0, #1
 800b92e:	f000 fd31 	bl	800c394 <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 800b932:	2000      	movs	r0, #0
 800b934:	bd10      	pop	{r4, pc}

0800b936 <osMessageCreate>:
* @param  thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval  message queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS.
*/
osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
{
 800b936:	b510      	push	{r4, lr}
    return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
  }
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
#else  
  return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
 800b938:	6841      	ldr	r1, [r0, #4]
 800b93a:	2200      	movs	r2, #0
 800b93c:	6800      	ldr	r0, [r0, #0]
 800b93e:	f000 f94f 	bl	800bbe0 <xQueueGenericCreate>
#endif
}
 800b942:	bd10      	pop	{r4, pc}

0800b944 <osMessagePut>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
*/
osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
 800b944:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  portBASE_TYPE taskWoken = pdFALSE;
 800b946:	2300      	movs	r3, #0
{
 800b948:	9101      	str	r1, [sp, #4]
  portBASE_TYPE taskWoken = pdFALSE;
 800b94a:	9303      	str	r3, [sp, #12]
  TickType_t ticks;
  
  ticks = millisec / portTICK_PERIOD_MS;
  if (ticks == 0) {
 800b94c:	429a      	cmp	r2, r3
 800b94e:	d100      	bne.n	800b952 <osMessagePut+0xe>
    ticks = 1;
 800b950:	2201      	movs	r2, #1
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b952:	f3ef 8305 	mrs	r3, IPSR
  }
  
  if (inHandlerMode()) {
 800b956:	2b00      	cmp	r3, #0
 800b958:	d012      	beq.n	800b980 <osMessagePut+0x3c>
    if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
 800b95a:	2300      	movs	r3, #0
 800b95c:	aa03      	add	r2, sp, #12
 800b95e:	a901      	add	r1, sp, #4
 800b960:	f000 f9e3 	bl	800bd2a <xQueueGenericSendFromISR>
 800b964:	2801      	cmp	r0, #1
 800b966:	d002      	beq.n	800b96e <osMessagePut+0x2a>
      return osErrorOS;
 800b968:	20ff      	movs	r0, #255	; 0xff
      return osErrorOS;
    }
  }
  
  return osOK;
}
 800b96a:	b005      	add	sp, #20
 800b96c:	bd00      	pop	{pc}
    portEND_SWITCHING_ISR(taskWoken);
 800b96e:	9b03      	ldr	r3, [sp, #12]
 800b970:	2b00      	cmp	r3, #0
 800b972:	d003      	beq.n	800b97c <osMessagePut+0x38>
 800b974:	2280      	movs	r2, #128	; 0x80
 800b976:	4b05      	ldr	r3, [pc, #20]	; (800b98c <osMessagePut+0x48>)
 800b978:	0552      	lsls	r2, r2, #21
 800b97a:	601a      	str	r2, [r3, #0]
  return osOK;
 800b97c:	2000      	movs	r0, #0
 800b97e:	e7f4      	b.n	800b96a <osMessagePut+0x26>
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
 800b980:	a901      	add	r1, sp, #4
 800b982:	f000 f94a 	bl	800bc1a <xQueueGenericSend>
 800b986:	2801      	cmp	r0, #1
 800b988:	d0f8      	beq.n	800b97c <osMessagePut+0x38>
 800b98a:	e7ed      	b.n	800b968 <osMessagePut+0x24>
 800b98c:	e000ed04 	.word	0xe000ed04

0800b990 <osMessageGet>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval event information that includes status code.
* @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
*/
osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
{
 800b990:	b5f0      	push	{r4, r5, r6, r7, lr}
  portBASE_TYPE taskWoken;
  TickType_t ticks;
  osEvent event;
  
  event.def.message_id = queue_id;
  event.value.v = 0;
 800b992:	2700      	movs	r7, #0
{
 800b994:	b085      	sub	sp, #20
  event.def.message_id = queue_id;
 800b996:	ac01      	add	r4, sp, #4
{
 800b998:	0005      	movs	r5, r0
 800b99a:	0016      	movs	r6, r2
 800b99c:	0008      	movs	r0, r1
  event.def.message_id = queue_id;
 800b99e:	60a1      	str	r1, [r4, #8]
  event.value.v = 0;
 800b9a0:	6067      	str	r7, [r4, #4]
  
  if (queue_id == NULL) {
 800b9a2:	42b9      	cmp	r1, r7
 800b9a4:	d107      	bne.n	800b9b6 <osMessageGet+0x26>
    event.status = osErrorParameter;
 800b9a6:	2380      	movs	r3, #128	; 0x80
 800b9a8:	9301      	str	r3, [sp, #4]
    else {
      event.status = (ticks == 0) ? osOK : osEventTimeout;
    }
  }
  
  return event;
 800b9aa:	002b      	movs	r3, r5
 800b9ac:	cc07      	ldmia	r4!, {r0, r1, r2}
 800b9ae:	c307      	stmia	r3!, {r0, r1, r2}
}
 800b9b0:	0028      	movs	r0, r5
 800b9b2:	b005      	add	sp, #20
 800b9b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  taskWoken = pdFALSE;
 800b9b6:	9700      	str	r7, [sp, #0]
 800b9b8:	f3ef 8305 	mrs	r3, IPSR
  if (inHandlerMode()) {
 800b9bc:	2b00      	cmp	r3, #0
 800b9be:	d011      	beq.n	800b9e4 <osMessageGet+0x54>
    if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
 800b9c0:	466a      	mov	r2, sp
 800b9c2:	a902      	add	r1, sp, #8
 800b9c4:	f000 fa8a 	bl	800bedc <xQueueReceiveFromISR>
 800b9c8:	2801      	cmp	r0, #1
 800b9ca:	d109      	bne.n	800b9e0 <osMessageGet+0x50>
      event.status = osEventMessage;
 800b9cc:	2310      	movs	r3, #16
 800b9ce:	6023      	str	r3, [r4, #0]
    portEND_SWITCHING_ISR(taskWoken);
 800b9d0:	9b00      	ldr	r3, [sp, #0]
 800b9d2:	2b00      	cmp	r3, #0
 800b9d4:	d0e9      	beq.n	800b9aa <osMessageGet+0x1a>
 800b9d6:	2280      	movs	r2, #128	; 0x80
 800b9d8:	4b09      	ldr	r3, [pc, #36]	; (800ba00 <osMessageGet+0x70>)
 800b9da:	0552      	lsls	r2, r2, #21
 800b9dc:	601a      	str	r2, [r3, #0]
 800b9de:	e7e4      	b.n	800b9aa <osMessageGet+0x1a>
      event.status = osOK;
 800b9e0:	6027      	str	r7, [r4, #0]
 800b9e2:	e7f5      	b.n	800b9d0 <osMessageGet+0x40>
    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
 800b9e4:	a902      	add	r1, sp, #8
 800b9e6:	f000 f9e9 	bl	800bdbc <xQueueGenericReceive>
 800b9ea:	2801      	cmp	r0, #1
 800b9ec:	d102      	bne.n	800b9f4 <osMessageGet+0x64>
      event.status = osEventMessage;
 800b9ee:	2310      	movs	r3, #16
 800b9f0:	6023      	str	r3, [r4, #0]
 800b9f2:	e7da      	b.n	800b9aa <osMessageGet+0x1a>
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 800b9f4:	1e73      	subs	r3, r6, #1
 800b9f6:	419e      	sbcs	r6, r3
 800b9f8:	01b6      	lsls	r6, r6, #6
 800b9fa:	9601      	str	r6, [sp, #4]
 800b9fc:	e7d5      	b.n	800b9aa <osMessageGet+0x1a>
 800b9fe:	46c0      	nop			; (mov r8, r8)
 800ba00:	e000ed04 	.word	0xe000ed04

0800ba04 <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 800ba04:	b510      	push	{r4, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
  {
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
 800ba06:	f000 ff0d 	bl	800c824 <xPortSysTickHandler>
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 800ba0a:	bd10      	pop	{r4, pc}

0800ba0c <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800ba0c:	0003      	movs	r3, r0

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800ba0e:	2201      	movs	r2, #1
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800ba10:	3308      	adds	r3, #8
 800ba12:	6043      	str	r3, [r0, #4]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800ba14:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800ba16:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800ba18:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800ba1a:	4252      	negs	r2, r2
 800ba1c:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800ba1e:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800ba20:	4770      	bx	lr

0800ba22 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 800ba22:	2300      	movs	r3, #0
 800ba24:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 800ba26:	4770      	bx	lr

0800ba28 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 800ba28:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800ba2a:	689a      	ldr	r2, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 800ba2c:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800ba2e:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800ba30:	689a      	ldr	r2, [r3, #8]
 800ba32:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800ba34:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800ba36:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800ba38:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800ba3a:	3301      	adds	r3, #1
 800ba3c:	6003      	str	r3, [r0, #0]
}
 800ba3e:	4770      	bx	lr

0800ba40 <vListInsert>:
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800ba40:	0003      	movs	r3, r0
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800ba42:	680a      	ldr	r2, [r1, #0]
{
 800ba44:	b530      	push	{r4, r5, lr}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800ba46:	3308      	adds	r3, #8
	if( xValueOfInsertion == portMAX_DELAY )
 800ba48:	1c54      	adds	r4, r2, #1
 800ba4a:	d10b      	bne.n	800ba64 <vListInsert+0x24>
		pxIterator = pxList->xListEnd.pxPrevious;
 800ba4c:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800ba4e:	685a      	ldr	r2, [r3, #4]
 800ba50:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 800ba52:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 800ba54:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 800ba56:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800ba58:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800ba5a:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800ba5c:	3301      	adds	r3, #1
 800ba5e:	6003      	str	r3, [r0, #0]
}
 800ba60:	bd30      	pop	{r4, r5, pc}
 800ba62:	0023      	movs	r3, r4
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800ba64:	685c      	ldr	r4, [r3, #4]
 800ba66:	6825      	ldr	r5, [r4, #0]
 800ba68:	4295      	cmp	r5, r2
 800ba6a:	d9fa      	bls.n	800ba62 <vListInsert+0x22>
 800ba6c:	e7ef      	b.n	800ba4e <vListInsert+0xe>

0800ba6e <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800ba6e:	6841      	ldr	r1, [r0, #4]
 800ba70:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 800ba72:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800ba74:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800ba76:	6882      	ldr	r2, [r0, #8]
 800ba78:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800ba7a:	6859      	ldr	r1, [r3, #4]
 800ba7c:	4281      	cmp	r1, r0
 800ba7e:	d100      	bne.n	800ba82 <uxListRemove+0x14>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800ba80:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 800ba82:	2200      	movs	r2, #0
 800ba84:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 800ba86:	681a      	ldr	r2, [r3, #0]
 800ba88:	1e50      	subs	r0, r2, #1
 800ba8a:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 800ba8c:	4770      	bx	lr

0800ba8e <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 800ba8e:	b570      	push	{r4, r5, r6, lr}
 800ba90:	0016      	movs	r6, r2

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800ba92:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
 800ba94:	0004      	movs	r4, r0
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800ba96:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800ba98:	2a00      	cmp	r2, #0
 800ba9a:	d00d      	beq.n	800bab8 <prvCopyDataToQueue+0x2a>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 800ba9c:	2e00      	cmp	r6, #0
 800ba9e:	d10f      	bne.n	800bac0 <prvCopyDataToQueue+0x32>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 800baa0:	6880      	ldr	r0, [r0, #8]
 800baa2:	f001 f803 	bl	800caac <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800baa6:	68a3      	ldr	r3, [r4, #8]
 800baa8:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800baaa:	189b      	adds	r3, r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800baac:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800baae:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800bab0:	4293      	cmp	r3, r2
 800bab2:	d301      	bcc.n	800bab8 <prvCopyDataToQueue+0x2a>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800bab4:	6823      	ldr	r3, [r4, #0]
 800bab6:	60a3      	str	r3, [r4, #8]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 800bab8:	3501      	adds	r5, #1
 800baba:	63a5      	str	r5, [r4, #56]	; 0x38

	return xReturn;
}
 800babc:	2000      	movs	r0, #0
 800babe:	bd70      	pop	{r4, r5, r6, pc}
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bac0:	68c0      	ldr	r0, [r0, #12]
 800bac2:	f000 fff3 	bl	800caac <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800bac6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800bac8:	68e2      	ldr	r2, [r4, #12]
 800baca:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800bacc:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800bace:	18d2      	adds	r2, r2, r3
 800bad0:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800bad2:	428a      	cmp	r2, r1
 800bad4:	d202      	bcs.n	800badc <prvCopyDataToQueue+0x4e>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 800bad6:	6862      	ldr	r2, [r4, #4]
 800bad8:	18d3      	adds	r3, r2, r3
 800bada:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 800badc:	2e02      	cmp	r6, #2
 800bade:	d1eb      	bne.n	800bab8 <prvCopyDataToQueue+0x2a>
				--uxMessagesWaiting;
 800bae0:	002b      	movs	r3, r5
 800bae2:	1e5a      	subs	r2, r3, #1
 800bae4:	4193      	sbcs	r3, r2
 800bae6:	1aed      	subs	r5, r5, r3
 800bae8:	e7e6      	b.n	800bab8 <prvCopyDataToQueue+0x2a>

0800baea <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 800baea:	0003      	movs	r3, r0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800baec:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
 800baee:	b510      	push	{r4, lr}
 800baf0:	0008      	movs	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800baf2:	2a00      	cmp	r2, #0
 800baf4:	d00a      	beq.n	800bb0c <prvCopyDataFromQueue+0x22>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800baf6:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800baf8:	685c      	ldr	r4, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800bafa:	1889      	adds	r1, r1, r2
 800bafc:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800bafe:	42a1      	cmp	r1, r4
 800bb00:	d301      	bcc.n	800bb06 <prvCopyDataFromQueue+0x1c>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 800bb02:	6819      	ldr	r1, [r3, #0]
 800bb04:	60d9      	str	r1, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 800bb06:	68d9      	ldr	r1, [r3, #12]
 800bb08:	f000 ffd0 	bl	800caac <memcpy>
	}
}
 800bb0c:	bd10      	pop	{r4, pc}

0800bb0e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 800bb0e:	b570      	push	{r4, r5, r6, lr}
 800bb10:	0005      	movs	r5, r0
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;
 800bb12:	002e      	movs	r6, r5
 800bb14:	3645      	adds	r6, #69	; 0x45
	taskENTER_CRITICAL();
 800bb16:	f000 fe3b 	bl	800c790 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 800bb1a:	7834      	ldrb	r4, [r6, #0]
 800bb1c:	b264      	sxtb	r4, r4

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800bb1e:	2c00      	cmp	r4, #0
 800bb20:	dc10      	bgt.n	800bb44 <prvUnlockQueue+0x36>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 800bb22:	23ff      	movs	r3, #255	; 0xff
 800bb24:	7033      	strb	r3, [r6, #0]
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;
 800bb26:	002e      	movs	r6, r5
 800bb28:	3644      	adds	r6, #68	; 0x44
	taskEXIT_CRITICAL();
 800bb2a:	f000 fe3d 	bl	800c7a8 <vPortExitCritical>
	taskENTER_CRITICAL();
 800bb2e:	f000 fe2f 	bl	800c790 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 800bb32:	7834      	ldrb	r4, [r6, #0]
 800bb34:	b264      	sxtb	r4, r4

		while( cRxLock > queueLOCKED_UNMODIFIED )
 800bb36:	2c00      	cmp	r4, #0
 800bb38:	dc11      	bgt.n	800bb5e <prvUnlockQueue+0x50>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 800bb3a:	23ff      	movs	r3, #255	; 0xff
 800bb3c:	7033      	strb	r3, [r6, #0]
	}
	taskEXIT_CRITICAL();
 800bb3e:	f000 fe33 	bl	800c7a8 <vPortExitCritical>
}
 800bb42:	bd70      	pop	{r4, r5, r6, pc}
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800bb44:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800bb46:	2b00      	cmp	r3, #0
 800bb48:	d0eb      	beq.n	800bb22 <prvUnlockQueue+0x14>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800bb4a:	0028      	movs	r0, r5
 800bb4c:	3024      	adds	r0, #36	; 0x24
 800bb4e:	f000 fcad 	bl	800c4ac <xTaskRemoveFromEventList>
 800bb52:	2800      	cmp	r0, #0
 800bb54:	d001      	beq.n	800bb5a <prvUnlockQueue+0x4c>
						vTaskMissedYield();
 800bb56:	f000 fd1d 	bl	800c594 <vTaskMissedYield>
 800bb5a:	3c01      	subs	r4, #1
 800bb5c:	e7de      	b.n	800bb1c <prvUnlockQueue+0xe>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800bb5e:	692b      	ldr	r3, [r5, #16]
 800bb60:	2b00      	cmp	r3, #0
 800bb62:	d0ea      	beq.n	800bb3a <prvUnlockQueue+0x2c>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800bb64:	0028      	movs	r0, r5
 800bb66:	3010      	adds	r0, #16
 800bb68:	f000 fca0 	bl	800c4ac <xTaskRemoveFromEventList>
 800bb6c:	2800      	cmp	r0, #0
 800bb6e:	d001      	beq.n	800bb74 <prvUnlockQueue+0x66>
					vTaskMissedYield();
 800bb70:	f000 fd10 	bl	800c594 <vTaskMissedYield>
 800bb74:	3c01      	subs	r4, #1
 800bb76:	e7dd      	b.n	800bb34 <prvUnlockQueue+0x26>

0800bb78 <xQueueGenericReset>:
{
 800bb78:	b570      	push	{r4, r5, r6, lr}
 800bb7a:	0004      	movs	r4, r0
 800bb7c:	000d      	movs	r5, r1
	configASSERT( pxQueue );
 800bb7e:	2800      	cmp	r0, #0
 800bb80:	d101      	bne.n	800bb86 <xQueueGenericReset+0xe>
 800bb82:	b672      	cpsid	i
 800bb84:	e7fe      	b.n	800bb84 <xQueueGenericReset+0xc>
	taskENTER_CRITICAL();
 800bb86:	f000 fe03 	bl	800c790 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800bb8a:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800bb8c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800bb8e:	6822      	ldr	r2, [r4, #0]
 800bb90:	434b      	muls	r3, r1
 800bb92:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 800bb94:	1a5b      	subs	r3, r3, r1
 800bb96:	18d3      	adds	r3, r2, r3
 800bb98:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 800bb9a:	0023      	movs	r3, r4
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800bb9c:	6060      	str	r0, [r4, #4]
		pxQueue->pcWriteTo = pxQueue->pcHead;
 800bb9e:	60a2      	str	r2, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800bba0:	2000      	movs	r0, #0
		pxQueue->cRxLock = queueUNLOCKED;
 800bba2:	22ff      	movs	r2, #255	; 0xff
 800bba4:	3344      	adds	r3, #68	; 0x44
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800bba6:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 800bba8:	701a      	strb	r2, [r3, #0]
		pxQueue->cTxLock = queueUNLOCKED;
 800bbaa:	705a      	strb	r2, [r3, #1]
		if( xNewQueue == pdFALSE )
 800bbac:	4285      	cmp	r5, r0
 800bbae:	d10e      	bne.n	800bbce <xQueueGenericReset+0x56>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800bbb0:	6923      	ldr	r3, [r4, #16]
 800bbb2:	4283      	cmp	r3, r0
 800bbb4:	d007      	beq.n	800bbc6 <xQueueGenericReset+0x4e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800bbb6:	0020      	movs	r0, r4
 800bbb8:	3010      	adds	r0, #16
 800bbba:	f000 fc77 	bl	800c4ac <xTaskRemoveFromEventList>
 800bbbe:	2800      	cmp	r0, #0
 800bbc0:	d001      	beq.n	800bbc6 <xQueueGenericReset+0x4e>
					queueYIELD_IF_USING_PREEMPTION();
 800bbc2:	f000 fdd9 	bl	800c778 <vPortYield>
	taskEXIT_CRITICAL();
 800bbc6:	f000 fdef 	bl	800c7a8 <vPortExitCritical>
}
 800bbca:	2001      	movs	r0, #1
 800bbcc:	bd70      	pop	{r4, r5, r6, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800bbce:	0020      	movs	r0, r4
 800bbd0:	3010      	adds	r0, #16
 800bbd2:	f7ff ff1b 	bl	800ba0c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 800bbd6:	0020      	movs	r0, r4
 800bbd8:	3024      	adds	r0, #36	; 0x24
 800bbda:	f7ff ff17 	bl	800ba0c <vListInitialise>
 800bbde:	e7f2      	b.n	800bbc6 <xQueueGenericReset+0x4e>

0800bbe0 <xQueueGenericCreate>:
	{
 800bbe0:	b570      	push	{r4, r5, r6, lr}
 800bbe2:	0006      	movs	r6, r0
 800bbe4:	000d      	movs	r5, r1
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 800bbe6:	2800      	cmp	r0, #0
 800bbe8:	d101      	bne.n	800bbee <xQueueGenericCreate+0xe>
 800bbea:	b672      	cpsid	i
 800bbec:	e7fe      	b.n	800bbec <xQueueGenericCreate+0xc>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bbee:	0008      	movs	r0, r1
 800bbf0:	4370      	muls	r0, r6
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 800bbf2:	3048      	adds	r0, #72	; 0x48
 800bbf4:	f000 fcf6 	bl	800c5e4 <pvPortMalloc>
 800bbf8:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
 800bbfa:	d008      	beq.n	800bc0e <xQueueGenericCreate+0x2e>
	if( uxItemSize == ( UBaseType_t ) 0 )
 800bbfc:	2d00      	cmp	r5, #0
 800bbfe:	d108      	bne.n	800bc12 <xQueueGenericCreate+0x32>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800bc00:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 800bc02:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 800bc04:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800bc06:	2101      	movs	r1, #1
 800bc08:	0020      	movs	r0, r4
 800bc0a:	f7ff ffb5 	bl	800bb78 <xQueueGenericReset>
	}
 800bc0e:	0020      	movs	r0, r4
 800bc10:	bd70      	pop	{r4, r5, r6, pc}
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 800bc12:	0003      	movs	r3, r0
 800bc14:	3348      	adds	r3, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 800bc16:	6003      	str	r3, [r0, #0]
 800bc18:	e7f3      	b.n	800bc02 <xQueueGenericCreate+0x22>

0800bc1a <xQueueGenericSend>:
{
 800bc1a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bc1c:	b085      	sub	sp, #20
 800bc1e:	0004      	movs	r4, r0
 800bc20:	000f      	movs	r7, r1
 800bc22:	9201      	str	r2, [sp, #4]
 800bc24:	001e      	movs	r6, r3
	configASSERT( pxQueue );
 800bc26:	2800      	cmp	r0, #0
 800bc28:	d101      	bne.n	800bc2e <xQueueGenericSend+0x14>
 800bc2a:	b672      	cpsid	i
 800bc2c:	e7fe      	b.n	800bc2c <xQueueGenericSend+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800bc2e:	2900      	cmp	r1, #0
 800bc30:	d104      	bne.n	800bc3c <xQueueGenericSend+0x22>
 800bc32:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800bc34:	2b00      	cmp	r3, #0
 800bc36:	d001      	beq.n	800bc3c <xQueueGenericSend+0x22>
 800bc38:	b672      	cpsid	i
 800bc3a:	e7fe      	b.n	800bc3a <xQueueGenericSend+0x20>
 800bc3c:	2300      	movs	r3, #0
 800bc3e:	9300      	str	r3, [sp, #0]
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800bc40:	2e02      	cmp	r6, #2
 800bc42:	d14f      	bne.n	800bce4 <xQueueGenericSend+0xca>
 800bc44:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800bc46:	2b01      	cmp	r3, #1
 800bc48:	d04c      	beq.n	800bce4 <xQueueGenericSend+0xca>
 800bc4a:	b672      	cpsid	i
 800bc4c:	e7fe      	b.n	800bc4c <xQueueGenericSend+0x32>
				if( xTicksToWait == ( TickType_t ) 0 )
 800bc4e:	9d01      	ldr	r5, [sp, #4]
 800bc50:	2d00      	cmp	r5, #0
 800bc52:	d103      	bne.n	800bc5c <xQueueGenericSend+0x42>
					taskEXIT_CRITICAL();
 800bc54:	f000 fda8 	bl	800c7a8 <vPortExitCritical>
			return errQUEUE_FULL;
 800bc58:	2000      	movs	r0, #0
 800bc5a:	e05e      	b.n	800bd1a <xQueueGenericSend+0x100>
				else if( xEntryTimeSet == pdFALSE )
 800bc5c:	9b00      	ldr	r3, [sp, #0]
 800bc5e:	2b00      	cmp	r3, #0
 800bc60:	d102      	bne.n	800bc68 <xQueueGenericSend+0x4e>
					vTaskSetTimeOutState( &xTimeOut );
 800bc62:	a802      	add	r0, sp, #8
 800bc64:	f000 fc56 	bl	800c514 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 800bc68:	f000 fd9e 	bl	800c7a8 <vPortExitCritical>
		vTaskSuspendAll();
 800bc6c:	f000 fac6 	bl	800c1fc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800bc70:	f000 fd8e 	bl	800c790 <vPortEnterCritical>
 800bc74:	0022      	movs	r2, r4
 800bc76:	3244      	adds	r2, #68	; 0x44
 800bc78:	7813      	ldrb	r3, [r2, #0]
 800bc7a:	b25b      	sxtb	r3, r3
 800bc7c:	3301      	adds	r3, #1
 800bc7e:	d101      	bne.n	800bc84 <xQueueGenericSend+0x6a>
 800bc80:	2300      	movs	r3, #0
 800bc82:	7013      	strb	r3, [r2, #0]
 800bc84:	0022      	movs	r2, r4
 800bc86:	3245      	adds	r2, #69	; 0x45
 800bc88:	7813      	ldrb	r3, [r2, #0]
 800bc8a:	b25b      	sxtb	r3, r3
 800bc8c:	3301      	adds	r3, #1
 800bc8e:	d101      	bne.n	800bc94 <xQueueGenericSend+0x7a>
 800bc90:	2300      	movs	r3, #0
 800bc92:	7013      	strb	r3, [r2, #0]
 800bc94:	f000 fd88 	bl	800c7a8 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800bc98:	a901      	add	r1, sp, #4
 800bc9a:	a802      	add	r0, sp, #8
 800bc9c:	f000 fc4a 	bl	800c534 <xTaskCheckForTimeOut>
 800bca0:	2800      	cmp	r0, #0
 800bca2:	d13c      	bne.n	800bd1e <xQueueGenericSend+0x104>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 800bca4:	f000 fd74 	bl	800c790 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800bca8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bcaa:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800bcac:	4293      	cmp	r3, r2
 800bcae:	d110      	bne.n	800bcd2 <xQueueGenericSend+0xb8>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800bcb0:	f000 fd7a 	bl	800c7a8 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800bcb4:	0020      	movs	r0, r4
 800bcb6:	9901      	ldr	r1, [sp, #4]
 800bcb8:	3010      	adds	r0, #16
 800bcba:	f000 fbe5 	bl	800c488 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800bcbe:	0020      	movs	r0, r4
 800bcc0:	f7ff ff25 	bl	800bb0e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800bcc4:	f000 fb0e 	bl	800c2e4 <xTaskResumeAll>
 800bcc8:	2800      	cmp	r0, #0
 800bcca:	d109      	bne.n	800bce0 <xQueueGenericSend+0xc6>
					portYIELD_WITHIN_API();
 800bccc:	f000 fd54 	bl	800c778 <vPortYield>
 800bcd0:	e006      	b.n	800bce0 <xQueueGenericSend+0xc6>
	taskEXIT_CRITICAL();
 800bcd2:	f000 fd69 	bl	800c7a8 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 800bcd6:	0020      	movs	r0, r4
 800bcd8:	f7ff ff19 	bl	800bb0e <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800bcdc:	f000 fb02 	bl	800c2e4 <xTaskResumeAll>
 800bce0:	2301      	movs	r3, #1
 800bce2:	9300      	str	r3, [sp, #0]
		taskENTER_CRITICAL();
 800bce4:	f000 fd54 	bl	800c790 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800bce8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bcea:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800bcec:	4293      	cmp	r3, r2
 800bcee:	d301      	bcc.n	800bcf4 <xQueueGenericSend+0xda>
 800bcf0:	2e02      	cmp	r6, #2
 800bcf2:	d1ac      	bne.n	800bc4e <xQueueGenericSend+0x34>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800bcf4:	0032      	movs	r2, r6
 800bcf6:	0039      	movs	r1, r7
 800bcf8:	0020      	movs	r0, r4
 800bcfa:	f7ff fec8 	bl	800ba8e <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800bcfe:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800bd00:	2b00      	cmp	r3, #0
 800bd02:	d003      	beq.n	800bd0c <xQueueGenericSend+0xf2>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800bd04:	0020      	movs	r0, r4
 800bd06:	3024      	adds	r0, #36	; 0x24
 800bd08:	f000 fbd0 	bl	800c4ac <xTaskRemoveFromEventList>
 800bd0c:	2800      	cmp	r0, #0
 800bd0e:	d001      	beq.n	800bd14 <xQueueGenericSend+0xfa>
							queueYIELD_IF_USING_PREEMPTION();
 800bd10:	f000 fd32 	bl	800c778 <vPortYield>
				taskEXIT_CRITICAL();
 800bd14:	f000 fd48 	bl	800c7a8 <vPortExitCritical>
				return pdPASS;
 800bd18:	2001      	movs	r0, #1
}
 800bd1a:	b005      	add	sp, #20
 800bd1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
			prvUnlockQueue( pxQueue );
 800bd1e:	0020      	movs	r0, r4
 800bd20:	f7ff fef5 	bl	800bb0e <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800bd24:	f000 fade 	bl	800c2e4 <xTaskResumeAll>
 800bd28:	e796      	b.n	800bc58 <xQueueGenericSend+0x3e>

0800bd2a <xQueueGenericSendFromISR>:
{
 800bd2a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bd2c:	b085      	sub	sp, #20
 800bd2e:	0004      	movs	r4, r0
 800bd30:	9101      	str	r1, [sp, #4]
 800bd32:	0017      	movs	r7, r2
 800bd34:	001e      	movs	r6, r3
	configASSERT( pxQueue );
 800bd36:	2800      	cmp	r0, #0
 800bd38:	d101      	bne.n	800bd3e <xQueueGenericSendFromISR+0x14>
 800bd3a:	b672      	cpsid	i
 800bd3c:	e7fe      	b.n	800bd3c <xQueueGenericSendFromISR+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800bd3e:	9b01      	ldr	r3, [sp, #4]
 800bd40:	2b00      	cmp	r3, #0
 800bd42:	d104      	bne.n	800bd4e <xQueueGenericSendFromISR+0x24>
 800bd44:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800bd46:	2b00      	cmp	r3, #0
 800bd48:	d001      	beq.n	800bd4e <xQueueGenericSendFromISR+0x24>
 800bd4a:	b672      	cpsid	i
 800bd4c:	e7fe      	b.n	800bd4c <xQueueGenericSendFromISR+0x22>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800bd4e:	2e02      	cmp	r6, #2
 800bd50:	d104      	bne.n	800bd5c <xQueueGenericSendFromISR+0x32>
 800bd52:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800bd54:	2b01      	cmp	r3, #1
 800bd56:	d001      	beq.n	800bd5c <xQueueGenericSendFromISR+0x32>
 800bd58:	b672      	cpsid	i
 800bd5a:	e7fe      	b.n	800bd5a <xQueueGenericSendFromISR+0x30>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800bd5c:	f000 fd32 	bl	800c7c4 <ulSetInterruptMaskFromISR>
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800bd60:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bd62:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800bd64:	9003      	str	r0, [sp, #12]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800bd66:	4293      	cmp	r3, r2
 800bd68:	d302      	bcc.n	800bd70 <xQueueGenericSendFromISR+0x46>
			xReturn = errQUEUE_FULL;
 800bd6a:	2500      	movs	r5, #0
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800bd6c:	2e02      	cmp	r6, #2
 800bd6e:	d11a      	bne.n	800bda6 <xQueueGenericSendFromISR+0x7c>
			const int8_t cTxLock = pxQueue->cTxLock;
 800bd70:	0023      	movs	r3, r4
 800bd72:	3345      	adds	r3, #69	; 0x45
 800bd74:	9302      	str	r3, [sp, #8]
 800bd76:	781d      	ldrb	r5, [r3, #0]
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800bd78:	0032      	movs	r2, r6
			const int8_t cTxLock = pxQueue->cTxLock;
 800bd7a:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800bd7c:	9901      	ldr	r1, [sp, #4]
 800bd7e:	0020      	movs	r0, r4
 800bd80:	f7ff fe85 	bl	800ba8e <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 800bd84:	1c6b      	adds	r3, r5, #1
 800bd86:	d114      	bne.n	800bdb2 <xQueueGenericSendFromISR+0x88>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800bd88:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800bd8a:	2b00      	cmp	r3, #0
 800bd8c:	d101      	bne.n	800bd92 <xQueueGenericSendFromISR+0x68>
			xReturn = pdPASS;
 800bd8e:	2501      	movs	r5, #1
 800bd90:	e009      	b.n	800bda6 <xQueueGenericSendFromISR+0x7c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800bd92:	0020      	movs	r0, r4
 800bd94:	3024      	adds	r0, #36	; 0x24
 800bd96:	f000 fb89 	bl	800c4ac <xTaskRemoveFromEventList>
 800bd9a:	2800      	cmp	r0, #0
 800bd9c:	d0f7      	beq.n	800bd8e <xQueueGenericSendFromISR+0x64>
							if( pxHigherPriorityTaskWoken != NULL )
 800bd9e:	2f00      	cmp	r7, #0
 800bda0:	d0f5      	beq.n	800bd8e <xQueueGenericSendFromISR+0x64>
								*pxHigherPriorityTaskWoken = pdTRUE;
 800bda2:	2501      	movs	r5, #1
 800bda4:	603d      	str	r5, [r7, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800bda6:	9803      	ldr	r0, [sp, #12]
 800bda8:	f000 fd11 	bl	800c7ce <vClearInterruptMaskFromISR>
}
 800bdac:	0028      	movs	r0, r5
 800bdae:	b005      	add	sp, #20
 800bdb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800bdb2:	3501      	adds	r5, #1
 800bdb4:	9b02      	ldr	r3, [sp, #8]
 800bdb6:	b26d      	sxtb	r5, r5
 800bdb8:	701d      	strb	r5, [r3, #0]
 800bdba:	e7e8      	b.n	800bd8e <xQueueGenericSendFromISR+0x64>

0800bdbc <xQueueGenericReceive>:
{
 800bdbc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bdbe:	b085      	sub	sp, #20
 800bdc0:	0004      	movs	r4, r0
 800bdc2:	000e      	movs	r6, r1
 800bdc4:	9201      	str	r2, [sp, #4]
 800bdc6:	9300      	str	r3, [sp, #0]
	configASSERT( pxQueue );
 800bdc8:	2800      	cmp	r0, #0
 800bdca:	d101      	bne.n	800bdd0 <xQueueGenericReceive+0x14>
 800bdcc:	b672      	cpsid	i
 800bdce:	e7fe      	b.n	800bdce <xQueueGenericReceive+0x12>
 800bdd0:	2700      	movs	r7, #0
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800bdd2:	42b9      	cmp	r1, r7
 800bdd4:	d155      	bne.n	800be82 <xQueueGenericReceive+0xc6>
 800bdd6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800bdd8:	42bb      	cmp	r3, r7
 800bdda:	d001      	beq.n	800bde0 <xQueueGenericReceive+0x24>
 800bddc:	b672      	cpsid	i
 800bdde:	e7fe      	b.n	800bdde <xQueueGenericReceive+0x22>
 800bde0:	000f      	movs	r7, r1
 800bde2:	e04e      	b.n	800be82 <xQueueGenericReceive+0xc6>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800bde4:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 800bde6:	60e7      	str	r7, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800bde8:	2b00      	cmp	r3, #0
 800bdea:	d064      	beq.n	800beb6 <xQueueGenericReceive+0xfa>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800bdec:	0020      	movs	r0, r4
 800bdee:	3024      	adds	r0, #36	; 0x24
 800bdf0:	e05b      	b.n	800beaa <xQueueGenericReceive+0xee>
				if( xTicksToWait == ( TickType_t ) 0 )
 800bdf2:	9b01      	ldr	r3, [sp, #4]
 800bdf4:	2b00      	cmp	r3, #0
 800bdf6:	d103      	bne.n	800be00 <xQueueGenericReceive+0x44>
					taskEXIT_CRITICAL();
 800bdf8:	f000 fcd6 	bl	800c7a8 <vPortExitCritical>
					return errQUEUE_EMPTY;
 800bdfc:	2000      	movs	r0, #0
 800bdfe:	e05d      	b.n	800bebc <xQueueGenericReceive+0x100>
				else if( xEntryTimeSet == pdFALSE )
 800be00:	2f00      	cmp	r7, #0
 800be02:	d102      	bne.n	800be0a <xQueueGenericReceive+0x4e>
					vTaskSetTimeOutState( &xTimeOut );
 800be04:	a802      	add	r0, sp, #8
 800be06:	f000 fb85 	bl	800c514 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 800be0a:	f000 fccd 	bl	800c7a8 <vPortExitCritical>
		vTaskSuspendAll();
 800be0e:	f000 f9f5 	bl	800c1fc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800be12:	f000 fcbd 	bl	800c790 <vPortEnterCritical>
 800be16:	0022      	movs	r2, r4
 800be18:	3244      	adds	r2, #68	; 0x44
 800be1a:	7813      	ldrb	r3, [r2, #0]
 800be1c:	b25b      	sxtb	r3, r3
 800be1e:	3301      	adds	r3, #1
 800be20:	d101      	bne.n	800be26 <xQueueGenericReceive+0x6a>
 800be22:	2300      	movs	r3, #0
 800be24:	7013      	strb	r3, [r2, #0]
 800be26:	0022      	movs	r2, r4
 800be28:	3245      	adds	r2, #69	; 0x45
 800be2a:	7813      	ldrb	r3, [r2, #0]
 800be2c:	b25b      	sxtb	r3, r3
 800be2e:	3301      	adds	r3, #1
 800be30:	d101      	bne.n	800be36 <xQueueGenericReceive+0x7a>
 800be32:	2300      	movs	r3, #0
 800be34:	7013      	strb	r3, [r2, #0]
 800be36:	f000 fcb7 	bl	800c7a8 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800be3a:	a901      	add	r1, sp, #4
 800be3c:	a802      	add	r0, sp, #8
 800be3e:	f000 fb79 	bl	800c534 <xTaskCheckForTimeOut>
 800be42:	2800      	cmp	r0, #0
 800be44:	d13c      	bne.n	800bec0 <xQueueGenericReceive+0x104>
	taskENTER_CRITICAL();
 800be46:	f000 fca3 	bl	800c790 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800be4a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800be4c:	2b00      	cmp	r3, #0
 800be4e:	d110      	bne.n	800be72 <xQueueGenericReceive+0xb6>
	taskEXIT_CRITICAL();
 800be50:	f000 fcaa 	bl	800c7a8 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800be54:	0020      	movs	r0, r4
 800be56:	9901      	ldr	r1, [sp, #4]
 800be58:	3024      	adds	r0, #36	; 0x24
 800be5a:	f000 fb15 	bl	800c488 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800be5e:	0020      	movs	r0, r4
 800be60:	f7ff fe55 	bl	800bb0e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800be64:	f000 fa3e 	bl	800c2e4 <xTaskResumeAll>
 800be68:	2800      	cmp	r0, #0
 800be6a:	d109      	bne.n	800be80 <xQueueGenericReceive+0xc4>
					portYIELD_WITHIN_API();
 800be6c:	f000 fc84 	bl	800c778 <vPortYield>
 800be70:	e006      	b.n	800be80 <xQueueGenericReceive+0xc4>
	taskEXIT_CRITICAL();
 800be72:	f000 fc99 	bl	800c7a8 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 800be76:	0020      	movs	r0, r4
 800be78:	f7ff fe49 	bl	800bb0e <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800be7c:	f000 fa32 	bl	800c2e4 <xTaskResumeAll>
 800be80:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
 800be82:	f000 fc85 	bl	800c790 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800be86:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800be88:	2d00      	cmp	r5, #0
 800be8a:	d0b2      	beq.n	800bdf2 <xQueueGenericReceive+0x36>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800be8c:	0031      	movs	r1, r6
 800be8e:	0020      	movs	r0, r4
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 800be90:	68e7      	ldr	r7, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800be92:	f7ff fe2a 	bl	800baea <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
 800be96:	9b00      	ldr	r3, [sp, #0]
 800be98:	2b00      	cmp	r3, #0
 800be9a:	d1a3      	bne.n	800bde4 <xQueueGenericReceive+0x28>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800be9c:	6923      	ldr	r3, [r4, #16]
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 800be9e:	3d01      	subs	r5, #1
 800bea0:	63a5      	str	r5, [r4, #56]	; 0x38
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800bea2:	2b00      	cmp	r3, #0
 800bea4:	d007      	beq.n	800beb6 <xQueueGenericReceive+0xfa>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800bea6:	0020      	movs	r0, r4
 800bea8:	3010      	adds	r0, #16
 800beaa:	f000 faff 	bl	800c4ac <xTaskRemoveFromEventList>
 800beae:	2800      	cmp	r0, #0
 800beb0:	d001      	beq.n	800beb6 <xQueueGenericReceive+0xfa>
							queueYIELD_IF_USING_PREEMPTION();
 800beb2:	f000 fc61 	bl	800c778 <vPortYield>
				taskEXIT_CRITICAL();
 800beb6:	f000 fc77 	bl	800c7a8 <vPortExitCritical>
				return pdPASS;
 800beba:	2001      	movs	r0, #1
}
 800bebc:	b005      	add	sp, #20
 800bebe:	bdf0      	pop	{r4, r5, r6, r7, pc}
			prvUnlockQueue( pxQueue );
 800bec0:	0020      	movs	r0, r4
 800bec2:	f7ff fe24 	bl	800bb0e <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800bec6:	f000 fa0d 	bl	800c2e4 <xTaskResumeAll>
	taskENTER_CRITICAL();
 800beca:	f000 fc61 	bl	800c790 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800bece:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bed0:	2b00      	cmp	r3, #0
 800bed2:	d100      	bne.n	800bed6 <xQueueGenericReceive+0x11a>
 800bed4:	e790      	b.n	800bdf8 <xQueueGenericReceive+0x3c>
	taskEXIT_CRITICAL();
 800bed6:	f000 fc67 	bl	800c7a8 <vPortExitCritical>
 800beda:	e7d1      	b.n	800be80 <xQueueGenericReceive+0xc4>

0800bedc <xQueueReceiveFromISR>:
{
 800bedc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bede:	b085      	sub	sp, #20
 800bee0:	0004      	movs	r4, r0
 800bee2:	9102      	str	r1, [sp, #8]
 800bee4:	0016      	movs	r6, r2
	configASSERT( pxQueue );
 800bee6:	2800      	cmp	r0, #0
 800bee8:	d101      	bne.n	800beee <xQueueReceiveFromISR+0x12>
 800beea:	b672      	cpsid	i
 800beec:	e7fe      	b.n	800beec <xQueueReceiveFromISR+0x10>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800beee:	9b02      	ldr	r3, [sp, #8]
 800bef0:	2b00      	cmp	r3, #0
 800bef2:	d104      	bne.n	800befe <xQueueReceiveFromISR+0x22>
 800bef4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800bef6:	2b00      	cmp	r3, #0
 800bef8:	d001      	beq.n	800befe <xQueueReceiveFromISR+0x22>
 800befa:	b672      	cpsid	i
 800befc:	e7fe      	b.n	800befc <xQueueReceiveFromISR+0x20>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800befe:	f000 fc61 	bl	800c7c4 <ulSetInterruptMaskFromISR>
			xReturn = pdFAIL;
 800bf02:	2500      	movs	r5, #0
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800bf04:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800bf06:	9003      	str	r0, [sp, #12]
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800bf08:	9301      	str	r3, [sp, #4]
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800bf0a:	42ab      	cmp	r3, r5
 800bf0c:	d01b      	beq.n	800bf46 <xQueueReceiveFromISR+0x6a>
			const int8_t cRxLock = pxQueue->cRxLock;
 800bf0e:	0027      	movs	r7, r4
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800bf10:	9902      	ldr	r1, [sp, #8]
			const int8_t cRxLock = pxQueue->cRxLock;
 800bf12:	3744      	adds	r7, #68	; 0x44
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800bf14:	0020      	movs	r0, r4
			const int8_t cRxLock = pxQueue->cRxLock;
 800bf16:	783d      	ldrb	r5, [r7, #0]
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800bf18:	f7ff fde7 	bl	800baea <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 800bf1c:	9b01      	ldr	r3, [sp, #4]
			const int8_t cRxLock = pxQueue->cRxLock;
 800bf1e:	b26d      	sxtb	r5, r5
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 800bf20:	3b01      	subs	r3, #1
 800bf22:	63a3      	str	r3, [r4, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 800bf24:	1c6b      	adds	r3, r5, #1
 800bf26:	d114      	bne.n	800bf52 <xQueueReceiveFromISR+0x76>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800bf28:	6923      	ldr	r3, [r4, #16]
 800bf2a:	2b00      	cmp	r3, #0
 800bf2c:	d101      	bne.n	800bf32 <xQueueReceiveFromISR+0x56>
			xReturn = pdPASS;
 800bf2e:	2501      	movs	r5, #1
 800bf30:	e009      	b.n	800bf46 <xQueueReceiveFromISR+0x6a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800bf32:	0020      	movs	r0, r4
 800bf34:	3010      	adds	r0, #16
 800bf36:	f000 fab9 	bl	800c4ac <xTaskRemoveFromEventList>
 800bf3a:	2800      	cmp	r0, #0
 800bf3c:	d0f7      	beq.n	800bf2e <xQueueReceiveFromISR+0x52>
						if( pxHigherPriorityTaskWoken != NULL )
 800bf3e:	2e00      	cmp	r6, #0
 800bf40:	d0f5      	beq.n	800bf2e <xQueueReceiveFromISR+0x52>
							*pxHigherPriorityTaskWoken = pdTRUE;
 800bf42:	2501      	movs	r5, #1
 800bf44:	6035      	str	r5, [r6, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800bf46:	9803      	ldr	r0, [sp, #12]
 800bf48:	f000 fc41 	bl	800c7ce <vClearInterruptMaskFromISR>
}
 800bf4c:	0028      	movs	r0, r5
 800bf4e:	b005      	add	sp, #20
 800bf50:	bdf0      	pop	{r4, r5, r6, r7, pc}
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 800bf52:	3501      	adds	r5, #1
 800bf54:	b26d      	sxtb	r5, r5
 800bf56:	703d      	strb	r5, [r7, #0]
 800bf58:	e7e9      	b.n	800bf2e <xQueueReceiveFromISR+0x52>
	...

0800bf5c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800bf5c:	4b06      	ldr	r3, [pc, #24]	; (800bf78 <prvResetNextTaskUnblockTime+0x1c>)
 800bf5e:	681a      	ldr	r2, [r3, #0]
 800bf60:	6812      	ldr	r2, [r2, #0]
 800bf62:	2a00      	cmp	r2, #0
 800bf64:	d102      	bne.n	800bf6c <prvResetNextTaskUnblockTime+0x10>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 800bf66:	3a01      	subs	r2, #1
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800bf68:	605a      	str	r2, [r3, #4]
	}
}
 800bf6a:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800bf6c:	681a      	ldr	r2, [r3, #0]
 800bf6e:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800bf70:	68d2      	ldr	r2, [r2, #12]
 800bf72:	6852      	ldr	r2, [r2, #4]
 800bf74:	e7f8      	b.n	800bf68 <prvResetNextTaskUnblockTime+0xc>
 800bf76:	46c0      	nop			; (mov r8, r8)
 800bf78:	200003e4 	.word	0x200003e4

0800bf7c <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 800bf7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800bf7e:	0005      	movs	r5, r0
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 800bf80:	4c13      	ldr	r4, [pc, #76]	; (800bfd0 <prvAddCurrentTaskToDelayedList+0x54>)
{
 800bf82:	000f      	movs	r7, r1
const TickType_t xConstTickCount = xTickCount;
 800bf84:	68a6      	ldr	r6, [r4, #8]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800bf86:	68e0      	ldr	r0, [r4, #12]
 800bf88:	3004      	adds	r0, #4
 800bf8a:	f7ff fd70 	bl	800ba6e <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800bf8e:	1c6b      	adds	r3, r5, #1
 800bf90:	d108      	bne.n	800bfa4 <prvAddCurrentTaskToDelayedList+0x28>
 800bf92:	2f00      	cmp	r7, #0
 800bf94:	d006      	beq.n	800bfa4 <prvAddCurrentTaskToDelayedList+0x28>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800bf96:	0020      	movs	r0, r4
 800bf98:	68e1      	ldr	r1, [r4, #12]
 800bf9a:	3010      	adds	r0, #16
 800bf9c:	3104      	adds	r1, #4
 800bf9e:	f7ff fd43 	bl	800ba28 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 800bfa2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800bfa4:	68e3      	ldr	r3, [r4, #12]
			xTimeToWake = xConstTickCount + xTicksToWait;
 800bfa6:	1975      	adds	r5, r6, r5
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800bfa8:	605d      	str	r5, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 800bfaa:	42ae      	cmp	r6, r5
 800bfac:	d905      	bls.n	800bfba <prvAddCurrentTaskToDelayedList+0x3e>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800bfae:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800bfb0:	68e1      	ldr	r1, [r4, #12]
 800bfb2:	3104      	adds	r1, #4
 800bfb4:	f7ff fd44 	bl	800ba40 <vListInsert>
 800bfb8:	e7f3      	b.n	800bfa2 <prvAddCurrentTaskToDelayedList+0x26>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800bfba:	6820      	ldr	r0, [r4, #0]
 800bfbc:	68e1      	ldr	r1, [r4, #12]
 800bfbe:	3104      	adds	r1, #4
 800bfc0:	f7ff fd3e 	bl	800ba40 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 800bfc4:	6863      	ldr	r3, [r4, #4]
 800bfc6:	42ab      	cmp	r3, r5
 800bfc8:	d9eb      	bls.n	800bfa2 <prvAddCurrentTaskToDelayedList+0x26>
					xNextTaskUnblockTime = xTimeToWake;
 800bfca:	6065      	str	r5, [r4, #4]
}
 800bfcc:	e7e9      	b.n	800bfa2 <prvAddCurrentTaskToDelayedList+0x26>
 800bfce:	46c0      	nop			; (mov r8, r8)
 800bfd0:	200003e4 	.word	0x200003e4

0800bfd4 <xTaskCreate>:
	{
 800bfd4:	b5f0      	push	{r4, r5, r6, r7, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bfd6:	0095      	lsls	r5, r2, #2
	{
 800bfd8:	b085      	sub	sp, #20
 800bfda:	9002      	str	r0, [sp, #8]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bfdc:	0028      	movs	r0, r5
	{
 800bfde:	000f      	movs	r7, r1
 800bfe0:	9303      	str	r3, [sp, #12]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bfe2:	f000 faff 	bl	800c5e4 <pvPortMalloc>
 800bfe6:	1e06      	subs	r6, r0, #0
			if( pxStack != NULL )
 800bfe8:	d100      	bne.n	800bfec <xTaskCreate+0x18>
 800bfea:	e08b      	b.n	800c104 <xTaskCreate+0x130>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 800bfec:	204c      	movs	r0, #76	; 0x4c
 800bfee:	f000 faf9 	bl	800c5e4 <pvPortMalloc>
 800bff2:	1e04      	subs	r4, r0, #0
				if( pxNewTCB != NULL )
 800bff4:	d100      	bne.n	800bff8 <xTaskCreate+0x24>
 800bff6:	e082      	b.n	800c0fe <xTaskCreate+0x12a>
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800bff8:	2307      	movs	r3, #7
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800bffa:	3d04      	subs	r5, #4
					pxNewTCB->pxStack = pxStack;
 800bffc:	6306      	str	r6, [r0, #48]	; 0x30
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800bffe:	1976      	adds	r6, r6, r5
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800c000:	439e      	bics	r6, r3
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800c002:	2300      	movs	r3, #0
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800c004:	9601      	str	r6, [sp, #4]
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800c006:	001a      	movs	r2, r3
 800c008:	5cf9      	ldrb	r1, [r7, r3]
 800c00a:	3234      	adds	r2, #52	; 0x34
 800c00c:	54a1      	strb	r1, [r4, r2]
		if( pcName[ x ] == 0x00 )
 800c00e:	5cfa      	ldrb	r2, [r7, r3]
 800c010:	2a00      	cmp	r2, #0
 800c012:	d002      	beq.n	800c01a <xTaskCreate+0x46>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800c014:	3301      	adds	r3, #1
 800c016:	2b10      	cmp	r3, #16
 800c018:	d1f5      	bne.n	800c006 <xTaskCreate+0x32>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800c01a:	0023      	movs	r3, r4
 800c01c:	2200      	movs	r2, #0
 800c01e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 800c020:	3343      	adds	r3, #67	; 0x43
 800c022:	701a      	strb	r2, [r3, #0]
 800c024:	2d06      	cmp	r5, #6
 800c026:	d900      	bls.n	800c02a <xTaskCreate+0x56>
 800c028:	2506      	movs	r5, #6
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800c02a:	1d26      	adds	r6, r4, #4
	pxNewTCB->uxPriority = uxPriority;
 800c02c:	62e5      	str	r5, [r4, #44]	; 0x2c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800c02e:	0030      	movs	r0, r6
 800c030:	f7ff fcf7 	bl	800ba22 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 800c034:	0020      	movs	r0, r4
 800c036:	3018      	adds	r0, #24
 800c038:	f7ff fcf3 	bl	800ba22 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c03c:	2307      	movs	r3, #7
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800c03e:	0022      	movs	r2, r4
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c040:	1b5d      	subs	r5, r3, r5
		pxNewTCB->ulNotifiedValue = 0;
 800c042:	2300      	movs	r3, #0
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800c044:	3248      	adds	r2, #72	; 0x48
		pxNewTCB->ulNotifiedValue = 0;
 800c046:	6463      	str	r3, [r4, #68]	; 0x44
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 800c048:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c04a:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800c04c:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800c04e:	9902      	ldr	r1, [sp, #8]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800c050:	7013      	strb	r3, [r2, #0]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800c052:	9801      	ldr	r0, [sp, #4]
 800c054:	9a03      	ldr	r2, [sp, #12]
 800c056:	f000 fb7d 	bl	800c754 <pxPortInitialiseStack>
	if( ( void * ) pxCreatedTask != NULL )
 800c05a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800c05c:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 800c05e:	2b00      	cmp	r3, #0
 800c060:	d000      	beq.n	800c064 <xTaskCreate+0x90>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 800c062:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
 800c064:	f000 fb94 	bl	800c790 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 800c068:	4d2d      	ldr	r5, [pc, #180]	; (800c120 <xTaskCreate+0x14c>)
 800c06a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800c06c:	3301      	adds	r3, #1
 800c06e:	62ab      	str	r3, [r5, #40]	; 0x28
		if( pxCurrentTCB == NULL )
 800c070:	68ef      	ldr	r7, [r5, #12]
 800c072:	2f00      	cmp	r7, #0
 800c074:	d149      	bne.n	800c10a <xTaskCreate+0x136>
			pxCurrentTCB = pxNewTCB;
 800c076:	60ec      	str	r4, [r5, #12]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800c078:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800c07a:	2b01      	cmp	r3, #1
 800c07c:	d11f      	bne.n	800c0be <xTaskCreate+0xea>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800c07e:	2014      	movs	r0, #20
 800c080:	4378      	muls	r0, r7
 800c082:	4b28      	ldr	r3, [pc, #160]	; (800c124 <xTaskCreate+0x150>)
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800c084:	3701      	adds	r7, #1
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800c086:	1818      	adds	r0, r3, r0
 800c088:	f7ff fcc0 	bl	800ba0c <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800c08c:	2f07      	cmp	r7, #7
 800c08e:	d1f6      	bne.n	800c07e <xTaskCreate+0xaa>
	vListInitialise( &xDelayedTaskList1 );
 800c090:	002f      	movs	r7, r5
 800c092:	372c      	adds	r7, #44	; 0x2c
 800c094:	0038      	movs	r0, r7
 800c096:	f7ff fcb9 	bl	800ba0c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800c09a:	4823      	ldr	r0, [pc, #140]	; (800c128 <xTaskCreate+0x154>)
 800c09c:	f7ff fcb6 	bl	800ba0c <vListInitialise>
	vListInitialise( &xPendingReadyList );
 800c0a0:	0028      	movs	r0, r5
 800c0a2:	3054      	adds	r0, #84	; 0x54
 800c0a4:	f7ff fcb2 	bl	800ba0c <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 800c0a8:	0028      	movs	r0, r5
 800c0aa:	3068      	adds	r0, #104	; 0x68
 800c0ac:	f7ff fcae 	bl	800ba0c <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 800c0b0:	0028      	movs	r0, r5
 800c0b2:	3010      	adds	r0, #16
 800c0b4:	f7ff fcaa 	bl	800ba0c <vListInitialise>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800c0b8:	4b1b      	ldr	r3, [pc, #108]	; (800c128 <xTaskCreate+0x154>)
	pxDelayedTaskList = &xDelayedTaskList1;
 800c0ba:	602f      	str	r7, [r5, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800c0bc:	626b      	str	r3, [r5, #36]	; 0x24
		uxTaskNumber++;
 800c0be:	4b1b      	ldr	r3, [pc, #108]	; (800c12c <xTaskCreate+0x158>)
 800c0c0:	681a      	ldr	r2, [r3, #0]
		prvAddTaskToReadyList( pxNewTCB );
 800c0c2:	6859      	ldr	r1, [r3, #4]
		uxTaskNumber++;
 800c0c4:	3201      	adds	r2, #1
 800c0c6:	601a      	str	r2, [r3, #0]
		prvAddTaskToReadyList( pxNewTCB );
 800c0c8:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800c0ca:	428a      	cmp	r2, r1
 800c0cc:	d900      	bls.n	800c0d0 <xTaskCreate+0xfc>
 800c0ce:	605a      	str	r2, [r3, #4]
 800c0d0:	2014      	movs	r0, #20
 800c0d2:	4350      	muls	r0, r2
 800c0d4:	4b13      	ldr	r3, [pc, #76]	; (800c124 <xTaskCreate+0x150>)
 800c0d6:	0031      	movs	r1, r6
 800c0d8:	1818      	adds	r0, r3, r0
 800c0da:	f7ff fca5 	bl	800ba28 <vListInsertEnd>
	taskEXIT_CRITICAL();
 800c0de:	f000 fb63 	bl	800c7a8 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 800c0e2:	6feb      	ldr	r3, [r5, #124]	; 0x7c
			xReturn = pdPASS;
 800c0e4:	2601      	movs	r6, #1
	if( xSchedulerRunning != pdFALSE )
 800c0e6:	2b00      	cmp	r3, #0
 800c0e8:	d006      	beq.n	800c0f8 <xTaskCreate+0x124>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800c0ea:	68eb      	ldr	r3, [r5, #12]
 800c0ec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c0ee:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800c0f0:	429a      	cmp	r2, r3
 800c0f2:	d201      	bcs.n	800c0f8 <xTaskCreate+0x124>
			taskYIELD_IF_USING_PREEMPTION();
 800c0f4:	f000 fb40 	bl	800c778 <vPortYield>
	}
 800c0f8:	0030      	movs	r0, r6
 800c0fa:	b005      	add	sp, #20
 800c0fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vPortFree( pxStack );
 800c0fe:	0030      	movs	r0, r6
 800c100:	f000 fae2 	bl	800c6c8 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800c104:	2601      	movs	r6, #1
 800c106:	4276      	negs	r6, r6
 800c108:	e7f6      	b.n	800c0f8 <xTaskCreate+0x124>
			if( xSchedulerRunning == pdFALSE )
 800c10a:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 800c10c:	2b00      	cmp	r3, #0
 800c10e:	d1d6      	bne.n	800c0be <xTaskCreate+0xea>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 800c110:	68eb      	ldr	r3, [r5, #12]
 800c112:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800c114:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c116:	4293      	cmp	r3, r2
 800c118:	d8d1      	bhi.n	800c0be <xTaskCreate+0xea>
					pxCurrentTCB = pxNewTCB;
 800c11a:	60ec      	str	r4, [r5, #12]
 800c11c:	e7cf      	b.n	800c0be <xTaskCreate+0xea>
 800c11e:	46c0      	nop			; (mov r8, r8)
 800c120:	200003e4 	.word	0x200003e4
 800c124:	20000484 	.word	0x20000484
 800c128:	20000424 	.word	0x20000424
 800c12c:	20000464 	.word	0x20000464

0800c130 <vTaskDelete>:
	{
 800c130:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c132:	0004      	movs	r4, r0
		taskENTER_CRITICAL();
 800c134:	f000 fb2c 	bl	800c790 <vPortEnterCritical>
 800c138:	4d1c      	ldr	r5, [pc, #112]	; (800c1ac <vTaskDelete+0x7c>)
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 800c13a:	2c00      	cmp	r4, #0
 800c13c:	d100      	bne.n	800c140 <vTaskDelete+0x10>
 800c13e:	68ec      	ldr	r4, [r5, #12]
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800c140:	1d27      	adds	r7, r4, #4
 800c142:	0038      	movs	r0, r7
 800c144:	f7ff fc93 	bl	800ba6e <uxListRemove>
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800c148:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800c14a:	2b00      	cmp	r3, #0
 800c14c:	d003      	beq.n	800c156 <vTaskDelete+0x26>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800c14e:	0020      	movs	r0, r4
 800c150:	3018      	adds	r0, #24
 800c152:	f7ff fc8c 	bl	800ba6e <uxListRemove>
			uxTaskNumber++;
 800c156:	4e16      	ldr	r6, [pc, #88]	; (800c1b0 <vTaskDelete+0x80>)
 800c158:	6833      	ldr	r3, [r6, #0]
 800c15a:	3301      	adds	r3, #1
 800c15c:	6033      	str	r3, [r6, #0]
			if( pxTCB == pxCurrentTCB )
 800c15e:	68eb      	ldr	r3, [r5, #12]
 800c160:	42a3      	cmp	r3, r4
 800c162:	d114      	bne.n	800c18e <vTaskDelete+0x5e>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 800c164:	0028      	movs	r0, r5
 800c166:	0039      	movs	r1, r7
 800c168:	3068      	adds	r0, #104	; 0x68
 800c16a:	f7ff fc5d 	bl	800ba28 <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
 800c16e:	68b3      	ldr	r3, [r6, #8]
 800c170:	3301      	adds	r3, #1
 800c172:	60b3      	str	r3, [r6, #8]
		taskEXIT_CRITICAL();
 800c174:	f000 fb18 	bl	800c7a8 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 800c178:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 800c17a:	2b00      	cmp	r3, #0
 800c17c:	d015      	beq.n	800c1aa <vTaskDelete+0x7a>
			if( pxTCB == pxCurrentTCB )
 800c17e:	68eb      	ldr	r3, [r5, #12]
 800c180:	42a3      	cmp	r3, r4
 800c182:	d112      	bne.n	800c1aa <vTaskDelete+0x7a>
				configASSERT( uxSchedulerSuspended == 0 );
 800c184:	68f3      	ldr	r3, [r6, #12]
 800c186:	2b00      	cmp	r3, #0
 800c188:	d00d      	beq.n	800c1a6 <vTaskDelete+0x76>
 800c18a:	b672      	cpsid	i
 800c18c:	e7fe      	b.n	800c18c <vTaskDelete+0x5c>
				--uxCurrentNumberOfTasks;
 800c18e:	6aab      	ldr	r3, [r5, #40]	; 0x28
			vPortFree( pxTCB->pxStack );
 800c190:	6b20      	ldr	r0, [r4, #48]	; 0x30
				--uxCurrentNumberOfTasks;
 800c192:	3b01      	subs	r3, #1
 800c194:	62ab      	str	r3, [r5, #40]	; 0x28
			vPortFree( pxTCB->pxStack );
 800c196:	f000 fa97 	bl	800c6c8 <vPortFree>
			vPortFree( pxTCB );
 800c19a:	0020      	movs	r0, r4
 800c19c:	f000 fa94 	bl	800c6c8 <vPortFree>
				prvResetNextTaskUnblockTime();
 800c1a0:	f7ff fedc 	bl	800bf5c <prvResetNextTaskUnblockTime>
 800c1a4:	e7e6      	b.n	800c174 <vTaskDelete+0x44>
				portYIELD_WITHIN_API();
 800c1a6:	f000 fae7 	bl	800c778 <vPortYield>
	}
 800c1aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c1ac:	200003e4 	.word	0x200003e4
 800c1b0:	20000464 	.word	0x20000464

0800c1b4 <vTaskStartScheduler>:
{
 800c1b4:	b513      	push	{r0, r1, r4, lr}
		xReturn = xTaskCreate(	prvIdleTask,
 800c1b6:	2400      	movs	r4, #0
 800c1b8:	4b0c      	ldr	r3, [pc, #48]	; (800c1ec <vTaskStartScheduler+0x38>)
 800c1ba:	9400      	str	r4, [sp, #0]
 800c1bc:	3310      	adds	r3, #16
 800c1be:	9301      	str	r3, [sp, #4]
 800c1c0:	2228      	movs	r2, #40	; 0x28
 800c1c2:	0023      	movs	r3, r4
 800c1c4:	490a      	ldr	r1, [pc, #40]	; (800c1f0 <vTaskStartScheduler+0x3c>)
 800c1c6:	480b      	ldr	r0, [pc, #44]	; (800c1f4 <vTaskStartScheduler+0x40>)
 800c1c8:	f7ff ff04 	bl	800bfd4 <xTaskCreate>
	if( xReturn == pdPASS )
 800c1cc:	2801      	cmp	r0, #1
 800c1ce:	d109      	bne.n	800c1e4 <vTaskStartScheduler+0x30>
		portDISABLE_INTERRUPTS();
 800c1d0:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
 800c1d2:	2201      	movs	r2, #1
 800c1d4:	4b08      	ldr	r3, [pc, #32]	; (800c1f8 <vTaskStartScheduler+0x44>)
 800c1d6:	4252      	negs	r2, r2
 800c1d8:	605a      	str	r2, [r3, #4]
		xSchedulerRunning = pdTRUE;
 800c1da:	67d8      	str	r0, [r3, #124]	; 0x7c
		xTickCount = ( TickType_t ) 0U;
 800c1dc:	609c      	str	r4, [r3, #8]
		if( xPortStartScheduler() != pdFALSE )
 800c1de:	f000 fb47 	bl	800c870 <xPortStartScheduler>
}
 800c1e2:	bd13      	pop	{r0, r1, r4, pc}
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 800c1e4:	1c43      	adds	r3, r0, #1
 800c1e6:	d1fc      	bne.n	800c1e2 <vTaskStartScheduler+0x2e>
 800c1e8:	b672      	cpsid	i
 800c1ea:	e7fe      	b.n	800c1ea <vTaskStartScheduler+0x36>
 800c1ec:	20000464 	.word	0x20000464
 800c1f0:	0800cdda 	.word	0x0800cdda
 800c1f4:	0800c3c9 	.word	0x0800c3c9
 800c1f8:	200003e4 	.word	0x200003e4

0800c1fc <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 800c1fc:	4a02      	ldr	r2, [pc, #8]	; (800c208 <vTaskSuspendAll+0xc>)
 800c1fe:	68d3      	ldr	r3, [r2, #12]
 800c200:	3301      	adds	r3, #1
 800c202:	60d3      	str	r3, [r2, #12]
}
 800c204:	4770      	bx	lr
 800c206:	46c0      	nop			; (mov r8, r8)
 800c208:	20000464 	.word	0x20000464

0800c20c <uxTaskGetNumberOfTasks>:
	return uxCurrentNumberOfTasks;
 800c20c:	4b01      	ldr	r3, [pc, #4]	; (800c214 <uxTaskGetNumberOfTasks+0x8>)
 800c20e:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
 800c210:	4770      	bx	lr
 800c212:	46c0      	nop			; (mov r8, r8)
 800c214:	200003e4 	.word	0x200003e4

0800c218 <xTaskIncrementTick>:
{
 800c218:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800c21a:	4d2f      	ldr	r5, [pc, #188]	; (800c2d8 <xTaskIncrementTick+0xc0>)
 800c21c:	68eb      	ldr	r3, [r5, #12]
 800c21e:	2b00      	cmp	r3, #0
 800c220:	d155      	bne.n	800c2ce <xTaskIncrementTick+0xb6>
		const TickType_t xConstTickCount = xTickCount + 1;
 800c222:	4c2e      	ldr	r4, [pc, #184]	; (800c2dc <xTaskIncrementTick+0xc4>)
 800c224:	68a3      	ldr	r3, [r4, #8]
 800c226:	3301      	adds	r3, #1
 800c228:	9300      	str	r3, [sp, #0]
		xTickCount = xConstTickCount;
 800c22a:	60a3      	str	r3, [r4, #8]
		if( xConstTickCount == ( TickType_t ) 0U )
 800c22c:	2b00      	cmp	r3, #0
 800c22e:	d10e      	bne.n	800c24e <xTaskIncrementTick+0x36>
			taskSWITCH_DELAYED_LISTS();
 800c230:	6823      	ldr	r3, [r4, #0]
 800c232:	681b      	ldr	r3, [r3, #0]
 800c234:	2b00      	cmp	r3, #0
 800c236:	d001      	beq.n	800c23c <xTaskIncrementTick+0x24>
 800c238:	b672      	cpsid	i
 800c23a:	e7fe      	b.n	800c23a <xTaskIncrementTick+0x22>
 800c23c:	6823      	ldr	r3, [r4, #0]
 800c23e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800c240:	6022      	str	r2, [r4, #0]
 800c242:	6263      	str	r3, [r4, #36]	; 0x24
 800c244:	696b      	ldr	r3, [r5, #20]
 800c246:	3301      	adds	r3, #1
 800c248:	616b      	str	r3, [r5, #20]
 800c24a:	f7ff fe87 	bl	800bf5c <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 800c24e:	6863      	ldr	r3, [r4, #4]
 800c250:	9a00      	ldr	r2, [sp, #0]
BaseType_t xSwitchRequired = pdFALSE;
 800c252:	2600      	movs	r6, #0
		if( xConstTickCount >= xNextTaskUnblockTime )
 800c254:	4293      	cmp	r3, r2
 800c256:	d933      	bls.n	800c2c0 <xTaskIncrementTick+0xa8>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800c258:	68e3      	ldr	r3, [r4, #12]
 800c25a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c25c:	2314      	movs	r3, #20
 800c25e:	4353      	muls	r3, r2
 800c260:	4a1f      	ldr	r2, [pc, #124]	; (800c2e0 <xTaskIncrementTick+0xc8>)
 800c262:	58d3      	ldr	r3, [r2, r3]
 800c264:	2b01      	cmp	r3, #1
 800c266:	d900      	bls.n	800c26a <xTaskIncrementTick+0x52>
				xSwitchRequired = pdTRUE;
 800c268:	2601      	movs	r6, #1
		if( xYieldPending != pdFALSE )
 800c26a:	69eb      	ldr	r3, [r5, #28]
 800c26c:	2b00      	cmp	r3, #0
 800c26e:	d000      	beq.n	800c272 <xTaskIncrementTick+0x5a>
			xSwitchRequired = pdTRUE;
 800c270:	2601      	movs	r6, #1
}
 800c272:	0030      	movs	r0, r6
 800c274:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800c276:	6823      	ldr	r3, [r4, #0]
					if( xConstTickCount < xItemValue )
 800c278:	9a00      	ldr	r2, [sp, #0]
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800c27a:	68db      	ldr	r3, [r3, #12]
 800c27c:	68df      	ldr	r7, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800c27e:	687b      	ldr	r3, [r7, #4]
					if( xConstTickCount < xItemValue )
 800c280:	429a      	cmp	r2, r3
 800c282:	d322      	bcc.n	800c2ca <xTaskIncrementTick+0xb2>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800c284:	1d3b      	adds	r3, r7, #4
 800c286:	0018      	movs	r0, r3
 800c288:	9301      	str	r3, [sp, #4]
 800c28a:	f7ff fbf0 	bl	800ba6e <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800c28e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c290:	2b00      	cmp	r3, #0
 800c292:	d003      	beq.n	800c29c <xTaskIncrementTick+0x84>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800c294:	0038      	movs	r0, r7
 800c296:	3018      	adds	r0, #24
 800c298:	f7ff fbe9 	bl	800ba6e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800c29c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c29e:	686b      	ldr	r3, [r5, #4]
 800c2a0:	4298      	cmp	r0, r3
 800c2a2:	d900      	bls.n	800c2a6 <xTaskIncrementTick+0x8e>
 800c2a4:	6068      	str	r0, [r5, #4]
 800c2a6:	2314      	movs	r3, #20
 800c2a8:	4358      	muls	r0, r3
 800c2aa:	4b0d      	ldr	r3, [pc, #52]	; (800c2e0 <xTaskIncrementTick+0xc8>)
 800c2ac:	1d39      	adds	r1, r7, #4
 800c2ae:	1818      	adds	r0, r3, r0
 800c2b0:	f7ff fbba 	bl	800ba28 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800c2b4:	68e3      	ldr	r3, [r4, #12]
 800c2b6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c2b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c2ba:	429a      	cmp	r2, r3
 800c2bc:	d300      	bcc.n	800c2c0 <xTaskIncrementTick+0xa8>
							xSwitchRequired = pdTRUE;
 800c2be:	2601      	movs	r6, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800c2c0:	6823      	ldr	r3, [r4, #0]
 800c2c2:	681b      	ldr	r3, [r3, #0]
 800c2c4:	2b00      	cmp	r3, #0
 800c2c6:	d1d6      	bne.n	800c276 <xTaskIncrementTick+0x5e>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c2c8:	3b01      	subs	r3, #1
						xNextTaskUnblockTime = xItemValue;
 800c2ca:	6063      	str	r3, [r4, #4]
						break;
 800c2cc:	e7c4      	b.n	800c258 <xTaskIncrementTick+0x40>
		++uxPendedTicks;
 800c2ce:	69ab      	ldr	r3, [r5, #24]
BaseType_t xSwitchRequired = pdFALSE;
 800c2d0:	2600      	movs	r6, #0
		++uxPendedTicks;
 800c2d2:	3301      	adds	r3, #1
 800c2d4:	61ab      	str	r3, [r5, #24]
 800c2d6:	e7c8      	b.n	800c26a <xTaskIncrementTick+0x52>
 800c2d8:	20000464 	.word	0x20000464
 800c2dc:	200003e4 	.word	0x200003e4
 800c2e0:	20000484 	.word	0x20000484

0800c2e4 <xTaskResumeAll>:
{
 800c2e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( uxSchedulerSuspended );
 800c2e6:	4c28      	ldr	r4, [pc, #160]	; (800c388 <xTaskResumeAll+0xa4>)
 800c2e8:	68e3      	ldr	r3, [r4, #12]
 800c2ea:	2b00      	cmp	r3, #0
 800c2ec:	d101      	bne.n	800c2f2 <xTaskResumeAll+0xe>
 800c2ee:	b672      	cpsid	i
 800c2f0:	e7fe      	b.n	800c2f0 <xTaskResumeAll+0xc>
	taskENTER_CRITICAL();
 800c2f2:	f000 fa4d 	bl	800c790 <vPortEnterCritical>
		--uxSchedulerSuspended;
 800c2f6:	68e3      	ldr	r3, [r4, #12]
 800c2f8:	3b01      	subs	r3, #1
 800c2fa:	60e3      	str	r3, [r4, #12]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800c2fc:	68e5      	ldr	r5, [r4, #12]
 800c2fe:	2d00      	cmp	r5, #0
 800c300:	d004      	beq.n	800c30c <xTaskResumeAll+0x28>
BaseType_t xAlreadyYielded = pdFALSE;
 800c302:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 800c304:	f000 fa50 	bl	800c7a8 <vPortExitCritical>
}
 800c308:	0020      	movs	r0, r4
 800c30a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800c30c:	4e1f      	ldr	r6, [pc, #124]	; (800c38c <xTaskResumeAll+0xa8>)
 800c30e:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800c310:	2b00      	cmp	r3, #0
 800c312:	d0f6      	beq.n	800c302 <xTaskResumeAll+0x1e>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800c314:	6d73      	ldr	r3, [r6, #84]	; 0x54
 800c316:	2b00      	cmp	r3, #0
 800c318:	d117      	bne.n	800c34a <xTaskResumeAll+0x66>
				if( pxTCB != NULL )
 800c31a:	2d00      	cmp	r5, #0
 800c31c:	d001      	beq.n	800c322 <xTaskResumeAll+0x3e>
					prvResetNextTaskUnblockTime();
 800c31e:	f7ff fe1d 	bl	800bf5c <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 800c322:	69a5      	ldr	r5, [r4, #24]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 800c324:	2d00      	cmp	r5, #0
 800c326:	d009      	beq.n	800c33c <xTaskResumeAll+0x58>
								xYieldPending = pdTRUE;
 800c328:	2601      	movs	r6, #1
							if( xTaskIncrementTick() != pdFALSE )
 800c32a:	f7ff ff75 	bl	800c218 <xTaskIncrementTick>
 800c32e:	2800      	cmp	r0, #0
 800c330:	d000      	beq.n	800c334 <xTaskResumeAll+0x50>
								xYieldPending = pdTRUE;
 800c332:	61e6      	str	r6, [r4, #28]
							--uxPendedCounts;
 800c334:	3d01      	subs	r5, #1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 800c336:	2d00      	cmp	r5, #0
 800c338:	d1f7      	bne.n	800c32a <xTaskResumeAll+0x46>
						uxPendedTicks = 0;
 800c33a:	61a5      	str	r5, [r4, #24]
				if( xYieldPending != pdFALSE )
 800c33c:	69e3      	ldr	r3, [r4, #28]
 800c33e:	2b00      	cmp	r3, #0
 800c340:	d0df      	beq.n	800c302 <xTaskResumeAll+0x1e>
					taskYIELD_IF_USING_PREEMPTION();
 800c342:	f000 fa19 	bl	800c778 <vPortYield>
						xAlreadyYielded = pdTRUE;
 800c346:	2401      	movs	r4, #1
 800c348:	e7dc      	b.n	800c304 <xTaskResumeAll+0x20>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 800c34a:	6e33      	ldr	r3, [r6, #96]	; 0x60
 800c34c:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800c34e:	0028      	movs	r0, r5
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800c350:	1d2f      	adds	r7, r5, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800c352:	3018      	adds	r0, #24
 800c354:	f7ff fb8b 	bl	800ba6e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800c358:	0038      	movs	r0, r7
 800c35a:	f7ff fb88 	bl	800ba6e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800c35e:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 800c360:	6863      	ldr	r3, [r4, #4]
 800c362:	4298      	cmp	r0, r3
 800c364:	d900      	bls.n	800c368 <xTaskResumeAll+0x84>
 800c366:	6060      	str	r0, [r4, #4]
 800c368:	2314      	movs	r3, #20
 800c36a:	4358      	muls	r0, r3
 800c36c:	4b08      	ldr	r3, [pc, #32]	; (800c390 <xTaskResumeAll+0xac>)
 800c36e:	0039      	movs	r1, r7
 800c370:	18c0      	adds	r0, r0, r3
 800c372:	f7ff fb59 	bl	800ba28 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800c376:	68f3      	ldr	r3, [r6, #12]
 800c378:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800c37a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c37c:	429a      	cmp	r2, r3
 800c37e:	d3c9      	bcc.n	800c314 <xTaskResumeAll+0x30>
						xYieldPending = pdTRUE;
 800c380:	2301      	movs	r3, #1
 800c382:	61e3      	str	r3, [r4, #28]
 800c384:	e7c6      	b.n	800c314 <xTaskResumeAll+0x30>
 800c386:	46c0      	nop			; (mov r8, r8)
 800c388:	20000464 	.word	0x20000464
 800c38c:	200003e4 	.word	0x200003e4
 800c390:	20000484 	.word	0x20000484

0800c394 <vTaskDelay>:
	{
 800c394:	b570      	push	{r4, r5, r6, lr}
 800c396:	1e04      	subs	r4, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
 800c398:	d102      	bne.n	800c3a0 <vTaskDelay+0xc>
			portYIELD_WITHIN_API();
 800c39a:	f000 f9ed 	bl	800c778 <vPortYield>
	}
 800c39e:	bd70      	pop	{r4, r5, r6, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 800c3a0:	4b08      	ldr	r3, [pc, #32]	; (800c3c4 <vTaskDelay+0x30>)
 800c3a2:	68dd      	ldr	r5, [r3, #12]
 800c3a4:	2d00      	cmp	r5, #0
 800c3a6:	d001      	beq.n	800c3ac <vTaskDelay+0x18>
 800c3a8:	b672      	cpsid	i
 800c3aa:	e7fe      	b.n	800c3aa <vTaskDelay+0x16>
			vTaskSuspendAll();
 800c3ac:	f7ff ff26 	bl	800c1fc <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 800c3b0:	0029      	movs	r1, r5
 800c3b2:	0020      	movs	r0, r4
 800c3b4:	f7ff fde2 	bl	800bf7c <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 800c3b8:	f7ff ff94 	bl	800c2e4 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 800c3bc:	2800      	cmp	r0, #0
 800c3be:	d0ec      	beq.n	800c39a <vTaskDelay+0x6>
 800c3c0:	e7ed      	b.n	800c39e <vTaskDelay+0xa>
 800c3c2:	46c0      	nop			; (mov r8, r8)
 800c3c4:	20000464 	.word	0x20000464

0800c3c8 <prvIdleTask>:
{
 800c3c8:	b570      	push	{r4, r5, r6, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800c3ca:	4d14      	ldr	r5, [pc, #80]	; (800c41c <prvIdleTask+0x54>)
 800c3cc:	68ab      	ldr	r3, [r5, #8]
 800c3ce:	2b00      	cmp	r3, #0
 800c3d0:	d106      	bne.n	800c3e0 <prvIdleTask+0x18>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800c3d2:	4b13      	ldr	r3, [pc, #76]	; (800c420 <prvIdleTask+0x58>)
 800c3d4:	681b      	ldr	r3, [r3, #0]
 800c3d6:	2b01      	cmp	r3, #1
 800c3d8:	d9f7      	bls.n	800c3ca <prvIdleTask+0x2>
				taskYIELD();
 800c3da:	f000 f9cd 	bl	800c778 <vPortYield>
 800c3de:	e7f4      	b.n	800c3ca <prvIdleTask+0x2>
			vTaskSuspendAll();
 800c3e0:	f7ff ff0c 	bl	800c1fc <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 800c3e4:	4c0f      	ldr	r4, [pc, #60]	; (800c424 <prvIdleTask+0x5c>)
 800c3e6:	6ea6      	ldr	r6, [r4, #104]	; 0x68
			( void ) xTaskResumeAll();
 800c3e8:	f7ff ff7c 	bl	800c2e4 <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 800c3ec:	2e00      	cmp	r6, #0
 800c3ee:	d0ec      	beq.n	800c3ca <prvIdleTask+0x2>
				taskENTER_CRITICAL();
 800c3f0:	f000 f9ce 	bl	800c790 <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 800c3f4:	6f63      	ldr	r3, [r4, #116]	; 0x74
 800c3f6:	68de      	ldr	r6, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800c3f8:	1d30      	adds	r0, r6, #4
 800c3fa:	f7ff fb38 	bl	800ba6e <uxListRemove>
					--uxCurrentNumberOfTasks;
 800c3fe:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800c400:	3b01      	subs	r3, #1
 800c402:	62a3      	str	r3, [r4, #40]	; 0x28
					--uxDeletedTasksWaitingCleanUp;
 800c404:	68ab      	ldr	r3, [r5, #8]
 800c406:	3b01      	subs	r3, #1
 800c408:	60ab      	str	r3, [r5, #8]
				taskEXIT_CRITICAL();
 800c40a:	f000 f9cd 	bl	800c7a8 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 800c40e:	6b30      	ldr	r0, [r6, #48]	; 0x30
 800c410:	f000 f95a 	bl	800c6c8 <vPortFree>
			vPortFree( pxTCB );
 800c414:	0030      	movs	r0, r6
 800c416:	f000 f957 	bl	800c6c8 <vPortFree>
 800c41a:	e7d6      	b.n	800c3ca <prvIdleTask+0x2>
 800c41c:	20000464 	.word	0x20000464
 800c420:	20000484 	.word	0x20000484
 800c424:	200003e4 	.word	0x200003e4

0800c428 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800c428:	4914      	ldr	r1, [pc, #80]	; (800c47c <vTaskSwitchContext+0x54>)
{
 800c42a:	b570      	push	{r4, r5, r6, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800c42c:	68cb      	ldr	r3, [r1, #12]
 800c42e:	2b00      	cmp	r3, #0
 800c430:	d002      	beq.n	800c438 <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
 800c432:	2301      	movs	r3, #1
 800c434:	61cb      	str	r3, [r1, #28]
}
 800c436:	bd70      	pop	{r4, r5, r6, pc}
 800c438:	2514      	movs	r5, #20
		xYieldPending = pdFALSE;
 800c43a:	61cb      	str	r3, [r1, #28]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800c43c:	684b      	ldr	r3, [r1, #4]
 800c43e:	4810      	ldr	r0, [pc, #64]	; (800c480 <vTaskSwitchContext+0x58>)
 800c440:	002a      	movs	r2, r5
 800c442:	435a      	muls	r2, r3
 800c444:	1814      	adds	r4, r2, r0
 800c446:	6826      	ldr	r6, [r4, #0]
 800c448:	2e00      	cmp	r6, #0
 800c44a:	d011      	beq.n	800c470 <vTaskSwitchContext+0x48>
 800c44c:	6865      	ldr	r5, [r4, #4]
 800c44e:	3208      	adds	r2, #8
 800c450:	686d      	ldr	r5, [r5, #4]
 800c452:	1812      	adds	r2, r2, r0
 800c454:	6065      	str	r5, [r4, #4]
 800c456:	4295      	cmp	r5, r2
 800c458:	d101      	bne.n	800c45e <vTaskSwitchContext+0x36>
 800c45a:	686a      	ldr	r2, [r5, #4]
 800c45c:	6062      	str	r2, [r4, #4]
 800c45e:	2214      	movs	r2, #20
 800c460:	435a      	muls	r2, r3
 800c462:	1880      	adds	r0, r0, r2
 800c464:	6842      	ldr	r2, [r0, #4]
 800c466:	68d0      	ldr	r0, [r2, #12]
 800c468:	4a06      	ldr	r2, [pc, #24]	; (800c484 <vTaskSwitchContext+0x5c>)
 800c46a:	60d0      	str	r0, [r2, #12]
 800c46c:	604b      	str	r3, [r1, #4]
}
 800c46e:	e7e2      	b.n	800c436 <vTaskSwitchContext+0xe>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800c470:	2b00      	cmp	r3, #0
 800c472:	d101      	bne.n	800c478 <vTaskSwitchContext+0x50>
 800c474:	b672      	cpsid	i
 800c476:	e7fe      	b.n	800c476 <vTaskSwitchContext+0x4e>
 800c478:	3b01      	subs	r3, #1
 800c47a:	e7e1      	b.n	800c440 <vTaskSwitchContext+0x18>
 800c47c:	20000464 	.word	0x20000464
 800c480:	20000484 	.word	0x20000484
 800c484:	200003e4 	.word	0x200003e4

0800c488 <vTaskPlaceOnEventList>:
{
 800c488:	b510      	push	{r4, lr}
 800c48a:	000c      	movs	r4, r1
	configASSERT( pxEventList );
 800c48c:	2800      	cmp	r0, #0
 800c48e:	d101      	bne.n	800c494 <vTaskPlaceOnEventList+0xc>
 800c490:	b672      	cpsid	i
 800c492:	e7fe      	b.n	800c492 <vTaskPlaceOnEventList+0xa>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800c494:	4b04      	ldr	r3, [pc, #16]	; (800c4a8 <vTaskPlaceOnEventList+0x20>)
 800c496:	68d9      	ldr	r1, [r3, #12]
 800c498:	3118      	adds	r1, #24
 800c49a:	f7ff fad1 	bl	800ba40 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800c49e:	2101      	movs	r1, #1
 800c4a0:	0020      	movs	r0, r4
 800c4a2:	f7ff fd6b 	bl	800bf7c <prvAddCurrentTaskToDelayedList>
}
 800c4a6:	bd10      	pop	{r4, pc}
 800c4a8:	200003e4 	.word	0x200003e4

0800c4ac <xTaskRemoveFromEventList>:
{
 800c4ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800c4ae:	68c3      	ldr	r3, [r0, #12]
 800c4b0:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 800c4b2:	2c00      	cmp	r4, #0
 800c4b4:	d101      	bne.n	800c4ba <xTaskRemoveFromEventList+0xe>
 800c4b6:	b672      	cpsid	i
 800c4b8:	e7fe      	b.n	800c4b8 <xTaskRemoveFromEventList+0xc>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800c4ba:	0027      	movs	r7, r4
 800c4bc:	3718      	adds	r7, #24
 800c4be:	0038      	movs	r0, r7
 800c4c0:	f7ff fad5 	bl	800ba6e <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800c4c4:	4d10      	ldr	r5, [pc, #64]	; (800c508 <xTaskRemoveFromEventList+0x5c>)
 800c4c6:	4e11      	ldr	r6, [pc, #68]	; (800c50c <xTaskRemoveFromEventList+0x60>)
 800c4c8:	68eb      	ldr	r3, [r5, #12]
 800c4ca:	2b00      	cmp	r3, #0
 800c4cc:	d118      	bne.n	800c500 <xTaskRemoveFromEventList+0x54>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800c4ce:	1d27      	adds	r7, r4, #4
 800c4d0:	0038      	movs	r0, r7
 800c4d2:	f7ff facc 	bl	800ba6e <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800c4d6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800c4d8:	686a      	ldr	r2, [r5, #4]
 800c4da:	4293      	cmp	r3, r2
 800c4dc:	d900      	bls.n	800c4e0 <xTaskRemoveFromEventList+0x34>
 800c4de:	606b      	str	r3, [r5, #4]
 800c4e0:	2014      	movs	r0, #20
 800c4e2:	4358      	muls	r0, r3
 800c4e4:	4b0a      	ldr	r3, [pc, #40]	; (800c510 <xTaskRemoveFromEventList+0x64>)
 800c4e6:	18c0      	adds	r0, r0, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800c4e8:	0039      	movs	r1, r7
 800c4ea:	f7ff fa9d 	bl	800ba28 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800c4ee:	68f3      	ldr	r3, [r6, #12]
 800c4f0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800c4f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		xReturn = pdFALSE;
 800c4f4:	2000      	movs	r0, #0
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800c4f6:	429a      	cmp	r2, r3
 800c4f8:	d901      	bls.n	800c4fe <xTaskRemoveFromEventList+0x52>
		xYieldPending = pdTRUE;
 800c4fa:	3001      	adds	r0, #1
 800c4fc:	61e8      	str	r0, [r5, #28]
}
 800c4fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800c500:	0030      	movs	r0, r6
 800c502:	3054      	adds	r0, #84	; 0x54
 800c504:	e7f0      	b.n	800c4e8 <xTaskRemoveFromEventList+0x3c>
 800c506:	46c0      	nop			; (mov r8, r8)
 800c508:	20000464 	.word	0x20000464
 800c50c:	200003e4 	.word	0x200003e4
 800c510:	20000484 	.word	0x20000484

0800c514 <vTaskSetTimeOutState>:
	configASSERT( pxTimeOut );
 800c514:	2800      	cmp	r0, #0
 800c516:	d101      	bne.n	800c51c <vTaskSetTimeOutState+0x8>
 800c518:	b672      	cpsid	i
 800c51a:	e7fe      	b.n	800c51a <vTaskSetTimeOutState+0x6>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800c51c:	4b03      	ldr	r3, [pc, #12]	; (800c52c <vTaskSetTimeOutState+0x18>)
 800c51e:	695b      	ldr	r3, [r3, #20]
 800c520:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800c522:	4b03      	ldr	r3, [pc, #12]	; (800c530 <vTaskSetTimeOutState+0x1c>)
 800c524:	689b      	ldr	r3, [r3, #8]
 800c526:	6043      	str	r3, [r0, #4]
}
 800c528:	4770      	bx	lr
 800c52a:	46c0      	nop			; (mov r8, r8)
 800c52c:	20000464 	.word	0x20000464
 800c530:	200003e4 	.word	0x200003e4

0800c534 <xTaskCheckForTimeOut>:
{
 800c534:	b570      	push	{r4, r5, r6, lr}
 800c536:	0004      	movs	r4, r0
 800c538:	000d      	movs	r5, r1
	configASSERT( pxTimeOut );
 800c53a:	2800      	cmp	r0, #0
 800c53c:	d101      	bne.n	800c542 <xTaskCheckForTimeOut+0xe>
 800c53e:	b672      	cpsid	i
 800c540:	e7fe      	b.n	800c540 <xTaskCheckForTimeOut+0xc>
	configASSERT( pxTicksToWait );
 800c542:	2900      	cmp	r1, #0
 800c544:	d101      	bne.n	800c54a <xTaskCheckForTimeOut+0x16>
 800c546:	b672      	cpsid	i
 800c548:	e7fe      	b.n	800c548 <xTaskCheckForTimeOut+0x14>
	taskENTER_CRITICAL();
 800c54a:	f000 f921 	bl	800c790 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 800c54e:	4b0f      	ldr	r3, [pc, #60]	; (800c58c <xTaskCheckForTimeOut+0x58>)
				xReturn = pdFALSE;
 800c550:	2600      	movs	r6, #0
		const TickType_t xConstTickCount = xTickCount;
 800c552:	6899      	ldr	r1, [r3, #8]
			if( *pxTicksToWait == portMAX_DELAY )
 800c554:	682b      	ldr	r3, [r5, #0]
 800c556:	1c5a      	adds	r2, r3, #1
 800c558:	d013      	beq.n	800c582 <xTaskCheckForTimeOut+0x4e>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800c55a:	4a0d      	ldr	r2, [pc, #52]	; (800c590 <xTaskCheckForTimeOut+0x5c>)
 800c55c:	6826      	ldr	r6, [r4, #0]
 800c55e:	6950      	ldr	r0, [r2, #20]
 800c560:	6862      	ldr	r2, [r4, #4]
 800c562:	4286      	cmp	r6, r0
 800c564:	d002      	beq.n	800c56c <xTaskCheckForTimeOut+0x38>
			xReturn = pdTRUE;
 800c566:	2601      	movs	r6, #1
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800c568:	4291      	cmp	r1, r2
 800c56a:	d20a      	bcs.n	800c582 <xTaskCheckForTimeOut+0x4e>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800c56c:	1a88      	subs	r0, r1, r2
			xReturn = pdTRUE;
 800c56e:	2601      	movs	r6, #1
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800c570:	4283      	cmp	r3, r0
 800c572:	d906      	bls.n	800c582 <xTaskCheckForTimeOut+0x4e>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 800c574:	1a5b      	subs	r3, r3, r1
 800c576:	189b      	adds	r3, r3, r2
 800c578:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 800c57a:	0020      	movs	r0, r4
 800c57c:	f7ff ffca 	bl	800c514 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 800c580:	2600      	movs	r6, #0
	taskEXIT_CRITICAL();
 800c582:	f000 f911 	bl	800c7a8 <vPortExitCritical>
}
 800c586:	0030      	movs	r0, r6
 800c588:	bd70      	pop	{r4, r5, r6, pc}
 800c58a:	46c0      	nop			; (mov r8, r8)
 800c58c:	200003e4 	.word	0x200003e4
 800c590:	20000464 	.word	0x20000464

0800c594 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 800c594:	2201      	movs	r2, #1
 800c596:	4b01      	ldr	r3, [pc, #4]	; (800c59c <vTaskMissedYield+0x8>)
 800c598:	61da      	str	r2, [r3, #28]
}
 800c59a:	4770      	bx	lr
 800c59c:	20000464 	.word	0x20000464

0800c5a0 <prvInsertBlockIntoFreeList>:
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800c5a0:	4b0f      	ldr	r3, [pc, #60]	; (800c5e0 <prvInsertBlockIntoFreeList+0x40>)
{
 800c5a2:	b530      	push	{r4, r5, lr}
 800c5a4:	001d      	movs	r5, r3
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800c5a6:	681a      	ldr	r2, [r3, #0]
 800c5a8:	4282      	cmp	r2, r0
 800c5aa:	d317      	bcc.n	800c5dc <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800c5ac:	685c      	ldr	r4, [r3, #4]
 800c5ae:	1919      	adds	r1, r3, r4
 800c5b0:	4288      	cmp	r0, r1
 800c5b2:	d103      	bne.n	800c5bc <prvInsertBlockIntoFreeList+0x1c>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800c5b4:	6841      	ldr	r1, [r0, #4]
 800c5b6:	0018      	movs	r0, r3
 800c5b8:	1909      	adds	r1, r1, r4
 800c5ba:	6059      	str	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800c5bc:	6841      	ldr	r1, [r0, #4]
 800c5be:	1844      	adds	r4, r0, r1
 800c5c0:	42a2      	cmp	r2, r4
 800c5c2:	d106      	bne.n	800c5d2 <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800c5c4:	68ac      	ldr	r4, [r5, #8]
 800c5c6:	42a2      	cmp	r2, r4
 800c5c8:	d003      	beq.n	800c5d2 <prvInsertBlockIntoFreeList+0x32>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800c5ca:	6854      	ldr	r4, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800c5cc:	6812      	ldr	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800c5ce:	1861      	adds	r1, r4, r1
 800c5d0:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 800c5d2:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 800c5d4:	4298      	cmp	r0, r3
 800c5d6:	d000      	beq.n	800c5da <prvInsertBlockIntoFreeList+0x3a>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800c5d8:	6018      	str	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800c5da:	bd30      	pop	{r4, r5, pc}
 800c5dc:	0013      	movs	r3, r2
 800c5de:	e7e2      	b.n	800c5a6 <prvInsertBlockIntoFreeList+0x6>
 800c5e0:	20000510 	.word	0x20000510

0800c5e4 <pvPortMalloc>:
{
 800c5e4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800c5e6:	0005      	movs	r5, r0
	vTaskSuspendAll();
 800c5e8:	f7ff fe08 	bl	800c1fc <vTaskSuspendAll>
		if( pxEnd == NULL )
 800c5ec:	4c33      	ldr	r4, [pc, #204]	; (800c6bc <pvPortMalloc+0xd8>)
 800c5ee:	68a3      	ldr	r3, [r4, #8]
 800c5f0:	2b00      	cmp	r3, #0
 800c5f2:	d11a      	bne.n	800c62a <pvPortMalloc+0x46>
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800c5f4:	2107      	movs	r1, #7
	uxAddress = ( size_t ) ucHeap;
 800c5f6:	4a32      	ldr	r2, [pc, #200]	; (800c6c0 <pvPortMalloc+0xdc>)
 800c5f8:	4b32      	ldr	r3, [pc, #200]	; (800c6c4 <pvPortMalloc+0xe0>)
 800c5fa:	18d3      	adds	r3, r2, r3
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800c5fc:	420a      	tst	r2, r1
 800c5fe:	d03c      	beq.n	800c67a <pvPortMalloc+0x96>
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800c600:	1852      	adds	r2, r2, r1
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800c602:	438a      	bics	r2, r1
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 800c604:	1a9b      	subs	r3, r3, r2
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800c606:	2007      	movs	r0, #7
	xStart.xBlockSize = ( size_t ) 0;
 800c608:	2100      	movs	r1, #0
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 800c60a:	18d3      	adds	r3, r2, r3
	uxAddress -= xHeapStructSize;
 800c60c:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800c60e:	4383      	bics	r3, r0
	xStart.xBlockSize = ( size_t ) 0;
 800c610:	6061      	str	r1, [r4, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800c612:	6022      	str	r2, [r4, #0]
	pxEnd->xBlockSize = 0;
 800c614:	6059      	str	r1, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 800c616:	6019      	str	r1, [r3, #0]
	pxEnd = ( void * ) uxAddress;
 800c618:	60a3      	str	r3, [r4, #8]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800c61a:	1a99      	subs	r1, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 800c61c:	6013      	str	r3, [r2, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800c61e:	2380      	movs	r3, #128	; 0x80
 800c620:	061b      	lsls	r3, r3, #24
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800c622:	6051      	str	r1, [r2, #4]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800c624:	60e1      	str	r1, [r4, #12]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800c626:	6121      	str	r1, [r4, #16]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800c628:	6163      	str	r3, [r4, #20]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800c62a:	6967      	ldr	r7, [r4, #20]
 800c62c:	423d      	tst	r5, r7
 800c62e:	d140      	bne.n	800c6b2 <pvPortMalloc+0xce>
			if( xWantedSize > 0 )
 800c630:	2d00      	cmp	r5, #0
 800c632:	d03e      	beq.n	800c6b2 <pvPortMalloc+0xce>
				xWantedSize += xHeapStructSize;
 800c634:	002b      	movs	r3, r5
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800c636:	2207      	movs	r2, #7
				xWantedSize += xHeapStructSize;
 800c638:	3308      	adds	r3, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800c63a:	4213      	tst	r3, r2
 800c63c:	d001      	beq.n	800c642 <pvPortMalloc+0x5e>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800c63e:	4393      	bics	r3, r2
 800c640:	3308      	adds	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 800c642:	2b00      	cmp	r3, #0
 800c644:	d035      	beq.n	800c6b2 <pvPortMalloc+0xce>
 800c646:	6926      	ldr	r6, [r4, #16]
 800c648:	429e      	cmp	r6, r3
 800c64a:	d332      	bcc.n	800c6b2 <pvPortMalloc+0xce>
				pxPreviousBlock = &xStart;
 800c64c:	0021      	movs	r1, r4
				pxBlock = xStart.pxNextFreeBlock;
 800c64e:	6825      	ldr	r5, [r4, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800c650:	686a      	ldr	r2, [r5, #4]
 800c652:	429a      	cmp	r2, r3
 800c654:	d202      	bcs.n	800c65c <pvPortMalloc+0x78>
 800c656:	6828      	ldr	r0, [r5, #0]
 800c658:	2800      	cmp	r0, #0
 800c65a:	d110      	bne.n	800c67e <pvPortMalloc+0x9a>
				if( pxBlock != pxEnd )
 800c65c:	68a0      	ldr	r0, [r4, #8]
 800c65e:	42a8      	cmp	r0, r5
 800c660:	d027      	beq.n	800c6b2 <pvPortMalloc+0xce>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c662:	6808      	ldr	r0, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800c664:	1ad2      	subs	r2, r2, r3
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c666:	9001      	str	r0, [sp, #4]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 800c668:	6828      	ldr	r0, [r5, #0]
 800c66a:	6008      	str	r0, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800c66c:	2a10      	cmp	r2, #16
 800c66e:	d90d      	bls.n	800c68c <pvPortMalloc+0xa8>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800c670:	18e8      	adds	r0, r5, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 800c672:	0741      	lsls	r1, r0, #29
 800c674:	d006      	beq.n	800c684 <pvPortMalloc+0xa0>
 800c676:	b672      	cpsid	i
 800c678:	e7fe      	b.n	800c678 <pvPortMalloc+0x94>
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 800c67a:	4b12      	ldr	r3, [pc, #72]	; (800c6c4 <pvPortMalloc+0xe0>)
 800c67c:	e7c3      	b.n	800c606 <pvPortMalloc+0x22>
 800c67e:	0029      	movs	r1, r5
 800c680:	0005      	movs	r5, r0
 800c682:	e7e5      	b.n	800c650 <pvPortMalloc+0x6c>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 800c684:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 800c686:	606b      	str	r3, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 800c688:	f7ff ff8a 	bl	800c5a0 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800c68c:	686b      	ldr	r3, [r5, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800c68e:	68e2      	ldr	r2, [r4, #12]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800c690:	1af6      	subs	r6, r6, r3
 800c692:	6126      	str	r6, [r4, #16]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800c694:	4296      	cmp	r6, r2
 800c696:	d200      	bcs.n	800c69a <pvPortMalloc+0xb6>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 800c698:	60e6      	str	r6, [r4, #12]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800c69a:	431f      	orrs	r7, r3
					pxBlock->pxNextFreeBlock = NULL;
 800c69c:	2300      	movs	r3, #0
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c69e:	9c01      	ldr	r4, [sp, #4]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800c6a0:	606f      	str	r7, [r5, #4]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c6a2:	3408      	adds	r4, #8
					pxBlock->pxNextFreeBlock = NULL;
 800c6a4:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 800c6a6:	f7ff fe1d 	bl	800c2e4 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 800c6aa:	0763      	lsls	r3, r4, #29
 800c6ac:	d003      	beq.n	800c6b6 <pvPortMalloc+0xd2>
 800c6ae:	b672      	cpsid	i
 800c6b0:	e7fe      	b.n	800c6b0 <pvPortMalloc+0xcc>
void *pvReturn = NULL;
 800c6b2:	2400      	movs	r4, #0
 800c6b4:	e7f7      	b.n	800c6a6 <pvPortMalloc+0xc2>
}
 800c6b6:	0020      	movs	r0, r4
 800c6b8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800c6ba:	46c0      	nop			; (mov r8, r8)
 800c6bc:	20000510 	.word	0x20000510
 800c6c0:	20000528 	.word	0x20000528
 800c6c4:	00001450 	.word	0x00001450

0800c6c8 <vPortFree>:
{
 800c6c8:	b570      	push	{r4, r5, r6, lr}
	if( pv != NULL )
 800c6ca:	2800      	cmp	r0, #0
 800c6cc:	d01a      	beq.n	800c704 <vPortFree+0x3c>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800c6ce:	4d0e      	ldr	r5, [pc, #56]	; (800c708 <vPortFree+0x40>)
 800c6d0:	3808      	subs	r0, #8
 800c6d2:	6843      	ldr	r3, [r0, #4]
 800c6d4:	696a      	ldr	r2, [r5, #20]
 800c6d6:	0004      	movs	r4, r0
 800c6d8:	421a      	tst	r2, r3
 800c6da:	d101      	bne.n	800c6e0 <vPortFree+0x18>
 800c6dc:	b672      	cpsid	i
 800c6de:	e7fe      	b.n	800c6de <vPortFree+0x16>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800c6e0:	6801      	ldr	r1, [r0, #0]
 800c6e2:	2900      	cmp	r1, #0
 800c6e4:	d001      	beq.n	800c6ea <vPortFree+0x22>
 800c6e6:	b672      	cpsid	i
 800c6e8:	e7fe      	b.n	800c6e8 <vPortFree+0x20>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800c6ea:	4393      	bics	r3, r2
 800c6ec:	6043      	str	r3, [r0, #4]
				vTaskSuspendAll();
 800c6ee:	f7ff fd85 	bl	800c1fc <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 800c6f2:	692a      	ldr	r2, [r5, #16]
 800c6f4:	6863      	ldr	r3, [r4, #4]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800c6f6:	0020      	movs	r0, r4
					xFreeBytesRemaining += pxLink->xBlockSize;
 800c6f8:	189b      	adds	r3, r3, r2
 800c6fa:	612b      	str	r3, [r5, #16]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800c6fc:	f7ff ff50 	bl	800c5a0 <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 800c700:	f7ff fdf0 	bl	800c2e4 <xTaskResumeAll>
}
 800c704:	bd70      	pop	{r4, r5, r6, pc}
 800c706:	46c0      	nop			; (mov r8, r8)
 800c708:	20000510 	.word	0x20000510

0800c70c <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800c70c:	4b03      	ldr	r3, [pc, #12]	; (800c71c <prvTaskExitError+0x10>)
 800c70e:	681b      	ldr	r3, [r3, #0]
 800c710:	3301      	adds	r3, #1
 800c712:	d001      	beq.n	800c718 <prvTaskExitError+0xc>
 800c714:	b672      	cpsid	i
 800c716:	e7fe      	b.n	800c716 <prvTaskExitError+0xa>
	portDISABLE_INTERRUPTS();
 800c718:	b672      	cpsid	i
 800c71a:	e7fe      	b.n	800c71a <prvTaskExitError+0xe>
 800c71c:	20000238 	.word	0x20000238

0800c720 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
 800c720:	4a0b      	ldr	r2, [pc, #44]	; (800c750 <pxCurrentTCBConst2>)
 800c722:	6813      	ldr	r3, [r2, #0]
 800c724:	6818      	ldr	r0, [r3, #0]
 800c726:	3020      	adds	r0, #32
 800c728:	f380 8809 	msr	PSP, r0
 800c72c:	2002      	movs	r0, #2
 800c72e:	f380 8814 	msr	CONTROL, r0
 800c732:	f3bf 8f6f 	isb	sy
 800c736:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
 800c738:	46ae      	mov	lr, r5
 800c73a:	bc08      	pop	{r3}
 800c73c:	bc04      	pop	{r2}
 800c73e:	b662      	cpsie	i
 800c740:	4718      	bx	r3
 800c742:	46c0      	nop			; (mov r8, r8)
 800c744:	46c0      	nop			; (mov r8, r8)
 800c746:	46c0      	nop			; (mov r8, r8)
 800c748:	46c0      	nop			; (mov r8, r8)
 800c74a:	46c0      	nop			; (mov r8, r8)
 800c74c:	46c0      	nop			; (mov r8, r8)
 800c74e:	46c0      	nop			; (mov r8, r8)

0800c750 <pxCurrentTCBConst2>:
 800c750:	200003f0 	.word	0x200003f0

0800c754 <pxPortInitialiseStack>:
{
 800c754:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800c756:	2480      	movs	r4, #128	; 0x80
 800c758:	1f03      	subs	r3, r0, #4
 800c75a:	0464      	lsls	r4, r4, #17
 800c75c:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 800c75e:	3b04      	subs	r3, #4
 800c760:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 800c762:	4903      	ldr	r1, [pc, #12]	; (800c770 <pxPortInitialiseStack+0x1c>)
 800c764:	3b04      	subs	r3, #4
 800c766:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800c768:	3b14      	subs	r3, #20
	pxTopOfStack -= 8; /* R11..R4. */
 800c76a:	3840      	subs	r0, #64	; 0x40
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800c76c:	601a      	str	r2, [r3, #0]
}
 800c76e:	bd10      	pop	{r4, pc}
 800c770:	0800c70d 	.word	0x0800c70d

0800c774 <SVC_Handler>:
}
 800c774:	4770      	bx	lr
	...

0800c778 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
 800c778:	2280      	movs	r2, #128	; 0x80
 800c77a:	4b04      	ldr	r3, [pc, #16]	; (800c78c <vPortYield+0x14>)
 800c77c:	0552      	lsls	r2, r2, #21
 800c77e:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 800c780:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800c784:	f3bf 8f6f 	isb	sy
}
 800c788:	4770      	bx	lr
 800c78a:	46c0      	nop			; (mov r8, r8)
 800c78c:	e000ed04 	.word	0xe000ed04

0800c790 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
 800c790:	b672      	cpsid	i
    uxCriticalNesting++;
 800c792:	4a04      	ldr	r2, [pc, #16]	; (800c7a4 <vPortEnterCritical+0x14>)
 800c794:	6813      	ldr	r3, [r2, #0]
 800c796:	3301      	adds	r3, #1
 800c798:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
 800c79a:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800c79e:	f3bf 8f6f 	isb	sy
}
 800c7a2:	4770      	bx	lr
 800c7a4:	20000238 	.word	0x20000238

0800c7a8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
 800c7a8:	4a05      	ldr	r2, [pc, #20]	; (800c7c0 <vPortExitCritical+0x18>)
 800c7aa:	6813      	ldr	r3, [r2, #0]
 800c7ac:	2b00      	cmp	r3, #0
 800c7ae:	d101      	bne.n	800c7b4 <vPortExitCritical+0xc>
 800c7b0:	b672      	cpsid	i
 800c7b2:	e7fe      	b.n	800c7b2 <vPortExitCritical+0xa>
    uxCriticalNesting--;
 800c7b4:	3b01      	subs	r3, #1
 800c7b6:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
 800c7b8:	2b00      	cmp	r3, #0
 800c7ba:	d100      	bne.n	800c7be <vPortExitCritical+0x16>
    {
        portENABLE_INTERRUPTS();
 800c7bc:	b662      	cpsie	i
    }
}
 800c7be:	4770      	bx	lr
 800c7c0:	20000238 	.word	0x20000238

0800c7c4 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
	__asm volatile(
 800c7c4:	f3ef 8010 	mrs	r0, PRIMASK
 800c7c8:	b672      	cpsid	i
 800c7ca:	4770      	bx	lr
					" bx lr				  "
				  );

	/* To avoid compiler warnings.  This line will never be reached. */
	return 0;
}
 800c7cc:	2000      	movs	r0, #0

0800c7ce <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( uint32_t ulMask )
{
	__asm volatile(
 800c7ce:	f380 8810 	msr	PRIMASK, r0
 800c7d2:	4770      	bx	lr
	...

0800c7e0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 800c7e0:	f3ef 8009 	mrs	r0, PSP
 800c7e4:	4b0e      	ldr	r3, [pc, #56]	; (800c820 <pxCurrentTCBConst>)
 800c7e6:	681a      	ldr	r2, [r3, #0]
 800c7e8:	3820      	subs	r0, #32
 800c7ea:	6010      	str	r0, [r2, #0]
 800c7ec:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800c7ee:	4644      	mov	r4, r8
 800c7f0:	464d      	mov	r5, r9
 800c7f2:	4656      	mov	r6, sl
 800c7f4:	465f      	mov	r7, fp
 800c7f6:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800c7f8:	b508      	push	{r3, lr}
 800c7fa:	b672      	cpsid	i
 800c7fc:	f7ff fe14 	bl	800c428 <vTaskSwitchContext>
 800c800:	b662      	cpsie	i
 800c802:	bc0c      	pop	{r2, r3}
 800c804:	6811      	ldr	r1, [r2, #0]
 800c806:	6808      	ldr	r0, [r1, #0]
 800c808:	3010      	adds	r0, #16
 800c80a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800c80c:	46a0      	mov	r8, r4
 800c80e:	46a9      	mov	r9, r5
 800c810:	46b2      	mov	sl, r6
 800c812:	46bb      	mov	fp, r7
 800c814:	f380 8809 	msr	PSP, r0
 800c818:	3820      	subs	r0, #32
 800c81a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800c81c:	4718      	bx	r3
 800c81e:	46c0      	nop			; (mov r8, r8)

0800c820 <pxCurrentTCBConst>:
 800c820:	200003f0 	.word	0x200003f0

0800c824 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 800c824:	b510      	push	{r4, lr}
uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 800c826:	f7ff ffcd 	bl	800c7c4 <ulSetInterruptMaskFromISR>
 800c82a:	0004      	movs	r4, r0
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 800c82c:	f7ff fcf4 	bl	800c218 <xTaskIncrementTick>
 800c830:	2800      	cmp	r0, #0
 800c832:	d003      	beq.n	800c83c <xPortSysTickHandler+0x18>
		{
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 800c834:	2280      	movs	r2, #128	; 0x80
 800c836:	4b03      	ldr	r3, [pc, #12]	; (800c844 <xPortSysTickHandler+0x20>)
 800c838:	0552      	lsls	r2, r2, #21
 800c83a:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 800c83c:	0020      	movs	r0, r4
 800c83e:	f7ff ffc6 	bl	800c7ce <vClearInterruptMaskFromISR>
}
 800c842:	bd10      	pop	{r4, pc}
 800c844:	e000ed04 	.word	0xe000ed04

0800c848 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */
	/* Configure SysTick to interrupt at the requested rate. */

	portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800c848:	21fa      	movs	r1, #250	; 0xfa
 800c84a:	4b06      	ldr	r3, [pc, #24]	; (800c864 <vPortSetupTimerInterrupt+0x1c>)
{
 800c84c:	b510      	push	{r4, lr}
	portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800c84e:	6818      	ldr	r0, [r3, #0]
 800c850:	0089      	lsls	r1, r1, #2
 800c852:	f7f9 f8b9 	bl	80059c8 <__udivsi3>
	portNVIC_SYSTICK_CTRL = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 800c856:	2207      	movs	r2, #7
	portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800c858:	4b03      	ldr	r3, [pc, #12]	; (800c868 <vPortSetupTimerInterrupt+0x20>)
 800c85a:	3801      	subs	r0, #1
 800c85c:	6018      	str	r0, [r3, #0]
	portNVIC_SYSTICK_CTRL = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 800c85e:	4b03      	ldr	r3, [pc, #12]	; (800c86c <vPortSetupTimerInterrupt+0x24>)
 800c860:	601a      	str	r2, [r3, #0]
}
 800c862:	bd10      	pop	{r4, pc}
 800c864:	20000030 	.word	0x20000030
 800c868:	e000e014 	.word	0xe000e014
 800c86c:	e000e010 	.word	0xe000e010

0800c870 <xPortStartScheduler>:
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 800c870:	22ff      	movs	r2, #255	; 0xff
 800c872:	4b0a      	ldr	r3, [pc, #40]	; (800c89c <xPortStartScheduler+0x2c>)
 800c874:	0412      	lsls	r2, r2, #16
 800c876:	6819      	ldr	r1, [r3, #0]
{
 800c878:	b510      	push	{r4, lr}
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 800c87a:	430a      	orrs	r2, r1
 800c87c:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 800c87e:	22ff      	movs	r2, #255	; 0xff
 800c880:	6819      	ldr	r1, [r3, #0]
 800c882:	0612      	lsls	r2, r2, #24
 800c884:	430a      	orrs	r2, r1
 800c886:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 800c888:	f7ff ffde 	bl	800c848 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 800c88c:	2200      	movs	r2, #0
 800c88e:	4b04      	ldr	r3, [pc, #16]	; (800c8a0 <xPortStartScheduler+0x30>)
 800c890:	601a      	str	r2, [r3, #0]
	vPortStartFirstTask();
 800c892:	f7ff ff45 	bl	800c720 <vPortStartFirstTask>
	prvTaskExitError();
 800c896:	f7ff ff39 	bl	800c70c <prvTaskExitError>
 800c89a:	46c0      	nop			; (mov r8, r8)
 800c89c:	e000ed20 	.word	0xe000ed20
 800c8a0:	20000238 	.word	0x20000238

0800c8a4 <Led_Init>:
/**
  * @brief This function performs an init of the LED manager.
  * @retval None
  */
void Led_Init()
{
 800c8a4:	2300      	movs	r3, #0
 800c8a6:	4a08      	ldr	r2, [pc, #32]	; (800c8c8 <Led_Init+0x24>)
 800c8a8:	b530      	push	{r4, r5, lr}
 800c8aa:	0010      	movs	r0, r2
static inline void prvLedStatusInit(LED_BSP_TypeDef Index)
{
  configASSERT(LED_INDEX_IsValid(Index));

  Status[Index].Index = Index;
  Status[Index].Mode = LED_MODE_OFF;
 800c8ac:	0019      	movs	r1, r3
  Status[Index].Period = LED_PERIOD_DEFAULT;
 800c8ae:	2564      	movs	r5, #100	; 0x64
    LedOrder[i] = i;
 800c8b0:	4c06      	ldr	r4, [pc, #24]	; (800c8cc <Led_Init+0x28>)
    prvLedStatusInit((LED_BSP_TypeDef)i);
 800c8b2:	7013      	strb	r3, [r2, #0]
    LedOrder[i] = i;
 800c8b4:	54e3      	strb	r3, [r4, r3]
 800c8b6:	3301      	adds	r3, #1
  Status[Index].Mode = LED_MODE_OFF;
 800c8b8:	7051      	strb	r1, [r2, #1]
  Status[Index].Period = LED_PERIOD_DEFAULT;
 800c8ba:	8095      	strh	r5, [r2, #4]
  Status[Index].Count = 0;
 800c8bc:	80d1      	strh	r1, [r2, #6]
 800c8be:	3208      	adds	r2, #8
  for(i=0; i<LED_INDEX_LEN; i++)
 800c8c0:	2b04      	cmp	r3, #4
 800c8c2:	d1f6      	bne.n	800c8b2 <Led_Init+0xe>
  GlobalCount = 0;
 800c8c4:	8401      	strh	r1, [r0, #32]
}
 800c8c6:	bd30      	pop	{r4, r5, pc}
 800c8c8:	20001978 	.word	0x20001978
 800c8cc:	20001dbc 	.word	0x20001dbc

0800c8d0 <Led_Set>:
{
 800c8d0:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (!LED_INDEX_IsValid(Index) || 
 800c8d2:	b2c3      	uxtb	r3, r0
{
 800c8d4:	b089      	sub	sp, #36	; 0x24
 800c8d6:	0006      	movs	r6, r0
 800c8d8:	000d      	movs	r5, r1
  if (!LED_INDEX_IsValid(Index) || 
 800c8da:	2b03      	cmp	r3, #3
 800c8dc:	d821      	bhi.n	800c922 <Led_Set+0x52>
 800c8de:	2909      	cmp	r1, #9
 800c8e0:	d81f      	bhi.n	800c922 <Led_Set+0x52>
      !LED_MODE_IsValid(Mode) || 
 800c8e2:	2902      	cmp	r1, #2
 800c8e4:	d105      	bne.n	800c8f2 <Led_Set+0x22>
      !LED_PERIOD_IsValid(Mode, Period) )
 800c8e6:	0013      	movs	r3, r2
 800c8e8:	491e      	ldr	r1, [pc, #120]	; (800c964 <Led_Set+0x94>)
 800c8ea:	3b0a      	subs	r3, #10
 800c8ec:	b29b      	uxth	r3, r3
 800c8ee:	428b      	cmp	r3, r1
 800c8f0:	d817      	bhi.n	800c922 <Led_Set+0x52>
  pStatus->Count = 0;
 800c8f2:	2100      	movs	r1, #0
  pStatus->Mode = Mode;
 800c8f4:	4c1c      	ldr	r4, [pc, #112]	; (800c968 <Led_Set+0x98>)
 800c8f6:	00f3      	lsls	r3, r6, #3
 800c8f8:	9301      	str	r3, [sp, #4]
  switch(Mode)
 800c8fa:	1e68      	subs	r0, r5, #1
  pStatus->Mode = Mode;
 800c8fc:	18e3      	adds	r3, r4, r3
 800c8fe:	705d      	strb	r5, [r3, #1]
  pStatus->Period = Period;
 800c900:	809a      	strh	r2, [r3, #4]
  pStatus->Count = 0;
 800c902:	80d9      	strh	r1, [r3, #6]
  switch(Mode)
 800c904:	2808      	cmp	r0, #8
 800c906:	d829      	bhi.n	800c95c <Led_Set+0x8c>
 800c908:	f7f9 f854 	bl	80059b4 <__gnu_thumb1_case_uqi>
 800c90c:	10100d05 	.word	0x10100d05
 800c910:	10101010 	.word	0x10101010
 800c914:	10          	.byte	0x10
 800c915:	00          	.byte	0x00
 * @brief  Turn on a LED.
 * @param  cIndex: State Index
 */
void prvLedOn(LED_BSP_TypeDef Index)
{
  USBPD_BSP_LED_On(Index);
 800c916:	0030      	movs	r0, r6
 800c918:	f7fa fb14 	bl	8006f44 <USBPD_BSP_LED_On>
  pStatus->ModePrevious = Mode;
 800c91c:	9b01      	ldr	r3, [sp, #4]
 800c91e:	18e4      	adds	r4, r4, r3
 800c920:	70a5      	strb	r5, [r4, #2]
}
 800c922:	b009      	add	sp, #36	; 0x24
 800c924:	bdf0      	pop	{r4, r5, r6, r7, pc}
    pStatus->Count = pStatus->Period;
 800c926:	00f3      	lsls	r3, r6, #3
 800c928:	18e3      	adds	r3, r4, r3
 800c92a:	80da      	strh	r2, [r3, #6]
    if (xLedThreadId == NULL)
 800c92c:	4b0f      	ldr	r3, [pc, #60]	; (800c96c <Led_Set+0x9c>)
 800c92e:	681b      	ldr	r3, [r3, #0]
 800c930:	469c      	mov	ip, r3
 800c932:	2b00      	cmp	r3, #0
 800c934:	d10d      	bne.n	800c952 <Led_Set+0x82>
      osThreadDef(LEDThread, prvLedThread, LED_THREAD_PRIORITY, 0, configMINIMAL_STACK_SIZE);
 800c936:	ab03      	add	r3, sp, #12
 800c938:	9300      	str	r3, [sp, #0]
 800c93a:	9a00      	ldr	r2, [sp, #0]
 800c93c:	4b0c      	ldr	r3, [pc, #48]	; (800c970 <Led_Set+0xa0>)
 800c93e:	cb83      	ldmia	r3!, {r0, r1, r7}
 800c940:	c283      	stmia	r2!, {r0, r1, r7}
 800c942:	cb03      	ldmia	r3!, {r0, r1}
 800c944:	c203      	stmia	r2!, {r0, r1}
      xLedThreadId = osThreadCreate(osThread(LEDThread), NULL);
 800c946:	4661      	mov	r1, ip
 800c948:	9800      	ldr	r0, [sp, #0]
 800c94a:	f7fe ffce 	bl	800b8ea <osThreadCreate>
 800c94e:	4b07      	ldr	r3, [pc, #28]	; (800c96c <Led_Set+0x9c>)
 800c950:	6018      	str	r0, [r3, #0]
    if (pStatus->ModePrevious != Mode)
 800c952:	00f3      	lsls	r3, r6, #3
 800c954:	18e3      	adds	r3, r4, r3
 800c956:	789b      	ldrb	r3, [r3, #2]
 800c958:	42ab      	cmp	r3, r5
 800c95a:	d0df      	beq.n	800c91c <Led_Set+0x4c>
 * @brief  Turn off a LED.
 * @param  cIndex: State Index
 */
void prvLedOff(LED_BSP_TypeDef Index)
{
  USBPD_BSP_LED_Off(Index);
 800c95c:	0030      	movs	r0, r6
 800c95e:	f7fa faff 	bl	8006f60 <USBPD_BSP_LED_Off>
 800c962:	e7db      	b.n	800c91c <Led_Set+0x4c>
 800c964:	00002706 	.word	0x00002706
 800c968:	20001978 	.word	0x20001978
 800c96c:	20001dc0 	.word	0x20001dc0
 800c970:	0800cdb0 	.word	0x0800cdb0

0800c974 <prvLedThread>:
{
 800c974:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    half_period = GlobalPeriod>>1;
 800c976:	2401      	movs	r4, #1
  osDelay(100);
 800c978:	2064      	movs	r0, #100	; 0x64
 800c97a:	f7fe ffd4 	bl	800b926 <osDelay>
    half_period = GlobalPeriod>>1;
 800c97e:	4f2c      	ldr	r7, [pc, #176]	; (800ca30 <prvLedThread+0xbc>)
 800c980:	883d      	ldrh	r5, [r7, #0]
 800c982:	086d      	lsrs	r5, r5, #1
      if (LED_MODE_IsBlinking(pStatus->Mode))
 800c984:	4e2b      	ldr	r6, [pc, #172]	; (800ca34 <prvLedThread+0xc0>)
 800c986:	00e3      	lsls	r3, r4, #3
 800c988:	3b07      	subs	r3, #7
 800c98a:	5cf0      	ldrb	r0, [r6, r3]
 800c98c:	1ec3      	subs	r3, r0, #3
 800c98e:	2b06      	cmp	r3, #6
 800c990:	d810      	bhi.n	800c9b4 <prvLedThread+0x40>
        switch(pStatus->Mode)
 800c992:	3804      	subs	r0, #4
 800c994:	8c33      	ldrh	r3, [r6, #32]
 800c996:	2805      	cmp	r0, #5
 800c998:	d804      	bhi.n	800c9a4 <prvLedThread+0x30>
 800c99a:	f7f9 f80b 	bl	80059b4 <__gnu_thumb1_case_uqi>
 800c99e:	1633      	.short	0x1633
 800c9a0:	3e383328 	.word	0x3e383328
          prvLed((LED_BSP_TypeDef)i, (GlobalMap >> GlobalCount) & 0x01);
 800c9a4:	6879      	ldr	r1, [r7, #4]
 * @brief  Turn on off a LED.
 * @param  cIndex: State Index
 */
void prvLed(LED_BSP_TypeDef Index, uint8_t Value)
{
  USBPD_BSP_LED_Set(Index, Value);
 800c9a6:	1e60      	subs	r0, r4, #1
          prvLed((LED_BSP_TypeDef)i, (GlobalMap >> GlobalCount) & 0x01);
 800c9a8:	40d9      	lsrs	r1, r3
  USBPD_BSP_LED_Set(Index, Value);
 800c9aa:	2301      	movs	r3, #1
 800c9ac:	b240      	sxtb	r0, r0
 800c9ae:	4019      	ands	r1, r3
 800c9b0:	f7fa fab8 	bl	8006f24 <USBPD_BSP_LED_Set>
 800c9b4:	3401      	adds	r4, #1
    for(i=0; i<LED_INDEX_LEN; i++)
 800c9b6:	2c05      	cmp	r4, #5
 800c9b8:	d1e4      	bne.n	800c984 <prvLedThread+0x10>
    GlobalCount++;
 800c9ba:	8c30      	ldrh	r0, [r6, #32]
    GlobalCount %= GlobalPeriod;
 800c9bc:	8839      	ldrh	r1, [r7, #0]
    GlobalCount++;
 800c9be:	3001      	adds	r0, #1
    GlobalCount %= GlobalPeriod;
 800c9c0:	b280      	uxth	r0, r0
 800c9c2:	f7f9 f887 	bl	8005ad4 <__aeabi_uidivmod>
 800c9c6:	8431      	strh	r1, [r6, #32]
 800c9c8:	e7d5      	b.n	800c976 <prvLedThread+0x2>
          if (GlobalCount == 0 || GlobalCount == 3) 
 800c9ca:	2b00      	cmp	r3, #0
 800c9cc:	d001      	beq.n	800c9d2 <prvLedThread+0x5e>
 800c9ce:	2b03      	cmp	r3, #3
 800c9d0:	d104      	bne.n	800c9dc <prvLedThread+0x68>
  USBPD_BSP_LED_On(Index);
 800c9d2:	1e60      	subs	r0, r4, #1
 800c9d4:	b240      	sxtb	r0, r0
 800c9d6:	f7fa fab5 	bl	8006f44 <USBPD_BSP_LED_On>
 800c9da:	e7eb      	b.n	800c9b4 <prvLedThread+0x40>
          else if (GlobalCount == 1 || GlobalCount == 4) 
 800c9dc:	2b01      	cmp	r3, #1
 800c9de:	d001      	beq.n	800c9e4 <prvLedThread+0x70>
 800c9e0:	2b04      	cmp	r3, #4
 800c9e2:	d1e7      	bne.n	800c9b4 <prvLedThread+0x40>
  USBPD_BSP_LED_Off(Index);
 800c9e4:	1e60      	subs	r0, r4, #1
 800c9e6:	b240      	sxtb	r0, r0
 800c9e8:	f7fa faba 	bl	8006f60 <USBPD_BSP_LED_Off>
 800c9ec:	e7e2      	b.n	800c9b4 <prvLedThread+0x40>
          if (GlobalCount == 0 || GlobalCount == 4 || GlobalCount == 8) 
 800c9ee:	001a      	movs	r2, r3
 800c9f0:	2104      	movs	r1, #4
 800c9f2:	438a      	bics	r2, r1
 800c9f4:	d0ed      	beq.n	800c9d2 <prvLedThread+0x5e>
 800c9f6:	2b08      	cmp	r3, #8
 800c9f8:	d0eb      	beq.n	800c9d2 <prvLedThread+0x5e>
          else if (GlobalCount == 2 || GlobalCount == 6 || GlobalCount == 10) 
 800c9fa:	2a02      	cmp	r2, #2
 800c9fc:	d0f2      	beq.n	800c9e4 <prvLedThread+0x70>
 800c9fe:	2b0a      	cmp	r3, #10
 800ca00:	d1d8      	bne.n	800c9b4 <prvLedThread+0x40>
 800ca02:	e7ef      	b.n	800c9e4 <prvLedThread+0x70>
          if (GlobalCount == 0) 
 800ca04:	2b00      	cmp	r3, #0
 800ca06:	d0e4      	beq.n	800c9d2 <prvLedThread+0x5e>
          else if (GlobalCount == 2) 
 800ca08:	2b02      	cmp	r3, #2
 800ca0a:	d1d3      	bne.n	800c9b4 <prvLedThread+0x40>
 800ca0c:	e7ea      	b.n	800c9e4 <prvLedThread+0x70>
          else if (GlobalCount == (half_period+2)) 
 800ca0e:	1caa      	adds	r2, r5, #2
          if (GlobalCount == half_period) 
 800ca10:	429d      	cmp	r5, r3
 800ca12:	d0de      	beq.n	800c9d2 <prvLedThread+0x5e>
          else if (GlobalCount == (half_period+1) || GlobalCount == (half_period+4))
 800ca14:	4293      	cmp	r3, r2
 800ca16:	d1cd      	bne.n	800c9b4 <prvLedThread+0x40>
 800ca18:	e7e4      	b.n	800c9e4 <prvLedThread+0x70>
          if (GlobalCount == half_period || GlobalCount == (half_period+3)) 
 800ca1a:	429d      	cmp	r5, r3
 800ca1c:	d0d9      	beq.n	800c9d2 <prvLedThread+0x5e>
 800ca1e:	1cea      	adds	r2, r5, #3
 800ca20:	4293      	cmp	r3, r2
 800ca22:	d0d6      	beq.n	800c9d2 <prvLedThread+0x5e>
          else if (GlobalCount == (half_period+1) || GlobalCount == (half_period+4))
 800ca24:	1c6a      	adds	r2, r5, #1
 800ca26:	4293      	cmp	r3, r2
 800ca28:	d0dc      	beq.n	800c9e4 <prvLedThread+0x70>
 800ca2a:	1d2a      	adds	r2, r5, #4
 800ca2c:	e7f2      	b.n	800ca14 <prvLedThread+0xa0>
 800ca2e:	46c0      	nop			; (mov r8, r8)
 800ca30:	2000023c 	.word	0x2000023c
 800ca34:	20001978 	.word	0x20001978

0800ca38 <__aeabi_memclr>:
 800ca38:	b510      	push	{r4, lr}
 800ca3a:	2200      	movs	r2, #0
 800ca3c:	f000 f801 	bl	800ca42 <__aeabi_memset>
 800ca40:	bd10      	pop	{r4, pc}

0800ca42 <__aeabi_memset>:
 800ca42:	0013      	movs	r3, r2
 800ca44:	b510      	push	{r4, lr}
 800ca46:	000a      	movs	r2, r1
 800ca48:	0019      	movs	r1, r3
 800ca4a:	f000 f838 	bl	800cabe <memset>
 800ca4e:	bd10      	pop	{r4, pc}

0800ca50 <__libc_init_array>:
 800ca50:	b570      	push	{r4, r5, r6, lr}
 800ca52:	2600      	movs	r6, #0
 800ca54:	4d0c      	ldr	r5, [pc, #48]	; (800ca88 <__libc_init_array+0x38>)
 800ca56:	4c0d      	ldr	r4, [pc, #52]	; (800ca8c <__libc_init_array+0x3c>)
 800ca58:	1b64      	subs	r4, r4, r5
 800ca5a:	10a4      	asrs	r4, r4, #2
 800ca5c:	42a6      	cmp	r6, r4
 800ca5e:	d109      	bne.n	800ca74 <__libc_init_array+0x24>
 800ca60:	2600      	movs	r6, #0
 800ca62:	f000 f8b7 	bl	800cbd4 <_init>
 800ca66:	4d0a      	ldr	r5, [pc, #40]	; (800ca90 <__libc_init_array+0x40>)
 800ca68:	4c0a      	ldr	r4, [pc, #40]	; (800ca94 <__libc_init_array+0x44>)
 800ca6a:	1b64      	subs	r4, r4, r5
 800ca6c:	10a4      	asrs	r4, r4, #2
 800ca6e:	42a6      	cmp	r6, r4
 800ca70:	d105      	bne.n	800ca7e <__libc_init_array+0x2e>
 800ca72:	bd70      	pop	{r4, r5, r6, pc}
 800ca74:	00b3      	lsls	r3, r6, #2
 800ca76:	58eb      	ldr	r3, [r5, r3]
 800ca78:	4798      	blx	r3
 800ca7a:	3601      	adds	r6, #1
 800ca7c:	e7ee      	b.n	800ca5c <__libc_init_array+0xc>
 800ca7e:	00b3      	lsls	r3, r6, #2
 800ca80:	58eb      	ldr	r3, [r5, r3]
 800ca82:	4798      	blx	r3
 800ca84:	3601      	adds	r6, #1
 800ca86:	e7f2      	b.n	800ca6e <__libc_init_array+0x1e>
 800ca88:	0800cdec 	.word	0x0800cdec
 800ca8c:	0800cdec 	.word	0x0800cdec
 800ca90:	0800cdec 	.word	0x0800cdec
 800ca94:	0800cdf0 	.word	0x0800cdf0

0800ca98 <malloc>:
 800ca98:	b510      	push	{r4, lr}
 800ca9a:	4b03      	ldr	r3, [pc, #12]	; (800caa8 <malloc+0x10>)
 800ca9c:	0001      	movs	r1, r0
 800ca9e:	6818      	ldr	r0, [r3, #0]
 800caa0:	f000 f816 	bl	800cad0 <_malloc_r>
 800caa4:	bd10      	pop	{r4, pc}
 800caa6:	46c0      	nop			; (mov r8, r8)
 800caa8:	20000244 	.word	0x20000244

0800caac <memcpy>:
 800caac:	2300      	movs	r3, #0
 800caae:	b510      	push	{r4, lr}
 800cab0:	429a      	cmp	r2, r3
 800cab2:	d100      	bne.n	800cab6 <memcpy+0xa>
 800cab4:	bd10      	pop	{r4, pc}
 800cab6:	5ccc      	ldrb	r4, [r1, r3]
 800cab8:	54c4      	strb	r4, [r0, r3]
 800caba:	3301      	adds	r3, #1
 800cabc:	e7f8      	b.n	800cab0 <memcpy+0x4>

0800cabe <memset>:
 800cabe:	0003      	movs	r3, r0
 800cac0:	1812      	adds	r2, r2, r0
 800cac2:	4293      	cmp	r3, r2
 800cac4:	d100      	bne.n	800cac8 <memset+0xa>
 800cac6:	4770      	bx	lr
 800cac8:	7019      	strb	r1, [r3, #0]
 800caca:	3301      	adds	r3, #1
 800cacc:	e7f9      	b.n	800cac2 <memset+0x4>
	...

0800cad0 <_malloc_r>:
 800cad0:	2303      	movs	r3, #3
 800cad2:	b570      	push	{r4, r5, r6, lr}
 800cad4:	1ccd      	adds	r5, r1, #3
 800cad6:	439d      	bics	r5, r3
 800cad8:	3508      	adds	r5, #8
 800cada:	0006      	movs	r6, r0
 800cadc:	2d0c      	cmp	r5, #12
 800cade:	d21e      	bcs.n	800cb1e <_malloc_r+0x4e>
 800cae0:	250c      	movs	r5, #12
 800cae2:	42a9      	cmp	r1, r5
 800cae4:	d81d      	bhi.n	800cb22 <_malloc_r+0x52>
 800cae6:	0030      	movs	r0, r6
 800cae8:	f000 f862 	bl	800cbb0 <__malloc_lock>
 800caec:	4a25      	ldr	r2, [pc, #148]	; (800cb84 <_malloc_r+0xb4>)
 800caee:	6814      	ldr	r4, [r2, #0]
 800caf0:	0021      	movs	r1, r4
 800caf2:	2900      	cmp	r1, #0
 800caf4:	d119      	bne.n	800cb2a <_malloc_r+0x5a>
 800caf6:	4c24      	ldr	r4, [pc, #144]	; (800cb88 <_malloc_r+0xb8>)
 800caf8:	6823      	ldr	r3, [r4, #0]
 800cafa:	2b00      	cmp	r3, #0
 800cafc:	d103      	bne.n	800cb06 <_malloc_r+0x36>
 800cafe:	0030      	movs	r0, r6
 800cb00:	f000 f844 	bl	800cb8c <_sbrk_r>
 800cb04:	6020      	str	r0, [r4, #0]
 800cb06:	0029      	movs	r1, r5
 800cb08:	0030      	movs	r0, r6
 800cb0a:	f000 f83f 	bl	800cb8c <_sbrk_r>
 800cb0e:	1c43      	adds	r3, r0, #1
 800cb10:	d12b      	bne.n	800cb6a <_malloc_r+0x9a>
 800cb12:	230c      	movs	r3, #12
 800cb14:	0030      	movs	r0, r6
 800cb16:	6033      	str	r3, [r6, #0]
 800cb18:	f000 f84b 	bl	800cbb2 <__malloc_unlock>
 800cb1c:	e003      	b.n	800cb26 <_malloc_r+0x56>
 800cb1e:	2d00      	cmp	r5, #0
 800cb20:	dadf      	bge.n	800cae2 <_malloc_r+0x12>
 800cb22:	230c      	movs	r3, #12
 800cb24:	6033      	str	r3, [r6, #0]
 800cb26:	2000      	movs	r0, #0
 800cb28:	bd70      	pop	{r4, r5, r6, pc}
 800cb2a:	680b      	ldr	r3, [r1, #0]
 800cb2c:	1b5b      	subs	r3, r3, r5
 800cb2e:	d419      	bmi.n	800cb64 <_malloc_r+0x94>
 800cb30:	2b0b      	cmp	r3, #11
 800cb32:	d903      	bls.n	800cb3c <_malloc_r+0x6c>
 800cb34:	600b      	str	r3, [r1, #0]
 800cb36:	18cc      	adds	r4, r1, r3
 800cb38:	6025      	str	r5, [r4, #0]
 800cb3a:	e003      	b.n	800cb44 <_malloc_r+0x74>
 800cb3c:	684b      	ldr	r3, [r1, #4]
 800cb3e:	428c      	cmp	r4, r1
 800cb40:	d10d      	bne.n	800cb5e <_malloc_r+0x8e>
 800cb42:	6013      	str	r3, [r2, #0]
 800cb44:	0030      	movs	r0, r6
 800cb46:	f000 f834 	bl	800cbb2 <__malloc_unlock>
 800cb4a:	0020      	movs	r0, r4
 800cb4c:	2207      	movs	r2, #7
 800cb4e:	300b      	adds	r0, #11
 800cb50:	1d23      	adds	r3, r4, #4
 800cb52:	4390      	bics	r0, r2
 800cb54:	1ac3      	subs	r3, r0, r3
 800cb56:	d0e7      	beq.n	800cb28 <_malloc_r+0x58>
 800cb58:	425a      	negs	r2, r3
 800cb5a:	50e2      	str	r2, [r4, r3]
 800cb5c:	e7e4      	b.n	800cb28 <_malloc_r+0x58>
 800cb5e:	6063      	str	r3, [r4, #4]
 800cb60:	000c      	movs	r4, r1
 800cb62:	e7ef      	b.n	800cb44 <_malloc_r+0x74>
 800cb64:	000c      	movs	r4, r1
 800cb66:	6849      	ldr	r1, [r1, #4]
 800cb68:	e7c3      	b.n	800caf2 <_malloc_r+0x22>
 800cb6a:	2303      	movs	r3, #3
 800cb6c:	1cc4      	adds	r4, r0, #3
 800cb6e:	439c      	bics	r4, r3
 800cb70:	42a0      	cmp	r0, r4
 800cb72:	d0e1      	beq.n	800cb38 <_malloc_r+0x68>
 800cb74:	1a21      	subs	r1, r4, r0
 800cb76:	0030      	movs	r0, r6
 800cb78:	f000 f808 	bl	800cb8c <_sbrk_r>
 800cb7c:	1c43      	adds	r3, r0, #1
 800cb7e:	d1db      	bne.n	800cb38 <_malloc_r+0x68>
 800cb80:	e7c7      	b.n	800cb12 <_malloc_r+0x42>
 800cb82:	46c0      	nop			; (mov r8, r8)
 800cb84:	200019c8 	.word	0x200019c8
 800cb88:	200019cc 	.word	0x200019cc

0800cb8c <_sbrk_r>:
 800cb8c:	2300      	movs	r3, #0
 800cb8e:	b570      	push	{r4, r5, r6, lr}
 800cb90:	4c06      	ldr	r4, [pc, #24]	; (800cbac <_sbrk_r+0x20>)
 800cb92:	0005      	movs	r5, r0
 800cb94:	0008      	movs	r0, r1
 800cb96:	6023      	str	r3, [r4, #0]
 800cb98:	f000 f80c 	bl	800cbb4 <_sbrk>
 800cb9c:	1c43      	adds	r3, r0, #1
 800cb9e:	d103      	bne.n	800cba8 <_sbrk_r+0x1c>
 800cba0:	6823      	ldr	r3, [r4, #0]
 800cba2:	2b00      	cmp	r3, #0
 800cba4:	d000      	beq.n	800cba8 <_sbrk_r+0x1c>
 800cba6:	602b      	str	r3, [r5, #0]
 800cba8:	bd70      	pop	{r4, r5, r6, pc}
 800cbaa:	46c0      	nop			; (mov r8, r8)
 800cbac:	20001dc4 	.word	0x20001dc4

0800cbb0 <__malloc_lock>:
 800cbb0:	4770      	bx	lr

0800cbb2 <__malloc_unlock>:
 800cbb2:	4770      	bx	lr

0800cbb4 <_sbrk>:
 800cbb4:	4b05      	ldr	r3, [pc, #20]	; (800cbcc <_sbrk+0x18>)
 800cbb6:	0002      	movs	r2, r0
 800cbb8:	6819      	ldr	r1, [r3, #0]
 800cbba:	2900      	cmp	r1, #0
 800cbbc:	d101      	bne.n	800cbc2 <_sbrk+0xe>
 800cbbe:	4904      	ldr	r1, [pc, #16]	; (800cbd0 <_sbrk+0x1c>)
 800cbc0:	6019      	str	r1, [r3, #0]
 800cbc2:	6818      	ldr	r0, [r3, #0]
 800cbc4:	1882      	adds	r2, r0, r2
 800cbc6:	601a      	str	r2, [r3, #0]
 800cbc8:	4770      	bx	lr
 800cbca:	46c0      	nop			; (mov r8, r8)
 800cbcc:	200019d0 	.word	0x200019d0
 800cbd0:	20001dc8 	.word	0x20001dc8

0800cbd4 <_init>:
 800cbd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800cbd6:	46c0      	nop			; (mov r8, r8)
 800cbd8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800cbda:	bc08      	pop	{r3}
 800cbdc:	469e      	mov	lr, r3
 800cbde:	4770      	bx	lr

0800cbe0 <_fini>:
 800cbe0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800cbe2:	46c0      	nop			; (mov r8, r8)
 800cbe4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800cbe6:	bc08      	pop	{r3}
 800cbe8:	469e      	mov	lr, r3
 800cbea:	4770      	bx	lr
