
STM32F072RB-Nucleo_MB1303_Provider_PD30.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000c5fc  080000c0  080000c0  000100c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000001cc  0800c6bc  0800c6bc  0001c6bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  0800c888  0800c888  0001c888  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  0800c88c  0800c88c  0001c88c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         000002a8  20000000  0800c890  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00001a44  200002a8  0800cb38  000202a8  2**2
                  ALLOC
  7 ._user_heap_stack 00000804  20001cec  0800cb38  00021cec  2**0
                  ALLOC
  8 .ARM.attributes 0000002e  00000000  00000000  000202a8  2**0
                  CONTENTS, READONLY
  9 .debug_line   000206e1  00000000  00000000  000202d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00041abe  00000000  00000000  000409b7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000077dc  00000000  00000000  00082475  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00001c18  00000000  00000000  00089c58  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000a0739  00000000  00000000  0008b870  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00002798  00000000  00000000  0012bfb0  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00015dd3  00000000  00000000  0012e748  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  000204b7  00000000  00000000  0014451b  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      00000f98  00000000  00000000  001649d2  2**0
                  CONTENTS, READONLY
 18 .iar.rtmodel  000000c9  00000000  00000000  0016596a  2**0
                  CONTENTS, READONLY
 19 .iar_vfe_header 0000000c  00000000  00000000  00165a34  2**2
                  CONTENTS, READONLY
 20 .debug_frame  00006e28  00000000  00000000  00165a40  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	200002a8 	.word	0x200002a8
 80000e0:	00000000 	.word	0x00000000
 80000e4:	0800c6a4 	.word	0x0800c6a4

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	200002ac 	.word	0x200002ac
 8000104:	0800c6a4 	.word	0x0800c6a4

08000108 <USBPD_CAD_Init>:
 8000108:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800010a:	0007      	movs	r7, r0
 800010c:	000c      	movs	r4, r1
 800010e:	0015      	movs	r5, r2
 8000110:	001e      	movs	r6, r3
 8000112:	2801      	cmp	r0, #1
 8000114:	d830      	bhi.n	8000178 <USBPD_CAD_Init+0x70>
 8000116:	200c      	movs	r0, #12
 8000118:	f00c fa26 	bl	800c568 <malloc>
 800011c:	0002      	movs	r2, r0
 800011e:	4841      	ldr	r0, [pc, #260]	; (8000224 <.text_6>)
 8000120:	00b9      	lsls	r1, r7, #2
 8000122:	1841      	adds	r1, r0, r1
 8000124:	604a      	str	r2, [r1, #4]
 8000126:	2a00      	cmp	r2, #0
 8000128:	d101      	bne.n	800012e <USBPD_CAD_Init+0x26>
 800012a:	2003      	movs	r0, #3
 800012c:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 800012e:	9600      	str	r6, [sp, #0]
 8000130:	2300      	movs	r3, #0
 8000132:	2600      	movs	r6, #0
 8000134:	c248      	stmia	r2!, {r3, r6}
 8000136:	6013      	str	r3, [r2, #0]
 8000138:	7802      	ldrb	r2, [r0, #0]
 800013a:	1c52      	adds	r2, r2, #1
 800013c:	7002      	strb	r2, [r0, #0]
 800013e:	6848      	ldr	r0, [r1, #4]
 8000140:	9900      	ldr	r1, [sp, #0]
 8000142:	6001      	str	r1, [r0, #0]
 8000144:	7103      	strb	r3, [r0, #4]
 8000146:	6084      	str	r4, [r0, #8]
 8000148:	4837      	ldr	r0, [pc, #220]	; (8000228 <.text_7>)
 800014a:	6882      	ldr	r2, [r0, #8]
 800014c:	2301      	movs	r3, #1
 800014e:	6083      	str	r3, [r0, #8]
 8000150:	6881      	ldr	r1, [r0, #8]
 8000152:	2900      	cmp	r1, #0
 8000154:	d1fc      	bne.n	8000150 <USBPD_CAD_Init+0x48>
 8000156:	0029      	movs	r1, r5
 8000158:	4d34      	ldr	r5, [pc, #208]	; (800022c <.text_8>)
 800015a:	6005      	str	r5, [r0, #0]
 800015c:	6805      	ldr	r5, [r0, #0]
 800015e:	4e34      	ldr	r6, [pc, #208]	; (8000230 <.text_9>)
 8000160:	6035      	str	r5, [r6, #0]
 8000162:	6082      	str	r2, [r0, #8]
 8000164:	6882      	ldr	r2, [r0, #8]
 8000166:	4313      	orrs	r3, r2
 8000168:	6083      	str	r3, [r0, #8]
 800016a:	6863      	ldr	r3, [r4, #4]
 800016c:	9a00      	ldr	r2, [sp, #0]
 800016e:	0038      	movs	r0, r7
 8000170:	f009 f8a2 	bl	80092b8 <CAD_Init>
 8000174:	2000      	movs	r0, #0
 8000176:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 8000178:	2001      	movs	r0, #1
 800017a:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

0800017c <USBPD_CAD_PortEnable>:
 800017c:	2802      	cmp	r0, #2
 800017e:	d204      	bcs.n	800018a <USBPD_CAD_PortEnable+0xe>
 8000180:	4a28      	ldr	r2, [pc, #160]	; (8000224 <.text_6>)
 8000182:	0080      	lsls	r0, r0, #2
 8000184:	1810      	adds	r0, r2, r0
 8000186:	6840      	ldr	r0, [r0, #4]
 8000188:	7101      	strb	r1, [r0, #4]
 800018a:	4770      	bx	lr

0800018c <USBPD_CAD_Process>:
 800018c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800018e:	b084      	sub	sp, #16
 8000190:	a802      	add	r0, sp, #8
 8000192:	bf00      	nop
 8000194:	a132      	add	r1, pc, #200	; (adr r1, 8000260 <.text_14>)
 8000196:	c90c      	ldmia	r1!, {r2, r3}
 8000198:	c00c      	stmia	r0!, {r2, r3}
 800019a:	2400      	movs	r4, #0
 800019c:	4d22      	ldr	r5, [pc, #136]	; (8000228 <.text_7>)
 800019e:	4e21      	ldr	r6, [pc, #132]	; (8000224 <.text_6>)
 80001a0:	e031      	b.n	8000206 <USBPD_CAD_Process+0x7a>
 80001a2:	68a8      	ldr	r0, [r5, #8]
 80001a4:	2101      	movs	r1, #1
 80001a6:	60a9      	str	r1, [r5, #8]
 80001a8:	68aa      	ldr	r2, [r5, #8]
 80001aa:	2a00      	cmp	r2, #0
 80001ac:	d1fc      	bne.n	80001a8 <USBPD_CAD_Process+0x1c>
 80001ae:	4a1f      	ldr	r2, [pc, #124]	; (800022c <.text_8>)
 80001b0:	602a      	str	r2, [r5, #0]
 80001b2:	4a1f      	ldr	r2, [pc, #124]	; (8000230 <.text_9>)
 80001b4:	682b      	ldr	r3, [r5, #0]
 80001b6:	6013      	str	r3, [r2, #0]
 80001b8:	60a8      	str	r0, [r5, #8]
 80001ba:	68a8      	ldr	r0, [r5, #8]
 80001bc:	4301      	orrs	r1, r0
 80001be:	60a9      	str	r1, [r5, #8]
 80001c0:	e018      	b.n	80001f4 <USBPD_CAD_Process+0x68>
 80001c2:	0620      	lsls	r0, r4, #24
 80001c4:	0d80      	lsrs	r0, r0, #22
 80001c6:	9001      	str	r0, [sp, #4]
 80001c8:	1d30      	adds	r0, r6, #4
 80001ca:	9901      	ldr	r1, [sp, #4]
 80001cc:	1847      	adds	r7, r0, r1
 80001ce:	6838      	ldr	r0, [r7, #0]
 80001d0:	7900      	ldrb	r0, [r0, #4]
 80001d2:	2801      	cmp	r0, #1
 80001d4:	d116      	bne.n	8000204 <USBPD_CAD_Process+0x78>
 80001d6:	aa00      	add	r2, sp, #0
 80001d8:	1c52      	adds	r2, r2, #1
 80001da:	4669      	mov	r1, sp
 80001dc:	b2e0      	uxtb	r0, r4
 80001de:	f00a ff27 	bl	800b030 <CAD_StateMachine>
 80001e2:	a902      	add	r1, sp, #8
 80001e4:	9a01      	ldr	r2, [sp, #4]
 80001e6:	5088      	str	r0, [r1, r2]
 80001e8:	4668      	mov	r0, sp
 80001ea:	7800      	ldrb	r0, [r0, #0]
 80001ec:	2800      	cmp	r0, #0
 80001ee:	d009      	beq.n	8000204 <USBPD_CAD_Process+0x78>
 80001f0:	2801      	cmp	r0, #1
 80001f2:	d0d6      	beq.n	80001a2 <USBPD_CAD_Process+0x16>
 80001f4:	4668      	mov	r0, sp
 80001f6:	7842      	ldrb	r2, [r0, #1]
 80001f8:	7801      	ldrb	r1, [r0, #0]
 80001fa:	b2e0      	uxtb	r0, r4
 80001fc:	683b      	ldr	r3, [r7, #0]
 80001fe:	689b      	ldr	r3, [r3, #8]
 8000200:	681b      	ldr	r3, [r3, #0]
 8000202:	4798      	blx	r3
 8000204:	1c64      	adds	r4, r4, #1
 8000206:	7830      	ldrb	r0, [r6, #0]
 8000208:	b2e1      	uxtb	r1, r4
 800020a:	4281      	cmp	r1, r0
 800020c:	d3d9      	bcc.n	80001c2 <USBPD_CAD_Process+0x36>
 800020e:	2801      	cmp	r0, #1
 8000210:	d101      	bne.n	8000216 <USBPD_CAD_Process+0x8a>
 8000212:	9802      	ldr	r0, [sp, #8]
 8000214:	e004      	b.n	8000220 <USBPD_CAD_Process+0x94>
 8000216:	9803      	ldr	r0, [sp, #12]
 8000218:	9902      	ldr	r1, [sp, #8]
 800021a:	4288      	cmp	r0, r1
 800021c:	d300      	bcc.n	8000220 <USBPD_CAD_Process+0x94>
 800021e:	4608      	mov	r0, r1
 8000220:	b005      	add	sp, #20
 8000222:	bdf0      	pop	{r4, r5, r6, r7, pc}

08000224 <.text_6>:
 8000224:	200019a0 	.word	0x200019a0

08000228 <.text_7>:
 8000228:	40023000 	.word	0x40023000

0800022c <.text_8>:
 800022c:	f407a5c2 	.word	0xf407a5c2

08000230 <.text_9>:
 8000230:	200019bc 	.word	0x200019bc

08000234 <USBPD_CAD_AssertRd>:
 8000234:	b510      	push	{r4, lr}
 8000236:	0004      	movs	r4, r0
 8000238:	f00a f8a3 	bl	800a382 <USBPDM1_DeAssertRp>
 800023c:	0020      	movs	r0, r4
 800023e:	f00a f8a1 	bl	800a384 <USBPDM1_AssertRd>
 8000242:	bd10      	pop	{r4, pc}

08000244 <USBPD_CAD_AssertRp>:
 8000244:	b510      	push	{r4, lr}
 8000246:	0004      	movs	r4, r0
 8000248:	f00a f89d 	bl	800a386 <USBPDM1_DeAssertRd>
 800024c:	0020      	movs	r0, r4
 800024e:	f00a f897 	bl	800a380 <USBPDM1_AssertRp>
 8000252:	bd10      	pop	{r4, pc}

08000254 <USBPD_CAD_EnterErrorRecovery>:
 8000254:	b580      	push	{r7, lr}
 8000256:	f009 f853 	bl	8009300 <CAD_Enter_ErrorRecovery>
 800025a:	bd01      	pop	{r0, pc}

0800025c <USBPD_CAD_GetMemoryConsumption>:
 800025c:	2018      	movs	r0, #24
 800025e:	4770      	bx	lr

08000260 <.text_14>:
 8000260:	00000002 	.word	0x00000002
 8000264:	00000002 	.word	0x00000002

08000268 <USBPD_PE_Init>:
 8000268:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
 800026a:	b083      	sub	sp, #12
 800026c:	0017      	movs	r7, r2
 800026e:	001d      	movs	r5, r3
 8000270:	4668      	mov	r0, sp
 8000272:	7b06      	ldrb	r6, [r0, #12]
 8000274:	2e01      	cmp	r6, #1
 8000276:	d838      	bhi.n	80002ea <USBPD_PE_Init+0x82>
 8000278:	20e6      	movs	r0, #230	; 0xe6
 800027a:	0080      	lsls	r0, r0, #2
 800027c:	f00c f974 	bl	800c568 <malloc>
 8000280:	499b      	ldr	r1, [pc, #620]	; (80004f0 <.text_10>)
 8000282:	466a      	mov	r2, sp
 8000284:	7b12      	ldrb	r2, [r2, #12]
 8000286:	0092      	lsls	r2, r2, #2
 8000288:	5088      	str	r0, [r1, r2]
 800028a:	0004      	movs	r4, r0
 800028c:	d101      	bne.n	8000292 <USBPD_PE_Init+0x2a>
 800028e:	2016      	movs	r0, #22
 8000290:	e073      	b.n	800037a <USBPD_PE_Init+0x112>
 8000292:	9500      	str	r5, [sp, #0]
 8000294:	9d04      	ldr	r5, [sp, #16]
 8000296:	21e6      	movs	r1, #230	; 0xe6
 8000298:	0089      	lsls	r1, r1, #2
 800029a:	f00c f935 	bl	800c508 <__aeabi_memclr>
 800029e:	6025      	str	r5, [r4, #0]
 80002a0:	6067      	str	r7, [r4, #4]
 80002a2:	2701      	movs	r7, #1
 80002a4:	68e0      	ldr	r0, [r4, #12]
 80002a6:	43b8      	bics	r0, r7
 80002a8:	403e      	ands	r6, r7
 80002aa:	4306      	orrs	r6, r0
 80002ac:	60e6      	str	r6, [r4, #12]
 80002ae:	9800      	ldr	r0, [sp, #0]
 80002b0:	60a0      	str	r0, [r4, #8]
 80002b2:	2600      	movs	r6, #0
 80002b4:	498f      	ldr	r1, [pc, #572]	; (80004f4 <.text_11>)
 80002b6:	1861      	adds	r1, r4, r1
 80002b8:	704e      	strb	r6, [r1, #1]
 80002ba:	6820      	ldr	r0, [r4, #0]
 80002bc:	6801      	ldr	r1, [r0, #0]
 80002be:	9102      	str	r1, [sp, #8]
 80002c0:	498d      	ldr	r1, [pc, #564]	; (80004f8 <.text_12>)
 80002c2:	1861      	adds	r1, r4, r1
 80002c4:	9101      	str	r1, [sp, #4]
 80002c6:	0021      	movs	r1, r4
 80002c8:	3136      	adds	r1, #54	; 0x36
 80002ca:	9100      	str	r1, [sp, #0]
 80002cc:	7900      	ldrb	r0, [r0, #4]
 80002ce:	0880      	lsrs	r0, r0, #2
 80002d0:	2301      	movs	r3, #1
 80002d2:	4003      	ands	r3, r0
 80002d4:	209d      	movs	r0, #157	; 0x9d
 80002d6:	0040      	lsls	r0, r0, #1
 80002d8:	1822      	adds	r2, r4, r0
 80002da:	bf00      	nop
 80002dc:	a128      	add	r1, pc, #160	; (adr r1, 8000380 <PE_PrlCallbacks>)
 80002de:	4668      	mov	r0, sp
 80002e0:	7b00      	ldrb	r0, [r0, #12]
 80002e2:	f004 fdad 	bl	8004e40 <USBPD_PRL_Init>
 80002e6:	2800      	cmp	r0, #0
 80002e8:	d001      	beq.n	80002ee <USBPD_PE_Init+0x86>
 80002ea:	2002      	movs	r0, #2
 80002ec:	e045      	b.n	800037a <USBPD_PE_Init+0x112>
 80002ee:	68e0      	ldr	r0, [r4, #12]
 80002f0:	4982      	ldr	r1, [pc, #520]	; (80004fc <.text_13>)
 80002f2:	4001      	ands	r1, r0
 80002f4:	60e1      	str	r1, [r4, #12]
 80002f6:	6860      	ldr	r0, [r4, #4]
 80002f8:	9000      	str	r0, [sp, #0]
 80002fa:	7800      	ldrb	r0, [r0, #0]
 80002fc:	2303      	movs	r3, #3
 80002fe:	6821      	ldr	r1, [r4, #0]
 8000300:	7909      	ldrb	r1, [r1, #4]
 8000302:	088a      	lsrs	r2, r1, #2
 8000304:	423a      	tst	r2, r7
 8000306:	d00c      	beq.n	8000322 <USBPD_PE_Init+0xba>
 8000308:	2108      	movs	r1, #8
 800030a:	4301      	orrs	r1, r0
 800030c:	9800      	ldr	r0, [sp, #0]
 800030e:	7001      	strb	r1, [r0, #0]
 8000310:	7928      	ldrb	r0, [r5, #4]
 8000312:	4003      	ands	r3, r0
 8000314:	2201      	movs	r2, #1
 8000316:	2101      	movs	r1, #1
 8000318:	4668      	mov	r0, sp
 800031a:	7b00      	ldrb	r0, [r0, #12]
 800031c:	f004 fde4 	bl	8004ee8 <USBPD_PRL_SetHeader>
 8000320:	e017      	b.n	8000352 <USBPD_PE_Init+0xea>
 8000322:	21f7      	movs	r1, #247	; 0xf7
 8000324:	4001      	ands	r1, r0
 8000326:	9800      	ldr	r0, [sp, #0]
 8000328:	7001      	strb	r1, [r0, #0]
 800032a:	4872      	ldr	r0, [pc, #456]	; (80004f4 <.text_11>)
 800032c:	5426      	strb	r6, [r4, r0]
 800032e:	7928      	ldrb	r0, [r5, #4]
 8000330:	4003      	ands	r3, r0
 8000332:	2200      	movs	r2, #0
 8000334:	2100      	movs	r1, #0
 8000336:	4668      	mov	r0, sp
 8000338:	7b00      	ldrb	r0, [r0, #12]
 800033a:	f004 fdd5 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800033e:	0638      	lsls	r0, r7, #24
 8000340:	9001      	str	r0, [sp, #4]
 8000342:	2304      	movs	r3, #4
 8000344:	aa01      	add	r2, sp, #4
 8000346:	2106      	movs	r1, #6
 8000348:	4668      	mov	r0, sp
 800034a:	7b00      	ldrb	r0, [r0, #12]
 800034c:	68a5      	ldr	r5, [r4, #8]
 800034e:	69ed      	ldr	r5, [r5, #28]
 8000350:	47a8      	blx	r5
 8000352:	6820      	ldr	r0, [r4, #0]
 8000354:	7900      	ldrb	r0, [r0, #4]
 8000356:	0880      	lsrs	r0, r0, #2
 8000358:	4007      	ands	r7, r0
 800035a:	0039      	movs	r1, r7
 800035c:	4668      	mov	r0, sp
 800035e:	7b00      	ldrb	r0, [r0, #12]
 8000360:	f004 fddf 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8000364:	6860      	ldr	r0, [r4, #4]
 8000366:	7841      	ldrb	r1, [r0, #1]
 8000368:	228f      	movs	r2, #143	; 0x8f
 800036a:	400a      	ands	r2, r1
 800036c:	7042      	strb	r2, [r0, #1]
 800036e:	6860      	ldr	r0, [r4, #4]
 8000370:	6801      	ldr	r1, [r0, #0]
 8000372:	2210      	movs	r2, #16
 8000374:	4391      	bics	r1, r2
 8000376:	6001      	str	r1, [r0, #0]
 8000378:	2000      	movs	r0, #0
 800037a:	b005      	add	sp, #20
 800037c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08000380 <PE_PrlCallbacks>:
 8000380:	4463 0800 4481 0800 4139 0800 418d 0800     cD...D..9A...A..

08000390 <USBPD_PE_SetTrace>:
 8000390:	4a5b      	ldr	r2, [pc, #364]	; (8000500 <.text_14>)
 8000392:	60d0      	str	r0, [r2, #12]
 8000394:	7011      	strb	r1, [r2, #0]
 8000396:	4770      	bx	lr

08000398 <USBPD_PE_CheckLIB>:
 8000398:	495a      	ldr	r1, [pc, #360]	; (8000504 <.text_15>)
 800039a:	4288      	cmp	r0, r1
 800039c:	d101      	bne.n	80003a2 <USBPD_PE_CheckLIB+0xa>
 800039e:	2001      	movs	r0, #1
 80003a0:	4770      	bx	lr
 80003a2:	2000      	movs	r0, #0
 80003a4:	4770      	bx	lr

080003a6 <USBPD_PE_GetMemoryConsumption>:
 80003a6:	b510      	push	{r4, lr}
 80003a8:	f004 fd9c 	bl	8004ee4 <USBPD_PRL_GetMemoryConsumption>
 80003ac:	0004      	movs	r4, r0
 80003ae:	f7ff ff55 	bl	800025c <USBPD_CAD_GetMemoryConsumption>
 80003b2:	1820      	adds	r0, r4, r0
 80003b4:	21e6      	movs	r1, #230	; 0xe6
 80003b6:	00c9      	lsls	r1, r1, #3
 80003b8:	1840      	adds	r0, r0, r1
 80003ba:	bd10      	pop	{r4, pc}

080003bc <USBPD_PE_TimerCounter>:
 80003bc:	b081      	sub	sp, #4
 80003be:	4950      	ldr	r1, [pc, #320]	; (8000500 <.text_14>)
 80003c0:	0080      	lsls	r0, r0, #2
 80003c2:	1808      	adds	r0, r1, r0
 80003c4:	6840      	ldr	r0, [r0, #4]
 80003c6:	21d9      	movs	r1, #217	; 0xd9
 80003c8:	0089      	lsls	r1, r1, #2
 80003ca:	1840      	adds	r0, r0, r1
 80003cc:	494e      	ldr	r1, [pc, #312]	; (8000508 <.text_16>)
 80003ce:	084a      	lsrs	r2, r1, #1
 80003d0:	8b43      	ldrh	r3, [r0, #26]
 80003d2:	4013      	ands	r3, r2
 80003d4:	2b01      	cmp	r3, #1
 80003d6:	db02      	blt.n	80003de <USBPD_PE_TimerCounter+0x22>
 80003d8:	8b43      	ldrh	r3, [r0, #26]
 80003da:	185b      	adds	r3, r3, r1
 80003dc:	8343      	strh	r3, [r0, #26]
 80003de:	8803      	ldrh	r3, [r0, #0]
 80003e0:	4013      	ands	r3, r2
 80003e2:	2b01      	cmp	r3, #1
 80003e4:	db02      	blt.n	80003ec <USBPD_PE_TimerCounter+0x30>
 80003e6:	8803      	ldrh	r3, [r0, #0]
 80003e8:	185b      	adds	r3, r3, r1
 80003ea:	8003      	strh	r3, [r0, #0]
 80003ec:	8843      	ldrh	r3, [r0, #2]
 80003ee:	4013      	ands	r3, r2
 80003f0:	2b01      	cmp	r3, #1
 80003f2:	db02      	blt.n	80003fa <USBPD_PE_TimerCounter+0x3e>
 80003f4:	8843      	ldrh	r3, [r0, #2]
 80003f6:	185b      	adds	r3, r3, r1
 80003f8:	8043      	strh	r3, [r0, #2]
 80003fa:	8883      	ldrh	r3, [r0, #4]
 80003fc:	4013      	ands	r3, r2
 80003fe:	2b01      	cmp	r3, #1
 8000400:	db02      	blt.n	8000408 <USBPD_PE_TimerCounter+0x4c>
 8000402:	8883      	ldrh	r3, [r0, #4]
 8000404:	185b      	adds	r3, r3, r1
 8000406:	8083      	strh	r3, [r0, #4]
 8000408:	88c3      	ldrh	r3, [r0, #6]
 800040a:	4013      	ands	r3, r2
 800040c:	2b01      	cmp	r3, #1
 800040e:	db02      	blt.n	8000416 <USBPD_PE_TimerCounter+0x5a>
 8000410:	88c3      	ldrh	r3, [r0, #6]
 8000412:	185b      	adds	r3, r3, r1
 8000414:	80c3      	strh	r3, [r0, #6]
 8000416:	8903      	ldrh	r3, [r0, #8]
 8000418:	4013      	ands	r3, r2
 800041a:	2b01      	cmp	r3, #1
 800041c:	db02      	blt.n	8000424 <USBPD_PE_TimerCounter+0x68>
 800041e:	8903      	ldrh	r3, [r0, #8]
 8000420:	185b      	adds	r3, r3, r1
 8000422:	8103      	strh	r3, [r0, #8]
 8000424:	8943      	ldrh	r3, [r0, #10]
 8000426:	4013      	ands	r3, r2
 8000428:	2b01      	cmp	r3, #1
 800042a:	db02      	blt.n	8000432 <USBPD_PE_TimerCounter+0x76>
 800042c:	8943      	ldrh	r3, [r0, #10]
 800042e:	185b      	adds	r3, r3, r1
 8000430:	8143      	strh	r3, [r0, #10]
 8000432:	8983      	ldrh	r3, [r0, #12]
 8000434:	4013      	ands	r3, r2
 8000436:	2b01      	cmp	r3, #1
 8000438:	db02      	blt.n	8000440 <USBPD_PE_TimerCounter+0x84>
 800043a:	8983      	ldrh	r3, [r0, #12]
 800043c:	185b      	adds	r3, r3, r1
 800043e:	8183      	strh	r3, [r0, #12]
 8000440:	89c3      	ldrh	r3, [r0, #14]
 8000442:	4013      	ands	r3, r2
 8000444:	2b01      	cmp	r3, #1
 8000446:	db02      	blt.n	800044e <USBPD_PE_TimerCounter+0x92>
 8000448:	89c3      	ldrh	r3, [r0, #14]
 800044a:	185b      	adds	r3, r3, r1
 800044c:	81c3      	strh	r3, [r0, #14]
 800044e:	8a43      	ldrh	r3, [r0, #18]
 8000450:	4013      	ands	r3, r2
 8000452:	2b01      	cmp	r3, #1
 8000454:	db02      	blt.n	800045c <USBPD_PE_TimerCounter+0xa0>
 8000456:	8a43      	ldrh	r3, [r0, #18]
 8000458:	185b      	adds	r3, r3, r1
 800045a:	8243      	strh	r3, [r0, #18]
 800045c:	8a83      	ldrh	r3, [r0, #20]
 800045e:	4013      	ands	r3, r2
 8000460:	2b01      	cmp	r3, #1
 8000462:	db02      	blt.n	800046a <USBPD_PE_TimerCounter+0xae>
 8000464:	8a83      	ldrh	r3, [r0, #20]
 8000466:	185b      	adds	r3, r3, r1
 8000468:	8283      	strh	r3, [r0, #20]
 800046a:	8ac3      	ldrh	r3, [r0, #22]
 800046c:	4013      	ands	r3, r2
 800046e:	2b01      	cmp	r3, #1
 8000470:	db02      	blt.n	8000478 <USBPD_PE_TimerCounter+0xbc>
 8000472:	8ac3      	ldrh	r3, [r0, #22]
 8000474:	185b      	adds	r3, r3, r1
 8000476:	82c3      	strh	r3, [r0, #22]
 8000478:	8a03      	ldrh	r3, [r0, #16]
 800047a:	4013      	ands	r3, r2
 800047c:	2b01      	cmp	r3, #1
 800047e:	db02      	blt.n	8000486 <USBPD_PE_TimerCounter+0xca>
 8000480:	8a03      	ldrh	r3, [r0, #16]
 8000482:	185b      	adds	r3, r3, r1
 8000484:	8203      	strh	r3, [r0, #16]
 8000486:	8b03      	ldrh	r3, [r0, #24]
 8000488:	4013      	ands	r3, r2
 800048a:	2b01      	cmp	r3, #1
 800048c:	db02      	blt.n	8000494 <USBPD_PE_TimerCounter+0xd8>
 800048e:	8b03      	ldrh	r3, [r0, #24]
 8000490:	185b      	adds	r3, r3, r1
 8000492:	8303      	strh	r3, [r0, #24]
 8000494:	8b83      	ldrh	r3, [r0, #28]
 8000496:	4013      	ands	r3, r2
 8000498:	2b01      	cmp	r3, #1
 800049a:	db02      	blt.n	80004a2 <USBPD_PE_TimerCounter+0xe6>
 800049c:	8b83      	ldrh	r3, [r0, #28]
 800049e:	185b      	adds	r3, r3, r1
 80004a0:	8383      	strh	r3, [r0, #28]
 80004a2:	8bc3      	ldrh	r3, [r0, #30]
 80004a4:	401a      	ands	r2, r3
 80004a6:	2a01      	cmp	r2, #1
 80004a8:	db02      	blt.n	80004b0 <USBPD_PE_TimerCounter+0xf4>
 80004aa:	8bc2      	ldrh	r2, [r0, #30]
 80004ac:	1851      	adds	r1, r2, r1
 80004ae:	83c1      	strh	r1, [r0, #30]
 80004b0:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80004b2:	1c49      	adds	r1, r1, #1
 80004b4:	6241      	str	r1, [r0, #36]	; 0x24
 80004b6:	b001      	add	sp, #4
 80004b8:	4770      	bx	lr

080004ba <USBPD_PE_IsCableConnected>:
 80004ba:	b538      	push	{r3, r4, r5, lr}
 80004bc:	000c      	movs	r4, r1
 80004be:	490c      	ldr	r1, [pc, #48]	; (80004f0 <.text_10>)
 80004c0:	0082      	lsls	r2, r0, #2
 80004c2:	588d      	ldr	r5, [r1, r2]
 80004c4:	2100      	movs	r1, #0
 80004c6:	f003 fe62 	bl	800418e <PE_Reset>
 80004ca:	6868      	ldr	r0, [r5, #4]
 80004cc:	6801      	ldr	r1, [r0, #0]
 80004ce:	2c01      	cmp	r4, #1
 80004d0:	d104      	bne.n	80004dc <USBPD_PE_IsCableConnected+0x22>
 80004d2:	2280      	movs	r2, #128	; 0x80
 80004d4:	0112      	lsls	r2, r2, #4
 80004d6:	430a      	orrs	r2, r1
 80004d8:	6002      	str	r2, [r0, #0]
 80004da:	e006      	b.n	80004ea <USBPD_PE_IsCableConnected+0x30>
 80004dc:	4a07      	ldr	r2, [pc, #28]	; (80004fc <.text_13>)
 80004de:	400a      	ands	r2, r1
 80004e0:	6002      	str	r2, [r0, #0]
 80004e2:	2000      	movs	r0, #0
 80004e4:	21d6      	movs	r1, #214	; 0xd6
 80004e6:	0089      	lsls	r1, r1, #2
 80004e8:	5468      	strb	r0, [r5, r1]
 80004ea:	2000      	movs	r0, #0
 80004ec:	bd32      	pop	{r1, r4, r5, pc}
	...

080004f0 <.text_10>:
 80004f0:	200019b0 	.word	0x200019b0

080004f4 <.text_11>:
 80004f4:	00000357 	.word	0x00000357

080004f8 <.text_12>:
 80004f8:	0000034a 	.word	0x0000034a

080004fc <.text_13>:
 80004fc:	fffff7ff 	.word	0xfffff7ff

08000500 <.text_14>:
 8000500:	200019ac 	.word	0x200019ac

08000504 <.text_15>:
 8000504:	30210001 	.word	0x30210001

08000508 <.text_16>:
 8000508:	0000ffff 	.word	0x0000ffff

0800050c <USBPD_PE_StateMachine_SRC>:
 800050c:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 800050e:	b08a      	sub	sp, #40	; 0x28
 8000510:	48b5      	ldr	r0, [pc, #724]	; (80007e8 <__iar_annotation$$branch+0xc>)
 8000512:	a90a      	add	r1, sp, #40	; 0x28
 8000514:	7809      	ldrb	r1, [r1, #0]
 8000516:	0089      	lsls	r1, r1, #2
 8000518:	1840      	adds	r0, r0, r1
 800051a:	6844      	ldr	r4, [r0, #4]
 800051c:	2000      	movs	r0, #0
 800051e:	9008      	str	r0, [sp, #32]
 8000520:	20d9      	movs	r0, #217	; 0xd9
 8000522:	0080      	lsls	r0, r0, #2
 8000524:	1820      	adds	r0, r4, r0
 8000526:	9004      	str	r0, [sp, #16]
 8000528:	6a46      	ldr	r6, [r0, #36]	; 0x24
 800052a:	8807      	ldrh	r7, [r0, #0]
 800052c:	4668      	mov	r0, sp
 800052e:	9904      	ldr	r1, [sp, #16]
 8000530:	8849      	ldrh	r1, [r1, #2]
 8000532:	8281      	strh	r1, [r0, #20]
 8000534:	9904      	ldr	r1, [sp, #16]
 8000536:	8889      	ldrh	r1, [r1, #4]
 8000538:	81c1      	strh	r1, [r0, #14]
 800053a:	9904      	ldr	r1, [sp, #16]
 800053c:	88c9      	ldrh	r1, [r1, #6]
 800053e:	8141      	strh	r1, [r0, #10]
 8000540:	9904      	ldr	r1, [sp, #16]
 8000542:	8909      	ldrh	r1, [r1, #8]
 8000544:	8101      	strh	r1, [r0, #8]
 8000546:	9904      	ldr	r1, [sp, #16]
 8000548:	8949      	ldrh	r1, [r1, #10]
 800054a:	80c1      	strh	r1, [r0, #6]
 800054c:	9904      	ldr	r1, [sp, #16]
 800054e:	8989      	ldrh	r1, [r1, #12]
 8000550:	8081      	strh	r1, [r0, #4]
 8000552:	9904      	ldr	r1, [sp, #16]
 8000554:	89c9      	ldrh	r1, [r1, #14]
 8000556:	8041      	strh	r1, [r0, #2]
 8000558:	9904      	ldr	r1, [sp, #16]
 800055a:	89c9      	ldrh	r1, [r1, #14]
 800055c:	8001      	strh	r1, [r0, #0]
 800055e:	9804      	ldr	r0, [sp, #16]
 8000560:	8a00      	ldrh	r0, [r0, #16]
 8000562:	9904      	ldr	r1, [sp, #16]
 8000564:	8a49      	ldrh	r1, [r1, #18]
 8000566:	9a04      	ldr	r2, [sp, #16]
 8000568:	8a92      	ldrh	r2, [r2, #20]
 800056a:	9b04      	ldr	r3, [sp, #16]
 800056c:	8adb      	ldrh	r3, [r3, #22]
 800056e:	9d04      	ldr	r5, [sp, #16]
 8000570:	8c2d      	ldrh	r5, [r5, #32]
 8000572:	0536      	lsls	r6, r6, #20
 8000574:	0d36      	lsrs	r6, r6, #20
 8000576:	19f6      	adds	r6, r6, r7
 8000578:	466f      	mov	r7, sp
 800057a:	8abf      	ldrh	r7, [r7, #20]
 800057c:	19f6      	adds	r6, r6, r7
 800057e:	466f      	mov	r7, sp
 8000580:	89ff      	ldrh	r7, [r7, #14]
 8000582:	19f6      	adds	r6, r6, r7
 8000584:	466f      	mov	r7, sp
 8000586:	897f      	ldrh	r7, [r7, #10]
 8000588:	19f6      	adds	r6, r6, r7
 800058a:	466f      	mov	r7, sp
 800058c:	893f      	ldrh	r7, [r7, #8]
 800058e:	19f6      	adds	r6, r6, r7
 8000590:	466f      	mov	r7, sp
 8000592:	88ff      	ldrh	r7, [r7, #6]
 8000594:	19f6      	adds	r6, r6, r7
 8000596:	466f      	mov	r7, sp
 8000598:	88bf      	ldrh	r7, [r7, #4]
 800059a:	19f6      	adds	r6, r6, r7
 800059c:	466f      	mov	r7, sp
 800059e:	887f      	ldrh	r7, [r7, #2]
 80005a0:	19f6      	adds	r6, r6, r7
 80005a2:	466f      	mov	r7, sp
 80005a4:	883f      	ldrh	r7, [r7, #0]
 80005a6:	19f6      	adds	r6, r6, r7
 80005a8:	1830      	adds	r0, r6, r0
 80005aa:	1840      	adds	r0, r0, r1
 80005ac:	1880      	adds	r0, r0, r2
 80005ae:	18c0      	adds	r0, r0, r3
 80005b0:	0529      	lsls	r1, r5, #20
 80005b2:	0f49      	lsrs	r1, r1, #29
 80005b4:	1840      	adds	r0, r0, r1
 80005b6:	9904      	ldr	r1, [sp, #16]
 80005b8:	8c09      	ldrh	r1, [r1, #32]
 80005ba:	06c9      	lsls	r1, r1, #27
 80005bc:	0ec9      	lsrs	r1, r1, #27
 80005be:	1840      	adds	r0, r0, r1
 80005c0:	b280      	uxth	r0, r0
 80005c2:	9007      	str	r0, [sp, #28]
 80005c4:	0020      	movs	r0, r4
 80005c6:	f003 f9f9 	bl	80039bc <PE_Check_RxEvent>
 80005ca:	4669      	mov	r1, sp
 80005cc:	7308      	strb	r0, [r1, #12]
 80005ce:	2803      	cmp	r0, #3
 80005d0:	d101      	bne.n	80005d6 <USBPD_PE_StateMachine_SRC+0xca>
 80005d2:	2001      	movs	r0, #1
 80005d4:	e254      	b.n	8000a80 <__iar_annotation$$branch+0x88>
 80005d6:	2502      	movs	r5, #2
 80005d8:	20d4      	movs	r0, #212	; 0xd4
 80005da:	0080      	lsls	r0, r0, #2
 80005dc:	1826      	adds	r6, r4, r0
 80005de:	7930      	ldrb	r0, [r6, #4]
 80005e0:	280f      	cmp	r0, #15
 80005e2:	d117      	bne.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 80005e4:	7230      	strb	r0, [r6, #8]
 80005e6:	2000      	movs	r0, #0
 80005e8:	7130      	strb	r0, [r6, #4]
 80005ea:	487f      	ldr	r0, [pc, #508]	; (80007e8 <__iar_annotation$$branch+0xc>)
 80005ec:	68c7      	ldr	r7, [r0, #12]
 80005ee:	2f00      	cmp	r7, #0
 80005f0:	d010      	beq.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 80005f2:	7800      	ldrb	r0, [r0, #0]
 80005f4:	07c0      	lsls	r0, r0, #31
 80005f6:	d50d      	bpl.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 80005f8:	7a30      	ldrb	r0, [r6, #8]
 80005fa:	7a71      	ldrb	r1, [r6, #9]
 80005fc:	4281      	cmp	r1, r0
 80005fe:	d009      	beq.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 8000600:	7270      	strb	r0, [r6, #9]
 8000602:	2000      	movs	r0, #0
 8000604:	9000      	str	r0, [sp, #0]
 8000606:	2300      	movs	r3, #0
 8000608:	7a32      	ldrb	r2, [r6, #8]
 800060a:	7b20      	ldrb	r0, [r4, #12]
 800060c:	07c1      	lsls	r1, r0, #31
 800060e:	0fc9      	lsrs	r1, r1, #31
 8000610:	2004      	movs	r0, #4
 8000612:	47b8      	blx	r7
 8000614:	9807      	ldr	r0, [sp, #28]
 8000616:	2800      	cmp	r0, #0
 8000618:	d006      	beq.n	8000628 <USBPD_PE_StateMachine_SRC+0x11c>
 800061a:	2107      	movs	r1, #7
 800061c:	f005 fb3a 	bl	8005c94 <__aeabi_idivmod>
 8000620:	2900      	cmp	r1, #0
 8000622:	d101      	bne.n	8000628 <USBPD_PE_StateMachine_SRC+0x11c>
 8000624:	2001      	movs	r0, #1
 8000626:	9008      	str	r0, [sp, #32]
 8000628:	496f      	ldr	r1, [pc, #444]	; (80007e8 <__iar_annotation$$branch+0xc>)
 800062a:	7808      	ldrb	r0, [r1, #0]
 800062c:	4028      	ands	r0, r5
 800062e:	68c9      	ldr	r1, [r1, #12]
 8000630:	9101      	str	r1, [sp, #4]
 8000632:	4669      	mov	r1, sp
 8000634:	7b09      	ldrb	r1, [r1, #12]
 8000636:	7a32      	ldrb	r2, [r6, #8]
 8000638:	2a00      	cmp	r2, #0
 800063a:	d100      	bne.n	800063e <USBPD_PE_StateMachine_SRC+0x132>
 800063c:	e0eb      	b.n	8000816 <__iar_annotation$$branch+0x3a>
 800063e:	1e52      	subs	r2, r2, #1
 8000640:	d100      	bne.n	8000644 <USBPD_PE_StateMachine_SRC+0x138>
 8000642:	e0a8      	b.n	8000796 <__iar_annotation$$branch+0xe>
 8000644:	1e52      	subs	r2, r2, #1
 8000646:	d100      	bne.n	800064a <USBPD_PE_StateMachine_SRC+0x13e>
 8000648:	e0ed      	b.n	8000826 <__iar_annotation$$branch+0x4a>
 800064a:	1e52      	subs	r2, r2, #1
 800064c:	d101      	bne.n	8000652 <__iar_annotation$$branch+0x4>

0800064e <__iar_annotation$$branch>:
 800064e:	f001 f8e6 	bl	800181e <__iar_annotation$$branch+0x250>
 8000652:	1e52      	subs	r2, r2, #1
 8000654:	d101      	bne.n	800065a <__iar_annotation$$branch+0x4>

08000656 <__iar_annotation$$branch>:
 8000656:	f001 f8fc 	bl	8001852 <__iar_annotation$$branch+0x284>
 800065a:	1e52      	subs	r2, r2, #1
 800065c:	d100      	bne.n	8000660 <__iar_annotation$$branch+0xa>
 800065e:	e133      	b.n	80008c8 <__iar_annotation$$branch+0xec>
 8000660:	1e52      	subs	r2, r2, #1
 8000662:	d100      	bne.n	8000666 <__iar_annotation$$branch+0x10>
 8000664:	e214      	b.n	8000a90 <__iar_annotation$$branch+0x98>
 8000666:	1e52      	subs	r2, r2, #1
 8000668:	d100      	bne.n	800066c <__iar_annotation$$branch+0x16>
 800066a:	e219      	b.n	8000aa0 <__iar_annotation$$branch+0xa8>
 800066c:	1e52      	subs	r2, r2, #1
 800066e:	d100      	bne.n	8000672 <__iar_annotation$$branch+0x1c>
 8000670:	e282      	b.n	8000b78 <__iar_annotation$$branch+0x180>
 8000672:	1e52      	subs	r2, r2, #1
 8000674:	d100      	bne.n	8000678 <__iar_annotation$$branch+0x22>
 8000676:	e2ca      	b.n	8000c0e <__iar_annotation$$branch+0x216>
 8000678:	1e52      	subs	r2, r2, #1
 800067a:	2a01      	cmp	r2, #1
 800067c:	d800      	bhi.n	8000680 <__iar_annotation$$branch+0x2a>
 800067e:	e3c3      	b.n	8000e08 <__iar_annotation$$branch+0x410>
 8000680:	1e92      	subs	r2, r2, #2
 8000682:	d100      	bne.n	8000686 <__iar_annotation$$branch+0x30>
 8000684:	e357      	b.n	8000d36 <__iar_annotation$$branch+0x33e>
 8000686:	1e52      	subs	r2, r2, #1
 8000688:	d100      	bne.n	800068c <__iar_annotation$$branch+0x36>
 800068a:	e383      	b.n	8000d94 <__iar_annotation$$branch+0x39c>
 800068c:	1e52      	subs	r2, r2, #1
 800068e:	d100      	bne.n	8000692 <__iar_annotation$$branch+0x3c>
 8000690:	e3b7      	b.n	8000e02 <__iar_annotation$$branch+0x40a>
 8000692:	1e52      	subs	r2, r2, #1
 8000694:	d101      	bne.n	800069a <__iar_annotation$$branch+0x4>

08000696 <__iar_annotation$$branch>:
 8000696:	f000 fc91 	bl	8000fbc <__iar_annotation$$branch+0x5c4>
 800069a:	1e52      	subs	r2, r2, #1
 800069c:	d101      	bne.n	80006a2 <__iar_annotation$$branch+0x4>

0800069e <__iar_annotation$$branch>:
 800069e:	f000 fc21 	bl	8000ee4 <__iar_annotation$$branch+0x4ec>
 80006a2:	1e52      	subs	r2, r2, #1
 80006a4:	d101      	bne.n	80006aa <__iar_annotation$$branch+0x4>

080006a6 <__iar_annotation$$branch>:
 80006a6:	f000 fc3d 	bl	8000f24 <__iar_annotation$$branch+0x52c>
 80006aa:	1e52      	subs	r2, r2, #1
 80006ac:	d101      	bne.n	80006b2 <__iar_annotation$$branch+0x4>

080006ae <__iar_annotation$$branch>:
 80006ae:	f000 fc56 	bl	8000f5e <__iar_annotation$$branch+0x566>
 80006b2:	1e52      	subs	r2, r2, #1
 80006b4:	d101      	bne.n	80006ba <__iar_annotation$$branch+0x4>

080006b6 <__iar_annotation$$branch>:
 80006b6:	f000 fce5 	bl	8001084 <__iar_annotation$$branch+0x68c>
 80006ba:	1e52      	subs	r2, r2, #1
 80006bc:	d101      	bne.n	80006c2 <__iar_annotation$$branch+0x4>

080006be <__iar_annotation$$branch>:
 80006be:	f000 fc9d 	bl	8000ffc <__iar_annotation$$branch+0x604>
 80006c2:	1e52      	subs	r2, r2, #1
 80006c4:	d101      	bne.n	80006ca <__iar_annotation$$branch+0x4>

080006c6 <__iar_annotation$$branch>:
 80006c6:	f000 fcac 	bl	8001022 <__iar_annotation$$branch+0x62a>
 80006ca:	1e52      	subs	r2, r2, #1
 80006cc:	d100      	bne.n	80006d0 <__iar_annotation$$branch+0xa>
 80006ce:	e263      	b.n	8000b98 <__iar_annotation$$branch+0x1a0>
 80006d0:	1e92      	subs	r2, r2, #2
 80006d2:	d101      	bne.n	80006d8 <__iar_annotation$$branch+0x4>

080006d4 <__iar_annotation$$branch>:
 80006d4:	f000 fd2a 	bl	800112c <__iar_annotation$$branch+0x734>
 80006d8:	1e52      	subs	r2, r2, #1
 80006da:	d101      	bne.n	80006e0 <__iar_annotation$$branch+0x4>

080006dc <__iar_annotation$$branch>:
 80006dc:	f000 fd56 	bl	800118c <__iar_annotation$$branch+0x794>
 80006e0:	1e52      	subs	r2, r2, #1
 80006e2:	d101      	bne.n	80006e8 <__iar_annotation$$branch+0x4>

080006e4 <__iar_annotation$$branch>:
 80006e4:	f000 fdcd 	bl	8001282 <__iar_annotation$$branch+0x88a>
 80006e8:	1e52      	subs	r2, r2, #1
 80006ea:	d101      	bne.n	80006f0 <__iar_annotation$$branch+0x4>

080006ec <__iar_annotation$$branch>:
 80006ec:	f000 fde9 	bl	80012c2 <__iar_annotation$$branch+0x8ca>
 80006f0:	1e92      	subs	r2, r2, #2
 80006f2:	d101      	bne.n	80006f8 <__iar_annotation$$branch+0x4>

080006f4 <__iar_annotation$$branch>:
 80006f4:	f001 f869 	bl	80017ca <__iar_annotation$$branch+0x1fc>
 80006f8:	1e52      	subs	r2, r2, #1
 80006fa:	d101      	bne.n	8000700 <__iar_annotation$$branch+0x4>

080006fc <__iar_annotation$$branch>:
 80006fc:	f000 ff69 	bl	80015d2 <__iar_annotation$$branch+0x4>
 8000700:	1e52      	subs	r2, r2, #1
 8000702:	d101      	bne.n	8000708 <__iar_annotation$$branch+0x4>

08000704 <__iar_annotation$$branch>:
 8000704:	f000 ff8e 	bl	8001624 <__iar_annotation$$branch+0x56>
 8000708:	1e52      	subs	r2, r2, #1
 800070a:	d101      	bne.n	8000710 <__iar_annotation$$branch+0x4>

0800070c <__iar_annotation$$branch>:
 800070c:	f001 f814 	bl	8001738 <__iar_annotation$$branch+0x16a>
 8000710:	1e52      	subs	r2, r2, #1
 8000712:	d101      	bne.n	8000718 <__iar_annotation$$branch+0x4>

08000714 <__iar_annotation$$branch>:
 8000714:	f001 f849 	bl	80017aa <__iar_annotation$$branch+0x1dc>
 8000718:	1e52      	subs	r2, r2, #1
 800071a:	d101      	bne.n	8000720 <__iar_annotation$$branch+0x4>

0800071c <__iar_annotation$$branch>:
 800071c:	f000 fe39 	bl	8001392 <__iar_annotation$$branch+0x99a>
 8000720:	1e92      	subs	r2, r2, #2
 8000722:	d101      	bne.n	8000728 <__iar_annotation$$branch+0x4>

08000724 <__iar_annotation$$branch>:
 8000724:	f000 fea0 	bl	8001468 <__iar_annotation$$branch+0xa70>
 8000728:	1e52      	subs	r2, r2, #1
 800072a:	d101      	bne.n	8000730 <__iar_annotation$$branch+0x4>

0800072c <__iar_annotation$$branch>:
 800072c:	f000 fefa 	bl	8001524 <__iar_annotation$$branch+0xb2c>
 8000730:	1e52      	subs	r2, r2, #1
 8000732:	d101      	bne.n	8000738 <__iar_annotation$$branch+0x4>

08000734 <__iar_annotation$$branch>:
 8000734:	f000 ff1a 	bl	800156c <__iar_annotation$$branch+0xb74>
 8000738:	1e52      	subs	r2, r2, #1
 800073a:	d101      	bne.n	8000740 <__iar_annotation$$branch+0x4>

0800073c <__iar_annotation$$branch>:
 800073c:	f000 fcc7 	bl	80010ce <__iar_annotation$$branch+0x6d6>
 8000740:	1e52      	subs	r2, r2, #1
 8000742:	d101      	bne.n	8000748 <__iar_annotation$$branch+0x4>

08000744 <__iar_annotation$$branch>:
 8000744:	f000 fcd1 	bl	80010ea <__iar_annotation$$branch+0x6f2>
 8000748:	1e52      	subs	r2, r2, #1
 800074a:	d101      	bne.n	8000750 <__iar_annotation$$branch+0x4>

0800074c <__iar_annotation$$branch>:
 800074c:	f000 fcda 	bl	8001104 <__iar_annotation$$branch+0x70c>
 8000750:	1e52      	subs	r2, r2, #1
 8000752:	d101      	bne.n	8000758 <__iar_annotation$$branch+0x4>

08000754 <__iar_annotation$$branch>:
 8000754:	f000 fe21 	bl	800139a <__iar_annotation$$branch+0x9a2>
 8000758:	1e52      	subs	r2, r2, #1
 800075a:	d101      	bne.n	8000760 <__iar_annotation$$branch+0x4>

0800075c <__iar_annotation$$branch>:
 800075c:	f001 f9a5 	bl	8001aaa <__iar_annotation$$branch+0xca>
 8000760:	1e52      	subs	r2, r2, #1
 8000762:	d018      	beq.n	8000796 <__iar_annotation$$branch+0xe>
 8000764:	1e52      	subs	r2, r2, #1
 8000766:	d101      	bne.n	800076c <__iar_annotation$$branch+0x4>

08000768 <__iar_annotation$$branch>:
 8000768:	f001 f9ae 	bl	8001ac8 <__iar_annotation$$branch+0xe8>
 800076c:	1e52      	subs	r2, r2, #1
 800076e:	d101      	bne.n	8000774 <__iar_annotation$$branch+0x4>

08000770 <__iar_annotation$$branch>:
 8000770:	f001 f9e6 	bl	8001b40 <__iar_annotation$$branch+0x160>
 8000774:	1e52      	subs	r2, r2, #1
 8000776:	2a01      	cmp	r2, #1
 8000778:	d90d      	bls.n	8000796 <__iar_annotation$$branch+0xe>
 800077a:	1e92      	subs	r2, r2, #2
 800077c:	2a07      	cmp	r2, #7
 800077e:	d801      	bhi.n	8000784 <__iar_annotation$$branch+0x4>

08000780 <__iar_annotation$$branch>:
 8000780:	f001 fa10 	bl	8001ba4 <__iar_annotation$$branch+0x22>
 8000784:	3a08      	subs	r2, #8
 8000786:	d101      	bne.n	800078c <__iar_annotation$$branch+0x4>

08000788 <__iar_annotation$$branch>:
 8000788:	f001 f9fd 	bl	8001b86 <__iar_annotation$$branch+0x4>
 800078c:	1e52      	subs	r2, r2, #1
 800078e:	2a03      	cmp	r2, #3
 8000790:	d901      	bls.n	8000796 <__iar_annotation$$branch+0xe>
 8000792:	3a28      	subs	r2, #40	; 0x28
 8000794:	2a01      	cmp	r2, #1
 8000796:	d801      	bhi.n	800079c <__iar_annotation$$branch+0x4>

08000798 <__iar_annotation$$branch>:
 8000798:	f001 fa09 	bl	8001bae <__iar_annotation$$branch+0x2c>
 800079c:	3a12      	subs	r2, #18
 800079e:	d0fa      	beq.n	8000796 <__iar_annotation$$branch+0xe>
 80007a0:	3a1e      	subs	r2, #30
 80007a2:	d023      	beq.n	80007ec <__iar_annotation$$branch+0x10>
 80007a4:	1e52      	subs	r2, r2, #1
 80007a6:	d101      	bne.n	80007ac <__iar_annotation$$branch+0x4>

080007a8 <__iar_annotation$$branch>:
 80007a8:	f001 f898 	bl	80018dc <__iar_annotation$$branch+0x1e>
 80007ac:	1e52      	subs	r2, r2, #1
 80007ae:	d101      	bne.n	80007b4 <__iar_annotation$$branch+0x4>

080007b0 <__iar_annotation$$branch>:
 80007b0:	f001 f8e0 	bl	8001974 <__iar_annotation$$branch+0xb6>
 80007b4:	1e52      	subs	r2, r2, #1
 80007b6:	d101      	bne.n	80007bc <__iar_annotation$$branch+0x4>

080007b8 <__iar_annotation$$branch>:
 80007b8:	f001 f8fb 	bl	80019b2 <__iar_annotation$$branch+0xf4>
 80007bc:	1e52      	subs	r2, r2, #1
 80007be:	d100      	bne.n	80007c2 <__iar_annotation$$branch+0xa>
 80007c0:	e339      	b.n	8000e36 <__iar_annotation$$branch+0x43e>
 80007c2:	1e52      	subs	r2, r2, #1
 80007c4:	d100      	bne.n	80007c8 <__iar_annotation$$branch+0x10>
 80007c6:	e35c      	b.n	8000e82 <__iar_annotation$$branch+0x48a>
 80007c8:	1e92      	subs	r2, r2, #2
 80007ca:	d101      	bne.n	80007d0 <__iar_annotation$$branch+0x4>

080007cc <__iar_annotation$$branch>:
 80007cc:	f001 fa02 	bl	8001bd4 <__iar_annotation$$branch+0x52>
 80007d0:	1e52      	subs	r2, r2, #1
 80007d2:	d100      	bne.n	80007d6 <__iar_annotation$$branch+0xa>
 80007d4:	e0b9      	b.n	800094a <__iar_annotation$$branch+0x16e>
 80007d6:	1e92      	subs	r2, r2, #2
 80007d8:	2a08      	cmp	r2, #8
 80007da:	d801      	bhi.n	80007e0 <__iar_annotation$$branch+0x4>

080007dc <__iar_annotation$$branch>:
 80007dc:	f001 f9ec 	bl	8001bb8 <__iar_annotation$$branch+0x36>
 80007e0:	3a09      	subs	r2, #9
 80007e2:	d0cc      	beq.n	800077e <__iar_annotation$$branch+0xe>
 80007e4:	e0ee      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80007e6:	bf00      	nop
 80007e8:	200019ac 	.word	0x200019ac
 80007ec:	68a0      	ldr	r0, [r4, #8]
 80007ee:	6b81      	ldr	r1, [r0, #56]	; 0x38
 80007f0:	2900      	cmp	r1, #0
 80007f2:	d003      	beq.n	80007fc <__iar_annotation$$branch+0x20>
 80007f4:	7b22      	ldrb	r2, [r4, #12]
 80007f6:	07d0      	lsls	r0, r2, #31
 80007f8:	0fc0      	lsrs	r0, r0, #31
 80007fa:	4788      	blx	r1
 80007fc:	2014      	movs	r0, #20
 80007fe:	4669      	mov	r1, sp
 8000800:	7308      	strb	r0, [r1, #12]
 8000802:	2101      	movs	r1, #1
 8000804:	a80a      	add	r0, sp, #40	; 0x28
 8000806:	7800      	ldrb	r0, [r0, #0]
 8000808:	f003 fcc1 	bl	800418e <PE_Reset>
 800080c:	a80a      	add	r0, sp, #40	; 0x28
 800080e:	7800      	ldrb	r0, [r0, #0]
 8000810:	f004 fe20 	bl	8005454 <USBPD_PRL_Reset>
 8000814:	e0d6      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000816:	2500      	movs	r5, #0
 8000818:	43ed      	mvns	r5, r5
 800081a:	6860      	ldr	r0, [r4, #4]
 800081c:	6801      	ldr	r1, [r0, #0]
 800081e:	2210      	movs	r2, #16
 8000820:	4391      	bics	r1, r2
 8000822:	6001      	str	r1, [r0, #0]
 8000824:	e0ce      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000826:	6860      	ldr	r0, [r4, #4]
 8000828:	6800      	ldr	r0, [r0, #0]
 800082a:	0340      	lsls	r0, r0, #13
 800082c:	0fc1      	lsrs	r1, r0, #31
 800082e:	a80a      	add	r0, sp, #40	; 0x28
 8000830:	7800      	ldrb	r0, [r0, #0]
 8000832:	f004 fbb2 	bl	8004f9a <USBPD_PRL_CableCapable>
 8000836:	6860      	ldr	r0, [r4, #4]
 8000838:	2701      	movs	r7, #1
 800083a:	6801      	ldr	r1, [r0, #0]
 800083c:	0ac9      	lsrs	r1, r1, #11
 800083e:	4039      	ands	r1, r7
 8000840:	d100      	bne.n	8000844 <__iar_annotation$$branch+0x68>
 8000842:	e170      	b.n	8000b26 <__iar_annotation$$branch+0x12e>
 8000844:	2103      	movs	r1, #3
 8000846:	6822      	ldr	r2, [r4, #0]
 8000848:	7913      	ldrb	r3, [r2, #4]
 800084a:	2203      	movs	r2, #3
 800084c:	401a      	ands	r2, r3
 800084e:	7803      	ldrb	r3, [r0, #0]
 8000850:	25fc      	movs	r5, #252	; 0xfc
 8000852:	401d      	ands	r5, r3
 8000854:	432a      	orrs	r2, r5
 8000856:	7002      	strb	r2, [r0, #0]
 8000858:	6860      	ldr	r0, [r4, #4]
 800085a:	7802      	ldrb	r2, [r0, #0]
 800085c:	4011      	ands	r1, r2
 800085e:	2901      	cmp	r1, #1
 8000860:	d101      	bne.n	8000866 <__iar_annotation$$branch+0x8a>
 8000862:	2100      	movs	r1, #0
 8000864:	e000      	b.n	8000868 <__iar_annotation$$branch+0x8c>
 8000866:	2101      	movs	r1, #1
 8000868:	239f      	movs	r3, #159	; 0x9f
 800086a:	4013      	ands	r3, r2
 800086c:	0149      	lsls	r1, r1, #5
 800086e:	4319      	orrs	r1, r3
 8000870:	7001      	strb	r1, [r0, #0]
 8000872:	2000      	movs	r0, #0
 8000874:	7560      	strb	r0, [r4, #21]
 8000876:	6860      	ldr	r0, [r4, #4]
 8000878:	7841      	ldrb	r1, [r0, #1]
 800087a:	228f      	movs	r2, #143	; 0x8f
 800087c:	400a      	ands	r2, r1
 800087e:	2110      	movs	r1, #16
 8000880:	4311      	orrs	r1, r2
 8000882:	7041      	strb	r1, [r0, #1]
 8000884:	4db3      	ldr	r5, [pc, #716]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000886:	7828      	ldrb	r0, [r5, #0]
 8000888:	0780      	lsls	r0, r0, #30
 800088a:	d509      	bpl.n	80008a0 <__iar_annotation$$branch+0xc4>
 800088c:	2000      	movs	r0, #0
 800088e:	9000      	str	r0, [sp, #0]
 8000890:	2300      	movs	r3, #0
 8000892:	2256      	movs	r2, #86	; 0x56
 8000894:	68e0      	ldr	r0, [r4, #12]
 8000896:	2101      	movs	r1, #1
 8000898:	4001      	ands	r1, r0
 800089a:	2009      	movs	r0, #9
 800089c:	68ed      	ldr	r5, [r5, #12]
 800089e:	47a8      	blx	r5
 80008a0:	2156      	movs	r1, #86	; 0x56
 80008a2:	68e2      	ldr	r2, [r4, #12]
 80008a4:	2001      	movs	r0, #1
 80008a6:	4010      	ands	r0, r2
 80008a8:	68a2      	ldr	r2, [r4, #8]
 80008aa:	68d2      	ldr	r2, [r2, #12]
 80008ac:	4790      	blx	r2
 80008ae:	6860      	ldr	r0, [r4, #4]
 80008b0:	6800      	ldr	r0, [r0, #0]
 80008b2:	0900      	lsrs	r0, r0, #4
 80008b4:	4007      	ands	r7, r0
 80008b6:	d005      	beq.n	80008c4 <__iar_annotation$$branch+0xe8>
 80008b8:	48a7      	ldr	r0, [pc, #668]	; (8000b58 <__iar_annotation$$branch+0x160>)
 80008ba:	84b0      	strh	r0, [r6, #36]	; 0x24
 80008bc:	2514      	movs	r5, #20
 80008be:	2006      	movs	r0, #6
 80008c0:	7230      	strb	r0, [r6, #8]
 80008c2:	e07f      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80008c4:	2005      	movs	r0, #5
 80008c6:	e0e8      	b.n	8000a9a <__iar_annotation$$branch+0xa2>
 80008c8:	2001      	movs	r0, #1
 80008ca:	6861      	ldr	r1, [r4, #4]
 80008cc:	6809      	ldr	r1, [r1, #0]
 80008ce:	0c89      	lsrs	r1, r1, #18
 80008d0:	4001      	ands	r1, r0
 80008d2:	d100      	bne.n	80008d6 <__iar_annotation$$branch+0xfa>
 80008d4:	e0e0      	b.n	8000a98 <__iar_annotation$$branch+0xa0>
 80008d6:	6821      	ldr	r1, [r4, #0]
 80008d8:	7809      	ldrb	r1, [r1, #0]
 80008da:	0789      	lsls	r1, r1, #30
 80008dc:	d400      	bmi.n	80008e0 <__iar_annotation$$branch+0x104>
 80008de:	e0db      	b.n	8000a98 <__iar_annotation$$branch+0xa0>
 80008e0:	21ff      	movs	r1, #255	; 0xff
 80008e2:	1c89      	adds	r1, r1, #2
 80008e4:	82e1      	strh	r1, [r4, #22]
 80008e6:	7831      	ldrb	r1, [r6, #0]
 80008e8:	22e0      	movs	r2, #224	; 0xe0
 80008ea:	400a      	ands	r2, r1
 80008ec:	4310      	orrs	r0, r2
 80008ee:	7030      	strb	r0, [r6, #0]
 80008f0:	7870      	ldrb	r0, [r6, #1]
 80008f2:	2180      	movs	r1, #128	; 0x80
 80008f4:	4301      	orrs	r1, r0
 80008f6:	7071      	strb	r1, [r6, #1]
 80008f8:	6860      	ldr	r0, [r4, #4]
 80008fa:	7800      	ldrb	r0, [r0, #0]
 80008fc:	0640      	lsls	r0, r0, #25
 80008fe:	0f80      	lsrs	r0, r0, #30
 8000900:	6831      	ldr	r1, [r6, #0]
 8000902:	4a96      	ldr	r2, [pc, #600]	; (8000b5c <__iar_annotation$$branch+0x164>)
 8000904:	400a      	ands	r2, r1
 8000906:	0340      	lsls	r0, r0, #13
 8000908:	4310      	orrs	r0, r2
 800090a:	6030      	str	r0, [r6, #0]
 800090c:	4994      	ldr	r1, [pc, #592]	; (8000b60 <__iar_annotation$$branch+0x168>)
 800090e:	4001      	ands	r1, r0
 8000910:	6031      	str	r1, [r6, #0]
 8000912:	7830      	ldrb	r0, [r6, #0]
 8000914:	0680      	lsls	r0, r0, #26
 8000916:	0e80      	lsrs	r0, r0, #26
 8000918:	7030      	strb	r0, [r6, #0]
 800091a:	6830      	ldr	r0, [r6, #0]
 800091c:	b280      	uxth	r0, r0
 800091e:	21ff      	movs	r1, #255	; 0xff
 8000920:	0609      	lsls	r1, r1, #24
 8000922:	4301      	orrs	r1, r0
 8000924:	6031      	str	r1, [r6, #0]
 8000926:	2001      	movs	r0, #1
 8000928:	9002      	str	r0, [sp, #8]
 800092a:	209a      	movs	r0, #154	; 0x9a
 800092c:	9001      	str	r0, [sp, #4]
 800092e:	2001      	movs	r0, #1
 8000930:	9000      	str	r0, [sp, #0]
 8000932:	0033      	movs	r3, r6
 8000934:	220f      	movs	r2, #15
 8000936:	2101      	movs	r1, #1
 8000938:	0020      	movs	r0, r4
 800093a:	f002 ff61 	bl	8003800 <PE_Send_DataMessage>
 800093e:	2800      	cmp	r0, #0
 8000940:	d140      	bne.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000942:	4888      	ldr	r0, [pc, #544]	; (8000b64 <__iar_annotation$$branch+0x16c>)
 8000944:	83b0      	strh	r0, [r6, #28]
 8000946:	251e      	movs	r5, #30
 8000948:	e03c      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 800094a:	2912      	cmp	r1, #18
 800094c:	d136      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 800094e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000950:	0bc0      	lsrs	r0, r0, #15
 8000952:	d133      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 8000954:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000956:	0b00      	lsrs	r0, r0, #12
 8000958:	0740      	lsls	r0, r0, #29
 800095a:	d02f      	beq.n	80009bc <__iar_annotation$$branch+0x1e0>
 800095c:	201f      	movs	r0, #31
 800095e:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000960:	4001      	ands	r1, r0
 8000962:	290f      	cmp	r1, #15
 8000964:	d12a      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 8000966:	219e      	movs	r1, #158	; 0x9e
 8000968:	0049      	lsls	r1, r1, #1
 800096a:	1861      	adds	r1, r4, r1
 800096c:	780a      	ldrb	r2, [r1, #0]
 800096e:	784b      	ldrb	r3, [r1, #1]
 8000970:	021b      	lsls	r3, r3, #8
 8000972:	18d2      	adds	r2, r2, r3
 8000974:	788b      	ldrb	r3, [r1, #2]
 8000976:	041b      	lsls	r3, r3, #16
 8000978:	18d2      	adds	r2, r2, r3
 800097a:	78c9      	ldrb	r1, [r1, #3]
 800097c:	0609      	lsls	r1, r1, #24
 800097e:	1851      	adds	r1, r2, r1
 8000980:	9100      	str	r1, [sp, #0]
 8000982:	4669      	mov	r1, sp
 8000984:	7809      	ldrb	r1, [r1, #0]
 8000986:	4008      	ands	r0, r1
 8000988:	2801      	cmp	r0, #1
 800098a:	d117      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 800098c:	0988      	lsrs	r0, r1, #6
 800098e:	2801      	cmp	r0, #1
 8000990:	d114      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 8000992:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000994:	0440      	lsls	r0, r0, #17
 8000996:	0f40      	lsrs	r0, r0, #29
 8000998:	1e43      	subs	r3, r0, #1
 800099a:	20a0      	movs	r0, #160	; 0xa0
 800099c:	0040      	lsls	r0, r0, #1
 800099e:	1822      	adds	r2, r4, r0
 80009a0:	2113      	movs	r1, #19
 80009a2:	7b27      	ldrb	r7, [r4, #12]
 80009a4:	07f8      	lsls	r0, r7, #31
 80009a6:	0fc0      	lsrs	r0, r0, #31
 80009a8:	68a7      	ldr	r7, [r4, #8]
 80009aa:	69ff      	ldr	r7, [r7, #28]
 80009ac:	47b8      	blx	r7
 80009ae:	2007      	movs	r0, #7
 80009b0:	7230      	strb	r0, [r6, #8]
 80009b2:	2000      	movs	r0, #0
 80009b4:	83b0      	strh	r0, [r6, #28]
 80009b6:	2014      	movs	r0, #20
 80009b8:	4669      	mov	r1, sp
 80009ba:	7308      	strb	r0, [r1, #12]
 80009bc:	8bb0      	ldrh	r0, [r6, #28]
 80009be:	03a9      	lsls	r1, r5, #14
 80009c0:	4288      	cmp	r0, r1
 80009c2:	d05f      	beq.n	8000a84 <__iar_annotation$$branch+0x8c>
 80009c4:	4863      	ldr	r0, [pc, #396]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 80009c6:	68c7      	ldr	r7, [r0, #12]
 80009c8:	2f00      	cmp	r7, #0
 80009ca:	d010      	beq.n	80009ee <__iar_annotation$$branch+0x212>
 80009cc:	7800      	ldrb	r0, [r0, #0]
 80009ce:	07c0      	lsls	r0, r0, #31
 80009d0:	d50d      	bpl.n	80009ee <__iar_annotation$$branch+0x212>
 80009d2:	7a30      	ldrb	r0, [r6, #8]
 80009d4:	7a71      	ldrb	r1, [r6, #9]
 80009d6:	4281      	cmp	r1, r0
 80009d8:	d009      	beq.n	80009ee <__iar_annotation$$branch+0x212>
 80009da:	7270      	strb	r0, [r6, #9]
 80009dc:	2000      	movs	r0, #0
 80009de:	9000      	str	r0, [sp, #0]
 80009e0:	2300      	movs	r3, #0
 80009e2:	7a32      	ldrb	r2, [r6, #8]
 80009e4:	7b20      	ldrb	r0, [r4, #12]
 80009e6:	07c1      	lsls	r1, r0, #31
 80009e8:	0fc9      	lsrs	r1, r1, #31
 80009ea:	2004      	movs	r0, #4
 80009ec:	47b8      	blx	r7
 80009ee:	2701      	movs	r7, #1
 80009f0:	4668      	mov	r0, sp
 80009f2:	7b00      	ldrb	r0, [r0, #12]
 80009f4:	2814      	cmp	r0, #20
 80009f6:	d101      	bne.n	80009fc <__iar_annotation$$branch+0x4>

080009f8 <__iar_annotation$$branch>:
 80009f8:	f001 f8fd 	bl	8001bf6 <__iar_annotation$$branch+0x4>
 80009fc:	0020      	movs	r0, r4
 80009fe:	f003 f809 	bl	8003a14 <PE_Check_AMSConflict>
 8000a02:	2815      	cmp	r0, #21
 8000a04:	d102      	bne.n	8000a0c <__iar_annotation$$branch+0x14>
 8000a06:	2014      	movs	r0, #20
 8000a08:	4669      	mov	r1, sp
 8000a0a:	7308      	strb	r0, [r1, #12]
 8000a0c:	4851      	ldr	r0, [pc, #324]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000a0e:	68c5      	ldr	r5, [r0, #12]
 8000a10:	2d00      	cmp	r5, #0
 8000a12:	d010      	beq.n	8000a36 <__iar_annotation$$branch+0x3e>
 8000a14:	7800      	ldrb	r0, [r0, #0]
 8000a16:	07c0      	lsls	r0, r0, #31
 8000a18:	d50d      	bpl.n	8000a36 <__iar_annotation$$branch+0x3e>
 8000a1a:	7a30      	ldrb	r0, [r6, #8]
 8000a1c:	7a71      	ldrb	r1, [r6, #9]
 8000a1e:	4281      	cmp	r1, r0
 8000a20:	d009      	beq.n	8000a36 <__iar_annotation$$branch+0x3e>
 8000a22:	7270      	strb	r0, [r6, #9]
 8000a24:	2000      	movs	r0, #0
 8000a26:	9000      	str	r0, [sp, #0]
 8000a28:	2300      	movs	r3, #0
 8000a2a:	7a32      	ldrb	r2, [r6, #8]
 8000a2c:	68e0      	ldr	r0, [r4, #12]
 8000a2e:	2101      	movs	r1, #1
 8000a30:	4001      	ands	r1, r0
 8000a32:	2004      	movs	r0, #4
 8000a34:	47a8      	blx	r5
 8000a36:	2500      	movs	r5, #0
 8000a38:	9808      	ldr	r0, [sp, #32]
 8000a3a:	2800      	cmp	r0, #0
 8000a3c:	d01c      	beq.n	8000a78 <__iar_annotation$$branch+0x80>
 8000a3e:	4845      	ldr	r0, [pc, #276]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000a40:	6901      	ldr	r1, [r0, #16]
 8000a42:	4a49      	ldr	r2, [pc, #292]	; (8000b68 <__iar_annotation$$branch+0x170>)
 8000a44:	4291      	cmp	r1, r2
 8000a46:	d017      	beq.n	8000a78 <__iar_annotation$$branch+0x80>
 8000a48:	1d01      	adds	r1, r0, #4
 8000a4a:	68e2      	ldr	r2, [r4, #12]
 8000a4c:	403a      	ands	r2, r7
 8000a4e:	0092      	lsls	r2, r2, #2
 8000a50:	5889      	ldr	r1, [r1, r2]
 8000a52:	68ce      	ldr	r6, [r1, #12]
 8000a54:	0b33      	lsrs	r3, r6, #12
 8000a56:	1c5b      	adds	r3, r3, #1
 8000a58:	4a44      	ldr	r2, [pc, #272]	; (8000b6c <__iar_annotation$$branch+0x174>)
 8000a5a:	4016      	ands	r6, r2
 8000a5c:	031b      	lsls	r3, r3, #12
 8000a5e:	4333      	orrs	r3, r6
 8000a60:	60cb      	str	r3, [r1, #12]
 8000a62:	1d00      	adds	r0, r0, #4
 8000a64:	68e1      	ldr	r1, [r4, #12]
 8000a66:	400f      	ands	r7, r1
 8000a68:	00b9      	lsls	r1, r7, #2
 8000a6a:	5840      	ldr	r0, [r0, r1]
 8000a6c:	68c1      	ldr	r1, [r0, #12]
 8000a6e:	0b0b      	lsrs	r3, r1, #12
 8000a70:	2b08      	cmp	r3, #8
 8000a72:	db01      	blt.n	8000a78 <__iar_annotation$$branch+0x80>
 8000a74:	400a      	ands	r2, r1
 8000a76:	60c2      	str	r2, [r0, #12]
 8000a78:	2d00      	cmp	r5, #0
 8000a7a:	d100      	bne.n	8000a7e <__iar_annotation$$branch+0x86>
 8000a7c:	e5ab      	b.n	80005d6 <USBPD_PE_StateMachine_SRC+0xca>
 8000a7e:	0028      	movs	r0, r5
 8000a80:	b00b      	add	sp, #44	; 0x2c
 8000a82:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000a84:	2000      	movs	r0, #0
 8000a86:	83b0      	strh	r0, [r6, #28]
 8000a88:	2007      	movs	r0, #7
 8000a8a:	7230      	strb	r0, [r6, #8]
 8000a8c:	2010      	movs	r0, #16
 8000a8e:	e7f7      	b.n	8000a80 <__iar_annotation$$branch+0x88>
 8000a90:	8cb0      	ldrh	r0, [r6, #36]	; 0x24
 8000a92:	03a9      	lsls	r1, r5, #14
 8000a94:	4288      	cmp	r0, r1
 8000a96:	d195      	bne.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000a98:	2007      	movs	r0, #7
 8000a9a:	7230      	strb	r0, [r6, #8]
 8000a9c:	2500      	movs	r5, #0
 8000a9e:	e791      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000aa0:	2101      	movs	r1, #1
 8000aa2:	0020      	movs	r0, r4
 8000aa4:	f002 fe0b 	bl	80036be <PE_Send_SRCCapabilities>
 8000aa8:	2805      	cmp	r0, #5
 8000aaa:	d002      	beq.n	8000ab2 <__iar_annotation$$branch+0xba>
 8000aac:	2809      	cmp	r0, #9
 8000aae:	d089      	beq.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000ab0:	e023      	b.n	8000afa <__iar_annotation$$branch+0x102>
 8000ab2:	2001      	movs	r0, #1
 8000ab4:	82e0      	strh	r0, [r4, #22]
 8000ab6:	2002      	movs	r0, #2
 8000ab8:	68e1      	ldr	r1, [r4, #12]
 8000aba:	4301      	orrs	r1, r0
 8000abc:	60e1      	str	r1, [r4, #12]
 8000abe:	2100      	movs	r1, #0
 8000ac0:	7561      	strb	r1, [r4, #21]
 8000ac2:	7521      	strb	r1, [r4, #20]
 8000ac4:	492a      	ldr	r1, [pc, #168]	; (8000b70 <__iar_annotation$$branch+0x178>)
 8000ac6:	83b1      	strh	r1, [r6, #28]
 8000ac8:	251a      	movs	r5, #26
 8000aca:	2116      	movs	r1, #22
 8000acc:	7231      	strb	r1, [r6, #8]
 8000ace:	4f21      	ldr	r7, [pc, #132]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000ad0:	7839      	ldrb	r1, [r7, #0]
 8000ad2:	4201      	tst	r1, r0
 8000ad4:	d009      	beq.n	8000aea <__iar_annotation$$branch+0xf2>
 8000ad6:	2000      	movs	r0, #0
 8000ad8:	9000      	str	r0, [sp, #0]
 8000ada:	2300      	movs	r3, #0
 8000adc:	220f      	movs	r2, #15
 8000ade:	7b20      	ldrb	r0, [r4, #12]
 8000ae0:	07c1      	lsls	r1, r0, #31
 8000ae2:	0fc9      	lsrs	r1, r1, #31
 8000ae4:	2009      	movs	r0, #9
 8000ae6:	68ff      	ldr	r7, [r7, #12]
 8000ae8:	47b8      	blx	r7
 8000aea:	210f      	movs	r1, #15
 8000aec:	7b22      	ldrb	r2, [r4, #12]
 8000aee:	07d0      	lsls	r0, r2, #31
 8000af0:	0fc0      	lsrs	r0, r0, #31
 8000af2:	68a2      	ldr	r2, [r4, #8]
 8000af4:	68d2      	ldr	r2, [r2, #12]
 8000af6:	4790      	blx	r2
 8000af8:	e764      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000afa:	2701      	movs	r7, #1
 8000afc:	68e1      	ldr	r1, [r4, #12]
 8000afe:	2001      	movs	r0, #1
 8000b00:	4008      	ands	r0, r1
 8000b02:	f004 fa37 	bl	8004f74 <USBPD_PRL_SRCReleaseSinkNG>
 8000b06:	68e0      	ldr	r0, [r4, #12]
 8000b08:	0840      	lsrs	r0, r0, #1
 8000b0a:	4007      	ands	r7, r0
 8000b0c:	d107      	bne.n	8000b1e <__iar_annotation$$branch+0x126>
 8000b0e:	7d60      	ldrb	r0, [r4, #21]
 8000b10:	2833      	cmp	r0, #51	; 0x33
 8000b12:	d204      	bcs.n	8000b1e <__iar_annotation$$branch+0x126>
 8000b14:	4817      	ldr	r0, [pc, #92]	; (8000b74 <__iar_annotation$$branch+0x17c>)
 8000b16:	8430      	strh	r0, [r6, #32]
 8000b18:	2596      	movs	r5, #150	; 0x96
 8000b1a:	2008      	movs	r0, #8
 8000b1c:	e6d0      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000b1e:	2f00      	cmp	r7, #0
 8000b20:	d001      	beq.n	8000b26 <__iar_annotation$$branch+0x12e>
 8000b22:	200f      	movs	r0, #15
 8000b24:	e7b9      	b.n	8000a9a <__iar_annotation$$branch+0xa2>
 8000b26:	4f0b      	ldr	r7, [pc, #44]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000b28:	7838      	ldrb	r0, [r7, #0]
 8000b2a:	0780      	lsls	r0, r0, #30
 8000b2c:	d509      	bpl.n	8000b42 <__iar_annotation$$branch+0x14a>
 8000b2e:	2000      	movs	r0, #0
 8000b30:	9000      	str	r0, [sp, #0]
 8000b32:	2300      	movs	r3, #0
 8000b34:	2220      	movs	r2, #32
 8000b36:	7b20      	ldrb	r0, [r4, #12]
 8000b38:	07c1      	lsls	r1, r0, #31
 8000b3a:	0fc9      	lsrs	r1, r1, #31
 8000b3c:	2009      	movs	r0, #9
 8000b3e:	68ff      	ldr	r7, [r7, #12]
 8000b40:	47b8      	blx	r7
 8000b42:	2120      	movs	r1, #32
 8000b44:	7b22      	ldrb	r2, [r4, #12]
 8000b46:	07d0      	lsls	r0, r2, #31
 8000b48:	0fc0      	lsrs	r0, r0, #31
 8000b4a:	68a2      	ldr	r2, [r4, #8]
 8000b4c:	68d2      	ldr	r2, [r2, #12]
 8000b4e:	4790      	blx	r2
 8000b50:	2000      	movs	r0, #0
 8000b52:	e6b5      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000b54:	200019ac 	.word	0x200019ac
 8000b58:	00008014 	.word	0x00008014
 8000b5c:	ffff9fff 	.word	0xffff9fff
 8000b60:	fffff8ff 	.word	0xfffff8ff
 8000b64:	0000801e 	.word	0x0000801e
 8000b68:	b5e8b5cd 	.word	0xb5e8b5cd
 8000b6c:	00000fff 	.word	0x00000fff
 8000b70:	0000801a 	.word	0x0000801a
 8000b74:	00008096 	.word	0x00008096
 8000b78:	8c30      	ldrh	r0, [r6, #32]
 8000b7a:	03a9      	lsls	r1, r5, #14
 8000b7c:	4288      	cmp	r0, r1
 8000b7e:	d1bb      	bne.n	8000af8 <__iar_annotation$$branch+0x100>
 8000b80:	2000      	movs	r0, #0
 8000b82:	8430      	strh	r0, [r6, #32]
 8000b84:	6820      	ldr	r0, [r4, #0]
 8000b86:	6840      	ldr	r0, [r0, #4]
 8000b88:	0601      	lsls	r1, r0, #24
 8000b8a:	0fc9      	lsrs	r1, r1, #31
 8000b8c:	d002      	beq.n	8000b94 <__iar_annotation$$branch+0x19c>
 8000b8e:	7d60      	ldrb	r0, [r4, #21]
 8000b90:	1c40      	adds	r0, r0, #1
 8000b92:	7560      	strb	r0, [r4, #21]
 8000b94:	2007      	movs	r0, #7
 8000b96:	e693      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000b98:	2911      	cmp	r1, #17
 8000b9a:	d132      	bne.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000b9c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000b9e:	0bc0      	lsrs	r0, r0, #15
 8000ba0:	d12f      	bne.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000ba2:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000ba4:	0b00      	lsrs	r0, r0, #12
 8000ba6:	0740      	lsls	r0, r0, #29
 8000ba8:	d02b      	beq.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000baa:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000bac:	06c0      	lsls	r0, r0, #27
 8000bae:	0ec0      	lsrs	r0, r0, #27
 8000bb0:	2802      	cmp	r0, #2
 8000bb2:	d126      	bne.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000bb4:	2501      	movs	r5, #1
 8000bb6:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000bb8:	0600      	lsls	r0, r0, #24
 8000bba:	0f81      	lsrs	r1, r0, #30
 8000bbc:	68e2      	ldr	r2, [r4, #12]
 8000bbe:	2001      	movs	r0, #1
 8000bc0:	4010      	ands	r0, r2
 8000bc2:	f003 fc05 	bl	80043d0 <PE_ExtRevisionInteroperability>
 8000bc6:	209e      	movs	r0, #158	; 0x9e
 8000bc8:	0040      	lsls	r0, r0, #1
 8000bca:	1820      	adds	r0, r4, r0
 8000bcc:	7801      	ldrb	r1, [r0, #0]
 8000bce:	7842      	ldrb	r2, [r0, #1]
 8000bd0:	0212      	lsls	r2, r2, #8
 8000bd2:	1889      	adds	r1, r1, r2
 8000bd4:	7882      	ldrb	r2, [r0, #2]
 8000bd6:	0412      	lsls	r2, r2, #16
 8000bd8:	1889      	adds	r1, r1, r2
 8000bda:	78c0      	ldrb	r0, [r0, #3]
 8000bdc:	0600      	lsls	r0, r0, #24
 8000bde:	1808      	adds	r0, r1, r0
 8000be0:	9000      	str	r0, [sp, #0]
 8000be2:	2304      	movs	r3, #4
 8000be4:	466a      	mov	r2, sp
 8000be6:	2106      	movs	r1, #6
 8000be8:	68e0      	ldr	r0, [r4, #12]
 8000bea:	4005      	ands	r5, r0
 8000bec:	0028      	movs	r0, r5
 8000bee:	68a5      	ldr	r5, [r4, #8]
 8000bf0:	69ed      	ldr	r5, [r5, #28]
 8000bf2:	47a8      	blx	r5
 8000bf4:	2500      	movs	r5, #0
 8000bf6:	83b5      	strh	r5, [r6, #28]
 8000bf8:	2009      	movs	r0, #9
 8000bfa:	7230      	strb	r0, [r6, #8]
 8000bfc:	2014      	movs	r0, #20
 8000bfe:	4669      	mov	r1, sp
 8000c00:	7308      	strb	r0, [r1, #12]
 8000c02:	8bb0      	ldrh	r0, [r6, #28]
 8000c04:	2180      	movs	r1, #128	; 0x80
 8000c06:	0209      	lsls	r1, r1, #8
 8000c08:	4288      	cmp	r0, r1
 8000c0a:	d163      	bne.n	8000cd4 <__iar_annotation$$branch+0x2dc>
 8000c0c:	e1d3      	b.n	8000fb6 <__iar_annotation$$branch+0x5be>
 8000c0e:	a901      	add	r1, sp, #4
 8000c10:	7b22      	ldrb	r2, [r4, #12]
 8000c12:	07d0      	lsls	r0, r2, #31
 8000c14:	0fc0      	lsrs	r0, r0, #31
 8000c16:	68a2      	ldr	r2, [r4, #8]
 8000c18:	6a12      	ldr	r2, [r2, #32]
 8000c1a:	4790      	blx	r2
 8000c1c:	280a      	cmp	r0, #10
 8000c1e:	d01c      	beq.n	8000c5a <__iar_annotation$$branch+0x262>
 8000c20:	280b      	cmp	r0, #11
 8000c22:	d002      	beq.n	8000c2a <__iar_annotation$$branch+0x232>
 8000c24:	280d      	cmp	r0, #13
 8000c26:	d056      	beq.n	8000cd6 <__iar_annotation$$branch+0x2de>
 8000c28:	e06d      	b.n	8000d06 <__iar_annotation$$branch+0x30e>
 8000c2a:	2000      	movs	r0, #0
 8000c2c:	9000      	str	r0, [sp, #0]
 8000c2e:	230c      	movs	r3, #12
 8000c30:	2202      	movs	r2, #2
 8000c32:	2100      	movs	r1, #0
 8000c34:	0020      	movs	r0, r4
 8000c36:	f002 fd9c 	bl	8003772 <PE_Send_CtrlMessage>
 8000c3a:	4fb8      	ldr	r7, [pc, #736]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000c3c:	7838      	ldrb	r0, [r7, #0]
 8000c3e:	0780      	lsls	r0, r0, #30
 8000c40:	d509      	bpl.n	8000c56 <__iar_annotation$$branch+0x25e>
 8000c42:	2000      	movs	r0, #0
 8000c44:	9000      	str	r0, [sp, #0]
 8000c46:	2300      	movs	r3, #0
 8000c48:	2204      	movs	r2, #4
 8000c4a:	7b20      	ldrb	r0, [r4, #12]
 8000c4c:	07c1      	lsls	r1, r0, #31
 8000c4e:	0fc9      	lsrs	r1, r1, #31
 8000c50:	2009      	movs	r0, #9
 8000c52:	68ff      	ldr	r7, [r7, #12]
 8000c54:	47b8      	blx	r7
 8000c56:	2104      	movs	r1, #4
 8000c58:	e748      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000c5a:	6860      	ldr	r0, [r4, #4]
 8000c5c:	7840      	ldrb	r0, [r0, #1]
 8000c5e:	0640      	lsls	r0, r0, #25
 8000c60:	0f40      	lsrs	r0, r0, #29
 8000c62:	2801      	cmp	r0, #1
 8000c64:	d00c      	beq.n	8000c80 <__iar_annotation$$branch+0x288>
 8000c66:	4668      	mov	r0, sp
 8000c68:	7900      	ldrb	r0, [r0, #4]
 8000c6a:	2803      	cmp	r0, #3
 8000c6c:	d108      	bne.n	8000c80 <__iar_annotation$$branch+0x288>
 8000c6e:	7b20      	ldrb	r0, [r4, #12]
 8000c70:	0700      	lsls	r0, r0, #28
 8000c72:	0f80      	lsrs	r0, r0, #30
 8000c74:	2803      	cmp	r0, #3
 8000c76:	d103      	bne.n	8000c80 <__iar_annotation$$branch+0x288>
 8000c78:	03a8      	lsls	r0, r5, #14
 8000c7a:	8470      	strh	r0, [r6, #34]	; 0x22
 8000c7c:	2500      	movs	r5, #0
 8000c7e:	e002      	b.n	8000c86 <__iar_annotation$$branch+0x28e>
 8000c80:	48a7      	ldr	r0, [pc, #668]	; (8000f20 <__iar_annotation$$branch+0x528>)
 8000c82:	8470      	strh	r0, [r6, #34]	; 0x22
 8000c84:	251e      	movs	r5, #30
 8000c86:	2000      	movs	r0, #0
 8000c88:	9000      	str	r0, [sp, #0]
 8000c8a:	230c      	movs	r3, #12
 8000c8c:	2203      	movs	r2, #3
 8000c8e:	2100      	movs	r1, #0
 8000c90:	0020      	movs	r0, r4
 8000c92:	f002 fd6e 	bl	8003772 <PE_Send_CtrlMessage>
 8000c96:	4fa1      	ldr	r7, [pc, #644]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000c98:	7838      	ldrb	r0, [r7, #0]
 8000c9a:	0780      	lsls	r0, r0, #30
 8000c9c:	d509      	bpl.n	8000cb2 <__iar_annotation$$branch+0x2ba>
 8000c9e:	2000      	movs	r0, #0
 8000ca0:	9000      	str	r0, [sp, #0]
 8000ca2:	2300      	movs	r3, #0
 8000ca4:	2201      	movs	r2, #1
 8000ca6:	7b20      	ldrb	r0, [r4, #12]
 8000ca8:	07c1      	lsls	r1, r0, #31
 8000caa:	0fc9      	lsrs	r1, r1, #31
 8000cac:	2009      	movs	r0, #9
 8000cae:	68ff      	ldr	r7, [r7, #12]
 8000cb0:	47b8      	blx	r7
 8000cb2:	2101      	movs	r1, #1
 8000cb4:	7b22      	ldrb	r2, [r4, #12]
 8000cb6:	07d0      	lsls	r0, r2, #31
 8000cb8:	0fc0      	lsrs	r0, r0, #31
 8000cba:	68a2      	ldr	r2, [r4, #8]
 8000cbc:	68d2      	ldr	r2, [r2, #12]
 8000cbe:	4790      	blx	r2
 8000cc0:	7b21      	ldrb	r1, [r4, #12]
 8000cc2:	20f3      	movs	r0, #243	; 0xf3
 8000cc4:	4008      	ands	r0, r1
 8000cc6:	4669      	mov	r1, sp
 8000cc8:	7909      	ldrb	r1, [r1, #4]
 8000cca:	0089      	lsls	r1, r1, #2
 8000ccc:	220c      	movs	r2, #12
 8000cce:	400a      	ands	r2, r1
 8000cd0:	4302      	orrs	r2, r0
 8000cd2:	7322      	strb	r2, [r4, #12]
 8000cd4:	e676      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000cd6:	2000      	movs	r0, #0
 8000cd8:	9000      	str	r0, [sp, #0]
 8000cda:	2303      	movs	r3, #3
 8000cdc:	220c      	movs	r2, #12
 8000cde:	2100      	movs	r1, #0
 8000ce0:	0020      	movs	r0, r4
 8000ce2:	f002 fd46 	bl	8003772 <PE_Send_CtrlMessage>
 8000ce6:	4f8d      	ldr	r7, [pc, #564]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000ce8:	7838      	ldrb	r0, [r7, #0]
 8000cea:	0780      	lsls	r0, r0, #30
 8000cec:	d509      	bpl.n	8000d02 <__iar_annotation$$branch+0x30a>
 8000cee:	2000      	movs	r0, #0
 8000cf0:	9000      	str	r0, [sp, #0]
 8000cf2:	2300      	movs	r3, #0
 8000cf4:	2203      	movs	r2, #3
 8000cf6:	7b20      	ldrb	r0, [r4, #12]
 8000cf8:	07c1      	lsls	r1, r0, #31
 8000cfa:	0fc9      	lsrs	r1, r1, #31
 8000cfc:	2009      	movs	r0, #9
 8000cfe:	68ff      	ldr	r7, [r7, #12]
 8000d00:	47b8      	blx	r7
 8000d02:	2103      	movs	r1, #3
 8000d04:	e6f2      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000d06:	2000      	movs	r0, #0
 8000d08:	9000      	str	r0, [sp, #0]
 8000d0a:	230e      	movs	r3, #14
 8000d0c:	2204      	movs	r2, #4
 8000d0e:	2100      	movs	r1, #0
 8000d10:	0020      	movs	r0, r4
 8000d12:	f002 fd2e 	bl	8003772 <PE_Send_CtrlMessage>
 8000d16:	4f81      	ldr	r7, [pc, #516]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000d18:	7838      	ldrb	r0, [r7, #0]
 8000d1a:	0780      	lsls	r0, r0, #30
 8000d1c:	d509      	bpl.n	8000d32 <__iar_annotation$$branch+0x33a>
 8000d1e:	2000      	movs	r0, #0
 8000d20:	9000      	str	r0, [sp, #0]
 8000d22:	2300      	movs	r3, #0
 8000d24:	2202      	movs	r2, #2
 8000d26:	7b20      	ldrb	r0, [r4, #12]
 8000d28:	07c1      	lsls	r1, r0, #31
 8000d2a:	0fc9      	lsrs	r1, r1, #31
 8000d2c:	2009      	movs	r0, #9
 8000d2e:	68ff      	ldr	r7, [r7, #12]
 8000d30:	47b8      	blx	r7
 8000d32:	2102      	movs	r1, #2
 8000d34:	e6da      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000d36:	8c71      	ldrh	r1, [r6, #34]	; 0x22
 8000d38:	03aa      	lsls	r2, r5, #14
 8000d3a:	4291      	cmp	r1, r2
 8000d3c:	d1ca      	bne.n	8000cd4 <__iar_annotation$$branch+0x2dc>
 8000d3e:	2100      	movs	r1, #0
 8000d40:	8471      	strh	r1, [r6, #34]	; 0x22
 8000d42:	6861      	ldr	r1, [r4, #4]
 8000d44:	784a      	ldrb	r2, [r1, #1]
 8000d46:	238f      	movs	r3, #143	; 0x8f
 8000d48:	4013      	ands	r3, r2
 8000d4a:	2240      	movs	r2, #64	; 0x40
 8000d4c:	431a      	orrs	r2, r3
 8000d4e:	704a      	strb	r2, [r1, #1]
 8000d50:	2800      	cmp	r0, #0
 8000d52:	d009      	beq.n	8000d68 <__iar_annotation$$branch+0x370>
 8000d54:	2000      	movs	r0, #0
 8000d56:	9000      	str	r0, [sp, #0]
 8000d58:	2300      	movs	r3, #0
 8000d5a:	2256      	movs	r2, #86	; 0x56
 8000d5c:	7b20      	ldrb	r0, [r4, #12]
 8000d5e:	07c1      	lsls	r1, r0, #31
 8000d60:	0fc9      	lsrs	r1, r1, #31
 8000d62:	2009      	movs	r0, #9
 8000d64:	9f01      	ldr	r7, [sp, #4]
 8000d66:	47b8      	blx	r7
 8000d68:	2701      	movs	r7, #1
 8000d6a:	2156      	movs	r1, #86	; 0x56
 8000d6c:	68e2      	ldr	r2, [r4, #12]
 8000d6e:	2001      	movs	r0, #1
 8000d70:	4010      	ands	r0, r2
 8000d72:	68a2      	ldr	r2, [r4, #8]
 8000d74:	68d2      	ldr	r2, [r2, #12]
 8000d76:	4790      	blx	r2
 8000d78:	68a0      	ldr	r0, [r4, #8]
 8000d7a:	6801      	ldr	r1, [r0, #0]
 8000d7c:	2900      	cmp	r1, #0
 8000d7e:	d007      	beq.n	8000d90 <__iar_annotation$$branch+0x398>
 8000d80:	68e0      	ldr	r0, [r4, #12]
 8000d82:	4007      	ands	r7, r0
 8000d84:	0038      	movs	r0, r7
 8000d86:	4788      	blx	r1
 8000d88:	2800      	cmp	r0, #0
 8000d8a:	d001      	beq.n	8000d90 <__iar_annotation$$branch+0x398>
 8000d8c:	200f      	movs	r0, #15
 8000d8e:	7230      	strb	r0, [r6, #8]
 8000d90:	200d      	movs	r0, #13
 8000d92:	e595      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000d94:	2000      	movs	r0, #0
 8000d96:	9000      	str	r0, [sp, #0]
 8000d98:	2303      	movs	r3, #3
 8000d9a:	2206      	movs	r2, #6
 8000d9c:	2100      	movs	r1, #0
 8000d9e:	0020      	movs	r0, r4
 8000da0:	f002 fce7 	bl	8003772 <PE_Send_CtrlMessage>
 8000da4:	2800      	cmp	r0, #0
 8000da6:	d12e      	bne.n	8000e06 <__iar_annotation$$branch+0x40e>
 8000da8:	6860      	ldr	r0, [r4, #4]
 8000daa:	7841      	ldrb	r1, [r0, #1]
 8000dac:	228f      	movs	r2, #143	; 0x8f
 8000dae:	400a      	ands	r2, r1
 8000db0:	2130      	movs	r1, #48	; 0x30
 8000db2:	4311      	orrs	r1, r2
 8000db4:	7041      	strb	r1, [r0, #1]
 8000db6:	4859      	ldr	r0, [pc, #356]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000db8:	7800      	ldrb	r0, [r0, #0]
 8000dba:	0780      	lsls	r0, r0, #30
 8000dbc:	d50a      	bpl.n	8000dd4 <__iar_annotation$$branch+0x3dc>
 8000dbe:	2000      	movs	r0, #0
 8000dc0:	9000      	str	r0, [sp, #0]
 8000dc2:	2300      	movs	r3, #0
 8000dc4:	2256      	movs	r2, #86	; 0x56
 8000dc6:	7b20      	ldrb	r0, [r4, #12]
 8000dc8:	07c1      	lsls	r1, r0, #31
 8000dca:	0fc9      	lsrs	r1, r1, #31
 8000dcc:	2009      	movs	r0, #9
 8000dce:	4f53      	ldr	r7, [pc, #332]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000dd0:	68ff      	ldr	r7, [r7, #12]
 8000dd2:	47b8      	blx	r7
 8000dd4:	2156      	movs	r1, #86	; 0x56
 8000dd6:	7b22      	ldrb	r2, [r4, #12]
 8000dd8:	07d0      	lsls	r0, r2, #31
 8000dda:	0fc0      	lsrs	r0, r0, #31
 8000ddc:	68a2      	ldr	r2, [r4, #8]
 8000dde:	68d2      	ldr	r2, [r2, #12]
 8000de0:	4790      	blx	r2
 8000de2:	4f4e      	ldr	r7, [pc, #312]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000de4:	7838      	ldrb	r0, [r7, #0]
 8000de6:	0780      	lsls	r0, r0, #30
 8000de8:	d509      	bpl.n	8000dfe <__iar_annotation$$branch+0x406>
 8000dea:	2000      	movs	r0, #0
 8000dec:	9000      	str	r0, [sp, #0]
 8000dee:	2300      	movs	r3, #0
 8000df0:	2210      	movs	r2, #16
 8000df2:	7b20      	ldrb	r0, [r4, #12]
 8000df4:	07c1      	lsls	r1, r0, #31
 8000df6:	0fc9      	lsrs	r1, r1, #31
 8000df8:	2009      	movs	r0, #9
 8000dfa:	68ff      	ldr	r7, [r7, #12]
 8000dfc:	47b8      	blx	r7
 8000dfe:	2110      	movs	r1, #16
 8000e00:	e674      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000e02:	2500      	movs	r5, #0
 8000e04:	43ed      	mvns	r5, r5
 8000e06:	e5dd      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000e08:	6860      	ldr	r0, [r4, #4]
 8000e0a:	7840      	ldrb	r0, [r0, #1]
 8000e0c:	0640      	lsls	r0, r0, #25
 8000e0e:	0f40      	lsrs	r0, r0, #29
 8000e10:	2803      	cmp	r0, #3
 8000e12:	d001      	beq.n	8000e18 <__iar_annotation$$branch+0x420>
 8000e14:	200e      	movs	r0, #14
 8000e16:	e553      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000e18:	7a30      	ldrb	r0, [r6, #8]
 8000e1a:	280a      	cmp	r0, #10
 8000e1c:	d007      	beq.n	8000e2e <__iar_annotation$$branch+0x436>
 8000e1e:	7b21      	ldrb	r1, [r4, #12]
 8000e20:	07c8      	lsls	r0, r1, #31
 8000e22:	0fc0      	lsrs	r0, r0, #31
 8000e24:	68a1      	ldr	r1, [r4, #8]
 8000e26:	6909      	ldr	r1, [r1, #16]
 8000e28:	4788      	blx	r1
 8000e2a:	2800      	cmp	r0, #0
 8000e2c:	d101      	bne.n	8000e32 <__iar_annotation$$branch+0x43a>
 8000e2e:	2003      	movs	r0, #3
 8000e30:	e546      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000e32:	200f      	movs	r0, #15
 8000e34:	e544      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000e36:	2001      	movs	r0, #1
 8000e38:	9000      	str	r0, [sp, #0]
 8000e3a:	2397      	movs	r3, #151	; 0x97
 8000e3c:	2202      	movs	r2, #2
 8000e3e:	2100      	movs	r1, #0
 8000e40:	0020      	movs	r0, r4
 8000e42:	f002 fc96 	bl	8003772 <PE_Send_CtrlMessage>
 8000e46:	2800      	cmp	r0, #0
 8000e48:	d11a      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000e4a:	2002      	movs	r0, #2
 8000e4c:	82e0      	strh	r0, [r4, #22]
 8000e4e:	2501      	movs	r5, #1
 8000e50:	4f32      	ldr	r7, [pc, #200]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000e52:	7839      	ldrb	r1, [r7, #0]
 8000e54:	4201      	tst	r1, r0
 8000e56:	d009      	beq.n	8000e6c <__iar_annotation$$branch+0x474>
 8000e58:	2000      	movs	r0, #0
 8000e5a:	9000      	str	r0, [sp, #0]
 8000e5c:	2300      	movs	r3, #0
 8000e5e:	2227      	movs	r2, #39	; 0x27
 8000e60:	68e0      	ldr	r0, [r4, #12]
 8000e62:	2101      	movs	r1, #1
 8000e64:	4001      	ands	r1, r0
 8000e66:	2009      	movs	r0, #9
 8000e68:	68ff      	ldr	r7, [r7, #12]
 8000e6a:	47b8      	blx	r7
 8000e6c:	2127      	movs	r1, #39	; 0x27
 8000e6e:	68e0      	ldr	r0, [r4, #12]
 8000e70:	4005      	ands	r5, r0
 8000e72:	0028      	movs	r0, r5
 8000e74:	68a2      	ldr	r2, [r4, #8]
 8000e76:	68d2      	ldr	r2, [r2, #12]
 8000e78:	4790      	blx	r2
 8000e7a:	48bc      	ldr	r0, [pc, #752]	; (800116c <__iar_annotation$$branch+0x774>)
 8000e7c:	8470      	strh	r0, [r6, #34]	; 0x22
 8000e7e:	4dbc      	ldr	r5, [pc, #752]	; (8001170 <__iar_annotation$$branch+0x778>)
 8000e80:	e5a0      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000e82:	8c71      	ldrh	r1, [r6, #34]	; 0x22
 8000e84:	03aa      	lsls	r2, r5, #14
 8000e86:	4291      	cmp	r1, r2
 8000e88:	d1fa      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000e8a:	2800      	cmp	r0, #0
 8000e8c:	d009      	beq.n	8000ea2 <__iar_annotation$$branch+0x4aa>
 8000e8e:	2000      	movs	r0, #0
 8000e90:	9000      	str	r0, [sp, #0]
 8000e92:	2300      	movs	r3, #0
 8000e94:	2228      	movs	r2, #40	; 0x28
 8000e96:	7b20      	ldrb	r0, [r4, #12]
 8000e98:	07c1      	lsls	r1, r0, #31
 8000e9a:	0fc9      	lsrs	r1, r1, #31
 8000e9c:	2009      	movs	r0, #9
 8000e9e:	9f01      	ldr	r7, [sp, #4]
 8000ea0:	47b8      	blx	r7
 8000ea2:	2128      	movs	r1, #40	; 0x28
 8000ea4:	7b22      	ldrb	r2, [r4, #12]
 8000ea6:	07d0      	lsls	r0, r2, #31
 8000ea8:	0fc0      	lsrs	r0, r0, #31
 8000eaa:	68a2      	ldr	r2, [r4, #8]
 8000eac:	68d2      	ldr	r2, [r2, #12]
 8000eae:	4790      	blx	r2
 8000eb0:	2000      	movs	r0, #0
 8000eb2:	9000      	str	r0, [sp, #0]
 8000eb4:	2303      	movs	r3, #3
 8000eb6:	2206      	movs	r2, #6
 8000eb8:	2100      	movs	r1, #0
 8000eba:	0020      	movs	r0, r4
 8000ebc:	f002 fc59 	bl	8003772 <PE_Send_CtrlMessage>
 8000ec0:	2800      	cmp	r0, #0
 8000ec2:	d1dd      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000ec4:	4f15      	ldr	r7, [pc, #84]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000ec6:	7838      	ldrb	r0, [r7, #0]
 8000ec8:	0780      	lsls	r0, r0, #30
 8000eca:	d509      	bpl.n	8000ee0 <__iar_annotation$$branch+0x4e8>
 8000ecc:	2000      	movs	r0, #0
 8000ece:	9000      	str	r0, [sp, #0]
 8000ed0:	2300      	movs	r3, #0
 8000ed2:	222c      	movs	r2, #44	; 0x2c
 8000ed4:	7b20      	ldrb	r0, [r4, #12]
 8000ed6:	07c1      	lsls	r1, r0, #31
 8000ed8:	0fc9      	lsrs	r1, r1, #31
 8000eda:	2009      	movs	r0, #9
 8000edc:	68ff      	ldr	r7, [r7, #12]
 8000ede:	47b8      	blx	r7
 8000ee0:	212c      	movs	r1, #44	; 0x2c
 8000ee2:	e603      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000ee4:	0020      	movs	r0, r4
 8000ee6:	f002 fd2a 	bl	800393e <PE_PerformSoftReset>
 8000eea:	2000      	movs	r0, #0
 8000eec:	9000      	str	r0, [sp, #0]
 8000eee:	2307      	movs	r3, #7
 8000ef0:	2203      	movs	r2, #3
 8000ef2:	2100      	movs	r1, #0
 8000ef4:	0020      	movs	r0, r4
 8000ef6:	f002 fc3c 	bl	8003772 <PE_Send_CtrlMessage>
 8000efa:	4f08      	ldr	r7, [pc, #32]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000efc:	7838      	ldrb	r0, [r7, #0]
 8000efe:	0780      	lsls	r0, r0, #30
 8000f00:	d509      	bpl.n	8000f16 <__iar_annotation$$branch+0x51e>
 8000f02:	2000      	movs	r0, #0
 8000f04:	9000      	str	r0, [sp, #0]
 8000f06:	2300      	movs	r3, #0
 8000f08:	222f      	movs	r2, #47	; 0x2f
 8000f0a:	7b20      	ldrb	r0, [r4, #12]
 8000f0c:	07c1      	lsls	r1, r0, #31
 8000f0e:	0fc9      	lsrs	r1, r1, #31
 8000f10:	2009      	movs	r0, #9
 8000f12:	68ff      	ldr	r7, [r7, #12]
 8000f14:	47b8      	blx	r7
 8000f16:	212f      	movs	r1, #47	; 0x2f
 8000f18:	e5e8      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000f1a:	bf00      	nop
 8000f1c:	200019ac 	.word	0x200019ac
 8000f20:	0000801e 	.word	0x0000801e
 8000f24:	2000      	movs	r0, #0
 8000f26:	9000      	str	r0, [sp, #0]
 8000f28:	2312      	movs	r3, #18
 8000f2a:	220d      	movs	r2, #13
 8000f2c:	2100      	movs	r1, #0
 8000f2e:	0020      	movs	r0, r4
 8000f30:	f002 fc1f 	bl	8003772 <PE_Send_CtrlMessage>
 8000f34:	2800      	cmp	r0, #0
 8000f36:	d1a3      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000f38:	488e      	ldr	r0, [pc, #568]	; (8001174 <__iar_annotation$$branch+0x77c>)
 8000f3a:	83b0      	strh	r0, [r6, #28]
 8000f3c:	251a      	movs	r5, #26
 8000f3e:	4f8e      	ldr	r7, [pc, #568]	; (8001178 <__iar_annotation$$branch+0x780>)
 8000f40:	7838      	ldrb	r0, [r7, #0]
 8000f42:	0780      	lsls	r0, r0, #30
 8000f44:	d509      	bpl.n	8000f5a <__iar_annotation$$branch+0x562>
 8000f46:	2000      	movs	r0, #0
 8000f48:	9000      	str	r0, [sp, #0]
 8000f4a:	2300      	movs	r3, #0
 8000f4c:	222e      	movs	r2, #46	; 0x2e
 8000f4e:	7b20      	ldrb	r0, [r4, #12]
 8000f50:	07c1      	lsls	r1, r0, #31
 8000f52:	0fc9      	lsrs	r1, r1, #31
 8000f54:	2009      	movs	r0, #9
 8000f56:	68ff      	ldr	r7, [r7, #12]
 8000f58:	47b8      	blx	r7
 8000f5a:	212e      	movs	r1, #46	; 0x2e
 8000f5c:	e5c6      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000f5e:	2911      	cmp	r1, #17
 8000f60:	d124      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f62:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000f64:	0bc9      	lsrs	r1, r1, #15
 8000f66:	d121      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f68:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000f6a:	0b09      	lsrs	r1, r1, #12
 8000f6c:	0749      	lsls	r1, r1, #29
 8000f6e:	d11d      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f70:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000f72:	06c9      	lsls	r1, r1, #27
 8000f74:	0ec9      	lsrs	r1, r1, #27
 8000f76:	2903      	cmp	r1, #3
 8000f78:	d118      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f7a:	2100      	movs	r1, #0
 8000f7c:	83b1      	strh	r1, [r6, #28]
 8000f7e:	2800      	cmp	r0, #0
 8000f80:	d008      	beq.n	8000f94 <__iar_annotation$$branch+0x59c>
 8000f82:	9100      	str	r1, [sp, #0]
 8000f84:	2300      	movs	r3, #0
 8000f86:	222f      	movs	r2, #47	; 0x2f
 8000f88:	7b20      	ldrb	r0, [r4, #12]
 8000f8a:	07c1      	lsls	r1, r0, #31
 8000f8c:	0fc9      	lsrs	r1, r1, #31
 8000f8e:	2009      	movs	r0, #9
 8000f90:	9f01      	ldr	r7, [sp, #4]
 8000f92:	47b8      	blx	r7
 8000f94:	212f      	movs	r1, #47	; 0x2f
 8000f96:	7b22      	ldrb	r2, [r4, #12]
 8000f98:	07d0      	lsls	r0, r2, #31
 8000f9a:	0fc0      	lsrs	r0, r0, #31
 8000f9c:	68a2      	ldr	r2, [r4, #8]
 8000f9e:	68d2      	ldr	r2, [r2, #12]
 8000fa0:	4790      	blx	r2
 8000fa2:	2007      	movs	r0, #7
 8000fa4:	7230      	strb	r0, [r6, #8]
 8000fa6:	2014      	movs	r0, #20
 8000fa8:	4669      	mov	r1, sp
 8000faa:	7308      	strb	r0, [r1, #12]
 8000fac:	8bb0      	ldrh	r0, [r6, #28]
 8000fae:	03a9      	lsls	r1, r5, #14
 8000fb0:	4288      	cmp	r0, r1
 8000fb2:	d000      	beq.n	8000fb6 <__iar_annotation$$branch+0x5be>
 8000fb4:	e506      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000fb6:	2000      	movs	r0, #0
 8000fb8:	83b0      	strh	r0, [r6, #28]
 8000fba:	e73a      	b.n	8000e32 <__iar_annotation$$branch+0x43a>
 8000fbc:	7b60      	ldrb	r0, [r4, #13]
 8000fbe:	21fc      	movs	r1, #252	; 0xfc
 8000fc0:	4001      	ands	r1, r0
 8000fc2:	7361      	strb	r1, [r4, #13]
 8000fc4:	0020      	movs	r0, r4
 8000fc6:	f002 fc81 	bl	80038cc <PE_Send_HARDRESET>
 8000fca:	68a0      	ldr	r0, [r4, #8]
 8000fcc:	6843      	ldr	r3, [r0, #4]
 8000fce:	2b00      	cmp	r3, #0
 8000fd0:	d005      	beq.n	8000fde <__iar_annotation$$branch+0x5e6>
 8000fd2:	2202      	movs	r2, #2
 8000fd4:	2101      	movs	r1, #1
 8000fd6:	7b25      	ldrb	r5, [r4, #12]
 8000fd8:	07e8      	lsls	r0, r5, #31
 8000fda:	0fc0      	lsrs	r0, r0, #31
 8000fdc:	4798      	blx	r3
 8000fde:	4867      	ldr	r0, [pc, #412]	; (800117c <__iar_annotation$$branch+0x784>)
 8000fe0:	82f0      	strh	r0, [r6, #22]
 8000fe2:	251b      	movs	r5, #27
 8000fe4:	7d20      	ldrb	r0, [r4, #20]
 8000fe6:	1c40      	adds	r0, r0, #1
 8000fe8:	7520      	strb	r0, [r4, #20]
 8000fea:	6860      	ldr	r0, [r4, #4]
 8000fec:	6801      	ldr	r1, [r0, #0]
 8000fee:	2210      	movs	r2, #16
 8000ff0:	4391      	bics	r1, r2
 8000ff2:	6001      	str	r1, [r0, #0]
 8000ff4:	2000      	movs	r0, #0
 8000ff6:	7130      	strb	r0, [r6, #4]
 8000ff8:	2015      	movs	r0, #21
 8000ffa:	e461      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000ffc:	495f      	ldr	r1, [pc, #380]	; (800117c <__iar_annotation$$branch+0x784>)
 8000ffe:	82f1      	strh	r1, [r6, #22]
 8001000:	251b      	movs	r5, #27
 8001002:	2115      	movs	r1, #21
 8001004:	7231      	strb	r1, [r6, #8]
 8001006:	2800      	cmp	r0, #0
 8001008:	d009      	beq.n	800101e <__iar_annotation$$branch+0x626>
 800100a:	2000      	movs	r0, #0
 800100c:	9000      	str	r0, [sp, #0]
 800100e:	2300      	movs	r3, #0
 8001010:	221d      	movs	r2, #29
 8001012:	7b20      	ldrb	r0, [r4, #12]
 8001014:	07c1      	lsls	r1, r0, #31
 8001016:	0fc9      	lsrs	r1, r1, #31
 8001018:	2009      	movs	r0, #9
 800101a:	9f01      	ldr	r7, [sp, #4]
 800101c:	47b8      	blx	r7
 800101e:	211d      	movs	r1, #29
 8001020:	e564      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8001022:	8af0      	ldrh	r0, [r6, #22]
 8001024:	03a9      	lsls	r1, r5, #14
 8001026:	4288      	cmp	r0, r1
 8001028:	d150      	bne.n	80010cc <__iar_annotation$$branch+0x6d4>
 800102a:	2000      	movs	r0, #0
 800102c:	82f0      	strh	r0, [r6, #22]
 800102e:	7d21      	ldrb	r1, [r4, #20]
 8001030:	2903      	cmp	r1, #3
 8001032:	d311      	bcc.n	8001058 <__iar_annotation$$branch+0x660>
 8001034:	7520      	strb	r0, [r4, #20]
 8001036:	7230      	strb	r0, [r6, #8]
 8001038:	4f4f      	ldr	r7, [pc, #316]	; (8001178 <__iar_annotation$$branch+0x780>)
 800103a:	7838      	ldrb	r0, [r7, #0]
 800103c:	0780      	lsls	r0, r0, #30
 800103e:	d509      	bpl.n	8001054 <__iar_annotation$$branch+0x65c>
 8001040:	2000      	movs	r0, #0
 8001042:	9000      	str	r0, [sp, #0]
 8001044:	2300      	movs	r3, #0
 8001046:	2220      	movs	r2, #32
 8001048:	7b20      	ldrb	r0, [r4, #12]
 800104a:	07c1      	lsls	r1, r0, #31
 800104c:	0fc9      	lsrs	r1, r1, #31
 800104e:	2009      	movs	r0, #9
 8001050:	68ff      	ldr	r7, [r7, #12]
 8001052:	47b8      	blx	r7
 8001054:	2120      	movs	r1, #32
 8001056:	e549      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8001058:	68a0      	ldr	r0, [r4, #8]
 800105a:	6843      	ldr	r3, [r0, #4]
 800105c:	2b00      	cmp	r3, #0
 800105e:	d00a      	beq.n	8001076 <__iar_annotation$$branch+0x67e>
 8001060:	7b60      	ldrb	r0, [r4, #13]
 8001062:	0780      	lsls	r0, r0, #30
 8001064:	0f80      	lsrs	r0, r0, #30
 8001066:	1e42      	subs	r2, r0, #1
 8001068:	4192      	sbcs	r2, r2
 800106a:	0fd2      	lsrs	r2, r2, #31
 800106c:	2101      	movs	r1, #1
 800106e:	7b25      	ldrb	r5, [r4, #12]
 8001070:	07e8      	lsls	r0, r5, #31
 8001072:	0fc0      	lsrs	r0, r0, #31
 8001074:	4798      	blx	r3
 8001076:	4842      	ldr	r0, [pc, #264]	; (8001180 <__iar_annotation$$branch+0x788>)
 8001078:	9904      	ldr	r1, [sp, #16]
 800107a:	8008      	strh	r0, [r1, #0]
 800107c:	25c8      	movs	r5, #200	; 0xc8
 800107e:	00ad      	lsls	r5, r5, #2
 8001080:	2013      	movs	r0, #19
 8001082:	e41d      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8001084:	68a0      	ldr	r0, [r4, #8]
 8001086:	6843      	ldr	r3, [r0, #4]
 8001088:	2701      	movs	r7, #1
 800108a:	2b00      	cmp	r3, #0
 800108c:	d005      	beq.n	800109a <__iar_annotation$$branch+0x6a2>
 800108e:	2204      	movs	r2, #4
 8001090:	68e1      	ldr	r1, [r4, #12]
 8001092:	2001      	movs	r0, #1
 8001094:	4008      	ands	r0, r1
 8001096:	2101      	movs	r1, #1
 8001098:	4798      	blx	r3
 800109a:	8ab0      	ldrh	r0, [r6, #20]
 800109c:	03a9      	lsls	r1, r5, #14
 800109e:	4288      	cmp	r0, r1
 80010a0:	d114      	bne.n	80010cc <__iar_annotation$$branch+0x6d4>
 80010a2:	2000      	movs	r0, #0
 80010a4:	9904      	ldr	r1, [sp, #16]
 80010a6:	8008      	strh	r0, [r1, #0]
 80010a8:	68a0      	ldr	r0, [r4, #8]
 80010aa:	6843      	ldr	r3, [r0, #4]
 80010ac:	2b00      	cmp	r3, #0
 80010ae:	d005      	beq.n	80010bc <__iar_annotation$$branch+0x6c4>
 80010b0:	2205      	movs	r2, #5
 80010b2:	2101      	movs	r1, #1
 80010b4:	68e0      	ldr	r0, [r4, #12]
 80010b6:	4007      	ands	r7, r0
 80010b8:	0038      	movs	r0, r7
 80010ba:	4798      	blx	r3
 80010bc:	4831      	ldr	r0, [pc, #196]	; (8001184 <__iar_annotation$$branch+0x78c>)
 80010be:	83f0      	strh	r0, [r6, #30]
 80010c0:	2101      	movs	r1, #1
 80010c2:	a80a      	add	r0, sp, #40	; 0x28
 80010c4:	7800      	ldrb	r0, [r0, #0]
 80010c6:	f003 f862 	bl	800418e <PE_Reset>
 80010ca:	7235      	strb	r5, [r6, #8]
 80010cc:	e47a      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80010ce:	2011      	movs	r0, #17
 80010d0:	82e0      	strh	r0, [r4, #22]
 80010d2:	2105      	movs	r1, #5
 80010d4:	7b22      	ldrb	r2, [r4, #12]
 80010d6:	07d0      	lsls	r0, r2, #31
 80010d8:	0fc0      	lsrs	r0, r0, #31
 80010da:	f004 f9aa 	bl	8005432 <USBDPD_PRL_BistCarrierEyeMode>
 80010de:	2028      	movs	r0, #40	; 0x28
 80010e0:	7230      	strb	r0, [r6, #8]
 80010e2:	4829      	ldr	r0, [pc, #164]	; (8001188 <__iar_annotation$$branch+0x790>)
 80010e4:	85b0      	strh	r0, [r6, #44]	; 0x2c
 80010e6:	253a      	movs	r5, #58	; 0x3a
 80010e8:	e46c      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80010ea:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 80010ec:	03a9      	lsls	r1, r5, #14
 80010ee:	4288      	cmp	r0, r1
 80010f0:	d1fa      	bne.n	80010e8 <__iar_annotation$$branch+0x6f0>
 80010f2:	2105      	movs	r1, #5
 80010f4:	7b22      	ldrb	r2, [r4, #12]
 80010f6:	07d0      	lsls	r0, r2, #31
 80010f8:	0fc0      	lsrs	r0, r0, #31
 80010fa:	f004 f9a2 	bl	8005442 <USBDPD_PRL_BistCarrierEyeModeExit>
 80010fe:	2000      	movs	r0, #0
 8001100:	85b0      	strh	r0, [r6, #44]	; 0x2c
 8001102:	e694      	b.n	8000e2e <__iar_annotation$$branch+0x436>
 8001104:	2911      	cmp	r1, #17
 8001106:	d10e      	bne.n	8001126 <__iar_annotation$$branch+0x72e>
 8001108:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800110a:	0bc0      	lsrs	r0, r0, #15
 800110c:	d10b      	bne.n	8001126 <__iar_annotation$$branch+0x72e>
 800110e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001110:	0b00      	lsrs	r0, r0, #12
 8001112:	0740      	lsls	r0, r0, #29
 8001114:	d007      	beq.n	8001126 <__iar_annotation$$branch+0x72e>
 8001116:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001118:	06c0      	lsls	r0, r0, #27
 800111a:	0ec0      	lsrs	r0, r0, #27
 800111c:	2803      	cmp	r0, #3
 800111e:	d102      	bne.n	8001126 <__iar_annotation$$branch+0x72e>
 8001120:	2014      	movs	r0, #20
 8001122:	4669      	mov	r1, sp
 8001124:	7308      	strb	r0, [r1, #12]
 8001126:	2011      	movs	r0, #17
 8001128:	82e0      	strh	r0, [r4, #22]
 800112a:	e44b      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 800112c:	2000      	movs	r0, #0
 800112e:	9000      	str	r0, [sp, #0]
 8001130:	2319      	movs	r3, #25
 8001132:	2208      	movs	r2, #8
 8001134:	2100      	movs	r1, #0
 8001136:	0020      	movs	r0, r4
 8001138:	f002 fb1b 	bl	8003772 <PE_Send_CtrlMessage>
 800113c:	2800      	cmp	r0, #0
 800113e:	d1f4      	bne.n	800112a <__iar_annotation$$branch+0x732>
 8001140:	2007      	movs	r0, #7
 8001142:	82e0      	strh	r0, [r4, #22]
 8001144:	480b      	ldr	r0, [pc, #44]	; (8001174 <__iar_annotation$$branch+0x77c>)
 8001146:	83b0      	strh	r0, [r6, #28]
 8001148:	251a      	movs	r5, #26
 800114a:	4f0b      	ldr	r7, [pc, #44]	; (8001178 <__iar_annotation$$branch+0x780>)
 800114c:	7838      	ldrb	r0, [r7, #0]
 800114e:	0780      	lsls	r0, r0, #30
 8001150:	d509      	bpl.n	8001166 <__iar_annotation$$branch+0x76e>
 8001152:	2000      	movs	r0, #0
 8001154:	9000      	str	r0, [sp, #0]
 8001156:	2300      	movs	r3, #0
 8001158:	2205      	movs	r2, #5
 800115a:	7b20      	ldrb	r0, [r4, #12]
 800115c:	07c1      	lsls	r1, r0, #31
 800115e:	0fc9      	lsrs	r1, r1, #31
 8001160:	2009      	movs	r0, #9
 8001162:	68ff      	ldr	r7, [r7, #12]
 8001164:	47b8      	blx	r7
 8001166:	2105      	movs	r1, #5
 8001168:	e4c0      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 800116a:	bf00      	nop
 800116c:	00008226 	.word	0x00008226
 8001170:	00000226 	.word	0x00000226
 8001174:	0000801a 	.word	0x0000801a
 8001178:	200019ac 	.word	0x200019ac
 800117c:	0000801b 	.word	0x0000801b
 8001180:	00008320 	.word	0x00008320
 8001184:	0000957c 	.word	0x0000957c
 8001188:	0000803a 	.word	0x0000803a
 800118c:	2911      	cmp	r1, #17
 800118e:	d15e      	bne.n	800124e <__iar_annotation$$branch+0x856>
 8001190:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001192:	0bc0      	lsrs	r0, r0, #15
 8001194:	d133      	bne.n	80011fe <__iar_annotation$$branch+0x806>
 8001196:	2007      	movs	r0, #7
 8001198:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800119a:	0b09      	lsrs	r1, r1, #12
 800119c:	4201      	tst	r1, r0
 800119e:	d02e      	beq.n	80011fe <__iar_annotation$$branch+0x806>
 80011a0:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80011a2:	06c9      	lsls	r1, r1, #27
 80011a4:	0ec9      	lsrs	r1, r1, #27
 80011a6:	2904      	cmp	r1, #4
 80011a8:	d129      	bne.n	80011fe <__iar_annotation$$branch+0x806>
 80011aa:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80011ac:	0b09      	lsrs	r1, r1, #12
 80011ae:	4008      	ands	r0, r1
 80011b0:	0083      	lsls	r3, r0, #2
 80011b2:	209e      	movs	r0, #158	; 0x9e
 80011b4:	0040      	lsls	r0, r0, #1
 80011b6:	1822      	adds	r2, r4, r0
 80011b8:	2105      	movs	r1, #5
 80011ba:	7b27      	ldrb	r7, [r4, #12]
 80011bc:	07f8      	lsls	r0, r7, #31
 80011be:	0fc0      	lsrs	r0, r0, #31
 80011c0:	68a7      	ldr	r7, [r4, #8]
 80011c2:	69ff      	ldr	r7, [r7, #28]
 80011c4:	47b8      	blx	r7
 80011c6:	2000      	movs	r0, #0
 80011c8:	83b0      	strh	r0, [r6, #28]
 80011ca:	2003      	movs	r0, #3
 80011cc:	7230      	strb	r0, [r6, #8]
 80011ce:	2014      	movs	r0, #20
 80011d0:	4669      	mov	r1, sp
 80011d2:	7308      	strb	r0, [r1, #12]
 80011d4:	4fd0      	ldr	r7, [pc, #832]	; (8001518 <__iar_annotation$$branch+0xb20>)
 80011d6:	7838      	ldrb	r0, [r7, #0]
 80011d8:	0780      	lsls	r0, r0, #30
 80011da:	d509      	bpl.n	80011f0 <__iar_annotation$$branch+0x7f8>
 80011dc:	2000      	movs	r0, #0
 80011de:	9000      	str	r0, [sp, #0]
 80011e0:	2300      	movs	r3, #0
 80011e2:	2207      	movs	r2, #7
 80011e4:	7b20      	ldrb	r0, [r4, #12]
 80011e6:	07c1      	lsls	r1, r0, #31
 80011e8:	0fc9      	lsrs	r1, r1, #31
 80011ea:	2009      	movs	r0, #9
 80011ec:	68ff      	ldr	r7, [r7, #12]
 80011ee:	47b8      	blx	r7
 80011f0:	2107      	movs	r1, #7
 80011f2:	7b22      	ldrb	r2, [r4, #12]
 80011f4:	07d0      	lsls	r0, r2, #31
 80011f6:	0fc0      	lsrs	r0, r0, #31
 80011f8:	68a2      	ldr	r2, [r4, #8]
 80011fa:	68d2      	ldr	r2, [r2, #12]
 80011fc:	4790      	blx	r2
 80011fe:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001200:	0bc0      	lsrs	r0, r0, #15
 8001202:	d124      	bne.n	800124e <__iar_annotation$$branch+0x856>
 8001204:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001206:	0b00      	lsrs	r0, r0, #12
 8001208:	0740      	lsls	r0, r0, #29
 800120a:	d120      	bne.n	800124e <__iar_annotation$$branch+0x856>
 800120c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800120e:	06c0      	lsls	r0, r0, #27
 8001210:	0ec0      	lsrs	r0, r0, #27
 8001212:	2804      	cmp	r0, #4
 8001214:	d11b      	bne.n	800124e <__iar_annotation$$branch+0x856>
 8001216:	2000      	movs	r0, #0
 8001218:	83b0      	strh	r0, [r6, #28]
 800121a:	2003      	movs	r0, #3
 800121c:	7230      	strb	r0, [r6, #8]
 800121e:	2014      	movs	r0, #20
 8001220:	4669      	mov	r1, sp
 8001222:	7308      	strb	r0, [r1, #12]
 8001224:	4fbc      	ldr	r7, [pc, #752]	; (8001518 <__iar_annotation$$branch+0xb20>)
 8001226:	7838      	ldrb	r0, [r7, #0]
 8001228:	0780      	lsls	r0, r0, #30
 800122a:	d509      	bpl.n	8001240 <__iar_annotation$$branch+0x848>
 800122c:	2000      	movs	r0, #0
 800122e:	9000      	str	r0, [sp, #0]
 8001230:	2300      	movs	r3, #0
 8001232:	2208      	movs	r2, #8
 8001234:	7b20      	ldrb	r0, [r4, #12]
 8001236:	07c1      	lsls	r1, r0, #31
 8001238:	0fc9      	lsrs	r1, r1, #31
 800123a:	2009      	movs	r0, #9
 800123c:	68ff      	ldr	r7, [r7, #12]
 800123e:	47b8      	blx	r7
 8001240:	2108      	movs	r1, #8
 8001242:	7b22      	ldrb	r2, [r4, #12]
 8001244:	07d0      	lsls	r0, r2, #31
 8001246:	0fc0      	lsrs	r0, r0, #31
 8001248:	68a2      	ldr	r2, [r4, #8]
 800124a:	68d2      	ldr	r2, [r2, #12]
 800124c:	4790      	blx	r2
 800124e:	8bb0      	ldrh	r0, [r6, #28]
 8001250:	03a9      	lsls	r1, r5, #14
 8001252:	4288      	cmp	r0, r1
 8001254:	d11e      	bne.n	8001294 <__iar_annotation$$branch+0x89c>
 8001256:	4fb0      	ldr	r7, [pc, #704]	; (8001518 <__iar_annotation$$branch+0xb20>)
 8001258:	7838      	ldrb	r0, [r7, #0]
 800125a:	0780      	lsls	r0, r0, #30
 800125c:	d509      	bpl.n	8001272 <__iar_annotation$$branch+0x87a>
 800125e:	2000      	movs	r0, #0
 8001260:	9000      	str	r0, [sp, #0]
 8001262:	2300      	movs	r3, #0
 8001264:	2209      	movs	r2, #9
 8001266:	7b20      	ldrb	r0, [r4, #12]
 8001268:	07c1      	lsls	r1, r0, #31
 800126a:	0fc9      	lsrs	r1, r1, #31
 800126c:	2009      	movs	r0, #9
 800126e:	68ff      	ldr	r7, [r7, #12]
 8001270:	47b8      	blx	r7
 8001272:	2109      	movs	r1, #9
 8001274:	7b22      	ldrb	r2, [r4, #12]
 8001276:	07d0      	lsls	r0, r2, #31
 8001278:	0fc0      	lsrs	r0, r0, #31
 800127a:	68a2      	ldr	r2, [r4, #8]
 800127c:	68d2      	ldr	r2, [r2, #12]
 800127e:	4790      	blx	r2
 8001280:	e5d5      	b.n	8000e2e <__iar_annotation$$branch+0x436>
 8001282:	2001      	movs	r0, #1
 8001284:	9000      	str	r0, [sp, #0]
 8001286:	231b      	movs	r3, #27
 8001288:	2207      	movs	r2, #7
 800128a:	2100      	movs	r1, #0
 800128c:	0020      	movs	r0, r4
 800128e:	f002 fa70 	bl	8003772 <PE_Send_CtrlMessage>
 8001292:	2800      	cmp	r0, #0
 8001294:	d000      	beq.n	8001298 <__iar_annotation$$branch+0x8a0>
 8001296:	e748      	b.n	800112a <__iar_annotation$$branch+0x732>
 8001298:	2006      	movs	r0, #6
 800129a:	82e0      	strh	r0, [r4, #22]
 800129c:	489f      	ldr	r0, [pc, #636]	; (800151c <__iar_annotation$$branch+0xb24>)
 800129e:	83b0      	strh	r0, [r6, #28]
 80012a0:	251a      	movs	r5, #26
 80012a2:	4f9d      	ldr	r7, [pc, #628]	; (8001518 <__iar_annotation$$branch+0xb20>)
 80012a4:	7838      	ldrb	r0, [r7, #0]
 80012a6:	0780      	lsls	r0, r0, #30
 80012a8:	d509      	bpl.n	80012be <__iar_annotation$$branch+0x8c6>
 80012aa:	2000      	movs	r0, #0
 80012ac:	9000      	str	r0, [sp, #0]
 80012ae:	2300      	movs	r3, #0
 80012b0:	220b      	movs	r2, #11
 80012b2:	7b20      	ldrb	r0, [r4, #12]
 80012b4:	07c1      	lsls	r1, r0, #31
 80012b6:	0fc9      	lsrs	r1, r1, #31
 80012b8:	2009      	movs	r0, #9
 80012ba:	68ff      	ldr	r7, [r7, #12]
 80012bc:	47b8      	blx	r7
 80012be:	210b      	movs	r1, #11
 80012c0:	e752      	b.n	8001168 <__iar_annotation$$branch+0x770>
 80012c2:	2911      	cmp	r1, #17
 80012c4:	d162      	bne.n	800138c <__iar_annotation$$branch+0x994>
 80012c6:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 80012c8:	0bc0      	lsrs	r0, r0, #15
 80012ca:	d133      	bne.n	8001334 <__iar_annotation$$branch+0x93c>
 80012cc:	2007      	movs	r0, #7
 80012ce:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80012d0:	0b09      	lsrs	r1, r1, #12
 80012d2:	4201      	tst	r1, r0
 80012d4:	d02e      	beq.n	8001334 <__iar_annotation$$branch+0x93c>
 80012d6:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80012d8:	06c9      	lsls	r1, r1, #27
 80012da:	0ec9      	lsrs	r1, r1, #27
 80012dc:	2901      	cmp	r1, #1
 80012de:	d129      	bne.n	8001334 <__iar_annotation$$branch+0x93c>
 80012e0:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80012e2:	0b09      	lsrs	r1, r1, #12
 80012e4:	4008      	ands	r0, r1
 80012e6:	0083      	lsls	r3, r0, #2
 80012e8:	209e      	movs	r0, #158	; 0x9e
 80012ea:	0040      	lsls	r0, r0, #1
 80012ec:	1822      	adds	r2, r4, r0
 80012ee:	2104      	movs	r1, #4
 80012f0:	7b27      	ldrb	r7, [r4, #12]
 80012f2:	07f8      	lsls	r0, r7, #31
 80012f4:	0fc0      	lsrs	r0, r0, #31
 80012f6:	68a7      	ldr	r7, [r4, #8]
 80012f8:	69ff      	ldr	r7, [r7, #28]
 80012fa:	47b8      	blx	r7
 80012fc:	2000      	movs	r0, #0
 80012fe:	83b0      	strh	r0, [r6, #28]
 8001300:	2003      	movs	r0, #3
 8001302:	7230      	strb	r0, [r6, #8]
 8001304:	2014      	movs	r0, #20
 8001306:	4669      	mov	r1, sp
 8001308:	7308      	strb	r0, [r1, #12]
 800130a:	4f83      	ldr	r7, [pc, #524]	; (8001518 <__iar_annotation$$branch+0xb20>)
 800130c:	7838      	ldrb	r0, [r7, #0]
 800130e:	0780      	lsls	r0, r0, #30
 8001310:	d509      	bpl.n	8001326 <__iar_annotation$$branch+0x92e>
 8001312:	2000      	movs	r0, #0
 8001314:	9000      	str	r0, [sp, #0]
 8001316:	2300      	movs	r3, #0
 8001318:	220d      	movs	r2, #13
 800131a:	7b20      	ldrb	r0, [r4, #12]
 800131c:	07c1      	lsls	r1, r0, #31
 800131e:	0fc9      	lsrs	r1, r1, #31
 8001320:	2009      	movs	r0, #9
 8001322:	68ff      	ldr	r7, [r7, #12]
 8001324:	47b8      	blx	r7
 8001326:	210d      	movs	r1, #13
 8001328:	7b22      	ldrb	r2, [r4, #12]
 800132a:	07d0      	lsls	r0, r2, #31
 800132c:	0fc0      	lsrs	r0, r0, #31
 800132e:	68a2      	ldr	r2, [r4, #8]
 8001330:	68d2      	ldr	r2, [r2, #12]
 8001332:	4790      	blx	r2
 8001334:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001336:	0bc0      	lsrs	r0, r0, #15
 8001338:	d128      	bne.n	800138c <__iar_annotation$$branch+0x994>
 800133a:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800133c:	0b00      	lsrs	r0, r0, #12
 800133e:	0740      	lsls	r0, r0, #29
 8001340:	d124      	bne.n	800138c <__iar_annotation$$branch+0x994>
 8001342:	201f      	movs	r0, #31
 8001344:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8001346:	4001      	ands	r1, r0
 8001348:	2904      	cmp	r1, #4
 800134a:	d003      	beq.n	8001354 <__iar_annotation$$branch+0x95c>
 800134c:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800134e:	4008      	ands	r0, r1
 8001350:	2810      	cmp	r0, #16
 8001352:	d11b      	bne.n	800138c <__iar_annotation$$branch+0x994>
 8001354:	2000      	movs	r0, #0
 8001356:	83b0      	strh	r0, [r6, #28]
 8001358:	2003      	movs	r0, #3
 800135a:	7230      	strb	r0, [r6, #8]
 800135c:	2014      	movs	r0, #20
 800135e:	4669      	mov	r1, sp
 8001360:	7308      	strb	r0, [r1, #12]
 8001362:	4f6d      	ldr	r7, [pc, #436]	; (8001518 <__iar_annotation$$branch+0xb20>)
 8001364:	7838      	ldrb	r0, [r7, #0]
 8001366:	0780      	lsls	r0, r0, #30
 8001368:	d509      	bpl.n	800137e <__iar_annotation$$branch+0x986>
 800136a:	2000      	movs	r0, #0
 800136c:	9000      	str	r0, [sp, #0]
 800136e:	2300      	movs	r3, #0
 8001370:	220e      	movs	r2, #14
 8001372:	7b20      	ldrb	r0, [r4, #12]
 8001374:	07c1      	lsls	r1, r0, #31
 8001376:	0fc9      	lsrs	r1, r1, #31
 8001378:	2009      	movs	r0, #9
 800137a:	68ff      	ldr	r7, [r7, #12]
 800137c:	47b8      	blx	r7
 800137e:	210e      	movs	r1, #14
 8001380:	7b22      	ldrb	r2, [r4, #12]
 8001382:	07d0      	lsls	r0, r2, #31
 8001384:	0fc0      	lsrs	r0, r0, #31
 8001386:	68a2      	ldr	r2, [r4, #8]
 8001388:	68d2      	ldr	r2, [r2, #12]
 800138a:	4790      	blx	r2
 800138c:	8bb0      	ldrh	r0, [r6, #28]
 800138e:	03a9      	lsls	r1, r5, #14
 8001390:	e1cf      	b.n	8001732 <__iar_annotation$$branch+0x164>
 8001392:	68a0      	ldr	r0, [r4, #8]
 8001394:	6881      	ldr	r1, [r0, #8]
 8001396:	2900      	cmp	r1, #0
 8001398:	d108      	bne.n	80013ac <__iar_annotation$$branch+0x9b4>
 800139a:	2000      	movs	r0, #0
 800139c:	9000      	str	r0, [sp, #0]
 800139e:	2303      	movs	r3, #3
 80013a0:	2204      	movs	r2, #4
 80013a2:	2100      	movs	r1, #0
 80013a4:	0020      	movs	r0, r4
 80013a6:	f002 f9e4 	bl	8003772 <PE_Send_CtrlMessage>
 80013aa:	e6be      	b.n	800112a <__iar_annotation$$branch+0x732>
 80013ac:	7b22      	ldrb	r2, [r4, #12]
 80013ae:	07d0      	lsls	r0, r2, #31
 80013b0:	0fc0      	lsrs	r0, r0, #31
 80013b2:	4788      	blx	r1
 80013b4:	280a      	cmp	r0, #10
 80013b6:	d002      	beq.n	80013be <__iar_annotation$$branch+0x9c6>
 80013b8:	280d      	cmp	r0, #13
 80013ba:	d025      	beq.n	8001408 <__iar_annotation$$branch+0xa10>
 80013bc:	e03c      	b.n	8001438 <__iar_annotation$$branch+0xa40>
 80013be:	4858      	ldr	r0, [pc, #352]	; (8001520 <__iar_annotation$$branch+0xb28>)
 80013c0:	8470      	strh	r0, [r6, #34]	; 0x22
 80013c2:	251e      	movs	r5, #30
 80013c4:	2000      	movs	r0, #0
 80013c6:	9000      	str	r0, [sp, #0]
 80013c8:	2324      	movs	r3, #36	; 0x24
 80013ca:	2203      	movs	r2, #3
 80013cc:	2100      	movs	r1, #0
 80013ce:	0020      	movs	r0, r4
 80013d0:	f002 f9cf 	bl	8003772 <PE_Send_CtrlMessage>
 80013d4:	68a0      	ldr	r0, [r4, #8]
 80013d6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80013d8:	2b00      	cmp	r3, #0
 80013da:	d005      	beq.n	80013e8 <__iar_annotation$$branch+0x9f0>
 80013dc:	2201      	movs	r2, #1
 80013de:	2101      	movs	r1, #1
 80013e0:	7b27      	ldrb	r7, [r4, #12]
 80013e2:	07f8      	lsls	r0, r7, #31
 80013e4:	0fc0      	lsrs	r0, r0, #31
 80013e6:	4798      	blx	r3
 80013e8:	4f4b      	ldr	r7, [pc, #300]	; (8001518 <__iar_annotation$$branch+0xb20>)
 80013ea:	7838      	ldrb	r0, [r7, #0]
 80013ec:	0780      	lsls	r0, r0, #30
 80013ee:	d509      	bpl.n	8001404 <__iar_annotation$$branch+0xa0c>
 80013f0:	2000      	movs	r0, #0
 80013f2:	9000      	str	r0, [sp, #0]
 80013f4:	2300      	movs	r3, #0
 80013f6:	2238      	movs	r2, #56	; 0x38
 80013f8:	7b20      	ldrb	r0, [r4, #12]
 80013fa:	07c1      	lsls	r1, r0, #31
 80013fc:	0fc9      	lsrs	r1, r1, #31
 80013fe:	2009      	movs	r0, #9
 8001400:	68ff      	ldr	r7, [r7, #12]
 8001402:	47b8      	blx	r7
 8001404:	2138      	movs	r1, #56	; 0x38
 8001406:	e6af      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001408:	2000      	movs	r0, #0
 800140a:	9000      	str	r0, [sp, #0]
 800140c:	2303      	movs	r3, #3
 800140e:	220c      	movs	r2, #12
 8001410:	2100      	movs	r1, #0
 8001412:	0020      	movs	r0, r4
 8001414:	f002 f9ad 	bl	8003772 <PE_Send_CtrlMessage>
 8001418:	4f3f      	ldr	r7, [pc, #252]	; (8001518 <__iar_annotation$$branch+0xb20>)
 800141a:	7838      	ldrb	r0, [r7, #0]
 800141c:	0780      	lsls	r0, r0, #30
 800141e:	d509      	bpl.n	8001434 <__iar_annotation$$branch+0xa3c>
 8001420:	2000      	movs	r0, #0
 8001422:	9000      	str	r0, [sp, #0]
 8001424:	2300      	movs	r3, #0
 8001426:	2239      	movs	r2, #57	; 0x39
 8001428:	7b20      	ldrb	r0, [r4, #12]
 800142a:	07c1      	lsls	r1, r0, #31
 800142c:	0fc9      	lsrs	r1, r1, #31
 800142e:	2009      	movs	r0, #9
 8001430:	68ff      	ldr	r7, [r7, #12]
 8001432:	47b8      	blx	r7
 8001434:	2139      	movs	r1, #57	; 0x39
 8001436:	e697      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001438:	2000      	movs	r0, #0
 800143a:	9000      	str	r0, [sp, #0]
 800143c:	2303      	movs	r3, #3
 800143e:	2204      	movs	r2, #4
 8001440:	2100      	movs	r1, #0
 8001442:	0020      	movs	r0, r4
 8001444:	f002 f995 	bl	8003772 <PE_Send_CtrlMessage>
 8001448:	4f33      	ldr	r7, [pc, #204]	; (8001518 <__iar_annotation$$branch+0xb20>)
 800144a:	7838      	ldrb	r0, [r7, #0]
 800144c:	0780      	lsls	r0, r0, #30
 800144e:	d509      	bpl.n	8001464 <__iar_annotation$$branch+0xa6c>
 8001450:	2000      	movs	r0, #0
 8001452:	9000      	str	r0, [sp, #0]
 8001454:	2300      	movs	r3, #0
 8001456:	2216      	movs	r2, #22
 8001458:	7b20      	ldrb	r0, [r4, #12]
 800145a:	07c1      	lsls	r1, r0, #31
 800145c:	0fc9      	lsrs	r1, r1, #31
 800145e:	2009      	movs	r0, #9
 8001460:	68ff      	ldr	r7, [r7, #12]
 8001462:	47b8      	blx	r7
 8001464:	2116      	movs	r1, #22
 8001466:	e67f      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001468:	8c71      	ldrh	r1, [r6, #34]	; 0x22
 800146a:	03aa      	lsls	r2, r5, #14
 800146c:	4291      	cmp	r1, r2
 800146e:	d151      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 8001470:	2100      	movs	r1, #0
 8001472:	8471      	strh	r1, [r6, #34]	; 0x22
 8001474:	6861      	ldr	r1, [r4, #4]
 8001476:	784a      	ldrb	r2, [r1, #1]
 8001478:	238f      	movs	r3, #143	; 0x8f
 800147a:	4013      	ands	r3, r2
 800147c:	2240      	movs	r2, #64	; 0x40
 800147e:	431a      	orrs	r2, r3
 8001480:	704a      	strb	r2, [r1, #1]
 8001482:	2800      	cmp	r0, #0
 8001484:	d009      	beq.n	800149a <__iar_annotation$$branch+0xaa2>
 8001486:	2000      	movs	r0, #0
 8001488:	9000      	str	r0, [sp, #0]
 800148a:	2300      	movs	r3, #0
 800148c:	2256      	movs	r2, #86	; 0x56
 800148e:	7b20      	ldrb	r0, [r4, #12]
 8001490:	07c1      	lsls	r1, r0, #31
 8001492:	0fc9      	lsrs	r1, r1, #31
 8001494:	2009      	movs	r0, #9
 8001496:	9f01      	ldr	r7, [sp, #4]
 8001498:	47b8      	blx	r7
 800149a:	2701      	movs	r7, #1
 800149c:	2156      	movs	r1, #86	; 0x56
 800149e:	68e2      	ldr	r2, [r4, #12]
 80014a0:	2001      	movs	r0, #1
 80014a2:	4010      	ands	r0, r2
 80014a4:	68a2      	ldr	r2, [r4, #8]
 80014a6:	68d2      	ldr	r2, [r2, #12]
 80014a8:	4790      	blx	r2
 80014aa:	6860      	ldr	r0, [r4, #4]
 80014ac:	6801      	ldr	r1, [r0, #0]
 80014ae:	2210      	movs	r2, #16
 80014b0:	430a      	orrs	r2, r1
 80014b2:	6002      	str	r2, [r0, #0]
 80014b4:	68a0      	ldr	r0, [r4, #8]
 80014b6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80014b8:	2b00      	cmp	r3, #0
 80014ba:	d00f      	beq.n	80014dc <__iar_annotation$$branch+0xae4>
 80014bc:	2206      	movs	r2, #6
 80014be:	68e1      	ldr	r1, [r4, #12]
 80014c0:	2001      	movs	r0, #1
 80014c2:	4008      	ands	r0, r1
 80014c4:	2101      	movs	r1, #1
 80014c6:	4798      	blx	r3
 80014c8:	68a0      	ldr	r0, [r4, #8]
 80014ca:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80014cc:	2b00      	cmp	r3, #0
 80014ce:	d005      	beq.n	80014dc <__iar_annotation$$branch+0xae4>
 80014d0:	2207      	movs	r2, #7
 80014d2:	68e1      	ldr	r1, [r4, #12]
 80014d4:	2001      	movs	r0, #1
 80014d6:	4008      	ands	r0, r1
 80014d8:	2101      	movs	r1, #1
 80014da:	4798      	blx	r3
 80014dc:	2100      	movs	r1, #0
 80014de:	68e2      	ldr	r2, [r4, #12]
 80014e0:	2001      	movs	r0, #1
 80014e2:	4010      	ands	r0, r2
 80014e4:	f003 fd1d 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 80014e8:	2000      	movs	r0, #0
 80014ea:	9000      	str	r0, [sp, #0]
 80014ec:	2325      	movs	r3, #37	; 0x25
 80014ee:	2206      	movs	r2, #6
 80014f0:	2100      	movs	r1, #0
 80014f2:	0020      	movs	r0, r4
 80014f4:	f002 f93d 	bl	8003772 <PE_Send_CtrlMessage>
 80014f8:	2800      	cmp	r0, #0
 80014fa:	d10b      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 80014fc:	68a0      	ldr	r0, [r4, #8]
 80014fe:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001500:	2b00      	cmp	r3, #0
 8001502:	d005      	beq.n	8001510 <__iar_annotation$$branch+0xb18>
 8001504:	2208      	movs	r2, #8
 8001506:	2101      	movs	r1, #1
 8001508:	68e0      	ldr	r0, [r4, #12]
 800150a:	4007      	ands	r7, r0
 800150c:	0038      	movs	r0, r7
 800150e:	4798      	blx	r3
 8001510:	48bd      	ldr	r0, [pc, #756]	; (8001808 <__iar_annotation$$branch+0x23a>)
 8001512:	8370      	strh	r0, [r6, #26]
 8001514:	e609      	b.n	800112a <__iar_annotation$$branch+0x732>
 8001516:	bf00      	nop
 8001518:	200019ac 	.word	0x200019ac
 800151c:	0000801a 	.word	0x0000801a
 8001520:	0000801e 	.word	0x0000801e
 8001524:	2911      	cmp	r1, #17
 8001526:	d112      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 8001528:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800152a:	0bc0      	lsrs	r0, r0, #15
 800152c:	d10f      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 800152e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001530:	0b00      	lsrs	r0, r0, #12
 8001532:	0740      	lsls	r0, r0, #29
 8001534:	d10b      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 8001536:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001538:	06c0      	lsls	r0, r0, #27
 800153a:	0ec0      	lsrs	r0, r0, #27
 800153c:	2806      	cmp	r0, #6
 800153e:	d106      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 8001540:	2000      	movs	r0, #0
 8001542:	8370      	strh	r0, [r6, #26]
 8001544:	2014      	movs	r0, #20
 8001546:	4669      	mov	r1, sp
 8001548:	7308      	strb	r0, [r1, #12]
 800154a:	2026      	movs	r0, #38	; 0x26
 800154c:	7230      	strb	r0, [r6, #8]
 800154e:	8b70      	ldrh	r0, [r6, #26]
 8001550:	03a9      	lsls	r1, r5, #14
 8001552:	4288      	cmp	r0, r1
 8001554:	d1de      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 8001556:	68a0      	ldr	r0, [r4, #8]
 8001558:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800155a:	2b00      	cmp	r3, #0
 800155c:	d005      	beq.n	800156a <__iar_annotation$$branch+0xb72>
 800155e:	220a      	movs	r2, #10
 8001560:	2101      	movs	r1, #1
 8001562:	7b27      	ldrb	r7, [r4, #12]
 8001564:	07f8      	lsls	r0, r7, #31
 8001566:	0fc0      	lsrs	r0, r0, #31
 8001568:	4798      	blx	r3
 800156a:	e12b      	b.n	80017c4 <__iar_annotation$$branch+0x1f6>
 800156c:	2100      	movs	r1, #0
 800156e:	0020      	movs	r0, r4
 8001570:	f002 fa14 	bl	800399c <PE_ChangePowerRole>
 8001574:	68a0      	ldr	r0, [r4, #8]
 8001576:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001578:	2501      	movs	r5, #1
 800157a:	2b00      	cmp	r3, #0
 800157c:	d005      	beq.n	800158a <__iar_annotation$$branch+0xb92>
 800157e:	220d      	movs	r2, #13
 8001580:	2100      	movs	r1, #0
 8001582:	68e7      	ldr	r7, [r4, #12]
 8001584:	2001      	movs	r0, #1
 8001586:	4038      	ands	r0, r7
 8001588:	4798      	blx	r3
 800158a:	0020      	movs	r0, r4
 800158c:	f002 feb0 	bl	80042f0 <PE_ResetDuringSwap>
 8001590:	4fae      	ldr	r7, [pc, #696]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001592:	7838      	ldrb	r0, [r7, #0]
 8001594:	0780      	lsls	r0, r0, #30
 8001596:	d509      	bpl.n	80015ac <__iar_annotation$$branch+0xbb4>
 8001598:	2000      	movs	r0, #0
 800159a:	9000      	str	r0, [sp, #0]
 800159c:	2300      	movs	r3, #0
 800159e:	2214      	movs	r2, #20
 80015a0:	68e0      	ldr	r0, [r4, #12]
 80015a2:	2101      	movs	r1, #1
 80015a4:	4001      	ands	r1, r0
 80015a6:	2009      	movs	r0, #9
 80015a8:	68ff      	ldr	r7, [r7, #12]
 80015aa:	47b8      	blx	r7
 80015ac:	2114      	movs	r1, #20
 80015ae:	68e2      	ldr	r2, [r4, #12]
 80015b0:	2001      	movs	r0, #1
 80015b2:	4010      	ands	r0, r2
 80015b4:	68a2      	ldr	r2, [r4, #8]
 80015b6:	68d2      	ldr	r2, [r2, #12]
 80015b8:	4790      	blx	r2
 80015ba:	68a0      	ldr	r0, [r4, #8]
 80015bc:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80015be:	2b00      	cmp	r3, #0
 80015c0:	d005      	beq.n	80015ce <__iar_annotation$$branch>
 80015c2:	220e      	movs	r2, #14
 80015c4:	2100      	movs	r1, #0
 80015c6:	68e0      	ldr	r0, [r4, #12]
 80015c8:	4005      	ands	r5, r0
 80015ca:	0028      	movs	r0, r5
 80015cc:	4798      	blx	r3

080015ce <__iar_annotation$$branch>:
 80015ce:	f7ff fa65 	bl	8000a9c <__iar_annotation$$branch+0xa4>
 80015d2:	2001      	movs	r0, #1
 80015d4:	9000      	str	r0, [sp, #0]
 80015d6:	231f      	movs	r3, #31
 80015d8:	220a      	movs	r2, #10
 80015da:	2100      	movs	r1, #0
 80015dc:	0020      	movs	r0, r4
 80015de:	f002 f8c8 	bl	8003772 <PE_Send_CtrlMessage>
 80015e2:	2800      	cmp	r0, #0
 80015e4:	d196      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 80015e6:	2008      	movs	r0, #8
 80015e8:	82e0      	strh	r0, [r4, #22]
 80015ea:	48b7      	ldr	r0, [pc, #732]	; (80018c8 <__iar_annotation$$branch+0xa>)
 80015ec:	83b0      	strh	r0, [r6, #28]
 80015ee:	251a      	movs	r5, #26
 80015f0:	68a0      	ldr	r0, [r4, #8]
 80015f2:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80015f4:	2b00      	cmp	r3, #0
 80015f6:	d005      	beq.n	8001604 <__iar_annotation$$branch+0x36>
 80015f8:	2202      	movs	r2, #2
 80015fa:	2101      	movs	r1, #1
 80015fc:	7b27      	ldrb	r7, [r4, #12]
 80015fe:	07f8      	lsls	r0, r7, #31
 8001600:	0fc0      	lsrs	r0, r0, #31
 8001602:	4798      	blx	r3
 8001604:	4f91      	ldr	r7, [pc, #580]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001606:	7838      	ldrb	r0, [r7, #0]
 8001608:	0780      	lsls	r0, r0, #30
 800160a:	d509      	bpl.n	8001620 <__iar_annotation$$branch+0x52>
 800160c:	2000      	movs	r0, #0
 800160e:	9000      	str	r0, [sp, #0]
 8001610:	2300      	movs	r3, #0
 8001612:	2237      	movs	r2, #55	; 0x37
 8001614:	7b20      	ldrb	r0, [r4, #12]
 8001616:	07c1      	lsls	r1, r0, #31
 8001618:	0fc9      	lsrs	r1, r1, #31
 800161a:	2009      	movs	r0, #9
 800161c:	68ff      	ldr	r7, [r7, #12]
 800161e:	47b8      	blx	r7
 8001620:	2137      	movs	r1, #55	; 0x37
 8001622:	e5a1      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001624:	2911      	cmp	r1, #17
 8001626:	d000      	beq.n	800162a <__iar_annotation$$branch+0x5c>
 8001628:	e57f      	b.n	800112a <__iar_annotation$$branch+0x732>
 800162a:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800162c:	0bc9      	lsrs	r1, r1, #15
 800162e:	d17d      	bne.n	800172c <__iar_annotation$$branch+0x15e>
 8001630:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8001632:	0b09      	lsrs	r1, r1, #12
 8001634:	0749      	lsls	r1, r1, #29
 8001636:	d179      	bne.n	800172c <__iar_annotation$$branch+0x15e>
 8001638:	2703      	movs	r7, #3
 800163a:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800163c:	06c9      	lsls	r1, r1, #27
 800163e:	0ec9      	lsrs	r1, r1, #27
 8001640:	2903      	cmp	r1, #3
 8001642:	d006      	beq.n	8001652 <__iar_annotation$$branch+0x84>
 8001644:	2904      	cmp	r1, #4
 8001646:	d031      	beq.n	80016ac <__iar_annotation$$branch+0xde>
 8001648:	290c      	cmp	r1, #12
 800164a:	d013      	beq.n	8001674 <__iar_annotation$$branch+0xa6>
 800164c:	2910      	cmp	r1, #16
 800164e:	d049      	beq.n	80016e4 <__iar_annotation$$branch+0x116>
 8001650:	e06c      	b.n	800172c <__iar_annotation$$branch+0x15e>
 8001652:	2500      	movs	r5, #0
 8001654:	83b5      	strh	r5, [r6, #28]
 8001656:	2120      	movs	r1, #32
 8001658:	7231      	strb	r1, [r6, #8]
 800165a:	2800      	cmp	r0, #0
 800165c:	d008      	beq.n	8001670 <__iar_annotation$$branch+0xa2>
 800165e:	9500      	str	r5, [sp, #0]
 8001660:	2300      	movs	r3, #0
 8001662:	2238      	movs	r2, #56	; 0x38
 8001664:	7b20      	ldrb	r0, [r4, #12]
 8001666:	07c1      	lsls	r1, r0, #31
 8001668:	0fc9      	lsrs	r1, r1, #31
 800166a:	2009      	movs	r0, #9
 800166c:	9f01      	ldr	r7, [sp, #4]
 800166e:	47b8      	blx	r7
 8001670:	2138      	movs	r1, #56	; 0x38
 8001672:	e052      	b.n	800171a <__iar_annotation$$branch+0x14c>
 8001674:	68a0      	ldr	r0, [r4, #8]
 8001676:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001678:	2b00      	cmp	r3, #0
 800167a:	d005      	beq.n	8001688 <__iar_annotation$$branch+0xba>
 800167c:	2205      	movs	r2, #5
 800167e:	2101      	movs	r1, #1
 8001680:	7b25      	ldrb	r5, [r4, #12]
 8001682:	07e8      	lsls	r0, r5, #31
 8001684:	0fc0      	lsrs	r0, r0, #31
 8001686:	4798      	blx	r3
 8001688:	2500      	movs	r5, #0
 800168a:	83b5      	strh	r5, [r6, #28]
 800168c:	7237      	strb	r7, [r6, #8]
 800168e:	4f6f      	ldr	r7, [pc, #444]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001690:	7838      	ldrb	r0, [r7, #0]
 8001692:	0780      	lsls	r0, r0, #30
 8001694:	d508      	bpl.n	80016a8 <__iar_annotation$$branch+0xda>
 8001696:	9500      	str	r5, [sp, #0]
 8001698:	2300      	movs	r3, #0
 800169a:	2239      	movs	r2, #57	; 0x39
 800169c:	7b20      	ldrb	r0, [r4, #12]
 800169e:	07c1      	lsls	r1, r0, #31
 80016a0:	0fc9      	lsrs	r1, r1, #31
 80016a2:	2009      	movs	r0, #9
 80016a4:	68ff      	ldr	r7, [r7, #12]
 80016a6:	47b8      	blx	r7
 80016a8:	2139      	movs	r1, #57	; 0x39
 80016aa:	e036      	b.n	800171a <__iar_annotation$$branch+0x14c>
 80016ac:	68a0      	ldr	r0, [r4, #8]
 80016ae:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80016b0:	2b00      	cmp	r3, #0
 80016b2:	d005      	beq.n	80016c0 <__iar_annotation$$branch+0xf2>
 80016b4:	2204      	movs	r2, #4
 80016b6:	2101      	movs	r1, #1
 80016b8:	7b25      	ldrb	r5, [r4, #12]
 80016ba:	07e8      	lsls	r0, r5, #31
 80016bc:	0fc0      	lsrs	r0, r0, #31
 80016be:	4798      	blx	r3
 80016c0:	2500      	movs	r5, #0
 80016c2:	83b5      	strh	r5, [r6, #28]
 80016c4:	7237      	strb	r7, [r6, #8]
 80016c6:	4f61      	ldr	r7, [pc, #388]	; (800184c <__iar_annotation$$branch+0x27e>)
 80016c8:	7838      	ldrb	r0, [r7, #0]
 80016ca:	0780      	lsls	r0, r0, #30
 80016cc:	d508      	bpl.n	80016e0 <__iar_annotation$$branch+0x112>
 80016ce:	9500      	str	r5, [sp, #0]
 80016d0:	2300      	movs	r3, #0
 80016d2:	2216      	movs	r2, #22
 80016d4:	7b20      	ldrb	r0, [r4, #12]
 80016d6:	07c1      	lsls	r1, r0, #31
 80016d8:	0fc9      	lsrs	r1, r1, #31
 80016da:	2009      	movs	r0, #9
 80016dc:	68ff      	ldr	r7, [r7, #12]
 80016de:	47b8      	blx	r7
 80016e0:	2116      	movs	r1, #22
 80016e2:	e01a      	b.n	800171a <__iar_annotation$$branch+0x14c>
 80016e4:	68a0      	ldr	r0, [r4, #8]
 80016e6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80016e8:	2b00      	cmp	r3, #0
 80016ea:	d005      	beq.n	80016f8 <__iar_annotation$$branch+0x12a>
 80016ec:	2204      	movs	r2, #4
 80016ee:	2101      	movs	r1, #1
 80016f0:	7b25      	ldrb	r5, [r4, #12]
 80016f2:	07e8      	lsls	r0, r5, #31
 80016f4:	0fc0      	lsrs	r0, r0, #31
 80016f6:	4798      	blx	r3
 80016f8:	2500      	movs	r5, #0
 80016fa:	83b5      	strh	r5, [r6, #28]
 80016fc:	7237      	strb	r7, [r6, #8]
 80016fe:	4f53      	ldr	r7, [pc, #332]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001700:	7838      	ldrb	r0, [r7, #0]
 8001702:	0780      	lsls	r0, r0, #30
 8001704:	d508      	bpl.n	8001718 <__iar_annotation$$branch+0x14a>
 8001706:	9500      	str	r5, [sp, #0]
 8001708:	2300      	movs	r3, #0
 800170a:	2255      	movs	r2, #85	; 0x55
 800170c:	7b20      	ldrb	r0, [r4, #12]
 800170e:	07c1      	lsls	r1, r0, #31
 8001710:	0fc9      	lsrs	r1, r1, #31
 8001712:	2009      	movs	r0, #9
 8001714:	68ff      	ldr	r7, [r7, #12]
 8001716:	47b8      	blx	r7
 8001718:	2155      	movs	r1, #85	; 0x55
 800171a:	7b22      	ldrb	r2, [r4, #12]
 800171c:	07d0      	lsls	r0, r2, #31
 800171e:	0fc0      	lsrs	r0, r0, #31
 8001720:	68a2      	ldr	r2, [r4, #8]
 8001722:	68d2      	ldr	r2, [r2, #12]
 8001724:	4790      	blx	r2
 8001726:	2014      	movs	r0, #20
 8001728:	4669      	mov	r1, sp
 800172a:	7308      	strb	r0, [r1, #12]
 800172c:	8bb0      	ldrh	r0, [r6, #28]
 800172e:	2180      	movs	r1, #128	; 0x80
 8001730:	0209      	lsls	r1, r1, #8
 8001732:	4288      	cmp	r0, r1
 8001734:	d138      	bne.n	80017a8 <__iar_annotation$$branch+0x1da>
 8001736:	e22a      	b.n	8001b8e <__iar_annotation$$branch+0xc>
 8001738:	6860      	ldr	r0, [r4, #4]
 800173a:	6801      	ldr	r1, [r0, #0]
 800173c:	2210      	movs	r2, #16
 800173e:	430a      	orrs	r2, r1
 8001740:	6002      	str	r2, [r0, #0]
 8001742:	68a0      	ldr	r0, [r4, #8]
 8001744:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001746:	2701      	movs	r7, #1
 8001748:	2b00      	cmp	r3, #0
 800174a:	d00f      	beq.n	800176c <__iar_annotation$$branch+0x19e>
 800174c:	2206      	movs	r2, #6
 800174e:	68e1      	ldr	r1, [r4, #12]
 8001750:	2001      	movs	r0, #1
 8001752:	4008      	ands	r0, r1
 8001754:	2101      	movs	r1, #1
 8001756:	4798      	blx	r3
 8001758:	68a0      	ldr	r0, [r4, #8]
 800175a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800175c:	2b00      	cmp	r3, #0
 800175e:	d005      	beq.n	800176c <__iar_annotation$$branch+0x19e>
 8001760:	2207      	movs	r2, #7
 8001762:	68e1      	ldr	r1, [r4, #12]
 8001764:	2001      	movs	r0, #1
 8001766:	4008      	ands	r0, r1
 8001768:	2101      	movs	r1, #1
 800176a:	4798      	blx	r3
 800176c:	2100      	movs	r1, #0
 800176e:	68e2      	ldr	r2, [r4, #12]
 8001770:	2001      	movs	r0, #1
 8001772:	4010      	ands	r0, r2
 8001774:	f003 fbd5 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8001778:	2000      	movs	r0, #0
 800177a:	9000      	str	r0, [sp, #0]
 800177c:	2321      	movs	r3, #33	; 0x21
 800177e:	2206      	movs	r2, #6
 8001780:	2100      	movs	r1, #0
 8001782:	0020      	movs	r0, r4
 8001784:	f001 fff5 	bl	8003772 <PE_Send_CtrlMessage>
 8001788:	2800      	cmp	r0, #0
 800178a:	d10d      	bne.n	80017a8 <__iar_annotation$$branch+0x1da>
 800178c:	68a0      	ldr	r0, [r4, #8]
 800178e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001790:	2b00      	cmp	r3, #0
 8001792:	d005      	beq.n	80017a0 <__iar_annotation$$branch+0x1d2>
 8001794:	2208      	movs	r2, #8
 8001796:	2101      	movs	r1, #1
 8001798:	68e0      	ldr	r0, [r4, #12]
 800179a:	4007      	ands	r7, r0
 800179c:	0038      	movs	r0, r7
 800179e:	4798      	blx	r3
 80017a0:	484a      	ldr	r0, [pc, #296]	; (80018cc <__iar_annotation$$branch+0xe>)
 80017a2:	8370      	strh	r0, [r6, #26]
 80017a4:	25f0      	movs	r5, #240	; 0xf0
 80017a6:	006d      	lsls	r5, r5, #1
 80017a8:	e4bf      	b.n	800112a <__iar_annotation$$branch+0x732>
 80017aa:	2911      	cmp	r1, #17
 80017ac:	d106      	bne.n	80017bc <__iar_annotation$$branch+0x1ee>
 80017ae:	2000      	movs	r0, #0
 80017b0:	8370      	strh	r0, [r6, #26]
 80017b2:	2026      	movs	r0, #38	; 0x26
 80017b4:	7230      	strb	r0, [r6, #8]
 80017b6:	2014      	movs	r0, #20
 80017b8:	4669      	mov	r1, sp
 80017ba:	7308      	strb	r0, [r1, #12]
 80017bc:	8b70      	ldrh	r0, [r6, #26]
 80017be:	03a9      	lsls	r1, r5, #14
 80017c0:	4288      	cmp	r0, r1
 80017c2:	d1f1      	bne.n	80017a8 <__iar_annotation$$branch+0x1da>
 80017c4:	2000      	movs	r0, #0
 80017c6:	8370      	strh	r0, [r6, #26]
 80017c8:	e069      	b.n	800189e <__iar_annotation$$branch>
 80017ca:	6860      	ldr	r0, [r4, #4]
 80017cc:	7841      	ldrb	r1, [r0, #1]
 80017ce:	0649      	lsls	r1, r1, #25
 80017d0:	0f49      	lsrs	r1, r1, #29
 80017d2:	2903      	cmp	r1, #3
 80017d4:	d11a      	bne.n	800180c <__iar_annotation$$branch+0x23e>
 80017d6:	6821      	ldr	r1, [r4, #0]
 80017d8:	6849      	ldr	r1, [r1, #4]
 80017da:	070a      	lsls	r2, r1, #28
 80017dc:	0fd2      	lsrs	r2, r2, #31
 80017de:	d015      	beq.n	800180c <__iar_annotation$$branch+0x23e>
 80017e0:	2103      	movs	r1, #3
 80017e2:	0020      	movs	r0, r4
 80017e4:	f001 ffaa 	bl	800373c <PE_Send_SNKCapabilities>
 80017e8:	4f18      	ldr	r7, [pc, #96]	; (800184c <__iar_annotation$$branch+0x27e>)
 80017ea:	7838      	ldrb	r0, [r7, #0]
 80017ec:	0780      	lsls	r0, r0, #30
 80017ee:	d509      	bpl.n	8001804 <__iar_annotation$$branch+0x236>
 80017f0:	2000      	movs	r0, #0
 80017f2:	9000      	str	r0, [sp, #0]
 80017f4:	2300      	movs	r3, #0
 80017f6:	220a      	movs	r2, #10
 80017f8:	7b20      	ldrb	r0, [r4, #12]
 80017fa:	07c1      	lsls	r1, r0, #31
 80017fc:	0fc9      	lsrs	r1, r1, #31
 80017fe:	2009      	movs	r0, #9
 8001800:	68ff      	ldr	r7, [r7, #12]
 8001802:	47b8      	blx	r7
 8001804:	210a      	movs	r1, #10
 8001806:	e4af      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001808:	000081ae 	.word	0x000081ae
 800180c:	7800      	ldrb	r0, [r0, #0]
 800180e:	0780      	lsls	r0, r0, #30
 8001810:	0f80      	lsrs	r0, r0, #30
 8001812:	2802      	cmp	r0, #2
 8001814:	d101      	bne.n	800181a <__iar_annotation$$branch+0x24c>
 8001816:	2001      	movs	r0, #1
 8001818:	e433      	b.n	8001082 <__iar_annotation$$branch+0x68a>
 800181a:	202a      	movs	r0, #42	; 0x2a
 800181c:	e431      	b.n	8001082 <__iar_annotation$$branch+0x68a>
 800181e:	2700      	movs	r7, #0
 8001820:	82e7      	strh	r7, [r4, #22]
 8001822:	7b21      	ldrb	r1, [r4, #12]
 8001824:	07c8      	lsls	r0, r1, #31
 8001826:	0fc0      	lsrs	r0, r0, #31
 8001828:	f003 fba4 	bl	8004f74 <USBPD_PRL_SRCReleaseSinkNG>
 800182c:	2004      	movs	r0, #4
 800182e:	7230      	strb	r0, [r6, #8]
 8001830:	7b20      	ldrb	r0, [r4, #12]
 8001832:	0700      	lsls	r0, r0, #28
 8001834:	0f80      	lsrs	r0, r0, #30
 8001836:	2803      	cmp	r0, #3
 8001838:	d10a      	bne.n	8001850 <__iar_annotation$$branch+0x282>
 800183a:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 800183c:	0440      	lsls	r0, r0, #17
 800183e:	0c40      	lsrs	r0, r0, #17
 8001840:	2800      	cmp	r0, #0
 8001842:	dc06      	bgt.n	8001852 <__iar_annotation$$branch+0x284>
 8001844:	4822      	ldr	r0, [pc, #136]	; (80018d0 <__iar_annotation$$branch+0x12>)
 8001846:	8670      	strh	r0, [r6, #50]	; 0x32
 8001848:	4d22      	ldr	r5, [pc, #136]	; (80018d4 <__iar_annotation$$branch+0x16>)
 800184a:	e002      	b.n	8001852 <__iar_annotation$$branch+0x284>
 800184c:	200019ac 	.word	0x200019ac
 8001850:	8677      	strh	r7, [r6, #50]	; 0x32
 8001852:	4668      	mov	r0, sp
 8001854:	7b00      	ldrb	r0, [r0, #12]
 8001856:	2814      	cmp	r0, #20
 8001858:	d01a      	beq.n	8001890 <__iar_annotation$$branch+0x2c2>
 800185a:	7ab0      	ldrb	r0, [r6, #10]
 800185c:	72f0      	strb	r0, [r6, #11]
 800185e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001860:	0bc0      	lsrs	r0, r0, #15
 8001862:	d003      	beq.n	800186c <__iar_annotation$$branch+0x29e>
 8001864:	0020      	movs	r0, r4
 8001866:	f002 fb57 	bl	8003f18 <PE_Check_ExtendedMessage>
 800186a:	e00d      	b.n	8001888 <__iar_annotation$$branch+0x2ba>
 800186c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800186e:	0bc0      	lsrs	r0, r0, #15
 8001870:	d107      	bne.n	8001882 <__iar_annotation$$branch+0x2b4>
 8001872:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001874:	0b00      	lsrs	r0, r0, #12
 8001876:	0740      	lsls	r0, r0, #29
 8001878:	d103      	bne.n	8001882 <__iar_annotation$$branch+0x2b4>
 800187a:	0020      	movs	r0, r4
 800187c:	f002 f902 	bl	8003a84 <PE_Check_ControlMessage>
 8001880:	e002      	b.n	8001888 <__iar_annotation$$branch+0x2ba>
 8001882:	0020      	movs	r0, r4
 8001884:	f002 fa9a 	bl	8003dbc <PE_Check_DataMessage>
 8001888:	2014      	movs	r0, #20
 800188a:	4669      	mov	r1, sp
 800188c:	7308      	strb	r0, [r1, #12]
 800188e:	e44c      	b.n	800112a <__iar_annotation$$branch+0x732>
 8001890:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 8001892:	2180      	movs	r1, #128	; 0x80
 8001894:	0209      	lsls	r1, r1, #8
 8001896:	4288      	cmp	r0, r1
 8001898:	d103      	bne.n	80018a2 <__iar_annotation$$branch+0x4>
 800189a:	2500      	movs	r5, #0
 800189c:	8675      	strh	r5, [r6, #50]	; 0x32

0800189e <__iar_annotation$$branch>:
 800189e:	f7ff fac8 	bl	8000e32 <__iar_annotation$$branch+0x43a>
 80018a2:	7930      	ldrb	r0, [r6, #4]
 80018a4:	2800      	cmp	r0, #0
 80018a6:	d006      	beq.n	80018b6 <__iar_annotation$$branch+0x18>
 80018a8:	7970      	ldrb	r0, [r6, #5]
 80018aa:	72f0      	strb	r0, [r6, #11]
 80018ac:	7930      	ldrb	r0, [r6, #4]
 80018ae:	7230      	strb	r0, [r6, #8]
 80018b0:	2500      	movs	r5, #0
 80018b2:	7135      	strb	r5, [r6, #4]
 80018b4:	e439      	b.n	800112a <__iar_annotation$$branch+0x732>
 80018b6:	4d08      	ldr	r5, [pc, #32]	; (80018d8 <__iar_annotation$$branch+0x1a>)
 80018b8:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 80018ba:	4028      	ands	r0, r5
 80018bc:	dc01      	bgt.n	80018c2 <__iar_annotation$$branch+0x4>

080018be <__iar_annotation$$branch>:
 80018be:	f7ff faa0 	bl	8000e02 <__iar_annotation$$branch+0x40a>
 80018c2:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 80018c4:	4005      	ands	r5, r0
 80018c6:	e430      	b.n	800112a <__iar_annotation$$branch+0x732>
 80018c8:	0000801a 	.word	0x0000801a
 80018cc:	000081e0 	.word	0x000081e0
 80018d0:	0000b6b0 	.word	0x0000b6b0
 80018d4:	000036b0 	.word	0x000036b0
 80018d8:	00007fff 	.word	0x00007fff
 80018dc:	a80a      	add	r0, sp, #40	; 0x28
 80018de:	7800      	ldrb	r0, [r0, #0]
 80018e0:	68a1      	ldr	r1, [r4, #8]
 80018e2:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
 80018e4:	4788      	blx	r1
 80018e6:	280a      	cmp	r0, #10
 80018e8:	d142      	bne.n	8001970 <__iar_annotation$$branch+0xb2>
 80018ea:	2000      	movs	r0, #0
 80018ec:	9000      	str	r0, [sp, #0]
 80018ee:	2303      	movs	r3, #3
 80018f0:	2203      	movs	r2, #3
 80018f2:	2100      	movs	r1, #0
 80018f4:	0020      	movs	r0, r4
 80018f6:	f001 ff3c 	bl	8003772 <PE_Send_CtrlMessage>
 80018fa:	2800      	cmp	r0, #0
 80018fc:	d170      	bne.n	80019e0 <__iar_annotation$$branch>
 80018fe:	6861      	ldr	r1, [r4, #4]
 8001900:	780a      	ldrb	r2, [r1, #0]
 8001902:	48c8      	ldr	r0, [pc, #800]	; (8001c24 <.text_18>)
 8001904:	68c7      	ldr	r7, [r0, #12]
 8001906:	7800      	ldrb	r0, [r0, #0]
 8001908:	4028      	ands	r0, r5
 800190a:	08d3      	lsrs	r3, r2, #3
 800190c:	07db      	lsls	r3, r3, #31
 800190e:	d40f      	bmi.n	8001930 <__iar_annotation$$branch+0x72>
 8001910:	2308      	movs	r3, #8
 8001912:	4313      	orrs	r3, r2
 8001914:	700b      	strb	r3, [r1, #0]
 8001916:	2800      	cmp	r0, #0
 8001918:	d008      	beq.n	800192c <__iar_annotation$$branch+0x6e>
 800191a:	2000      	movs	r0, #0
 800191c:	9000      	str	r0, [sp, #0]
 800191e:	2300      	movs	r3, #0
 8001920:	2224      	movs	r2, #36	; 0x24
 8001922:	7b20      	ldrb	r0, [r4, #12]
 8001924:	07c1      	lsls	r1, r0, #31
 8001926:	0fc9      	lsrs	r1, r1, #31
 8001928:	2009      	movs	r0, #9
 800192a:	47b8      	blx	r7
 800192c:	2124      	movs	r1, #36	; 0x24
 800192e:	e00e      	b.n	800194e <__iar_annotation$$branch+0x90>
 8001930:	23f7      	movs	r3, #247	; 0xf7
 8001932:	4013      	ands	r3, r2
 8001934:	700b      	strb	r3, [r1, #0]
 8001936:	2800      	cmp	r0, #0
 8001938:	d008      	beq.n	800194c <__iar_annotation$$branch+0x8e>
 800193a:	2000      	movs	r0, #0
 800193c:	9000      	str	r0, [sp, #0]
 800193e:	2300      	movs	r3, #0
 8001940:	2223      	movs	r2, #35	; 0x23
 8001942:	7b20      	ldrb	r0, [r4, #12]
 8001944:	07c1      	lsls	r1, r0, #31
 8001946:	0fc9      	lsrs	r1, r1, #31
 8001948:	2009      	movs	r0, #9
 800194a:	47b8      	blx	r7
 800194c:	2123      	movs	r1, #35	; 0x23
 800194e:	7b22      	ldrb	r2, [r4, #12]
 8001950:	07d0      	lsls	r0, r2, #31
 8001952:	0fc0      	lsrs	r0, r0, #31
 8001954:	68a2      	ldr	r2, [r4, #8]
 8001956:	68d2      	ldr	r2, [r2, #12]
 8001958:	4790      	blx	r2
 800195a:	2001      	movs	r0, #1
 800195c:	6861      	ldr	r1, [r4, #4]
 800195e:	7809      	ldrb	r1, [r1, #0]
 8001960:	08ca      	lsrs	r2, r1, #3
 8001962:	2101      	movs	r1, #1
 8001964:	4011      	ands	r1, r2
 8001966:	68e2      	ldr	r2, [r4, #12]
 8001968:	4010      	ands	r0, r2
 800196a:	f003 fae5 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 800196e:	e037      	b.n	80019e0 <__iar_annotation$$branch>
 8001970:	6860      	ldr	r0, [r4, #4]
 8001972:	e74b      	b.n	800180c <__iar_annotation$$branch+0x23e>
 8001974:	2001      	movs	r0, #1
 8001976:	9000      	str	r0, [sp, #0]
 8001978:	2395      	movs	r3, #149	; 0x95
 800197a:	2209      	movs	r2, #9
 800197c:	2100      	movs	r1, #0
 800197e:	0020      	movs	r0, r4
 8001980:	f001 fef7 	bl	8003772 <PE_Send_CtrlMessage>
 8001984:	2800      	cmp	r0, #0
 8001986:	d12b      	bne.n	80019e0 <__iar_annotation$$branch>
 8001988:	200f      	movs	r0, #15
 800198a:	82e0      	strh	r0, [r4, #22]
 800198c:	48a6      	ldr	r0, [pc, #664]	; (8001c28 <.text_19>)
 800198e:	83b0      	strh	r0, [r6, #28]
 8001990:	251a      	movs	r5, #26
 8001992:	4fa4      	ldr	r7, [pc, #656]	; (8001c24 <.text_18>)
 8001994:	7838      	ldrb	r0, [r7, #0]
 8001996:	0780      	lsls	r0, r0, #30
 8001998:	d509      	bpl.n	80019ae <__iar_annotation$$branch+0xf0>
 800199a:	2000      	movs	r0, #0
 800199c:	9000      	str	r0, [sp, #0]
 800199e:	2300      	movs	r3, #0
 80019a0:	2221      	movs	r2, #33	; 0x21
 80019a2:	7b20      	ldrb	r0, [r4, #12]
 80019a4:	07c1      	lsls	r1, r0, #31
 80019a6:	0fc9      	lsrs	r1, r1, #31
 80019a8:	2009      	movs	r0, #9
 80019aa:	68ff      	ldr	r7, [r7, #12]
 80019ac:	47b8      	blx	r7
 80019ae:	2121      	movs	r1, #33	; 0x21
 80019b0:	e0e7      	b.n	8001b82 <__iar_annotation$$branch>
 80019b2:	8bb2      	ldrh	r2, [r6, #28]
 80019b4:	03ab      	lsls	r3, r5, #14
 80019b6:	429a      	cmp	r2, r3
 80019b8:	d100      	bne.n	80019bc <__iar_annotation$$branch+0xfe>
 80019ba:	e0e8      	b.n	8001b8e <__iar_annotation$$branch+0xc>
 80019bc:	2914      	cmp	r1, #20
 80019be:	d00f      	beq.n	80019e0 <__iar_annotation$$branch>
 80019c0:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80019c2:	0bc9      	lsrs	r1, r1, #15
 80019c4:	d10c      	bne.n	80019e0 <__iar_annotation$$branch>
 80019c6:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80019c8:	0b09      	lsrs	r1, r1, #12
 80019ca:	0749      	lsls	r1, r1, #29
 80019cc:	d108      	bne.n	80019e0 <__iar_annotation$$branch>
 80019ce:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80019d0:	06c9      	lsls	r1, r1, #27
 80019d2:	0ec9      	lsrs	r1, r1, #27
 80019d4:	2903      	cmp	r1, #3
 80019d6:	d005      	beq.n	80019e4 <__iar_annotation$$branch+0x4>
 80019d8:	2904      	cmp	r1, #4
 80019da:	d052      	beq.n	8001a82 <__iar_annotation$$branch+0xa2>
 80019dc:	290c      	cmp	r1, #12
 80019de:	d03c      	beq.n	8001a5a <__iar_annotation$$branch+0x7a>

080019e0 <__iar_annotation$$branch>:
 80019e0:	f7fe fff0 	bl	80009c4 <__iar_annotation$$branch+0x1e8>
 80019e4:	6861      	ldr	r1, [r4, #4]
 80019e6:	780a      	ldrb	r2, [r1, #0]
 80019e8:	08d3      	lsrs	r3, r2, #3
 80019ea:	07db      	lsls	r3, r3, #31
 80019ec:	d410      	bmi.n	8001a10 <__iar_annotation$$branch+0x30>
 80019ee:	2308      	movs	r3, #8
 80019f0:	4313      	orrs	r3, r2
 80019f2:	700b      	strb	r3, [r1, #0]
 80019f4:	2800      	cmp	r0, #0
 80019f6:	d009      	beq.n	8001a0c <__iar_annotation$$branch+0x2c>
 80019f8:	2000      	movs	r0, #0
 80019fa:	9000      	str	r0, [sp, #0]
 80019fc:	2300      	movs	r3, #0
 80019fe:	2224      	movs	r2, #36	; 0x24
 8001a00:	7b20      	ldrb	r0, [r4, #12]
 8001a02:	07c1      	lsls	r1, r0, #31
 8001a04:	0fc9      	lsrs	r1, r1, #31
 8001a06:	2009      	movs	r0, #9
 8001a08:	9f01      	ldr	r7, [sp, #4]
 8001a0a:	47b8      	blx	r7
 8001a0c:	2124      	movs	r1, #36	; 0x24
 8001a0e:	e00f      	b.n	8001a30 <__iar_annotation$$branch+0x50>
 8001a10:	23f7      	movs	r3, #247	; 0xf7
 8001a12:	4013      	ands	r3, r2
 8001a14:	700b      	strb	r3, [r1, #0]
 8001a16:	2800      	cmp	r0, #0
 8001a18:	d009      	beq.n	8001a2e <__iar_annotation$$branch+0x4e>
 8001a1a:	2000      	movs	r0, #0
 8001a1c:	9000      	str	r0, [sp, #0]
 8001a1e:	2300      	movs	r3, #0
 8001a20:	2223      	movs	r2, #35	; 0x23
 8001a22:	7b20      	ldrb	r0, [r4, #12]
 8001a24:	07c1      	lsls	r1, r0, #31
 8001a26:	0fc9      	lsrs	r1, r1, #31
 8001a28:	2009      	movs	r0, #9
 8001a2a:	9f01      	ldr	r7, [sp, #4]
 8001a2c:	47b8      	blx	r7
 8001a2e:	2123      	movs	r1, #35	; 0x23
 8001a30:	7b22      	ldrb	r2, [r4, #12]
 8001a32:	07d0      	lsls	r0, r2, #31
 8001a34:	0fc0      	lsrs	r0, r0, #31
 8001a36:	68a2      	ldr	r2, [r4, #8]
 8001a38:	68d2      	ldr	r2, [r2, #12]
 8001a3a:	4790      	blx	r2
 8001a3c:	2001      	movs	r0, #1
 8001a3e:	6861      	ldr	r1, [r4, #4]
 8001a40:	7809      	ldrb	r1, [r1, #0]
 8001a42:	08ca      	lsrs	r2, r1, #3
 8001a44:	2101      	movs	r1, #1
 8001a46:	4011      	ands	r1, r2
 8001a48:	68e2      	ldr	r2, [r4, #12]
 8001a4a:	4010      	ands	r0, r2
 8001a4c:	f003 fa74 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 8001a50:	2000      	movs	r0, #0
 8001a52:	83b0      	strh	r0, [r6, #28]
 8001a54:	2003      	movs	r0, #3
 8001a56:	7230      	strb	r0, [r6, #8]
 8001a58:	e716      	b.n	8001888 <__iar_annotation$$branch+0x2ba>
 8001a5a:	2800      	cmp	r0, #0
 8001a5c:	d009      	beq.n	8001a72 <__iar_annotation$$branch+0x92>
 8001a5e:	2000      	movs	r0, #0
 8001a60:	9000      	str	r0, [sp, #0]
 8001a62:	2300      	movs	r3, #0
 8001a64:	2225      	movs	r2, #37	; 0x25
 8001a66:	7b20      	ldrb	r0, [r4, #12]
 8001a68:	07c1      	lsls	r1, r0, #31
 8001a6a:	0fc9      	lsrs	r1, r1, #31
 8001a6c:	2009      	movs	r0, #9
 8001a6e:	9f01      	ldr	r7, [sp, #4]
 8001a70:	47b8      	blx	r7
 8001a72:	2125      	movs	r1, #37	; 0x25
 8001a74:	7b22      	ldrb	r2, [r4, #12]
 8001a76:	07d0      	lsls	r0, r2, #31
 8001a78:	0fc0      	lsrs	r0, r0, #31
 8001a7a:	68a2      	ldr	r2, [r4, #8]
 8001a7c:	68d2      	ldr	r2, [r2, #12]
 8001a7e:	4790      	blx	r2
 8001a80:	e7e6      	b.n	8001a50 <__iar_annotation$$branch+0x70>
 8001a82:	2800      	cmp	r0, #0
 8001a84:	d009      	beq.n	8001a9a <__iar_annotation$$branch+0xba>
 8001a86:	2000      	movs	r0, #0
 8001a88:	9000      	str	r0, [sp, #0]
 8001a8a:	2300      	movs	r3, #0
 8001a8c:	2226      	movs	r2, #38	; 0x26
 8001a8e:	7b20      	ldrb	r0, [r4, #12]
 8001a90:	07c1      	lsls	r1, r0, #31
 8001a92:	0fc9      	lsrs	r1, r1, #31
 8001a94:	2009      	movs	r0, #9
 8001a96:	9f01      	ldr	r7, [sp, #4]
 8001a98:	47b8      	blx	r7
 8001a9a:	2126      	movs	r1, #38	; 0x26
 8001a9c:	7b22      	ldrb	r2, [r4, #12]
 8001a9e:	07d0      	lsls	r0, r2, #31
 8001aa0:	0fc0      	lsrs	r0, r0, #31
 8001aa2:	68a2      	ldr	r2, [r4, #8]
 8001aa4:	68d2      	ldr	r2, [r2, #12]
 8001aa6:	4790      	blx	r2
 8001aa8:	e7d2      	b.n	8001a50 <__iar_annotation$$branch+0x70>
 8001aaa:	2000      	movs	r0, #0
 8001aac:	9002      	str	r0, [sp, #8]
 8001aae:	2003      	movs	r0, #3
 8001ab0:	9001      	str	r0, [sp, #4]
 8001ab2:	2001      	movs	r0, #1
 8001ab4:	9000      	str	r0, [sp, #0]
 8001ab6:	20e3      	movs	r0, #227	; 0xe3
 8001ab8:	0080      	lsls	r0, r0, #2
 8001aba:	1823      	adds	r3, r4, r0
 8001abc:	2206      	movs	r2, #6
 8001abe:	2100      	movs	r1, #0
 8001ac0:	0020      	movs	r0, r4
 8001ac2:	f001 fe9d 	bl	8003800 <PE_Send_DataMessage>
 8001ac6:	e78b      	b.n	80019e0 <__iar_annotation$$branch>
 8001ac8:	ab06      	add	r3, sp, #24
 8001aca:	aa05      	add	r2, sp, #20
 8001acc:	210a      	movs	r1, #10
 8001ace:	a80a      	add	r0, sp, #40	; 0x28
 8001ad0:	7800      	ldrb	r0, [r0, #0]
 8001ad2:	68a7      	ldr	r7, [r4, #8]
 8001ad4:	69bf      	ldr	r7, [r7, #24]
 8001ad6:	47b8      	blx	r7
 8001ad8:	2700      	movs	r7, #0
 8001ada:	76e7      	strb	r7, [r4, #27]
 8001adc:	76a7      	strb	r7, [r4, #26]
 8001ade:	7b21      	ldrb	r1, [r4, #12]
 8001ae0:	07c8      	lsls	r0, r1, #31
 8001ae2:	0fc0      	lsrs	r0, r0, #31
 8001ae4:	f002 fcde 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8001ae8:	2800      	cmp	r0, #0
 8001aea:	d103      	bne.n	8001af4 <__iar_annotation$$branch+0x114>
 8001aec:	8b60      	ldrh	r0, [r4, #26]
 8001aee:	03a9      	lsls	r1, r5, #14
 8001af0:	4301      	orrs	r1, r0
 8001af2:	8361      	strh	r1, [r4, #26]
 8001af4:	9805      	ldr	r0, [sp, #20]
 8001af6:	00f9      	lsls	r1, r7, #3
 8001af8:	40c8      	lsrs	r0, r1
 8001afa:	0021      	movs	r1, r4
 8001afc:	311c      	adds	r1, #28
 8001afe:	55c8      	strb	r0, [r1, r7]
 8001b00:	1c7f      	adds	r7, r7, #1
 8001b02:	2f04      	cmp	r7, #4
 8001b04:	dbf6      	blt.n	8001af4 <__iar_annotation$$branch+0x114>
 8001b06:	2000      	movs	r0, #0
 8001b08:	9002      	str	r0, [sp, #8]
 8001b0a:	2003      	movs	r0, #3
 8001b0c:	9001      	str	r0, [sp, #4]
 8001b0e:	2008      	movs	r0, #8
 8001b10:	9000      	str	r0, [sp, #0]
 8001b12:	0023      	movs	r3, r4
 8001b14:	3318      	adds	r3, #24
 8001b16:	228c      	movs	r2, #140	; 0x8c
 8001b18:	2100      	movs	r1, #0
 8001b1a:	0020      	movs	r0, r4
 8001b1c:	f002 fcd2 	bl	80044c4 <PE_Send_ExtendedMessage>
 8001b20:	4f40      	ldr	r7, [pc, #256]	; (8001c24 <.text_18>)
 8001b22:	7838      	ldrb	r0, [r7, #0]
 8001b24:	0780      	lsls	r0, r0, #30
 8001b26:	d509      	bpl.n	8001b3c <__iar_annotation$$branch+0x15c>
 8001b28:	2000      	movs	r0, #0
 8001b2a:	9000      	str	r0, [sp, #0]
 8001b2c:	2300      	movs	r3, #0
 8001b2e:	2249      	movs	r2, #73	; 0x49
 8001b30:	7b20      	ldrb	r0, [r4, #12]
 8001b32:	07c1      	lsls	r1, r0, #31
 8001b34:	0fc9      	lsrs	r1, r1, #31
 8001b36:	2009      	movs	r0, #9
 8001b38:	68ff      	ldr	r7, [r7, #12]
 8001b3a:	47b8      	blx	r7
 8001b3c:	2149      	movs	r1, #73	; 0x49
 8001b3e:	e020      	b.n	8001b82 <__iar_annotation$$branch>
 8001b40:	20e5      	movs	r0, #229	; 0xe5
 8001b42:	0080      	lsls	r0, r0, #2
 8001b44:	1827      	adds	r7, r4, r0
 8001b46:	2001      	movs	r0, #1
 8001b48:	9000      	str	r0, [sp, #0]
 8001b4a:	2339      	movs	r3, #57	; 0x39
 8001b4c:	783a      	ldrb	r2, [r7, #0]
 8001b4e:	7971      	ldrb	r1, [r6, #5]
 8001b50:	0020      	movs	r0, r4
 8001b52:	f001 fe0e 	bl	8003772 <PE_Send_CtrlMessage>
 8001b56:	2800      	cmp	r0, #0
 8001b58:	d128      	bne.n	8001bac <__iar_annotation$$branch+0x2a>
 8001b5a:	8878      	ldrh	r0, [r7, #2]
 8001b5c:	82e0      	strh	r0, [r4, #22]
 8001b5e:	4832      	ldr	r0, [pc, #200]	; (8001c28 <.text_19>)
 8001b60:	83b0      	strh	r0, [r6, #28]
 8001b62:	251a      	movs	r5, #26
 8001b64:	4f2f      	ldr	r7, [pc, #188]	; (8001c24 <.text_18>)
 8001b66:	7838      	ldrb	r0, [r7, #0]
 8001b68:	0780      	lsls	r0, r0, #30
 8001b6a:	d509      	bpl.n	8001b80 <__iar_annotation$$branch+0x1a0>
 8001b6c:	2000      	movs	r0, #0
 8001b6e:	9000      	str	r0, [sp, #0]
 8001b70:	2300      	movs	r3, #0
 8001b72:	2241      	movs	r2, #65	; 0x41
 8001b74:	7b20      	ldrb	r0, [r4, #12]
 8001b76:	07c1      	lsls	r1, r0, #31
 8001b78:	0fc9      	lsrs	r1, r1, #31
 8001b7a:	2009      	movs	r0, #9
 8001b7c:	68ff      	ldr	r7, [r7, #12]
 8001b7e:	47b8      	blx	r7
 8001b80:	2141      	movs	r1, #65	; 0x41

08001b82 <__iar_annotation$$branch>:
 8001b82:	f7fe ffb3 	bl	8000aec <__iar_annotation$$branch+0xf4>
 8001b86:	8bb0      	ldrh	r0, [r6, #28]
 8001b88:	03aa      	lsls	r2, r5, #14
 8001b8a:	4290      	cmp	r0, r2
 8001b8c:	d102      	bne.n	8001b94 <__iar_annotation$$branch+0x12>
 8001b8e:	2000      	movs	r0, #0
 8001b90:	83b0      	strh	r0, [r6, #28]
 8001b92:	e02e      	b.n	8001bf2 <__iar_annotation$$branch>
 8001b94:	2914      	cmp	r1, #20
 8001b96:	d009      	beq.n	8001bac <__iar_annotation$$branch+0x2a>
 8001b98:	2000      	movs	r0, #0
 8001b9a:	83b0      	strh	r0, [r6, #28]
 8001b9c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001b9e:	0bc0      	lsrs	r0, r0, #15
 8001ba0:	d027      	beq.n	8001bf2 <__iar_annotation$$branch>
 8001ba2:	e65f      	b.n	8001864 <__iar_annotation$$branch+0x296>
 8001ba4:	0020      	movs	r0, r4
 8001ba6:	f002 fce0 	bl	800456a <PE_SubStateMachine_ExtendedMessages>
 8001baa:	0005      	movs	r5, r0
 8001bac:	e718      	b.n	80019e0 <__iar_annotation$$branch>
 8001bae:	a903      	add	r1, sp, #12
 8001bb0:	0020      	movs	r0, r4
 8001bb2:	f002 fdf1 	bl	8004798 <PE_SubStateMachine_Generic>
 8001bb6:	e7f8      	b.n	8001baa <__iar_annotation$$branch+0x28>
 8001bb8:	a903      	add	r1, sp, #12
 8001bba:	0020      	movs	r0, r4
 8001bbc:	f002 ff5e 	bl	8004a7c <PE_SubStateMachine_VconnSwap>
 8001bc0:	0005      	movs	r5, r0
 8001bc2:	6860      	ldr	r0, [r4, #4]
 8001bc4:	6800      	ldr	r0, [r0, #0]
 8001bc6:	0340      	lsls	r0, r0, #13
 8001bc8:	0fc1      	lsrs	r1, r0, #31
 8001bca:	a80a      	add	r0, sp, #40	; 0x28
 8001bcc:	7800      	ldrb	r0, [r0, #0]
 8001bce:	f003 f9e4 	bl	8004f9a <USBPD_PRL_CableCapable>
 8001bd2:	e705      	b.n	80019e0 <__iar_annotation$$branch>
 8001bd4:	2106      	movs	r1, #6
 8001bd6:	a80a      	add	r0, sp, #40	; 0x28
 8001bd8:	7800      	ldrb	r0, [r0, #0]
 8001bda:	f007 fe3f 	bl	800985c <USBPD_PHY_ResetRequest>
 8001bde:	2007      	movs	r0, #7
 8001be0:	6861      	ldr	r1, [r4, #4]
 8001be2:	7849      	ldrb	r1, [r1, #1]
 8001be4:	0909      	lsrs	r1, r1, #4
 8001be6:	2207      	movs	r2, #7
 8001be8:	400a      	ands	r2, r1
 8001bea:	2a03      	cmp	r2, #3
 8001bec:	d001      	beq.n	8001bf2 <__iar_annotation$$branch>

08001bee <__iar_annotation$$branch>:
 8001bee:	f7fe fe67 	bl	80008c0 <__iar_annotation$$branch+0xe4>

08001bf2 <__iar_annotation$$branch>:
 8001bf2:	f7ff f91c 	bl	8000e2e <__iar_annotation$$branch+0x436>
 8001bf6:	7a30      	ldrb	r0, [r6, #8]
 8001bf8:	2803      	cmp	r0, #3
 8001bfa:	d110      	bne.n	8001c1e <__iar_annotation$$branch>
 8001bfc:	200e      	movs	r0, #14
 8001bfe:	5e30      	ldrsh	r0, [r6, r0]
 8001c00:	2800      	cmp	r0, #0
 8001c02:	d00c      	beq.n	8001c1e <__iar_annotation$$branch>
 8001c04:	2016      	movs	r0, #22
 8001c06:	5e20      	ldrsh	r0, [r4, r0]
 8001c08:	2800      	cmp	r0, #0
 8001c0a:	d108      	bne.n	8001c1e <__iar_annotation$$branch>
 8001c0c:	7b30      	ldrb	r0, [r6, #12]
 8001c0e:	7230      	strb	r0, [r6, #8]
 8001c10:	7b70      	ldrb	r0, [r6, #13]
 8001c12:	72f0      	strb	r0, [r6, #11]
 8001c14:	89f0      	ldrh	r0, [r6, #14]
 8001c16:	82e0      	strh	r0, [r4, #22]
 8001c18:	2000      	movs	r0, #0
 8001c1a:	81f0      	strh	r0, [r6, #14]
 8001c1c:	2501      	movs	r5, #1

08001c1e <__iar_annotation$$branch>:
 8001c1e:	f7fe ff0b 	bl	8000a38 <__iar_annotation$$branch+0x40>
	...

08001c24 <.text_18>:
 8001c24:	200019ac 	.word	0x200019ac

08001c28 <.text_19>:
 8001c28:	0000801a 	.word	0x0000801a

08001c2c <USBPD_PE_StateMachine_SNK>:
 8001c2c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001c2e:	b08f      	sub	sp, #60	; 0x3c
 8001c30:	0005      	movs	r5, r0
 8001c32:	48b3      	ldr	r0, [pc, #716]	; (8001f00 <__iar_annotation$$branch+0xce>)
 8001c34:	00a9      	lsls	r1, r5, #2
 8001c36:	1840      	adds	r0, r0, r1
 8001c38:	6840      	ldr	r0, [r0, #4]
 8001c3a:	9006      	str	r0, [sp, #24]
 8001c3c:	2400      	movs	r4, #0
 8001c3e:	21d9      	movs	r1, #217	; 0xd9
 8001c40:	0089      	lsls	r1, r1, #2
 8001c42:	1840      	adds	r0, r0, r1
 8001c44:	9004      	str	r0, [sp, #16]
 8001c46:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8001c48:	8807      	ldrh	r7, [r0, #0]
 8001c4a:	4668      	mov	r0, sp
 8001c4c:	9904      	ldr	r1, [sp, #16]
 8001c4e:	8849      	ldrh	r1, [r1, #2]
 8001c50:	82c1      	strh	r1, [r0, #22]
 8001c52:	9904      	ldr	r1, [sp, #16]
 8001c54:	8889      	ldrh	r1, [r1, #4]
 8001c56:	8281      	strh	r1, [r0, #20]
 8001c58:	9904      	ldr	r1, [sp, #16]
 8001c5a:	88c9      	ldrh	r1, [r1, #6]
 8001c5c:	81c1      	strh	r1, [r0, #14]
 8001c5e:	9904      	ldr	r1, [sp, #16]
 8001c60:	8909      	ldrh	r1, [r1, #8]
 8001c62:	8141      	strh	r1, [r0, #10]
 8001c64:	9904      	ldr	r1, [sp, #16]
 8001c66:	8949      	ldrh	r1, [r1, #10]
 8001c68:	8101      	strh	r1, [r0, #8]
 8001c6a:	9904      	ldr	r1, [sp, #16]
 8001c6c:	8989      	ldrh	r1, [r1, #12]
 8001c6e:	80c1      	strh	r1, [r0, #6]
 8001c70:	9904      	ldr	r1, [sp, #16]
 8001c72:	89c9      	ldrh	r1, [r1, #14]
 8001c74:	8081      	strh	r1, [r0, #4]
 8001c76:	9904      	ldr	r1, [sp, #16]
 8001c78:	89c9      	ldrh	r1, [r1, #14]
 8001c7a:	8041      	strh	r1, [r0, #2]
 8001c7c:	9904      	ldr	r1, [sp, #16]
 8001c7e:	8a09      	ldrh	r1, [r1, #16]
 8001c80:	8001      	strh	r1, [r0, #0]
 8001c82:	9804      	ldr	r0, [sp, #16]
 8001c84:	8a40      	ldrh	r0, [r0, #18]
 8001c86:	9904      	ldr	r1, [sp, #16]
 8001c88:	8a89      	ldrh	r1, [r1, #20]
 8001c8a:	9a04      	ldr	r2, [sp, #16]
 8001c8c:	8ad2      	ldrh	r2, [r2, #22]
 8001c8e:	9b04      	ldr	r3, [sp, #16]
 8001c90:	8c1b      	ldrh	r3, [r3, #32]
 8001c92:	0536      	lsls	r6, r6, #20
 8001c94:	0d36      	lsrs	r6, r6, #20
 8001c96:	19f6      	adds	r6, r6, r7
 8001c98:	466f      	mov	r7, sp
 8001c9a:	8aff      	ldrh	r7, [r7, #22]
 8001c9c:	19f6      	adds	r6, r6, r7
 8001c9e:	466f      	mov	r7, sp
 8001ca0:	8abf      	ldrh	r7, [r7, #20]
 8001ca2:	19f6      	adds	r6, r6, r7
 8001ca4:	466f      	mov	r7, sp
 8001ca6:	89ff      	ldrh	r7, [r7, #14]
 8001ca8:	19f6      	adds	r6, r6, r7
 8001caa:	466f      	mov	r7, sp
 8001cac:	897f      	ldrh	r7, [r7, #10]
 8001cae:	19f6      	adds	r6, r6, r7
 8001cb0:	466f      	mov	r7, sp
 8001cb2:	893f      	ldrh	r7, [r7, #8]
 8001cb4:	19f6      	adds	r6, r6, r7
 8001cb6:	466f      	mov	r7, sp
 8001cb8:	88ff      	ldrh	r7, [r7, #6]
 8001cba:	19f6      	adds	r6, r6, r7
 8001cbc:	466f      	mov	r7, sp
 8001cbe:	88bf      	ldrh	r7, [r7, #4]
 8001cc0:	19f6      	adds	r6, r6, r7
 8001cc2:	466f      	mov	r7, sp
 8001cc4:	887f      	ldrh	r7, [r7, #2]
 8001cc6:	19f6      	adds	r6, r6, r7
 8001cc8:	466f      	mov	r7, sp
 8001cca:	883f      	ldrh	r7, [r7, #0]
 8001ccc:	19f6      	adds	r6, r6, r7
 8001cce:	1830      	adds	r0, r6, r0
 8001cd0:	1840      	adds	r0, r0, r1
 8001cd2:	1880      	adds	r0, r0, r2
 8001cd4:	0519      	lsls	r1, r3, #20
 8001cd6:	0f49      	lsrs	r1, r1, #29
 8001cd8:	1840      	adds	r0, r0, r1
 8001cda:	9904      	ldr	r1, [sp, #16]
 8001cdc:	8c09      	ldrh	r1, [r1, #32]
 8001cde:	06c9      	lsls	r1, r1, #27
 8001ce0:	0ec9      	lsrs	r1, r1, #27
 8001ce2:	1846      	adds	r6, r0, r1
 8001ce4:	b2b6      	uxth	r6, r6
 8001ce6:	9806      	ldr	r0, [sp, #24]
 8001ce8:	f001 fe68 	bl	80039bc <PE_Check_RxEvent>
 8001cec:	4669      	mov	r1, sp
 8001cee:	7308      	strb	r0, [r1, #12]
 8001cf0:	2803      	cmp	r0, #3
 8001cf2:	d001      	beq.n	8001cf8 <__iar_annotation$$branch+0x4>

08001cf4 <__iar_annotation$$branch>:
 8001cf4:	f001 f97c 	bl	8002ff0 <__iar_annotation$$branch+0xaa0>
 8001cf8:	2001      	movs	r0, #1

08001cfa <__iar_annotation$$branch>:
 8001cfa:	f001 f974 	bl	8002fe6 <__iar_annotation$$branch+0xa96>
 8001cfe:	2400      	movs	r4, #0
 8001d00:	43e4      	mvns	r4, r4
 8001d02:	6868      	ldr	r0, [r5, #4]
 8001d04:	6801      	ldr	r1, [r0, #0]
 8001d06:	2210      	movs	r2, #16
 8001d08:	4391      	bics	r1, r2
 8001d0a:	6001      	str	r1, [r0, #0]

08001d0c <__iar_annotation$$branch>:
 8001d0c:	f001 f8fe 	bl	8002f0c <__iar_annotation$$branch+0x9bc>
 8001d10:	6868      	ldr	r0, [r5, #4]
 8001d12:	6800      	ldr	r0, [r0, #0]
 8001d14:	0340      	lsls	r0, r0, #13
 8001d16:	0fc1      	lsrs	r1, r0, #31
 8001d18:	4668      	mov	r0, sp
 8001d1a:	7b40      	ldrb	r0, [r0, #13]
 8001d1c:	f003 f93d 	bl	8004f9a <USBPD_PRL_CableCapable>
 8001d20:	2701      	movs	r7, #1
 8001d22:	68e9      	ldr	r1, [r5, #12]
 8001d24:	2001      	movs	r0, #1
 8001d26:	4008      	ands	r0, r1
 8001d28:	f003 fb94 	bl	8005454 <USBPD_PRL_Reset>
 8001d2c:	6868      	ldr	r0, [r5, #4]
 8001d2e:	6801      	ldr	r1, [r0, #0]
 8001d30:	0ac9      	lsrs	r1, r1, #11
 8001d32:	4039      	ands	r1, r7
 8001d34:	d0ea      	beq.n	8001d0c <__iar_annotation$$branch>
 8001d36:	2103      	movs	r1, #3
 8001d38:	682a      	ldr	r2, [r5, #0]
 8001d3a:	7913      	ldrb	r3, [r2, #4]
 8001d3c:	2203      	movs	r2, #3
 8001d3e:	401a      	ands	r2, r3
 8001d40:	7803      	ldrb	r3, [r0, #0]
 8001d42:	24fc      	movs	r4, #252	; 0xfc
 8001d44:	401c      	ands	r4, r3
 8001d46:	4322      	orrs	r2, r4
 8001d48:	7002      	strb	r2, [r0, #0]
 8001d4a:	6868      	ldr	r0, [r5, #4]
 8001d4c:	7802      	ldrb	r2, [r0, #0]
 8001d4e:	4011      	ands	r1, r2
 8001d50:	2901      	cmp	r1, #1
 8001d52:	d100      	bne.n	8001d56 <__iar_annotation$$branch+0x4a>
 8001d54:	2700      	movs	r7, #0
 8001d56:	219f      	movs	r1, #159	; 0x9f
 8001d58:	4011      	ands	r1, r2
 8001d5a:	017a      	lsls	r2, r7, #5
 8001d5c:	430a      	orrs	r2, r1
 8001d5e:	7002      	strb	r2, [r0, #0]
 8001d60:	48b3      	ldr	r0, [pc, #716]	; (8002030 <__iar_annotation$$branch+0x1fe>)
 8001d62:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001d64:	24fa      	movs	r4, #250	; 0xfa
 8001d66:	0064      	lsls	r4, r4, #1

08001d68 <__iar_annotation$$branch>:
 8001d68:	f001 f8ce 	bl	8002f08 <__iar_annotation$$branch+0x9b8>
 8001d6c:	2911      	cmp	r1, #17
 8001d6e:	d131      	bne.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d70:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d72:	0bc0      	lsrs	r0, r0, #15
 8001d74:	d12e      	bne.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d76:	2707      	movs	r7, #7
 8001d78:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d7a:	0b00      	lsrs	r0, r0, #12
 8001d7c:	4238      	tst	r0, r7
 8001d7e:	d029      	beq.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d80:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d82:	06c0      	lsls	r0, r0, #27
 8001d84:	0ec0      	lsrs	r0, r0, #27
 8001d86:	2801      	cmp	r0, #1
 8001d88:	d124      	bne.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d8a:	2000      	movs	r0, #0
 8001d8c:	7528      	strb	r0, [r5, #20]
 8001d8e:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d90:	0600      	lsls	r0, r0, #24
 8001d92:	0f81      	lsrs	r1, r0, #30
 8001d94:	4668      	mov	r0, sp
 8001d96:	7b40      	ldrb	r0, [r0, #13]
 8001d98:	f002 fb1a 	bl	80043d0 <PE_ExtRevisionInteroperability>
 8001d9c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d9e:	0b00      	lsrs	r0, r0, #12
 8001da0:	4007      	ands	r7, r0
 8001da2:	00bb      	lsls	r3, r7, #2
 8001da4:	209e      	movs	r0, #158	; 0x9e
 8001da6:	0040      	lsls	r0, r0, #1
 8001da8:	182a      	adds	r2, r5, r0
 8001daa:	2104      	movs	r1, #4
 8001dac:	7b2f      	ldrb	r7, [r5, #12]
 8001dae:	07f8      	lsls	r0, r7, #31
 8001db0:	0fc0      	lsrs	r0, r0, #31
 8001db2:	68af      	ldr	r7, [r5, #8]
 8001db4:	69ff      	ldr	r7, [r7, #28]
 8001db6:	47b8      	blx	r7
 8001db8:	2001      	movs	r0, #1
 8001dba:	82e8      	strh	r0, [r5, #22]
 8001dbc:	2044      	movs	r0, #68	; 0x44
 8001dbe:	7130      	strb	r0, [r6, #4]
 8001dc0:	6868      	ldr	r0, [r5, #4]
 8001dc2:	6801      	ldr	r1, [r0, #0]
 8001dc4:	2210      	movs	r2, #16
 8001dc6:	4391      	bics	r1, r2
 8001dc8:	6001      	str	r1, [r0, #0]
 8001dca:	2000      	movs	r0, #0
 8001dcc:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001dce:	2014      	movs	r0, #20
 8001dd0:	4669      	mov	r1, sp
 8001dd2:	7308      	strb	r0, [r1, #12]
 8001dd4:	8cf0      	ldrh	r0, [r6, #38]	; 0x26
 8001dd6:	03a1      	lsls	r1, r4, #14
 8001dd8:	4288      	cmp	r0, r1
 8001dda:	d197      	bne.n	8001d0c <__iar_annotation$$branch>
 8001ddc:	6868      	ldr	r0, [r5, #4]
 8001dde:	6801      	ldr	r1, [r0, #0]
 8001de0:	2210      	movs	r2, #16
 8001de2:	4391      	bics	r1, r2
 8001de4:	6001      	str	r1, [r0, #0]
 8001de6:	2000      	movs	r0, #0
 8001de8:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001dea:	e241      	b.n	8002270 <__iar_annotation$$branch>
 8001dec:	2001      	movs	r0, #1
 8001dee:	82e8      	strh	r0, [r5, #22]
 8001df0:	466a      	mov	r2, sp
 8001df2:	0029      	movs	r1, r5
 8001df4:	3110      	adds	r1, #16
 8001df6:	68eb      	ldr	r3, [r5, #12]
 8001df8:	4018      	ands	r0, r3
 8001dfa:	68ab      	ldr	r3, [r5, #8]
 8001dfc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001dfe:	4798      	blx	r3
 8001e00:	7b28      	ldrb	r0, [r5, #12]
 8001e02:	21f3      	movs	r1, #243	; 0xf3
 8001e04:	4001      	ands	r1, r0
 8001e06:	4668      	mov	r0, sp
 8001e08:	7800      	ldrb	r0, [r0, #0]
 8001e0a:	0080      	lsls	r0, r0, #2
 8001e0c:	220c      	movs	r2, #12
 8001e0e:	4002      	ands	r2, r0
 8001e10:	430a      	orrs	r2, r1
 8001e12:	732a      	strb	r2, [r5, #12]
 8001e14:	2045      	movs	r0, #69	; 0x45
 8001e16:	e181      	b.n	800211c <__iar_annotation$$branch+0x2ea>
 8001e18:	2000      	movs	r0, #0
 8001e1a:	9002      	str	r0, [sp, #8]
 8001e1c:	2046      	movs	r0, #70	; 0x46
 8001e1e:	9001      	str	r0, [sp, #4]
 8001e20:	2001      	movs	r0, #1
 8001e22:	9000      	str	r0, [sp, #0]
 8001e24:	002b      	movs	r3, r5
 8001e26:	3310      	adds	r3, #16
 8001e28:	2202      	movs	r2, #2
 8001e2a:	2100      	movs	r1, #0
 8001e2c:	0028      	movs	r0, r5
 8001e2e:	f001 fce7 	bl	8003800 <PE_Send_DataMessage>

08001e32 <__iar_annotation$$branch>:
 8001e32:	f000 fff6 	bl	8002e22 <__iar_annotation$$branch+0x8d2>
 8001e36:	2911      	cmp	r1, #17
 8001e38:	d111      	bne.n	8001e5e <__iar_annotation$$branch+0x2c>
 8001e3a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001e3c:	0bc9      	lsrs	r1, r1, #15
 8001e3e:	d10e      	bne.n	8001e5e <__iar_annotation$$branch+0x2c>
 8001e40:	2107      	movs	r1, #7
 8001e42:	8e32      	ldrh	r2, [r6, #48]	; 0x30
 8001e44:	0b12      	lsrs	r2, r2, #12
 8001e46:	420a      	tst	r2, r1
 8001e48:	d109      	bne.n	8001e5e <__iar_annotation$$branch+0x2c>
 8001e4a:	8e32      	ldrh	r2, [r6, #48]	; 0x30
 8001e4c:	06d2      	lsls	r2, r2, #27
 8001e4e:	0ed2      	lsrs	r2, r2, #27
 8001e50:	1e92      	subs	r2, r2, #2
 8001e52:	2a01      	cmp	r2, #1
 8001e54:	d904      	bls.n	8001e60 <__iar_annotation$$branch+0x2e>
 8001e56:	1e92      	subs	r2, r2, #2
 8001e58:	d026      	beq.n	8001ea8 <__iar_annotation$$branch+0x76>
 8001e5a:	3a08      	subs	r2, #8
 8001e5c:	d024      	beq.n	8001ea8 <__iar_annotation$$branch+0x76>
 8001e5e:	e08a      	b.n	8001f76 <__iar_annotation$$branch+0x144>
 8001e60:	2100      	movs	r1, #0
 8001e62:	8331      	strh	r1, [r6, #24]
 8001e64:	8471      	strh	r1, [r6, #34]	; 0x22
 8001e66:	2147      	movs	r1, #71	; 0x47
 8001e68:	7131      	strb	r1, [r6, #4]
 8001e6a:	4971      	ldr	r1, [pc, #452]	; (8002030 <__iar_annotation$$branch+0x1fe>)
 8001e6c:	8471      	strh	r1, [r6, #34]	; 0x22
 8001e6e:	24fa      	movs	r4, #250	; 0xfa
 8001e70:	0064      	lsls	r4, r4, #1
 8001e72:	6869      	ldr	r1, [r5, #4]
 8001e74:	784a      	ldrb	r2, [r1, #1]
 8001e76:	238f      	movs	r3, #143	; 0x8f
 8001e78:	4013      	ands	r3, r2
 8001e7a:	2240      	movs	r2, #64	; 0x40
 8001e7c:	431a      	orrs	r2, r3
 8001e7e:	704a      	strb	r2, [r1, #1]
 8001e80:	2800      	cmp	r0, #0
 8001e82:	d009      	beq.n	8001e98 <__iar_annotation$$branch+0x66>
 8001e84:	2000      	movs	r0, #0
 8001e86:	9000      	str	r0, [sp, #0]
 8001e88:	2300      	movs	r3, #0
 8001e8a:	2256      	movs	r2, #86	; 0x56
 8001e8c:	7b28      	ldrb	r0, [r5, #12]
 8001e8e:	07c1      	lsls	r1, r0, #31
 8001e90:	0fc9      	lsrs	r1, r1, #31
 8001e92:	2009      	movs	r0, #9
 8001e94:	9f01      	ldr	r7, [sp, #4]
 8001e96:	47b8      	blx	r7
 8001e98:	2156      	movs	r1, #86	; 0x56
 8001e9a:	7b2a      	ldrb	r2, [r5, #12]
 8001e9c:	07d0      	lsls	r0, r2, #31
 8001e9e:	0fc0      	lsrs	r0, r0, #31
 8001ea0:	68aa      	ldr	r2, [r5, #8]
 8001ea2:	68d2      	ldr	r2, [r2, #12]
 8001ea4:	4790      	blx	r2
 8001ea6:	e016      	b.n	8001ed6 <__iar_annotation$$branch+0xa4>
 8001ea8:	2400      	movs	r4, #0
 8001eaa:	8474      	strh	r4, [r6, #34]	; 0x22
 8001eac:	6868      	ldr	r0, [r5, #4]
 8001eae:	7840      	ldrb	r0, [r0, #1]
 8001eb0:	0900      	lsrs	r0, r0, #4
 8001eb2:	4001      	ands	r1, r0
 8001eb4:	2903      	cmp	r1, #3
 8001eb6:	d005      	beq.n	8001ec4 <__iar_annotation$$branch+0x92>
 8001eb8:	485d      	ldr	r0, [pc, #372]	; (8002030 <__iar_annotation$$branch+0x1fe>)
 8001eba:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001ebc:	24fa      	movs	r4, #250	; 0xfa
 8001ebe:	0064      	lsls	r4, r4, #1
 8001ec0:	2043      	movs	r0, #67	; 0x43
 8001ec2:	e007      	b.n	8001ed4 <__iar_annotation$$branch+0xa2>
 8001ec4:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001ec6:	06c0      	lsls	r0, r0, #27
 8001ec8:	0ec0      	lsrs	r0, r0, #27
 8001eca:	280c      	cmp	r0, #12
 8001ecc:	d101      	bne.n	8001ed2 <__iar_annotation$$branch+0xa0>
 8001ece:	2049      	movs	r0, #73	; 0x49
 8001ed0:	e000      	b.n	8001ed4 <__iar_annotation$$branch+0xa2>
 8001ed2:	2003      	movs	r0, #3
 8001ed4:	7130      	strb	r0, [r6, #4]
 8001ed6:	2014      	movs	r0, #20
 8001ed8:	4669      	mov	r1, sp
 8001eda:	7308      	strb	r0, [r1, #12]
 8001edc:	4808      	ldr	r0, [pc, #32]	; (8001f00 <__iar_annotation$$branch+0xce>)
 8001ede:	68c7      	ldr	r7, [r0, #12]
 8001ee0:	7800      	ldrb	r0, [r0, #0]
 8001ee2:	2102      	movs	r1, #2
 8001ee4:	4008      	ands	r0, r1
 8001ee6:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001ee8:	06c9      	lsls	r1, r1, #27
 8001eea:	0ec9      	lsrs	r1, r1, #27
 8001eec:	2902      	cmp	r1, #2
 8001eee:	d016      	beq.n	8001f1e <__iar_annotation$$branch+0xec>
 8001ef0:	2903      	cmp	r1, #3
 8001ef2:	d007      	beq.n	8001f04 <__iar_annotation$$branch+0xd2>
 8001ef4:	2904      	cmp	r1, #4
 8001ef6:	d01f      	beq.n	8001f38 <__iar_annotation$$branch+0x106>
 8001ef8:	290c      	cmp	r1, #12
 8001efa:	d02a      	beq.n	8001f52 <__iar_annotation$$branch+0x120>
 8001efc:	e03b      	b.n	8001f76 <__iar_annotation$$branch+0x144>
 8001efe:	bf00      	nop
 8001f00:	200019ac 	.word	0x200019ac
 8001f04:	2800      	cmp	r0, #0
 8001f06:	d008      	beq.n	8001f1a <__iar_annotation$$branch+0xe8>
 8001f08:	2000      	movs	r0, #0
 8001f0a:	9000      	str	r0, [sp, #0]
 8001f0c:	2300      	movs	r3, #0
 8001f0e:	2201      	movs	r2, #1
 8001f10:	7b28      	ldrb	r0, [r5, #12]
 8001f12:	07c1      	lsls	r1, r0, #31
 8001f14:	0fc9      	lsrs	r1, r1, #31
 8001f16:	2009      	movs	r0, #9
 8001f18:	47b8      	blx	r7
 8001f1a:	2101      	movs	r1, #1
 8001f1c:	e025      	b.n	8001f6a <__iar_annotation$$branch+0x138>
 8001f1e:	2800      	cmp	r0, #0
 8001f20:	d008      	beq.n	8001f34 <__iar_annotation$$branch+0x102>
 8001f22:	2000      	movs	r0, #0
 8001f24:	9000      	str	r0, [sp, #0]
 8001f26:	2300      	movs	r3, #0
 8001f28:	2204      	movs	r2, #4
 8001f2a:	7b28      	ldrb	r0, [r5, #12]
 8001f2c:	07c1      	lsls	r1, r0, #31
 8001f2e:	0fc9      	lsrs	r1, r1, #31
 8001f30:	2009      	movs	r0, #9
 8001f32:	47b8      	blx	r7
 8001f34:	2104      	movs	r1, #4
 8001f36:	e018      	b.n	8001f6a <__iar_annotation$$branch+0x138>
 8001f38:	2800      	cmp	r0, #0
 8001f3a:	d008      	beq.n	8001f4e <__iar_annotation$$branch+0x11c>
 8001f3c:	2000      	movs	r0, #0
 8001f3e:	9000      	str	r0, [sp, #0]
 8001f40:	2300      	movs	r3, #0
 8001f42:	2202      	movs	r2, #2
 8001f44:	7b28      	ldrb	r0, [r5, #12]
 8001f46:	07c1      	lsls	r1, r0, #31
 8001f48:	0fc9      	lsrs	r1, r1, #31
 8001f4a:	2009      	movs	r0, #9
 8001f4c:	47b8      	blx	r7
 8001f4e:	2102      	movs	r1, #2
 8001f50:	e00b      	b.n	8001f6a <__iar_annotation$$branch+0x138>
 8001f52:	2800      	cmp	r0, #0
 8001f54:	d008      	beq.n	8001f68 <__iar_annotation$$branch+0x136>
 8001f56:	2000      	movs	r0, #0
 8001f58:	9000      	str	r0, [sp, #0]
 8001f5a:	2300      	movs	r3, #0
 8001f5c:	2203      	movs	r2, #3
 8001f5e:	7b28      	ldrb	r0, [r5, #12]
 8001f60:	07c1      	lsls	r1, r0, #31
 8001f62:	0fc9      	lsrs	r1, r1, #31
 8001f64:	2009      	movs	r0, #9
 8001f66:	47b8      	blx	r7
 8001f68:	2103      	movs	r1, #3
 8001f6a:	7b2a      	ldrb	r2, [r5, #12]
 8001f6c:	07d0      	lsls	r0, r2, #31
 8001f6e:	0fc0      	lsrs	r0, r0, #31
 8001f70:	68aa      	ldr	r2, [r5, #8]
 8001f72:	68d2      	ldr	r2, [r2, #12]
 8001f74:	4790      	blx	r2
 8001f76:	8b30      	ldrh	r0, [r6, #24]
 8001f78:	2180      	movs	r1, #128	; 0x80
 8001f7a:	0209      	lsls	r1, r1, #8
 8001f7c:	4288      	cmp	r0, r1
 8001f7e:	d000      	beq.n	8001f82 <__iar_annotation$$branch+0x150>
 8001f80:	e6c4      	b.n	8001d0c <__iar_annotation$$branch>
 8001f82:	2400      	movs	r4, #0
 8001f84:	8334      	strh	r4, [r6, #24]
 8001f86:	e173      	b.n	8002270 <__iar_annotation$$branch>
 8001f88:	2911      	cmp	r1, #17
 8001f8a:	d148      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001f8c:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001f8e:	0bc9      	lsrs	r1, r1, #15
 8001f90:	d145      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001f92:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001f94:	0b09      	lsrs	r1, r1, #12
 8001f96:	0749      	lsls	r1, r1, #29
 8001f98:	d141      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001f9a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001f9c:	06c9      	lsls	r1, r1, #27
 8001f9e:	0ec9      	lsrs	r1, r1, #27
 8001fa0:	2906      	cmp	r1, #6
 8001fa2:	d13c      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001fa4:	2400      	movs	r4, #0
 8001fa6:	8474      	strh	r4, [r6, #34]	; 0x22
 8001fa8:	2114      	movs	r1, #20
 8001faa:	466a      	mov	r2, sp
 8001fac:	7311      	strb	r1, [r2, #12]
 8001fae:	6869      	ldr	r1, [r5, #4]
 8001fb0:	784a      	ldrb	r2, [r1, #1]
 8001fb2:	238f      	movs	r3, #143	; 0x8f
 8001fb4:	4013      	ands	r3, r2
 8001fb6:	2230      	movs	r2, #48	; 0x30
 8001fb8:	431a      	orrs	r2, r3
 8001fba:	704a      	strb	r2, [r1, #1]
 8001fbc:	2800      	cmp	r0, #0
 8001fbe:	d008      	beq.n	8001fd2 <__iar_annotation$$branch+0x1a0>
 8001fc0:	9400      	str	r4, [sp, #0]
 8001fc2:	2300      	movs	r3, #0
 8001fc4:	2256      	movs	r2, #86	; 0x56
 8001fc6:	7b28      	ldrb	r0, [r5, #12]
 8001fc8:	07c1      	lsls	r1, r0, #31
 8001fca:	0fc9      	lsrs	r1, r1, #31
 8001fcc:	2009      	movs	r0, #9
 8001fce:	9f01      	ldr	r7, [sp, #4]
 8001fd0:	47b8      	blx	r7
 8001fd2:	2156      	movs	r1, #86	; 0x56
 8001fd4:	7b2a      	ldrb	r2, [r5, #12]
 8001fd6:	07d0      	lsls	r0, r2, #31
 8001fd8:	0fc0      	lsrs	r0, r0, #31
 8001fda:	68aa      	ldr	r2, [r5, #8]
 8001fdc:	68d2      	ldr	r2, [r2, #12]
 8001fde:	4790      	blx	r2
 8001fe0:	82ec      	strh	r4, [r5, #22]
 8001fe2:	2003      	movs	r0, #3
 8001fe4:	7130      	strb	r0, [r6, #4]
 8001fe6:	4fb0      	ldr	r7, [pc, #704]	; (80022a8 <__iar_annotation$$branch+0x38>)
 8001fe8:	7838      	ldrb	r0, [r7, #0]
 8001fea:	0780      	lsls	r0, r0, #30
 8001fec:	d508      	bpl.n	8002000 <__iar_annotation$$branch+0x1ce>
 8001fee:	9400      	str	r4, [sp, #0]
 8001ff0:	2300      	movs	r3, #0
 8001ff2:	2210      	movs	r2, #16
 8001ff4:	7b28      	ldrb	r0, [r5, #12]
 8001ff6:	07c1      	lsls	r1, r0, #31
 8001ff8:	0fc9      	lsrs	r1, r1, #31
 8001ffa:	2009      	movs	r0, #9
 8001ffc:	68ff      	ldr	r7, [r7, #12]
 8001ffe:	47b8      	blx	r7
 8002000:	2110      	movs	r1, #16
 8002002:	7b2a      	ldrb	r2, [r5, #12]
 8002004:	07d0      	lsls	r0, r2, #31
 8002006:	0fc0      	lsrs	r0, r0, #31
 8002008:	68aa      	ldr	r2, [r5, #8]
 800200a:	68d2      	ldr	r2, [r2, #12]
 800200c:	4790      	blx	r2
 800200e:	7b28      	ldrb	r0, [r5, #12]
 8002010:	0700      	lsls	r0, r0, #28
 8002012:	0f80      	lsrs	r0, r0, #30
 8002014:	2803      	cmp	r0, #3
 8002016:	d102      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8002018:	48a4      	ldr	r0, [pc, #656]	; (80022ac <__iar_annotation$$branch+0x3c>)
 800201a:	85b0      	strh	r0, [r6, #44]	; 0x2c
 800201c:	4ca4      	ldr	r4, [pc, #656]	; (80022b0 <__iar_annotation$$branch+0x40>)
 800201e:	8c70      	ldrh	r0, [r6, #34]	; 0x22
 8002020:	2180      	movs	r1, #128	; 0x80
 8002022:	0209      	lsls	r1, r1, #8
 8002024:	4288      	cmp	r0, r1
 8002026:	d000      	beq.n	800202a <__iar_annotation$$branch+0x1f8>
 8002028:	e670      	b.n	8001d0c <__iar_annotation$$branch>
 800202a:	2400      	movs	r4, #0
 800202c:	8474      	strh	r4, [r6, #34]	; 0x22
 800202e:	e11f      	b.n	8002270 <__iar_annotation$$branch>
 8002030:	000081f4 	.word	0x000081f4
 8002034:	7b69      	ldrb	r1, [r5, #13]
 8002036:	22fc      	movs	r2, #252	; 0xfc
 8002038:	400a      	ands	r2, r1
 800203a:	736a      	strb	r2, [r5, #13]
 800203c:	686a      	ldr	r2, [r5, #4]
 800203e:	2110      	movs	r1, #16
 8002040:	6813      	ldr	r3, [r2, #0]
 8002042:	430b      	orrs	r3, r1
 8002044:	6013      	str	r3, [r2, #0]
 8002046:	2200      	movs	r2, #0
 8002048:	82ea      	strh	r2, [r5, #22]
 800204a:	686a      	ldr	r2, [r5, #4]
 800204c:	7853      	ldrb	r3, [r2, #1]
 800204e:	278f      	movs	r7, #143	; 0x8f
 8002050:	401f      	ands	r7, r3
 8002052:	4339      	orrs	r1, r7
 8002054:	7051      	strb	r1, [r2, #1]
 8002056:	2800      	cmp	r0, #0
 8002058:	d009      	beq.n	800206e <__iar_annotation$$branch+0x23c>
 800205a:	2000      	movs	r0, #0
 800205c:	9000      	str	r0, [sp, #0]
 800205e:	2300      	movs	r3, #0
 8002060:	2256      	movs	r2, #86	; 0x56
 8002062:	7b28      	ldrb	r0, [r5, #12]
 8002064:	07c1      	lsls	r1, r0, #31
 8002066:	0fc9      	lsrs	r1, r1, #31
 8002068:	2009      	movs	r0, #9
 800206a:	9f01      	ldr	r7, [sp, #4]
 800206c:	47b8      	blx	r7
 800206e:	2156      	movs	r1, #86	; 0x56
 8002070:	7b2a      	ldrb	r2, [r5, #12]
 8002072:	07d0      	lsls	r0, r2, #31
 8002074:	0fc0      	lsrs	r0, r0, #31
 8002076:	68aa      	ldr	r2, [r5, #8]
 8002078:	68d2      	ldr	r2, [r2, #12]
 800207a:	4790      	blx	r2
 800207c:	2700      	movs	r7, #0
 800207e:	7037      	strb	r7, [r6, #0]
 8002080:	7d28      	ldrb	r0, [r5, #20]
 8002082:	2803      	cmp	r0, #3
 8002084:	d302      	bcc.n	800208c <__iar_annotation$$branch+0x25a>
 8002086:	752f      	strb	r7, [r5, #20]
 8002088:	7137      	strb	r7, [r6, #4]
 800208a:	e3ab      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800208c:	1c40      	adds	r0, r0, #1
 800208e:	7528      	strb	r0, [r5, #20]
 8002090:	0028      	movs	r0, r5
 8002092:	f001 fc1b 	bl	80038cc <PE_Send_HARDRESET>
 8002096:	2101      	movs	r1, #1
 8002098:	4668      	mov	r0, sp
 800209a:	7b40      	ldrb	r0, [r0, #13]
 800209c:	f002 f877 	bl	800418e <PE_Reset>
 80020a0:	6868      	ldr	r0, [r5, #4]
 80020a2:	6801      	ldr	r1, [r0, #0]
 80020a4:	2210      	movs	r2, #16
 80020a6:	430a      	orrs	r2, r1
 80020a8:	6002      	str	r2, [r0, #0]
 80020aa:	4882      	ldr	r0, [pc, #520]	; (80022b4 <__iar_annotation$$branch+0x44>)
 80020ac:	8270      	strh	r0, [r6, #18]
 80020ae:	209b      	movs	r0, #155	; 0x9b
 80020b0:	7130      	strb	r0, [r6, #4]
 80020b2:	e38d      	b.n	80027d0 <__iar_annotation$$branch+0x280>
 80020b4:	68e8      	ldr	r0, [r5, #12]
 80020b6:	4a80      	ldr	r2, [pc, #512]	; (80022b8 <__iar_annotation$$branch+0x48>)
 80020b8:	4002      	ands	r2, r0
 80020ba:	60ea      	str	r2, [r5, #12]
 80020bc:	2401      	movs	r4, #1
 80020be:	6868      	ldr	r0, [r5, #4]
 80020c0:	6800      	ldr	r0, [r0, #0]
 80020c2:	0c80      	lsrs	r0, r0, #18
 80020c4:	4020      	ands	r0, r4
 80020c6:	d007      	beq.n	80020d8 <__iar_annotation$$branch+0x2a6>
 80020c8:	68a8      	ldr	r0, [r5, #8]
 80020ca:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80020cc:	2b00      	cmp	r3, #0
 80020ce:	d003      	beq.n	80020d8 <__iar_annotation$$branch+0x2a6>
 80020d0:	2100      	movs	r1, #0
 80020d2:	2001      	movs	r0, #1
 80020d4:	4010      	ands	r0, r2
 80020d6:	4798      	blx	r3
 80020d8:	4f73      	ldr	r7, [pc, #460]	; (80022a8 <__iar_annotation$$branch+0x38>)
 80020da:	7838      	ldrb	r0, [r7, #0]
 80020dc:	0780      	lsls	r0, r0, #30
 80020de:	d509      	bpl.n	80020f4 <__iar_annotation$$branch+0x2c2>
 80020e0:	2000      	movs	r0, #0
 80020e2:	9000      	str	r0, [sp, #0]
 80020e4:	2300      	movs	r3, #0
 80020e6:	221d      	movs	r2, #29
 80020e8:	68e8      	ldr	r0, [r5, #12]
 80020ea:	2101      	movs	r1, #1
 80020ec:	4001      	ands	r1, r0
 80020ee:	2009      	movs	r0, #9
 80020f0:	68ff      	ldr	r7, [r7, #12]
 80020f2:	47b8      	blx	r7
 80020f4:	211d      	movs	r1, #29
 80020f6:	68e8      	ldr	r0, [r5, #12]
 80020f8:	4004      	ands	r4, r0
 80020fa:	0020      	movs	r0, r4
 80020fc:	68aa      	ldr	r2, [r5, #8]
 80020fe:	68d2      	ldr	r2, [r2, #12]
 8002100:	4790      	blx	r2
 8002102:	2101      	movs	r1, #1
 8002104:	4668      	mov	r0, sp
 8002106:	7b40      	ldrb	r0, [r0, #13]
 8002108:	f002 f841 	bl	800418e <PE_Reset>
 800210c:	6868      	ldr	r0, [r5, #4]
 800210e:	6801      	ldr	r1, [r0, #0]
 8002110:	2210      	movs	r2, #16
 8002112:	430a      	orrs	r2, r1
 8002114:	6002      	str	r2, [r0, #0]
 8002116:	4867      	ldr	r0, [pc, #412]	; (80022b4 <__iar_annotation$$branch+0x44>)
 8002118:	8270      	strh	r0, [r6, #18]
 800211a:	209b      	movs	r0, #155	; 0x9b
 800211c:	e357      	b.n	80027ce <__iar_annotation$$branch+0x27e>
 800211e:	68a8      	ldr	r0, [r5, #8]
 8002120:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8002122:	2a00      	cmp	r2, #0
 8002124:	d005      	beq.n	8002132 <__iar_annotation$$branch+0x300>
 8002126:	2100      	movs	r1, #0
 8002128:	4668      	mov	r0, sp
 800212a:	7b40      	ldrb	r0, [r0, #13]
 800212c:	4790      	blx	r2
 800212e:	2801      	cmp	r0, #1
 8002130:	d004      	beq.n	800213c <__iar_annotation$$branch+0x30a>
 8002132:	8a70      	ldrh	r0, [r6, #18]
 8002134:	03a1      	lsls	r1, r4, #14
 8002136:	4288      	cmp	r0, r1
 8002138:	d000      	beq.n	800213c <__iar_annotation$$branch+0x30a>
 800213a:	e353      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800213c:	485f      	ldr	r0, [pc, #380]	; (80022bc <__iar_annotation$$branch+0x4c>)
 800213e:	8270      	strh	r0, [r6, #18]
 8002140:	2040      	movs	r0, #64	; 0x40
 8002142:	7130      	strb	r0, [r6, #4]
 8002144:	2400      	movs	r4, #0
 8002146:	4f58      	ldr	r7, [pc, #352]	; (80022a8 <__iar_annotation$$branch+0x38>)
 8002148:	7838      	ldrb	r0, [r7, #0]
 800214a:	0780      	lsls	r0, r0, #30
 800214c:	d508      	bpl.n	8002160 <__iar_annotation$$branch+0x32e>
 800214e:	9400      	str	r4, [sp, #0]
 8002150:	2300      	movs	r3, #0
 8002152:	2213      	movs	r2, #19
 8002154:	7b28      	ldrb	r0, [r5, #12]
 8002156:	07c1      	lsls	r1, r0, #31
 8002158:	0fc9      	lsrs	r1, r1, #31
 800215a:	2009      	movs	r0, #9
 800215c:	68ff      	ldr	r7, [r7, #12]
 800215e:	47b8      	blx	r7
 8002160:	2113      	movs	r1, #19
 8002162:	e377      	b.n	8002854 <__iar_annotation$$branch+0x304>
 8002164:	68a8      	ldr	r0, [r5, #8]
 8002166:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8002168:	2a00      	cmp	r2, #0
 800216a:	d012      	beq.n	8002192 <__iar_annotation$$branch+0x360>
 800216c:	2101      	movs	r1, #1
 800216e:	4668      	mov	r0, sp
 8002170:	7b40      	ldrb	r0, [r0, #13]
 8002172:	4790      	blx	r2
 8002174:	2801      	cmp	r0, #1
 8002176:	d10c      	bne.n	8002192 <__iar_annotation$$branch+0x360>
 8002178:	6868      	ldr	r0, [r5, #4]
 800217a:	6801      	ldr	r1, [r0, #0]
 800217c:	2210      	movs	r2, #16
 800217e:	4391      	bics	r1, r2
 8002180:	6001      	str	r1, [r0, #0]
 8002182:	2000      	movs	r0, #0
 8002184:	8270      	strh	r0, [r6, #18]
 8002186:	484e      	ldr	r0, [pc, #312]	; (80022c0 <__iar_annotation$$branch+0x50>)
 8002188:	84f0      	strh	r0, [r6, #38]	; 0x26
 800218a:	24fa      	movs	r4, #250	; 0xfa
 800218c:	0064      	lsls	r4, r4, #1
 800218e:	2043      	movs	r0, #67	; 0x43
 8002190:	7130      	strb	r0, [r6, #4]
 8002192:	8a70      	ldrh	r0, [r6, #18]
 8002194:	2180      	movs	r1, #128	; 0x80
 8002196:	0209      	lsls	r1, r1, #8
 8002198:	4288      	cmp	r0, r1
 800219a:	d000      	beq.n	800219e <__iar_annotation$$branch+0x36c>
 800219c:	e322      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800219e:	2000      	movs	r0, #0
 80021a0:	8270      	strh	r0, [r6, #18]
 80021a2:	6868      	ldr	r0, [r5, #4]
 80021a4:	6801      	ldr	r1, [r0, #0]
 80021a6:	2210      	movs	r2, #16
 80021a8:	4391      	bics	r1, r2
 80021aa:	6001      	str	r1, [r0, #0]
 80021ac:	e060      	b.n	8002270 <__iar_annotation$$branch>
 80021ae:	0028      	movs	r0, r5
 80021b0:	f001 fbc5 	bl	800393e <PE_PerformSoftReset>
 80021b4:	2000      	movs	r0, #0
 80021b6:	9000      	str	r0, [sp, #0]
 80021b8:	2303      	movs	r3, #3
 80021ba:	2203      	movs	r2, #3
 80021bc:	2100      	movs	r1, #0
 80021be:	0028      	movs	r0, r5
 80021c0:	f001 fad7 	bl	8003772 <PE_Send_CtrlMessage>
 80021c4:	4f38      	ldr	r7, [pc, #224]	; (80022a8 <__iar_annotation$$branch+0x38>)
 80021c6:	7838      	ldrb	r0, [r7, #0]
 80021c8:	0780      	lsls	r0, r0, #30
 80021ca:	d509      	bpl.n	80021e0 <__iar_annotation$$branch+0x3ae>
 80021cc:	2000      	movs	r0, #0
 80021ce:	9000      	str	r0, [sp, #0]
 80021d0:	2300      	movs	r3, #0
 80021d2:	222f      	movs	r2, #47	; 0x2f
 80021d4:	7b28      	ldrb	r0, [r5, #12]
 80021d6:	07c1      	lsls	r1, r0, #31
 80021d8:	0fc9      	lsrs	r1, r1, #31
 80021da:	2009      	movs	r0, #9
 80021dc:	68ff      	ldr	r7, [r7, #12]
 80021de:	47b8      	blx	r7
 80021e0:	212f      	movs	r1, #47	; 0x2f
 80021e2:	e337      	b.n	8002854 <__iar_annotation$$branch+0x304>
 80021e4:	6868      	ldr	r0, [r5, #4]
 80021e6:	7840      	ldrb	r0, [r0, #1]
 80021e8:	0640      	lsls	r0, r0, #25
 80021ea:	0f40      	lsrs	r0, r0, #29
 80021ec:	2804      	cmp	r0, #4
 80021ee:	d101      	bne.n	80021f4 <__iar_annotation$$branch+0x3c2>
 80021f0:	200f      	movs	r0, #15
 80021f2:	e2ec      	b.n	80027ce <__iar_annotation$$branch+0x27e>
 80021f4:	2000      	movs	r0, #0
 80021f6:	9000      	str	r0, [sp, #0]
 80021f8:	2350      	movs	r3, #80	; 0x50
 80021fa:	220d      	movs	r2, #13
 80021fc:	2100      	movs	r1, #0
 80021fe:	0028      	movs	r0, r5
 8002200:	f001 fab7 	bl	8003772 <PE_Send_CtrlMessage>
 8002204:	2800      	cmp	r0, #0
 8002206:	d000      	beq.n	800220a <__iar_annotation$$branch+0x3d8>
 8002208:	e2ec      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800220a:	2003      	movs	r0, #3
 800220c:	82e8      	strh	r0, [r5, #22]
 800220e:	8337      	strh	r7, [r6, #24]
 8002210:	241a      	movs	r4, #26
 8002212:	4f25      	ldr	r7, [pc, #148]	; (80022a8 <__iar_annotation$$branch+0x38>)
 8002214:	7838      	ldrb	r0, [r7, #0]
 8002216:	0780      	lsls	r0, r0, #30
 8002218:	d509      	bpl.n	800222e <__iar_annotation$$branch+0x3fc>
 800221a:	2000      	movs	r0, #0
 800221c:	9000      	str	r0, [sp, #0]
 800221e:	2300      	movs	r3, #0
 8002220:	222e      	movs	r2, #46	; 0x2e
 8002222:	7b28      	ldrb	r0, [r5, #12]
 8002224:	07c1      	lsls	r1, r0, #31
 8002226:	0fc9      	lsrs	r1, r1, #31
 8002228:	2009      	movs	r0, #9
 800222a:	68ff      	ldr	r7, [r7, #12]
 800222c:	47b8      	blx	r7
 800222e:	212e      	movs	r1, #46	; 0x2e
 8002230:	e310      	b.n	8002854 <__iar_annotation$$branch+0x304>
 8002232:	2911      	cmp	r1, #17
 8002234:	d115      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 8002236:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002238:	0bc0      	lsrs	r0, r0, #15
 800223a:	d112      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 800223c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800223e:	0b00      	lsrs	r0, r0, #12
 8002240:	0740      	lsls	r0, r0, #29
 8002242:	d10e      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 8002244:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002246:	06c0      	lsls	r0, r0, #27
 8002248:	0ec0      	lsrs	r0, r0, #27
 800224a:	2803      	cmp	r0, #3
 800224c:	d109      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 800224e:	2000      	movs	r0, #0
 8002250:	8330      	strh	r0, [r6, #24]
 8002252:	0028      	movs	r0, r5
 8002254:	f001 fb73 	bl	800393e <PE_PerformSoftReset>
 8002258:	2003      	movs	r0, #3
 800225a:	7130      	strb	r0, [r6, #4]
 800225c:	2014      	movs	r0, #20
 800225e:	4669      	mov	r1, sp
 8002260:	7308      	strb	r0, [r1, #12]
 8002262:	8b30      	ldrh	r0, [r6, #24]
 8002264:	03a1      	lsls	r1, r4, #14
 8002266:	4288      	cmp	r0, r1
 8002268:	d000      	beq.n	800226c <__iar_annotation$$branch+0x43a>
 800226a:	e2bb      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800226c:	2000      	movs	r0, #0
 800226e:	8330      	strh	r0, [r6, #24]

08002270 <__iar_annotation$$branch>:
 8002270:	f000 fcd3 	bl	8002c1a <__iar_annotation$$branch+0x6ca>
 8002274:	6868      	ldr	r0, [r5, #4]
 8002276:	7840      	ldrb	r0, [r0, #1]
 8002278:	0640      	lsls	r0, r0, #25
 800227a:	0f40      	lsrs	r0, r0, #29
 800227c:	2803      	cmp	r0, #3
 800227e:	d121      	bne.n	80022c4 <__iar_annotation$$branch+0x54>
 8002280:	2103      	movs	r1, #3
 8002282:	0028      	movs	r0, r5
 8002284:	f001 fa5a 	bl	800373c <PE_Send_SNKCapabilities>
 8002288:	4f07      	ldr	r7, [pc, #28]	; (80022a8 <__iar_annotation$$branch+0x38>)
 800228a:	7838      	ldrb	r0, [r7, #0]
 800228c:	0780      	lsls	r0, r0, #30
 800228e:	d509      	bpl.n	80022a4 <__iar_annotation$$branch+0x34>
 8002290:	2000      	movs	r0, #0
 8002292:	9000      	str	r0, [sp, #0]
 8002294:	2300      	movs	r3, #0
 8002296:	220a      	movs	r2, #10
 8002298:	7b28      	ldrb	r0, [r5, #12]
 800229a:	07c1      	lsls	r1, r0, #31
 800229c:	0fc9      	lsrs	r1, r1, #31
 800229e:	2009      	movs	r0, #9
 80022a0:	68ff      	ldr	r7, [r7, #12]
 80022a2:	47b8      	blx	r7
 80022a4:	210a      	movs	r1, #10
 80022a6:	e2d5      	b.n	8002854 <__iar_annotation$$branch+0x304>
 80022a8:	200019ac 	.word	0x200019ac
 80022ac:	0000a328 	.word	0x0000a328
 80022b0:	00002328 	.word	0x00002328
 80022b4:	0000828a 	.word	0x0000828a
 80022b8:	fffff7ff 	.word	0xfffff7ff
 80022bc:	000084fb 	.word	0x000084fb
 80022c0:	000081f4 	.word	0x000081f4
 80022c4:	2000      	movs	r0, #0
 80022c6:	9000      	str	r0, [sp, #0]
 80022c8:	2303      	movs	r3, #3
 80022ca:	2204      	movs	r2, #4
 80022cc:	2100      	movs	r1, #0
 80022ce:	0028      	movs	r0, r5
 80022d0:	f001 fa4f 	bl	8003772 <PE_Send_CtrlMessage>
 80022d4:	e286      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80022d6:	9400      	str	r4, [sp, #0]
 80022d8:	2343      	movs	r3, #67	; 0x43
 80022da:	2207      	movs	r2, #7
 80022dc:	2100      	movs	r1, #0
 80022de:	0028      	movs	r0, r5
 80022e0:	f001 fa47 	bl	8003772 <PE_Send_CtrlMessage>
 80022e4:	2800      	cmp	r0, #0
 80022e6:	d000      	beq.n	80022ea <__iar_annotation$$branch+0x7a>
 80022e8:	e27c      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80022ea:	2006      	movs	r0, #6
 80022ec:	82e8      	strh	r0, [r5, #22]
 80022ee:	8337      	strh	r7, [r6, #24]
 80022f0:	241a      	movs	r4, #26
 80022f2:	4fbf      	ldr	r7, [pc, #764]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 80022f4:	7838      	ldrb	r0, [r7, #0]
 80022f6:	0780      	lsls	r0, r0, #30
 80022f8:	d509      	bpl.n	800230e <__iar_annotation$$branch+0x9e>
 80022fa:	2000      	movs	r0, #0
 80022fc:	9000      	str	r0, [sp, #0]
 80022fe:	2300      	movs	r3, #0
 8002300:	220b      	movs	r2, #11
 8002302:	7b28      	ldrb	r0, [r5, #12]
 8002304:	07c1      	lsls	r1, r0, #31
 8002306:	0fc9      	lsrs	r1, r1, #31
 8002308:	2009      	movs	r0, #9
 800230a:	68ff      	ldr	r7, [r7, #12]
 800230c:	47b8      	blx	r7
 800230e:	210b      	movs	r1, #11
 8002310:	e2a0      	b.n	8002854 <__iar_annotation$$branch+0x304>
 8002312:	2914      	cmp	r1, #20
 8002314:	d00e      	beq.n	8002334 <__iar_annotation$$branch+0xc4>
 8002316:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002318:	0bc0      	lsrs	r0, r0, #15
 800231a:	d10b      	bne.n	8002334 <__iar_annotation$$branch+0xc4>
 800231c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800231e:	0b00      	lsrs	r0, r0, #12
 8002320:	0740      	lsls	r0, r0, #29
 8002322:	d007      	beq.n	8002334 <__iar_annotation$$branch+0xc4>
 8002324:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002326:	06c0      	lsls	r0, r0, #27
 8002328:	0ec0      	lsrs	r0, r0, #27
 800232a:	2803      	cmp	r0, #3
 800232c:	d102      	bne.n	8002334 <__iar_annotation$$branch+0xc4>
 800232e:	2014      	movs	r0, #20
 8002330:	4669      	mov	r1, sp
 8002332:	7308      	strb	r0, [r1, #12]
 8002334:	2011      	movs	r0, #17

08002336 <__iar_annotation$$branch>:
 8002336:	f000 fd1d 	bl	8002d74 <__iar_annotation$$branch+0x824>
 800233a:	2011      	movs	r0, #17
 800233c:	82e8      	strh	r0, [r5, #22]
 800233e:	2105      	movs	r1, #5
 8002340:	7b2a      	ldrb	r2, [r5, #12]
 8002342:	07d0      	lsls	r0, r2, #31
 8002344:	0fc0      	lsrs	r0, r0, #31
 8002346:	f003 f874 	bl	8005432 <USBDPD_PRL_BistCarrierEyeMode>
 800234a:	205d      	movs	r0, #93	; 0x5d
 800234c:	7130      	strb	r0, [r6, #4]
 800234e:	48a9      	ldr	r0, [pc, #676]	; (80025f4 <__iar_annotation$$branch+0xa4>)
 8002350:	8530      	strh	r0, [r6, #40]	; 0x28
 8002352:	243a      	movs	r4, #58	; 0x3a
 8002354:	e246      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002356:	8d30      	ldrh	r0, [r6, #40]	; 0x28
 8002358:	03a1      	lsls	r1, r4, #14
 800235a:	4288      	cmp	r0, r1
 800235c:	d000      	beq.n	8002360 <__iar_annotation$$branch+0x2a>
 800235e:	e241      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002360:	2105      	movs	r1, #5
 8002362:	7b2a      	ldrb	r2, [r5, #12]
 8002364:	07d0      	lsls	r0, r2, #31
 8002366:	0fc0      	lsrs	r0, r0, #31
 8002368:	f003 f86b 	bl	8005442 <USBDPD_PRL_BistCarrierEyeModeExit>
 800236c:	2000      	movs	r0, #0
 800236e:	8530      	strh	r0, [r6, #40]	; 0x28

08002370 <__iar_annotation$$branch>:
 8002370:	f000 fda5 	bl	8002ebe <__iar_annotation$$branch+0x96e>
 8002374:	2911      	cmp	r1, #17
 8002376:	d000      	beq.n	800237a <__iar_annotation$$branch+0xa>
 8002378:	e234      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800237a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800237c:	0bc9      	lsrs	r1, r1, #15
 800237e:	d000      	beq.n	8002382 <__iar_annotation$$branch+0x12>
 8002380:	e230      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002382:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002384:	0b09      	lsrs	r1, r1, #12
 8002386:	0749      	lsls	r1, r1, #29
 8002388:	d000      	beq.n	800238c <__iar_annotation$$branch+0x1c>
 800238a:	e22b      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800238c:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800238e:	06c9      	lsls	r1, r1, #27
 8002390:	0ec9      	lsrs	r1, r1, #27
 8002392:	2906      	cmp	r1, #6
 8002394:	d000      	beq.n	8002398 <__iar_annotation$$branch+0x28>
 8002396:	e225      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002398:	2800      	cmp	r0, #0
 800239a:	d009      	beq.n	80023b0 <__iar_annotation$$branch+0x40>
 800239c:	2000      	movs	r0, #0
 800239e:	9000      	str	r0, [sp, #0]
 80023a0:	2300      	movs	r3, #0
 80023a2:	222a      	movs	r2, #42	; 0x2a
 80023a4:	7b28      	ldrb	r0, [r5, #12]
 80023a6:	07c1      	lsls	r1, r0, #31
 80023a8:	0fc9      	lsrs	r1, r1, #31
 80023aa:	2009      	movs	r0, #9
 80023ac:	9f01      	ldr	r7, [sp, #4]
 80023ae:	47b8      	blx	r7
 80023b0:	212a      	movs	r1, #42	; 0x2a
 80023b2:	7b2a      	ldrb	r2, [r5, #12]
 80023b4:	07d0      	lsls	r0, r2, #31
 80023b6:	0fc0      	lsrs	r0, r0, #31
 80023b8:	68aa      	ldr	r2, [r5, #8]
 80023ba:	68d2      	ldr	r2, [r2, #12]
 80023bc:	4790      	blx	r2

080023be <__iar_annotation$$branch>:
 80023be:	f000 fceb 	bl	8002d98 <__iar_annotation$$branch+0x848>
 80023c2:	9400      	str	r4, [sp, #0]
 80023c4:	2360      	movs	r3, #96	; 0x60
 80023c6:	2208      	movs	r2, #8
 80023c8:	2100      	movs	r1, #0
 80023ca:	0028      	movs	r0, r5
 80023cc:	f001 f9d1 	bl	8003772 <PE_Send_CtrlMessage>
 80023d0:	2800      	cmp	r0, #0
 80023d2:	d000      	beq.n	80023d6 <__iar_annotation$$branch+0x18>
 80023d4:	e206      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80023d6:	2007      	movs	r0, #7
 80023d8:	82e8      	strh	r0, [r5, #22]
 80023da:	8337      	strh	r7, [r6, #24]
 80023dc:	241a      	movs	r4, #26
 80023de:	4f84      	ldr	r7, [pc, #528]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 80023e0:	7838      	ldrb	r0, [r7, #0]
 80023e2:	0780      	lsls	r0, r0, #30
 80023e4:	d509      	bpl.n	80023fa <__iar_annotation$$branch+0x3c>
 80023e6:	2000      	movs	r0, #0
 80023e8:	9000      	str	r0, [sp, #0]
 80023ea:	2300      	movs	r3, #0
 80023ec:	2205      	movs	r2, #5
 80023ee:	7b28      	ldrb	r0, [r5, #12]
 80023f0:	07c1      	lsls	r1, r0, #31
 80023f2:	0fc9      	lsrs	r1, r1, #31
 80023f4:	2009      	movs	r0, #9
 80023f6:	68ff      	ldr	r7, [r7, #12]
 80023f8:	47b8      	blx	r7
 80023fa:	2105      	movs	r1, #5
 80023fc:	e22a      	b.n	8002854 <__iar_annotation$$branch+0x304>
 80023fe:	2911      	cmp	r1, #17
 8002400:	d15e      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 8002402:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002404:	0bc0      	lsrs	r0, r0, #15
 8002406:	d133      	bne.n	8002470 <__iar_annotation$$branch+0xb2>
 8002408:	2007      	movs	r0, #7
 800240a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800240c:	0b09      	lsrs	r1, r1, #12
 800240e:	4201      	tst	r1, r0
 8002410:	d02e      	beq.n	8002470 <__iar_annotation$$branch+0xb2>
 8002412:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002414:	06c9      	lsls	r1, r1, #27
 8002416:	0ec9      	lsrs	r1, r1, #27
 8002418:	2904      	cmp	r1, #4
 800241a:	d129      	bne.n	8002470 <__iar_annotation$$branch+0xb2>
 800241c:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800241e:	0b09      	lsrs	r1, r1, #12
 8002420:	4008      	ands	r0, r1
 8002422:	0083      	lsls	r3, r0, #2
 8002424:	209e      	movs	r0, #158	; 0x9e
 8002426:	0040      	lsls	r0, r0, #1
 8002428:	182a      	adds	r2, r5, r0
 800242a:	2105      	movs	r1, #5
 800242c:	7b2f      	ldrb	r7, [r5, #12]
 800242e:	07f8      	lsls	r0, r7, #31
 8002430:	0fc0      	lsrs	r0, r0, #31
 8002432:	68af      	ldr	r7, [r5, #8]
 8002434:	69ff      	ldr	r7, [r7, #28]
 8002436:	47b8      	blx	r7
 8002438:	2000      	movs	r0, #0
 800243a:	8330      	strh	r0, [r6, #24]
 800243c:	2014      	movs	r0, #20
 800243e:	4669      	mov	r1, sp
 8002440:	7308      	strb	r0, [r1, #12]
 8002442:	2003      	movs	r0, #3
 8002444:	7130      	strb	r0, [r6, #4]
 8002446:	4f6a      	ldr	r7, [pc, #424]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 8002448:	7838      	ldrb	r0, [r7, #0]
 800244a:	0780      	lsls	r0, r0, #30
 800244c:	d509      	bpl.n	8002462 <__iar_annotation$$branch+0xa4>
 800244e:	2000      	movs	r0, #0
 8002450:	9000      	str	r0, [sp, #0]
 8002452:	2300      	movs	r3, #0
 8002454:	2207      	movs	r2, #7
 8002456:	7b28      	ldrb	r0, [r5, #12]
 8002458:	07c1      	lsls	r1, r0, #31
 800245a:	0fc9      	lsrs	r1, r1, #31
 800245c:	2009      	movs	r0, #9
 800245e:	68ff      	ldr	r7, [r7, #12]
 8002460:	47b8      	blx	r7
 8002462:	2107      	movs	r1, #7
 8002464:	7b2a      	ldrb	r2, [r5, #12]
 8002466:	07d0      	lsls	r0, r2, #31
 8002468:	0fc0      	lsrs	r0, r0, #31
 800246a:	68aa      	ldr	r2, [r5, #8]
 800246c:	68d2      	ldr	r2, [r2, #12]
 800246e:	4790      	blx	r2
 8002470:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002472:	0bc0      	lsrs	r0, r0, #15
 8002474:	d124      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 8002476:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002478:	0b00      	lsrs	r0, r0, #12
 800247a:	0740      	lsls	r0, r0, #29
 800247c:	d120      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 800247e:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002480:	06c0      	lsls	r0, r0, #27
 8002482:	0ec0      	lsrs	r0, r0, #27
 8002484:	2804      	cmp	r0, #4
 8002486:	d11b      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 8002488:	2000      	movs	r0, #0
 800248a:	8330      	strh	r0, [r6, #24]
 800248c:	2014      	movs	r0, #20
 800248e:	4669      	mov	r1, sp
 8002490:	7308      	strb	r0, [r1, #12]
 8002492:	2003      	movs	r0, #3
 8002494:	7130      	strb	r0, [r6, #4]
 8002496:	4f56      	ldr	r7, [pc, #344]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 8002498:	7838      	ldrb	r0, [r7, #0]
 800249a:	0780      	lsls	r0, r0, #30
 800249c:	d509      	bpl.n	80024b2 <__iar_annotation$$branch+0xf4>
 800249e:	2000      	movs	r0, #0
 80024a0:	9000      	str	r0, [sp, #0]
 80024a2:	2300      	movs	r3, #0
 80024a4:	2208      	movs	r2, #8
 80024a6:	7b28      	ldrb	r0, [r5, #12]
 80024a8:	07c1      	lsls	r1, r0, #31
 80024aa:	0fc9      	lsrs	r1, r1, #31
 80024ac:	2009      	movs	r0, #9
 80024ae:	68ff      	ldr	r7, [r7, #12]
 80024b0:	47b8      	blx	r7
 80024b2:	2108      	movs	r1, #8
 80024b4:	7b2a      	ldrb	r2, [r5, #12]
 80024b6:	07d0      	lsls	r0, r2, #31
 80024b8:	0fc0      	lsrs	r0, r0, #31
 80024ba:	68aa      	ldr	r2, [r5, #8]
 80024bc:	68d2      	ldr	r2, [r2, #12]
 80024be:	4790      	blx	r2
 80024c0:	8b30      	ldrh	r0, [r6, #24]
 80024c2:	03a1      	lsls	r1, r4, #14
 80024c4:	4288      	cmp	r0, r1
 80024c6:	d000      	beq.n	80024ca <__iar_annotation$$branch>
 80024c8:	e18c      	b.n	80027e4 <__iar_annotation$$branch+0x294>

080024ca <__iar_annotation$$branch>:
 80024ca:	f000 fcf6 	bl	8002eba <__iar_annotation$$branch+0x96a>
 80024ce:	2000      	movs	r0, #0
 80024d0:	9000      	str	r0, [sp, #0]
 80024d2:	2303      	movs	r3, #3
 80024d4:	2204      	movs	r2, #4
 80024d6:	2100      	movs	r1, #0
 80024d8:	0028      	movs	r0, r5
 80024da:	f001 f94a 	bl	8003772 <PE_Send_CtrlMessage>
 80024de:	4844      	ldr	r0, [pc, #272]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 80024e0:	7800      	ldrb	r0, [r0, #0]
 80024e2:	0780      	lsls	r0, r0, #30
 80024e4:	d500      	bpl.n	80024e8 <__iar_annotation$$branch+0x1e>
 80024e6:	e1d5      	b.n	8002894 <__iar_annotation$$branch+0x344>
 80024e8:	e1df      	b.n	80028aa <__iar_annotation$$branch+0x35a>
 80024ea:	4943      	ldr	r1, [pc, #268]	; (80025f8 <__iar_annotation$$branch+0xa8>)
 80024ec:	84b1      	strh	r1, [r6, #36]	; 0x24
 80024ee:	2464      	movs	r4, #100	; 0x64
 80024f0:	2100      	movs	r1, #0
 80024f2:	82e9      	strh	r1, [r5, #22]
 80024f4:	2104      	movs	r1, #4
 80024f6:	7131      	strb	r1, [r6, #4]
 80024f8:	2800      	cmp	r0, #0
 80024fa:	d009      	beq.n	8002510 <__iar_annotation$$branch+0x46>
 80024fc:	2000      	movs	r0, #0
 80024fe:	9000      	str	r0, [sp, #0]
 8002500:	2300      	movs	r3, #0
 8002502:	221f      	movs	r2, #31
 8002504:	7b28      	ldrb	r0, [r5, #12]
 8002506:	07c1      	lsls	r1, r0, #31
 8002508:	0fc9      	lsrs	r1, r1, #31
 800250a:	2009      	movs	r0, #9
 800250c:	9f01      	ldr	r7, [sp, #4]
 800250e:	47b8      	blx	r7
 8002510:	211f      	movs	r1, #31
 8002512:	7b2a      	ldrb	r2, [r5, #12]
 8002514:	07d0      	lsls	r0, r2, #31
 8002516:	0fc0      	lsrs	r0, r0, #31
 8002518:	68aa      	ldr	r2, [r5, #8]
 800251a:	68d2      	ldr	r2, [r2, #12]
 800251c:	4790      	blx	r2
 800251e:	4668      	mov	r0, sp
 8002520:	7b00      	ldrb	r0, [r0, #12]
 8002522:	2814      	cmp	r0, #20
 8002524:	d016      	beq.n	8002554 <__iar_annotation$$branch+0x4>
 8002526:	79b0      	ldrb	r0, [r6, #6]
 8002528:	71f0      	strb	r0, [r6, #7]
 800252a:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800252c:	0bc0      	lsrs	r0, r0, #15
 800252e:	d001      	beq.n	8002534 <__iar_annotation$$branch+0x4>

08002530 <__iar_annotation$$branch>:
 8002530:	f000 fcad 	bl	8002e8e <__iar_annotation$$branch+0x93e>
 8002534:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002536:	0bc0      	lsrs	r0, r0, #15
 8002538:	d107      	bne.n	800254a <__iar_annotation$$branch+0x1a>
 800253a:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800253c:	0b00      	lsrs	r0, r0, #12
 800253e:	0740      	lsls	r0, r0, #29
 8002540:	d103      	bne.n	800254a <__iar_annotation$$branch+0x1a>
 8002542:	0028      	movs	r0, r5
 8002544:	f001 fa9e 	bl	8003a84 <PE_Check_ControlMessage>
 8002548:	e002      	b.n	8002550 <__iar_annotation$$branch>
 800254a:	0028      	movs	r0, r5
 800254c:	f001 fc36 	bl	8003dbc <PE_Check_DataMessage>

08002550 <__iar_annotation$$branch>:
 8002550:	f000 fca0 	bl	8002e94 <__iar_annotation$$branch+0x944>
 8002554:	68e8      	ldr	r0, [r5, #12]
 8002556:	0b00      	lsrs	r0, r0, #12
 8002558:	2180      	movs	r1, #128	; 0x80
 800255a:	0209      	lsls	r1, r1, #8
 800255c:	240f      	movs	r4, #15
 800255e:	2800      	cmp	r0, #0
 8002560:	d01e      	beq.n	80025a0 <__iar_annotation$$branch+0x50>
 8002562:	8a32      	ldrh	r2, [r6, #16]
 8002564:	428a      	cmp	r2, r1
 8002566:	d104      	bne.n	8002572 <__iar_annotation$$branch+0x22>
 8002568:	7134      	strb	r4, [r6, #4]
 800256a:	7d28      	ldrb	r0, [r5, #20]
 800256c:	1c40      	adds	r0, r0, #1
 800256e:	7528      	strb	r0, [r5, #20]
 8002570:	e12e      	b.n	80027d0 <__iar_annotation$$branch+0x280>
 8002572:	6b72      	ldr	r2, [r6, #52]	; 0x34
 8002574:	0512      	lsls	r2, r2, #20
 8002576:	0d12      	lsrs	r2, r2, #20
 8002578:	2307      	movs	r3, #7
 800257a:	8e34      	ldrh	r4, [r6, #48]	; 0x30
 800257c:	0a67      	lsrs	r7, r4, #9
 800257e:	2407      	movs	r4, #7
 8002580:	403c      	ands	r4, r7
 8002582:	1824      	adds	r4, r4, r0
 8002584:	2733      	movs	r7, #51	; 0x33
 8002586:	437c      	muls	r4, r7
 8002588:	18a4      	adds	r4, r4, r2
 800258a:	4321      	orrs	r1, r4
 800258c:	9c04      	ldr	r4, [sp, #16]
 800258e:	8021      	strh	r1, [r4, #0]
 8002590:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002592:	0a49      	lsrs	r1, r1, #9
 8002594:	400b      	ands	r3, r1
 8002596:	1818      	adds	r0, r3, r0
 8002598:	2133      	movs	r1, #51	; 0x33
 800259a:	4348      	muls	r0, r1
 800259c:	1884      	adds	r4, r0, r2
 800259e:	e121      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80025a0:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 80025a2:	4288      	cmp	r0, r1
 80025a4:	d103      	bne.n	80025ae <__iar_annotation$$branch+0x5e>
 80025a6:	2400      	movs	r4, #0
 80025a8:	85b4      	strh	r4, [r6, #44]	; 0x2c
 80025aa:	2044      	movs	r0, #68	; 0x44
 80025ac:	e1b0      	b.n	8002910 <__iar_annotation$$branch+0x3c0>
 80025ae:	7830      	ldrb	r0, [r6, #0]
 80025b0:	2800      	cmp	r0, #0
 80025b2:	d014      	beq.n	80025de <__iar_annotation$$branch+0x8e>
 80025b4:	6868      	ldr	r0, [r5, #4]
 80025b6:	7800      	ldrb	r0, [r0, #0]
 80025b8:	0781      	lsls	r1, r0, #30
 80025ba:	0f89      	lsrs	r1, r1, #30
 80025bc:	2901      	cmp	r1, #1
 80025be:	d007      	beq.n	80025d0 <__iar_annotation$$branch+0x80>
 80025c0:	2902      	cmp	r1, #2
 80025c2:	d10c      	bne.n	80025de <__iar_annotation$$branch+0x8e>
 80025c4:	4668      	mov	r0, sp
 80025c6:	7b40      	ldrb	r0, [r0, #13]
 80025c8:	f002 fcdf 	bl	8004f8a <USBPD_PRL_IsResistor_SinkTxOK>
 80025cc:	2801      	cmp	r0, #1
 80025ce:	d106      	bne.n	80025de <__iar_annotation$$branch+0x8e>
 80025d0:	7870      	ldrb	r0, [r6, #1]
 80025d2:	71f0      	strb	r0, [r6, #7]
 80025d4:	7830      	ldrb	r0, [r6, #0]
 80025d6:	7130      	strb	r0, [r6, #4]
 80025d8:	2400      	movs	r4, #0
 80025da:	7034      	strb	r4, [r6, #0]
 80025dc:	e102      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80025de:	48b4      	ldr	r0, [pc, #720]	; (80028b0 <__iar_annotation$$branch+0x360>)
 80025e0:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 80025e2:	4001      	ands	r1, r0
 80025e4:	2900      	cmp	r1, #0
 80025e6:	dd09      	ble.n	80025fc <__iar_annotation$$branch+0xac>
 80025e8:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 80025ea:	0004      	movs	r4, r0
 80025ec:	400c      	ands	r4, r1
 80025ee:	e0f9      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80025f0:	200019ac 	.word	0x200019ac
 80025f4:	0000803a 	.word	0x0000803a
 80025f8:	00008064 	.word	0x00008064
 80025fc:	7830      	ldrb	r0, [r6, #0]
 80025fe:	2800      	cmp	r0, #0
 8002600:	d000      	beq.n	8002604 <__iar_annotation$$branch+0xb4>
 8002602:	e0ef      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002604:	2400      	movs	r4, #0
 8002606:	43e4      	mvns	r4, r4
 8002608:	e0ec      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800260a:	4668      	mov	r0, sp
 800260c:	7b40      	ldrb	r0, [r0, #13]
 800260e:	68a9      	ldr	r1, [r5, #8]
 8002610:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
 8002612:	4788      	blx	r1
 8002614:	280a      	cmp	r0, #10
 8002616:	d145      	bne.n	80026a4 <__iar_annotation$$branch+0x154>
 8002618:	2000      	movs	r0, #0
 800261a:	9000      	str	r0, [sp, #0]
 800261c:	2303      	movs	r3, #3
 800261e:	2203      	movs	r2, #3
 8002620:	2100      	movs	r1, #0
 8002622:	0028      	movs	r0, r5
 8002624:	f001 f8a5 	bl	8003772 <PE_Send_CtrlMessage>
 8002628:	2800      	cmp	r0, #0
 800262a:	d000      	beq.n	800262e <__iar_annotation$$branch+0xde>
 800262c:	e0da      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800262e:	6868      	ldr	r0, [r5, #4]
 8002630:	7801      	ldrb	r1, [r0, #0]
 8002632:	08ca      	lsrs	r2, r1, #3
 8002634:	07d2      	lsls	r2, r2, #31
 8002636:	d412      	bmi.n	800265e <__iar_annotation$$branch+0x10e>
 8002638:	2208      	movs	r2, #8
 800263a:	430a      	orrs	r2, r1
 800263c:	7002      	strb	r2, [r0, #0]
 800263e:	4f9d      	ldr	r7, [pc, #628]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002640:	7838      	ldrb	r0, [r7, #0]
 8002642:	0780      	lsls	r0, r0, #30
 8002644:	d509      	bpl.n	800265a <__iar_annotation$$branch+0x10a>
 8002646:	2000      	movs	r0, #0
 8002648:	9000      	str	r0, [sp, #0]
 800264a:	2300      	movs	r3, #0
 800264c:	2224      	movs	r2, #36	; 0x24
 800264e:	7b28      	ldrb	r0, [r5, #12]
 8002650:	07c1      	lsls	r1, r0, #31
 8002652:	0fc9      	lsrs	r1, r1, #31
 8002654:	2009      	movs	r0, #9
 8002656:	68ff      	ldr	r7, [r7, #12]
 8002658:	47b8      	blx	r7
 800265a:	2124      	movs	r1, #36	; 0x24
 800265c:	e011      	b.n	8002682 <__iar_annotation$$branch+0x132>
 800265e:	22f7      	movs	r2, #247	; 0xf7
 8002660:	400a      	ands	r2, r1
 8002662:	7002      	strb	r2, [r0, #0]
 8002664:	4f93      	ldr	r7, [pc, #588]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002666:	7838      	ldrb	r0, [r7, #0]
 8002668:	0780      	lsls	r0, r0, #30
 800266a:	d509      	bpl.n	8002680 <__iar_annotation$$branch+0x130>
 800266c:	2000      	movs	r0, #0
 800266e:	9000      	str	r0, [sp, #0]
 8002670:	2300      	movs	r3, #0
 8002672:	2223      	movs	r2, #35	; 0x23
 8002674:	7b28      	ldrb	r0, [r5, #12]
 8002676:	07c1      	lsls	r1, r0, #31
 8002678:	0fc9      	lsrs	r1, r1, #31
 800267a:	2009      	movs	r0, #9
 800267c:	68ff      	ldr	r7, [r7, #12]
 800267e:	47b8      	blx	r7
 8002680:	2123      	movs	r1, #35	; 0x23
 8002682:	7b2a      	ldrb	r2, [r5, #12]
 8002684:	07d0      	lsls	r0, r2, #31
 8002686:	0fc0      	lsrs	r0, r0, #31
 8002688:	68aa      	ldr	r2, [r5, #8]
 800268a:	68d2      	ldr	r2, [r2, #12]
 800268c:	4790      	blx	r2
 800268e:	2001      	movs	r0, #1
 8002690:	6869      	ldr	r1, [r5, #4]
 8002692:	7809      	ldrb	r1, [r1, #0]
 8002694:	08ca      	lsrs	r2, r1, #3
 8002696:	2101      	movs	r1, #1
 8002698:	4011      	ands	r1, r2
 800269a:	68ea      	ldr	r2, [r5, #12]
 800269c:	4010      	ands	r0, r2
 800269e:	f002 fc4b 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 80026a2:	e09f      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026a4:	6868      	ldr	r0, [r5, #4]
 80026a6:	7800      	ldrb	r0, [r0, #0]
 80026a8:	0780      	lsls	r0, r0, #30
 80026aa:	0f80      	lsrs	r0, r0, #30
 80026ac:	2802      	cmp	r0, #2
 80026ae:	d101      	bne.n	80026b4 <__iar_annotation$$branch+0x164>
 80026b0:	2001      	movs	r0, #1
 80026b2:	e12d      	b.n	8002910 <__iar_annotation$$branch+0x3c0>
 80026b4:	202a      	movs	r0, #42	; 0x2a
 80026b6:	e12b      	b.n	8002910 <__iar_annotation$$branch+0x3c0>
 80026b8:	9400      	str	r4, [sp, #0]
 80026ba:	2395      	movs	r3, #149	; 0x95
 80026bc:	2209      	movs	r2, #9
 80026be:	2100      	movs	r1, #0
 80026c0:	0028      	movs	r0, r5
 80026c2:	f001 f856 	bl	8003772 <PE_Send_CtrlMessage>
 80026c6:	2800      	cmp	r0, #0
 80026c8:	d000      	beq.n	80026cc <__iar_annotation$$branch+0x17c>
 80026ca:	e08b      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026cc:	200f      	movs	r0, #15
 80026ce:	82e8      	strh	r0, [r5, #22]
 80026d0:	e3a7      	b.n	8002e22 <__iar_annotation$$branch+0x8d2>
 80026d2:	8b32      	ldrh	r2, [r6, #24]
 80026d4:	03a3      	lsls	r3, r4, #14
 80026d6:	429a      	cmp	r2, r3
 80026d8:	d100      	bne.n	80026dc <__iar_annotation$$branch+0x18c>
 80026da:	e6f6      	b.n	80024ca <__iar_annotation$$branch>
 80026dc:	2914      	cmp	r1, #20
 80026de:	d100      	bne.n	80026e2 <__iar_annotation$$branch+0x192>
 80026e0:	e080      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026e2:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 80026e4:	0bc9      	lsrs	r1, r1, #15
 80026e6:	d000      	beq.n	80026ea <__iar_annotation$$branch+0x19a>
 80026e8:	e07c      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026ea:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 80026ec:	0b09      	lsrs	r1, r1, #12
 80026ee:	0749      	lsls	r1, r1, #29
 80026f0:	d178      	bne.n	80027e4 <__iar_annotation$$branch+0x294>
 80026f2:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 80026f4:	06c9      	lsls	r1, r1, #27
 80026f6:	0ec9      	lsrs	r1, r1, #27
 80026f8:	2903      	cmp	r1, #3
 80026fa:	d004      	beq.n	8002706 <__iar_annotation$$branch+0x1b6>
 80026fc:	2904      	cmp	r1, #4
 80026fe:	d04d      	beq.n	800279c <__iar_annotation$$branch+0x24c>
 8002700:	290c      	cmp	r1, #12
 8002702:	d037      	beq.n	8002774 <__iar_annotation$$branch+0x224>
 8002704:	e06e      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002706:	6869      	ldr	r1, [r5, #4]
 8002708:	780a      	ldrb	r2, [r1, #0]
 800270a:	08d3      	lsrs	r3, r2, #3
 800270c:	07db      	lsls	r3, r3, #31
 800270e:	d410      	bmi.n	8002732 <__iar_annotation$$branch+0x1e2>
 8002710:	2308      	movs	r3, #8
 8002712:	4313      	orrs	r3, r2
 8002714:	700b      	strb	r3, [r1, #0]
 8002716:	2800      	cmp	r0, #0
 8002718:	d009      	beq.n	800272e <__iar_annotation$$branch+0x1de>
 800271a:	2000      	movs	r0, #0
 800271c:	9000      	str	r0, [sp, #0]
 800271e:	2300      	movs	r3, #0
 8002720:	2224      	movs	r2, #36	; 0x24
 8002722:	7b28      	ldrb	r0, [r5, #12]
 8002724:	07c1      	lsls	r1, r0, #31
 8002726:	0fc9      	lsrs	r1, r1, #31
 8002728:	2009      	movs	r0, #9
 800272a:	9f01      	ldr	r7, [sp, #4]
 800272c:	47b8      	blx	r7
 800272e:	2124      	movs	r1, #36	; 0x24
 8002730:	e00f      	b.n	8002752 <__iar_annotation$$branch+0x202>
 8002732:	23f7      	movs	r3, #247	; 0xf7
 8002734:	4013      	ands	r3, r2
 8002736:	700b      	strb	r3, [r1, #0]
 8002738:	2800      	cmp	r0, #0
 800273a:	d009      	beq.n	8002750 <__iar_annotation$$branch+0x200>
 800273c:	2000      	movs	r0, #0
 800273e:	9000      	str	r0, [sp, #0]
 8002740:	2300      	movs	r3, #0
 8002742:	2223      	movs	r2, #35	; 0x23
 8002744:	7b28      	ldrb	r0, [r5, #12]
 8002746:	07c1      	lsls	r1, r0, #31
 8002748:	0fc9      	lsrs	r1, r1, #31
 800274a:	2009      	movs	r0, #9
 800274c:	9f01      	ldr	r7, [sp, #4]
 800274e:	47b8      	blx	r7
 8002750:	2123      	movs	r1, #35	; 0x23
 8002752:	7b2a      	ldrb	r2, [r5, #12]
 8002754:	07d0      	lsls	r0, r2, #31
 8002756:	0fc0      	lsrs	r0, r0, #31
 8002758:	68aa      	ldr	r2, [r5, #8]
 800275a:	68d2      	ldr	r2, [r2, #12]
 800275c:	4790      	blx	r2
 800275e:	2001      	movs	r0, #1
 8002760:	6869      	ldr	r1, [r5, #4]
 8002762:	7809      	ldrb	r1, [r1, #0]
 8002764:	08ca      	lsrs	r2, r1, #3
 8002766:	2101      	movs	r1, #1
 8002768:	4011      	ands	r1, r2
 800276a:	68ea      	ldr	r2, [r5, #12]
 800276c:	4010      	ands	r0, r2
 800276e:	f002 fbe3 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 8002772:	e30f      	b.n	8002d94 <__iar_annotation$$branch+0x844>
 8002774:	2800      	cmp	r0, #0
 8002776:	d009      	beq.n	800278c <__iar_annotation$$branch+0x23c>
 8002778:	2000      	movs	r0, #0
 800277a:	9000      	str	r0, [sp, #0]
 800277c:	2300      	movs	r3, #0
 800277e:	2225      	movs	r2, #37	; 0x25
 8002780:	7b28      	ldrb	r0, [r5, #12]
 8002782:	07c1      	lsls	r1, r0, #31
 8002784:	0fc9      	lsrs	r1, r1, #31
 8002786:	2009      	movs	r0, #9
 8002788:	9f01      	ldr	r7, [sp, #4]
 800278a:	47b8      	blx	r7
 800278c:	2125      	movs	r1, #37	; 0x25
 800278e:	7b2a      	ldrb	r2, [r5, #12]
 8002790:	07d0      	lsls	r0, r2, #31
 8002792:	0fc0      	lsrs	r0, r0, #31
 8002794:	68aa      	ldr	r2, [r5, #8]
 8002796:	68d2      	ldr	r2, [r2, #12]
 8002798:	4790      	blx	r2
 800279a:	e2fb      	b.n	8002d94 <__iar_annotation$$branch+0x844>
 800279c:	2800      	cmp	r0, #0
 800279e:	d009      	beq.n	80027b4 <__iar_annotation$$branch+0x264>
 80027a0:	2000      	movs	r0, #0
 80027a2:	9000      	str	r0, [sp, #0]
 80027a4:	2300      	movs	r3, #0
 80027a6:	2226      	movs	r2, #38	; 0x26
 80027a8:	7b28      	ldrb	r0, [r5, #12]
 80027aa:	07c1      	lsls	r1, r0, #31
 80027ac:	0fc9      	lsrs	r1, r1, #31
 80027ae:	2009      	movs	r0, #9
 80027b0:	9f01      	ldr	r7, [sp, #4]
 80027b2:	47b8      	blx	r7
 80027b4:	2126      	movs	r1, #38	; 0x26
 80027b6:	7b2a      	ldrb	r2, [r5, #12]
 80027b8:	07d0      	lsls	r0, r2, #31
 80027ba:	0fc0      	lsrs	r0, r0, #31
 80027bc:	68aa      	ldr	r2, [r5, #8]
 80027be:	68d2      	ldr	r2, [r2, #12]
 80027c0:	4790      	blx	r2
 80027c2:	e2e7      	b.n	8002d94 <__iar_annotation$$branch+0x844>
 80027c4:	68a8      	ldr	r0, [r5, #8]
 80027c6:	6881      	ldr	r1, [r0, #8]
 80027c8:	2900      	cmp	r1, #0
 80027ca:	d102      	bne.n	80027d2 <__iar_annotation$$branch+0x282>
 80027cc:	202a      	movs	r0, #42	; 0x2a
 80027ce:	7130      	strb	r0, [r6, #4]
 80027d0:	e354      	b.n	8002e7c <__iar_annotation$$branch+0x92c>
 80027d2:	4668      	mov	r0, sp
 80027d4:	7b40      	ldrb	r0, [r0, #13]
 80027d6:	4788      	blx	r1
 80027d8:	280a      	cmp	r0, #10
 80027da:	d004      	beq.n	80027e6 <__iar_annotation$$branch+0x296>
 80027dc:	280c      	cmp	r0, #12
 80027de:	d052      	beq.n	8002886 <__iar_annotation$$branch+0x336>
 80027e0:	280d      	cmp	r0, #13
 80027e2:	d038      	beq.n	8002856 <__iar_annotation$$branch+0x306>
 80027e4:	e392      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 80027e6:	68a8      	ldr	r0, [r5, #8]
 80027e8:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80027ea:	2b00      	cmp	r3, #0
 80027ec:	d005      	beq.n	80027fa <__iar_annotation$$branch+0x2aa>
 80027ee:	2201      	movs	r2, #1
 80027f0:	2100      	movs	r1, #0
 80027f2:	7b2f      	ldrb	r7, [r5, #12]
 80027f4:	07f8      	lsls	r0, r7, #31
 80027f6:	0fc0      	lsrs	r0, r0, #31
 80027f8:	4798      	blx	r3
 80027fa:	2000      	movs	r0, #0
 80027fc:	9000      	str	r0, [sp, #0]
 80027fe:	2352      	movs	r3, #82	; 0x52
 8002800:	2203      	movs	r2, #3
 8002802:	2100      	movs	r1, #0
 8002804:	0028      	movs	r0, r5
 8002806:	f000 ffb4 	bl	8003772 <PE_Send_CtrlMessage>
 800280a:	2800      	cmp	r0, #0
 800280c:	d1ea      	bne.n	80027e4 <__iar_annotation$$branch+0x294>
 800280e:	2008      	movs	r0, #8
 8002810:	82e8      	strh	r0, [r5, #22]
 8002812:	6868      	ldr	r0, [r5, #4]
 8002814:	6801      	ldr	r1, [r0, #0]
 8002816:	2210      	movs	r2, #16
 8002818:	430a      	orrs	r2, r1
 800281a:	6002      	str	r2, [r0, #0]
 800281c:	68a8      	ldr	r0, [r5, #8]
 800281e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002820:	2b00      	cmp	r3, #0
 8002822:	d005      	beq.n	8002830 <__iar_annotation$$branch+0x2e0>
 8002824:	2206      	movs	r2, #6
 8002826:	2100      	movs	r1, #0
 8002828:	7b2c      	ldrb	r4, [r5, #12]
 800282a:	07e0      	lsls	r0, r4, #31
 800282c:	0fc0      	lsrs	r0, r0, #31
 800282e:	4798      	blx	r3
 8002830:	489d      	ldr	r0, [pc, #628]	; (8002aa8 <__iar_annotation$$branch+0x558>)
 8002832:	82b0      	strh	r0, [r6, #20]
 8002834:	4c9d      	ldr	r4, [pc, #628]	; (8002aac <__iar_annotation$$branch+0x55c>)
 8002836:	4f1f      	ldr	r7, [pc, #124]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002838:	7838      	ldrb	r0, [r7, #0]
 800283a:	0780      	lsls	r0, r0, #30
 800283c:	d509      	bpl.n	8002852 <__iar_annotation$$branch+0x302>
 800283e:	2000      	movs	r0, #0
 8002840:	9000      	str	r0, [sp, #0]
 8002842:	2300      	movs	r3, #0
 8002844:	2238      	movs	r2, #56	; 0x38
 8002846:	7b28      	ldrb	r0, [r5, #12]
 8002848:	07c1      	lsls	r1, r0, #31
 800284a:	0fc9      	lsrs	r1, r1, #31
 800284c:	2009      	movs	r0, #9
 800284e:	68ff      	ldr	r7, [r7, #12]
 8002850:	47b8      	blx	r7
 8002852:	2138      	movs	r1, #56	; 0x38
 8002854:	e2fe      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 8002856:	2000      	movs	r0, #0
 8002858:	9000      	str	r0, [sp, #0]
 800285a:	2303      	movs	r3, #3
 800285c:	220c      	movs	r2, #12
 800285e:	2100      	movs	r1, #0
 8002860:	0028      	movs	r0, r5
 8002862:	f000 ff86 	bl	8003772 <PE_Send_CtrlMessage>
 8002866:	4f13      	ldr	r7, [pc, #76]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002868:	7838      	ldrb	r0, [r7, #0]
 800286a:	0780      	lsls	r0, r0, #30
 800286c:	d509      	bpl.n	8002882 <__iar_annotation$$branch+0x332>
 800286e:	2000      	movs	r0, #0
 8002870:	9000      	str	r0, [sp, #0]
 8002872:	2300      	movs	r3, #0
 8002874:	2239      	movs	r2, #57	; 0x39
 8002876:	7b28      	ldrb	r0, [r5, #12]
 8002878:	07c1      	lsls	r1, r0, #31
 800287a:	0fc9      	lsrs	r1, r1, #31
 800287c:	2009      	movs	r0, #9
 800287e:	68ff      	ldr	r7, [r7, #12]
 8002880:	47b8      	blx	r7
 8002882:	2139      	movs	r1, #57	; 0x39
 8002884:	e2e6      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 8002886:	202a      	movs	r0, #42	; 0x2a
 8002888:	7130      	strb	r0, [r6, #4]
 800288a:	2400      	movs	r4, #0
 800288c:	4809      	ldr	r0, [pc, #36]	; (80028b4 <__iar_annotation$$branch+0x364>)
 800288e:	7800      	ldrb	r0, [r0, #0]
 8002890:	0780      	lsls	r0, r0, #30
 8002892:	d50a      	bpl.n	80028aa <__iar_annotation$$branch+0x35a>
 8002894:	2000      	movs	r0, #0
 8002896:	9000      	str	r0, [sp, #0]
 8002898:	2300      	movs	r3, #0
 800289a:	2216      	movs	r2, #22
 800289c:	7b28      	ldrb	r0, [r5, #12]
 800289e:	07c1      	lsls	r1, r0, #31
 80028a0:	0fc9      	lsrs	r1, r1, #31
 80028a2:	2009      	movs	r0, #9
 80028a4:	4f03      	ldr	r7, [pc, #12]	; (80028b4 <__iar_annotation$$branch+0x364>)
 80028a6:	68ff      	ldr	r7, [r7, #12]
 80028a8:	47b8      	blx	r7
 80028aa:	2116      	movs	r1, #22
 80028ac:	e2d2      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 80028ae:	bf00      	nop
 80028b0:	00007fff 	.word	0x00007fff
 80028b4:	200019ac 	.word	0x200019ac
 80028b8:	2911      	cmp	r1, #17
 80028ba:	d11c      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028bc:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 80028be:	0bc0      	lsrs	r0, r0, #15
 80028c0:	d119      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028c2:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 80028c4:	0b00      	lsrs	r0, r0, #12
 80028c6:	0740      	lsls	r0, r0, #29
 80028c8:	d115      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028ca:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 80028cc:	06c0      	lsls	r0, r0, #27
 80028ce:	0ec0      	lsrs	r0, r0, #27
 80028d0:	2806      	cmp	r0, #6
 80028d2:	d110      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028d4:	2000      	movs	r0, #0
 80028d6:	82f0      	strh	r0, [r6, #22]
 80028d8:	68a8      	ldr	r0, [r5, #8]
 80028da:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80028dc:	2b00      	cmp	r3, #0
 80028de:	d005      	beq.n	80028ec <__iar_annotation$$branch+0x39c>
 80028e0:	2209      	movs	r2, #9
 80028e2:	2100      	movs	r1, #0
 80028e4:	7b2f      	ldrb	r7, [r5, #12]
 80028e6:	07f8      	lsls	r0, r7, #31
 80028e8:	0fc0      	lsrs	r0, r0, #31
 80028ea:	4798      	blx	r3
 80028ec:	2053      	movs	r0, #83	; 0x53
 80028ee:	7130      	strb	r0, [r6, #4]
 80028f0:	2014      	movs	r0, #20
 80028f2:	4669      	mov	r1, sp
 80028f4:	7308      	strb	r0, [r1, #12]
 80028f6:	8ab0      	ldrh	r0, [r6, #20]
 80028f8:	03a1      	lsls	r1, r4, #14
 80028fa:	4288      	cmp	r0, r1
 80028fc:	d000      	beq.n	8002900 <__iar_annotation$$branch+0x3b0>
 80028fe:	e305      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002900:	2000      	movs	r0, #0
 8002902:	82b0      	strh	r0, [r6, #20]
 8002904:	68a8      	ldr	r0, [r5, #8]
 8002906:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8002908:	2800      	cmp	r0, #0
 800290a:	d100      	bne.n	800290e <__iar_annotation$$branch+0x3be>
 800290c:	e185      	b.n	8002c1a <__iar_annotation$$branch+0x6ca>
 800290e:	2092      	movs	r0, #146	; 0x92
 8002910:	e2fb      	b.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002912:	6869      	ldr	r1, [r5, #4]
 8002914:	784a      	ldrb	r2, [r1, #1]
 8002916:	238f      	movs	r3, #143	; 0x8f
 8002918:	4013      	ands	r3, r2
 800291a:	2240      	movs	r2, #64	; 0x40
 800291c:	431a      	orrs	r2, r3
 800291e:	704a      	strb	r2, [r1, #1]
 8002920:	2800      	cmp	r0, #0
 8002922:	d009      	beq.n	8002938 <__iar_annotation$$branch+0x3e8>
 8002924:	2000      	movs	r0, #0
 8002926:	9000      	str	r0, [sp, #0]
 8002928:	2300      	movs	r3, #0
 800292a:	2256      	movs	r2, #86	; 0x56
 800292c:	7b28      	ldrb	r0, [r5, #12]
 800292e:	07c1      	lsls	r1, r0, #31
 8002930:	0fc9      	lsrs	r1, r1, #31
 8002932:	2009      	movs	r0, #9
 8002934:	9f01      	ldr	r7, [sp, #4]
 8002936:	47b8      	blx	r7
 8002938:	2701      	movs	r7, #1
 800293a:	2156      	movs	r1, #86	; 0x56
 800293c:	68ea      	ldr	r2, [r5, #12]
 800293e:	2001      	movs	r0, #1
 8002940:	4010      	ands	r0, r2
 8002942:	68aa      	ldr	r2, [r5, #8]
 8002944:	68d2      	ldr	r2, [r2, #12]
 8002946:	4790      	blx	r2
 8002948:	68a8      	ldr	r0, [r5, #8]
 800294a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800294c:	2b00      	cmp	r3, #0
 800294e:	d005      	beq.n	800295c <__iar_annotation$$branch+0x40c>
 8002950:	220a      	movs	r2, #10
 8002952:	68e9      	ldr	r1, [r5, #12]
 8002954:	2001      	movs	r0, #1
 8002956:	4008      	ands	r0, r1
 8002958:	2100      	movs	r1, #0
 800295a:	4798      	blx	r3
 800295c:	68e9      	ldr	r1, [r5, #12]
 800295e:	2001      	movs	r0, #1
 8002960:	4008      	ands	r0, r1
 8002962:	f002 fb03 	bl	8004f6c <USBPD_PRL_SRCSetSinkNG>
 8002966:	68a8      	ldr	r0, [r5, #8]
 8002968:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800296a:	2b00      	cmp	r3, #0
 800296c:	d005      	beq.n	800297a <__iar_annotation$$branch+0x42a>
 800296e:	220b      	movs	r2, #11
 8002970:	68e9      	ldr	r1, [r5, #12]
 8002972:	2001      	movs	r0, #1
 8002974:	4008      	ands	r0, r1
 8002976:	2101      	movs	r1, #1
 8002978:	4798      	blx	r3
 800297a:	2101      	movs	r1, #1
 800297c:	4668      	mov	r0, sp
 800297e:	7b40      	ldrb	r0, [r0, #13]
 8002980:	f002 facf 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8002984:	2000      	movs	r0, #0
 8002986:	9000      	str	r0, [sp, #0]
 8002988:	2354      	movs	r3, #84	; 0x54
 800298a:	2206      	movs	r2, #6
 800298c:	2100      	movs	r1, #0
 800298e:	0028      	movs	r0, r5
 8002990:	f000 feef 	bl	8003772 <PE_Send_CtrlMessage>
 8002994:	2800      	cmp	r0, #0
 8002996:	d10c      	bne.n	80029b2 <__iar_annotation$$branch+0x462>
 8002998:	68a8      	ldr	r0, [r5, #8]
 800299a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800299c:	2b00      	cmp	r3, #0
 800299e:	d005      	beq.n	80029ac <__iar_annotation$$branch+0x45c>
 80029a0:	220c      	movs	r2, #12
 80029a2:	2100      	movs	r1, #0
 80029a4:	68ec      	ldr	r4, [r5, #12]
 80029a6:	2001      	movs	r0, #1
 80029a8:	4020      	ands	r0, r4
 80029aa:	4798      	blx	r3
 80029ac:	48b2      	ldr	r0, [pc, #712]	; (8002c78 <__iar_annotation$$branch+0x728>)
 80029ae:	8430      	strh	r0, [r6, #32]
 80029b0:	2414      	movs	r4, #20
 80029b2:	7930      	ldrb	r0, [r6, #4]
 80029b4:	2854      	cmp	r0, #84	; 0x54
 80029b6:	d05c      	beq.n	8002a72 <__iar_annotation$$branch+0x522>
 80029b8:	2100      	movs	r1, #0
 80029ba:	4668      	mov	r0, sp
 80029bc:	7b40      	ldrb	r0, [r0, #13]
 80029be:	f002 fab0 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 80029c2:	68a8      	ldr	r0, [r5, #8]
 80029c4:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80029c6:	2b00      	cmp	r3, #0
 80029c8:	d053      	beq.n	8002a72 <__iar_annotation$$branch+0x522>
 80029ca:	2206      	movs	r2, #6
 80029cc:	68e9      	ldr	r1, [r5, #12]
 80029ce:	2001      	movs	r0, #1
 80029d0:	4008      	ands	r0, r1
 80029d2:	2101      	movs	r1, #1
 80029d4:	4798      	blx	r3
 80029d6:	68a8      	ldr	r0, [r5, #8]
 80029d8:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80029da:	2b00      	cmp	r3, #0
 80029dc:	d049      	beq.n	8002a72 <__iar_annotation$$branch+0x522>
 80029de:	2207      	movs	r2, #7
 80029e0:	2100      	movs	r1, #0
 80029e2:	68e8      	ldr	r0, [r5, #12]
 80029e4:	4007      	ands	r7, r0
 80029e6:	0038      	movs	r0, r7
 80029e8:	e151      	b.n	8002c8e <__iar_annotation$$branch+0x73e>
 80029ea:	8c30      	ldrh	r0, [r6, #32]
 80029ec:	03a1      	lsls	r1, r4, #14
 80029ee:	4288      	cmp	r0, r1
 80029f0:	d13f      	bne.n	8002a72 <__iar_annotation$$branch+0x522>
 80029f2:	2000      	movs	r0, #0
 80029f4:	8430      	strh	r0, [r6, #32]
 80029f6:	2101      	movs	r1, #1
 80029f8:	0028      	movs	r0, r5
 80029fa:	f000 ffcf 	bl	800399c <PE_ChangePowerRole>
 80029fe:	68a8      	ldr	r0, [r5, #8]
 8002a00:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002a02:	2b00      	cmp	r3, #0
 8002a04:	d005      	beq.n	8002a12 <__iar_annotation$$branch+0x4c2>
 8002a06:	220e      	movs	r2, #14
 8002a08:	2101      	movs	r1, #1
 8002a0a:	7b2f      	ldrb	r7, [r5, #12]
 8002a0c:	07f8      	lsls	r0, r7, #31
 8002a0e:	0fc0      	lsrs	r0, r0, #31
 8002a10:	4798      	blx	r3
 8002a12:	7b29      	ldrb	r1, [r5, #12]
 8002a14:	07c8      	lsls	r0, r1, #31
 8002a16:	0fc0      	lsrs	r0, r0, #31
 8002a18:	f002 faac 	bl	8004f74 <USBPD_PRL_SRCReleaseSinkNG>
 8002a1c:	0028      	movs	r0, r5
 8002a1e:	f001 fc67 	bl	80042f0 <PE_ResetDuringSwap>
 8002a22:	48b0      	ldr	r0, [pc, #704]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002a24:	7800      	ldrb	r0, [r0, #0]
 8002a26:	0780      	lsls	r0, r0, #30
 8002a28:	d500      	bpl.n	8002a2c <__iar_annotation$$branch+0x4dc>
 8002a2a:	e14d      	b.n	8002cc8 <__iar_annotation$$branch+0x778>
 8002a2c:	e157      	b.n	8002cde <__iar_annotation$$branch+0x78e>
 8002a2e:	68a8      	ldr	r0, [r5, #8]
 8002a30:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002a32:	2b00      	cmp	r3, #0
 8002a34:	d005      	beq.n	8002a42 <__iar_annotation$$branch+0x4f2>
 8002a36:	2202      	movs	r2, #2
 8002a38:	7b29      	ldrb	r1, [r5, #12]
 8002a3a:	07c8      	lsls	r0, r1, #31
 8002a3c:	0fc0      	lsrs	r0, r0, #31
 8002a3e:	2100      	movs	r1, #0
 8002a40:	4798      	blx	r3
 8002a42:	9400      	str	r4, [sp, #0]
 8002a44:	2358      	movs	r3, #88	; 0x58
 8002a46:	20e5      	movs	r0, #229	; 0xe5
 8002a48:	0080      	lsls	r0, r0, #2
 8002a4a:	5c2a      	ldrb	r2, [r5, r0]
 8002a4c:	2100      	movs	r1, #0
 8002a4e:	0028      	movs	r0, r5
 8002a50:	f000 fe8f 	bl	8003772 <PE_Send_CtrlMessage>
 8002a54:	2800      	cmp	r0, #0
 8002a56:	d000      	beq.n	8002a5a <__iar_annotation$$branch+0x50a>
 8002a58:	e110      	b.n	8002c7c <__iar_annotation$$branch+0x72c>
 8002a5a:	20e5      	movs	r0, #229	; 0xe5
 8002a5c:	0080      	lsls	r0, r0, #2
 8002a5e:	1828      	adds	r0, r5, r0
 8002a60:	8840      	ldrh	r0, [r0, #2]
 8002a62:	82e8      	strh	r0, [r5, #22]
 8002a64:	8337      	strh	r7, [r6, #24]
 8002a66:	241a      	movs	r4, #26
 8002a68:	6868      	ldr	r0, [r5, #4]
 8002a6a:	6801      	ldr	r1, [r0, #0]
 8002a6c:	2210      	movs	r2, #16
 8002a6e:	430a      	orrs	r2, r1
 8002a70:	6002      	str	r2, [r0, #0]
 8002a72:	e24b      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002a74:	2911      	cmp	r1, #17
 8002a76:	d111      	bne.n	8002a9c <__iar_annotation$$branch+0x54c>
 8002a78:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002a7a:	0bc9      	lsrs	r1, r1, #15
 8002a7c:	d10e      	bne.n	8002a9c <__iar_annotation$$branch+0x54c>
 8002a7e:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002a80:	0b09      	lsrs	r1, r1, #12
 8002a82:	0749      	lsls	r1, r1, #29
 8002a84:	d10a      	bne.n	8002a9c <__iar_annotation$$branch+0x54c>
 8002a86:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002a88:	06c9      	lsls	r1, r1, #27
 8002a8a:	0ec9      	lsrs	r1, r1, #27
 8002a8c:	2903      	cmp	r1, #3
 8002a8e:	d006      	beq.n	8002a9e <__iar_annotation$$branch+0x54e>
 8002a90:	2904      	cmp	r1, #4
 8002a92:	d066      	beq.n	8002b62 <__iar_annotation$$branch+0x612>
 8002a94:	290c      	cmp	r1, #12
 8002a96:	d049      	beq.n	8002b2c <__iar_annotation$$branch+0x5dc>
 8002a98:	2910      	cmp	r1, #16
 8002a9a:	d077      	beq.n	8002b8c <__iar_annotation$$branch+0x63c>
 8002a9c:	e090      	b.n	8002bc0 <__iar_annotation$$branch+0x670>
 8002a9e:	4802      	ldr	r0, [pc, #8]	; (8002aa8 <__iar_annotation$$branch+0x558>)
 8002aa0:	82b0      	strh	r0, [r6, #20]
 8002aa2:	4c02      	ldr	r4, [pc, #8]	; (8002aac <__iar_annotation$$branch+0x55c>)
 8002aa4:	e004      	b.n	8002ab0 <__iar_annotation$$branch+0x560>
 8002aa6:	bf00      	nop
 8002aa8:	00008343 	.word	0x00008343
 8002aac:	00000343 	.word	0x00000343
 8002ab0:	2000      	movs	r0, #0
 8002ab2:	8330      	strh	r0, [r6, #24]
 8002ab4:	2014      	movs	r0, #20
 8002ab6:	4669      	mov	r1, sp
 8002ab8:	7308      	strb	r0, [r1, #12]
 8002aba:	2059      	movs	r0, #89	; 0x59
 8002abc:	7130      	strb	r0, [r6, #4]
 8002abe:	68a8      	ldr	r0, [r5, #8]
 8002ac0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002ac2:	2b00      	cmp	r3, #0
 8002ac4:	d005      	beq.n	8002ad2 <__iar_annotation$$branch+0x582>
 8002ac6:	2206      	movs	r2, #6
 8002ac8:	2100      	movs	r1, #0
 8002aca:	7b2f      	ldrb	r7, [r5, #12]
 8002acc:	07f8      	lsls	r0, r7, #31
 8002ace:	0fc0      	lsrs	r0, r0, #31
 8002ad0:	4798      	blx	r3
 8002ad2:	6868      	ldr	r0, [r5, #4]
 8002ad4:	7841      	ldrb	r1, [r0, #1]
 8002ad6:	228f      	movs	r2, #143	; 0x8f
 8002ad8:	400a      	ands	r2, r1
 8002ada:	2140      	movs	r1, #64	; 0x40
 8002adc:	4311      	orrs	r1, r2
 8002ade:	7041      	strb	r1, [r0, #1]
 8002ae0:	4880      	ldr	r0, [pc, #512]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002ae2:	7800      	ldrb	r0, [r0, #0]
 8002ae4:	0780      	lsls	r0, r0, #30
 8002ae6:	d50a      	bpl.n	8002afe <__iar_annotation$$branch+0x5ae>
 8002ae8:	2000      	movs	r0, #0
 8002aea:	9000      	str	r0, [sp, #0]
 8002aec:	2300      	movs	r3, #0
 8002aee:	2256      	movs	r2, #86	; 0x56
 8002af0:	7b28      	ldrb	r0, [r5, #12]
 8002af2:	07c1      	lsls	r1, r0, #31
 8002af4:	0fc9      	lsrs	r1, r1, #31
 8002af6:	2009      	movs	r0, #9
 8002af8:	4f7a      	ldr	r7, [pc, #488]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002afa:	68ff      	ldr	r7, [r7, #12]
 8002afc:	47b8      	blx	r7
 8002afe:	2156      	movs	r1, #86	; 0x56
 8002b00:	7b2a      	ldrb	r2, [r5, #12]
 8002b02:	07d0      	lsls	r0, r2, #31
 8002b04:	0fc0      	lsrs	r0, r0, #31
 8002b06:	68aa      	ldr	r2, [r5, #8]
 8002b08:	68d2      	ldr	r2, [r2, #12]
 8002b0a:	4790      	blx	r2
 8002b0c:	4f75      	ldr	r7, [pc, #468]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002b0e:	7838      	ldrb	r0, [r7, #0]
 8002b10:	0780      	lsls	r0, r0, #30
 8002b12:	d509      	bpl.n	8002b28 <__iar_annotation$$branch+0x5d8>
 8002b14:	2000      	movs	r0, #0
 8002b16:	9000      	str	r0, [sp, #0]
 8002b18:	2300      	movs	r3, #0
 8002b1a:	2238      	movs	r2, #56	; 0x38
 8002b1c:	7b28      	ldrb	r0, [r5, #12]
 8002b1e:	07c1      	lsls	r1, r0, #31
 8002b20:	0fc9      	lsrs	r1, r1, #31
 8002b22:	2009      	movs	r0, #9
 8002b24:	68ff      	ldr	r7, [r7, #12]
 8002b26:	47b8      	blx	r7
 8002b28:	2138      	movs	r1, #56	; 0x38
 8002b2a:	e043      	b.n	8002bb4 <__iar_annotation$$branch+0x664>
 8002b2c:	2800      	cmp	r0, #0
 8002b2e:	d009      	beq.n	8002b44 <__iar_annotation$$branch+0x5f4>
 8002b30:	2000      	movs	r0, #0
 8002b32:	9000      	str	r0, [sp, #0]
 8002b34:	2300      	movs	r3, #0
 8002b36:	2239      	movs	r2, #57	; 0x39
 8002b38:	7b28      	ldrb	r0, [r5, #12]
 8002b3a:	07c1      	lsls	r1, r0, #31
 8002b3c:	0fc9      	lsrs	r1, r1, #31
 8002b3e:	2009      	movs	r0, #9
 8002b40:	9f01      	ldr	r7, [sp, #4]
 8002b42:	47b8      	blx	r7
 8002b44:	2139      	movs	r1, #57	; 0x39
 8002b46:	7b2a      	ldrb	r2, [r5, #12]
 8002b48:	07d0      	lsls	r0, r2, #31
 8002b4a:	0fc0      	lsrs	r0, r0, #31
 8002b4c:	68aa      	ldr	r2, [r5, #8]
 8002b4e:	68d2      	ldr	r2, [r2, #12]
 8002b50:	4790      	blx	r2
 8002b52:	2000      	movs	r0, #0
 8002b54:	8330      	strh	r0, [r6, #24]
 8002b56:	2014      	movs	r0, #20
 8002b58:	4669      	mov	r1, sp
 8002b5a:	7308      	strb	r0, [r1, #12]
 8002b5c:	2003      	movs	r0, #3
 8002b5e:	7130      	strb	r0, [r6, #4]
 8002b60:	e02e      	b.n	8002bc0 <__iar_annotation$$branch+0x670>
 8002b62:	2100      	movs	r1, #0
 8002b64:	8331      	strh	r1, [r6, #24]
 8002b66:	2114      	movs	r1, #20
 8002b68:	466a      	mov	r2, sp
 8002b6a:	7311      	strb	r1, [r2, #12]
 8002b6c:	2103      	movs	r1, #3
 8002b6e:	7131      	strb	r1, [r6, #4]
 8002b70:	2800      	cmp	r0, #0
 8002b72:	d009      	beq.n	8002b88 <__iar_annotation$$branch+0x638>
 8002b74:	2000      	movs	r0, #0
 8002b76:	9000      	str	r0, [sp, #0]
 8002b78:	2300      	movs	r3, #0
 8002b7a:	2216      	movs	r2, #22
 8002b7c:	7b28      	ldrb	r0, [r5, #12]
 8002b7e:	07c1      	lsls	r1, r0, #31
 8002b80:	0fc9      	lsrs	r1, r1, #31
 8002b82:	2009      	movs	r0, #9
 8002b84:	9f01      	ldr	r7, [sp, #4]
 8002b86:	47b8      	blx	r7
 8002b88:	2116      	movs	r1, #22
 8002b8a:	e013      	b.n	8002bb4 <__iar_annotation$$branch+0x664>
 8002b8c:	2100      	movs	r1, #0
 8002b8e:	8331      	strh	r1, [r6, #24]
 8002b90:	2114      	movs	r1, #20
 8002b92:	466a      	mov	r2, sp
 8002b94:	7311      	strb	r1, [r2, #12]
 8002b96:	2103      	movs	r1, #3
 8002b98:	7131      	strb	r1, [r6, #4]
 8002b9a:	2800      	cmp	r0, #0
 8002b9c:	d009      	beq.n	8002bb2 <__iar_annotation$$branch+0x662>
 8002b9e:	2000      	movs	r0, #0
 8002ba0:	9000      	str	r0, [sp, #0]
 8002ba2:	2300      	movs	r3, #0
 8002ba4:	2255      	movs	r2, #85	; 0x55
 8002ba6:	7b28      	ldrb	r0, [r5, #12]
 8002ba8:	07c1      	lsls	r1, r0, #31
 8002baa:	0fc9      	lsrs	r1, r1, #31
 8002bac:	2009      	movs	r0, #9
 8002bae:	9f01      	ldr	r7, [sp, #4]
 8002bb0:	47b8      	blx	r7
 8002bb2:	2155      	movs	r1, #85	; 0x55
 8002bb4:	7b2a      	ldrb	r2, [r5, #12]
 8002bb6:	07d0      	lsls	r0, r2, #31
 8002bb8:	0fc0      	lsrs	r0, r0, #31
 8002bba:	68aa      	ldr	r2, [r5, #8]
 8002bbc:	68d2      	ldr	r2, [r2, #12]
 8002bbe:	4790      	blx	r2
 8002bc0:	8b30      	ldrh	r0, [r6, #24]
 8002bc2:	2180      	movs	r1, #128	; 0x80
 8002bc4:	0209      	lsls	r1, r1, #8
 8002bc6:	4288      	cmp	r0, r1
 8002bc8:	d155      	bne.n	8002c76 <__iar_annotation$$branch+0x726>
 8002bca:	2400      	movs	r4, #0
 8002bcc:	8334      	strh	r4, [r6, #24]
 8002bce:	e176      	b.n	8002ebe <__iar_annotation$$branch+0x96e>
 8002bd0:	2911      	cmp	r1, #17
 8002bd2:	d112      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002bd4:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002bd6:	0bc0      	lsrs	r0, r0, #15
 8002bd8:	d10f      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002bda:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002bdc:	0b00      	lsrs	r0, r0, #12
 8002bde:	0740      	lsls	r0, r0, #29
 8002be0:	d10b      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002be2:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002be4:	06c0      	lsls	r0, r0, #27
 8002be6:	0ec0      	lsrs	r0, r0, #27
 8002be8:	2806      	cmp	r0, #6
 8002bea:	d106      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002bec:	2000      	movs	r0, #0
 8002bee:	82b0      	strh	r0, [r6, #20]
 8002bf0:	205a      	movs	r0, #90	; 0x5a
 8002bf2:	7130      	strb	r0, [r6, #4]
 8002bf4:	2014      	movs	r0, #20
 8002bf6:	4669      	mov	r1, sp
 8002bf8:	7308      	strb	r0, [r1, #12]
 8002bfa:	8ab0      	ldrh	r0, [r6, #20]
 8002bfc:	03a1      	lsls	r1, r4, #14
 8002bfe:	4288      	cmp	r0, r1
 8002c00:	d139      	bne.n	8002c76 <__iar_annotation$$branch+0x726>
 8002c02:	68a8      	ldr	r0, [r5, #8]
 8002c04:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c06:	2b00      	cmp	r3, #0
 8002c08:	d005      	beq.n	8002c16 <__iar_annotation$$branch+0x6c6>
 8002c0a:	220f      	movs	r2, #15
 8002c0c:	2100      	movs	r1, #0
 8002c0e:	7b2f      	ldrb	r7, [r5, #12]
 8002c10:	07f8      	lsls	r0, r7, #31
 8002c12:	0fc0      	lsrs	r0, r0, #31
 8002c14:	4798      	blx	r3
 8002c16:	2000      	movs	r0, #0
 8002c18:	82b0      	strh	r0, [r6, #20]
 8002c1a:	200f      	movs	r0, #15
 8002c1c:	e175      	b.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002c1e:	68a8      	ldr	r0, [r5, #8]
 8002c20:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c22:	2701      	movs	r7, #1
 8002c24:	2b00      	cmp	r3, #0
 8002c26:	d00f      	beq.n	8002c48 <__iar_annotation$$branch+0x6f8>
 8002c28:	220a      	movs	r2, #10
 8002c2a:	68e9      	ldr	r1, [r5, #12]
 8002c2c:	2001      	movs	r0, #1
 8002c2e:	4008      	ands	r0, r1
 8002c30:	2100      	movs	r1, #0
 8002c32:	4798      	blx	r3
 8002c34:	68a8      	ldr	r0, [r5, #8]
 8002c36:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c38:	2b00      	cmp	r3, #0
 8002c3a:	d005      	beq.n	8002c48 <__iar_annotation$$branch+0x6f8>
 8002c3c:	220b      	movs	r2, #11
 8002c3e:	68e9      	ldr	r1, [r5, #12]
 8002c40:	2001      	movs	r0, #1
 8002c42:	4008      	ands	r0, r1
 8002c44:	2101      	movs	r1, #1
 8002c46:	4798      	blx	r3
 8002c48:	2000      	movs	r0, #0
 8002c4a:	9000      	str	r0, [sp, #0]
 8002c4c:	235b      	movs	r3, #91	; 0x5b
 8002c4e:	2206      	movs	r2, #6
 8002c50:	2100      	movs	r1, #0
 8002c52:	0028      	movs	r0, r5
 8002c54:	f000 fd8d 	bl	8003772 <PE_Send_CtrlMessage>
 8002c58:	2800      	cmp	r0, #0
 8002c5a:	d10f      	bne.n	8002c7c <__iar_annotation$$branch+0x72c>
 8002c5c:	68a8      	ldr	r0, [r5, #8]
 8002c5e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c60:	2b00      	cmp	r3, #0
 8002c62:	d005      	beq.n	8002c70 <__iar_annotation$$branch+0x720>
 8002c64:	220c      	movs	r2, #12
 8002c66:	2100      	movs	r1, #0
 8002c68:	68e8      	ldr	r0, [r5, #12]
 8002c6a:	4007      	ands	r7, r0
 8002c6c:	0038      	movs	r0, r7
 8002c6e:	4798      	blx	r3
 8002c70:	4801      	ldr	r0, [pc, #4]	; (8002c78 <__iar_annotation$$branch+0x728>)
 8002c72:	8430      	strh	r0, [r6, #32]
 8002c74:	2414      	movs	r4, #20
 8002c76:	e149      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002c78:	00008014 	.word	0x00008014
 8002c7c:	68a8      	ldr	r0, [r5, #8]
 8002c7e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c80:	2b00      	cmp	r3, #0
 8002c82:	d0f8      	beq.n	8002c76 <__iar_annotation$$branch+0x726>
 8002c84:	220f      	movs	r2, #15
 8002c86:	2100      	movs	r1, #0
 8002c88:	7b2f      	ldrb	r7, [r5, #12]
 8002c8a:	07f8      	lsls	r0, r7, #31
 8002c8c:	0fc0      	lsrs	r0, r0, #31
 8002c8e:	4798      	blx	r3
 8002c90:	e13c      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002c92:	8c30      	ldrh	r0, [r6, #32]
 8002c94:	03a1      	lsls	r1, r4, #14
 8002c96:	4288      	cmp	r0, r1
 8002c98:	d1fa      	bne.n	8002c90 <__iar_annotation$$branch+0x740>
 8002c9a:	2000      	movs	r0, #0
 8002c9c:	8430      	strh	r0, [r6, #32]
 8002c9e:	2101      	movs	r1, #1
 8002ca0:	0028      	movs	r0, r5
 8002ca2:	f000 fe7b 	bl	800399c <PE_ChangePowerRole>
 8002ca6:	0028      	movs	r0, r5
 8002ca8:	f001 fb22 	bl	80042f0 <PE_ResetDuringSwap>
 8002cac:	68a8      	ldr	r0, [r5, #8]
 8002cae:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002cb0:	2b00      	cmp	r3, #0
 8002cb2:	d005      	beq.n	8002cc0 <__iar_annotation$$branch+0x770>
 8002cb4:	220e      	movs	r2, #14
 8002cb6:	2101      	movs	r1, #1
 8002cb8:	7b2f      	ldrb	r7, [r5, #12]
 8002cba:	07f8      	lsls	r0, r7, #31
 8002cbc:	0fc0      	lsrs	r0, r0, #31
 8002cbe:	4798      	blx	r3
 8002cc0:	4808      	ldr	r0, [pc, #32]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002cc2:	7800      	ldrb	r0, [r0, #0]
 8002cc4:	0780      	lsls	r0, r0, #30
 8002cc6:	d50a      	bpl.n	8002cde <__iar_annotation$$branch+0x78e>
 8002cc8:	2000      	movs	r0, #0
 8002cca:	9000      	str	r0, [sp, #0]
 8002ccc:	2300      	movs	r3, #0
 8002cce:	2215      	movs	r2, #21
 8002cd0:	7b28      	ldrb	r0, [r5, #12]
 8002cd2:	07c1      	lsls	r1, r0, #31
 8002cd4:	0fc9      	lsrs	r1, r1, #31
 8002cd6:	2009      	movs	r0, #9
 8002cd8:	4f02      	ldr	r7, [pc, #8]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002cda:	68ff      	ldr	r7, [r7, #12]
 8002cdc:	47b8      	blx	r7
 8002cde:	2115      	movs	r1, #21
 8002ce0:	e0b8      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 8002ce2:	bf00      	nop
 8002ce4:	200019ac 	.word	0x200019ac
 8002ce8:	ab05      	add	r3, sp, #20
 8002cea:	aa08      	add	r2, sp, #32
 8002cec:	2100      	movs	r1, #0
 8002cee:	7b2f      	ldrb	r7, [r5, #12]
 8002cf0:	07f8      	lsls	r0, r7, #31
 8002cf2:	0fc0      	lsrs	r0, r0, #31
 8002cf4:	68af      	ldr	r7, [r5, #8]
 8002cf6:	69bf      	ldr	r7, [r7, #24]
 8002cf8:	47b8      	blx	r7
 8002cfa:	2000      	movs	r0, #0
 8002cfc:	9002      	str	r0, [sp, #8]
 8002cfe:	2003      	movs	r0, #3
 8002d00:	9001      	str	r0, [sp, #4]
 8002d02:	9805      	ldr	r0, [sp, #20]
 8002d04:	0880      	lsrs	r0, r0, #2
 8002d06:	9000      	str	r0, [sp, #0]
 8002d08:	ab08      	add	r3, sp, #32
 8002d0a:	2201      	movs	r2, #1
 8002d0c:	2100      	movs	r1, #0
 8002d0e:	0028      	movs	r0, r5
 8002d10:	f000 fd76 	bl	8003800 <PE_Send_DataMessage>
 8002d14:	e0fa      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002d16:	9402      	str	r4, [sp, #8]
 8002d18:	2003      	movs	r0, #3
 8002d1a:	9001      	str	r0, [sp, #4]
 8002d1c:	2001      	movs	r0, #1
 8002d1e:	9000      	str	r0, [sp, #0]
 8002d20:	20e3      	movs	r0, #227	; 0xe3
 8002d22:	0080      	lsls	r0, r0, #2
 8002d24:	182b      	adds	r3, r5, r0
 8002d26:	2206      	movs	r2, #6
 8002d28:	2100      	movs	r1, #0
 8002d2a:	0028      	movs	r0, r5
 8002d2c:	f000 fd68 	bl	8003800 <PE_Send_DataMessage>
 8002d30:	e0ec      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002d32:	9400      	str	r4, [sp, #0]
 8002d34:	2366      	movs	r3, #102	; 0x66
 8002d36:	2214      	movs	r2, #20
 8002d38:	2100      	movs	r1, #0
 8002d3a:	0028      	movs	r0, r5
 8002d3c:	f000 fd19 	bl	8003772 <PE_Send_CtrlMessage>
 8002d40:	2800      	cmp	r0, #0
 8002d42:	d1f5      	bne.n	8002d30 <__iar_annotation$$branch+0x7e0>
 8002d44:	8337      	strh	r7, [r6, #24]
 8002d46:	241a      	movs	r4, #26
 8002d48:	4fa8      	ldr	r7, [pc, #672]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002d4a:	7838      	ldrb	r0, [r7, #0]
 8002d4c:	0780      	lsls	r0, r0, #30
 8002d4e:	d509      	bpl.n	8002d64 <__iar_annotation$$branch+0x814>
 8002d50:	2000      	movs	r0, #0
 8002d52:	9000      	str	r0, [sp, #0]
 8002d54:	2300      	movs	r3, #0
 8002d56:	2247      	movs	r2, #71	; 0x47
 8002d58:	7b28      	ldrb	r0, [r5, #12]
 8002d5a:	07c1      	lsls	r1, r0, #31
 8002d5c:	0fc9      	lsrs	r1, r1, #31
 8002d5e:	2009      	movs	r0, #9
 8002d60:	68ff      	ldr	r7, [r7, #12]
 8002d62:	47b8      	blx	r7
 8002d64:	2147      	movs	r1, #71	; 0x47
 8002d66:	7b2a      	ldrb	r2, [r5, #12]
 8002d68:	07d0      	lsls	r0, r2, #31
 8002d6a:	0fc0      	lsrs	r0, r0, #31
 8002d6c:	68aa      	ldr	r2, [r5, #8]
 8002d6e:	68d2      	ldr	r2, [r2, #12]
 8002d70:	4790      	blx	r2
 8002d72:	200b      	movs	r0, #11
 8002d74:	82e8      	strh	r0, [r5, #22]
 8002d76:	e0c9      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002d78:	2911      	cmp	r1, #17
 8002d7a:	d107      	bne.n	8002d8c <__iar_annotation$$branch+0x83c>
 8002d7c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002d7e:	0bc0      	lsrs	r0, r0, #15
 8002d80:	d004      	beq.n	8002d8c <__iar_annotation$$branch+0x83c>
 8002d82:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002d84:	0b00      	lsrs	r0, r0, #12
 8002d86:	0740      	lsls	r0, r0, #29
 8002d88:	d000      	beq.n	8002d8c <__iar_annotation$$branch+0x83c>
 8002d8a:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002d8c:	8b30      	ldrh	r0, [r6, #24]
 8002d8e:	03a1      	lsls	r1, r4, #14
 8002d90:	4288      	cmp	r0, r1
 8002d92:	d1f0      	bne.n	8002d76 <__iar_annotation$$branch+0x826>
 8002d94:	2000      	movs	r0, #0
 8002d96:	8330      	strh	r0, [r6, #24]
 8002d98:	2003      	movs	r0, #3
 8002d9a:	7130      	strb	r0, [r6, #4]
 8002d9c:	e07a      	b.n	8002e94 <__iar_annotation$$branch+0x944>
 8002d9e:	9400      	str	r4, [sp, #0]
 8002da0:	2339      	movs	r3, #57	; 0x39
 8002da2:	20e5      	movs	r0, #229	; 0xe5
 8002da4:	0080      	lsls	r0, r0, #2
 8002da6:	5c2a      	ldrb	r2, [r5, r0]
 8002da8:	2100      	movs	r1, #0
 8002daa:	0028      	movs	r0, r5
 8002dac:	f000 fce1 	bl	8003772 <PE_Send_CtrlMessage>
 8002db0:	2800      	cmp	r0, #0
 8002db2:	d139      	bne.n	8002e28 <__iar_annotation$$branch+0x8d8>
 8002db4:	20e5      	movs	r0, #229	; 0xe5
 8002db6:	0080      	lsls	r0, r0, #2
 8002db8:	1828      	adds	r0, r5, r0
 8002dba:	8840      	ldrh	r0, [r0, #2]
 8002dbc:	82e8      	strh	r0, [r5, #22]
 8002dbe:	6868      	ldr	r0, [r5, #4]
 8002dc0:	7841      	ldrb	r1, [r0, #1]
 8002dc2:	228f      	movs	r2, #143	; 0x8f
 8002dc4:	400a      	ands	r2, r1
 8002dc6:	2130      	movs	r1, #48	; 0x30
 8002dc8:	4311      	orrs	r1, r2
 8002dca:	7041      	strb	r1, [r0, #1]
 8002dcc:	4887      	ldr	r0, [pc, #540]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002dce:	7800      	ldrb	r0, [r0, #0]
 8002dd0:	0780      	lsls	r0, r0, #30
 8002dd2:	d50a      	bpl.n	8002dea <__iar_annotation$$branch+0x89a>
 8002dd4:	2000      	movs	r0, #0
 8002dd6:	9000      	str	r0, [sp, #0]
 8002dd8:	2300      	movs	r3, #0
 8002dda:	2256      	movs	r2, #86	; 0x56
 8002ddc:	7b28      	ldrb	r0, [r5, #12]
 8002dde:	07c1      	lsls	r1, r0, #31
 8002de0:	0fc9      	lsrs	r1, r1, #31
 8002de2:	2009      	movs	r0, #9
 8002de4:	4c81      	ldr	r4, [pc, #516]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002de6:	68e4      	ldr	r4, [r4, #12]
 8002de8:	47a0      	blx	r4
 8002dea:	2156      	movs	r1, #86	; 0x56
 8002dec:	7b2a      	ldrb	r2, [r5, #12]
 8002dee:	07d0      	lsls	r0, r2, #31
 8002df0:	0fc0      	lsrs	r0, r0, #31
 8002df2:	68aa      	ldr	r2, [r5, #8]
 8002df4:	68d2      	ldr	r2, [r2, #12]
 8002df6:	4790      	blx	r2
 8002df8:	4c7c      	ldr	r4, [pc, #496]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002dfa:	7820      	ldrb	r0, [r4, #0]
 8002dfc:	0780      	lsls	r0, r0, #30
 8002dfe:	d509      	bpl.n	8002e14 <__iar_annotation$$branch+0x8c4>
 8002e00:	2000      	movs	r0, #0
 8002e02:	9000      	str	r0, [sp, #0]
 8002e04:	2300      	movs	r3, #0
 8002e06:	2241      	movs	r2, #65	; 0x41
 8002e08:	7b28      	ldrb	r0, [r5, #12]
 8002e0a:	07c1      	lsls	r1, r0, #31
 8002e0c:	0fc9      	lsrs	r1, r1, #31
 8002e0e:	2009      	movs	r0, #9
 8002e10:	68e4      	ldr	r4, [r4, #12]
 8002e12:	47a0      	blx	r4
 8002e14:	2141      	movs	r1, #65	; 0x41
 8002e16:	7b2a      	ldrb	r2, [r5, #12]
 8002e18:	07d0      	lsls	r0, r2, #31
 8002e1a:	0fc0      	lsrs	r0, r0, #31
 8002e1c:	68aa      	ldr	r2, [r5, #8]
 8002e1e:	68d2      	ldr	r2, [r2, #12]
 8002e20:	4790      	blx	r2
 8002e22:	8337      	strh	r7, [r6, #24]
 8002e24:	241a      	movs	r4, #26
 8002e26:	e071      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e28:	6868      	ldr	r0, [r5, #4]
 8002e2a:	7841      	ldrb	r1, [r0, #1]
 8002e2c:	228f      	movs	r2, #143	; 0x8f
 8002e2e:	400a      	ands	r2, r1
 8002e30:	2130      	movs	r1, #48	; 0x30
 8002e32:	4311      	orrs	r1, r2
 8002e34:	7041      	strb	r1, [r0, #1]
 8002e36:	4f6d      	ldr	r7, [pc, #436]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002e38:	7838      	ldrb	r0, [r7, #0]
 8002e3a:	0780      	lsls	r0, r0, #30
 8002e3c:	d509      	bpl.n	8002e52 <__iar_annotation$$branch+0x902>
 8002e3e:	2000      	movs	r0, #0
 8002e40:	9000      	str	r0, [sp, #0]
 8002e42:	2300      	movs	r3, #0
 8002e44:	2256      	movs	r2, #86	; 0x56
 8002e46:	7b28      	ldrb	r0, [r5, #12]
 8002e48:	07c1      	lsls	r1, r0, #31
 8002e4a:	0fc9      	lsrs	r1, r1, #31
 8002e4c:	2009      	movs	r0, #9
 8002e4e:	68ff      	ldr	r7, [r7, #12]
 8002e50:	47b8      	blx	r7
 8002e52:	2156      	movs	r1, #86	; 0x56
 8002e54:	7b2a      	ldrb	r2, [r5, #12]
 8002e56:	07d0      	lsls	r0, r2, #31
 8002e58:	0fc0      	lsrs	r0, r0, #31
 8002e5a:	68aa      	ldr	r2, [r5, #8]
 8002e5c:	68d2      	ldr	r2, [r2, #12]
 8002e5e:	4790      	blx	r2
 8002e60:	e054      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e62:	8b30      	ldrh	r0, [r6, #24]
 8002e64:	03a2      	lsls	r2, r4, #14
 8002e66:	4290      	cmp	r0, r2
 8002e68:	d10a      	bne.n	8002e80 <__iar_annotation$$branch+0x930>
 8002e6a:	2000      	movs	r0, #0
 8002e6c:	8330      	strh	r0, [r6, #24]
 8002e6e:	2103      	movs	r1, #3
 8002e70:	22e5      	movs	r2, #229	; 0xe5
 8002e72:	0092      	lsls	r2, r2, #2
 8002e74:	5caa      	ldrb	r2, [r5, r2]
 8002e76:	2a11      	cmp	r2, #17
 8002e78:	7131      	strb	r1, [r6, #4]
 8002e7a:	d147      	bne.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e7c:	2400      	movs	r4, #0
 8002e7e:	e045      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e80:	2914      	cmp	r1, #20
 8002e82:	d043      	beq.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e84:	2000      	movs	r0, #0
 8002e86:	8330      	strh	r0, [r6, #24]
 8002e88:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002e8a:	0bc0      	lsrs	r0, r0, #15
 8002e8c:	d006      	beq.n	8002e9c <__iar_annotation$$branch+0x94c>
 8002e8e:	0028      	movs	r0, r5
 8002e90:	f001 f842 	bl	8003f18 <PE_Check_ExtendedMessage>
 8002e94:	2014      	movs	r0, #20
 8002e96:	4669      	mov	r1, sp
 8002e98:	7308      	strb	r0, [r1, #12]
 8002e9a:	e037      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e9c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002e9e:	0bc0      	lsrs	r0, r0, #15
 8002ea0:	d10b      	bne.n	8002eba <__iar_annotation$$branch+0x96a>
 8002ea2:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002ea4:	0b00      	lsrs	r0, r0, #12
 8002ea6:	0740      	lsls	r0, r0, #29
 8002ea8:	d107      	bne.n	8002eba <__iar_annotation$$branch+0x96a>
 8002eaa:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002eac:	06c0      	lsls	r0, r0, #27
 8002eae:	0ec0      	lsrs	r0, r0, #27
 8002eb0:	2810      	cmp	r0, #16
 8002eb2:	d102      	bne.n	8002eba <__iar_annotation$$branch+0x96a>
 8002eb4:	2014      	movs	r0, #20
 8002eb6:	4669      	mov	r1, sp
 8002eb8:	7308      	strb	r0, [r1, #12]
 8002eba:	2000      	movs	r0, #0
 8002ebc:	8330      	strh	r0, [r6, #24]
 8002ebe:	2003      	movs	r0, #3
 8002ec0:	e023      	b.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002ec2:	0028      	movs	r0, r5
 8002ec4:	f001 fb51 	bl	800456a <PE_SubStateMachine_ExtendedMessages>
 8002ec8:	e003      	b.n	8002ed2 <__iar_annotation$$branch+0x982>
 8002eca:	a903      	add	r1, sp, #12
 8002ecc:	0028      	movs	r0, r5
 8002ece:	f001 fc63 	bl	8004798 <PE_SubStateMachine_Generic>
 8002ed2:	0004      	movs	r4, r0
 8002ed4:	e01a      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002ed6:	a903      	add	r1, sp, #12
 8002ed8:	0028      	movs	r0, r5
 8002eda:	f001 fdcf 	bl	8004a7c <PE_SubStateMachine_VconnSwap>
 8002ede:	0004      	movs	r4, r0
 8002ee0:	6868      	ldr	r0, [r5, #4]
 8002ee2:	6800      	ldr	r0, [r0, #0]
 8002ee4:	0340      	lsls	r0, r0, #13
 8002ee6:	0fc1      	lsrs	r1, r0, #31
 8002ee8:	4668      	mov	r0, sp
 8002eea:	7b40      	ldrb	r0, [r0, #13]
 8002eec:	f002 f855 	bl	8004f9a <USBPD_PRL_CableCapable>
 8002ef0:	e00c      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002ef2:	2106      	movs	r1, #6
 8002ef4:	4668      	mov	r0, sp
 8002ef6:	7b40      	ldrb	r0, [r0, #13]
 8002ef8:	f006 fcb0 	bl	800985c <USBPD_PHY_ResetRequest>
 8002efc:	6868      	ldr	r0, [r5, #4]
 8002efe:	7840      	ldrb	r0, [r0, #1]
 8002f00:	0640      	lsls	r0, r0, #25
 8002f02:	0f40      	lsrs	r0, r0, #29
 8002f04:	2803      	cmp	r0, #3
 8002f06:	d000      	beq.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002f08:	2043      	movs	r0, #67	; 0x43
 8002f0a:	7130      	strb	r0, [r6, #4]
 8002f0c:	4837      	ldr	r0, [pc, #220]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002f0e:	68c7      	ldr	r7, [r0, #12]
 8002f10:	2f00      	cmp	r7, #0
 8002f12:	d00f      	beq.n	8002f34 <__iar_annotation$$branch+0x9e4>
 8002f14:	7800      	ldrb	r0, [r0, #0]
 8002f16:	07c0      	lsls	r0, r0, #31
 8002f18:	d50c      	bpl.n	8002f34 <__iar_annotation$$branch+0x9e4>
 8002f1a:	7932      	ldrb	r2, [r6, #4]
 8002f1c:	7970      	ldrb	r0, [r6, #5]
 8002f1e:	4290      	cmp	r0, r2
 8002f20:	d008      	beq.n	8002f34 <__iar_annotation$$branch+0x9e4>
 8002f22:	7172      	strb	r2, [r6, #5]
 8002f24:	2000      	movs	r0, #0
 8002f26:	9000      	str	r0, [sp, #0]
 8002f28:	2300      	movs	r3, #0
 8002f2a:	7b28      	ldrb	r0, [r5, #12]
 8002f2c:	07c1      	lsls	r1, r0, #31
 8002f2e:	0fc9      	lsrs	r1, r1, #31
 8002f30:	2004      	movs	r0, #4
 8002f32:	47b8      	blx	r7
 8002f34:	4668      	mov	r0, sp
 8002f36:	7b00      	ldrb	r0, [r0, #12]
 8002f38:	2814      	cmp	r0, #20
 8002f3a:	d01d      	beq.n	8002f78 <__iar_annotation$$branch+0xa28>
 8002f3c:	0028      	movs	r0, r5
 8002f3e:	f000 fd69 	bl	8003a14 <PE_Check_AMSConflict>
 8002f42:	2815      	cmp	r0, #21
 8002f44:	d102      	bne.n	8002f4c <__iar_annotation$$branch+0x9fc>
 8002f46:	2014      	movs	r0, #20
 8002f48:	4669      	mov	r1, sp
 8002f4a:	7308      	strb	r0, [r1, #12]
 8002f4c:	4827      	ldr	r0, [pc, #156]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002f4e:	68c4      	ldr	r4, [r0, #12]
 8002f50:	2c00      	cmp	r4, #0
 8002f52:	d00f      	beq.n	8002f74 <__iar_annotation$$branch+0xa24>
 8002f54:	7800      	ldrb	r0, [r0, #0]
 8002f56:	07c0      	lsls	r0, r0, #31
 8002f58:	d50c      	bpl.n	8002f74 <__iar_annotation$$branch+0xa24>
 8002f5a:	7932      	ldrb	r2, [r6, #4]
 8002f5c:	7970      	ldrb	r0, [r6, #5]
 8002f5e:	4290      	cmp	r0, r2
 8002f60:	d008      	beq.n	8002f74 <__iar_annotation$$branch+0xa24>
 8002f62:	7172      	strb	r2, [r6, #5]
 8002f64:	2000      	movs	r0, #0
 8002f66:	9000      	str	r0, [sp, #0]
 8002f68:	2300      	movs	r3, #0
 8002f6a:	7b28      	ldrb	r0, [r5, #12]
 8002f6c:	07c1      	lsls	r1, r0, #31
 8002f6e:	0fc9      	lsrs	r1, r1, #31
 8002f70:	2004      	movs	r0, #4
 8002f72:	47a0      	blx	r4
 8002f74:	2400      	movs	r4, #0
 8002f76:	e012      	b.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f78:	7930      	ldrb	r0, [r6, #4]
 8002f7a:	2803      	cmp	r0, #3
 8002f7c:	d10f      	bne.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f7e:	200a      	movs	r0, #10
 8002f80:	5e30      	ldrsh	r0, [r6, r0]
 8002f82:	2800      	cmp	r0, #0
 8002f84:	d00b      	beq.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f86:	2116      	movs	r1, #22
 8002f88:	5e69      	ldrsh	r1, [r5, r1]
 8002f8a:	2900      	cmp	r1, #0
 8002f8c:	d107      	bne.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f8e:	7a31      	ldrb	r1, [r6, #8]
 8002f90:	7131      	strb	r1, [r6, #4]
 8002f92:	7a71      	ldrb	r1, [r6, #9]
 8002f94:	71f1      	strb	r1, [r6, #7]
 8002f96:	82e8      	strh	r0, [r5, #22]
 8002f98:	2000      	movs	r0, #0
 8002f9a:	8170      	strh	r0, [r6, #10]
 8002f9c:	2401      	movs	r4, #1
 8002f9e:	9807      	ldr	r0, [sp, #28]
 8002fa0:	2800      	cmp	r0, #0
 8002fa2:	d01d      	beq.n	8002fe0 <__iar_annotation$$branch+0xa90>
 8002fa4:	4811      	ldr	r0, [pc, #68]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002fa6:	6901      	ldr	r1, [r0, #16]
 8002fa8:	4aa9      	ldr	r2, [pc, #676]	; (8003250 <.text_23>)
 8002faa:	4291      	cmp	r1, r2
 8002fac:	d018      	beq.n	8002fe0 <__iar_annotation$$branch+0xa90>
 8002fae:	2101      	movs	r1, #1
 8002fb0:	1d02      	adds	r2, r0, #4
 8002fb2:	68eb      	ldr	r3, [r5, #12]
 8002fb4:	400b      	ands	r3, r1
 8002fb6:	009b      	lsls	r3, r3, #2
 8002fb8:	58d2      	ldr	r2, [r2, r3]
 8002fba:	68d7      	ldr	r7, [r2, #12]
 8002fbc:	0b3e      	lsrs	r6, r7, #12
 8002fbe:	1c76      	adds	r6, r6, #1
 8002fc0:	4ba4      	ldr	r3, [pc, #656]	; (8003254 <.text_24>)
 8002fc2:	401f      	ands	r7, r3
 8002fc4:	0336      	lsls	r6, r6, #12
 8002fc6:	433e      	orrs	r6, r7
 8002fc8:	60d6      	str	r6, [r2, #12]
 8002fca:	1d00      	adds	r0, r0, #4
 8002fcc:	68ea      	ldr	r2, [r5, #12]
 8002fce:	4011      	ands	r1, r2
 8002fd0:	0089      	lsls	r1, r1, #2
 8002fd2:	5840      	ldr	r0, [r0, r1]
 8002fd4:	68c1      	ldr	r1, [r0, #12]
 8002fd6:	0b0a      	lsrs	r2, r1, #12
 8002fd8:	2a08      	cmp	r2, #8
 8002fda:	db01      	blt.n	8002fe0 <__iar_annotation$$branch+0xa90>
 8002fdc:	400b      	ands	r3, r1
 8002fde:	60c3      	str	r3, [r0, #12]
 8002fe0:	2c00      	cmp	r4, #0
 8002fe2:	d00a      	beq.n	8002ffa <__iar_annotation$$branch+0xaaa>
 8002fe4:	0020      	movs	r0, r4
 8002fe6:	b00f      	add	sp, #60	; 0x3c
 8002fe8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002fea:	bf00      	nop
 8002fec:	200019ac 	.word	0x200019ac
 8002ff0:	4668      	mov	r0, sp
 8002ff2:	7345      	strb	r5, [r0, #13]
 8002ff4:	9d06      	ldr	r5, [sp, #24]
 8002ff6:	9407      	str	r4, [sp, #28]
 8002ff8:	9606      	str	r6, [sp, #24]
 8002ffa:	2402      	movs	r4, #2
 8002ffc:	20d5      	movs	r0, #213	; 0xd5
 8002ffe:	0080      	lsls	r0, r0, #2
 8003000:	182e      	adds	r6, r5, r0
 8003002:	7832      	ldrb	r2, [r6, #0]
 8003004:	2a0f      	cmp	r2, #15
 8003006:	d115      	bne.n	8003034 <__iar_annotation$$branch+0xae4>
 8003008:	7132      	strb	r2, [r6, #4]
 800300a:	2000      	movs	r0, #0
 800300c:	7030      	strb	r0, [r6, #0]
 800300e:	4892      	ldr	r0, [pc, #584]	; (8003258 <.text_25>)
 8003010:	68c7      	ldr	r7, [r0, #12]
 8003012:	2f00      	cmp	r7, #0
 8003014:	d00e      	beq.n	8003034 <__iar_annotation$$branch+0xae4>
 8003016:	7800      	ldrb	r0, [r0, #0]
 8003018:	07c0      	lsls	r0, r0, #31
 800301a:	d50b      	bpl.n	8003034 <__iar_annotation$$branch+0xae4>
 800301c:	7970      	ldrb	r0, [r6, #5]
 800301e:	4290      	cmp	r0, r2
 8003020:	d008      	beq.n	8003034 <__iar_annotation$$branch+0xae4>
 8003022:	7172      	strb	r2, [r6, #5]
 8003024:	2000      	movs	r0, #0
 8003026:	9000      	str	r0, [sp, #0]
 8003028:	2300      	movs	r3, #0
 800302a:	7b28      	ldrb	r0, [r5, #12]
 800302c:	07c1      	lsls	r1, r0, #31
 800302e:	0fc9      	lsrs	r1, r1, #31
 8003030:	2004      	movs	r0, #4
 8003032:	47b8      	blx	r7
 8003034:	9806      	ldr	r0, [sp, #24]
 8003036:	2800      	cmp	r0, #0
 8003038:	d006      	beq.n	8003048 <__iar_annotation$$branch+0xaf8>
 800303a:	2107      	movs	r1, #7
 800303c:	f002 fe2a 	bl	8005c94 <__aeabi_idivmod>
 8003040:	2900      	cmp	r1, #0
 8003042:	d101      	bne.n	8003048 <__iar_annotation$$branch+0xaf8>
 8003044:	2001      	movs	r0, #1
 8003046:	9007      	str	r0, [sp, #28]
 8003048:	4983      	ldr	r1, [pc, #524]	; (8003258 <.text_25>)
 800304a:	7808      	ldrb	r0, [r1, #0]
 800304c:	4020      	ands	r0, r4
 800304e:	68c9      	ldr	r1, [r1, #12]
 8003050:	9101      	str	r1, [sp, #4]
 8003052:	4669      	mov	r1, sp
 8003054:	7b09      	ldrb	r1, [r1, #12]
 8003056:	4f81      	ldr	r7, [pc, #516]	; (800325c <.text_26>)
 8003058:	7932      	ldrb	r2, [r6, #4]
 800305a:	2a00      	cmp	r2, #0
 800305c:	d101      	bne.n	8003062 <__iar_annotation$$branch+0x4>

0800305e <__iar_annotation$$branch>:
 800305e:	f7fe fe4e 	bl	8001cfe <__iar_annotation$$branch+0x4>
 8003062:	1e52      	subs	r2, r2, #1
 8003064:	d046      	beq.n	80030f4 <__iar_annotation$$branch+0x2c>
 8003066:	1e92      	subs	r2, r2, #2
 8003068:	d101      	bne.n	800306e <__iar_annotation$$branch+0x4>

0800306a <__iar_annotation$$branch>:
 800306a:	f7ff fa41 	bl	80024f0 <__iar_annotation$$branch+0x26>
 800306e:	1e52      	subs	r2, r2, #1
 8003070:	d101      	bne.n	8003076 <__iar_annotation$$branch+0x4>

08003072 <__iar_annotation$$branch>:
 8003072:	f7ff fa54 	bl	800251e <__iar_annotation$$branch+0x54>
 8003076:	3a0b      	subs	r2, #11
 8003078:	d101      	bne.n	800307e <__iar_annotation$$branch+0x4>

0800307a <__iar_annotation$$branch>:
 800307a:	f7fe ffdb 	bl	8002034 <__iar_annotation$$branch+0x202>
 800307e:	1e52      	subs	r2, r2, #1
 8003080:	d101      	bne.n	8003086 <__iar_annotation$$branch+0x4>

08003082 <__iar_annotation$$branch>:
 8003082:	f7ff f894 	bl	80021ae <__iar_annotation$$branch+0x37c>
 8003086:	1e52      	subs	r2, r2, #1
 8003088:	d101      	bne.n	800308e <__iar_annotation$$branch+0x4>

0800308a <__iar_annotation$$branch>:
 800308a:	f7ff f8ab 	bl	80021e4 <__iar_annotation$$branch+0x3b2>
 800308e:	1fd2      	subs	r2, r2, #7
 8003090:	d101      	bne.n	8003096 <__iar_annotation$$branch+0x4>

08003092 <__iar_annotation$$branch>:
 8003092:	f7ff f996 	bl	80023c2 <__iar_annotation$$branch+0x4>
 8003096:	1e92      	subs	r2, r2, #2
 8003098:	d101      	bne.n	800309e <__iar_annotation$$branch+0x4>

0800309a <__iar_annotation$$branch>:
 800309a:	f7ff f91c 	bl	80022d6 <__iar_annotation$$branch+0x66>
 800309e:	1ed2      	subs	r2, r2, #3
 80030a0:	d101      	bne.n	80030a6 <__iar_annotation$$branch+0x4>

080030a2 <__iar_annotation$$branch>:
 80030a2:	f7ff f8e7 	bl	8002274 <__iar_annotation$$branch+0x4>
 80030a6:	1e52      	subs	r2, r2, #1
 80030a8:	d100      	bne.n	80030ac <__iar_annotation$$branch+0xa>
 80030aa:	e4c0      	b.n	8002a2e <__iar_annotation$$branch+0x4de>
 80030ac:	1f12      	subs	r2, r2, #4
 80030ae:	d101      	bne.n	80030b4 <__iar_annotation$$branch+0x4>

080030b0 <__iar_annotation$$branch>:
 80030b0:	f7ff fb88 	bl	80027c4 <__iar_annotation$$branch+0x274>
 80030b4:	1f52      	subs	r2, r2, #5
 80030b6:	d101      	bne.n	80030bc <__iar_annotation$$branch+0x4>

080030b8 <__iar_annotation$$branch>:
 80030b8:	f7ff f93f 	bl	800233a <__iar_annotation$$branch+0x4>
 80030bc:	1e92      	subs	r2, r2, #2
 80030be:	d101      	bne.n	80030c4 <__iar_annotation$$branch+0x4>

080030c0 <__iar_annotation$$branch>:
 80030c0:	f7ff f927 	bl	8002312 <__iar_annotation$$branch+0xa2>
 80030c4:	1e52      	subs	r2, r2, #1
 80030c6:	d101      	bne.n	80030cc <__iar_annotation$$branch+0x4>

080030c8 <__iar_annotation$$branch>:
 80030c8:	f7ff fa01 	bl	80024ce <__iar_annotation$$branch+0x4>
 80030cc:	1e52      	subs	r2, r2, #1
 80030ce:	d100      	bne.n	80030d2 <__iar_annotation$$branch+0xa>
 80030d0:	e621      	b.n	8002d16 <__iar_annotation$$branch+0x7c6>
 80030d2:	1e52      	subs	r2, r2, #1
 80030d4:	d00e      	beq.n	80030f4 <__iar_annotation$$branch+0x2c>
 80030d6:	1e92      	subs	r2, r2, #2
 80030d8:	d100      	bne.n	80030dc <__iar_annotation$$branch+0x14>
 80030da:	e660      	b.n	8002d9e <__iar_annotation$$branch+0x84e>
 80030dc:	1e52      	subs	r2, r2, #1
 80030de:	2a01      	cmp	r2, #1
 80030e0:	d908      	bls.n	80030f4 <__iar_annotation$$branch+0x2c>
 80030e2:	1e92      	subs	r2, r2, #2
 80030e4:	2a07      	cmp	r2, #7
 80030e6:	d800      	bhi.n	80030ea <__iar_annotation$$branch+0x22>
 80030e8:	e6eb      	b.n	8002ec2 <__iar_annotation$$branch+0x972>
 80030ea:	3a08      	subs	r2, #8
 80030ec:	d100      	bne.n	80030f0 <__iar_annotation$$branch+0x28>
 80030ee:	e6b8      	b.n	8002e62 <__iar_annotation$$branch+0x912>
 80030f0:	1e52      	subs	r2, r2, #1
 80030f2:	2a03      	cmp	r2, #3
 80030f4:	d800      	bhi.n	80030f8 <__iar_annotation$$branch+0x30>
 80030f6:	e6e8      	b.n	8002eca <__iar_annotation$$branch+0x97a>
 80030f8:	1f12      	subs	r2, r2, #4
 80030fa:	d101      	bne.n	8003100 <__iar_annotation$$branch+0x4>

080030fc <__iar_annotation$$branch>:
 80030fc:	f7fe fe08 	bl	8001d10 <__iar_annotation$$branch+0x4>
 8003100:	1e52      	subs	r2, r2, #1
 8003102:	d101      	bne.n	8003108 <__iar_annotation$$branch+0x4>

08003104 <__iar_annotation$$branch>:
 8003104:	f7fe ffd6 	bl	80020b4 <__iar_annotation$$branch+0x282>
 8003108:	1e52      	subs	r2, r2, #1
 800310a:	d101      	bne.n	8003110 <__iar_annotation$$branch+0x4>

0800310c <__iar_annotation$$branch>:
 800310c:	f7ff f82a 	bl	8002164 <__iar_annotation$$branch+0x332>
 8003110:	1ed2      	subs	r2, r2, #3
 8003112:	d101      	bne.n	8003118 <__iar_annotation$$branch+0x4>

08003114 <__iar_annotation$$branch>:
 8003114:	f7fe fe2a 	bl	8001d6c <__iar_annotation$$branch+0x4>
 8003118:	1e52      	subs	r2, r2, #1
 800311a:	d101      	bne.n	8003120 <__iar_annotation$$branch+0x4>

0800311c <__iar_annotation$$branch>:
 800311c:	f7fe fe66 	bl	8001dec <__iar_annotation$$branch+0x84>
 8003120:	1e52      	subs	r2, r2, #1
 8003122:	d101      	bne.n	8003128 <__iar_annotation$$branch+0x4>

08003124 <__iar_annotation$$branch>:
 8003124:	f7fe fe78 	bl	8001e18 <__iar_annotation$$branch+0xb0>
 8003128:	1e52      	subs	r2, r2, #1
 800312a:	d101      	bne.n	8003130 <__iar_annotation$$branch+0x4>

0800312c <__iar_annotation$$branch>:
 800312c:	f7fe fe83 	bl	8001e36 <__iar_annotation$$branch+0x4>
 8003130:	1e52      	subs	r2, r2, #1
 8003132:	d101      	bne.n	8003138 <__iar_annotation$$branch+0x4>

08003134 <__iar_annotation$$branch>:
 8003134:	f7fe ff28 	bl	8001f88 <__iar_annotation$$branch+0x156>
 8003138:	1e92      	subs	r2, r2, #2
 800313a:	d101      	bne.n	8003140 <__iar_annotation$$branch+0x4>

0800313c <__iar_annotation$$branch>:
 800313c:	f7ff f9d5 	bl	80024ea <__iar_annotation$$branch+0x20>
 8003140:	1ed2      	subs	r2, r2, #3
 8003142:	d100      	bne.n	8003146 <__iar_annotation$$branch+0xa>
 8003144:	e5d0      	b.n	8002ce8 <__iar_annotation$$branch+0x798>
 8003146:	1f12      	subs	r2, r2, #4
 8003148:	d101      	bne.n	800314e <__iar_annotation$$branch+0x4>

0800314a <__iar_annotation$$branch>:
 800314a:	f7ff f872 	bl	8002232 <__iar_annotation$$branch+0x400>
 800314e:	1e92      	subs	r2, r2, #2
 8003150:	d101      	bne.n	8003156 <__iar_annotation$$branch+0x4>

08003152 <__iar_annotation$$branch>:
 8003152:	f7ff fbb1 	bl	80028b8 <__iar_annotation$$branch+0x368>
 8003156:	1e52      	subs	r2, r2, #1
 8003158:	d101      	bne.n	800315e <__iar_annotation$$branch+0x4>

0800315a <__iar_annotation$$branch>:
 800315a:	f7ff fbda 	bl	8002912 <__iar_annotation$$branch+0x3c2>
 800315e:	1e52      	subs	r2, r2, #1
 8003160:	d100      	bne.n	8003164 <__iar_annotation$$branch+0xa>
 8003162:	e442      	b.n	80029ea <__iar_annotation$$branch+0x49a>
 8003164:	1f12      	subs	r2, r2, #4
 8003166:	d100      	bne.n	800316a <__iar_annotation$$branch+0x10>
 8003168:	e484      	b.n	8002a74 <__iar_annotation$$branch+0x524>
 800316a:	1e52      	subs	r2, r2, #1
 800316c:	d100      	bne.n	8003170 <__iar_annotation$$branch+0x16>
 800316e:	e52f      	b.n	8002bd0 <__iar_annotation$$branch+0x680>
 8003170:	1e52      	subs	r2, r2, #1
 8003172:	d100      	bne.n	8003176 <__iar_annotation$$branch+0x1c>
 8003174:	e553      	b.n	8002c1e <__iar_annotation$$branch+0x6ce>
 8003176:	1e52      	subs	r2, r2, #1
 8003178:	d100      	bne.n	800317c <__iar_annotation$$branch+0x22>
 800317a:	e58a      	b.n	8002c92 <__iar_annotation$$branch+0x742>
 800317c:	1e92      	subs	r2, r2, #2
 800317e:	d101      	bne.n	8003184 <__iar_annotation$$branch+0x4>

08003180 <__iar_annotation$$branch>:
 8003180:	f7ff f8e9 	bl	8002356 <__iar_annotation$$branch+0x20>
 8003184:	1ed2      	subs	r2, r2, #3
 8003186:	d101      	bne.n	800318c <__iar_annotation$$branch+0x4>

08003188 <__iar_annotation$$branch>:
 8003188:	f7ff f939 	bl	80023fe <__iar_annotation$$branch+0x40>
 800318c:	1e92      	subs	r2, r2, #2
 800318e:	2a01      	cmp	r2, #1
 8003190:	d9b0      	bls.n	80030f4 <__iar_annotation$$branch+0x2c>
 8003192:	1ed2      	subs	r2, r2, #3
 8003194:	d100      	bne.n	8003198 <__iar_annotation$$branch+0x10>
 8003196:	e5cc      	b.n	8002d32 <__iar_annotation$$branch+0x7e2>
 8003198:	1e52      	subs	r2, r2, #1
 800319a:	d100      	bne.n	800319e <__iar_annotation$$branch+0x16>
 800319c:	e5ec      	b.n	8002d78 <__iar_annotation$$branch+0x828>
 800319e:	3a0e      	subs	r2, #14
 80031a0:	d0a8      	beq.n	80030f4 <__iar_annotation$$branch+0x2c>
 80031a2:	3a1e      	subs	r2, #30
 80031a4:	d01e      	beq.n	80031e4 <__iar_annotation$$branch+0x14>
 80031a6:	1e52      	subs	r2, r2, #1
 80031a8:	d101      	bne.n	80031ae <__iar_annotation$$branch+0x4>

080031aa <__iar_annotation$$branch>:
 80031aa:	f7ff fa2e 	bl	800260a <__iar_annotation$$branch+0xba>
 80031ae:	1e52      	subs	r2, r2, #1
 80031b0:	d101      	bne.n	80031b6 <__iar_annotation$$branch+0x4>

080031b2 <__iar_annotation$$branch>:
 80031b2:	f7ff fa81 	bl	80026b8 <__iar_annotation$$branch+0x168>
 80031b6:	1e52      	subs	r2, r2, #1
 80031b8:	d101      	bne.n	80031be <__iar_annotation$$branch+0x4>

080031ba <__iar_annotation$$branch>:
 80031ba:	f7ff fa8a 	bl	80026d2 <__iar_annotation$$branch+0x182>
 80031be:	1ed2      	subs	r2, r2, #3
 80031c0:	d101      	bne.n	80031c6 <__iar_annotation$$branch+0x4>

080031c2 <__iar_annotation$$branch>:
 80031c2:	f7ff f8d7 	bl	8002374 <__iar_annotation$$branch+0x4>
 80031c6:	1e52      	subs	r2, r2, #1
 80031c8:	d100      	bne.n	80031cc <__iar_annotation$$branch+0xa>
 80031ca:	e692      	b.n	8002ef2 <__iar_annotation$$branch+0x9a2>
 80031cc:	1e92      	subs	r2, r2, #2
 80031ce:	d101      	bne.n	80031d4 <__iar_annotation$$branch+0x4>

080031d0 <__iar_annotation$$branch>:
 80031d0:	f7fe ffa5 	bl	800211e <__iar_annotation$$branch+0x2ec>
 80031d4:	1e52      	subs	r2, r2, #1
 80031d6:	2a08      	cmp	r2, #8
 80031d8:	d800      	bhi.n	80031dc <__iar_annotation$$branch+0xc>
 80031da:	e67c      	b.n	8002ed6 <__iar_annotation$$branch+0x986>
 80031dc:	3a09      	subs	r2, #9
 80031de:	d100      	bne.n	80031e2 <__iar_annotation$$branch+0x12>
 80031e0:	e66f      	b.n	8002ec2 <__iar_annotation$$branch+0x972>
 80031e2:	e693      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 80031e4:	68a8      	ldr	r0, [r5, #8]
 80031e6:	6b81      	ldr	r1, [r0, #56]	; 0x38
 80031e8:	2900      	cmp	r1, #0
 80031ea:	d003      	beq.n	80031f4 <__iar_annotation$$branch+0x24>
 80031ec:	7b2a      	ldrb	r2, [r5, #12]
 80031ee:	07d0      	lsls	r0, r2, #31
 80031f0:	0fc0      	lsrs	r0, r0, #31
 80031f2:	4788      	blx	r1
 80031f4:	2014      	movs	r0, #20
 80031f6:	4669      	mov	r1, sp
 80031f8:	7308      	strb	r0, [r1, #12]
 80031fa:	2101      	movs	r1, #1
 80031fc:	4668      	mov	r0, sp
 80031fe:	7b40      	ldrb	r0, [r0, #13]
 8003200:	f000 ffc5 	bl	800418e <PE_Reset>
 8003204:	4668      	mov	r0, sp
 8003206:	7b40      	ldrb	r0, [r0, #13]
 8003208:	f002 f924 	bl	8005454 <USBPD_PRL_Reset>
 800320c:	e67e      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>

0800320e <USBPD_PE_StateMachine_DRP>:
 800320e:	b580      	push	{r7, lr}
 8003210:	4911      	ldr	r1, [pc, #68]	; (8003258 <.text_25>)
 8003212:	0082      	lsls	r2, r0, #2
 8003214:	1889      	adds	r1, r1, r2
 8003216:	6849      	ldr	r1, [r1, #4]
 8003218:	6849      	ldr	r1, [r1, #4]
 800321a:	7809      	ldrb	r1, [r1, #0]
 800321c:	0889      	lsrs	r1, r1, #2
 800321e:	07c9      	lsls	r1, r1, #31
 8003220:	d502      	bpl.n	8003228 <USBPD_PE_StateMachine_DRP+0x1a>
 8003222:	f7fd f973 	bl	800050c <USBPD_PE_StateMachine_SRC>
 8003226:	bd02      	pop	{r1, pc}
 8003228:	f7fe fd00 	bl	8001c2c <USBPD_PE_StateMachine_SNK>
 800322c:	bd02      	pop	{r1, pc}

0800322e <USBPD_PE_Request_HardReset>:
 800322e:	b580      	push	{r7, lr}
 8003230:	4909      	ldr	r1, [pc, #36]	; (8003258 <.text_25>)
 8003232:	0082      	lsls	r2, r0, #2
 8003234:	1889      	adds	r1, r1, r2
 8003236:	6849      	ldr	r1, [r1, #4]
 8003238:	22d5      	movs	r2, #213	; 0xd5
 800323a:	0092      	lsls	r2, r2, #2
 800323c:	188a      	adds	r2, r1, r2
 800323e:	2300      	movs	r3, #0
 8003240:	7053      	strb	r3, [r2, #1]
 8003242:	230f      	movs	r3, #15
 8003244:	7013      	strb	r3, [r2, #0]
 8003246:	6889      	ldr	r1, [r1, #8]
 8003248:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800324a:	4788      	blx	r1
 800324c:	2000      	movs	r0, #0
 800324e:	bd02      	pop	{r1, pc}

08003250 <.text_23>:
 8003250:	b5e8b5cd 	.word	0xb5e8b5cd

08003254 <.text_24>:
 8003254:	00000fff 	.word	0x00000fff

08003258 <.text_25>:
 8003258:	200019ac 	.word	0x200019ac

0800325c <.text_26>:
 800325c:	0000801a 	.word	0x0000801a

08003260 <USBPD_PE_Request_CtrlMessage>:
 8003260:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 8003262:	b082      	sub	sp, #8
 8003264:	48b9      	ldr	r0, [pc, #740]	; (800354c <.text_29>)
 8003266:	466b      	mov	r3, sp
 8003268:	7a1b      	ldrb	r3, [r3, #8]
 800326a:	009b      	lsls	r3, r3, #2
 800326c:	58c0      	ldr	r0, [r0, r3]
 800326e:	9000      	str	r0, [sp, #0]
 8003270:	2402      	movs	r4, #2
 8003272:	23d5      	movs	r3, #213	; 0xd5
 8003274:	009b      	lsls	r3, r3, #2
 8003276:	18c0      	adds	r0, r0, r3
 8003278:	7803      	ldrb	r3, [r0, #0]
 800327a:	2b00      	cmp	r3, #0
 800327c:	d106      	bne.n	800328c <USBPD_PE_Request_CtrlMessage+0x2c>
 800327e:	9b00      	ldr	r3, [sp, #0]
 8003280:	685b      	ldr	r3, [r3, #4]
 8003282:	2501      	movs	r5, #1
 8003284:	681e      	ldr	r6, [r3, #0]
 8003286:	0af6      	lsrs	r6, r6, #11
 8003288:	402e      	ands	r6, r5
 800328a:	d101      	bne.n	8003290 <USBPD_PE_Request_CtrlMessage+0x30>
 800328c:	2003      	movs	r0, #3
 800328e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8003290:	466e      	mov	r6, sp
 8003292:	7132      	strb	r2, [r6, #4]
 8003294:	466a      	mov	r2, sp
 8003296:	7151      	strb	r1, [r2, #5]
 8003298:	9900      	ldr	r1, [sp, #0]
 800329a:	22e5      	movs	r2, #229	; 0xe5
 800329c:	0092      	lsls	r2, r2, #2
 800329e:	1889      	adds	r1, r1, r2
 80032a0:	222e      	movs	r2, #46	; 0x2e
 80032a2:	2603      	movs	r6, #3
 80032a4:	466f      	mov	r7, sp
 80032a6:	797f      	ldrb	r7, [r7, #5]
 80032a8:	2f02      	cmp	r7, #2
 80032aa:	d01a      	beq.n	80032e2 <USBPD_PE_Request_CtrlMessage+0x82>
 80032ac:	2f07      	cmp	r7, #7
 80032ae:	d029      	beq.n	8003304 <USBPD_PE_Request_CtrlMessage+0xa4>
 80032b0:	2f08      	cmp	r7, #8
 80032b2:	d03a      	beq.n	800332a <USBPD_PE_Request_CtrlMessage+0xca>
 80032b4:	2f09      	cmp	r7, #9
 80032b6:	d04b      	beq.n	8003350 <USBPD_PE_Request_CtrlMessage+0xf0>
 80032b8:	2f0a      	cmp	r7, #10
 80032ba:	d052      	beq.n	8003362 <USBPD_PE_Request_CtrlMessage+0x102>
 80032bc:	2f0b      	cmp	r7, #11
 80032be:	d063      	beq.n	8003388 <USBPD_PE_Request_CtrlMessage+0x128>
 80032c0:	2f0d      	cmp	r7, #13
 80032c2:	d06c      	beq.n	800339e <USBPD_PE_Request_CtrlMessage+0x13e>
 80032c4:	2f11      	cmp	r7, #17
 80032c6:	d071      	beq.n	80033ac <USBPD_PE_Request_CtrlMessage+0x14c>
 80032c8:	2f12      	cmp	r7, #18
 80032ca:	d100      	bne.n	80032ce <USBPD_PE_Request_CtrlMessage+0x6e>
 80032cc:	e082      	b.n	80033d4 <USBPD_PE_Request_CtrlMessage+0x174>
 80032ce:	2f13      	cmp	r7, #19
 80032d0:	d100      	bne.n	80032d4 <USBPD_PE_Request_CtrlMessage+0x74>
 80032d2:	e090      	b.n	80033f6 <USBPD_PE_Request_CtrlMessage+0x196>
 80032d4:	2f14      	cmp	r7, #20
 80032d6:	d100      	bne.n	80032da <USBPD_PE_Request_CtrlMessage+0x7a>
 80032d8:	e0a3      	b.n	8003422 <USBPD_PE_Request_CtrlMessage+0x1c2>
 80032da:	2f15      	cmp	r7, #21
 80032dc:	d100      	bne.n	80032e0 <USBPD_PE_Request_CtrlMessage+0x80>
 80032de:	e0b8      	b.n	8003452 <USBPD_PE_Request_CtrlMessage+0x1f2>
 80032e0:	e0d0      	b.n	8003484 <USBPD_PE_Request_CtrlMessage+0x224>
 80032e2:	781a      	ldrb	r2, [r3, #0]
 80032e4:	0892      	lsrs	r2, r2, #2
 80032e6:	422a      	tst	r2, r5
 80032e8:	d00a      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80032ea:	804c      	strh	r4, [r1, #2]
 80032ec:	2400      	movs	r4, #0
 80032ee:	7044      	strb	r4, [r0, #1]
 80032f0:	2196      	movs	r1, #150	; 0x96
 80032f2:	7001      	strb	r1, [r0, #0]
 80032f4:	4668      	mov	r0, sp
 80032f6:	7a00      	ldrb	r0, [r0, #8]
 80032f8:	9900      	ldr	r1, [sp, #0]
 80032fa:	6889      	ldr	r1, [r1, #8]
 80032fc:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80032fe:	4788      	blx	r1
 8003300:	0020      	movs	r0, r4
 8003302:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8003304:	7859      	ldrb	r1, [r3, #1]
 8003306:	0649      	lsls	r1, r1, #25
 8003308:	0f49      	lsrs	r1, r1, #29
 800330a:	2903      	cmp	r1, #3
 800330c:	d1f8      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 800330e:	9900      	ldr	r1, [sp, #0]
 8003310:	6809      	ldr	r1, [r1, #0]
 8003312:	6849      	ldr	r1, [r1, #4]
 8003314:	08c9      	lsrs	r1, r1, #3
 8003316:	4029      	ands	r1, r5
 8003318:	d103      	bne.n	8003322 <USBPD_PE_Request_CtrlMessage+0xc2>
 800331a:	7819      	ldrb	r1, [r3, #0]
 800331c:	0889      	lsrs	r1, r1, #2
 800331e:	4229      	tst	r1, r5
 8003320:	d1ee      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003322:	2400      	movs	r4, #0
 8003324:	7044      	strb	r4, [r0, #1]
 8003326:	211a      	movs	r1, #26
 8003328:	e7e3      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 800332a:	7859      	ldrb	r1, [r3, #1]
 800332c:	0649      	lsls	r1, r1, #25
 800332e:	0f49      	lsrs	r1, r1, #29
 8003330:	2903      	cmp	r1, #3
 8003332:	d1e5      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003334:	9900      	ldr	r1, [sp, #0]
 8003336:	6809      	ldr	r1, [r1, #0]
 8003338:	6849      	ldr	r1, [r1, #4]
 800333a:	08c9      	lsrs	r1, r1, #3
 800333c:	4029      	ands	r1, r5
 800333e:	d103      	bne.n	8003348 <USBPD_PE_Request_CtrlMessage+0xe8>
 8003340:	7819      	ldrb	r1, [r3, #0]
 8003342:	0889      	lsrs	r1, r1, #2
 8003344:	4229      	tst	r1, r5
 8003346:	d0db      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003348:	2400      	movs	r4, #0
 800334a:	7044      	strb	r4, [r0, #1]
 800334c:	2118      	movs	r1, #24
 800334e:	e7d0      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003350:	7859      	ldrb	r1, [r3, #1]
 8003352:	0649      	lsls	r1, r1, #25
 8003354:	0f49      	lsrs	r1, r1, #29
 8003356:	2903      	cmp	r1, #3
 8003358:	d1d2      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 800335a:	2400      	movs	r4, #0
 800335c:	7044      	strb	r4, [r0, #1]
 800335e:	2194      	movs	r1, #148	; 0x94
 8003360:	e7c7      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003362:	785a      	ldrb	r2, [r3, #1]
 8003364:	0652      	lsls	r2, r2, #25
 8003366:	0f52      	lsrs	r2, r2, #29
 8003368:	2a03      	cmp	r2, #3
 800336a:	d1c9      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 800336c:	9a00      	ldr	r2, [sp, #0]
 800336e:	6812      	ldr	r2, [r2, #0]
 8003370:	6852      	ldr	r2, [r2, #4]
 8003372:	08d2      	lsrs	r2, r2, #3
 8003374:	4015      	ands	r5, r2
 8003376:	d0c3      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003378:	220a      	movs	r2, #10
 800337a:	700a      	strb	r2, [r1, #0]
 800337c:	2208      	movs	r2, #8
 800337e:	804a      	strh	r2, [r1, #2]
 8003380:	2400      	movs	r4, #0
 8003382:	7044      	strb	r4, [r0, #1]
 8003384:	211e      	movs	r1, #30
 8003386:	e7b4      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003388:	9a00      	ldr	r2, [sp, #0]
 800338a:	6892      	ldr	r2, [r2, #8]
 800338c:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800338e:	2a00      	cmp	r2, #0
 8003390:	d0b6      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003392:	2210      	movs	r2, #16
 8003394:	804a      	strh	r2, [r1, #2]
 8003396:	2400      	movs	r4, #0
 8003398:	7044      	strb	r4, [r0, #1]
 800339a:	21a2      	movs	r1, #162	; 0xa2
 800339c:	e7a9      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 800339e:	4669      	mov	r1, sp
 80033a0:	7909      	ldrb	r1, [r1, #4]
 80033a2:	7041      	strb	r1, [r0, #1]
 80033a4:	2111      	movs	r1, #17
 80033a6:	7001      	strb	r1, [r0, #0]
 80033a8:	2400      	movs	r4, #0
 80033aa:	e7a3      	b.n	80032f4 <USBPD_PE_Request_CtrlMessage+0x94>
 80033ac:	785f      	ldrb	r7, [r3, #1]
 80033ae:	067f      	lsls	r7, r7, #25
 80033b0:	0f7f      	lsrs	r7, r7, #29
 80033b2:	2f03      	cmp	r7, #3
 80033b4:	d1a4      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033b6:	781b      	ldrb	r3, [r3, #0]
 80033b8:	401e      	ands	r6, r3
 80033ba:	2e01      	cmp	r6, #1
 80033bc:	dda0      	ble.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033be:	089b      	lsrs	r3, r3, #2
 80033c0:	422b      	tst	r3, r5
 80033c2:	d19d      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033c4:	2311      	movs	r3, #17
 80033c6:	700b      	strb	r3, [r1, #0]
 80033c8:	230a      	movs	r3, #10
 80033ca:	804b      	strh	r3, [r1, #2]
 80033cc:	2400      	movs	r4, #0
 80033ce:	7044      	strb	r4, [r0, #1]
 80033d0:	7002      	strb	r2, [r0, #0]
 80033d2:	e78f      	b.n	80032f4 <USBPD_PE_Request_CtrlMessage+0x94>
 80033d4:	785d      	ldrb	r5, [r3, #1]
 80033d6:	066d      	lsls	r5, r5, #25
 80033d8:	0f6d      	lsrs	r5, r5, #29
 80033da:	2d03      	cmp	r5, #3
 80033dc:	d190      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033de:	781b      	ldrb	r3, [r3, #0]
 80033e0:	401e      	ands	r6, r3
 80033e2:	2e01      	cmp	r6, #1
 80033e4:	dd8c      	ble.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033e6:	7002      	strb	r2, [r0, #0]
 80033e8:	2212      	movs	r2, #18
 80033ea:	700a      	strb	r2, [r1, #0]
 80033ec:	220b      	movs	r2, #11
 80033ee:	804a      	strh	r2, [r1, #2]
 80033f0:	2400      	movs	r4, #0
 80033f2:	7044      	strb	r4, [r0, #1]
 80033f4:	e77e      	b.n	80032f4 <USBPD_PE_Request_CtrlMessage+0x94>
 80033f6:	785a      	ldrb	r2, [r3, #1]
 80033f8:	0652      	lsls	r2, r2, #25
 80033fa:	0f52      	lsrs	r2, r2, #29
 80033fc:	2a03      	cmp	r2, #3
 80033fe:	d1ed      	bne.n	80033dc <USBPD_PE_Request_CtrlMessage+0x17c>
 8003400:	781a      	ldrb	r2, [r3, #0]
 8003402:	4016      	ands	r6, r2
 8003404:	2e01      	cmp	r6, #1
 8003406:	dded      	ble.n	80033e4 <USBPD_PE_Request_CtrlMessage+0x184>
 8003408:	0892      	lsrs	r2, r2, #2
 800340a:	422a      	tst	r2, r5
 800340c:	d1e6      	bne.n	80033dc <USBPD_PE_Request_CtrlMessage+0x17c>
 800340e:	9a00      	ldr	r2, [sp, #0]
 8003410:	6812      	ldr	r2, [r2, #0]
 8003412:	88d2      	ldrh	r2, [r2, #6]
 8003414:	0852      	lsrs	r2, r2, #1
 8003416:	422a      	tst	r2, r5
 8003418:	d0e4      	beq.n	80033e4 <USBPD_PE_Request_CtrlMessage+0x184>
 800341a:	2213      	movs	r2, #19
 800341c:	700a      	strb	r2, [r1, #0]
 800341e:	2209      	movs	r2, #9
 8003420:	e7ad      	b.n	800337e <USBPD_PE_Request_CtrlMessage+0x11e>
 8003422:	785a      	ldrb	r2, [r3, #1]
 8003424:	0652      	lsls	r2, r2, #25
 8003426:	0f52      	lsrs	r2, r2, #29
 8003428:	2a03      	cmp	r2, #3
 800342a:	d1d7      	bne.n	80033dc <USBPD_PE_Request_CtrlMessage+0x17c>
 800342c:	781a      	ldrb	r2, [r3, #0]
 800342e:	4016      	ands	r6, r2
 8003430:	2e01      	cmp	r6, #1
 8003432:	ddd7      	ble.n	80033e4 <USBPD_PE_Request_CtrlMessage+0x184>
 8003434:	0892      	lsrs	r2, r2, #2
 8003436:	422a      	tst	r2, r5
 8003438:	d125      	bne.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 800343a:	9a00      	ldr	r2, [sp, #0]
 800343c:	6812      	ldr	r2, [r2, #0]
 800343e:	88d2      	ldrh	r2, [r2, #6]
 8003440:	0892      	lsrs	r2, r2, #2
 8003442:	422a      	tst	r2, r5
 8003444:	d01f      	beq.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 8003446:	220b      	movs	r2, #11
 8003448:	804a      	strh	r2, [r1, #2]
 800344a:	2400      	movs	r4, #0
 800344c:	7044      	strb	r4, [r0, #1]
 800344e:	2165      	movs	r1, #101	; 0x65
 8003450:	e74f      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003452:	785f      	ldrb	r7, [r3, #1]
 8003454:	067f      	lsls	r7, r7, #25
 8003456:	0f7f      	lsrs	r7, r7, #29
 8003458:	2f03      	cmp	r7, #3
 800345a:	d114      	bne.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 800345c:	781b      	ldrb	r3, [r3, #0]
 800345e:	401e      	ands	r6, r3
 8003460:	2e01      	cmp	r6, #1
 8003462:	dd10      	ble.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 8003464:	9b00      	ldr	r3, [sp, #0]
 8003466:	681b      	ldr	r3, [r3, #0]
 8003468:	88db      	ldrh	r3, [r3, #6]
 800346a:	0a1b      	lsrs	r3, r3, #8
 800346c:	422b      	tst	r3, r5
 800346e:	d00a      	beq.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 8003470:	466b      	mov	r3, sp
 8003472:	791b      	ldrb	r3, [r3, #4]
 8003474:	7043      	strb	r3, [r0, #1]
 8003476:	23ff      	movs	r3, #255	; 0xff
 8003478:	330e      	adds	r3, #14
 800347a:	804b      	strh	r3, [r1, #2]
 800347c:	2315      	movs	r3, #21
 800347e:	700b      	strb	r3, [r1, #0]
 8003480:	7002      	strb	r2, [r0, #0]
 8003482:	e791      	b.n	80033a8 <USBPD_PE_Request_CtrlMessage+0x148>
 8003484:	2410      	movs	r4, #16
 8003486:	e73b      	b.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>

08003488 <USBPD_PE_Request_DataMessage>:
 8003488:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 800348a:	b084      	sub	sp, #16
 800348c:	482f      	ldr	r0, [pc, #188]	; (800354c <.text_29>)
 800348e:	466b      	mov	r3, sp
 8003490:	7c1b      	ldrb	r3, [r3, #16]
 8003492:	009b      	lsls	r3, r3, #2
 8003494:	58c0      	ldr	r0, [r0, r3]
 8003496:	9001      	str	r0, [sp, #4]
 8003498:	2402      	movs	r4, #2
 800349a:	23d5      	movs	r3, #213	; 0xd5
 800349c:	009b      	lsls	r3, r3, #2
 800349e:	18c0      	adds	r0, r0, r3
 80034a0:	7803      	ldrb	r3, [r0, #0]
 80034a2:	2b00      	cmp	r3, #0
 80034a4:	d106      	bne.n	80034b4 <USBPD_PE_Request_DataMessage+0x2c>
 80034a6:	9b01      	ldr	r3, [sp, #4]
 80034a8:	685b      	ldr	r3, [r3, #4]
 80034aa:	2501      	movs	r5, #1
 80034ac:	681e      	ldr	r6, [r3, #0]
 80034ae:	0af6      	lsrs	r6, r6, #11
 80034b0:	402e      	ands	r6, r5
 80034b2:	d101      	bne.n	80034b8 <USBPD_PE_Request_DataMessage+0x30>
 80034b4:	2003      	movs	r0, #3
 80034b6:	e022      	b.n	80034fe <USBPD_PE_Request_DataMessage+0x76>
 80034b8:	9203      	str	r2, [sp, #12]
 80034ba:	466a      	mov	r2, sp
 80034bc:	7011      	strb	r1, [r2, #0]
 80034be:	9901      	ldr	r1, [sp, #4]
 80034c0:	4a9c      	ldr	r2, [pc, #624]	; (8003734 <.text_33>)
 80034c2:	1889      	adds	r1, r1, r2
 80034c4:	9102      	str	r1, [sp, #8]
 80034c6:	2103      	movs	r1, #3
 80034c8:	2207      	movs	r2, #7
 80034ca:	2600      	movs	r6, #0
 80034cc:	466f      	mov	r7, sp
 80034ce:	783f      	ldrb	r7, [r7, #0]
 80034d0:	2f01      	cmp	r7, #1
 80034d2:	d004      	beq.n	80034de <USBPD_PE_Request_DataMessage+0x56>
 80034d4:	2f06      	cmp	r7, #6
 80034d6:	d014      	beq.n	8003502 <USBPD_PE_Request_DataMessage+0x7a>
 80034d8:	2f07      	cmp	r7, #7
 80034da:	d022      	beq.n	8003522 <USBPD_PE_Request_DataMessage+0x9a>
 80034dc:	e034      	b.n	8003548 <USBPD_PE_Request_DataMessage+0xc0>
 80034de:	7819      	ldrb	r1, [r3, #0]
 80034e0:	0889      	lsrs	r1, r1, #2
 80034e2:	4229      	tst	r1, r5
 80034e4:	d00a      	beq.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 80034e6:	9902      	ldr	r1, [sp, #8]
 80034e8:	800d      	strh	r5, [r1, #0]
 80034ea:	7046      	strb	r6, [r0, #1]
 80034ec:	7002      	strb	r2, [r0, #0]
 80034ee:	2400      	movs	r4, #0
 80034f0:	4668      	mov	r0, sp
 80034f2:	7c00      	ldrb	r0, [r0, #16]
 80034f4:	9901      	ldr	r1, [sp, #4]
 80034f6:	6889      	ldr	r1, [r1, #8]
 80034f8:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80034fa:	4788      	blx	r1
 80034fc:	0020      	movs	r0, r4
 80034fe:	b005      	add	sp, #20
 8003500:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003502:	785d      	ldrb	r5, [r3, #1]
 8003504:	092d      	lsrs	r5, r5, #4
 8003506:	402a      	ands	r2, r5
 8003508:	2a03      	cmp	r2, #3
 800350a:	d1f7      	bne.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 800350c:	781a      	ldrb	r2, [r3, #0]
 800350e:	4011      	ands	r1, r2
 8003510:	2901      	cmp	r1, #1
 8003512:	ddf3      	ble.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 8003514:	7046      	strb	r6, [r0, #1]
 8003516:	9903      	ldr	r1, [sp, #12]
 8003518:	6809      	ldr	r1, [r1, #0]
 800351a:	6381      	str	r1, [r0, #56]	; 0x38
 800351c:	212b      	movs	r1, #43	; 0x2b
 800351e:	7001      	strb	r1, [r0, #0]
 8003520:	e7e5      	b.n	80034ee <USBPD_PE_Request_DataMessage+0x66>
 8003522:	785d      	ldrb	r5, [r3, #1]
 8003524:	092d      	lsrs	r5, r5, #4
 8003526:	402a      	ands	r2, r5
 8003528:	2a03      	cmp	r2, #3
 800352a:	d1e7      	bne.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 800352c:	781a      	ldrb	r2, [r3, #0]
 800352e:	4011      	ands	r1, r2
 8003530:	2901      	cmp	r1, #1
 8003532:	dde3      	ble.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 8003534:	9903      	ldr	r1, [sp, #12]
 8003536:	6809      	ldr	r1, [r1, #0]
 8003538:	6381      	str	r1, [r0, #56]	; 0x38
 800353a:	21ff      	movs	r1, #255	; 0xff
 800353c:	310e      	adds	r1, #14
 800353e:	9a02      	ldr	r2, [sp, #8]
 8003540:	8011      	strh	r1, [r2, #0]
 8003542:	7046      	strb	r6, [r0, #1]
 8003544:	2162      	movs	r1, #98	; 0x62
 8003546:	e7ea      	b.n	800351e <USBPD_PE_Request_DataMessage+0x96>
 8003548:	2410      	movs	r4, #16
 800354a:	e7d7      	b.n	80034fc <USBPD_PE_Request_DataMessage+0x74>

0800354c <.text_29>:
 800354c:	200019b0 	.word	0x200019b0

08003550 <USBPD_PE_Send_Request>:
 8003550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003552:	4b79      	ldr	r3, [pc, #484]	; (8003738 <.text_34>)
 8003554:	0084      	lsls	r4, r0, #2
 8003556:	591b      	ldr	r3, [r3, r4]
 8003558:	24d5      	movs	r4, #213	; 0xd5
 800355a:	00a4      	lsls	r4, r4, #2
 800355c:	191c      	adds	r4, r3, r4
 800355e:	7825      	ldrb	r5, [r4, #0]
 8003560:	2d00      	cmp	r5, #0
 8003562:	d105      	bne.n	8003570 <USBPD_PE_Send_Request+0x20>
 8003564:	685d      	ldr	r5, [r3, #4]
 8003566:	2601      	movs	r6, #1
 8003568:	682f      	ldr	r7, [r5, #0]
 800356a:	0aff      	lsrs	r7, r7, #11
 800356c:	4037      	ands	r7, r6
 800356e:	d101      	bne.n	8003574 <USBPD_PE_Send_Request+0x24>
 8003570:	2003      	movs	r0, #3
 8003572:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 8003574:	786f      	ldrb	r7, [r5, #1]
 8003576:	067f      	lsls	r7, r7, #25
 8003578:	0f7f      	lsrs	r7, r7, #29
 800357a:	2f03      	cmp	r7, #3
 800357c:	d115      	bne.n	80035aa <USBPD_PE_Send_Request+0x5a>
 800357e:	782d      	ldrb	r5, [r5, #0]
 8003580:	08ad      	lsrs	r5, r5, #2
 8003582:	4235      	tst	r5, r6
 8003584:	d111      	bne.n	80035aa <USBPD_PE_Send_Request+0x5a>
 8003586:	2545      	movs	r5, #69	; 0x45
 8003588:	7025      	strb	r5, [r4, #0]
 800358a:	6119      	str	r1, [r3, #16]
 800358c:	7b19      	ldrb	r1, [r3, #12]
 800358e:	25f3      	movs	r5, #243	; 0xf3
 8003590:	400d      	ands	r5, r1
 8003592:	0091      	lsls	r1, r2, #2
 8003594:	220c      	movs	r2, #12
 8003596:	400a      	ands	r2, r1
 8003598:	432a      	orrs	r2, r5
 800359a:	731a      	strb	r2, [r3, #12]
 800359c:	2100      	movs	r1, #0
 800359e:	7061      	strb	r1, [r4, #1]
 80035a0:	6899      	ldr	r1, [r3, #8]
 80035a2:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80035a4:	4788      	blx	r1
 80035a6:	2000      	movs	r0, #0
 80035a8:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 80035aa:	2002      	movs	r0, #2
 80035ac:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

080035ae <USBPD_PE_SendExtendedMessage>:
 80035ae:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
 80035b0:	b083      	sub	sp, #12
 80035b2:	2600      	movs	r6, #0
 80035b4:	9601      	str	r6, [sp, #4]
 80035b6:	4860      	ldr	r0, [pc, #384]	; (8003738 <.text_34>)
 80035b8:	4669      	mov	r1, sp
 80035ba:	7b09      	ldrb	r1, [r1, #12]
 80035bc:	0089      	lsls	r1, r1, #2
 80035be:	5844      	ldr	r4, [r0, r1]
 80035c0:	20d3      	movs	r0, #211	; 0xd3
 80035c2:	0080      	lsls	r0, r0, #2
 80035c4:	1825      	adds	r5, r4, r0
 80035c6:	7a28      	ldrb	r0, [r5, #8]
 80035c8:	2800      	cmp	r0, #0
 80035ca:	d104      	bne.n	80035d6 <USBPD_PE_SendExtendedMessage+0x28>
 80035cc:	6860      	ldr	r0, [r4, #4]
 80035ce:	6801      	ldr	r1, [r0, #0]
 80035d0:	050f      	lsls	r7, r1, #20
 80035d2:	0fff      	lsrs	r7, r7, #31
 80035d4:	d101      	bne.n	80035da <USBPD_PE_SendExtendedMessage+0x2c>
 80035d6:	2003      	movs	r0, #3
 80035d8:	e06f      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 80035da:	7841      	ldrb	r1, [r0, #1]
 80035dc:	0649      	lsls	r1, r1, #25
 80035de:	0f49      	lsrs	r1, r1, #29
 80035e0:	2903      	cmp	r1, #3
 80035e2:	d10c      	bne.n	80035fe <USBPD_PE_SendExtendedMessage+0x50>
 80035e4:	7800      	ldrb	r0, [r0, #0]
 80035e6:	0780      	lsls	r0, r0, #30
 80035e8:	0f80      	lsrs	r0, r0, #30
 80035ea:	2801      	cmp	r0, #1
 80035ec:	dc01      	bgt.n	80035f2 <USBPD_PE_SendExtendedMessage+0x44>
 80035ee:	2001      	movs	r0, #1
 80035f0:	e063      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 80035f2:	4668      	mov	r0, sp
 80035f4:	8d00      	ldrh	r0, [r0, #40]	; 0x28
 80035f6:	21ff      	movs	r1, #255	; 0xff
 80035f8:	1d89      	adds	r1, r1, #6
 80035fa:	4288      	cmp	r0, r1
 80035fc:	d301      	bcc.n	8003602 <USBPD_PE_SendExtendedMessage+0x54>
 80035fe:	2002      	movs	r0, #2
 8003600:	e05b      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 8003602:	4668      	mov	r0, sp
 8003604:	7002      	strb	r2, [r0, #0]
 8003606:	68e0      	ldr	r0, [r4, #12]
 8003608:	2110      	movs	r1, #16
 800360a:	4388      	bics	r0, r1
 800360c:	60e0      	str	r0, [r4, #12]
 800360e:	4949      	ldr	r1, [pc, #292]	; (8003734 <.text_33>)
 8003610:	1861      	adds	r1, r4, r1
 8003612:	2210      	movs	r2, #16
 8003614:	466f      	mov	r7, sp
 8003616:	783f      	ldrb	r7, [r7, #0]
 8003618:	2f83      	cmp	r7, #131	; 0x83
 800361a:	d00c      	beq.n	8003636 <USBPD_PE_SendExtendedMessage+0x88>
 800361c:	2f84      	cmp	r7, #132	; 0x84
 800361e:	d021      	beq.n	8003664 <USBPD_PE_SendExtendedMessage+0xb6>
 8003620:	2f86      	cmp	r7, #134	; 0x86
 8003622:	d021      	beq.n	8003668 <USBPD_PE_SendExtendedMessage+0xba>
 8003624:	2f88      	cmp	r7, #136	; 0x88
 8003626:	d021      	beq.n	800366c <USBPD_PE_SendExtendedMessage+0xbe>
 8003628:	2f89      	cmp	r7, #137	; 0x89
 800362a:	d009      	beq.n	8003640 <USBPD_PE_SendExtendedMessage+0x92>
 800362c:	2f8a      	cmp	r7, #138	; 0x8a
 800362e:	d023      	beq.n	8003678 <USBPD_PE_SendExtendedMessage+0xca>
 8003630:	2f8b      	cmp	r7, #139	; 0x8b
 8003632:	d005      	beq.n	8003640 <USBPD_PE_SendExtendedMessage+0x92>
 8003634:	e025      	b.n	8003682 <USBPD_PE_SendExtendedMessage+0xd4>
 8003636:	200c      	movs	r0, #12
 8003638:	8008      	strh	r0, [r1, #0]
 800363a:	68e0      	ldr	r0, [r4, #12]
 800363c:	4302      	orrs	r2, r0
 800363e:	60e2      	str	r2, [r4, #12]
 8003640:	4668      	mov	r0, sp
 8003642:	8d00      	ldrh	r0, [r0, #40]	; 0x28
 8003644:	2800      	cmp	r0, #0
 8003646:	d028      	beq.n	800369a <USBPD_PE_SendExtendedMessage+0xec>
 8003648:	001f      	movs	r7, r3
 800364a:	4668      	mov	r0, sp
 800364c:	7b00      	ldrb	r0, [r0, #12]
 800364e:	f000 ff29 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8003652:	2801      	cmp	r0, #1
 8003654:	d100      	bne.n	8003658 <USBPD_PE_SendExtendedMessage+0xaa>
 8003656:	2604      	movs	r6, #4
 8003658:	9702      	str	r7, [sp, #8]
 800365a:	9801      	ldr	r0, [sp, #4]
 800365c:	4669      	mov	r1, sp
 800365e:	8d09      	ldrh	r1, [r1, #40]	; 0x28
 8003660:	4fc3      	ldr	r7, [pc, #780]	; (8003970 <.text_40>)
 8003662:	e016      	b.n	8003692 <USBPD_PE_SendExtendedMessage+0xe4>
 8003664:	200d      	movs	r0, #13
 8003666:	e7e7      	b.n	8003638 <USBPD_PE_SendExtendedMessage+0x8a>
 8003668:	200e      	movs	r0, #14
 800366a:	e7e5      	b.n	8003638 <USBPD_PE_SendExtendedMessage+0x8a>
 800366c:	4302      	orrs	r2, r0
 800366e:	60e2      	str	r2, [r4, #12]
 8003670:	20ff      	movs	r0, #255	; 0xff
 8003672:	300c      	adds	r0, #12
 8003674:	8008      	strh	r0, [r1, #0]
 8003676:	e7e3      	b.n	8003640 <USBPD_PE_SendExtendedMessage+0x92>
 8003678:	4302      	orrs	r2, r0
 800367a:	60e2      	str	r2, [r4, #12]
 800367c:	2086      	movs	r0, #134	; 0x86
 800367e:	0040      	lsls	r0, r0, #1
 8003680:	e7f8      	b.n	8003674 <USBPD_PE_SendExtendedMessage+0xc6>
 8003682:	2010      	movs	r0, #16
 8003684:	e019      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 8003686:	9a02      	ldr	r2, [sp, #8]
 8003688:	5c12      	ldrb	r2, [r2, r0]
 800368a:	1983      	adds	r3, r0, r6
 800368c:	18e3      	adds	r3, r4, r3
 800368e:	55da      	strb	r2, [r3, r7]
 8003690:	1c40      	adds	r0, r0, #1
 8003692:	4288      	cmp	r0, r1
 8003694:	d3f7      	bcc.n	8003686 <USBPD_PE_SendExtendedMessage+0xd8>
 8003696:	8029      	strh	r1, [r5, #0]
 8003698:	e000      	b.n	800369c <USBPD_PE_SendExtendedMessage+0xee>
 800369a:	802e      	strh	r6, [r5, #0]
 800369c:	4668      	mov	r0, sp
 800369e:	7c00      	ldrb	r0, [r0, #16]
 80036a0:	7268      	strb	r0, [r5, #9]
 80036a2:	4668      	mov	r0, sp
 80036a4:	7800      	ldrb	r0, [r0, #0]
 80036a6:	49bc      	ldr	r1, [pc, #752]	; (8003998 <.text_43>)
 80036a8:	5460      	strb	r0, [r4, r1]
 80036aa:	2031      	movs	r0, #49	; 0x31
 80036ac:	7228      	strb	r0, [r5, #8]
 80036ae:	4668      	mov	r0, sp
 80036b0:	7b00      	ldrb	r0, [r0, #12]
 80036b2:	68a1      	ldr	r1, [r4, #8]
 80036b4:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80036b6:	4788      	blx	r1
 80036b8:	2000      	movs	r0, #0
 80036ba:	b005      	add	sp, #20
 80036bc:	bdf0      	pop	{r4, r5, r6, r7, pc}

080036be <PE_Send_SRCCapabilities>:
 80036be:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80036c0:	b084      	sub	sp, #16
 80036c2:	0005      	movs	r5, r0
 80036c4:	000f      	movs	r7, r1
 80036c6:	20e2      	movs	r0, #226	; 0xe2
 80036c8:	0080      	lsls	r0, r0, #2
 80036ca:	582e      	ldr	r6, [r5, r0]
 80036cc:	211e      	movs	r1, #30
 80036ce:	0028      	movs	r0, r5
 80036d0:	3018      	adds	r0, #24
 80036d2:	f008 ff19 	bl	800c508 <__aeabi_memclr>
 80036d6:	ab02      	add	r3, sp, #8
 80036d8:	002a      	movs	r2, r5
 80036da:	321a      	adds	r2, #26
 80036dc:	2100      	movs	r1, #0
 80036de:	7b2c      	ldrb	r4, [r5, #12]
 80036e0:	07e0      	lsls	r0, r4, #31
 80036e2:	0fc0      	lsrs	r0, r0, #31
 80036e4:	68ac      	ldr	r4, [r5, #8]
 80036e6:	69a4      	ldr	r4, [r4, #24]
 80036e8:	47a0      	blx	r4
 80036ea:	9802      	ldr	r0, [sp, #8]
 80036ec:	1c80      	adds	r0, r0, #2
 80036ee:	b2c0      	uxtb	r0, r0
 80036f0:	4669      	mov	r1, sp
 80036f2:	8188      	strh	r0, [r1, #12]
 80036f4:	2401      	movs	r4, #1
 80036f6:	9701      	str	r7, [sp, #4]
 80036f8:	4668      	mov	r0, sp
 80036fa:	8980      	ldrh	r0, [r0, #12]
 80036fc:	9000      	str	r0, [sp, #0]
 80036fe:	002b      	movs	r3, r5
 8003700:	3318      	adds	r3, #24
 8003702:	2201      	movs	r2, #1
 8003704:	68e9      	ldr	r1, [r5, #12]
 8003706:	2001      	movs	r0, #1
 8003708:	4008      	ands	r0, r1
 800370a:	2100      	movs	r1, #0
 800370c:	f001 fc5a 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8003710:	2803      	cmp	r0, #3
 8003712:	d10c      	bne.n	800372e <PE_Send_SRCCapabilities+0x70>
 8003714:	20e2      	movs	r0, #226	; 0xe2
 8003716:	0080      	lsls	r0, r0, #2
 8003718:	5828      	ldr	r0, [r5, r0]
 800371a:	1b80      	subs	r0, r0, r6
 800371c:	49b9      	ldr	r1, [pc, #740]	; (8003a04 <.text_46>)
 800371e:	4288      	cmp	r0, r1
 8003720:	d204      	bcs.n	800372c <PE_Send_SRCCapabilities+0x6e>
 8003722:	6868      	ldr	r0, [r5, #4]
 8003724:	6800      	ldr	r0, [r0, #0]
 8003726:	0ac0      	lsrs	r0, r0, #11
 8003728:	4004      	ands	r4, r0
 800372a:	d1e3      	bne.n	80036f4 <PE_Send_SRCCapabilities+0x36>
 800372c:	2010      	movs	r0, #16
 800372e:	b005      	add	sp, #20
 8003730:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08003734 <.text_33>:
 8003734:	00000396 	.word	0x00000396

08003738 <.text_34>:
 8003738:	200019b0 	.word	0x200019b0

0800373c <PE_Send_SNKCapabilities>:
 800373c:	b578      	push	{r3, r4, r5, r6, lr}
 800373e:	b08b      	sub	sp, #44	; 0x2c
 8003740:	0004      	movs	r4, r0
 8003742:	000d      	movs	r5, r1
 8003744:	ab03      	add	r3, sp, #12
 8003746:	aa04      	add	r2, sp, #16
 8003748:	2101      	movs	r1, #1
 800374a:	7b26      	ldrb	r6, [r4, #12]
 800374c:	07f0      	lsls	r0, r6, #31
 800374e:	0fc0      	lsrs	r0, r0, #31
 8003750:	68a6      	ldr	r6, [r4, #8]
 8003752:	69b6      	ldr	r6, [r6, #24]
 8003754:	47b0      	blx	r6
 8003756:	2000      	movs	r0, #0
 8003758:	9002      	str	r0, [sp, #8]
 800375a:	9501      	str	r5, [sp, #4]
 800375c:	9803      	ldr	r0, [sp, #12]
 800375e:	0880      	lsrs	r0, r0, #2
 8003760:	9000      	str	r0, [sp, #0]
 8003762:	ab04      	add	r3, sp, #16
 8003764:	2204      	movs	r2, #4
 8003766:	2100      	movs	r1, #0
 8003768:	0020      	movs	r0, r4
 800376a:	f000 f849 	bl	8003800 <PE_Send_DataMessage>
 800376e:	b00c      	add	sp, #48	; 0x30
 8003770:	bd70      	pop	{r4, r5, r6, pc}

08003772 <PE_Send_CtrlMessage>:
 8003772:	b5fc      	push	{r2, r3, r4, r5, r6, r7, lr}
 8003774:	b083      	sub	sp, #12
 8003776:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8003778:	0005      	movs	r5, r0
 800377a:	4668      	mov	r0, sp
 800377c:	7201      	strb	r1, [r0, #8]
 800377e:	0016      	movs	r6, r2
 8003780:	2401      	movs	r4, #1
 8003782:	9701      	str	r7, [sp, #4]
 8003784:	2002      	movs	r0, #2
 8003786:	9000      	str	r0, [sp, #0]
 8003788:	002b      	movs	r3, r5
 800378a:	3318      	adds	r3, #24
 800378c:	0032      	movs	r2, r6
 800378e:	4668      	mov	r0, sp
 8003790:	7a01      	ldrb	r1, [r0, #8]
 8003792:	468c      	mov	ip, r1
 8003794:	68e9      	ldr	r1, [r5, #12]
 8003796:	2001      	movs	r0, #1
 8003798:	4008      	ands	r0, r1
 800379a:	4661      	mov	r1, ip
 800379c:	f001 fc12 	bl	8004fc4 <USBPD_PRL_SendMessage>
 80037a0:	2803      	cmp	r0, #3
 80037a2:	d11a      	bne.n	80037da <PE_Send_CtrlMessage+0x68>
 80037a4:	6868      	ldr	r0, [r5, #4]
 80037a6:	6800      	ldr	r0, [r0, #0]
 80037a8:	0ac0      	lsrs	r0, r0, #11
 80037aa:	4004      	ands	r4, r0
 80037ac:	d1e8      	bne.n	8003780 <PE_Send_CtrlMessage+0xe>
 80037ae:	2000      	movs	r0, #0
 80037b0:	21d5      	movs	r1, #213	; 0xd5
 80037b2:	0089      	lsls	r1, r1, #2
 80037b4:	1869      	adds	r1, r5, r1
 80037b6:	e00c      	b.n	80037d2 <PE_Send_CtrlMessage+0x60>
 80037b8:	700a      	strb	r2, [r1, #0]
 80037ba:	e00b      	b.n	80037d4 <PE_Send_CtrlMessage+0x62>
 80037bc:	6868      	ldr	r0, [r5, #4]
 80037be:	7840      	ldrb	r0, [r0, #1]
 80037c0:	0640      	lsls	r0, r0, #25
 80037c2:	0f40      	lsrs	r0, r0, #29
 80037c4:	2804      	cmp	r0, #4
 80037c6:	d001      	beq.n	80037cc <PE_Send_CtrlMessage+0x5a>
 80037c8:	2e0d      	cmp	r6, #13
 80037ca:	d101      	bne.n	80037d0 <PE_Send_CtrlMessage+0x5e>
 80037cc:	200f      	movs	r0, #15
 80037ce:	e000      	b.n	80037d2 <PE_Send_CtrlMessage+0x60>
 80037d0:	2011      	movs	r0, #17
 80037d2:	7108      	strb	r0, [r1, #4]
 80037d4:	2010      	movs	r0, #16
 80037d6:	b005      	add	sp, #20
 80037d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80037da:	21d5      	movs	r1, #213	; 0xd5
 80037dc:	0089      	lsls	r1, r1, #2
 80037de:	1869      	adds	r1, r5, r1
 80037e0:	2200      	movs	r2, #0
 80037e2:	2805      	cmp	r0, #5
 80037e4:	d006      	beq.n	80037f4 <PE_Send_CtrlMessage+0x82>
 80037e6:	2806      	cmp	r0, #6
 80037e8:	d0e6      	beq.n	80037b8 <PE_Send_CtrlMessage+0x46>
 80037ea:	2807      	cmp	r0, #7
 80037ec:	d0e6      	beq.n	80037bc <PE_Send_CtrlMessage+0x4a>
 80037ee:	2809      	cmp	r0, #9
 80037f0:	d0f1      	beq.n	80037d6 <PE_Send_CtrlMessage+0x64>
 80037f2:	e7ef      	b.n	80037d4 <PE_Send_CtrlMessage+0x62>
 80037f4:	4668      	mov	r0, sp
 80037f6:	7c00      	ldrb	r0, [r0, #16]
 80037f8:	7108      	strb	r0, [r1, #4]
 80037fa:	700a      	strb	r2, [r1, #0]
 80037fc:	2000      	movs	r0, #0
 80037fe:	e7ea      	b.n	80037d6 <PE_Send_CtrlMessage+0x64>

08003800 <PE_Send_DataMessage>:
 8003800:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8003802:	b082      	sub	sp, #8
 8003804:	0005      	movs	r5, r0
 8003806:	2000      	movs	r0, #0
 8003808:	e00c      	b.n	8003824 <PE_Send_DataMessage+0x24>
 800380a:	2600      	movs	r6, #0
 800380c:	0081      	lsls	r1, r0, #2
 800380e:	1869      	adds	r1, r5, r1
 8003810:	198a      	adds	r2, r1, r6
 8003812:	6819      	ldr	r1, [r3, #0]
 8003814:	00f7      	lsls	r7, r6, #3
 8003816:	40f9      	lsrs	r1, r7
 8003818:	7691      	strb	r1, [r2, #26]
 800381a:	1c76      	adds	r6, r6, #1
 800381c:	2e04      	cmp	r6, #4
 800381e:	dbf5      	blt.n	800380c <PE_Send_DataMessage+0xc>
 8003820:	1d1b      	adds	r3, r3, #4
 8003822:	1c40      	adds	r0, r0, #1
 8003824:	990a      	ldr	r1, [sp, #40]	; 0x28
 8003826:	4288      	cmp	r0, r1
 8003828:	d3ef      	bcc.n	800380a <PE_Send_DataMessage+0xa>
 800382a:	2401      	movs	r4, #1
 800382c:	a80c      	add	r0, sp, #48	; 0x30
 800382e:	7800      	ldrb	r0, [r0, #0]
 8003830:	9001      	str	r0, [sp, #4]
 8003832:	980a      	ldr	r0, [sp, #40]	; 0x28
 8003834:	0080      	lsls	r0, r0, #2
 8003836:	1c80      	adds	r0, r0, #2
 8003838:	b280      	uxth	r0, r0
 800383a:	9000      	str	r0, [sp, #0]
 800383c:	002b      	movs	r3, r5
 800383e:	3318      	adds	r3, #24
 8003840:	4668      	mov	r0, sp
 8003842:	7c02      	ldrb	r2, [r0, #16]
 8003844:	7b01      	ldrb	r1, [r0, #12]
 8003846:	68ee      	ldr	r6, [r5, #12]
 8003848:	2001      	movs	r0, #1
 800384a:	4030      	ands	r0, r6
 800384c:	f001 fbba 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8003850:	2803      	cmp	r0, #3
 8003852:	d117      	bne.n	8003884 <PE_Send_DataMessage+0x84>
 8003854:	6868      	ldr	r0, [r5, #4]
 8003856:	6800      	ldr	r0, [r0, #0]
 8003858:	0ac0      	lsrs	r0, r0, #11
 800385a:	4004      	ands	r4, r0
 800385c:	d1e5      	bne.n	800382a <PE_Send_DataMessage+0x2a>
 800385e:	2010      	movs	r0, #16
 8003860:	e00e      	b.n	8003880 <PE_Send_DataMessage+0x80>
 8003862:	2a00      	cmp	r2, #0
 8003864:	d001      	beq.n	800386a <PE_Send_DataMessage+0x6a>
 8003866:	2099      	movs	r0, #153	; 0x99
 8003868:	e008      	b.n	800387c <PE_Send_DataMessage+0x7c>
 800386a:	6868      	ldr	r0, [r5, #4]
 800386c:	7840      	ldrb	r0, [r0, #1]
 800386e:	0640      	lsls	r0, r0, #25
 8003870:	0f40      	lsrs	r0, r0, #29
 8003872:	2804      	cmp	r0, #4
 8003874:	d101      	bne.n	800387a <PE_Send_DataMessage+0x7a>
 8003876:	200f      	movs	r0, #15
 8003878:	e000      	b.n	800387c <PE_Send_DataMessage+0x7c>
 800387a:	2011      	movs	r0, #17
 800387c:	7008      	strb	r0, [r1, #0]
 800387e:	2000      	movs	r0, #0
 8003880:	b005      	add	sp, #20
 8003882:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003884:	4669      	mov	r1, sp
 8003886:	7b0a      	ldrb	r2, [r1, #12]
 8003888:	21d6      	movs	r1, #214	; 0xd6
 800388a:	0089      	lsls	r1, r1, #2
 800388c:	1869      	adds	r1, r5, r1
 800388e:	2805      	cmp	r0, #5
 8003890:	d004      	beq.n	800389c <PE_Send_DataMessage+0x9c>
 8003892:	2807      	cmp	r0, #7
 8003894:	d0e5      	beq.n	8003862 <PE_Send_DataMessage+0x62>
 8003896:	2809      	cmp	r0, #9
 8003898:	d0f2      	beq.n	8003880 <PE_Send_DataMessage+0x80>
 800389a:	e7f0      	b.n	800387e <PE_Send_DataMessage+0x7e>
 800389c:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800389e:	7008      	strb	r0, [r1, #0]
 80038a0:	4e59      	ldr	r6, [pc, #356]	; (8003a08 <.text_47>)
 80038a2:	7830      	ldrb	r0, [r6, #0]
 80038a4:	0780      	lsls	r0, r0, #30
 80038a6:	d509      	bpl.n	80038bc <PE_Send_DataMessage+0xbc>
 80038a8:	2000      	movs	r0, #0
 80038aa:	9000      	str	r0, [sp, #0]
 80038ac:	2300      	movs	r3, #0
 80038ae:	2242      	movs	r2, #66	; 0x42
 80038b0:	68e8      	ldr	r0, [r5, #12]
 80038b2:	2101      	movs	r1, #1
 80038b4:	4001      	ands	r1, r0
 80038b6:	2009      	movs	r0, #9
 80038b8:	68f6      	ldr	r6, [r6, #12]
 80038ba:	47b0      	blx	r6
 80038bc:	2142      	movs	r1, #66	; 0x42
 80038be:	68e8      	ldr	r0, [r5, #12]
 80038c0:	4004      	ands	r4, r0
 80038c2:	0020      	movs	r0, r4
 80038c4:	68aa      	ldr	r2, [r5, #8]
 80038c6:	68d2      	ldr	r2, [r2, #12]
 80038c8:	4790      	blx	r2
 80038ca:	e7d8      	b.n	800387e <PE_Send_DataMessage+0x7e>

080038cc <PE_Send_HARDRESET>:
 80038cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80038ce:	0004      	movs	r4, r0
 80038d0:	20e2      	movs	r0, #226	; 0xe2
 80038d2:	0080      	lsls	r0, r0, #2
 80038d4:	5825      	ldr	r5, [r4, r0]
 80038d6:	2601      	movs	r6, #1
 80038d8:	4f4b      	ldr	r7, [pc, #300]	; (8003a08 <.text_47>)
 80038da:	7838      	ldrb	r0, [r7, #0]
 80038dc:	0780      	lsls	r0, r0, #30
 80038de:	d509      	bpl.n	80038f4 <PE_Send_HARDRESET+0x28>
 80038e0:	2000      	movs	r0, #0
 80038e2:	9000      	str	r0, [sp, #0]
 80038e4:	2300      	movs	r3, #0
 80038e6:	221e      	movs	r2, #30
 80038e8:	68e0      	ldr	r0, [r4, #12]
 80038ea:	2101      	movs	r1, #1
 80038ec:	4001      	ands	r1, r0
 80038ee:	2009      	movs	r0, #9
 80038f0:	68ff      	ldr	r7, [r7, #12]
 80038f2:	47b8      	blx	r7
 80038f4:	211e      	movs	r1, #30
 80038f6:	68e2      	ldr	r2, [r4, #12]
 80038f8:	2001      	movs	r0, #1
 80038fa:	4010      	ands	r0, r2
 80038fc:	68a2      	ldr	r2, [r4, #8]
 80038fe:	68d2      	ldr	r2, [r2, #12]
 8003900:	4790      	blx	r2
 8003902:	68e1      	ldr	r1, [r4, #12]
 8003904:	2001      	movs	r0, #1
 8003906:	4008      	ands	r0, r1
 8003908:	f001 fd3f 	bl	800538a <USBPD_PRL_ResetRequestReset>
 800390c:	20e2      	movs	r0, #226	; 0xe2
 800390e:	0080      	lsls	r0, r0, #2
 8003910:	1820      	adds	r0, r4, r0
 8003912:	9000      	str	r0, [sp, #0]
 8003914:	4f3b      	ldr	r7, [pc, #236]	; (8003a04 <.text_46>)
 8003916:	2105      	movs	r1, #5
 8003918:	68e2      	ldr	r2, [r4, #12]
 800391a:	2001      	movs	r0, #1
 800391c:	4010      	ands	r0, r2
 800391e:	f001 fd3f 	bl	80053a0 <USBPD_PRL_ResetRequestProcess>
 8003922:	2803      	cmp	r0, #3
 8003924:	d10a      	bne.n	800393c <PE_Send_HARDRESET+0x70>
 8003926:	9800      	ldr	r0, [sp, #0]
 8003928:	6800      	ldr	r0, [r0, #0]
 800392a:	1b40      	subs	r0, r0, r5
 800392c:	42b8      	cmp	r0, r7
 800392e:	d204      	bcs.n	800393a <PE_Send_HARDRESET+0x6e>
 8003930:	6860      	ldr	r0, [r4, #4]
 8003932:	6800      	ldr	r0, [r0, #0]
 8003934:	0ac0      	lsrs	r0, r0, #11
 8003936:	4030      	ands	r0, r6
 8003938:	d1ed      	bne.n	8003916 <PE_Send_HARDRESET+0x4a>
 800393a:	2004      	movs	r0, #4
 800393c:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

0800393e <PE_PerformSoftReset>:
 800393e:	b538      	push	{r3, r4, r5, lr}
 8003940:	0004      	movs	r4, r0
 8003942:	2500      	movs	r5, #0
 8003944:	2001      	movs	r0, #1
 8003946:	6861      	ldr	r1, [r4, #4]
 8003948:	7809      	ldrb	r1, [r1, #0]
 800394a:	0889      	lsrs	r1, r1, #2
 800394c:	4201      	tst	r1, r0
 800394e:	d006      	beq.n	800395e <PE_PerformSoftReset+0x20>
 8003950:	7565      	strb	r5, [r4, #21]
 8003952:	2101      	movs	r1, #1
 8003954:	68e2      	ldr	r2, [r4, #12]
 8003956:	4010      	ands	r0, r2
 8003958:	f001 fae3 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 800395c:	bd31      	pop	{r0, r4, r5, pc}
 800395e:	2100      	movs	r1, #0
 8003960:	68e2      	ldr	r2, [r4, #12]
 8003962:	4010      	ands	r0, r2
 8003964:	f001 fadd 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8003968:	4828      	ldr	r0, [pc, #160]	; (8003a0c <.text_48>)
 800396a:	5225      	strh	r5, [r4, r0]
 800396c:	7525      	strb	r5, [r4, #20]
 800396e:	bd31      	pop	{r0, r4, r5, pc}

08003970 <.text_40>:
 8003970:	00000242 	.word	0x00000242

08003974 <PE_Get_DataRole>:
 8003974:	4924      	ldr	r1, [pc, #144]	; (8003a08 <.text_47>)
 8003976:	0080      	lsls	r0, r0, #2
 8003978:	1808      	adds	r0, r1, r0
 800397a:	6840      	ldr	r0, [r0, #4]
 800397c:	6840      	ldr	r0, [r0, #4]
 800397e:	7800      	ldrb	r0, [r0, #0]
 8003980:	0701      	lsls	r1, r0, #28
 8003982:	0fc8      	lsrs	r0, r1, #31
 8003984:	4770      	bx	lr

08003986 <PE_Get_SpecRevision>:
 8003986:	4920      	ldr	r1, [pc, #128]	; (8003a08 <.text_47>)
 8003988:	0080      	lsls	r0, r0, #2
 800398a:	1808      	adds	r0, r1, r0
 800398c:	6840      	ldr	r0, [r0, #4]
 800398e:	6840      	ldr	r0, [r0, #4]
 8003990:	7800      	ldrb	r0, [r0, #0]
 8003992:	0780      	lsls	r0, r0, #30
 8003994:	0f80      	lsrs	r0, r0, #30
 8003996:	4770      	bx	lr

08003998 <.text_43>:
 8003998:	00000393 	.word	0x00000393

0800399c <PE_ChangePowerRole>:
 800399c:	b538      	push	{r3, r4, r5, lr}
 800399e:	6842      	ldr	r2, [r0, #4]
 80039a0:	7813      	ldrb	r3, [r2, #0]
 80039a2:	24fb      	movs	r4, #251	; 0xfb
 80039a4:	401c      	ands	r4, r3
 80039a6:	008b      	lsls	r3, r1, #2
 80039a8:	2504      	movs	r5, #4
 80039aa:	402b      	ands	r3, r5
 80039ac:	4323      	orrs	r3, r4
 80039ae:	7013      	strb	r3, [r2, #0]
 80039b0:	7b02      	ldrb	r2, [r0, #12]
 80039b2:	07d0      	lsls	r0, r2, #31
 80039b4:	0fc0      	lsrs	r0, r0, #31
 80039b6:	f001 fab4 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 80039ba:	bd31      	pop	{r0, r4, r5, pc}

080039bc <PE_Check_RxEvent>:
 80039bc:	b081      	sub	sp, #4
 80039be:	0001      	movs	r1, r0
 80039c0:	2014      	movs	r0, #20
 80039c2:	4a13      	ldr	r2, [pc, #76]	; (8003a10 <.text_49>)
 80039c4:	1889      	adds	r1, r1, r2
 80039c6:	780a      	ldrb	r2, [r1, #0]
 80039c8:	2a00      	cmp	r2, #0
 80039ca:	d019      	beq.n	8003a00 <PE_Check_RxEvent+0x44>
 80039cc:	780a      	ldrb	r2, [r1, #0]
 80039ce:	0692      	lsls	r2, r2, #26
 80039d0:	d401      	bmi.n	80039d6 <PE_Check_RxEvent+0x1a>
 80039d2:	2003      	movs	r0, #3
 80039d4:	e014      	b.n	8003a00 <PE_Check_RxEvent+0x44>
 80039d6:	2200      	movs	r2, #0
 80039d8:	780b      	ldrb	r3, [r1, #0]
 80039da:	06db      	lsls	r3, r3, #27
 80039dc:	0edb      	lsrs	r3, r3, #27
 80039de:	2b01      	cmp	r3, #1
 80039e0:	d004      	beq.n	80039ec <PE_Check_RxEvent+0x30>
 80039e2:	2b02      	cmp	r3, #2
 80039e4:	d005      	beq.n	80039f2 <PE_Check_RxEvent+0x36>
 80039e6:	2b04      	cmp	r3, #4
 80039e8:	d006      	beq.n	80039f8 <PE_Check_RxEvent+0x3c>
 80039ea:	e008      	b.n	80039fe <PE_Check_RxEvent+0x42>
 80039ec:	2011      	movs	r0, #17
 80039ee:	710a      	strb	r2, [r1, #4]
 80039f0:	e005      	b.n	80039fe <PE_Check_RxEvent+0x42>
 80039f2:	2012      	movs	r0, #18
 80039f4:	2301      	movs	r3, #1
 80039f6:	e001      	b.n	80039fc <PE_Check_RxEvent+0x40>
 80039f8:	2013      	movs	r0, #19
 80039fa:	2302      	movs	r3, #2
 80039fc:	710b      	strb	r3, [r1, #4]
 80039fe:	700a      	strb	r2, [r1, #0]
 8003a00:	b001      	add	sp, #4
 8003a02:	4770      	bx	lr

08003a04 <.text_46>:
 8003a04:	00001771 	.word	0x00001771

08003a08 <.text_47>:
 8003a08:	200019ac 	.word	0x200019ac

08003a0c <.text_48>:
 8003a0c:	0000036e 	.word	0x0000036e

08003a10 <.text_49>:
 8003a10:	00000356 	.word	0x00000356

08003a14 <PE_Check_AMSConflict>:
 8003a14:	b081      	sub	sp, #4
 8003a16:	21d6      	movs	r1, #214	; 0xd6
 8003a18:	0089      	lsls	r1, r1, #2
 8003a1a:	1841      	adds	r1, r0, r1
 8003a1c:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
 8003a1e:	0bd2      	lsrs	r2, r2, #15
 8003a20:	d10a      	bne.n	8003a38 <PE_Check_AMSConflict+0x24>
 8003a22:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
 8003a24:	0452      	lsls	r2, r2, #17
 8003a26:	0f52      	lsrs	r2, r2, #29
 8003a28:	d106      	bne.n	8003a38 <PE_Check_AMSConflict+0x24>
 8003a2a:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
 8003a2c:	06d2      	lsls	r2, r2, #27
 8003a2e:	0ed2      	lsrs	r2, r2, #27
 8003a30:	2a0d      	cmp	r2, #13
 8003a32:	d101      	bne.n	8003a38 <PE_Check_AMSConflict+0x24>
 8003a34:	2010      	movs	r0, #16
 8003a36:	e01a      	b.n	8003a6e <PE_Check_AMSConflict+0x5a>
 8003a38:	2216      	movs	r2, #22
 8003a3a:	5e80      	ldrsh	r0, [r0, r2]
 8003a3c:	2203      	movs	r2, #3
 8003a3e:	0003      	movs	r3, r0
 8003a40:	d00f      	beq.n	8003a62 <PE_Check_AMSConflict+0x4e>
 8003a42:	1e43      	subs	r3, r0, #1
 8003a44:	2b01      	cmp	r3, #1
 8003a46:	d90f      	bls.n	8003a68 <PE_Check_AMSConflict+0x54>
 8003a48:	1e9b      	subs	r3, r3, #2
 8003a4a:	d00f      	beq.n	8003a6c <PE_Check_AMSConflict+0x58>
 8003a4c:	1e5b      	subs	r3, r3, #1
 8003a4e:	d00f      	beq.n	8003a70 <PE_Check_AMSConflict+0x5c>
 8003a50:	1e5b      	subs	r3, r3, #1
 8003a52:	2b0b      	cmp	r3, #11
 8003a54:	d908      	bls.n	8003a68 <PE_Check_AMSConflict+0x54>
 8003a56:	3b0c      	subs	r3, #12
 8003a58:	d00f      	beq.n	8003a7a <PE_Check_AMSConflict+0x66>
 8003a5a:	3bef      	subs	r3, #239	; 0xef
 8003a5c:	2b0e      	cmp	r3, #14
 8003a5e:	d909      	bls.n	8003a74 <PE_Check_AMSConflict+0x60>
 8003a60:	e00c      	b.n	8003a7c <PE_Check_AMSConflict+0x68>
 8003a62:	2004      	movs	r0, #4
 8003a64:	7008      	strb	r0, [r1, #0]
 8003a66:	e009      	b.n	8003a7c <PE_Check_AMSConflict+0x68>
 8003a68:	2011      	movs	r0, #17
 8003a6a:	e000      	b.n	8003a6e <PE_Check_AMSConflict+0x5a>
 8003a6c:	200f      	movs	r0, #15
 8003a6e:	7008      	strb	r0, [r1, #0]
 8003a70:	2015      	movs	r0, #21
 8003a72:	e004      	b.n	8003a7e <PE_Check_AMSConflict+0x6a>
 8003a74:	80c8      	strh	r0, [r1, #6]
 8003a76:	7808      	ldrb	r0, [r1, #0]
 8003a78:	7108      	strb	r0, [r1, #4]
 8003a7a:	700a      	strb	r2, [r1, #0]
 8003a7c:	2000      	movs	r0, #0
 8003a7e:	b001      	add	sp, #4
 8003a80:	4770      	bx	lr
	...

08003a84 <PE_Check_ControlMessage>:
 8003a84:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 8003a86:	0004      	movs	r4, r0
 8003a88:	48ca      	ldr	r0, [pc, #808]	; (8003db4 <.text_52>)
 8003a8a:	68c1      	ldr	r1, [r0, #12]
 8003a8c:	9101      	str	r1, [sp, #4]
 8003a8e:	7800      	ldrb	r0, [r0, #0]
 8003a90:	2102      	movs	r1, #2
 8003a92:	4008      	ands	r0, r1
 8003a94:	21d6      	movs	r1, #214	; 0xd6
 8003a96:	0089      	lsls	r1, r1, #2
 8003a98:	1866      	adds	r6, r4, r1
 8003a9a:	2103      	movs	r1, #3
 8003a9c:	2501      	movs	r5, #1
 8003a9e:	222a      	movs	r2, #42	; 0x2a
 8003aa0:	8db3      	ldrh	r3, [r6, #44]	; 0x2c
 8003aa2:	06db      	lsls	r3, r3, #27
 8003aa4:	0edb      	lsrs	r3, r3, #27
 8003aa6:	1e5b      	subs	r3, r3, #1
 8003aa8:	2b14      	cmp	r3, #20
 8003aaa:	d900      	bls.n	8003aae <PE_Check_ControlMessage+0x2a>
 8003aac:	e17b      	b.n	8003da6 <PE_Check_ControlMessage+0x322>
 8003aae:	a702      	add	r7, pc, #8	; (adr r7, 8003ab8 <PE_Check_ControlMessage+0x34>)
 8003ab0:	005b      	lsls	r3, r3, #1
 8003ab2:	5aff      	ldrh	r7, [r7, r3]
 8003ab4:	44bf      	add	pc, r7
 8003ab6:	bf00      	nop
 8003ab8:	002a02fa 	.word	0x002a02fa
 8003abc:	02e802e8 	.word	0x02e802e8
 8003ac0:	02e80090 	.word	0x02e80090
 8003ac4:	01d400ac 	.word	0x01d400ac
 8003ac8:	016e01b8 	.word	0x016e01b8
 8003acc:	02e801a8 	.word	0x02e801a8
 8003ad0:	02ee0064 	.word	0x02ee0064
 8003ad4:	02fa02ee 	.word	0x02fa02ee
 8003ad8:	025e021e 	.word	0x025e021e
 8003adc:	028c02e2 	.word	0x028c02e2
 8003ae0:	02d4      	.short	0x02d4
 8003ae2:	6861      	ldr	r1, [r4, #4]
 8003ae4:	7809      	ldrb	r1, [r1, #0]
 8003ae6:	0889      	lsrs	r1, r1, #2
 8003ae8:	4229      	tst	r1, r5
 8003aea:	d000      	beq.n	8003aee <PE_Check_ControlMessage+0x6a>
 8003aec:	e161      	b.n	8003db2 <PE_Check_ControlMessage+0x32e>
 8003aee:	2102      	movs	r1, #2
 8003af0:	82e1      	strh	r1, [r4, #22]
 8003af2:	2800      	cmp	r0, #0
 8003af4:	d009      	beq.n	8003b0a <PE_Check_ControlMessage+0x86>
 8003af6:	2000      	movs	r0, #0
 8003af8:	9000      	str	r0, [sp, #0]
 8003afa:	2300      	movs	r3, #0
 8003afc:	2229      	movs	r2, #41	; 0x29
 8003afe:	68e0      	ldr	r0, [r4, #12]
 8003b00:	2101      	movs	r1, #1
 8003b02:	4001      	ands	r1, r0
 8003b04:	2009      	movs	r0, #9
 8003b06:	9f01      	ldr	r7, [sp, #4]
 8003b08:	47b8      	blx	r7
 8003b0a:	2129      	movs	r1, #41	; 0x29
 8003b0c:	68e0      	ldr	r0, [r4, #12]
 8003b0e:	4005      	ands	r5, r0
 8003b10:	0028      	movs	r0, r5
 8003b12:	68a2      	ldr	r2, [r4, #8]
 8003b14:	68d2      	ldr	r2, [r2, #12]
 8003b16:	4790      	blx	r2
 8003b18:	2098      	movs	r0, #152	; 0x98
 8003b1a:	e142      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003b1c:	82e1      	strh	r1, [r4, #22]
 8003b1e:	2800      	cmp	r0, #0
 8003b20:	d009      	beq.n	8003b36 <PE_Check_ControlMessage+0xb2>
 8003b22:	2000      	movs	r0, #0
 8003b24:	9000      	str	r0, [sp, #0]
 8003b26:	2300      	movs	r3, #0
 8003b28:	2230      	movs	r2, #48	; 0x30
 8003b2a:	68e0      	ldr	r0, [r4, #12]
 8003b2c:	2101      	movs	r1, #1
 8003b2e:	4001      	ands	r1, r0
 8003b30:	2009      	movs	r0, #9
 8003b32:	9f01      	ldr	r7, [sp, #4]
 8003b34:	47b8      	blx	r7
 8003b36:	2130      	movs	r1, #48	; 0x30
 8003b38:	68e0      	ldr	r0, [r4, #12]
 8003b3a:	4005      	ands	r5, r0
 8003b3c:	0028      	movs	r0, r5
 8003b3e:	68a2      	ldr	r2, [r4, #8]
 8003b40:	68d2      	ldr	r2, [r2, #12]
 8003b42:	4790      	blx	r2
 8003b44:	2010      	movs	r0, #16
 8003b46:	e12c      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003b48:	2800      	cmp	r0, #0
 8003b4a:	d009      	beq.n	8003b60 <PE_Check_ControlMessage+0xdc>
 8003b4c:	2000      	movs	r0, #0
 8003b4e:	9000      	str	r0, [sp, #0]
 8003b50:	2300      	movs	r3, #0
 8003b52:	2231      	movs	r2, #49	; 0x31
 8003b54:	68e0      	ldr	r0, [r4, #12]
 8003b56:	2101      	movs	r1, #1
 8003b58:	4001      	ands	r1, r0
 8003b5a:	2009      	movs	r0, #9
 8003b5c:	9e01      	ldr	r6, [sp, #4]
 8003b5e:	47b0      	blx	r6
 8003b60:	2131      	movs	r1, #49	; 0x31
 8003b62:	e10c      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003b64:	2306      	movs	r3, #6
 8003b66:	82e3      	strh	r3, [r4, #22]
 8003b68:	466b      	mov	r3, sp
 8003b6a:	6867      	ldr	r7, [r4, #4]
 8003b6c:	783f      	ldrb	r7, [r7, #0]
 8003b6e:	701f      	strb	r7, [r3, #0]
 8003b70:	463b      	mov	r3, r7
 8003b72:	089f      	lsrs	r7, r3, #2
 8003b74:	422f      	tst	r7, r5
 8003b76:	d04d      	beq.n	8003c14 <PE_Check_ControlMessage+0x190>
 8003b78:	2800      	cmp	r0, #0
 8003b7a:	d009      	beq.n	8003b90 <PE_Check_ControlMessage+0x10c>
 8003b7c:	2000      	movs	r0, #0
 8003b7e:	9000      	str	r0, [sp, #0]
 8003b80:	2300      	movs	r3, #0
 8003b82:	220c      	movs	r2, #12
 8003b84:	68e0      	ldr	r0, [r4, #12]
 8003b86:	2101      	movs	r1, #1
 8003b88:	4001      	ands	r1, r0
 8003b8a:	2009      	movs	r0, #9
 8003b8c:	9f01      	ldr	r7, [sp, #4]
 8003b8e:	47b8      	blx	r7
 8003b90:	210c      	movs	r1, #12
 8003b92:	68e2      	ldr	r2, [r4, #12]
 8003b94:	2001      	movs	r0, #1
 8003b96:	4010      	ands	r0, r2
 8003b98:	68a2      	ldr	r2, [r4, #8]
 8003b9a:	68d2      	ldr	r2, [r2, #12]
 8003b9c:	4790      	blx	r2
 8003b9e:	2100      	movs	r1, #0
 8003ba0:	0020      	movs	r0, r4
 8003ba2:	f7ff fd8c 	bl	80036be <PE_Send_SRCCapabilities>
 8003ba6:	2805      	cmp	r0, #5
 8003ba8:	d002      	beq.n	8003bb0 <PE_Check_ControlMessage+0x12c>
 8003baa:	2000      	movs	r0, #0
 8003bac:	82e0      	strh	r0, [r4, #22]
 8003bae:	e0f7      	b.n	8003da0 <PE_Check_ControlMessage+0x31c>
 8003bb0:	6860      	ldr	r0, [r4, #4]
 8003bb2:	7841      	ldrb	r1, [r0, #1]
 8003bb4:	228f      	movs	r2, #143	; 0x8f
 8003bb6:	400a      	ands	r2, r1
 8003bb8:	2140      	movs	r1, #64	; 0x40
 8003bba:	4311      	orrs	r1, r2
 8003bbc:	7041      	strb	r1, [r0, #1]
 8003bbe:	487d      	ldr	r0, [pc, #500]	; (8003db4 <.text_52>)
 8003bc0:	7800      	ldrb	r0, [r0, #0]
 8003bc2:	0780      	lsls	r0, r0, #30
 8003bc4:	d50a      	bpl.n	8003bdc <PE_Check_ControlMessage+0x158>
 8003bc6:	2000      	movs	r0, #0
 8003bc8:	9000      	str	r0, [sp, #0]
 8003bca:	2300      	movs	r3, #0
 8003bcc:	2256      	movs	r2, #86	; 0x56
 8003bce:	68e0      	ldr	r0, [r4, #12]
 8003bd0:	2101      	movs	r1, #1
 8003bd2:	4001      	ands	r1, r0
 8003bd4:	2009      	movs	r0, #9
 8003bd6:	4f77      	ldr	r7, [pc, #476]	; (8003db4 <.text_52>)
 8003bd8:	68ff      	ldr	r7, [r7, #12]
 8003bda:	47b8      	blx	r7
 8003bdc:	2156      	movs	r1, #86	; 0x56
 8003bde:	68e2      	ldr	r2, [r4, #12]
 8003be0:	2001      	movs	r0, #1
 8003be2:	4010      	ands	r0, r2
 8003be4:	68a2      	ldr	r2, [r4, #8]
 8003be6:	68d2      	ldr	r2, [r2, #12]
 8003be8:	4790      	blx	r2
 8003bea:	82e5      	strh	r5, [r4, #22]
 8003bec:	4872      	ldr	r0, [pc, #456]	; (8003db8 <.text_53>)
 8003bee:	82b0      	strh	r0, [r6, #20]
 8003bf0:	2016      	movs	r0, #22
 8003bf2:	7030      	strb	r0, [r6, #0]
 8003bf4:	4e6f      	ldr	r6, [pc, #444]	; (8003db4 <.text_52>)
 8003bf6:	7830      	ldrb	r0, [r6, #0]
 8003bf8:	0780      	lsls	r0, r0, #30
 8003bfa:	d509      	bpl.n	8003c10 <PE_Check_ControlMessage+0x18c>
 8003bfc:	2000      	movs	r0, #0
 8003bfe:	9000      	str	r0, [sp, #0]
 8003c00:	2300      	movs	r3, #0
 8003c02:	220f      	movs	r2, #15
 8003c04:	68e0      	ldr	r0, [r4, #12]
 8003c06:	2101      	movs	r1, #1
 8003c08:	4001      	ands	r1, r0
 8003c0a:	2009      	movs	r0, #9
 8003c0c:	68f6      	ldr	r6, [r6, #12]
 8003c0e:	47b0      	blx	r6
 8003c10:	210f      	movs	r1, #15
 8003c12:	e0b4      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003c14:	6820      	ldr	r0, [r4, #0]
 8003c16:	6840      	ldr	r0, [r0, #4]
 8003c18:	08c0      	lsrs	r0, r0, #3
 8003c1a:	4028      	ands	r0, r5
 8003c1c:	d001      	beq.n	8003c22 <PE_Check_ControlMessage+0x19e>
 8003c1e:	204c      	movs	r0, #76	; 0x4c
 8003c20:	e0bf      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003c22:	4019      	ands	r1, r3
 8003c24:	e02b      	b.n	8003c7e <PE_Check_ControlMessage+0x1fa>
 8003c26:	6823      	ldr	r3, [r4, #0]
 8003c28:	685b      	ldr	r3, [r3, #4]
 8003c2a:	08db      	lsrs	r3, r3, #3
 8003c2c:	402b      	ands	r3, r5
 8003c2e:	d023      	beq.n	8003c78 <PE_Check_ControlMessage+0x1f4>
 8003c30:	2122      	movs	r1, #34	; 0x22
 8003c32:	7031      	strb	r1, [r6, #0]
 8003c34:	2800      	cmp	r0, #0
 8003c36:	d009      	beq.n	8003c4c <PE_Check_ControlMessage+0x1c8>
 8003c38:	2000      	movs	r0, #0
 8003c3a:	9000      	str	r0, [sp, #0]
 8003c3c:	2300      	movs	r3, #0
 8003c3e:	223a      	movs	r2, #58	; 0x3a
 8003c40:	68e0      	ldr	r0, [r4, #12]
 8003c42:	2101      	movs	r1, #1
 8003c44:	4001      	ands	r1, r0
 8003c46:	2009      	movs	r0, #9
 8003c48:	9e01      	ldr	r6, [sp, #4]
 8003c4a:	47b0      	blx	r6
 8003c4c:	213a      	movs	r1, #58	; 0x3a
 8003c4e:	68e0      	ldr	r0, [r4, #12]
 8003c50:	4005      	ands	r5, r0
 8003c52:	0028      	movs	r0, r5
 8003c54:	68a2      	ldr	r2, [r4, #8]
 8003c56:	68d2      	ldr	r2, [r2, #12]
 8003c58:	4790      	blx	r2
 8003c5a:	2008      	movs	r0, #8
 8003c5c:	82e0      	strh	r0, [r4, #22]
 8003c5e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003c60:	68a0      	ldr	r0, [r4, #8]
 8003c62:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8003c64:	2800      	cmp	r0, #0
 8003c66:	d007      	beq.n	8003c78 <PE_Check_ControlMessage+0x1f4>
 8003c68:	2010      	movs	r0, #16
 8003c6a:	82e0      	strh	r0, [r4, #22]
 8003c6c:	209d      	movs	r0, #157	; 0x9d
 8003c6e:	e098      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003c70:	68a0      	ldr	r0, [r4, #8]
 8003c72:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 8003c74:	2800      	cmp	r0, #0
 8003c76:	d105      	bne.n	8003c84 <PE_Check_ControlMessage+0x200>
 8003c78:	6860      	ldr	r0, [r4, #4]
 8003c7a:	7800      	ldrb	r0, [r0, #0]
 8003c7c:	4001      	ands	r1, r0
 8003c7e:	2902      	cmp	r1, #2
 8003c80:	d127      	bne.n	8003cd2 <PE_Check_ControlMessage+0x24e>
 8003c82:	e095      	b.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003c84:	200f      	movs	r0, #15
 8003c86:	82e0      	strh	r0, [r4, #22]
 8003c88:	2093      	movs	r0, #147	; 0x93
 8003c8a:	e08a      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003c8c:	2307      	movs	r3, #7
 8003c8e:	82e3      	strh	r3, [r4, #22]
 8003c90:	466b      	mov	r3, sp
 8003c92:	6867      	ldr	r7, [r4, #4]
 8003c94:	783f      	ldrb	r7, [r7, #0]
 8003c96:	701f      	strb	r7, [r3, #0]
 8003c98:	08bf      	lsrs	r7, r7, #2
 8003c9a:	422f      	tst	r7, r5
 8003c9c:	d004      	beq.n	8003ca8 <PE_Check_ControlMessage+0x224>
 8003c9e:	6823      	ldr	r3, [r4, #0]
 8003ca0:	685b      	ldr	r3, [r3, #4]
 8003ca2:	08db      	lsrs	r3, r3, #3
 8003ca4:	402b      	ands	r3, r5
 8003ca6:	d00f      	beq.n	8003cc8 <PE_Check_ControlMessage+0x244>
 8003ca8:	211d      	movs	r1, #29
 8003caa:	7031      	strb	r1, [r6, #0]
 8003cac:	2800      	cmp	r0, #0
 8003cae:	d009      	beq.n	8003cc4 <PE_Check_ControlMessage+0x240>
 8003cb0:	2000      	movs	r0, #0
 8003cb2:	9000      	str	r0, [sp, #0]
 8003cb4:	2300      	movs	r3, #0
 8003cb6:	2206      	movs	r2, #6
 8003cb8:	68e0      	ldr	r0, [r4, #12]
 8003cba:	2101      	movs	r1, #1
 8003cbc:	4001      	ands	r1, r0
 8003cbe:	2009      	movs	r0, #9
 8003cc0:	9e01      	ldr	r6, [sp, #4]
 8003cc2:	47b0      	blx	r6
 8003cc4:	2106      	movs	r1, #6
 8003cc6:	e05a      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003cc8:	4668      	mov	r0, sp
 8003cca:	7800      	ldrb	r0, [r0, #0]
 8003ccc:	4001      	ands	r1, r0
 8003cce:	2902      	cmp	r1, #2
 8003cd0:	d06e      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003cd2:	7032      	strb	r2, [r6, #0]
 8003cd4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003cd6:	6821      	ldr	r1, [r4, #0]
 8003cd8:	88ca      	ldrh	r2, [r1, #6]
 8003cda:	08d2      	lsrs	r2, r2, #3
 8003cdc:	422a      	tst	r2, r5
 8003cde:	d067      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003ce0:	6862      	ldr	r2, [r4, #4]
 8003ce2:	7812      	ldrb	r2, [r2, #0]
 8003ce4:	0892      	lsrs	r2, r2, #2
 8003ce6:	422a      	tst	r2, r5
 8003ce8:	d103      	bne.n	8003cf2 <PE_Check_ControlMessage+0x26e>
 8003cea:	6849      	ldr	r1, [r1, #4]
 8003cec:	08c9      	lsrs	r1, r1, #3
 8003cee:	4029      	ands	r1, r5
 8003cf0:	d05e      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003cf2:	210a      	movs	r1, #10
 8003cf4:	82e1      	strh	r1, [r4, #22]
 8003cf6:	2163      	movs	r1, #99	; 0x63
 8003cf8:	7031      	strb	r1, [r6, #0]
 8003cfa:	2800      	cmp	r0, #0
 8003cfc:	d009      	beq.n	8003d12 <PE_Check_ControlMessage+0x28e>
 8003cfe:	2000      	movs	r0, #0
 8003d00:	9000      	str	r0, [sp, #0]
 8003d02:	2300      	movs	r3, #0
 8003d04:	2243      	movs	r2, #67	; 0x43
 8003d06:	68e0      	ldr	r0, [r4, #12]
 8003d08:	2101      	movs	r1, #1
 8003d0a:	4001      	ands	r1, r0
 8003d0c:	2009      	movs	r0, #9
 8003d0e:	9e01      	ldr	r6, [sp, #4]
 8003d10:	47b0      	blx	r6
 8003d12:	2143      	movs	r1, #67	; 0x43
 8003d14:	e033      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003d16:	6821      	ldr	r1, [r4, #0]
 8003d18:	88c9      	ldrh	r1, [r1, #6]
 8003d1a:	0949      	lsrs	r1, r1, #5
 8003d1c:	4229      	tst	r1, r5
 8003d1e:	d047      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003d20:	210b      	movs	r1, #11
 8003d22:	82e1      	strh	r1, [r4, #22]
 8003d24:	2130      	movs	r1, #48	; 0x30
 8003d26:	7031      	strb	r1, [r6, #0]
 8003d28:	2800      	cmp	r0, #0
 8003d2a:	d009      	beq.n	8003d40 <PE_Check_ControlMessage+0x2bc>
 8003d2c:	2000      	movs	r0, #0
 8003d2e:	9000      	str	r0, [sp, #0]
 8003d30:	2300      	movs	r3, #0
 8003d32:	224a      	movs	r2, #74	; 0x4a
 8003d34:	68e0      	ldr	r0, [r4, #12]
 8003d36:	2101      	movs	r1, #1
 8003d38:	4001      	ands	r1, r0
 8003d3a:	2009      	movs	r0, #9
 8003d3c:	9e01      	ldr	r6, [sp, #4]
 8003d3e:	47b0      	blx	r6
 8003d40:	214a      	movs	r1, #74	; 0x4a
 8003d42:	e01c      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003d44:	6821      	ldr	r1, [r4, #0]
 8003d46:	88c9      	ldrh	r1, [r1, #6]
 8003d48:	0889      	lsrs	r1, r1, #2
 8003d4a:	4229      	tst	r1, r5
 8003d4c:	d030      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003d4e:	210b      	movs	r1, #11
 8003d50:	82e1      	strh	r1, [r4, #22]
 8003d52:	6861      	ldr	r1, [r4, #4]
 8003d54:	7809      	ldrb	r1, [r1, #0]
 8003d56:	0889      	lsrs	r1, r1, #2
 8003d58:	4229      	tst	r1, r5
 8003d5a:	d001      	beq.n	8003d60 <PE_Check_ControlMessage+0x2dc>
 8003d5c:	212d      	movs	r1, #45	; 0x2d
 8003d5e:	e000      	b.n	8003d62 <PE_Check_ControlMessage+0x2de>
 8003d60:	2111      	movs	r1, #17
 8003d62:	7031      	strb	r1, [r6, #0]
 8003d64:	2800      	cmp	r0, #0
 8003d66:	d009      	beq.n	8003d7c <PE_Check_ControlMessage+0x2f8>
 8003d68:	2000      	movs	r0, #0
 8003d6a:	9000      	str	r0, [sp, #0]
 8003d6c:	2300      	movs	r3, #0
 8003d6e:	2246      	movs	r2, #70	; 0x46
 8003d70:	68e0      	ldr	r0, [r4, #12]
 8003d72:	2101      	movs	r1, #1
 8003d74:	4001      	ands	r1, r0
 8003d76:	2009      	movs	r0, #9
 8003d78:	9e01      	ldr	r6, [sp, #4]
 8003d7a:	47b0      	blx	r6
 8003d7c:	2146      	movs	r1, #70	; 0x46
 8003d7e:	68e0      	ldr	r0, [r4, #12]
 8003d80:	4005      	ands	r5, r0
 8003d82:	0028      	movs	r0, r5
 8003d84:	68a2      	ldr	r2, [r4, #8]
 8003d86:	68d2      	ldr	r2, [r2, #12]
 8003d88:	4790      	blx	r2
 8003d8a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003d8c:	6820      	ldr	r0, [r4, #0]
 8003d8e:	88c0      	ldrh	r0, [r0, #6]
 8003d90:	0a00      	lsrs	r0, r0, #8
 8003d92:	4228      	tst	r0, r5
 8003d94:	d00c      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003d96:	202f      	movs	r0, #47	; 0x2f
 8003d98:	e003      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003d9a:	2009      	movs	r0, #9
 8003d9c:	82e0      	strh	r0, [r4, #22]
 8003d9e:	e007      	b.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003da0:	2011      	movs	r0, #17
 8003da2:	7030      	strb	r0, [r6, #0]
 8003da4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003da6:	6860      	ldr	r0, [r4, #4]
 8003da8:	7800      	ldrb	r0, [r0, #0]
 8003daa:	4001      	ands	r1, r0
 8003dac:	2902      	cmp	r1, #2
 8003dae:	d100      	bne.n	8003db2 <PE_Check_ControlMessage+0x32e>
 8003db0:	7035      	strb	r5, [r6, #0]
 8003db2:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

08003db4 <.text_52>:
 8003db4:	200019ac 	.word	0x200019ac

08003db8 <.text_53>:
 8003db8:	0000801a 	.word	0x0000801a

08003dbc <PE_Check_DataMessage>:
 8003dbc:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 8003dbe:	0004      	movs	r4, r0
 8003dc0:	209e      	movs	r0, #158	; 0x9e
 8003dc2:	0040      	lsls	r0, r0, #1
 8003dc4:	1827      	adds	r7, r4, r0
 8003dc6:	20d6      	movs	r0, #214	; 0xd6
 8003dc8:	0080      	lsls	r0, r0, #2
 8003dca:	1826      	adds	r6, r4, r0
 8003dcc:	2501      	movs	r5, #1
 8003dce:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 8003dd0:	06c0      	lsls	r0, r0, #27
 8003dd2:	0ec0      	lsrs	r0, r0, #27
 8003dd4:	2801      	cmp	r0, #1
 8003dd6:	d02f      	beq.n	8003e38 <PE_Check_DataMessage+0x7c>
 8003dd8:	2802      	cmp	r0, #2
 8003dda:	d009      	beq.n	8003df0 <PE_Check_DataMessage+0x34>
 8003ddc:	2803      	cmp	r0, #3
 8003dde:	d047      	beq.n	8003e70 <PE_Check_DataMessage+0xb4>
 8003de0:	2806      	cmp	r0, #6
 8003de2:	d07d      	beq.n	8003ee0 <PE_Check_DataMessage+0x124>
 8003de4:	2807      	cmp	r0, #7
 8003de6:	d100      	bne.n	8003dea <PE_Check_DataMessage+0x2e>
 8003de8:	e08a      	b.n	8003f00 <PE_Check_DataMessage+0x144>
 8003dea:	280f      	cmp	r0, #15
 8003dec:	d071      	beq.n	8003ed2 <PE_Check_DataMessage+0x116>
 8003dee:	e090      	b.n	8003f12 <PE_Check_DataMessage+0x156>
 8003df0:	6860      	ldr	r0, [r4, #4]
 8003df2:	7800      	ldrb	r0, [r0, #0]
 8003df4:	0880      	lsrs	r0, r0, #2
 8003df6:	4228      	tst	r0, r5
 8003df8:	d100      	bne.n	8003dfc <PE_Check_DataMessage+0x40>
 8003dfa:	e08c      	b.n	8003f16 <PE_Check_DataMessage+0x15a>
 8003dfc:	7838      	ldrb	r0, [r7, #0]
 8003dfe:	7879      	ldrb	r1, [r7, #1]
 8003e00:	0209      	lsls	r1, r1, #8
 8003e02:	1840      	adds	r0, r0, r1
 8003e04:	78b9      	ldrb	r1, [r7, #2]
 8003e06:	0409      	lsls	r1, r1, #16
 8003e08:	1840      	adds	r0, r0, r1
 8003e0a:	78f9      	ldrb	r1, [r7, #3]
 8003e0c:	0609      	lsls	r1, r1, #24
 8003e0e:	1840      	adds	r0, r0, r1
 8003e10:	9000      	str	r0, [sp, #0]
 8003e12:	2304      	movs	r3, #4
 8003e14:	466a      	mov	r2, sp
 8003e16:	2106      	movs	r1, #6
 8003e18:	68e7      	ldr	r7, [r4, #12]
 8003e1a:	2001      	movs	r0, #1
 8003e1c:	4038      	ands	r0, r7
 8003e1e:	68a7      	ldr	r7, [r4, #8]
 8003e20:	69ff      	ldr	r7, [r7, #28]
 8003e22:	47b8      	blx	r7
 8003e24:	82e5      	strh	r5, [r4, #22]
 8003e26:	8d70      	ldrh	r0, [r6, #42]	; 0x2a
 8003e28:	0440      	lsls	r0, r0, #17
 8003e2a:	0c40      	lsrs	r0, r0, #17
 8003e2c:	2801      	cmp	r0, #1
 8003e2e:	db01      	blt.n	8003e34 <PE_Check_DataMessage+0x78>
 8003e30:	2000      	movs	r0, #0
 8003e32:	8570      	strh	r0, [r6, #42]	; 0x2a
 8003e34:	2009      	movs	r0, #9
 8003e36:	e06d      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003e38:	6860      	ldr	r0, [r4, #4]
 8003e3a:	7800      	ldrb	r0, [r0, #0]
 8003e3c:	0880      	lsrs	r0, r0, #2
 8003e3e:	4228      	tst	r0, r5
 8003e40:	d169      	bne.n	8003f16 <PE_Check_DataMessage+0x15a>
 8003e42:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 8003e44:	0600      	lsls	r0, r0, #24
 8003e46:	0f81      	lsrs	r1, r0, #30
 8003e48:	68e2      	ldr	r2, [r4, #12]
 8003e4a:	2001      	movs	r0, #1
 8003e4c:	4010      	ands	r0, r2
 8003e4e:	f000 fabf 	bl	80043d0 <PE_ExtRevisionInteroperability>
 8003e52:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 8003e54:	0440      	lsls	r0, r0, #17
 8003e56:	0f40      	lsrs	r0, r0, #29
 8003e58:	0083      	lsls	r3, r0, #2
 8003e5a:	003a      	movs	r2, r7
 8003e5c:	2104      	movs	r1, #4
 8003e5e:	68e7      	ldr	r7, [r4, #12]
 8003e60:	2001      	movs	r0, #1
 8003e62:	4038      	ands	r0, r7
 8003e64:	68a7      	ldr	r7, [r4, #8]
 8003e66:	69ff      	ldr	r7, [r7, #28]
 8003e68:	47b8      	blx	r7
 8003e6a:	82e5      	strh	r5, [r4, #22]
 8003e6c:	2044      	movs	r0, #68	; 0x44
 8003e6e:	e051      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003e70:	2000      	movs	r0, #0
 8003e72:	9001      	str	r0, [sp, #4]
 8003e74:	9000      	str	r0, [sp, #0]
 8003e76:	7838      	ldrb	r0, [r7, #0]
 8003e78:	7879      	ldrb	r1, [r7, #1]
 8003e7a:	0209      	lsls	r1, r1, #8
 8003e7c:	1840      	adds	r0, r0, r1
 8003e7e:	78b9      	ldrb	r1, [r7, #2]
 8003e80:	0409      	lsls	r1, r1, #16
 8003e82:	1840      	adds	r0, r0, r1
 8003e84:	78f9      	ldrb	r1, [r7, #3]
 8003e86:	0609      	lsls	r1, r1, #24
 8003e88:	1847      	adds	r7, r0, r1
 8003e8a:	466b      	mov	r3, sp
 8003e8c:	aa01      	add	r2, sp, #4
 8003e8e:	2103      	movs	r1, #3
 8003e90:	68e0      	ldr	r0, [r4, #12]
 8003e92:	4005      	ands	r5, r0
 8003e94:	0028      	movs	r0, r5
 8003e96:	68a5      	ldr	r5, [r4, #8]
 8003e98:	69ad      	ldr	r5, [r5, #24]
 8003e9a:	47a8      	blx	r5
 8003e9c:	9800      	ldr	r0, [sp, #0]
 8003e9e:	2804      	cmp	r0, #4
 8003ea0:	d115      	bne.n	8003ece <PE_Check_DataMessage+0x112>
 8003ea2:	6860      	ldr	r0, [r4, #4]
 8003ea4:	7840      	ldrb	r0, [r0, #1]
 8003ea6:	0640      	lsls	r0, r0, #25
 8003ea8:	0f40      	lsrs	r0, r0, #29
 8003eaa:	2803      	cmp	r0, #3
 8003eac:	d10f      	bne.n	8003ece <PE_Check_DataMessage+0x112>
 8003eae:	9801      	ldr	r0, [sp, #4]
 8003eb0:	49b4      	ldr	r1, [pc, #720]	; (8004184 <.text_57>)
 8003eb2:	4288      	cmp	r0, r1
 8003eb4:	d10b      	bne.n	8003ece <PE_Check_DataMessage+0x112>
 8003eb6:	0f38      	lsrs	r0, r7, #28
 8003eb8:	d003      	beq.n	8003ec2 <PE_Check_DataMessage+0x106>
 8003eba:	2805      	cmp	r0, #5
 8003ebc:	d003      	beq.n	8003ec6 <PE_Check_DataMessage+0x10a>
 8003ebe:	2808      	cmp	r0, #8
 8003ec0:	d103      	bne.n	8003eca <PE_Check_DataMessage+0x10e>
 8003ec2:	2029      	movs	r0, #41	; 0x29
 8003ec4:	e026      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003ec6:	2027      	movs	r0, #39	; 0x27
 8003ec8:	e024      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003eca:	202a      	movs	r0, #42	; 0x2a
 8003ecc:	e022      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003ece:	2003      	movs	r0, #3
 8003ed0:	e020      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003ed2:	6860      	ldr	r0, [r4, #4]
 8003ed4:	7800      	ldrb	r0, [r0, #0]
 8003ed6:	0780      	lsls	r0, r0, #30
 8003ed8:	0f80      	lsrs	r0, r0, #30
 8003eda:	2802      	cmp	r0, #2
 8003edc:	d11b      	bne.n	8003f16 <PE_Check_DataMessage+0x15a>
 8003ede:	e016      	b.n	8003f0e <PE_Check_DataMessage+0x152>
 8003ee0:	6820      	ldr	r0, [r4, #0]
 8003ee2:	88c0      	ldrh	r0, [r0, #6]
 8003ee4:	0900      	lsrs	r0, r0, #4
 8003ee6:	4228      	tst	r0, r5
 8003ee8:	d011      	beq.n	8003f0e <PE_Check_DataMessage+0x152>
 8003eea:	2304      	movs	r3, #4
 8003eec:	003a      	movs	r2, r7
 8003eee:	210b      	movs	r1, #11
 8003ef0:	68e0      	ldr	r0, [r4, #12]
 8003ef2:	4005      	ands	r5, r0
 8003ef4:	0028      	movs	r0, r5
 8003ef6:	68a4      	ldr	r4, [r4, #8]
 8003ef8:	69e4      	ldr	r4, [r4, #28]
 8003efa:	47a0      	blx	r4
 8003efc:	202c      	movs	r0, #44	; 0x2c
 8003efe:	e009      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003f00:	6820      	ldr	r0, [r4, #0]
 8003f02:	88c0      	ldrh	r0, [r0, #6]
 8003f04:	0a40      	lsrs	r0, r0, #9
 8003f06:	4228      	tst	r0, r5
 8003f08:	d001      	beq.n	8003f0e <PE_Check_DataMessage+0x152>
 8003f0a:	203d      	movs	r0, #61	; 0x3d
 8003f0c:	e002      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003f0e:	7035      	strb	r5, [r6, #0]
 8003f10:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003f12:	2011      	movs	r0, #17
 8003f14:	7030      	strb	r0, [r6, #0]
 8003f16:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

08003f18 <PE_Check_ExtendedMessage>:
 8003f18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003f1a:	0005      	movs	r5, r0
 8003f1c:	209e      	movs	r0, #158	; 0x9e
 8003f1e:	0040      	lsls	r0, r0, #1
 8003f20:	1828      	adds	r0, r5, r0
 8003f22:	7801      	ldrb	r1, [r0, #0]
 8003f24:	7840      	ldrb	r0, [r0, #1]
 8003f26:	0200      	lsls	r0, r0, #8
 8003f28:	1808      	adds	r0, r1, r0
 8003f2a:	21e4      	movs	r1, #228	; 0xe4
 8003f2c:	0089      	lsls	r1, r1, #2
 8003f2e:	1869      	adds	r1, r5, r1
 8003f30:	8008      	strh	r0, [r1, #0]
 8003f32:	4a95      	ldr	r2, [pc, #596]	; (8004188 <.text_58>)
 8003f34:	18ac      	adds	r4, r5, r2
 8003f36:	8f62      	ldrh	r2, [r4, #58]	; 0x3a
 8003f38:	06d2      	lsls	r2, r2, #27
 8003f3a:	0ed2      	lsrs	r2, r2, #27
 8003f3c:	2380      	movs	r3, #128	; 0x80
 8003f3e:	4313      	orrs	r3, r2
 8003f40:	708b      	strb	r3, [r1, #2]
 8003f42:	2601      	movs	r6, #1
 8003f44:	0402      	lsls	r2, r0, #16
 8003f46:	0e92      	lsrs	r2, r2, #26
 8003f48:	2101      	movs	r1, #1
 8003f4a:	4011      	ands	r1, r2
 8003f4c:	0402      	lsls	r2, r0, #16
 8003f4e:	0ed2      	lsrs	r2, r2, #27
 8003f50:	0712      	lsls	r2, r2, #28
 8003f52:	d003      	beq.n	8003f5c <PE_Check_ExtendedMessage+0x44>
 8003f54:	000a      	movs	r2, r1
 8003f56:	d001      	beq.n	8003f5c <PE_Check_ExtendedMessage+0x44>
 8003f58:	2034      	movs	r0, #52	; 0x34
 8003f5a:	e0a7      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8003f5c:	05c2      	lsls	r2, r0, #23
 8003f5e:	0dd2      	lsrs	r2, r2, #23
 8003f60:	0403      	lsls	r3, r0, #16
 8003f62:	0fdb      	lsrs	r3, r3, #31
 8003f64:	d10c      	bne.n	8003f80 <PE_Check_ExtendedMessage+0x68>
 8003f66:	8022      	strh	r2, [r4, #0]
 8003f68:	2000      	movs	r0, #0
 8003f6a:	2336      	movs	r3, #54	; 0x36
 8003f6c:	8821      	ldrh	r1, [r4, #0]
 8003f6e:	4288      	cmp	r0, r1
 8003f70:	d218      	bcs.n	8003fa4 <PE_Check_ExtendedMessage+0x8c>
 8003f72:	1829      	adds	r1, r5, r0
 8003f74:	229f      	movs	r2, #159	; 0x9f
 8003f76:	0052      	lsls	r2, r2, #1
 8003f78:	5c8a      	ldrb	r2, [r1, r2]
 8003f7a:	54ca      	strb	r2, [r1, r3]
 8003f7c:	1c40      	adds	r0, r0, #1
 8003f7e:	e7f5      	b.n	8003f6c <PE_Check_ExtendedMessage+0x54>
 8003f80:	23f8      	movs	r3, #248	; 0xf8
 8003f82:	01db      	lsls	r3, r3, #7
 8003f84:	4003      	ands	r3, r0
 8003f86:	d108      	bne.n	8003f9a <PE_Check_ExtendedMessage+0x82>
 8003f88:	8f60      	ldrh	r0, [r4, #58]	; 0x3a
 8003f8a:	0440      	lsls	r0, r0, #17
 8003f8c:	0f40      	lsrs	r0, r0, #29
 8003f8e:	2806      	cmp	r0, #6
 8003f90:	dc00      	bgt.n	8003f94 <PE_Check_ExtendedMessage+0x7c>
 8003f92:	e08f      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003f94:	2a1b      	cmp	r2, #27
 8003f96:	d200      	bcs.n	8003f9a <PE_Check_ExtendedMessage+0x82>
 8003f98:	e08c      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003f9a:	2900      	cmp	r1, #0
 8003f9c:	d000      	beq.n	8003fa0 <PE_Check_ExtendedMessage+0x88>
 8003f9e:	e089      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003fa0:	8820      	ldrh	r0, [r4, #0]
 8003fa2:	4290      	cmp	r0, r2
 8003fa4:	d300      	bcc.n	8003fa8 <PE_Check_ExtendedMessage+0x90>
 8003fa6:	e085      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003fa8:	2037      	movs	r0, #55	; 0x37
 8003faa:	e07f      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8003fac:	2305      	movs	r3, #5
 8003fae:	2109      	movs	r1, #9
 8003fb0:	68ef      	ldr	r7, [r5, #12]
 8003fb2:	2001      	movs	r0, #1
 8003fb4:	4038      	ands	r0, r7
 8003fb6:	68af      	ldr	r7, [r5, #8]
 8003fb8:	69ff      	ldr	r7, [r7, #28]
 8003fba:	47b8      	blx	r7
 8003fbc:	2003      	movs	r0, #3
 8003fbe:	73a0      	strb	r0, [r4, #14]
 8003fc0:	4cca      	ldr	r4, [pc, #808]	; (80042ec <.text_61>)
 8003fc2:	7820      	ldrb	r0, [r4, #0]
 8003fc4:	0780      	lsls	r0, r0, #30
 8003fc6:	d509      	bpl.n	8003fdc <PE_Check_ExtendedMessage+0xc4>
 8003fc8:	2000      	movs	r0, #0
 8003fca:	9000      	str	r0, [sp, #0]
 8003fcc:	2300      	movs	r3, #0
 8003fce:	224b      	movs	r2, #75	; 0x4b
 8003fd0:	68e8      	ldr	r0, [r5, #12]
 8003fd2:	2101      	movs	r1, #1
 8003fd4:	4001      	ands	r1, r0
 8003fd6:	2009      	movs	r0, #9
 8003fd8:	68e4      	ldr	r4, [r4, #12]
 8003fda:	47a0      	blx	r4
 8003fdc:	214b      	movs	r1, #75	; 0x4b
 8003fde:	e0a4      	b.n	800412a <PE_Check_ExtendedMessage+0x212>
 8003fe0:	6828      	ldr	r0, [r5, #0]
 8003fe2:	88c0      	ldrh	r0, [r0, #6]
 8003fe4:	0980      	lsrs	r0, r0, #6
 8003fe6:	4230      	tst	r0, r6
 8003fe8:	d062      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8003fea:	2301      	movs	r3, #1
 8003fec:	2110      	movs	r1, #16
 8003fee:	68e8      	ldr	r0, [r5, #12]
 8003ff0:	4006      	ands	r6, r0
 8003ff2:	0030      	movs	r0, r6
 8003ff4:	68ad      	ldr	r5, [r5, #8]
 8003ff6:	69ed      	ldr	r5, [r5, #28]
 8003ff8:	47a8      	blx	r5
 8003ffa:	203a      	movs	r0, #58	; 0x3a
 8003ffc:	e056      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8003ffe:	6828      	ldr	r0, [r5, #0]
 8004000:	88c0      	ldrh	r0, [r0, #6]
 8004002:	0980      	lsrs	r0, r0, #6
 8004004:	4230      	tst	r0, r6
 8004006:	d053      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004008:	2301      	movs	r3, #1
 800400a:	210e      	movs	r1, #14
 800400c:	68e8      	ldr	r0, [r5, #12]
 800400e:	4006      	ands	r6, r0
 8004010:	0030      	movs	r0, r6
 8004012:	68ad      	ldr	r5, [r5, #8]
 8004014:	69ed      	ldr	r5, [r5, #28]
 8004016:	47a8      	blx	r5
 8004018:	203b      	movs	r0, #59	; 0x3b
 800401a:	e047      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 800401c:	6828      	ldr	r0, [r5, #0]
 800401e:	88c0      	ldrh	r0, [r0, #6]
 8004020:	09c0      	lsrs	r0, r0, #7
 8004022:	4230      	tst	r0, r6
 8004024:	d044      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004026:	2302      	movs	r3, #2
 8004028:	210c      	movs	r1, #12
 800402a:	68e8      	ldr	r0, [r5, #12]
 800402c:	4006      	ands	r6, r0
 800402e:	0030      	movs	r0, r6
 8004030:	68ad      	ldr	r5, [r5, #8]
 8004032:	69ed      	ldr	r5, [r5, #28]
 8004034:	47a8      	blx	r5
 8004036:	203c      	movs	r0, #60	; 0x3c
 8004038:	e038      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 800403a:	68a9      	ldr	r1, [r5, #8]
 800403c:	694f      	ldr	r7, [r1, #20]
 800403e:	2f00      	cmp	r7, #0
 8004040:	d036      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004042:	8823      	ldrh	r3, [r4, #0]
 8004044:	002a      	movs	r2, r5
 8004046:	3236      	adds	r2, #54	; 0x36
 8004048:	7881      	ldrb	r1, [r0, #2]
 800404a:	68e8      	ldr	r0, [r5, #12]
 800404c:	4006      	ands	r6, r0
 800404e:	0030      	movs	r0, r6
 8004050:	47b8      	blx	r7
 8004052:	2038      	movs	r0, #56	; 0x38
 8004054:	e02a      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8004056:	6829      	ldr	r1, [r5, #0]
 8004058:	88c9      	ldrh	r1, [r1, #6]
 800405a:	0ac9      	lsrs	r1, r1, #11
 800405c:	4231      	tst	r1, r6
 800405e:	d027      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004060:	68a9      	ldr	r1, [r5, #8]
 8004062:	6949      	ldr	r1, [r1, #20]
 8004064:	2900      	cmp	r1, #0
 8004066:	d116      	bne.n	8004096 <PE_Check_ExtendedMessage+0x17e>
 8004068:	e022      	b.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 800406a:	68a9      	ldr	r1, [r5, #8]
 800406c:	694f      	ldr	r7, [r1, #20]
 800406e:	2f00      	cmp	r7, #0
 8004070:	d01f      	beq.n	80040b2 <PE_Check_ExtendedMessage+0x19a>
 8004072:	8823      	ldrh	r3, [r4, #0]
 8004074:	002a      	movs	r2, r5
 8004076:	3236      	adds	r2, #54	; 0x36
 8004078:	7881      	ldrb	r1, [r0, #2]
 800407a:	68e8      	ldr	r0, [r5, #12]
 800407c:	4006      	ands	r6, r0
 800407e:	0030      	movs	r0, r6
 8004080:	47b8      	blx	r7
 8004082:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
 8004084:	6829      	ldr	r1, [r5, #0]
 8004086:	88c9      	ldrh	r1, [r1, #6]
 8004088:	0a89      	lsrs	r1, r1, #10
 800408a:	4231      	tst	r1, r6
 800408c:	d010      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 800408e:	68a9      	ldr	r1, [r5, #8]
 8004090:	6949      	ldr	r1, [r1, #20]
 8004092:	2900      	cmp	r1, #0
 8004094:	d00c      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004096:	8823      	ldrh	r3, [r4, #0]
 8004098:	002a      	movs	r2, r5
 800409a:	3236      	adds	r2, #54	; 0x36
 800409c:	7881      	ldrb	r1, [r0, #2]
 800409e:	68e8      	ldr	r0, [r5, #12]
 80040a0:	4006      	ands	r6, r0
 80040a2:	0030      	movs	r0, r6
 80040a4:	68ad      	ldr	r5, [r5, #8]
 80040a6:	696d      	ldr	r5, [r5, #20]
 80040a8:	47a8      	blx	r5
 80040aa:	20a5      	movs	r0, #165	; 0xa5
 80040ac:	73a0      	strb	r0, [r4, #14]
 80040ae:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
 80040b0:	73a6      	strb	r6, [r4, #14]
 80040b2:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
 80040b4:	20e4      	movs	r0, #228	; 0xe4
 80040b6:	0080      	lsls	r0, r0, #2
 80040b8:	1828      	adds	r0, r5, r0
 80040ba:	219f      	movs	r1, #159	; 0x9f
 80040bc:	0049      	lsls	r1, r1, #1
 80040be:	186a      	adds	r2, r5, r1
 80040c0:	7881      	ldrb	r1, [r0, #2]
 80040c2:	3981      	subs	r1, #129	; 0x81
 80040c4:	d018      	beq.n	80040f8 <PE_Check_ExtendedMessage+0x1e0>
 80040c6:	1e49      	subs	r1, r1, #1
 80040c8:	d100      	bne.n	80040cc <PE_Check_ExtendedMessage+0x1b4>
 80040ca:	e76f      	b.n	8003fac <PE_Check_ExtendedMessage+0x94>
 80040cc:	1e49      	subs	r1, r1, #1
 80040ce:	d087      	beq.n	8003fe0 <PE_Check_ExtendedMessage+0xc8>
 80040d0:	1e49      	subs	r1, r1, #1
 80040d2:	d094      	beq.n	8003ffe <PE_Check_ExtendedMessage+0xe6>
 80040d4:	1e49      	subs	r1, r1, #1
 80040d6:	d0b0      	beq.n	800403a <PE_Check_ExtendedMessage+0x122>
 80040d8:	1e49      	subs	r1, r1, #1
 80040da:	d09f      	beq.n	800401c <PE_Check_ExtendedMessage+0x104>
 80040dc:	1e49      	subs	r1, r1, #1
 80040de:	d0ac      	beq.n	800403a <PE_Check_ExtendedMessage+0x122>
 80040e0:	1e49      	subs	r1, r1, #1
 80040e2:	d0cf      	beq.n	8004084 <PE_Check_ExtendedMessage+0x16c>
 80040e4:	1e49      	subs	r1, r1, #1
 80040e6:	d0e4      	beq.n	80040b2 <PE_Check_ExtendedMessage+0x19a>
 80040e8:	1e49      	subs	r1, r1, #1
 80040ea:	d0b4      	beq.n	8004056 <PE_Check_ExtendedMessage+0x13e>
 80040ec:	1e49      	subs	r1, r1, #1
 80040ee:	d0bc      	beq.n	800406a <PE_Check_ExtendedMessage+0x152>
 80040f0:	1e89      	subs	r1, r1, #2
 80040f2:	2901      	cmp	r1, #1
 80040f4:	d9a1      	bls.n	800403a <PE_Check_ExtendedMessage+0x122>
 80040f6:	e7db      	b.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 80040f8:	2318      	movs	r3, #24
 80040fa:	2108      	movs	r1, #8
 80040fc:	68ef      	ldr	r7, [r5, #12]
 80040fe:	2001      	movs	r0, #1
 8004100:	4038      	ands	r0, r7
 8004102:	68af      	ldr	r7, [r5, #8]
 8004104:	69ff      	ldr	r7, [r7, #28]
 8004106:	47b8      	blx	r7
 8004108:	2003      	movs	r0, #3
 800410a:	73a0      	strb	r0, [r4, #14]
 800410c:	4c77      	ldr	r4, [pc, #476]	; (80042ec <.text_61>)
 800410e:	7820      	ldrb	r0, [r4, #0]
 8004110:	0780      	lsls	r0, r0, #30
 8004112:	d509      	bpl.n	8004128 <PE_Check_ExtendedMessage+0x210>
 8004114:	2000      	movs	r0, #0
 8004116:	9000      	str	r0, [sp, #0]
 8004118:	2300      	movs	r3, #0
 800411a:	2244      	movs	r2, #68	; 0x44
 800411c:	68e8      	ldr	r0, [r5, #12]
 800411e:	2101      	movs	r1, #1
 8004120:	4001      	ands	r1, r0
 8004122:	2009      	movs	r0, #9
 8004124:	68e4      	ldr	r4, [r4, #12]
 8004126:	47a0      	blx	r4
 8004128:	2144      	movs	r1, #68	; 0x44
 800412a:	68e8      	ldr	r0, [r5, #12]
 800412c:	4006      	ands	r6, r0
 800412e:	0030      	movs	r0, r6
 8004130:	68aa      	ldr	r2, [r5, #8]
 8004132:	68d2      	ldr	r2, [r2, #12]
 8004134:	4790      	blx	r2
 8004136:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}

08004138 <PE_PRL_HardResetReceived>:
 8004138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800413a:	0007      	movs	r7, r0
 800413c:	48cf      	ldr	r0, [pc, #828]	; (800447c <.text_65>)
 800413e:	00b9      	lsls	r1, r7, #2
 8004140:	5844      	ldr	r4, [r0, r1]
 8004142:	48d7      	ldr	r0, [pc, #860]	; (80044a0 <.text_67>)
 8004144:	1825      	adds	r5, r4, r0
 8004146:	2600      	movs	r6, #0
 8004148:	702e      	strb	r6, [r5, #0]
 800414a:	0038      	movs	r0, r7
 800414c:	f001 f982 	bl	8005454 <USBPD_PRL_Reset>
 8004150:	6860      	ldr	r0, [r4, #4]
 8004152:	2101      	movs	r1, #1
 8004154:	7802      	ldrb	r2, [r0, #0]
 8004156:	0892      	lsrs	r2, r2, #2
 8004158:	420a      	tst	r2, r1
 800415a:	d001      	beq.n	8004160 <PE_PRL_HardResetReceived+0x28>
 800415c:	2014      	movs	r0, #20
 800415e:	e005      	b.n	800416c <PE_PRL_HardResetReceived+0x34>
 8004160:	6802      	ldr	r2, [r0, #0]
 8004162:	2310      	movs	r3, #16
 8004164:	4313      	orrs	r3, r2
 8004166:	6003      	str	r3, [r0, #0]
 8004168:	842e      	strh	r6, [r5, #32]
 800416a:	203f      	movs	r0, #63	; 0x3f
 800416c:	70a8      	strb	r0, [r5, #2]
 800416e:	7b60      	ldrb	r0, [r4, #13]
 8004170:	22fc      	movs	r2, #252	; 0xfc
 8004172:	4002      	ands	r2, r0
 8004174:	4311      	orrs	r1, r2
 8004176:	7361      	strb	r1, [r4, #13]
 8004178:	0038      	movs	r0, r7
 800417a:	68a1      	ldr	r1, [r4, #8]
 800417c:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800417e:	4788      	blx	r1
 8004180:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
	...

08004184 <.text_57>:
 8004184:	00001388 	.word	0x00001388

08004188 <.text_58>:
 8004188:	0000034a 	.word	0x0000034a

0800418c <PE_PRL_BistCompleted>:
 800418c:	4770      	bx	lr

0800418e <PE_Reset>:
 800418e:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 8004190:	b084      	sub	sp, #16
 8004192:	000e      	movs	r6, r1
 8004194:	48c8      	ldr	r0, [pc, #800]	; (80044b8 <.text_69>)
 8004196:	1d01      	adds	r1, r0, #4
 8004198:	466a      	mov	r2, sp
 800419a:	7c12      	ldrb	r2, [r2, #16]
 800419c:	0092      	lsls	r2, r2, #2
 800419e:	588c      	ldr	r4, [r1, r2]
 80041a0:	2500      	movs	r5, #0
 80041a2:	9502      	str	r5, [sp, #8]
 80041a4:	68e1      	ldr	r1, [r4, #12]
 80041a6:	2203      	movs	r2, #3
 80041a8:	4391      	bics	r1, r2
 80041aa:	466a      	mov	r2, sp
 80041ac:	7c12      	ldrb	r2, [r2, #16]
 80041ae:	07d3      	lsls	r3, r2, #31
 80041b0:	0fdb      	lsrs	r3, r3, #31
 80041b2:	430b      	orrs	r3, r1
 80041b4:	60e3      	str	r3, [r4, #12]
 80041b6:	6861      	ldr	r1, [r4, #4]
 80041b8:	680a      	ldr	r2, [r1, #0]
 80041ba:	2310      	movs	r3, #16
 80041bc:	439a      	bics	r2, r3
 80041be:	600a      	str	r2, [r1, #0]
 80041c0:	6861      	ldr	r1, [r4, #4]
 80041c2:	784a      	ldrb	r2, [r1, #1]
 80041c4:	238f      	movs	r3, #143	; 0x8f
 80041c6:	4013      	ands	r3, r2
 80041c8:	704b      	strb	r3, [r1, #1]
 80041ca:	7800      	ldrb	r0, [r0, #0]
 80041cc:	0780      	lsls	r0, r0, #30
 80041ce:	d509      	bpl.n	80041e4 <PE_Reset+0x56>
 80041d0:	9500      	str	r5, [sp, #0]
 80041d2:	2300      	movs	r3, #0
 80041d4:	2256      	movs	r2, #86	; 0x56
 80041d6:	7b20      	ldrb	r0, [r4, #12]
 80041d8:	07c1      	lsls	r1, r0, #31
 80041da:	0fc9      	lsrs	r1, r1, #31
 80041dc:	2009      	movs	r0, #9
 80041de:	4fb6      	ldr	r7, [pc, #728]	; (80044b8 <.text_69>)
 80041e0:	68ff      	ldr	r7, [r7, #12]
 80041e2:	47b8      	blx	r7
 80041e4:	4668      	mov	r0, sp
 80041e6:	7006      	strb	r6, [r0, #0]
 80041e8:	2156      	movs	r1, #86	; 0x56
 80041ea:	7b22      	ldrb	r2, [r4, #12]
 80041ec:	07d0      	lsls	r0, r2, #31
 80041ee:	0fc0      	lsrs	r0, r0, #31
 80041f0:	68a2      	ldr	r2, [r4, #8]
 80041f2:	68d2      	ldr	r2, [r2, #12]
 80041f4:	4790      	blx	r2
 80041f6:	48b1      	ldr	r0, [pc, #708]	; (80044bc <.text_70>)
 80041f8:	1826      	adds	r6, r4, r0
 80041fa:	82b5      	strh	r5, [r6, #20]
 80041fc:	82e5      	strh	r5, [r4, #22]
 80041fe:	72b5      	strb	r5, [r6, #10]
 8004200:	4668      	mov	r0, sp
 8004202:	7800      	ldrb	r0, [r0, #0]
 8004204:	2800      	cmp	r0, #0
 8004206:	d100      	bne.n	800420a <PE_Reset+0x7c>
 8004208:	7525      	strb	r5, [r4, #20]
 800420a:	7335      	strb	r5, [r6, #12]
 800420c:	7475      	strb	r5, [r6, #17]
 800420e:	72f5      	strb	r5, [r6, #11]
 8004210:	6860      	ldr	r0, [r4, #4]
 8004212:	7800      	ldrb	r0, [r0, #0]
 8004214:	0880      	lsrs	r0, r0, #2
 8004216:	07c0      	lsls	r0, r0, #31
 8004218:	d51d      	bpl.n	8004256 <PE_Reset+0xc8>
 800421a:	6820      	ldr	r0, [r4, #0]
 800421c:	7900      	ldrb	r0, [r0, #4]
 800421e:	0783      	lsls	r3, r0, #30
 8004220:	0f9b      	lsrs	r3, r3, #30
 8004222:	2201      	movs	r2, #1
 8004224:	2101      	movs	r1, #1
 8004226:	4668      	mov	r0, sp
 8004228:	7c00      	ldrb	r0, [r0, #16]
 800422a:	f000 fe5d 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800422e:	6860      	ldr	r0, [r4, #4]
 8004230:	7801      	ldrb	r1, [r0, #0]
 8004232:	2208      	movs	r2, #8
 8004234:	430a      	orrs	r2, r1
 8004236:	7002      	strb	r2, [r0, #0]
 8004238:	2002      	movs	r0, #2
 800423a:	73b0      	strb	r0, [r6, #14]
 800423c:	2304      	movs	r3, #4
 800423e:	aa02      	add	r2, sp, #8
 8004240:	2102      	movs	r1, #2
 8004242:	4668      	mov	r0, sp
 8004244:	7c00      	ldrb	r0, [r0, #16]
 8004246:	68a7      	ldr	r7, [r4, #8]
 8004248:	69ff      	ldr	r7, [r7, #28]
 800424a:	47b8      	blx	r7
 800424c:	6860      	ldr	r0, [r4, #4]
 800424e:	7800      	ldrb	r0, [r0, #0]
 8004250:	0880      	lsrs	r0, r0, #2
 8004252:	07c0      	lsls	r0, r0, #31
 8004254:	d428      	bmi.n	80042a8 <PE_Reset+0x11a>
 8004256:	6820      	ldr	r0, [r4, #0]
 8004258:	7900      	ldrb	r0, [r0, #4]
 800425a:	0783      	lsls	r3, r0, #30
 800425c:	0f9b      	lsrs	r3, r3, #30
 800425e:	2200      	movs	r2, #0
 8004260:	2100      	movs	r1, #0
 8004262:	4668      	mov	r0, sp
 8004264:	7c00      	ldrb	r0, [r0, #16]
 8004266:	f000 fe3f 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800426a:	6860      	ldr	r0, [r4, #4]
 800426c:	7801      	ldrb	r1, [r0, #0]
 800426e:	22f7      	movs	r2, #247	; 0xf7
 8004270:	400a      	ands	r2, r1
 8004272:	7002      	strb	r2, [r0, #0]
 8004274:	4668      	mov	r0, sp
 8004276:	7800      	ldrb	r0, [r0, #0]
 8004278:	2800      	cmp	r0, #0
 800427a:	d101      	bne.n	8004280 <PE_Reset+0xf2>
 800427c:	203e      	movs	r0, #62	; 0x3e
 800427e:	73b0      	strb	r0, [r6, #14]
 8004280:	7375      	strb	r5, [r6, #13]
 8004282:	2080      	movs	r0, #128	; 0x80
 8004284:	0440      	lsls	r0, r0, #17
 8004286:	9001      	str	r0, [sp, #4]
 8004288:	2304      	movs	r3, #4
 800428a:	aa01      	add	r2, sp, #4
 800428c:	2107      	movs	r1, #7
 800428e:	4668      	mov	r0, sp
 8004290:	7c00      	ldrb	r0, [r0, #16]
 8004292:	68a7      	ldr	r7, [r4, #8]
 8004294:	69ff      	ldr	r7, [r7, #28]
 8004296:	47b8      	blx	r7
 8004298:	2304      	movs	r3, #4
 800429a:	aa02      	add	r2, sp, #8
 800429c:	2102      	movs	r1, #2
 800429e:	4668      	mov	r0, sp
 80042a0:	7c00      	ldrb	r0, [r0, #16]
 80042a2:	68a7      	ldr	r7, [r4, #8]
 80042a4:	69ff      	ldr	r7, [r7, #28]
 80042a6:	47b8      	blx	r7
 80042a8:	8035      	strh	r5, [r6, #0]
 80042aa:	8075      	strh	r5, [r6, #2]
 80042ac:	2124      	movs	r1, #36	; 0x24
 80042ae:	20d8      	movs	r0, #216	; 0xd8
 80042b0:	0080      	lsls	r0, r0, #2
 80042b2:	1820      	adds	r0, r4, r0
 80042b4:	f008 f928 	bl	800c508 <__aeabi_memclr>
 80042b8:	487f      	ldr	r0, [pc, #508]	; (80044b8 <.text_69>)
 80042ba:	68c5      	ldr	r5, [r0, #12]
 80042bc:	2d00      	cmp	r5, #0
 80042be:	d00f      	beq.n	80042e0 <PE_Reset+0x152>
 80042c0:	7800      	ldrb	r0, [r0, #0]
 80042c2:	07c0      	lsls	r0, r0, #31
 80042c4:	d50c      	bpl.n	80042e0 <PE_Reset+0x152>
 80042c6:	7bb2      	ldrb	r2, [r6, #14]
 80042c8:	7bf0      	ldrb	r0, [r6, #15]
 80042ca:	4290      	cmp	r0, r2
 80042cc:	d008      	beq.n	80042e0 <PE_Reset+0x152>
 80042ce:	73f2      	strb	r2, [r6, #15]
 80042d0:	2000      	movs	r0, #0
 80042d2:	9000      	str	r0, [sp, #0]
 80042d4:	2300      	movs	r3, #0
 80042d6:	7b20      	ldrb	r0, [r4, #12]
 80042d8:	07c1      	lsls	r1, r0, #31
 80042da:	0fc9      	lsrs	r1, r1, #31
 80042dc:	2004      	movs	r0, #4
 80042de:	47a8      	blx	r5
 80042e0:	4668      	mov	r0, sp
 80042e2:	7c00      	ldrb	r0, [r0, #16]
 80042e4:	f001 f8b6 	bl	8005454 <USBPD_PRL_Reset>
 80042e8:	b005      	add	sp, #20
 80042ea:	bdf0      	pop	{r4, r5, r6, r7, pc}

080042ec <.text_61>:
 80042ec:	200019ac 	.word	0x200019ac

080042f0 <PE_ResetDuringSwap>:
 80042f0:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 80042f2:	0004      	movs	r4, r0
 80042f4:	2700      	movs	r7, #0
 80042f6:	9701      	str	r7, [sp, #4]
 80042f8:	6860      	ldr	r0, [r4, #4]
 80042fa:	7841      	ldrb	r1, [r0, #1]
 80042fc:	228f      	movs	r2, #143	; 0x8f
 80042fe:	400a      	ands	r2, r1
 8004300:	2110      	movs	r1, #16
 8004302:	4311      	orrs	r1, r2
 8004304:	7041      	strb	r1, [r0, #1]
 8004306:	4d6c      	ldr	r5, [pc, #432]	; (80044b8 <.text_69>)
 8004308:	2601      	movs	r6, #1
 800430a:	7828      	ldrb	r0, [r5, #0]
 800430c:	0780      	lsls	r0, r0, #30
 800430e:	d508      	bpl.n	8004322 <PE_ResetDuringSwap+0x32>
 8004310:	9700      	str	r7, [sp, #0]
 8004312:	2300      	movs	r3, #0
 8004314:	2256      	movs	r2, #86	; 0x56
 8004316:	68e0      	ldr	r0, [r4, #12]
 8004318:	2101      	movs	r1, #1
 800431a:	4001      	ands	r1, r0
 800431c:	2009      	movs	r0, #9
 800431e:	68ed      	ldr	r5, [r5, #12]
 8004320:	47a8      	blx	r5
 8004322:	2156      	movs	r1, #86	; 0x56
 8004324:	68e2      	ldr	r2, [r4, #12]
 8004326:	2001      	movs	r0, #1
 8004328:	4010      	ands	r0, r2
 800432a:	68a2      	ldr	r2, [r4, #8]
 800432c:	68d2      	ldr	r2, [r2, #12]
 800432e:	4790      	blx	r2
 8004330:	4863      	ldr	r0, [pc, #396]	; (80044c0 <.text_71>)
 8004332:	1825      	adds	r5, r4, r0
 8004334:	702f      	strb	r7, [r5, #0]
 8004336:	712f      	strb	r7, [r5, #4]
 8004338:	68e1      	ldr	r1, [r4, #12]
 800433a:	2001      	movs	r0, #1
 800433c:	4008      	ands	r0, r1
 800433e:	6861      	ldr	r1, [r4, #4]
 8004340:	7809      	ldrb	r1, [r1, #0]
 8004342:	0889      	lsrs	r1, r1, #2
 8004344:	4231      	tst	r1, r6
 8004346:	d014      	beq.n	8004372 <PE_ResetDuringSwap+0x82>
 8004348:	f7ff fb14 	bl	8003974 <PE_Get_DataRole>
 800434c:	6861      	ldr	r1, [r4, #4]
 800434e:	7809      	ldrb	r1, [r1, #0]
 8004350:	2303      	movs	r3, #3
 8004352:	400b      	ands	r3, r1
 8004354:	0002      	movs	r2, r0
 8004356:	2101      	movs	r1, #1
 8004358:	68e7      	ldr	r7, [r4, #12]
 800435a:	2001      	movs	r0, #1
 800435c:	4038      	ands	r0, r7
 800435e:	f000 fdc3 	bl	8004ee8 <USBPD_PRL_SetHeader>
 8004362:	2002      	movs	r0, #2
 8004364:	7068      	strb	r0, [r5, #1]
 8004366:	6860      	ldr	r0, [r4, #4]
 8004368:	6801      	ldr	r1, [r0, #0]
 800436a:	2210      	movs	r2, #16
 800436c:	4391      	bics	r1, r2
 800436e:	6001      	str	r1, [r0, #0]
 8004370:	e019      	b.n	80043a6 <PE_ResetDuringSwap+0xb6>
 8004372:	f7ff faff 	bl	8003974 <PE_Get_DataRole>
 8004376:	6861      	ldr	r1, [r4, #4]
 8004378:	7809      	ldrb	r1, [r1, #0]
 800437a:	2303      	movs	r3, #3
 800437c:	400b      	ands	r3, r1
 800437e:	0002      	movs	r2, r0
 8004380:	2100      	movs	r1, #0
 8004382:	68e7      	ldr	r7, [r4, #12]
 8004384:	2001      	movs	r0, #1
 8004386:	4038      	ands	r0, r7
 8004388:	f000 fdae 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800438c:	203e      	movs	r0, #62	; 0x3e
 800438e:	7068      	strb	r0, [r5, #1]
 8004390:	0630      	lsls	r0, r6, #24
 8004392:	9000      	str	r0, [sp, #0]
 8004394:	2304      	movs	r3, #4
 8004396:	466a      	mov	r2, sp
 8004398:	2107      	movs	r1, #7
 800439a:	68e5      	ldr	r5, [r4, #12]
 800439c:	2001      	movs	r0, #1
 800439e:	4028      	ands	r0, r5
 80043a0:	68a5      	ldr	r5, [r4, #8]
 80043a2:	69ed      	ldr	r5, [r5, #28]
 80043a4:	47a8      	blx	r5
 80043a6:	2304      	movs	r3, #4
 80043a8:	aa01      	add	r2, sp, #4
 80043aa:	2102      	movs	r1, #2
 80043ac:	68e5      	ldr	r5, [r4, #12]
 80043ae:	2001      	movs	r0, #1
 80043b0:	4028      	ands	r0, r5
 80043b2:	68a5      	ldr	r5, [r4, #8]
 80043b4:	69ed      	ldr	r5, [r5, #28]
 80043b6:	47a8      	blx	r5
 80043b8:	2124      	movs	r1, #36	; 0x24
 80043ba:	20d8      	movs	r0, #216	; 0xd8
 80043bc:	0080      	lsls	r0, r0, #2
 80043be:	1820      	adds	r0, r4, r0
 80043c0:	f008 f8a2 	bl	800c508 <__aeabi_memclr>
 80043c4:	68e0      	ldr	r0, [r4, #12]
 80043c6:	4006      	ands	r6, r0
 80043c8:	0030      	movs	r0, r6
 80043ca:	f001 f843 	bl	8005454 <USBPD_PRL_Reset>
 80043ce:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

080043d0 <PE_ExtRevisionInteroperability>:
 80043d0:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 80043d2:	000a      	movs	r2, r1
 80043d4:	4c38      	ldr	r4, [pc, #224]	; (80044b8 <.text_69>)
 80043d6:	0081      	lsls	r1, r0, #2
 80043d8:	1861      	adds	r1, r4, r1
 80043da:	9101      	str	r1, [sp, #4]
 80043dc:	684e      	ldr	r6, [r1, #4]
 80043de:	2103      	movs	r1, #3
 80043e0:	6873      	ldr	r3, [r6, #4]
 80043e2:	781b      	ldrb	r3, [r3, #0]
 80043e4:	400b      	ands	r3, r1
 80043e6:	4293      	cmp	r3, r2
 80043e8:	d03a      	beq.n	8004460 <PE_ExtRevisionInteroperability+0x90>
 80043ea:	6873      	ldr	r3, [r6, #4]
 80043ec:	781b      	ldrb	r3, [r3, #0]
 80043ee:	079b      	lsls	r3, r3, #30
 80043f0:	0f9b      	lsrs	r3, r3, #30
 80043f2:	429a      	cmp	r2, r3
 80043f4:	d300      	bcc.n	80043f8 <PE_ExtRevisionInteroperability+0x28>
 80043f6:	001a      	movs	r2, r3
 80043f8:	6873      	ldr	r3, [r6, #4]
 80043fa:	781d      	ldrb	r5, [r3, #0]
 80043fc:	27fc      	movs	r7, #252	; 0xfc
 80043fe:	402f      	ands	r7, r5
 8004400:	400a      	ands	r2, r1
 8004402:	433a      	orrs	r2, r7
 8004404:	701a      	strb	r2, [r3, #0]
 8004406:	6872      	ldr	r2, [r6, #4]
 8004408:	7812      	ldrb	r2, [r2, #0]
 800440a:	2501      	movs	r5, #1
 800440c:	2303      	movs	r3, #3
 800440e:	4013      	ands	r3, r2
 8004410:	2b01      	cmp	r3, #1
 8004412:	d101      	bne.n	8004418 <PE_ExtRevisionInteroperability+0x48>
 8004414:	2700      	movs	r7, #0
 8004416:	e000      	b.n	800441a <PE_ExtRevisionInteroperability+0x4a>
 8004418:	2701      	movs	r7, #1
 800441a:	239f      	movs	r3, #159	; 0x9f
 800441c:	4013      	ands	r3, r2
 800441e:	017a      	lsls	r2, r7, #5
 8004420:	431a      	orrs	r2, r3
 8004422:	6873      	ldr	r3, [r6, #4]
 8004424:	701a      	strb	r2, [r3, #0]
 8004426:	6872      	ldr	r2, [r6, #4]
 8004428:	7812      	ldrb	r2, [r2, #0]
 800442a:	4011      	ands	r1, r2
 800442c:	f000 fd91 	bl	8004f52 <USBPD_PRL_SetHeaderSpecification>
 8004430:	7820      	ldrb	r0, [r4, #0]
 8004432:	0780      	lsls	r0, r0, #30
 8004434:	d50b      	bpl.n	800444e <PE_ExtRevisionInteroperability+0x7e>
 8004436:	2000      	movs	r0, #0
 8004438:	9000      	str	r0, [sp, #0]
 800443a:	2300      	movs	r3, #0
 800443c:	2236      	movs	r2, #54	; 0x36
 800443e:	9801      	ldr	r0, [sp, #4]
 8004440:	6840      	ldr	r0, [r0, #4]
 8004442:	68c0      	ldr	r0, [r0, #12]
 8004444:	2101      	movs	r1, #1
 8004446:	4001      	ands	r1, r0
 8004448:	2009      	movs	r0, #9
 800444a:	68e4      	ldr	r4, [r4, #12]
 800444c:	47a0      	blx	r4
 800444e:	9801      	ldr	r0, [sp, #4]
 8004450:	6842      	ldr	r2, [r0, #4]
 8004452:	2136      	movs	r1, #54	; 0x36
 8004454:	68d0      	ldr	r0, [r2, #12]
 8004456:	4005      	ands	r5, r0
 8004458:	0028      	movs	r0, r5
 800445a:	6892      	ldr	r2, [r2, #8]
 800445c:	68d2      	ldr	r2, [r2, #12]
 800445e:	4790      	blx	r2
 8004460:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

08004462 <PE_PRL_PostReceiveEvent>:
 8004462:	4b15      	ldr	r3, [pc, #84]	; (80044b8 <.text_69>)
 8004464:	0080      	lsls	r0, r0, #2
 8004466:	1818      	adds	r0, r3, r0
 8004468:	6840      	ldr	r0, [r0, #4]
 800446a:	4b0d      	ldr	r3, [pc, #52]	; (80044a0 <.text_67>)
 800446c:	18c0      	adds	r0, r0, r3
 800446e:	2301      	movs	r3, #1
 8004470:	408b      	lsls	r3, r1
 8004472:	7003      	strb	r3, [r0, #0]
 8004474:	8811      	ldrh	r1, [r2, #0]
 8004476:	85c1      	strh	r1, [r0, #46]	; 0x2e
 8004478:	4770      	bx	lr
	...

0800447c <.text_65>:
 800447c:	200019b0 	.word	0x200019b0

08004480 <PE_PRL_PostReceiveEventComplete>:
 8004480:	b510      	push	{r4, lr}
 8004482:	490d      	ldr	r1, [pc, #52]	; (80044b8 <.text_69>)
 8004484:	0082      	lsls	r2, r0, #2
 8004486:	1889      	adds	r1, r1, r2
 8004488:	6849      	ldr	r1, [r1, #4]
 800448a:	4a05      	ldr	r2, [pc, #20]	; (80044a0 <.text_67>)
 800448c:	188a      	adds	r2, r1, r2
 800448e:	7813      	ldrb	r3, [r2, #0]
 8004490:	2420      	movs	r4, #32
 8004492:	431c      	orrs	r4, r3
 8004494:	7014      	strb	r4, [r2, #0]
 8004496:	6889      	ldr	r1, [r1, #8]
 8004498:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800449a:	4788      	blx	r1
 800449c:	bd10      	pop	{r4, pc}
	...

080044a0 <.text_67>:
 80044a0:	00000356 	.word	0x00000356

080044a4 <PE_Get_UnchunkedSupport>:
 80044a4:	4904      	ldr	r1, [pc, #16]	; (80044b8 <.text_69>)
 80044a6:	0080      	lsls	r0, r0, #2
 80044a8:	1808      	adds	r0, r1, r0
 80044aa:	6840      	ldr	r0, [r0, #4]
 80044ac:	6840      	ldr	r0, [r0, #4]
 80044ae:	6800      	ldr	r0, [r0, #0]
 80044b0:	0301      	lsls	r1, r0, #12
 80044b2:	0fc8      	lsrs	r0, r1, #31
 80044b4:	4770      	bx	lr
	...

080044b8 <.text_69>:
 80044b8:	200019ac 	.word	0x200019ac

080044bc <.text_70>:
 80044bc:	0000034a 	.word	0x0000034a

080044c0 <.text_71>:
 80044c0:	00000357 	.word	0x00000357

080044c4 <PE_Send_ExtendedMessage>:
 80044c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80044c6:	b085      	sub	sp, #20
 80044c8:	6844      	ldr	r4, [r0, #4]
 80044ca:	25d6      	movs	r5, #214	; 0xd6
 80044cc:	00ad      	lsls	r5, r5, #2
 80044ce:	1945      	adds	r5, r0, r5
 80044d0:	9503      	str	r5, [sp, #12]
 80044d2:	2511      	movs	r5, #17
 80044d4:	7866      	ldrb	r6, [r4, #1]
 80044d6:	0676      	lsls	r6, r6, #25
 80044d8:	0f76      	lsrs	r6, r6, #29
 80044da:	2e03      	cmp	r6, #3
 80044dc:	d129      	bne.n	8004532 <PE_Send_ExtendedMessage+0x6e>
 80044de:	7824      	ldrb	r4, [r4, #0]
 80044e0:	07a4      	lsls	r4, r4, #30
 80044e2:	0fa4      	lsrs	r4, r4, #30
 80044e4:	2c01      	cmp	r4, #1
 80044e6:	dd24      	ble.n	8004532 <PE_Send_ExtendedMessage+0x6e>
 80044e8:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 80044ea:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80044ec:	9304      	str	r3, [sp, #16]
 80044ee:	23ff      	movs	r3, #255	; 0xff
 80044f0:	330a      	adds	r3, #10
 80044f2:	429f      	cmp	r7, r3
 80044f4:	d21d      	bcs.n	8004532 <PE_Send_ExtendedMessage+0x6e>
 80044f6:	0006      	movs	r6, r0
 80044f8:	4668      	mov	r0, sp
 80044fa:	7241      	strb	r1, [r0, #9]
 80044fc:	7202      	strb	r2, [r0, #8]
 80044fe:	970a      	str	r7, [sp, #40]	; 0x28
 8004500:	a80c      	add	r0, sp, #48	; 0x30
 8004502:	7004      	strb	r4, [r0, #0]
 8004504:	2401      	movs	r4, #1
 8004506:	a80c      	add	r0, sp, #48	; 0x30
 8004508:	7800      	ldrb	r0, [r0, #0]
 800450a:	9001      	str	r0, [sp, #4]
 800450c:	980a      	ldr	r0, [sp, #40]	; 0x28
 800450e:	b280      	uxth	r0, r0
 8004510:	9000      	str	r0, [sp, #0]
 8004512:	9b04      	ldr	r3, [sp, #16]
 8004514:	4668      	mov	r0, sp
 8004516:	7a02      	ldrb	r2, [r0, #8]
 8004518:	7a41      	ldrb	r1, [r0, #9]
 800451a:	68f7      	ldr	r7, [r6, #12]
 800451c:	2001      	movs	r0, #1
 800451e:	4038      	ands	r0, r7
 8004520:	f000 fd50 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8004524:	2803      	cmp	r0, #3
 8004526:	d117      	bne.n	8004558 <PE_Send_ExtendedMessage+0x94>
 8004528:	6870      	ldr	r0, [r6, #4]
 800452a:	6800      	ldr	r0, [r0, #0]
 800452c:	0ac0      	lsrs	r0, r0, #11
 800452e:	4004      	ands	r4, r0
 8004530:	d1e8      	bne.n	8004504 <PE_Send_ExtendedMessage+0x40>
 8004532:	9803      	ldr	r0, [sp, #12]
 8004534:	7005      	strb	r5, [r0, #0]
 8004536:	2010      	movs	r0, #16
 8004538:	e00c      	b.n	8004554 <PE_Send_ExtendedMessage+0x90>
 800453a:	6870      	ldr	r0, [r6, #4]
 800453c:	7840      	ldrb	r0, [r0, #1]
 800453e:	0640      	lsls	r0, r0, #25
 8004540:	0f40      	lsrs	r0, r0, #29
 8004542:	2804      	cmp	r0, #4
 8004544:	d103      	bne.n	800454e <PE_Send_ExtendedMessage+0x8a>
 8004546:	200f      	movs	r0, #15
 8004548:	9903      	ldr	r1, [sp, #12]
 800454a:	7008      	strb	r0, [r1, #0]
 800454c:	e001      	b.n	8004552 <PE_Send_ExtendedMessage+0x8e>
 800454e:	9803      	ldr	r0, [sp, #12]
 8004550:	7005      	strb	r5, [r0, #0]
 8004552:	2000      	movs	r0, #0
 8004554:	b005      	add	sp, #20
 8004556:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004558:	2805      	cmp	r0, #5
 800455a:	d004      	beq.n	8004566 <PE_Send_ExtendedMessage+0xa2>
 800455c:	2807      	cmp	r0, #7
 800455e:	d0ec      	beq.n	800453a <PE_Send_ExtendedMessage+0x76>
 8004560:	2809      	cmp	r0, #9
 8004562:	d0f7      	beq.n	8004554 <PE_Send_ExtendedMessage+0x90>
 8004564:	e7f5      	b.n	8004552 <PE_Send_ExtendedMessage+0x8e>
 8004566:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8004568:	e7ee      	b.n	8004548 <PE_Send_ExtendedMessage+0x84>

0800456a <PE_SubStateMachine_ExtendedMessages>:
 800456a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800456c:	b084      	sub	sp, #16
 800456e:	0005      	movs	r5, r0
 8004570:	2702      	movs	r7, #2
 8004572:	4886      	ldr	r0, [pc, #536]	; (800478c <.text_74>)
 8004574:	1828      	adds	r0, r5, r0
 8004576:	9002      	str	r0, [sp, #8]
 8004578:	4885      	ldr	r0, [pc, #532]	; (8004790 <.text_75>)
 800457a:	182c      	adds	r4, r5, r0
 800457c:	4985      	ldr	r1, [pc, #532]	; (8004794 <.text_76>)
 800457e:	2600      	movs	r6, #0
 8004580:	2003      	movs	r0, #3
 8004582:	7ba2      	ldrb	r2, [r4, #14]
 8004584:	2a31      	cmp	r2, #49	; 0x31
 8004586:	d016      	beq.n	80045b6 <PE_SubStateMachine_ExtendedMessages+0x4c>
 8004588:	2a32      	cmp	r2, #50	; 0x32
 800458a:	d049      	beq.n	8004620 <PE_SubStateMachine_ExtendedMessages+0xb6>
 800458c:	2a33      	cmp	r2, #51	; 0x33
 800458e:	d074      	beq.n	800467a <PE_SubStateMachine_ExtendedMessages+0x110>
 8004590:	2a34      	cmp	r2, #52	; 0x34
 8004592:	d100      	bne.n	8004596 <PE_SubStateMachine_ExtendedMessages+0x2c>
 8004594:	e083      	b.n	800469e <PE_SubStateMachine_ExtendedMessages+0x134>
 8004596:	2a35      	cmp	r2, #53	; 0x35
 8004598:	d100      	bne.n	800459c <PE_SubStateMachine_ExtendedMessages+0x32>
 800459a:	e0b6      	b.n	800470a <PE_SubStateMachine_ExtendedMessages+0x1a0>
 800459c:	2a36      	cmp	r2, #54	; 0x36
 800459e:	d100      	bne.n	80045a2 <PE_SubStateMachine_ExtendedMessages+0x38>
 80045a0:	e0c3      	b.n	800472a <PE_SubStateMachine_ExtendedMessages+0x1c0>
 80045a2:	2a37      	cmp	r2, #55	; 0x37
 80045a4:	d100      	bne.n	80045a8 <PE_SubStateMachine_ExtendedMessages+0x3e>
 80045a6:	e0c9      	b.n	800473c <PE_SubStateMachine_ExtendedMessages+0x1d2>
 80045a8:	2a38      	cmp	r2, #56	; 0x38
 80045aa:	d100      	bne.n	80045ae <PE_SubStateMachine_ExtendedMessages+0x44>
 80045ac:	e0e8      	b.n	8004780 <PE_SubStateMachine_ExtendedMessages+0x216>
 80045ae:	2aa5      	cmp	r2, #165	; 0xa5
 80045b0:	d100      	bne.n	80045b4 <PE_SubStateMachine_ExtendedMessages+0x4a>
 80045b2:	e0d9      	b.n	8004768 <PE_SubStateMachine_ExtendedMessages+0x1fe>
 80045b4:	e0e7      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 80045b6:	8026      	strh	r6, [r4, #0]
 80045b8:	2701      	movs	r7, #1
 80045ba:	68e9      	ldr	r1, [r5, #12]
 80045bc:	2001      	movs	r0, #1
 80045be:	4008      	ands	r0, r1
 80045c0:	f7ff ff70 	bl	80044a4 <PE_Get_UnchunkedSupport>
 80045c4:	2801      	cmp	r0, #1
 80045c6:	d105      	bne.n	80045d4 <PE_SubStateMachine_ExtendedMessages+0x6a>
 80045c8:	2091      	movs	r0, #145	; 0x91
 80045ca:	0080      	lsls	r0, r0, #2
 80045cc:	1828      	adds	r0, r5, r0
 80045ce:	7046      	strb	r6, [r0, #1]
 80045d0:	7006      	strb	r6, [r0, #0]
 80045d2:	e023      	b.n	800461c <PE_SubStateMachine_ExtendedMessages+0xb2>
 80045d4:	76ee      	strb	r6, [r5, #27]
 80045d6:	76ae      	strb	r6, [r5, #26]
 80045d8:	68e8      	ldr	r0, [r5, #12]
 80045da:	4007      	ands	r7, r0
 80045dc:	0038      	movs	r0, r7
 80045de:	f7ff ff61 	bl	80044a4 <PE_Get_UnchunkedSupport>
 80045e2:	2800      	cmp	r0, #0
 80045e4:	d104      	bne.n	80045f0 <PE_SubStateMachine_ExtendedMessages+0x86>
 80045e6:	8b68      	ldrh	r0, [r5, #26]
 80045e8:	2180      	movs	r1, #128	; 0x80
 80045ea:	0209      	lsls	r1, r1, #8
 80045ec:	4301      	orrs	r1, r0
 80045ee:	8369      	strh	r1, [r5, #26]
 80045f0:	4866      	ldr	r0, [pc, #408]	; (800478c <.text_74>)
 80045f2:	1828      	adds	r0, r5, r0
 80045f4:	8861      	ldrh	r1, [r4, #2]
 80045f6:	291a      	cmp	r1, #26
 80045f8:	4631      	mov	r1, r6
 80045fa:	d90c      	bls.n	8004616 <PE_SubStateMachine_ExtendedMessages+0xac>
 80045fc:	5c42      	ldrb	r2, [r0, r1]
 80045fe:	002b      	movs	r3, r5
 8004600:	331c      	adds	r3, #28
 8004602:	545a      	strb	r2, [r3, r1]
 8004604:	1c49      	adds	r1, r1, #1
 8004606:	291a      	cmp	r1, #26
 8004608:	d208      	bcs.n	800461c <PE_SubStateMachine_ExtendedMessages+0xb2>
 800460a:	e7f7      	b.n	80045fc <PE_SubStateMachine_ExtendedMessages+0x92>
 800460c:	5c42      	ldrb	r2, [r0, r1]
 800460e:	002b      	movs	r3, r5
 8004610:	331c      	adds	r3, #28
 8004612:	545a      	strb	r2, [r3, r1]
 8004614:	1c49      	adds	r1, r1, #1
 8004616:	8862      	ldrh	r2, [r4, #2]
 8004618:	4291      	cmp	r1, r2
 800461a:	d3f7      	bcc.n	800460c <PE_SubStateMachine_ExtendedMessages+0xa2>
 800461c:	2032      	movs	r0, #50	; 0x32
 800461e:	e08b      	b.n	8004738 <PE_SubStateMachine_ExtendedMessages+0x1ce>
 8004620:	0028      	movs	r0, r5
 8004622:	3018      	adds	r0, #24
 8004624:	9003      	str	r0, [sp, #12]
 8004626:	7b29      	ldrb	r1, [r5, #12]
 8004628:	07c8      	lsls	r0, r1, #31
 800462a:	0fc0      	lsrs	r0, r0, #31
 800462c:	f7ff ff3a 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004630:	2801      	cmp	r0, #1
 8004632:	d101      	bne.n	8004638 <PE_SubStateMachine_ExtendedMessages+0xce>
 8004634:	9802      	ldr	r0, [sp, #8]
 8004636:	9003      	str	r0, [sp, #12]
 8004638:	2001      	movs	r0, #1
 800463a:	68e9      	ldr	r1, [r5, #12]
 800463c:	0909      	lsrs	r1, r1, #4
 800463e:	4001      	ands	r1, r0
 8004640:	d006      	beq.n	8004650 <PE_SubStateMachine_ExtendedMessages+0xe6>
 8004642:	6869      	ldr	r1, [r5, #4]
 8004644:	7809      	ldrb	r1, [r1, #0]
 8004646:	0889      	lsrs	r1, r1, #2
 8004648:	4201      	tst	r1, r0
 800464a:	d102      	bne.n	8004652 <PE_SubStateMachine_ExtendedMessages+0xe8>
 800464c:	2002      	movs	r0, #2
 800464e:	e000      	b.n	8004652 <PE_SubStateMachine_ExtendedMessages+0xe8>
 8004650:	2000      	movs	r0, #0
 8004652:	21e4      	movs	r1, #228	; 0xe4
 8004654:	0089      	lsls	r1, r1, #2
 8004656:	186e      	adds	r6, r5, r1
 8004658:	9002      	str	r0, [sp, #8]
 800465a:	2033      	movs	r0, #51	; 0x33
 800465c:	9001      	str	r0, [sp, #4]
 800465e:	8860      	ldrh	r0, [r4, #2]
 8004660:	1d00      	adds	r0, r0, #4
 8004662:	9000      	str	r0, [sp, #0]
 8004664:	9b03      	ldr	r3, [sp, #12]
 8004666:	78f2      	ldrb	r2, [r6, #3]
 8004668:	7ae1      	ldrb	r1, [r4, #11]
 800466a:	0028      	movs	r0, r5
 800466c:	f7ff ff2a 	bl	80044c4 <PE_Send_ExtendedMessage>
 8004670:	2800      	cmp	r0, #0
 8004672:	d101      	bne.n	8004678 <PE_SubStateMachine_ExtendedMessages+0x10e>
 8004674:	88f0      	ldrh	r0, [r6, #6]
 8004676:	82e8      	strh	r0, [r5, #22]
 8004678:	e085      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800467a:	68ea      	ldr	r2, [r5, #12]
 800467c:	06d3      	lsls	r3, r2, #27
 800467e:	0fdb      	lsrs	r3, r3, #31
 8004680:	d009      	beq.n	8004696 <PE_SubStateMachine_ExtendedMessages+0x12c>
 8004682:	8461      	strh	r1, [r4, #34]	; 0x22
 8004684:	271a      	movs	r7, #26
 8004686:	20e4      	movs	r0, #228	; 0xe4
 8004688:	0080      	lsls	r0, r0, #2
 800468a:	1828      	adds	r0, r5, r0
 800468c:	78c0      	ldrb	r0, [r0, #3]
 800468e:	2884      	cmp	r0, #132	; 0x84
 8004690:	d166      	bne.n	8004760 <PE_SubStateMachine_ExtendedMessages+0x1f6>
 8004692:	2074      	movs	r0, #116	; 0x74
 8004694:	e072      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 8004696:	73a0      	strb	r0, [r4, #14]
 8004698:	2700      	movs	r7, #0
 800469a:	8466      	strh	r6, [r4, #34]	; 0x22
 800469c:	e073      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800469e:	4669      	mov	r1, sp
 80046a0:	22e4      	movs	r2, #228	; 0xe4
 80046a2:	0092      	lsls	r2, r2, #2
 80046a4:	5aaa      	ldrh	r2, [r5, r2]
 80046a6:	0452      	lsls	r2, r2, #17
 80046a8:	0f12      	lsrs	r2, r2, #28
 80046aa:	800a      	strh	r2, [r1, #0]
 80046ac:	4611      	mov	r1, r2
 80046ae:	221a      	movs	r2, #26
 80046b0:	434a      	muls	r2, r1
 80046b2:	9201      	str	r2, [sp, #4]
 80046b4:	8861      	ldrh	r1, [r4, #2]
 80046b6:	428a      	cmp	r2, r1
 80046b8:	da03      	bge.n	80046c2 <PE_SubStateMachine_ExtendedMessages+0x158>
 80046ba:	466a      	mov	r2, sp
 80046bc:	8812      	ldrh	r2, [r2, #0]
 80046be:	2a0a      	cmp	r2, #10
 80046c0:	db01      	blt.n	80046c6 <PE_SubStateMachine_ExtendedMessages+0x15c>
 80046c2:	8466      	strh	r6, [r4, #34]	; 0x22
 80046c4:	e05a      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 80046c6:	9a01      	ldr	r2, [sp, #4]
 80046c8:	1a88      	subs	r0, r1, r2
 80046ca:	281a      	cmp	r0, #26
 80046cc:	d202      	bcs.n	80046d4 <PE_SubStateMachine_ExtendedMessages+0x16a>
 80046ce:	1a89      	subs	r1, r1, r2
 80046d0:	b2c9      	uxtb	r1, r1
 80046d2:	e000      	b.n	80046d6 <PE_SubStateMachine_ExtendedMessages+0x16c>
 80046d4:	211a      	movs	r1, #26
 80046d6:	2000      	movs	r0, #0
 80046d8:	e006      	b.n	80046e8 <PE_SubStateMachine_ExtendedMessages+0x17e>
 80046da:	9b02      	ldr	r3, [sp, #8]
 80046dc:	1817      	adds	r7, r2, r0
 80046de:	5ddb      	ldrb	r3, [r3, r7]
 80046e0:	002f      	movs	r7, r5
 80046e2:	371c      	adds	r7, #28
 80046e4:	543b      	strb	r3, [r7, r0]
 80046e6:	1c40      	adds	r0, r0, #1
 80046e8:	4288      	cmp	r0, r1
 80046ea:	d3f6      	bcc.n	80046da <PE_SubStateMachine_ExtendedMessages+0x170>
 80046ec:	002b      	movs	r3, r5
 80046ee:	3318      	adds	r3, #24
 80046f0:	8862      	ldrh	r2, [r4, #2]
 80046f2:	20e4      	movs	r0, #228	; 0xe4
 80046f4:	0080      	lsls	r0, r0, #2
 80046f6:	5a28      	ldrh	r0, [r5, r0]
 80046f8:	0440      	lsls	r0, r0, #17
 80046fa:	0f01      	lsrs	r1, r0, #28
 80046fc:	7b2d      	ldrb	r5, [r5, #12]
 80046fe:	07e8      	lsls	r0, r5, #31
 8004700:	0fc0      	lsrs	r0, r0, #31
 8004702:	f001 f8cb 	bl	800589c <USBPD_PRL_PrepareExtendedTxChunkSending>
 8004706:	2035      	movs	r0, #53	; 0x35
 8004708:	e016      	b.n	8004738 <PE_SubStateMachine_ExtendedMessages+0x1ce>
 800470a:	9602      	str	r6, [sp, #8]
 800470c:	2036      	movs	r0, #54	; 0x36
 800470e:	9001      	str	r0, [sp, #4]
 8004710:	8860      	ldrh	r0, [r4, #2]
 8004712:	9000      	str	r0, [sp, #0]
 8004714:	002b      	movs	r3, r5
 8004716:	3318      	adds	r3, #24
 8004718:	20e4      	movs	r0, #228	; 0xe4
 800471a:	0080      	lsls	r0, r0, #2
 800471c:	1828      	adds	r0, r5, r0
 800471e:	78c2      	ldrb	r2, [r0, #3]
 8004720:	7ae1      	ldrb	r1, [r4, #11]
 8004722:	0028      	movs	r0, r5
 8004724:	f7ff fece 	bl	80044c4 <PE_Send_ExtendedMessage>
 8004728:	e02d      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800472a:	8026      	strh	r6, [r4, #0]
 800472c:	68ea      	ldr	r2, [r5, #12]
 800472e:	06d3      	lsls	r3, r2, #27
 8004730:	0fdb      	lsrs	r3, r3, #31
 8004732:	d001      	beq.n	8004738 <PE_SubStateMachine_ExtendedMessages+0x1ce>
 8004734:	8461      	strh	r1, [r4, #34]	; 0x22
 8004736:	2039      	movs	r0, #57	; 0x39
 8004738:	73a0      	strb	r0, [r4, #14]
 800473a:	e01d      	b.n	8004778 <PE_SubStateMachine_ExtendedMessages+0x20e>
 800473c:	8c60      	ldrh	r0, [r4, #34]	; 0x22
 800473e:	03ba      	lsls	r2, r7, #14
 8004740:	4290      	cmp	r0, r2
 8004742:	d101      	bne.n	8004748 <PE_SubStateMachine_ExtendedMessages+0x1de>
 8004744:	8466      	strh	r6, [r4, #34]	; 0x22
 8004746:	e00d      	b.n	8004764 <PE_SubStateMachine_ExtendedMessages+0x1fa>
 8004748:	8461      	strh	r1, [r4, #34]	; 0x22
 800474a:	271a      	movs	r7, #26
 800474c:	48c9      	ldr	r0, [pc, #804]	; (8004a74 <.text_78>)
 800474e:	182a      	adds	r2, r5, r0
 8004750:	7ae1      	ldrb	r1, [r4, #11]
 8004752:	7b2b      	ldrb	r3, [r5, #12]
 8004754:	07d8      	lsls	r0, r3, #31
 8004756:	0fc0      	lsrs	r0, r0, #31
 8004758:	f001 f8c8 	bl	80058ec <USBPD_PRL_ManageExtendedRx>
 800475c:	2800      	cmp	r0, #0
 800475e:	d101      	bne.n	8004764 <PE_SubStateMachine_ExtendedMessages+0x1fa>
 8004760:	2039      	movs	r0, #57	; 0x39
 8004762:	e00b      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 8004764:	200f      	movs	r0, #15
 8004766:	e009      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 8004768:	7aa1      	ldrb	r1, [r4, #10]
 800476a:	2900      	cmp	r1, #0
 800476c:	d006      	beq.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 800476e:	7ae0      	ldrb	r0, [r4, #11]
 8004770:	7460      	strb	r0, [r4, #17]
 8004772:	7aa0      	ldrb	r0, [r4, #10]
 8004774:	73a0      	strb	r0, [r4, #14]
 8004776:	72a6      	strb	r6, [r4, #10]
 8004778:	2700      	movs	r7, #0
 800477a:	e004      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800477c:	73a0      	strb	r0, [r4, #14]
 800477e:	e002      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 8004780:	8466      	strh	r6, [r4, #34]	; 0x22
 8004782:	73a0      	strb	r0, [r4, #14]
 8004784:	8026      	strh	r6, [r4, #0]
 8004786:	0038      	movs	r0, r7
 8004788:	b005      	add	sp, #20
 800478a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800478c <.text_74>:
 800478c:	00000242 	.word	0x00000242

08004790 <.text_75>:
 8004790:	0000034a 	.word	0x0000034a

08004794 <.text_76>:
 8004794:	0000801a 	.word	0x0000801a

08004798 <PE_SubStateMachine_Generic>:
 8004798:	b5f0      	push	{r4, r5, r6, r7, lr}
 800479a:	b085      	sub	sp, #20
 800479c:	0004      	movs	r4, r0
 800479e:	2601      	movs	r6, #1
 80047a0:	2703      	movs	r7, #3
 80047a2:	2500      	movs	r5, #0
 80047a4:	20d6      	movs	r0, #214	; 0xd6
 80047a6:	0080      	lsls	r0, r0, #2
 80047a8:	5c20      	ldrb	r0, [r4, r0]
 80047aa:	2801      	cmp	r0, #1
 80047ac:	d013      	beq.n	80047d6 <PE_SubStateMachine_Generic+0x3e>
 80047ae:	282c      	cmp	r0, #44	; 0x2c
 80047b0:	d100      	bne.n	80047b4 <PE_SubStateMachine_Generic+0x1c>
 80047b2:	e136      	b.n	8004a22 <PE_SubStateMachine_Generic+0x28a>
 80047b4:	2830      	cmp	r0, #48	; 0x30
 80047b6:	d05a      	beq.n	800486e <PE_SubStateMachine_Generic+0xd6>
 80047b8:	283a      	cmp	r0, #58	; 0x3a
 80047ba:	d100      	bne.n	80047be <PE_SubStateMachine_Generic+0x26>
 80047bc:	e10b      	b.n	80049d6 <PE_SubStateMachine_Generic+0x23e>
 80047be:	283b      	cmp	r0, #59	; 0x3b
 80047c0:	d100      	bne.n	80047c4 <PE_SubStateMachine_Generic+0x2c>
 80047c2:	e0e6      	b.n	8004992 <PE_SubStateMachine_Generic+0x1fa>
 80047c4:	283c      	cmp	r0, #60	; 0x3c
 80047c6:	d100      	bne.n	80047ca <PE_SubStateMachine_Generic+0x32>
 80047c8:	e0c1      	b.n	800494e <PE_SubStateMachine_Generic+0x1b6>
 80047ca:	2863      	cmp	r0, #99	; 0x63
 80047cc:	d01a      	beq.n	8004804 <PE_SubStateMachine_Generic+0x6c>
 80047ce:	2874      	cmp	r0, #116	; 0x74
 80047d0:	d100      	bne.n	80047d4 <PE_SubStateMachine_Generic+0x3c>
 80047d2:	e087      	b.n	80048e4 <PE_SubStateMachine_Generic+0x14c>
 80047d4:	e147      	b.n	8004a66 <PE_SubStateMachine_Generic+0x2ce>
 80047d6:	9500      	str	r5, [sp, #0]
 80047d8:	2303      	movs	r3, #3
 80047da:	2210      	movs	r2, #16
 80047dc:	2100      	movs	r1, #0
 80047de:	0020      	movs	r0, r4
 80047e0:	f7fe ffc7 	bl	8003772 <PE_Send_CtrlMessage>
 80047e4:	4da4      	ldr	r5, [pc, #656]	; (8004a78 <.text_79>)
 80047e6:	7828      	ldrb	r0, [r5, #0]
 80047e8:	0780      	lsls	r0, r0, #30
 80047ea:	d509      	bpl.n	8004800 <PE_SubStateMachine_Generic+0x68>
 80047ec:	2000      	movs	r0, #0
 80047ee:	9000      	str	r0, [sp, #0]
 80047f0:	2300      	movs	r3, #0
 80047f2:	2255      	movs	r2, #85	; 0x55
 80047f4:	68e0      	ldr	r0, [r4, #12]
 80047f6:	2101      	movs	r1, #1
 80047f8:	4001      	ands	r1, r0
 80047fa:	2009      	movs	r0, #9
 80047fc:	68ed      	ldr	r5, [r5, #12]
 80047fe:	47a8      	blx	r5
 8004800:	2155      	movs	r1, #85	; 0x55
 8004802:	e068      	b.n	80048d6 <PE_SubStateMachine_Generic+0x13e>
 8004804:	9503      	str	r5, [sp, #12]
 8004806:	ab03      	add	r3, sp, #12
 8004808:	0022      	movs	r2, r4
 800480a:	321c      	adds	r2, #28
 800480c:	2108      	movs	r1, #8
 800480e:	68e7      	ldr	r7, [r4, #12]
 8004810:	2001      	movs	r0, #1
 8004812:	4038      	ands	r0, r7
 8004814:	68a7      	ldr	r7, [r4, #8]
 8004816:	69bf      	ldr	r7, [r7, #24]
 8004818:	47b8      	blx	r7
 800481a:	76e5      	strb	r5, [r4, #27]
 800481c:	76a5      	strb	r5, [r4, #26]
 800481e:	68e1      	ldr	r1, [r4, #12]
 8004820:	2001      	movs	r0, #1
 8004822:	4008      	ands	r0, r1
 8004824:	f7ff fe3e 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004828:	2800      	cmp	r0, #0
 800482a:	d103      	bne.n	8004834 <PE_SubStateMachine_Generic+0x9c>
 800482c:	8b60      	ldrh	r0, [r4, #26]
 800482e:	03f1      	lsls	r1, r6, #15
 8004830:	4301      	orrs	r1, r0
 8004832:	8361      	strh	r1, [r4, #26]
 8004834:	9502      	str	r5, [sp, #8]
 8004836:	2003      	movs	r0, #3
 8004838:	9001      	str	r0, [sp, #4]
 800483a:	9803      	ldr	r0, [sp, #12]
 800483c:	1d00      	adds	r0, r0, #4
 800483e:	9000      	str	r0, [sp, #0]
 8004840:	0023      	movs	r3, r4
 8004842:	3318      	adds	r3, #24
 8004844:	2281      	movs	r2, #129	; 0x81
 8004846:	2100      	movs	r1, #0
 8004848:	0020      	movs	r0, r4
 800484a:	f7ff fe3b 	bl	80044c4 <PE_Send_ExtendedMessage>
 800484e:	4d8a      	ldr	r5, [pc, #552]	; (8004a78 <.text_79>)
 8004850:	7828      	ldrb	r0, [r5, #0]
 8004852:	0780      	lsls	r0, r0, #30
 8004854:	d509      	bpl.n	800486a <PE_SubStateMachine_Generic+0xd2>
 8004856:	2000      	movs	r0, #0
 8004858:	9000      	str	r0, [sp, #0]
 800485a:	2300      	movs	r3, #0
 800485c:	2245      	movs	r2, #69	; 0x45
 800485e:	68e0      	ldr	r0, [r4, #12]
 8004860:	2101      	movs	r1, #1
 8004862:	4001      	ands	r1, r0
 8004864:	2009      	movs	r0, #9
 8004866:	68ed      	ldr	r5, [r5, #12]
 8004868:	47a8      	blx	r5
 800486a:	2145      	movs	r1, #69	; 0x45
 800486c:	e033      	b.n	80048d6 <PE_SubStateMachine_Generic+0x13e>
 800486e:	9503      	str	r5, [sp, #12]
 8004870:	ab03      	add	r3, sp, #12
 8004872:	0022      	movs	r2, r4
 8004874:	321c      	adds	r2, #28
 8004876:	2109      	movs	r1, #9
 8004878:	68e7      	ldr	r7, [r4, #12]
 800487a:	2001      	movs	r0, #1
 800487c:	4038      	ands	r0, r7
 800487e:	68a7      	ldr	r7, [r4, #8]
 8004880:	69bf      	ldr	r7, [r7, #24]
 8004882:	47b8      	blx	r7
 8004884:	76e5      	strb	r5, [r4, #27]
 8004886:	76a5      	strb	r5, [r4, #26]
 8004888:	68e1      	ldr	r1, [r4, #12]
 800488a:	2001      	movs	r0, #1
 800488c:	4008      	ands	r0, r1
 800488e:	f7ff fe09 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004892:	2800      	cmp	r0, #0
 8004894:	d103      	bne.n	800489e <PE_SubStateMachine_Generic+0x106>
 8004896:	8b60      	ldrh	r0, [r4, #26]
 8004898:	03f1      	lsls	r1, r6, #15
 800489a:	4301      	orrs	r1, r0
 800489c:	8361      	strh	r1, [r4, #26]
 800489e:	9502      	str	r5, [sp, #8]
 80048a0:	2003      	movs	r0, #3
 80048a2:	9001      	str	r0, [sp, #4]
 80048a4:	9803      	ldr	r0, [sp, #12]
 80048a6:	1d00      	adds	r0, r0, #4
 80048a8:	9000      	str	r0, [sp, #0]
 80048aa:	0023      	movs	r3, r4
 80048ac:	3318      	adds	r3, #24
 80048ae:	2282      	movs	r2, #130	; 0x82
 80048b0:	2100      	movs	r1, #0
 80048b2:	0020      	movs	r0, r4
 80048b4:	f7ff fe06 	bl	80044c4 <PE_Send_ExtendedMessage>
 80048b8:	4d6f      	ldr	r5, [pc, #444]	; (8004a78 <.text_79>)
 80048ba:	7828      	ldrb	r0, [r5, #0]
 80048bc:	0780      	lsls	r0, r0, #30
 80048be:	d509      	bpl.n	80048d4 <PE_SubStateMachine_Generic+0x13c>
 80048c0:	2000      	movs	r0, #0
 80048c2:	9000      	str	r0, [sp, #0]
 80048c4:	2300      	movs	r3, #0
 80048c6:	224c      	movs	r2, #76	; 0x4c
 80048c8:	68e0      	ldr	r0, [r4, #12]
 80048ca:	2101      	movs	r1, #1
 80048cc:	4001      	ands	r1, r0
 80048ce:	2009      	movs	r0, #9
 80048d0:	68ed      	ldr	r5, [r5, #12]
 80048d2:	47a8      	blx	r5
 80048d4:	214c      	movs	r1, #76	; 0x4c
 80048d6:	68e0      	ldr	r0, [r4, #12]
 80048d8:	4006      	ands	r6, r0
 80048da:	0030      	movs	r0, r6
 80048dc:	68a2      	ldr	r2, [r4, #8]
 80048de:	68d2      	ldr	r2, [r2, #12]
 80048e0:	4790      	blx	r2
 80048e2:	e0c3      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 80048e4:	9100      	str	r1, [sp, #0]
 80048e6:	7808      	ldrb	r0, [r1, #0]
 80048e8:	2814      	cmp	r0, #20
 80048ea:	d025      	beq.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 80048ec:	20d6      	movs	r0, #214	; 0xd6
 80048ee:	0080      	lsls	r0, r0, #2
 80048f0:	1820      	adds	r0, r4, r0
 80048f2:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
 80048f4:	0bc0      	lsrs	r0, r0, #15
 80048f6:	d11f      	bne.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 80048f8:	20d6      	movs	r0, #214	; 0xd6
 80048fa:	0080      	lsls	r0, r0, #2
 80048fc:	1820      	adds	r0, r4, r0
 80048fe:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
 8004900:	0440      	lsls	r0, r0, #17
 8004902:	0f40      	lsrs	r0, r0, #29
 8004904:	d018      	beq.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 8004906:	20d6      	movs	r0, #214	; 0xd6
 8004908:	0080      	lsls	r0, r0, #2
 800490a:	1820      	adds	r0, r4, r0
 800490c:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
 800490e:	06c0      	lsls	r0, r0, #27
 8004910:	0ec0      	lsrs	r0, r0, #27
 8004912:	2805      	cmp	r0, #5
 8004914:	d110      	bne.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 8004916:	2318      	movs	r3, #24
 8004918:	209f      	movs	r0, #159	; 0x9f
 800491a:	0040      	lsls	r0, r0, #1
 800491c:	1822      	adds	r2, r4, r0
 800491e:	210f      	movs	r1, #15
 8004920:	68e0      	ldr	r0, [r4, #12]
 8004922:	4006      	ands	r6, r0
 8004924:	0030      	movs	r0, r6
 8004926:	68a6      	ldr	r6, [r4, #8]
 8004928:	69f6      	ldr	r6, [r6, #28]
 800492a:	47b0      	blx	r6
 800492c:	20d6      	movs	r0, #214	; 0xd6
 800492e:	0080      	lsls	r0, r0, #2
 8004930:	5427      	strb	r7, [r4, r0]
 8004932:	2014      	movs	r0, #20
 8004934:	9900      	ldr	r1, [sp, #0]
 8004936:	7008      	strb	r0, [r1, #0]
 8004938:	20d6      	movs	r0, #214	; 0xd6
 800493a:	0080      	lsls	r0, r0, #2
 800493c:	1820      	adds	r0, r4, r0
 800493e:	8a81      	ldrh	r1, [r0, #20]
 8004940:	2280      	movs	r2, #128	; 0x80
 8004942:	0212      	lsls	r2, r2, #8
 8004944:	4291      	cmp	r1, r2
 8004946:	d101      	bne.n	800494c <PE_SubStateMachine_Generic+0x1b4>
 8004948:	8285      	strh	r5, [r0, #20]
 800494a:	7007      	strb	r7, [r0, #0]
 800494c:	e08e      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 800494e:	ab03      	add	r3, sp, #12
 8004950:	0022      	movs	r2, r4
 8004952:	321c      	adds	r2, #28
 8004954:	210d      	movs	r1, #13
 8004956:	68e7      	ldr	r7, [r4, #12]
 8004958:	2001      	movs	r0, #1
 800495a:	4038      	ands	r0, r7
 800495c:	68a7      	ldr	r7, [r4, #8]
 800495e:	69bf      	ldr	r7, [r7, #24]
 8004960:	47b8      	blx	r7
 8004962:	76e5      	strb	r5, [r4, #27]
 8004964:	76a5      	strb	r5, [r4, #26]
 8004966:	68e0      	ldr	r0, [r4, #12]
 8004968:	4006      	ands	r6, r0
 800496a:	0030      	movs	r0, r6
 800496c:	f7ff fd9a 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004970:	2800      	cmp	r0, #0
 8004972:	d104      	bne.n	800497e <PE_SubStateMachine_Generic+0x1e6>
 8004974:	8b60      	ldrh	r0, [r4, #26]
 8004976:	2180      	movs	r1, #128	; 0x80
 8004978:	0209      	lsls	r1, r1, #8
 800497a:	4301      	orrs	r1, r0
 800497c:	8361      	strh	r1, [r4, #26]
 800497e:	9502      	str	r5, [sp, #8]
 8004980:	2003      	movs	r0, #3
 8004982:	9001      	str	r0, [sp, #4]
 8004984:	9803      	ldr	r0, [sp, #12]
 8004986:	1d00      	adds	r0, r0, #4
 8004988:	9000      	str	r0, [sp, #0]
 800498a:	0023      	movs	r3, r4
 800498c:	3318      	adds	r3, #24
 800498e:	2287      	movs	r2, #135	; 0x87
 8004990:	e042      	b.n	8004a18 <PE_SubStateMachine_Generic+0x280>
 8004992:	9503      	str	r5, [sp, #12]
 8004994:	ab04      	add	r3, sp, #16
 8004996:	0022      	movs	r2, r4
 8004998:	321c      	adds	r2, #28
 800499a:	210f      	movs	r1, #15
 800499c:	68e0      	ldr	r0, [r4, #12]
 800499e:	4006      	ands	r6, r0
 80049a0:	0030      	movs	r0, r6
 80049a2:	68a5      	ldr	r5, [r4, #8]
 80049a4:	69ad      	ldr	r5, [r5, #24]
 80049a6:	47a8      	blx	r5
 80049a8:	7fe0      	ldrb	r0, [r4, #31]
 80049aa:	0600      	lsls	r0, r0, #24
 80049ac:	7fa1      	ldrb	r1, [r4, #30]
 80049ae:	0409      	lsls	r1, r1, #16
 80049b0:	4301      	orrs	r1, r0
 80049b2:	7f60      	ldrb	r0, [r4, #29]
 80049b4:	0200      	lsls	r0, r0, #8
 80049b6:	4308      	orrs	r0, r1
 80049b8:	7f21      	ldrb	r1, [r4, #28]
 80049ba:	4301      	orrs	r1, r0
 80049bc:	9103      	str	r1, [sp, #12]
 80049be:	2000      	movs	r0, #0
 80049c0:	9002      	str	r0, [sp, #8]
 80049c2:	9701      	str	r7, [sp, #4]
 80049c4:	2001      	movs	r0, #1
 80049c6:	9000      	str	r0, [sp, #0]
 80049c8:	ab03      	add	r3, sp, #12
 80049ca:	2205      	movs	r2, #5
 80049cc:	2100      	movs	r1, #0
 80049ce:	0020      	movs	r0, r4
 80049d0:	f7fe ff16 	bl	8003800 <PE_Send_DataMessage>
 80049d4:	e04a      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 80049d6:	ab03      	add	r3, sp, #12
 80049d8:	0022      	movs	r2, r4
 80049da:	321c      	adds	r2, #28
 80049dc:	2111      	movs	r1, #17
 80049de:	68e7      	ldr	r7, [r4, #12]
 80049e0:	2001      	movs	r0, #1
 80049e2:	4038      	ands	r0, r7
 80049e4:	68a7      	ldr	r7, [r4, #8]
 80049e6:	69bf      	ldr	r7, [r7, #24]
 80049e8:	47b8      	blx	r7
 80049ea:	76e5      	strb	r5, [r4, #27]
 80049ec:	76a5      	strb	r5, [r4, #26]
 80049ee:	68e0      	ldr	r0, [r4, #12]
 80049f0:	4006      	ands	r6, r0
 80049f2:	0030      	movs	r0, r6
 80049f4:	f7ff fd56 	bl	80044a4 <PE_Get_UnchunkedSupport>
 80049f8:	2800      	cmp	r0, #0
 80049fa:	d104      	bne.n	8004a06 <PE_SubStateMachine_Generic+0x26e>
 80049fc:	8b60      	ldrh	r0, [r4, #26]
 80049fe:	2180      	movs	r1, #128	; 0x80
 8004a00:	0209      	lsls	r1, r1, #8
 8004a02:	4301      	orrs	r1, r0
 8004a04:	8361      	strh	r1, [r4, #26]
 8004a06:	9502      	str	r5, [sp, #8]
 8004a08:	2003      	movs	r0, #3
 8004a0a:	9001      	str	r0, [sp, #4]
 8004a0c:	9803      	ldr	r0, [sp, #12]
 8004a0e:	1d00      	adds	r0, r0, #4
 8004a10:	9000      	str	r0, [sp, #0]
 8004a12:	0023      	movs	r3, r4
 8004a14:	3318      	adds	r3, #24
 8004a16:	2285      	movs	r2, #133	; 0x85
 8004a18:	2100      	movs	r1, #0
 8004a1a:	0020      	movs	r0, r4
 8004a1c:	f7ff fd52 	bl	80044c4 <PE_Send_ExtendedMessage>
 8004a20:	e024      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 8004a22:	4d15      	ldr	r5, [pc, #84]	; (8004a78 <.text_79>)
 8004a24:	7828      	ldrb	r0, [r5, #0]
 8004a26:	0780      	lsls	r0, r0, #30
 8004a28:	d509      	bpl.n	8004a3e <PE_SubStateMachine_Generic+0x2a6>
 8004a2a:	2000      	movs	r0, #0
 8004a2c:	9000      	str	r0, [sp, #0]
 8004a2e:	2300      	movs	r3, #0
 8004a30:	224d      	movs	r2, #77	; 0x4d
 8004a32:	68e0      	ldr	r0, [r4, #12]
 8004a34:	2101      	movs	r1, #1
 8004a36:	4001      	ands	r1, r0
 8004a38:	2009      	movs	r0, #9
 8004a3a:	68ed      	ldr	r5, [r5, #12]
 8004a3c:	47a8      	blx	r5
 8004a3e:	214d      	movs	r1, #77	; 0x4d
 8004a40:	68e2      	ldr	r2, [r4, #12]
 8004a42:	2001      	movs	r0, #1
 8004a44:	4010      	ands	r0, r2
 8004a46:	68a2      	ldr	r2, [r4, #8]
 8004a48:	68d2      	ldr	r2, [r2, #12]
 8004a4a:	4790      	blx	r2
 8004a4c:	2300      	movs	r3, #0
 8004a4e:	2200      	movs	r2, #0
 8004a50:	210b      	movs	r1, #11
 8004a52:	68e0      	ldr	r0, [r4, #12]
 8004a54:	4006      	ands	r6, r0
 8004a56:	0030      	movs	r0, r6
 8004a58:	68a5      	ldr	r5, [r4, #8]
 8004a5a:	69ad      	ldr	r5, [r5, #24]
 8004a5c:	47a8      	blx	r5
 8004a5e:	20d6      	movs	r0, #214	; 0xd6
 8004a60:	0080      	lsls	r0, r0, #2
 8004a62:	5427      	strb	r7, [r4, r0]
 8004a64:	e002      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 8004a66:	20d6      	movs	r0, #214	; 0xd6
 8004a68:	0080      	lsls	r0, r0, #2
 8004a6a:	5426      	strb	r6, [r4, r0]
 8004a6c:	2002      	movs	r0, #2
 8004a6e:	b005      	add	sp, #20
 8004a70:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08004a74 <.text_78>:
 8004a74:	00000392 	.word	0x00000392

08004a78 <.text_79>:
 8004a78:	200019ac 	.word	0x200019ac

08004a7c <PE_SubStateMachine_VconnSwap>:
 8004a7c:	b5f2      	push	{r1, r4, r5, r6, r7, lr}
 8004a7e:	b082      	sub	sp, #8
 8004a80:	0004      	movs	r4, r0
 8004a82:	2002      	movs	r0, #2
 8004a84:	9001      	str	r0, [sp, #4]
 8004a86:	20d6      	movs	r0, #214	; 0xd6
 8004a88:	0080      	lsls	r0, r0, #2
 8004a8a:	1826      	adds	r6, r4, r0
 8004a8c:	201f      	movs	r0, #31
 8004a8e:	4d82      	ldr	r5, [pc, #520]	; (8004c98 <PE_SubStateMachine_VconnSwap+0x21c>)
 8004a90:	2107      	movs	r1, #7
 8004a92:	7832      	ldrb	r2, [r6, #0]
 8004a94:	2a9d      	cmp	r2, #157	; 0x9d
 8004a96:	d011      	beq.n	8004abc <PE_SubStateMachine_VconnSwap+0x40>
 8004a98:	d30f      	bcc.n	8004aba <PE_SubStateMachine_VconnSwap+0x3e>
 8004a9a:	2a9f      	cmp	r2, #159	; 0x9f
 8004a9c:	d077      	beq.n	8004b8e <PE_SubStateMachine_VconnSwap+0x112>
 8004a9e:	d34b      	bcc.n	8004b38 <PE_SubStateMachine_VconnSwap+0xbc>
 8004aa0:	2aa1      	cmp	r2, #161	; 0xa1
 8004aa2:	d100      	bne.n	8004aa6 <PE_SubStateMachine_VconnSwap+0x2a>
 8004aa4:	e0b0      	b.n	8004c08 <PE_SubStateMachine_VconnSwap+0x18c>
 8004aa6:	d200      	bcs.n	8004aaa <PE_SubStateMachine_VconnSwap+0x2e>
 8004aa8:	e0a3      	b.n	8004bf2 <PE_SubStateMachine_VconnSwap+0x176>
 8004aaa:	2aa3      	cmp	r2, #163	; 0xa3
 8004aac:	d100      	bne.n	8004ab0 <PE_SubStateMachine_VconnSwap+0x34>
 8004aae:	e0f5      	b.n	8004c9c <PE_SubStateMachine_VconnSwap+0x220>
 8004ab0:	d200      	bcs.n	8004ab4 <PE_SubStateMachine_VconnSwap+0x38>
 8004ab2:	e0c9      	b.n	8004c48 <PE_SubStateMachine_VconnSwap+0x1cc>
 8004ab4:	2aa4      	cmp	r2, #164	; 0xa4
 8004ab6:	d100      	bne.n	8004aba <PE_SubStateMachine_VconnSwap+0x3e>
 8004ab8:	e18f      	b.n	8004dda <PE_SubStateMachine_VconnSwap+0x35e>
 8004aba:	e1a3      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004abc:	6860      	ldr	r0, [r4, #4]
 8004abe:	2703      	movs	r7, #3
 8004ac0:	7842      	ldrb	r2, [r0, #1]
 8004ac2:	0912      	lsrs	r2, r2, #4
 8004ac4:	4011      	ands	r1, r2
 8004ac6:	2903      	cmp	r1, #3
 8004ac8:	d169      	bne.n	8004b9e <PE_SubStateMachine_VconnSwap+0x122>
 8004aca:	6800      	ldr	r0, [r0, #0]
 8004acc:	0501      	lsls	r1, r0, #20
 8004ace:	0fc9      	lsrs	r1, r1, #31
 8004ad0:	d065      	beq.n	8004b9e <PE_SubStateMachine_VconnSwap+0x122>
 8004ad2:	7b21      	ldrb	r1, [r4, #12]
 8004ad4:	07c8      	lsls	r0, r1, #31
 8004ad6:	0fc0      	lsrs	r0, r0, #31
 8004ad8:	68a1      	ldr	r1, [r4, #8]
 8004ada:	6b09      	ldr	r1, [r1, #48]	; 0x30
 8004adc:	4788      	blx	r1
 8004ade:	280a      	cmp	r0, #10
 8004ae0:	d002      	beq.n	8004ae8 <PE_SubStateMachine_VconnSwap+0x6c>
 8004ae2:	280d      	cmp	r0, #13
 8004ae4:	d008      	beq.n	8004af8 <PE_SubStateMachine_VconnSwap+0x7c>
 8004ae6:	e01e      	b.n	8004b26 <PE_SubStateMachine_VconnSwap+0xaa>
 8004ae8:	209e      	movs	r0, #158	; 0x9e
 8004aea:	7030      	strb	r0, [r6, #0]
 8004aec:	68e0      	ldr	r0, [r4, #12]
 8004aee:	2180      	movs	r1, #128	; 0x80
 8004af0:	0109      	lsls	r1, r1, #4
 8004af2:	4301      	orrs	r1, r0
 8004af4:	60e1      	str	r1, [r4, #12]
 8004af6:	e185      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004af8:	2000      	movs	r0, #0
 8004afa:	9000      	str	r0, [sp, #0]
 8004afc:	2303      	movs	r3, #3
 8004afe:	220c      	movs	r2, #12
 8004b00:	2100      	movs	r1, #0
 8004b02:	0020      	movs	r0, r4
 8004b04:	f7fe fe35 	bl	8003772 <PE_Send_CtrlMessage>
 8004b08:	7828      	ldrb	r0, [r5, #0]
 8004b0a:	0780      	lsls	r0, r0, #30
 8004b0c:	d509      	bpl.n	8004b22 <PE_SubStateMachine_VconnSwap+0xa6>
 8004b0e:	2000      	movs	r0, #0
 8004b10:	9000      	str	r0, [sp, #0]
 8004b12:	2300      	movs	r3, #0
 8004b14:	223e      	movs	r2, #62	; 0x3e
 8004b16:	7b20      	ldrb	r0, [r4, #12]
 8004b18:	07c1      	lsls	r1, r0, #31
 8004b1a:	0fc9      	lsrs	r1, r1, #31
 8004b1c:	2009      	movs	r0, #9
 8004b1e:	68ed      	ldr	r5, [r5, #12]
 8004b20:	47a8      	blx	r5
 8004b22:	213e      	movs	r1, #62	; 0x3e
 8004b24:	e08c      	b.n	8004c40 <PE_SubStateMachine_VconnSwap+0x1c4>
 8004b26:	2000      	movs	r0, #0
 8004b28:	9000      	str	r0, [sp, #0]
 8004b2a:	2303      	movs	r3, #3
 8004b2c:	2204      	movs	r2, #4
 8004b2e:	2100      	movs	r1, #0
 8004b30:	0020      	movs	r0, r4
 8004b32:	f7fe fe1e 	bl	8003772 <PE_Send_CtrlMessage>
 8004b36:	e036      	b.n	8004ba6 <PE_SubStateMachine_VconnSwap+0x12a>
 8004b38:	2000      	movs	r0, #0
 8004b3a:	9000      	str	r0, [sp, #0]
 8004b3c:	239e      	movs	r3, #158	; 0x9e
 8004b3e:	2203      	movs	r2, #3
 8004b40:	2100      	movs	r1, #0
 8004b42:	0020      	movs	r0, r4
 8004b44:	f7fe fe15 	bl	8003772 <PE_Send_CtrlMessage>
 8004b48:	2800      	cmp	r0, #0
 8004b4a:	d1d4      	bne.n	8004af6 <PE_SubStateMachine_VconnSwap+0x7a>
 8004b4c:	2701      	movs	r7, #1
 8004b4e:	6860      	ldr	r0, [r4, #4]
 8004b50:	6800      	ldr	r0, [r0, #0]
 8004b52:	0c80      	lsrs	r0, r0, #18
 8004b54:	4038      	ands	r0, r7
 8004b56:	d006      	beq.n	8004b66 <PE_SubStateMachine_VconnSwap+0xea>
 8004b58:	209f      	movs	r0, #159	; 0x9f
 8004b5a:	7030      	strb	r0, [r6, #0]
 8004b5c:	48aa      	ldr	r0, [pc, #680]	; (8004e08 <.text_81>)
 8004b5e:	84f0      	strh	r0, [r6, #38]	; 0x26
 8004b60:	2064      	movs	r0, #100	; 0x64
 8004b62:	9001      	str	r0, [sp, #4]
 8004b64:	e001      	b.n	8004b6a <PE_SubStateMachine_VconnSwap+0xee>
 8004b66:	20a0      	movs	r0, #160	; 0xa0
 8004b68:	7030      	strb	r0, [r6, #0]
 8004b6a:	7828      	ldrb	r0, [r5, #0]
 8004b6c:	0780      	lsls	r0, r0, #30
 8004b6e:	d509      	bpl.n	8004b84 <PE_SubStateMachine_VconnSwap+0x108>
 8004b70:	2000      	movs	r0, #0
 8004b72:	9000      	str	r0, [sp, #0]
 8004b74:	2300      	movs	r3, #0
 8004b76:	223d      	movs	r2, #61	; 0x3d
 8004b78:	68e0      	ldr	r0, [r4, #12]
 8004b7a:	2101      	movs	r1, #1
 8004b7c:	4001      	ands	r1, r0
 8004b7e:	2009      	movs	r0, #9
 8004b80:	68ed      	ldr	r5, [r5, #12]
 8004b82:	47a8      	blx	r5
 8004b84:	213d      	movs	r1, #61	; 0x3d
 8004b86:	68e0      	ldr	r0, [r4, #12]
 8004b88:	4007      	ands	r7, r0
 8004b8a:	0038      	movs	r0, r7
 8004b8c:	e080      	b.n	8004c90 <PE_SubStateMachine_VconnSwap+0x214>
 8004b8e:	2703      	movs	r7, #3
 8004b90:	8cf2      	ldrh	r2, [r6, #38]	; 0x26
 8004b92:	2380      	movs	r3, #128	; 0x80
 8004b94:	021b      	lsls	r3, r3, #8
 8004b96:	429a      	cmp	r2, r3
 8004b98:	d107      	bne.n	8004baa <PE_SubStateMachine_VconnSwap+0x12e>
 8004b9a:	2000      	movs	r0, #0
 8004b9c:	84f0      	strh	r0, [r6, #38]	; 0x26
 8004b9e:	68e0      	ldr	r0, [r4, #12]
 8004ba0:	499a      	ldr	r1, [pc, #616]	; (8004e0c <.text_82>)
 8004ba2:	4001      	ands	r1, r0
 8004ba4:	60e1      	str	r1, [r4, #12]
 8004ba6:	7037      	strb	r7, [r6, #0]
 8004ba8:	e12c      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004baa:	9a02      	ldr	r2, [sp, #8]
 8004bac:	7812      	ldrb	r2, [r2, #0]
 8004bae:	2a11      	cmp	r2, #17
 8004bb0:	d1fa      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bb2:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004bb4:	0bd2      	lsrs	r2, r2, #15
 8004bb6:	d1f7      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bb8:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004bba:	0b12      	lsrs	r2, r2, #12
 8004bbc:	420a      	tst	r2, r1
 8004bbe:	d1f3      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bc0:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 8004bc2:	4008      	ands	r0, r1
 8004bc4:	2806      	cmp	r0, #6
 8004bc6:	d1ef      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bc8:	2014      	movs	r0, #20
 8004bca:	9902      	ldr	r1, [sp, #8]
 8004bcc:	7008      	strb	r0, [r1, #0]
 8004bce:	68a0      	ldr	r0, [r4, #8]
 8004bd0:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004bd2:	2a00      	cmp	r2, #0
 8004bd4:	d004      	beq.n	8004be0 <PE_SubStateMachine_VconnSwap+0x164>
 8004bd6:	2100      	movs	r1, #0
 8004bd8:	7b23      	ldrb	r3, [r4, #12]
 8004bda:	07d8      	lsls	r0, r3, #31
 8004bdc:	0fc0      	lsrs	r0, r0, #31
 8004bde:	4790      	blx	r2
 8004be0:	68e0      	ldr	r0, [r4, #12]
 8004be2:	498a      	ldr	r1, [pc, #552]	; (8004e0c <.text_82>)
 8004be4:	4001      	ands	r1, r0
 8004be6:	60e1      	str	r1, [r4, #12]
 8004be8:	7037      	strb	r7, [r6, #0]
 8004bea:	7828      	ldrb	r0, [r5, #0]
 8004bec:	0780      	lsls	r0, r0, #30
 8004bee:	d41c      	bmi.n	8004c2a <PE_SubStateMachine_VconnSwap+0x1ae>
 8004bf0:	e025      	b.n	8004c3e <PE_SubStateMachine_VconnSwap+0x1c2>
 8004bf2:	68a0      	ldr	r0, [r4, #8]
 8004bf4:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004bf6:	2a00      	cmp	r2, #0
 8004bf8:	d004      	beq.n	8004c04 <PE_SubStateMachine_VconnSwap+0x188>
 8004bfa:	2101      	movs	r1, #1
 8004bfc:	7b23      	ldrb	r3, [r4, #12]
 8004bfe:	07d8      	lsls	r0, r3, #31
 8004c00:	0fc0      	lsrs	r0, r0, #31
 8004c02:	4790      	blx	r2
 8004c04:	20a1      	movs	r0, #161	; 0xa1
 8004c06:	e0fc      	b.n	8004e02 <PE_SubStateMachine_VconnSwap+0x386>
 8004c08:	2000      	movs	r0, #0
 8004c0a:	9000      	str	r0, [sp, #0]
 8004c0c:	2303      	movs	r3, #3
 8004c0e:	2206      	movs	r2, #6
 8004c10:	2100      	movs	r1, #0
 8004c12:	0020      	movs	r0, r4
 8004c14:	f7fe fdad 	bl	8003772 <PE_Send_CtrlMessage>
 8004c18:	2800      	cmp	r0, #0
 8004c1a:	d1c5      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004c1c:	68e0      	ldr	r0, [r4, #12]
 8004c1e:	497b      	ldr	r1, [pc, #492]	; (8004e0c <.text_82>)
 8004c20:	4001      	ands	r1, r0
 8004c22:	60e1      	str	r1, [r4, #12]
 8004c24:	7828      	ldrb	r0, [r5, #0]
 8004c26:	0780      	lsls	r0, r0, #30
 8004c28:	d509      	bpl.n	8004c3e <PE_SubStateMachine_VconnSwap+0x1c2>
 8004c2a:	2000      	movs	r0, #0
 8004c2c:	9000      	str	r0, [sp, #0]
 8004c2e:	2300      	movs	r3, #0
 8004c30:	2240      	movs	r2, #64	; 0x40
 8004c32:	7b20      	ldrb	r0, [r4, #12]
 8004c34:	07c1      	lsls	r1, r0, #31
 8004c36:	0fc9      	lsrs	r1, r1, #31
 8004c38:	2009      	movs	r0, #9
 8004c3a:	68ed      	ldr	r5, [r5, #12]
 8004c3c:	47a8      	blx	r5
 8004c3e:	2140      	movs	r1, #64	; 0x40
 8004c40:	7b22      	ldrb	r2, [r4, #12]
 8004c42:	07d0      	lsls	r0, r2, #31
 8004c44:	0fc0      	lsrs	r0, r0, #31
 8004c46:	e023      	b.n	8004c90 <PE_SubStateMachine_VconnSwap+0x214>
 8004c48:	2000      	movs	r0, #0
 8004c4a:	9000      	str	r0, [sp, #0]
 8004c4c:	23a3      	movs	r3, #163	; 0xa3
 8004c4e:	220b      	movs	r2, #11
 8004c50:	2100      	movs	r1, #0
 8004c52:	0020      	movs	r0, r4
 8004c54:	f7fe fd8d 	bl	8003772 <PE_Send_CtrlMessage>
 8004c58:	2800      	cmp	r0, #0
 8004c5a:	d11c      	bne.n	8004c96 <PE_SubStateMachine_VconnSwap+0x21a>
 8004c5c:	68e1      	ldr	r1, [r4, #12]
 8004c5e:	2080      	movs	r0, #128	; 0x80
 8004c60:	0100      	lsls	r0, r0, #4
 8004c62:	4308      	orrs	r0, r1
 8004c64:	60e0      	str	r0, [r4, #12]
 8004c66:	496a      	ldr	r1, [pc, #424]	; (8004e10 <.text_83>)
 8004c68:	82b1      	strh	r1, [r6, #20]
 8004c6a:	211a      	movs	r1, #26
 8004c6c:	9101      	str	r1, [sp, #4]
 8004c6e:	2601      	movs	r6, #1
 8004c70:	7829      	ldrb	r1, [r5, #0]
 8004c72:	0789      	lsls	r1, r1, #30
 8004c74:	d508      	bpl.n	8004c88 <PE_SubStateMachine_VconnSwap+0x20c>
 8004c76:	2100      	movs	r1, #0
 8004c78:	9100      	str	r1, [sp, #0]
 8004c7a:	2300      	movs	r3, #0
 8004c7c:	223c      	movs	r2, #60	; 0x3c
 8004c7e:	2101      	movs	r1, #1
 8004c80:	4001      	ands	r1, r0
 8004c82:	2009      	movs	r0, #9
 8004c84:	68ed      	ldr	r5, [r5, #12]
 8004c86:	47a8      	blx	r5
 8004c88:	213c      	movs	r1, #60	; 0x3c
 8004c8a:	68e0      	ldr	r0, [r4, #12]
 8004c8c:	4006      	ands	r6, r0
 8004c8e:	0030      	movs	r0, r6
 8004c90:	68a2      	ldr	r2, [r4, #8]
 8004c92:	68d2      	ldr	r2, [r2, #12]
 8004c94:	4790      	blx	r2
 8004c96:	e0b5      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004c98:	200019ac 	.word	0x200019ac
 8004c9c:	9a02      	ldr	r2, [sp, #8]
 8004c9e:	7812      	ldrb	r2, [r2, #0]
 8004ca0:	2a11      	cmp	r2, #17
 8004ca2:	d110      	bne.n	8004cc6 <PE_SubStateMachine_VconnSwap+0x24a>
 8004ca4:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004ca6:	0bd2      	lsrs	r2, r2, #15
 8004ca8:	d10d      	bne.n	8004cc6 <PE_SubStateMachine_VconnSwap+0x24a>
 8004caa:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004cac:	0b12      	lsrs	r2, r2, #12
 8004cae:	420a      	tst	r2, r1
 8004cb0:	d109      	bne.n	8004cc6 <PE_SubStateMachine_VconnSwap+0x24a>
 8004cb2:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 8004cb4:	4008      	ands	r0, r1
 8004cb6:	2803      	cmp	r0, #3
 8004cb8:	d006      	beq.n	8004cc8 <PE_SubStateMachine_VconnSwap+0x24c>
 8004cba:	2804      	cmp	r0, #4
 8004cbc:	d03f      	beq.n	8004d3e <PE_SubStateMachine_VconnSwap+0x2c2>
 8004cbe:	280c      	cmp	r0, #12
 8004cc0:	d020      	beq.n	8004d04 <PE_SubStateMachine_VconnSwap+0x288>
 8004cc2:	2810      	cmp	r0, #16
 8004cc4:	d05a      	beq.n	8004d7c <PE_SubStateMachine_VconnSwap+0x300>
 8004cc6:	e080      	b.n	8004dca <PE_SubStateMachine_VconnSwap+0x34e>
 8004cc8:	2000      	movs	r0, #0
 8004cca:	82b0      	strh	r0, [r6, #20]
 8004ccc:	2701      	movs	r7, #1
 8004cce:	6860      	ldr	r0, [r4, #4]
 8004cd0:	6800      	ldr	r0, [r0, #0]
 8004cd2:	0c80      	lsrs	r0, r0, #18
 8004cd4:	4038      	ands	r0, r7
 8004cd6:	d001      	beq.n	8004cdc <PE_SubStateMachine_VconnSwap+0x260>
 8004cd8:	209f      	movs	r0, #159	; 0x9f
 8004cda:	e000      	b.n	8004cde <PE_SubStateMachine_VconnSwap+0x262>
 8004cdc:	20a0      	movs	r0, #160	; 0xa0
 8004cde:	7030      	strb	r0, [r6, #0]
 8004ce0:	2014      	movs	r0, #20
 8004ce2:	9902      	ldr	r1, [sp, #8]
 8004ce4:	7008      	strb	r0, [r1, #0]
 8004ce6:	7828      	ldrb	r0, [r5, #0]
 8004ce8:	0780      	lsls	r0, r0, #30
 8004cea:	d509      	bpl.n	8004d00 <PE_SubStateMachine_VconnSwap+0x284>
 8004cec:	2000      	movs	r0, #0
 8004cee:	9000      	str	r0, [sp, #0]
 8004cf0:	2300      	movs	r3, #0
 8004cf2:	223d      	movs	r2, #61	; 0x3d
 8004cf4:	68e0      	ldr	r0, [r4, #12]
 8004cf6:	2101      	movs	r1, #1
 8004cf8:	4001      	ands	r1, r0
 8004cfa:	2009      	movs	r0, #9
 8004cfc:	68ed      	ldr	r5, [r5, #12]
 8004cfe:	47a8      	blx	r5
 8004d00:	213d      	movs	r1, #61	; 0x3d
 8004d02:	e05c      	b.n	8004dbe <PE_SubStateMachine_VconnSwap+0x342>
 8004d04:	2000      	movs	r0, #0
 8004d06:	82b0      	strh	r0, [r6, #20]
 8004d08:	68e0      	ldr	r0, [r4, #12]
 8004d0a:	4940      	ldr	r1, [pc, #256]	; (8004e0c <.text_82>)
 8004d0c:	4001      	ands	r1, r0
 8004d0e:	60e1      	str	r1, [r4, #12]
 8004d10:	2003      	movs	r0, #3
 8004d12:	7030      	strb	r0, [r6, #0]
 8004d14:	2014      	movs	r0, #20
 8004d16:	9902      	ldr	r1, [sp, #8]
 8004d18:	7008      	strb	r0, [r1, #0]
 8004d1a:	7828      	ldrb	r0, [r5, #0]
 8004d1c:	0780      	lsls	r0, r0, #30
 8004d1e:	d509      	bpl.n	8004d34 <PE_SubStateMachine_VconnSwap+0x2b8>
 8004d20:	2000      	movs	r0, #0
 8004d22:	9000      	str	r0, [sp, #0]
 8004d24:	2300      	movs	r3, #0
 8004d26:	223e      	movs	r2, #62	; 0x3e
 8004d28:	7b20      	ldrb	r0, [r4, #12]
 8004d2a:	07c1      	lsls	r1, r0, #31
 8004d2c:	0fc9      	lsrs	r1, r1, #31
 8004d2e:	2009      	movs	r0, #9
 8004d30:	68ed      	ldr	r5, [r5, #12]
 8004d32:	47a8      	blx	r5
 8004d34:	213e      	movs	r1, #62	; 0x3e
 8004d36:	7b22      	ldrb	r2, [r4, #12]
 8004d38:	07d0      	lsls	r0, r2, #31
 8004d3a:	0fc0      	lsrs	r0, r0, #31
 8004d3c:	e042      	b.n	8004dc4 <PE_SubStateMachine_VconnSwap+0x348>
 8004d3e:	2000      	movs	r0, #0
 8004d40:	82b0      	strh	r0, [r6, #20]
 8004d42:	68e0      	ldr	r0, [r4, #12]
 8004d44:	4931      	ldr	r1, [pc, #196]	; (8004e0c <.text_82>)
 8004d46:	4001      	ands	r1, r0
 8004d48:	60e1      	str	r1, [r4, #12]
 8004d4a:	2003      	movs	r0, #3
 8004d4c:	7030      	strb	r0, [r6, #0]
 8004d4e:	2014      	movs	r0, #20
 8004d50:	9902      	ldr	r1, [sp, #8]
 8004d52:	7008      	strb	r0, [r1, #0]
 8004d54:	7828      	ldrb	r0, [r5, #0]
 8004d56:	0780      	lsls	r0, r0, #30
 8004d58:	d509      	bpl.n	8004d6e <PE_SubStateMachine_VconnSwap+0x2f2>
 8004d5a:	2000      	movs	r0, #0
 8004d5c:	9000      	str	r0, [sp, #0]
 8004d5e:	2300      	movs	r3, #0
 8004d60:	223f      	movs	r2, #63	; 0x3f
 8004d62:	7b20      	ldrb	r0, [r4, #12]
 8004d64:	07c1      	lsls	r1, r0, #31
 8004d66:	0fc9      	lsrs	r1, r1, #31
 8004d68:	2009      	movs	r0, #9
 8004d6a:	68ef      	ldr	r7, [r5, #12]
 8004d6c:	47b8      	blx	r7
 8004d6e:	213f      	movs	r1, #63	; 0x3f
 8004d70:	7b22      	ldrb	r2, [r4, #12]
 8004d72:	07d0      	lsls	r0, r2, #31
 8004d74:	0fc0      	lsrs	r0, r0, #31
 8004d76:	68a2      	ldr	r2, [r4, #8]
 8004d78:	68d2      	ldr	r2, [r2, #12]
 8004d7a:	4790      	blx	r2
 8004d7c:	2000      	movs	r0, #0
 8004d7e:	82b0      	strh	r0, [r6, #20]
 8004d80:	2701      	movs	r7, #1
 8004d82:	6860      	ldr	r0, [r4, #4]
 8004d84:	6800      	ldr	r0, [r0, #0]
 8004d86:	0c80      	lsrs	r0, r0, #18
 8004d88:	4038      	ands	r0, r7
 8004d8a:	d101      	bne.n	8004d90 <PE_SubStateMachine_VconnSwap+0x314>
 8004d8c:	20a4      	movs	r0, #164	; 0xa4
 8004d8e:	e004      	b.n	8004d9a <PE_SubStateMachine_VconnSwap+0x31e>
 8004d90:	68e0      	ldr	r0, [r4, #12]
 8004d92:	491e      	ldr	r1, [pc, #120]	; (8004e0c <.text_82>)
 8004d94:	4001      	ands	r1, r0
 8004d96:	60e1      	str	r1, [r4, #12]
 8004d98:	2003      	movs	r0, #3
 8004d9a:	7030      	strb	r0, [r6, #0]
 8004d9c:	2014      	movs	r0, #20
 8004d9e:	9902      	ldr	r1, [sp, #8]
 8004da0:	7008      	strb	r0, [r1, #0]
 8004da2:	7828      	ldrb	r0, [r5, #0]
 8004da4:	0780      	lsls	r0, r0, #30
 8004da6:	d509      	bpl.n	8004dbc <PE_SubStateMachine_VconnSwap+0x340>
 8004da8:	2000      	movs	r0, #0
 8004daa:	9000      	str	r0, [sp, #0]
 8004dac:	2300      	movs	r3, #0
 8004dae:	2255      	movs	r2, #85	; 0x55
 8004db0:	68e0      	ldr	r0, [r4, #12]
 8004db2:	2101      	movs	r1, #1
 8004db4:	4001      	ands	r1, r0
 8004db6:	2009      	movs	r0, #9
 8004db8:	68ed      	ldr	r5, [r5, #12]
 8004dba:	47a8      	blx	r5
 8004dbc:	2155      	movs	r1, #85	; 0x55
 8004dbe:	68e0      	ldr	r0, [r4, #12]
 8004dc0:	4007      	ands	r7, r0
 8004dc2:	0038      	movs	r0, r7
 8004dc4:	68a2      	ldr	r2, [r4, #8]
 8004dc6:	68d2      	ldr	r2, [r2, #12]
 8004dc8:	4790      	blx	r2
 8004dca:	8ab0      	ldrh	r0, [r6, #20]
 8004dcc:	2180      	movs	r1, #128	; 0x80
 8004dce:	0209      	lsls	r1, r1, #8
 8004dd0:	4288      	cmp	r0, r1
 8004dd2:	d117      	bne.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004dd4:	2000      	movs	r0, #0
 8004dd6:	82b0      	strh	r0, [r6, #20]
 8004dd8:	e00e      	b.n	8004df8 <PE_SubStateMachine_VconnSwap+0x37c>
 8004dda:	68a0      	ldr	r0, [r4, #8]
 8004ddc:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004dde:	2a00      	cmp	r2, #0
 8004de0:	d004      	beq.n	8004dec <PE_SubStateMachine_VconnSwap+0x370>
 8004de2:	2101      	movs	r1, #1
 8004de4:	7b23      	ldrb	r3, [r4, #12]
 8004de6:	07d8      	lsls	r0, r3, #31
 8004de8:	0fc0      	lsrs	r0, r0, #31
 8004dea:	4790      	blx	r2
 8004dec:	6860      	ldr	r0, [r4, #4]
 8004dee:	6801      	ldr	r1, [r0, #0]
 8004df0:	2280      	movs	r2, #128	; 0x80
 8004df2:	02d2      	lsls	r2, r2, #11
 8004df4:	430a      	orrs	r2, r1
 8004df6:	6002      	str	r2, [r0, #0]
 8004df8:	68e0      	ldr	r0, [r4, #12]
 8004dfa:	4904      	ldr	r1, [pc, #16]	; (8004e0c <.text_82>)
 8004dfc:	4001      	ands	r1, r0
 8004dfe:	60e1      	str	r1, [r4, #12]
 8004e00:	2003      	movs	r0, #3
 8004e02:	7030      	strb	r0, [r6, #0]
 8004e04:	9801      	ldr	r0, [sp, #4]
 8004e06:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08004e08 <.text_81>:
 8004e08:	00008064 	.word	0x00008064

08004e0c <.text_82>:
 8004e0c:	fffff7ff 	.word	0xfffff7ff

08004e10 <.text_83>:
 8004e10:	0000801a 	.word	0x0000801a

08004e14 <USBPD_PE_ExecFastRoleSwapSignalling>:
 8004e14:	b580      	push	{r7, lr}
 8004e16:	f000 f8bc 	bl	8004f92 <USBPD_PRL_FastRoleSwapSignalling>
 8004e1a:	bd01      	pop	{r0, pc}

08004e1c <USBPD_PRL_TimerCounter>:
 8004e1c:	b081      	sub	sp, #4
 8004e1e:	4965      	ldr	r1, [pc, #404]	; (8004fb4 <.text_17>)
 8004e20:	0080      	lsls	r0, r0, #2
 8004e22:	1808      	adds	r0, r1, r0
 8004e24:	6841      	ldr	r1, [r0, #4]
 8004e26:	7a8a      	ldrb	r2, [r1, #10]
 8004e28:	2a00      	cmp	r2, #0
 8004e2a:	d001      	beq.n	8004e30 <USBPD_PRL_TimerCounter+0x14>
 8004e2c:	1e52      	subs	r2, r2, #1
 8004e2e:	728a      	strb	r2, [r1, #10]
 8004e30:	6840      	ldr	r0, [r0, #4]
 8004e32:	8e81      	ldrh	r1, [r0, #52]	; 0x34
 8004e34:	2900      	cmp	r1, #0
 8004e36:	d001      	beq.n	8004e3c <USBPD_PRL_TimerCounter+0x20>
 8004e38:	1e49      	subs	r1, r1, #1
 8004e3a:	8681      	strh	r1, [r0, #52]	; 0x34
 8004e3c:	b001      	add	sp, #4
 8004e3e:	4770      	bx	lr

08004e40 <USBPD_PRL_Init>:
 8004e40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8004e42:	b082      	sub	sp, #8
 8004e44:	001c      	movs	r4, r3
 8004e46:	4668      	mov	r0, sp
 8004e48:	7a00      	ldrb	r0, [r0, #8]
 8004e4a:	2801      	cmp	r0, #1
 8004e4c:	d83a      	bhi.n	8004ec4 <USBPD_PRL_Init+0x84>
 8004e4e:	2038      	movs	r0, #56	; 0x38
 8004e50:	f007 fb8a 	bl	800c568 <malloc>
 8004e54:	4957      	ldr	r1, [pc, #348]	; (8004fb4 <.text_17>)
 8004e56:	466a      	mov	r2, sp
 8004e58:	7a12      	ldrb	r2, [r2, #8]
 8004e5a:	0092      	lsls	r2, r2, #2
 8004e5c:	188d      	adds	r5, r1, r2
 8004e5e:	6068      	str	r0, [r5, #4]
 8004e60:	2800      	cmp	r0, #0
 8004e62:	d101      	bne.n	8004e68 <USBPD_PRL_Init+0x28>
 8004e64:	2016      	movs	r0, #22
 8004e66:	e02e      	b.n	8004ec6 <USBPD_PRL_Init+0x86>
 8004e68:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8004e6a:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8004e6c:	4669      	mov	r1, sp
 8004e6e:	710c      	strb	r4, [r1, #4]
 8004e70:	2138      	movs	r1, #56	; 0x38
 8004e72:	f007 fb49 	bl	800c508 <__aeabi_memclr>
 8004e76:	6868      	ldr	r0, [r5, #4]
 8004e78:	2400      	movs	r4, #0
 8004e7a:	7104      	strb	r4, [r0, #4]
 8004e7c:	7144      	strb	r4, [r0, #5]
 8004e7e:	6006      	str	r6, [r0, #0]
 8004e80:	7284      	strb	r4, [r0, #10]
 8004e82:	6869      	ldr	r1, [r5, #4]
 8004e84:	72cc      	strb	r4, [r1, #11]
 8004e86:	220f      	movs	r2, #15
 8004e88:	2103      	movs	r1, #3
 8004e8a:	6868      	ldr	r0, [r5, #4]
 8004e8c:	1d80      	adds	r0, r0, #6
 8004e8e:	f007 fb40 	bl	800c512 <__aeabi_memset>
 8004e92:	6869      	ldr	r1, [r5, #4]
 8004e94:	730c      	strb	r4, [r1, #12]
 8004e96:	6868      	ldr	r0, [r5, #4]
 8004e98:	9904      	ldr	r1, [sp, #16]
 8004e9a:	62c1      	str	r1, [r0, #44]	; 0x2c
 8004e9c:	990a      	ldr	r1, [sp, #40]	; 0x28
 8004e9e:	6281      	str	r1, [r0, #40]	; 0x28
 8004ea0:	6247      	str	r7, [r0, #36]	; 0x24
 8004ea2:	9903      	ldr	r1, [sp, #12]
 8004ea4:	6301      	str	r1, [r0, #48]	; 0x30
 8004ea6:	7344      	strb	r4, [r0, #13]
 8004ea8:	6868      	ldr	r0, [r5, #4]
 8004eaa:	7384      	strb	r4, [r0, #14]
 8004eac:	2001      	movs	r0, #1
 8004eae:	9000      	str	r0, [sp, #0]
 8004eb0:	4668      	mov	r0, sp
 8004eb2:	7903      	ldrb	r3, [r0, #4]
 8004eb4:	6868      	ldr	r0, [r5, #4]
 8004eb6:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8004eb8:	a104      	add	r1, pc, #16	; (adr r1, 8004ecc <PRL_PhyCallbacks>)
 8004eba:	4668      	mov	r0, sp
 8004ebc:	7a00      	ldrb	r0, [r0, #8]
 8004ebe:	f004 fbd5 	bl	800966c <USBPD_PHY_Init>
 8004ec2:	e000      	b.n	8004ec6 <USBPD_PRL_Init+0x86>
 8004ec4:	2002      	movs	r0, #2
 8004ec6:	b005      	add	sp, #20
 8004ec8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08004ecc <PRL_PhyCallbacks>:
 8004ecc:	54af 0800 57d1 0800 5819 0800 5827 0800     .T...W...X..'X..
 8004edc:	5839 0800 5855 0800                         9X..UX..

08004ee4 <USBPD_PRL_GetMemoryConsumption>:
 8004ee4:	2070      	movs	r0, #112	; 0x70
 8004ee6:	4770      	bx	lr

08004ee8 <USBPD_PRL_SetHeader>:
 8004ee8:	b530      	push	{r4, r5, lr}
 8004eea:	4c32      	ldr	r4, [pc, #200]	; (8004fb4 <.text_17>)
 8004eec:	0080      	lsls	r0, r0, #2
 8004eee:	1820      	adds	r0, r4, r0
 8004ef0:	6840      	ldr	r0, [r0, #4]
 8004ef2:	8a84      	ldrh	r4, [r0, #20]
 8004ef4:	4d30      	ldr	r5, [pc, #192]	; (8004fb8 <.text_18>)
 8004ef6:	4025      	ands	r5, r4
 8004ef8:	0209      	lsls	r1, r1, #8
 8004efa:	2480      	movs	r4, #128	; 0x80
 8004efc:	0064      	lsls	r4, r4, #1
 8004efe:	4021      	ands	r1, r4
 8004f00:	4329      	orrs	r1, r5
 8004f02:	8281      	strh	r1, [r0, #20]
 8004f04:	4c2d      	ldr	r4, [pc, #180]	; (8004fbc <.text_19>)
 8004f06:	400c      	ands	r4, r1
 8004f08:	0151      	lsls	r1, r2, #5
 8004f0a:	2220      	movs	r2, #32
 8004f0c:	4011      	ands	r1, r2
 8004f0e:	4321      	orrs	r1, r4
 8004f10:	8281      	strh	r1, [r0, #20]
 8004f12:	4a2b      	ldr	r2, [pc, #172]	; (8004fc0 <.text_20>)
 8004f14:	400a      	ands	r2, r1
 8004f16:	0199      	lsls	r1, r3, #6
 8004f18:	23c0      	movs	r3, #192	; 0xc0
 8004f1a:	400b      	ands	r3, r1
 8004f1c:	4313      	orrs	r3, r2
 8004f1e:	8283      	strh	r3, [r0, #20]
 8004f20:	bd30      	pop	{r4, r5, pc}

08004f22 <USBPD_PRL_SetHeaderPowerRole>:
 8004f22:	4a24      	ldr	r2, [pc, #144]	; (8004fb4 <.text_17>)
 8004f24:	0080      	lsls	r0, r0, #2
 8004f26:	1810      	adds	r0, r2, r0
 8004f28:	6840      	ldr	r0, [r0, #4]
 8004f2a:	8a82      	ldrh	r2, [r0, #20]
 8004f2c:	4b22      	ldr	r3, [pc, #136]	; (8004fb8 <.text_18>)
 8004f2e:	4013      	ands	r3, r2
 8004f30:	0209      	lsls	r1, r1, #8
 8004f32:	2280      	movs	r2, #128	; 0x80
 8004f34:	0052      	lsls	r2, r2, #1
 8004f36:	e008      	b.n	8004f4a <.text_10>

08004f38 <USBPD_PRL_SetHeaderDataRole>:
 8004f38:	4a1e      	ldr	r2, [pc, #120]	; (8004fb4 <.text_17>)
 8004f3a:	0080      	lsls	r0, r0, #2
 8004f3c:	1810      	adds	r0, r2, r0
 8004f3e:	6840      	ldr	r0, [r0, #4]
 8004f40:	8a82      	ldrh	r2, [r0, #20]
 8004f42:	4b1e      	ldr	r3, [pc, #120]	; (8004fbc <.text_19>)
 8004f44:	4013      	ands	r3, r2
 8004f46:	0149      	lsls	r1, r1, #5
 8004f48:	2220      	movs	r2, #32

08004f4a <.text_10>:
 8004f4a:	4011      	ands	r1, r2
 8004f4c:	4319      	orrs	r1, r3
 8004f4e:	8281      	strh	r1, [r0, #20]
 8004f50:	4770      	bx	lr

08004f52 <USBPD_PRL_SetHeaderSpecification>:
 8004f52:	4a18      	ldr	r2, [pc, #96]	; (8004fb4 <.text_17>)
 8004f54:	0080      	lsls	r0, r0, #2
 8004f56:	1810      	adds	r0, r2, r0
 8004f58:	6840      	ldr	r0, [r0, #4]
 8004f5a:	8a82      	ldrh	r2, [r0, #20]
 8004f5c:	4b18      	ldr	r3, [pc, #96]	; (8004fc0 <.text_20>)
 8004f5e:	4013      	ands	r3, r2
 8004f60:	0189      	lsls	r1, r1, #6
 8004f62:	22c0      	movs	r2, #192	; 0xc0
 8004f64:	400a      	ands	r2, r1
 8004f66:	431a      	orrs	r2, r3
 8004f68:	8282      	strh	r2, [r0, #20]
 8004f6a:	4770      	bx	lr

08004f6c <USBPD_PRL_SRCSetSinkNG>:
 8004f6c:	b580      	push	{r7, lr}
 8004f6e:	f004 fb51 	bl	8009614 <USBPD_PHY_SetResistor_SinkTxNG>
 8004f72:	bd01      	pop	{r0, pc}

08004f74 <USBPD_PRL_SRCReleaseSinkNG>:
 8004f74:	b510      	push	{r4, lr}
 8004f76:	0004      	movs	r4, r0
 8004f78:	f004 fb54 	bl	8009624 <USBPD_PHY_SetResistor_SinkTxOK>
 8004f7c:	480d      	ldr	r0, [pc, #52]	; (8004fb4 <.text_17>)
 8004f7e:	00a1      	lsls	r1, r4, #2
 8004f80:	1840      	adds	r0, r0, r1
 8004f82:	6840      	ldr	r0, [r0, #4]
 8004f84:	2106      	movs	r1, #6
 8004f86:	7101      	strb	r1, [r0, #4]
 8004f88:	bd10      	pop	{r4, pc}

08004f8a <USBPD_PRL_IsResistor_SinkTxOK>:
 8004f8a:	b580      	push	{r7, lr}
 8004f8c:	f004 fb53 	bl	8009636 <USBPD_PHY_IsResistor_SinkTxOk>
 8004f90:	bd02      	pop	{r1, pc}

08004f92 <USBPD_PRL_FastRoleSwapSignalling>:
 8004f92:	b580      	push	{r7, lr}
 8004f94:	f004 fb53 	bl	800963e <USBPD_PHY_FastRoleSwapSignalling>
 8004f98:	bd01      	pop	{r0, pc}

08004f9a <USBPD_PRL_CableCapable>:
 8004f9a:	b580      	push	{r7, lr}
 8004f9c:	2901      	cmp	r1, #1
 8004f9e:	d105      	bne.n	8004fac <USBPD_PRL_CableCapable+0x12>
 8004fa0:	4904      	ldr	r1, [pc, #16]	; (8004fb4 <.text_17>)
 8004fa2:	0082      	lsls	r2, r0, #2
 8004fa4:	1889      	adds	r1, r1, r2
 8004fa6:	6849      	ldr	r1, [r1, #4]
 8004fa8:	6809      	ldr	r1, [r1, #0]
 8004faa:	e000      	b.n	8004fae <USBPD_PRL_CableCapable+0x14>
 8004fac:	2101      	movs	r1, #1
 8004fae:	f004 fb41 	bl	8009634 <USBPD_PHY_SOPSupported>
 8004fb2:	bd01      	pop	{r0, pc}

08004fb4 <.text_17>:
 8004fb4:	200019c0 	.word	0x200019c0

08004fb8 <.text_18>:
 8004fb8:	0000feff 	.word	0x0000feff

08004fbc <.text_19>:
 8004fbc:	0000ffdf 	.word	0x0000ffdf

08004fc0 <.text_20>:
 8004fc0:	0000ff3f 	.word	0x0000ff3f

08004fc4 <USBPD_PRL_SendMessage>:
 8004fc4:	b5f5      	push	{r0, r2, r4, r5, r6, r7, lr}
 8004fc6:	b083      	sub	sp, #12
 8004fc8:	2703      	movs	r7, #3
 8004fca:	48b2      	ldr	r0, [pc, #712]	; (8005294 <USBPD_PRL_SendMessage+0x2d0>)
 8004fcc:	466a      	mov	r2, sp
 8004fce:	7b12      	ldrb	r2, [r2, #12]
 8004fd0:	0092      	lsls	r2, r2, #2
 8004fd2:	1884      	adds	r4, r0, r2
 8004fd4:	6860      	ldr	r0, [r4, #4]
 8004fd6:	7a42      	ldrb	r2, [r0, #9]
 8004fd8:	2a00      	cmp	r2, #0
 8004fda:	d104      	bne.n	8004fe6 <USBPD_PRL_SendMessage+0x22>
 8004fdc:	7902      	ldrb	r2, [r0, #4]
 8004fde:	2a06      	cmp	r2, #6
 8004fe0:	dd01      	ble.n	8004fe6 <USBPD_PRL_SendMessage+0x22>
 8004fe2:	220e      	movs	r2, #14
 8004fe4:	7102      	strb	r2, [r0, #4]
 8004fe6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8004fe8:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8004fea:	9302      	str	r3, [sp, #8]
 8004fec:	466b      	mov	r3, sp
 8004fee:	7119      	strb	r1, [r3, #4]
 8004ff0:	9200      	str	r2, [sp, #0]
 8004ff2:	2606      	movs	r6, #6
 8004ff4:	2200      	movs	r2, #0
 8004ff6:	7901      	ldrb	r1, [r0, #4]
 8004ff8:	290f      	cmp	r1, #15
 8004ffa:	d900      	bls.n	8004ffe <USBPD_PRL_SendMessage+0x3a>
 8004ffc:	e1c0      	b.n	8005380 <USBPD_PRL_SendMessage+0x3bc>
 8004ffe:	a302      	add	r3, pc, #8	; (adr r3, 8005008 <USBPD_PRL_SendMessage+0x44>)
 8005000:	0049      	lsls	r1, r1, #1
 8005002:	5a5b      	ldrh	r3, [r3, r1]
 8005004:	449f      	add	pc, r3
 8005006:	bf00      	nop
 8005008:	002e0020 	.word	0x002e0020
 800500c:	03780042 	.word	0x03780042
 8005010:	00900052 	.word	0x00900052
 8005014:	011e0078 	.word	0x011e0078
 8005018:	02900130 	.word	0x02900130
 800501c:	02dc02b6 	.word	0x02dc02b6
 8005020:	037802fc 	.word	0x037802fc
 8005024:	032e0372 	.word	0x032e0372
 8005028:	4668      	mov	r0, sp
 800502a:	7b00      	ldrb	r0, [r0, #12]
 800502c:	f004 fb1a 	bl	8009664 <USBPD_PHY_Reset>
 8005030:	6860      	ldr	r0, [r4, #4]
 8005032:	7106      	strb	r6, [r0, #4]
 8005034:	e1a6      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005036:	4668      	mov	r0, sp
 8005038:	7b00      	ldrb	r0, [r0, #12]
 800503a:	f004 faeb 	bl	8009614 <USBPD_PHY_SetResistor_SinkTxNG>
 800503e:	6860      	ldr	r0, [r4, #4]
 8005040:	2102      	movs	r1, #2
 8005042:	7101      	strb	r1, [r0, #4]
 8005044:	2111      	movs	r1, #17
 8005046:	8681      	strh	r1, [r0, #52]	; 0x34
 8005048:	e19c      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 800504a:	9900      	ldr	r1, [sp, #0]
 800504c:	2901      	cmp	r1, #1
 800504e:	d1ef      	bne.n	8005030 <USBPD_PRL_SendMessage+0x6c>
 8005050:	8e81      	ldrh	r1, [r0, #52]	; 0x34
 8005052:	2900      	cmp	r1, #0
 8005054:	d112      	bne.n	800507c <USBPD_PRL_SendMessage+0xb8>
 8005056:	2105      	movs	r1, #5
 8005058:	e168      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 800505a:	9800      	ldr	r0, [sp, #0]
 800505c:	2802      	cmp	r0, #2
 800505e:	d1e7      	bne.n	8005030 <USBPD_PRL_SendMessage+0x6c>
 8005060:	4668      	mov	r0, sp
 8005062:	7b00      	ldrb	r0, [r0, #12]
 8005064:	f004 fae7 	bl	8009636 <USBPD_PHY_IsResistor_SinkTxOk>
 8005068:	2801      	cmp	r0, #1
 800506a:	d107      	bne.n	800507c <USBPD_PRL_SendMessage+0xb8>
 800506c:	2005      	movs	r0, #5
 800506e:	6861      	ldr	r1, [r4, #4]
 8005070:	7108      	strb	r0, [r1, #4]
 8005072:	4668      	mov	r0, sp
 8005074:	7b00      	ldrb	r0, [r0, #12]
 8005076:	f004 fade 	bl	8009636 <USBPD_PHY_IsResistor_SinkTxOk>
 800507a:	e183      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 800507c:	2009      	movs	r0, #9
 800507e:	e182      	b.n	8005386 <USBPD_PRL_SendMessage+0x3c2>
 8005080:	8a81      	ldrh	r1, [r0, #20]
 8005082:	0609      	lsls	r1, r1, #24
 8005084:	0f89      	lsrs	r1, r1, #30
 8005086:	2902      	cmp	r1, #2
 8005088:	d106      	bne.n	8005098 <USBPD_PRL_SendMessage+0xd4>
 800508a:	9900      	ldr	r1, [sp, #0]
 800508c:	2901      	cmp	r1, #1
 800508e:	d002      	beq.n	8005096 <USBPD_PRL_SendMessage+0xd2>
 8005090:	2902      	cmp	r1, #2
 8005092:	d101      	bne.n	8005098 <USBPD_PRL_SendMessage+0xd4>
 8005094:	2104      	movs	r1, #4
 8005096:	e149      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 8005098:	4669      	mov	r1, sp
 800509a:	7c09      	ldrb	r1, [r1, #16]
 800509c:	23ff      	movs	r3, #255	; 0xff
 800509e:	7243      	strb	r3, [r0, #9]
 80050a0:	8a86      	ldrh	r6, [r0, #20]
 80050a2:	4bbd      	ldr	r3, [pc, #756]	; (8005398 <.text_23>)
 80050a4:	4033      	ands	r3, r6
 80050a6:	06ce      	lsls	r6, r1, #27
 80050a8:	0ef6      	lsrs	r6, r6, #27
 80050aa:	431e      	orrs	r6, r3
 80050ac:	8286      	strh	r6, [r0, #20]
 80050ae:	0473      	lsls	r3, r6, #17
 80050b0:	0c5b      	lsrs	r3, r3, #17
 80050b2:	09ce      	lsrs	r6, r1, #7
 80050b4:	03f6      	lsls	r6, r6, #15
 80050b6:	431e      	orrs	r6, r3
 80050b8:	8286      	strh	r6, [r0, #20]
 80050ba:	7302      	strb	r2, [r0, #12]
 80050bc:	6860      	ldr	r0, [r4, #4]
 80050be:	8a83      	ldrh	r3, [r0, #20]
 80050c0:	0bdc      	lsrs	r4, r3, #15
 80050c2:	d018      	beq.n	80050f6 <USBPD_PRL_SendMessage+0x132>
 80050c4:	9b02      	ldr	r3, [sp, #8]
 80050c6:	789b      	ldrb	r3, [r3, #2]
 80050c8:	9c02      	ldr	r4, [sp, #8]
 80050ca:	78e4      	ldrb	r4, [r4, #3]
 80050cc:	0224      	lsls	r4, r4, #8
 80050ce:	191b      	adds	r3, r3, r4
 80050d0:	8343      	strh	r3, [r0, #26]
 80050d2:	8b43      	ldrh	r3, [r0, #26]
 80050d4:	0a9c      	lsrs	r4, r3, #10
 80050d6:	07e4      	lsls	r4, r4, #31
 80050d8:	d41a      	bmi.n	8005110 <USBPD_PRL_SendMessage+0x14c>
 80050da:	0ada      	lsrs	r2, r3, #11
 80050dc:	0712      	lsls	r2, r2, #28
 80050de:	d118      	bne.n	8005112 <USBPD_PRL_SendMessage+0x14e>
 80050e0:	1f2a      	subs	r2, r5, #4
 80050e2:	8402      	strh	r2, [r0, #32]
 80050e4:	05d2      	lsls	r2, r2, #23
 80050e6:	0dd2      	lsrs	r2, r2, #23
 80050e8:	8b43      	ldrh	r3, [r0, #26]
 80050ea:	24fe      	movs	r4, #254	; 0xfe
 80050ec:	0224      	lsls	r4, r4, #8
 80050ee:	401c      	ands	r4, r3
 80050f0:	4322      	orrs	r2, r4
 80050f2:	8342      	strh	r2, [r0, #26]
 80050f4:	e00d      	b.n	8005112 <USBPD_PRL_SendMessage+0x14e>
 80050f6:	1eac      	subs	r4, r5, #2
 80050f8:	4da8      	ldr	r5, [pc, #672]	; (800539c <.text_24>)
 80050fa:	401d      	ands	r5, r3
 80050fc:	1063      	asrs	r3, r4, #1
 80050fe:	0f9b      	lsrs	r3, r3, #30
 8005100:	191b      	adds	r3, r3, r4
 8005102:	109b      	asrs	r3, r3, #2
 8005104:	031b      	lsls	r3, r3, #12
 8005106:	24e0      	movs	r4, #224	; 0xe0
 8005108:	01e4      	lsls	r4, r4, #7
 800510a:	401c      	ands	r4, r3
 800510c:	432c      	orrs	r4, r5
 800510e:	8284      	strh	r4, [r0, #20]
 8005110:	8402      	strh	r2, [r0, #32]
 8005112:	290d      	cmp	r1, #13
 8005114:	d103      	bne.n	800511e <USBPD_PRL_SendMessage+0x15a>
 8005116:	8a81      	ldrh	r1, [r0, #20]
 8005118:	22f0      	movs	r2, #240	; 0xf0
 800511a:	0212      	lsls	r2, r2, #8
 800511c:	400a      	ands	r2, r1
 800511e:	d000      	beq.n	8005122 <USBPD_PRL_SendMessage+0x15e>
 8005120:	e103      	b.n	800532a <USBPD_PRL_SendMessage+0x366>
 8005122:	2107      	movs	r1, #7
 8005124:	e102      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 8005126:	72c2      	strb	r2, [r0, #11]
 8005128:	220f      	movs	r2, #15
 800512a:	2103      	movs	r1, #3
 800512c:	6860      	ldr	r0, [r4, #4]
 800512e:	1d80      	adds	r0, r0, #6
 8005130:	f007 f9ef 	bl	800c512 <__aeabi_memset>
 8005134:	2008      	movs	r0, #8
 8005136:	e0bf      	b.n	80052b8 <USBPD_PRL_SendMessage+0x2f4>
 8005138:	8a81      	ldrh	r1, [r0, #20]
 800513a:	0bc9      	lsrs	r1, r1, #15
 800513c:	d06f      	beq.n	800521e <USBPD_PRL_SendMessage+0x25a>
 800513e:	8b41      	ldrh	r1, [r0, #26]
 8005140:	0a89      	lsrs	r1, r1, #10
 8005142:	07c9      	lsls	r1, r1, #31
 8005144:	d462      	bmi.n	800520c <USBPD_PRL_SendMessage+0x248>
 8005146:	8c03      	ldrh	r3, [r0, #32]
 8005148:	2b1b      	cmp	r3, #27
 800514a:	d302      	bcc.n	8005152 <USBPD_PRL_SendMessage+0x18e>
 800514c:	8b41      	ldrh	r1, [r0, #26]
 800514e:	0bc9      	lsrs	r1, r1, #15
 8005150:	d153      	bne.n	80051fa <USBPD_PRL_SendMessage+0x236>
 8005152:	4950      	ldr	r1, [pc, #320]	; (8005294 <USBPD_PRL_SendMessage+0x2d0>)
 8005154:	466e      	mov	r6, sp
 8005156:	7b36      	ldrb	r6, [r6, #12]
 8005158:	00b6      	lsls	r6, r6, #2
 800515a:	1989      	adds	r1, r1, r6
 800515c:	6849      	ldr	r1, [r1, #4]
 800515e:	8b49      	ldrh	r1, [r1, #26]
 8005160:	0ace      	lsrs	r6, r1, #11
 8005162:	0736      	lsls	r6, r6, #28
 8005164:	d106      	bne.n	8005174 <USBPD_PRL_SendMessage+0x1b0>
 8005166:	26fe      	movs	r6, #254	; 0xfe
 8005168:	0236      	lsls	r6, r6, #8
 800516a:	400e      	ands	r6, r1
 800516c:	05d9      	lsls	r1, r3, #23
 800516e:	0dc9      	lsrs	r1, r1, #23
 8005170:	4331      	orrs	r1, r6
 8005172:	8341      	strh	r1, [r0, #26]
 8005174:	8a83      	ldrh	r3, [r0, #20]
 8005176:	4989      	ldr	r1, [pc, #548]	; (800539c <.text_24>)
 8005178:	4019      	ands	r1, r3
 800517a:	8281      	strh	r1, [r0, #20]
 800517c:	8b43      	ldrh	r3, [r0, #26]
 800517e:	0bdb      	lsrs	r3, r3, #15
 8005180:	d038      	beq.n	80051f4 <USBPD_PRL_SendMessage+0x230>
 8005182:	8c03      	ldrh	r3, [r0, #32]
 8005184:	1c9b      	adds	r3, r3, #2
 8005186:	105d      	asrs	r5, r3, #1
 8005188:	0fad      	lsrs	r5, r5, #30
 800518a:	18eb      	adds	r3, r5, r3
 800518c:	109b      	asrs	r3, r3, #2
 800518e:	031b      	lsls	r3, r3, #12
 8005190:	25e0      	movs	r5, #224	; 0xe0
 8005192:	01ed      	lsls	r5, r5, #7
 8005194:	401d      	ands	r5, r3
 8005196:	430d      	orrs	r5, r1
 8005198:	8285      	strh	r5, [r0, #20]
 800519a:	8c00      	ldrh	r0, [r0, #32]
 800519c:	1c81      	adds	r1, r0, #2
 800519e:	1c80      	adds	r0, r0, #2
 80051a0:	104b      	asrs	r3, r1, #1
 80051a2:	0f9b      	lsrs	r3, r3, #30
 80051a4:	1859      	adds	r1, r3, r1
 80051a6:	1089      	asrs	r1, r1, #2
 80051a8:	0089      	lsls	r1, r1, #2
 80051aa:	1a40      	subs	r0, r0, r1
 80051ac:	b2c0      	uxtb	r0, r0
 80051ae:	2800      	cmp	r0, #0
 80051b0:	d01a      	beq.n	80051e8 <USBPD_PRL_SendMessage+0x224>
 80051b2:	2500      	movs	r5, #0
 80051b4:	9000      	str	r0, [sp, #0]
 80051b6:	e005      	b.n	80051c4 <USBPD_PRL_SendMessage+0x200>
 80051b8:	9902      	ldr	r1, [sp, #8]
 80051ba:	1d09      	adds	r1, r1, #4
 80051bc:	8c1b      	ldrh	r3, [r3, #32]
 80051be:	1818      	adds	r0, r3, r0
 80051c0:	540a      	strb	r2, [r1, r0]
 80051c2:	1c6d      	adds	r5, r5, #1
 80051c4:	6863      	ldr	r3, [r4, #4]
 80051c6:	b2e8      	uxtb	r0, r5
 80051c8:	2104      	movs	r1, #4
 80051ca:	9e00      	ldr	r6, [sp, #0]
 80051cc:	1b89      	subs	r1, r1, r6
 80051ce:	4288      	cmp	r0, r1
 80051d0:	dbf2      	blt.n	80051b8 <USBPD_PRL_SendMessage+0x1f4>
 80051d2:	8a99      	ldrh	r1, [r3, #20]
 80051d4:	4871      	ldr	r0, [pc, #452]	; (800539c <.text_24>)
 80051d6:	4008      	ands	r0, r1
 80051d8:	0b09      	lsrs	r1, r1, #12
 80051da:	1c49      	adds	r1, r1, #1
 80051dc:	0309      	lsls	r1, r1, #12
 80051de:	25e0      	movs	r5, #224	; 0xe0
 80051e0:	01ed      	lsls	r5, r5, #7
 80051e2:	400d      	ands	r5, r1
 80051e4:	4305      	orrs	r5, r0
 80051e6:	829d      	strh	r5, [r3, #20]
 80051e8:	6860      	ldr	r0, [r4, #4]
 80051ea:	8a80      	ldrh	r0, [r0, #20]
 80051ec:	0440      	lsls	r0, r0, #17
 80051ee:	0f40      	lsrs	r0, r0, #29
 80051f0:	0085      	lsls	r5, r0, #2
 80051f2:	1cad      	adds	r5, r5, #2
 80051f4:	6860      	ldr	r0, [r4, #4]
 80051f6:	8402      	strh	r2, [r0, #32]
 80051f8:	e008      	b.n	800520c <USBPD_PRL_SendMessage+0x248>
 80051fa:	8a81      	ldrh	r1, [r0, #20]
 80051fc:	22e0      	movs	r2, #224	; 0xe0
 80051fe:	01d2      	lsls	r2, r2, #7
 8005200:	430a      	orrs	r2, r1
 8005202:	8282      	strh	r2, [r0, #20]
 8005204:	8c01      	ldrh	r1, [r0, #32]
 8005206:	391a      	subs	r1, #26
 8005208:	8401      	strh	r1, [r0, #32]
 800520a:	251e      	movs	r5, #30
 800520c:	6860      	ldr	r0, [r4, #4]
 800520e:	8b40      	ldrh	r0, [r0, #26]
 8005210:	9902      	ldr	r1, [sp, #8]
 8005212:	7088      	strb	r0, [r1, #2]
 8005214:	6860      	ldr	r0, [r4, #4]
 8005216:	8b40      	ldrh	r0, [r0, #26]
 8005218:	0a00      	lsrs	r0, r0, #8
 800521a:	9902      	ldr	r1, [sp, #8]
 800521c:	70c8      	strb	r0, [r1, #3]
 800521e:	6860      	ldr	r0, [r4, #4]
 8005220:	7ac2      	ldrb	r2, [r0, #11]
 8005222:	8a83      	ldrh	r3, [r0, #20]
 8005224:	4999      	ldr	r1, [pc, #612]	; (800548c <.text_29>)
 8005226:	4019      	ands	r1, r3
 8005228:	0253      	lsls	r3, r2, #9
 800522a:	22e0      	movs	r2, #224	; 0xe0
 800522c:	0112      	lsls	r2, r2, #4
 800522e:	401a      	ands	r2, r3
 8005230:	430a      	orrs	r2, r1
 8005232:	8282      	strh	r2, [r0, #20]
 8005234:	4668      	mov	r0, sp
 8005236:	7900      	ldrb	r0, [r0, #4]
 8005238:	2800      	cmp	r0, #0
 800523a:	d004      	beq.n	8005246 <USBPD_PRL_SendMessage+0x282>
 800523c:	4894      	ldr	r0, [pc, #592]	; (8005490 <.text_30>)
 800523e:	4010      	ands	r0, r2
 8005240:	9a02      	ldr	r2, [sp, #8]
 8005242:	7010      	strb	r0, [r2, #0]
 8005244:	e003      	b.n	800524e <USBPD_PRL_SendMessage+0x28a>
 8005246:	9802      	ldr	r0, [sp, #8]
 8005248:	7002      	strb	r2, [r0, #0]
 800524a:	6860      	ldr	r0, [r4, #4]
 800524c:	8a80      	ldrh	r0, [r0, #20]
 800524e:	0a00      	lsrs	r0, r0, #8
 8005250:	9902      	ldr	r1, [sp, #8]
 8005252:	7048      	strb	r0, [r1, #1]
 8005254:	480f      	ldr	r0, [pc, #60]	; (8005294 <USBPD_PRL_SendMessage+0x2d0>)
 8005256:	8005      	strh	r5, [r0, #0]
 8005258:	6860      	ldr	r0, [r4, #4]
 800525a:	2109      	movs	r1, #9
 800525c:	7101      	strb	r1, [r0, #4]
 800525e:	2102      	movs	r1, #2
 8005260:	7481      	strb	r1, [r0, #18]
 8005262:	488c      	ldr	r0, [pc, #560]	; (8005494 <.text_31>)
 8005264:	6804      	ldr	r4, [r0, #0]
 8005266:	2c00      	cmp	r4, #0
 8005268:	d007      	beq.n	800527a <USBPD_PRL_SendMessage+0x2b6>
 800526a:	b2a8      	uxth	r0, r5
 800526c:	9000      	str	r0, [sp, #0]
 800526e:	9b02      	ldr	r3, [sp, #8]
 8005270:	4668      	mov	r0, sp
 8005272:	7902      	ldrb	r2, [r0, #4]
 8005274:	7b01      	ldrb	r1, [r0, #12]
 8005276:	2002      	movs	r0, #2
 8005278:	47a0      	blx	r4
 800527a:	4668      	mov	r0, sp
 800527c:	7b00      	ldrb	r0, [r0, #12]
 800527e:	2800      	cmp	r0, #0
 8005280:	d101      	bne.n	8005286 <USBPD_PRL_SendMessage+0x2c2>
 8005282:	2001      	movs	r0, #1
 8005284:	e000      	b.n	8005288 <USBPD_PRL_SendMessage+0x2c4>
 8005286:	2003      	movs	r0, #3
 8005288:	4983      	ldr	r1, [pc, #524]	; (8005498 <.text_32>)
 800528a:	f006 f847 	bl	800b31c <USBPD_TIM_Start>
 800528e:	b2ab      	uxth	r3, r5
 8005290:	e06c      	b.n	800536c <USBPD_PRL_SendMessage+0x3a8>
 8005292:	bf00      	nop
 8005294:	200019c0 	.word	0x200019c0
 8005298:	4668      	mov	r0, sp
 800529a:	7b00      	ldrb	r0, [r0, #12]
 800529c:	2800      	cmp	r0, #0
 800529e:	d101      	bne.n	80052a4 <USBPD_PRL_SendMessage+0x2e0>
 80052a0:	2001      	movs	r0, #1
 80052a2:	e000      	b.n	80052a6 <USBPD_PRL_SendMessage+0x2e2>
 80052a4:	2003      	movs	r0, #3
 80052a6:	f006 f868 	bl	800b37a <USBPD_TIM_IsExpired>
 80052aa:	2801      	cmp	r0, #1
 80052ac:	d003      	beq.n	80052b6 <USBPD_PRL_SendMessage+0x2f2>
 80052ae:	6860      	ldr	r0, [r4, #4]
 80052b0:	7b80      	ldrb	r0, [r0, #14]
 80052b2:	2801      	cmp	r0, #1
 80052b4:	d166      	bne.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 80052b6:	200c      	movs	r0, #12
 80052b8:	6861      	ldr	r1, [r4, #4]
 80052ba:	7108      	strb	r0, [r1, #4]
 80052bc:	e062      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 80052be:	7ac1      	ldrb	r1, [r0, #11]
 80052c0:	2207      	movs	r2, #7
 80052c2:	8b03      	ldrh	r3, [r0, #24]
 80052c4:	0a5d      	lsrs	r5, r3, #9
 80052c6:	2307      	movs	r3, #7
 80052c8:	402b      	ands	r3, r5
 80052ca:	4299      	cmp	r1, r3
 80052cc:	d1f3      	bne.n	80052b6 <USBPD_PRL_SendMessage+0x2f2>
 80052ce:	7e03      	ldrb	r3, [r0, #24]
 80052d0:	06db      	lsls	r3, r3, #27
 80052d2:	0edb      	lsrs	r3, r3, #27
 80052d4:	2b01      	cmp	r3, #1
 80052d6:	d1ee      	bne.n	80052b6 <USBPD_PRL_SendMessage+0x2f2>
 80052d8:	1c49      	adds	r1, r1, #1
 80052da:	400a      	ands	r2, r1
 80052dc:	72c2      	strb	r2, [r0, #11]
 80052de:	6860      	ldr	r0, [r4, #4]
 80052e0:	7106      	strb	r6, [r0, #4]
 80052e2:	e00d      	b.n	8005300 <USBPD_PRL_SendMessage+0x33c>
 80052e4:	7ac1      	ldrb	r1, [r0, #11]
 80052e6:	1c49      	adds	r1, r1, #1
 80052e8:	0749      	lsls	r1, r1, #29
 80052ea:	0f49      	lsrs	r1, r1, #29
 80052ec:	72c1      	strb	r1, [r0, #11]
 80052ee:	6860      	ldr	r0, [r4, #4]
 80052f0:	7106      	strb	r6, [r0, #4]
 80052f2:	8b42      	ldrh	r2, [r0, #26]
 80052f4:	4969      	ldr	r1, [pc, #420]	; (800549c <.text_33>)
 80052f6:	4011      	ands	r1, r2
 80052f8:	8341      	strh	r1, [r0, #26]
 80052fa:	4a69      	ldr	r2, [pc, #420]	; (80054a0 <.text_34>)
 80052fc:	400a      	ands	r2, r1
 80052fe:	8342      	strh	r2, [r0, #26]
 8005300:	2705      	movs	r7, #5
 8005302:	e03f      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005304:	7b01      	ldrb	r1, [r0, #12]
 8005306:	1c49      	adds	r1, r1, #1
 8005308:	7301      	strb	r1, [r0, #12]
 800530a:	6860      	ldr	r0, [r4, #4]
 800530c:	8a81      	ldrh	r1, [r0, #20]
 800530e:	2203      	movs	r2, #3
 8005310:	098b      	lsrs	r3, r1, #6
 8005312:	2403      	movs	r4, #3
 8005314:	401c      	ands	r4, r3
 8005316:	2c01      	cmp	r4, #1
 8005318:	d000      	beq.n	800531c <USBPD_PRL_SendMessage+0x358>
 800531a:	2202      	movs	r2, #2
 800531c:	7b03      	ldrb	r3, [r0, #12]
 800531e:	429a      	cmp	r2, r3
 8005320:	d306      	bcc.n	8005330 <USBPD_PRL_SendMessage+0x36c>
 8005322:	0bc9      	lsrs	r1, r1, #15
 8005324:	d001      	beq.n	800532a <USBPD_PRL_SendMessage+0x366>
 8005326:	210f      	movs	r1, #15
 8005328:	e000      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 800532a:	2108      	movs	r1, #8
 800532c:	7101      	strb	r1, [r0, #4]
 800532e:	e029      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005330:	7106      	strb	r6, [r0, #4]
 8005332:	2707      	movs	r7, #7
 8005334:	e026      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005336:	2109      	movs	r1, #9
 8005338:	7101      	strb	r1, [r0, #4]
 800533a:	2102      	movs	r1, #2
 800533c:	7481      	strb	r1, [r0, #18]
 800533e:	4668      	mov	r0, sp
 8005340:	7b00      	ldrb	r0, [r0, #12]
 8005342:	2800      	cmp	r0, #0
 8005344:	d101      	bne.n	800534a <USBPD_PRL_SendMessage+0x386>
 8005346:	2001      	movs	r0, #1
 8005348:	e000      	b.n	800534c <USBPD_PRL_SendMessage+0x388>
 800534a:	2003      	movs	r0, #3
 800534c:	4955      	ldr	r1, [pc, #340]	; (80054a4 <.text_35>)
 800534e:	f005 ffe5 	bl	800b31c <USBPD_TIM_Start>
 8005352:	4850      	ldr	r0, [pc, #320]	; (8005494 <.text_31>)
 8005354:	6804      	ldr	r4, [r0, #0]
 8005356:	2c00      	cmp	r4, #0
 8005358:	d006      	beq.n	8005368 <USBPD_PRL_SendMessage+0x3a4>
 800535a:	9500      	str	r5, [sp, #0]
 800535c:	9b02      	ldr	r3, [sp, #8]
 800535e:	4668      	mov	r0, sp
 8005360:	7902      	ldrb	r2, [r0, #4]
 8005362:	7b01      	ldrb	r1, [r0, #12]
 8005364:	2002      	movs	r0, #2
 8005366:	47a0      	blx	r4
 8005368:	484f      	ldr	r0, [pc, #316]	; (80054a8 <.text_36>)
 800536a:	8803      	ldrh	r3, [r0, #0]
 800536c:	9a02      	ldr	r2, [sp, #8]
 800536e:	4668      	mov	r0, sp
 8005370:	7901      	ldrb	r1, [r0, #4]
 8005372:	7b00      	ldrb	r0, [r0, #12]
 8005374:	f004 fa52 	bl	800981c <USBPD_PHY_SendMessage>
 8005378:	e004      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 800537a:	7106      	strb	r6, [r0, #4]
 800537c:	2706      	movs	r7, #6
 800537e:	e001      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005380:	7106      	strb	r6, [r0, #4]
 8005382:	2710      	movs	r7, #16
 8005384:	0038      	movs	r0, r7
 8005386:	b005      	add	sp, #20
 8005388:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800538a <USBPD_PRL_ResetRequestReset>:
 800538a:	4947      	ldr	r1, [pc, #284]	; (80054a8 <.text_36>)
 800538c:	0080      	lsls	r0, r0, #2
 800538e:	1808      	adds	r0, r1, r0
 8005390:	6840      	ldr	r0, [r0, #4]
 8005392:	2100      	movs	r1, #0
 8005394:	7141      	strb	r1, [r0, #5]
 8005396:	4770      	bx	lr

08005398 <.text_23>:
 8005398:	0000ffe0 	.word	0x0000ffe0

0800539c <.text_24>:
 800539c:	00008fff 	.word	0x00008fff

080053a0 <USBPD_PRL_ResetRequestProcess>:
 80053a0:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 80053a2:	b082      	sub	sp, #8
 80053a4:	000d      	movs	r5, r1
 80053a6:	2403      	movs	r4, #3
 80053a8:	483f      	ldr	r0, [pc, #252]	; (80054a8 <.text_36>)
 80053aa:	4669      	mov	r1, sp
 80053ac:	7a09      	ldrb	r1, [r1, #8]
 80053ae:	0089      	lsls	r1, r1, #2
 80053b0:	1846      	adds	r6, r0, r1
 80053b2:	6871      	ldr	r1, [r6, #4]
 80053b4:	2000      	movs	r0, #0
 80053b6:	2202      	movs	r2, #2
 80053b8:	794b      	ldrb	r3, [r1, #5]
 80053ba:	2b00      	cmp	r3, #0
 80053bc:	d003      	beq.n	80053c6 <USBPD_PRL_ResetRequestProcess+0x26>
 80053be:	2b02      	cmp	r3, #2
 80053c0:	d030      	beq.n	8005424 <USBPD_PRL_ResetRequestProcess+0x84>
 80053c2:	d323      	bcc.n	800540c <USBPD_PRL_ResetRequestProcess+0x6c>
 80053c4:	e031      	b.n	800542a <USBPD_PRL_ResetRequestProcess+0x8a>
 80053c6:	7348      	strb	r0, [r1, #13]
 80053c8:	6871      	ldr	r1, [r6, #4]
 80053ca:	72c8      	strb	r0, [r1, #11]
 80053cc:	220f      	movs	r2, #15
 80053ce:	2103      	movs	r1, #3
 80053d0:	6870      	ldr	r0, [r6, #4]
 80053d2:	1d80      	adds	r0, r0, #6
 80053d4:	f007 f89d 	bl	800c512 <__aeabi_memset>
 80053d8:	2006      	movs	r0, #6
 80053da:	6871      	ldr	r1, [r6, #4]
 80053dc:	7108      	strb	r0, [r1, #4]
 80053de:	482d      	ldr	r0, [pc, #180]	; (8005494 <.text_31>)
 80053e0:	6807      	ldr	r7, [r0, #0]
 80053e2:	2f00      	cmp	r7, #0
 80053e4:	d007      	beq.n	80053f6 <USBPD_PRL_ResetRequestProcess+0x56>
 80053e6:	2000      	movs	r0, #0
 80053e8:	9000      	str	r0, [sp, #0]
 80053ea:	2300      	movs	r3, #0
 80053ec:	2205      	movs	r2, #5
 80053ee:	4668      	mov	r0, sp
 80053f0:	7a01      	ldrb	r1, [r0, #8]
 80053f2:	2002      	movs	r0, #2
 80053f4:	47b8      	blx	r7
 80053f6:	0029      	movs	r1, r5
 80053f8:	4668      	mov	r0, sp
 80053fa:	7a00      	ldrb	r0, [r0, #8]
 80053fc:	f004 fa2e 	bl	800985c <USBPD_PHY_ResetRequest>
 8005400:	6870      	ldr	r0, [r6, #4]
 8005402:	2101      	movs	r1, #1
 8005404:	7141      	strb	r1, [r0, #5]
 8005406:	2105      	movs	r1, #5
 8005408:	7281      	strb	r1, [r0, #10]
 800540a:	e010      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 800540c:	7b4b      	ldrb	r3, [r1, #13]
 800540e:	2b01      	cmp	r3, #1
 8005410:	d102      	bne.n	8005418 <USBPD_PRL_ResetRequestProcess+0x78>
 8005412:	714a      	strb	r2, [r1, #5]
 8005414:	7348      	strb	r0, [r1, #13]
 8005416:	e00a      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 8005418:	7a8a      	ldrb	r2, [r1, #10]
 800541a:	2a00      	cmp	r2, #0
 800541c:	d107      	bne.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 800541e:	7148      	strb	r0, [r1, #5]
 8005420:	2404      	movs	r4, #4
 8005422:	e004      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 8005424:	7148      	strb	r0, [r1, #5]
 8005426:	2400      	movs	r4, #0
 8005428:	e001      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 800542a:	7148      	strb	r0, [r1, #5]
 800542c:	2402      	movs	r4, #2
 800542e:	0020      	movs	r0, r4
 8005430:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08005432 <USBDPD_PRL_BistCarrierEyeMode>:
 8005432:	b580      	push	{r7, lr}
 8005434:	2905      	cmp	r1, #5
 8005436:	d102      	bne.n	800543e <USBDPD_PRL_BistCarrierEyeMode+0xc>
 8005438:	f004 f8dc 	bl	80095f4 <USBPD_PHY_Send_BIST_Pattern>
 800543c:	bd02      	pop	{r1, pc}
 800543e:	2010      	movs	r0, #16
 8005440:	bd02      	pop	{r1, pc}

08005442 <USBDPD_PRL_BistCarrierEyeModeExit>:
 8005442:	b580      	push	{r7, lr}
 8005444:	2905      	cmp	r1, #5
 8005446:	d103      	bne.n	8005450 <USBDPD_PRL_BistCarrierEyeModeExit+0xe>
 8005448:	2107      	movs	r1, #7
 800544a:	f004 f8e1 	bl	8009610 <USBPD_PHY_ExitTransmit>
 800544e:	bd02      	pop	{r1, pc}
 8005450:	2010      	movs	r0, #16
 8005452:	bd02      	pop	{r1, pc}

08005454 <USBPD_PRL_Reset>:
 8005454:	b538      	push	{r3, r4, r5, lr}
 8005456:	4914      	ldr	r1, [pc, #80]	; (80054a8 <.text_36>)
 8005458:	0080      	lsls	r0, r0, #2
 800545a:	180c      	adds	r4, r1, r0
 800545c:	6860      	ldr	r0, [r4, #4]
 800545e:	2500      	movs	r5, #0
 8005460:	7105      	strb	r5, [r0, #4]
 8005462:	7145      	strb	r5, [r0, #5]
 8005464:	7285      	strb	r5, [r0, #10]
 8005466:	6860      	ldr	r0, [r4, #4]
 8005468:	72c5      	strb	r5, [r0, #11]
 800546a:	220f      	movs	r2, #15
 800546c:	2103      	movs	r1, #3
 800546e:	6860      	ldr	r0, [r4, #4]
 8005470:	1d80      	adds	r0, r0, #6
 8005472:	f007 f84e 	bl	800c512 <__aeabi_memset>
 8005476:	6860      	ldr	r0, [r4, #4]
 8005478:	7305      	strb	r5, [r0, #12]
 800547a:	6860      	ldr	r0, [r4, #4]
 800547c:	7345      	strb	r5, [r0, #13]
 800547e:	6860      	ldr	r0, [r4, #4]
 8005480:	7385      	strb	r5, [r0, #14]
 8005482:	6860      	ldr	r0, [r4, #4]
 8005484:	2123      	movs	r1, #35	; 0x23
 8005486:	5445      	strb	r5, [r0, r1]
 8005488:	bd31      	pop	{r0, r4, r5, pc}
	...

0800548c <.text_29>:
 800548c:	0000f1ff 	.word	0x0000f1ff

08005490 <.text_30>:
 8005490:	0000fedf 	.word	0x0000fedf

08005494 <.text_31>:
 8005494:	200019b8 	.word	0x200019b8

08005498 <.text_32>:
 8005498:	00002710 	.word	0x00002710

0800549c <.text_33>:
 800549c:	000087ff 	.word	0x000087ff

080054a0 <.text_34>:
 80054a0:	0000fbff 	.word	0x0000fbff

080054a4 <.text_35>:
 80054a4:	000009c4 	.word	0x000009c4

080054a8 <.text_36>:
 80054a8:	200019c0 	.word	0x200019c0

080054ac <USBPD_PRL_DeInit>:
 80054ac:	4770      	bx	lr

080054ae <PRL_Received>:
 80054ae:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
 80054b0:	b083      	sub	sp, #12
 80054b2:	48c4      	ldr	r0, [pc, #784]	; (80057c4 <.text_39>)
 80054b4:	8800      	ldrh	r0, [r0, #0]
 80054b6:	4669      	mov	r1, sp
 80054b8:	80c8      	strh	r0, [r1, #6]
 80054ba:	48c3      	ldr	r0, [pc, #780]	; (80057c8 <.text_40>)
 80054bc:	7b09      	ldrb	r1, [r1, #12]
 80054be:	0089      	lsls	r1, r1, #2
 80054c0:	1846      	adds	r6, r0, r1
 80054c2:	6870      	ldr	r0, [r6, #4]
 80054c4:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80054c6:	780a      	ldrb	r2, [r1, #0]
 80054c8:	7849      	ldrb	r1, [r1, #1]
 80054ca:	0209      	lsls	r1, r1, #8
 80054cc:	1851      	adds	r1, r2, r1
 80054ce:	466a      	mov	r2, sp
 80054d0:	8091      	strh	r1, [r2, #4]
 80054d2:	4fbe      	ldr	r7, [pc, #760]	; (80057cc <.text_41>)
 80054d4:	683c      	ldr	r4, [r7, #0]
 80054d6:	4669      	mov	r1, sp
 80054d8:	8889      	ldrh	r1, [r1, #4]
 80054da:	0bc9      	lsrs	r1, r1, #15
 80054dc:	d00b      	beq.n	80054f6 <PRL_Received+0x48>
 80054de:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80054e0:	7898      	ldrb	r0, [r3, #2]
 80054e2:	78d9      	ldrb	r1, [r3, #3]
 80054e4:	0209      	lsls	r1, r1, #8
 80054e6:	1845      	adds	r5, r0, r1
 80054e8:	2c00      	cmp	r4, #0
 80054ea:	d013      	beq.n	8005514 <PRL_Received+0x66>
 80054ec:	05e8      	lsls	r0, r5, #23
 80054ee:	0dc0      	lsrs	r0, r0, #23
 80054f0:	1d00      	adds	r0, r0, #4
 80054f2:	9000      	str	r0, [sp, #0]
 80054f4:	e009      	b.n	800550a <PRL_Received+0x5c>
 80054f6:	2c00      	cmp	r4, #0
 80054f8:	d00c      	beq.n	8005514 <PRL_Received+0x66>
 80054fa:	4669      	mov	r1, sp
 80054fc:	8889      	ldrh	r1, [r1, #4]
 80054fe:	0449      	lsls	r1, r1, #17
 8005500:	0f49      	lsrs	r1, r1, #29
 8005502:	0089      	lsls	r1, r1, #2
 8005504:	1c89      	adds	r1, r1, #2
 8005506:	9100      	str	r1, [sp, #0]
 8005508:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800550a:	4668      	mov	r0, sp
 800550c:	7c02      	ldrb	r2, [r0, #16]
 800550e:	7b01      	ldrb	r1, [r0, #12]
 8005510:	2001      	movs	r0, #1
 8005512:	47a0      	blx	r4
 8005514:	6870      	ldr	r0, [r6, #4]
 8005516:	49c7      	ldr	r1, [pc, #796]	; (8005834 <.text_45>)
 8005518:	466a      	mov	r2, sp
 800551a:	8892      	ldrh	r2, [r2, #4]
 800551c:	400a      	ands	r2, r1
 800551e:	2a01      	cmp	r2, #1
 8005520:	d105      	bne.n	800552e <PRL_Received+0x80>
 8005522:	210a      	movs	r1, #10
 8005524:	7101      	strb	r1, [r0, #4]
 8005526:	4669      	mov	r1, sp
 8005528:	8889      	ldrh	r1, [r1, #4]
 800552a:	8301      	strh	r1, [r0, #24]
 800552c:	e13b      	b.n	80057a6 <PRL_Received+0x2f8>
 800552e:	466a      	mov	r2, sp
 8005530:	7c12      	ldrb	r2, [r2, #16]
 8005532:	7242      	strb	r2, [r0, #9]
 8005534:	2400      	movs	r4, #0
 8005536:	466a      	mov	r2, sp
 8005538:	8892      	ldrh	r2, [r2, #4]
 800553a:	4011      	ands	r1, r2
 800553c:	290d      	cmp	r1, #13
 800553e:	d108      	bne.n	8005552 <PRL_Received+0xa4>
 8005540:	72c4      	strb	r4, [r0, #11]
 8005542:	220f      	movs	r2, #15
 8005544:	2103      	movs	r1, #3
 8005546:	6870      	ldr	r0, [r6, #4]
 8005548:	1d80      	adds	r0, r0, #6
 800554a:	f006 ffe2 	bl	800c512 <__aeabi_memset>
 800554e:	6871      	ldr	r1, [r6, #4]
 8005550:	710c      	strb	r4, [r1, #4]
 8005552:	4668      	mov	r0, sp
 8005554:	88c0      	ldrh	r0, [r0, #6]
 8005556:	49bd      	ldr	r1, [pc, #756]	; (800584c <.text_47>)
 8005558:	4001      	ands	r1, r0
 800555a:	2001      	movs	r0, #1
 800555c:	4308      	orrs	r0, r1
 800555e:	4669      	mov	r1, sp
 8005560:	4abb      	ldr	r2, [pc, #748]	; (8005850 <.text_48>)
 8005562:	4002      	ands	r2, r0
 8005564:	800a      	strh	r2, [r1, #0]
 8005566:	4668      	mov	r0, sp
 8005568:	7c00      	ldrb	r0, [r0, #16]
 800556a:	2800      	cmp	r0, #0
 800556c:	d10e      	bne.n	800558c <PRL_Received+0xde>
 800556e:	6870      	ldr	r0, [r6, #4]
 8005570:	8a82      	ldrh	r2, [r0, #20]
 8005572:	2101      	movs	r1, #1
 8005574:	0953      	lsrs	r3, r2, #5
 8005576:	2001      	movs	r0, #1
 8005578:	4018      	ands	r0, r3
 800557a:	0a12      	lsrs	r2, r2, #8
 800557c:	4011      	ands	r1, r2
 800557e:	466a      	mov	r2, sp
 8005580:	8812      	ldrh	r2, [r2, #0]
 8005582:	0140      	lsls	r0, r0, #5
 8005584:	4310      	orrs	r0, r2
 8005586:	0209      	lsls	r1, r1, #8
 8005588:	4301      	orrs	r1, r0
 800558a:	e000      	b.n	800558e <PRL_Received+0xe0>
 800558c:	4611      	mov	r1, r2
 800558e:	48c2      	ldr	r0, [pc, #776]	; (8005898 <.text_50>)
 8005590:	4008      	ands	r0, r1
 8005592:	4669      	mov	r1, sp
 8005594:	8889      	ldrh	r1, [r1, #4]
 8005596:	0609      	lsls	r1, r1, #24
 8005598:	0f89      	lsrs	r1, r1, #30
 800559a:	2902      	cmp	r1, #2
 800559c:	da02      	bge.n	80055a4 <PRL_Received+0xf6>
 800559e:	0001      	movs	r1, r0
 80055a0:	2040      	movs	r0, #64	; 0x40
 80055a2:	4308      	orrs	r0, r1
 80055a4:	05c1      	lsls	r1, r0, #23
 80055a6:	0dc9      	lsrs	r1, r1, #23
 80055a8:	4668      	mov	r0, sp
 80055aa:	8882      	ldrh	r2, [r0, #4]
 80055ac:	20e0      	movs	r0, #224	; 0xe0
 80055ae:	0100      	lsls	r0, r0, #4
 80055b0:	4010      	ands	r0, r2
 80055b2:	4308      	orrs	r0, r1
 80055b4:	6872      	ldr	r2, [r6, #4]
 80055b6:	7590      	strb	r0, [r2, #22]
 80055b8:	0a00      	lsrs	r0, r0, #8
 80055ba:	6871      	ldr	r1, [r6, #4]
 80055bc:	75c8      	strb	r0, [r1, #23]
 80055be:	6870      	ldr	r0, [r6, #4]
 80055c0:	2101      	movs	r1, #1
 80055c2:	7481      	strb	r1, [r0, #18]
 80055c4:	683f      	ldr	r7, [r7, #0]
 80055c6:	2f00      	cmp	r7, #0
 80055c8:	d008      	beq.n	80055dc <PRL_Received+0x12e>
 80055ca:	2102      	movs	r1, #2
 80055cc:	9100      	str	r1, [sp, #0]
 80055ce:	0003      	movs	r3, r0
 80055d0:	3316      	adds	r3, #22
 80055d2:	4668      	mov	r0, sp
 80055d4:	7c02      	ldrb	r2, [r0, #16]
 80055d6:	7b01      	ldrb	r1, [r0, #12]
 80055d8:	2002      	movs	r0, #2
 80055da:	47b8      	blx	r7
 80055dc:	2302      	movs	r3, #2
 80055de:	6872      	ldr	r2, [r6, #4]
 80055e0:	3216      	adds	r2, #22
 80055e2:	4668      	mov	r0, sp
 80055e4:	7c01      	ldrb	r1, [r0, #16]
 80055e6:	7b00      	ldrb	r0, [r0, #12]
 80055e8:	f004 f918 	bl	800981c <USBPD_PHY_SendMessage>
 80055ec:	2800      	cmp	r0, #0
 80055ee:	d19d      	bne.n	800552c <PRL_Received+0x7e>
 80055f0:	6870      	ldr	r0, [r6, #4]
 80055f2:	1d81      	adds	r1, r0, #6
 80055f4:	466a      	mov	r2, sp
 80055f6:	7c12      	ldrb	r2, [r2, #16]
 80055f8:	1889      	adds	r1, r1, r2
 80055fa:	9100      	str	r1, [sp, #0]
 80055fc:	4669      	mov	r1, sp
 80055fe:	8889      	ldrh	r1, [r1, #4]
 8005600:	0a49      	lsrs	r1, r1, #9
 8005602:	2207      	movs	r2, #7
 8005604:	9b00      	ldr	r3, [sp, #0]
 8005606:	781b      	ldrb	r3, [r3, #0]
 8005608:	2707      	movs	r7, #7
 800560a:	400f      	ands	r7, r1
 800560c:	42bb      	cmp	r3, r7
 800560e:	d100      	bne.n	8005612 <PRL_Received+0x164>
 8005610:	e0c8      	b.n	80057a4 <PRL_Received+0x2f6>
 8005612:	2007      	movs	r0, #7
 8005614:	4008      	ands	r0, r1
 8005616:	9900      	ldr	r1, [sp, #0]
 8005618:	7008      	strb	r0, [r1, #0]
 800561a:	6873      	ldr	r3, [r6, #4]
 800561c:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800561e:	7881      	ldrb	r1, [r0, #2]
 8005620:	78c7      	ldrb	r7, [r0, #3]
 8005622:	023f      	lsls	r7, r7, #8
 8005624:	19c9      	adds	r1, r1, r7
 8005626:	7907      	ldrb	r7, [r0, #4]
 8005628:	043f      	lsls	r7, r7, #16
 800562a:	19c9      	adds	r1, r1, r7
 800562c:	7940      	ldrb	r0, [r0, #5]
 800562e:	0600      	lsls	r0, r0, #24
 8005630:	1808      	adds	r0, r1, r0
 8005632:	4669      	mov	r1, sp
 8005634:	8889      	ldrh	r1, [r1, #4]
 8005636:	0b09      	lsrs	r1, r1, #12
 8005638:	4211      	tst	r1, r2
 800563a:	d00f      	beq.n	800565c <PRL_Received+0x1ae>
 800563c:	4669      	mov	r1, sp
 800563e:	8889      	ldrh	r1, [r1, #4]
 8005640:	06c9      	lsls	r1, r1, #27
 8005642:	0ec9      	lsrs	r1, r1, #27
 8005644:	2903      	cmp	r1, #3
 8005646:	d109      	bne.n	800565c <PRL_Received+0x1ae>
 8005648:	0f00      	lsrs	r0, r0, #28
 800564a:	2808      	cmp	r0, #8
 800564c:	d001      	beq.n	8005652 <PRL_Received+0x1a4>
 800564e:	2800      	cmp	r0, #0
 8005650:	d104      	bne.n	800565c <PRL_Received+0x1ae>
 8005652:	aa01      	add	r2, sp, #4
 8005654:	4668      	mov	r0, sp
 8005656:	7c01      	ldrb	r1, [r0, #16]
 8005658:	7b00      	ldrb	r0, [r0, #12]
 800565a:	e09f      	b.n	800579c <PRL_Received+0x2ee>
 800565c:	4668      	mov	r0, sp
 800565e:	8880      	ldrh	r0, [r0, #4]
 8005660:	83d8      	strh	r0, [r3, #30]
 8005662:	4668      	mov	r0, sp
 8005664:	8880      	ldrh	r0, [r0, #4]
 8005666:	0bc0      	lsrs	r0, r0, #15
 8005668:	d031      	beq.n	80056ce <PRL_Received+0x220>
 800566a:	0428      	lsls	r0, r5, #16
 800566c:	0fc0      	lsrs	r0, r0, #31
 800566e:	d02e      	beq.n	80056ce <PRL_Received+0x220>
 8005670:	839d      	strh	r5, [r3, #28]
 8005672:	200f      	movs	r0, #15
 8005674:	4669      	mov	r1, sp
 8005676:	8889      	ldrh	r1, [r1, #4]
 8005678:	0b09      	lsrs	r1, r1, #12
 800567a:	400a      	ands	r2, r1
 800567c:	21f8      	movs	r1, #248	; 0xf8
 800567e:	01c9      	lsls	r1, r1, #7
 8005680:	4029      	ands	r1, r5
 8005682:	d138      	bne.n	80056f6 <PRL_Received+0x248>
 8005684:	2a06      	cmp	r2, #6
 8005686:	dd03      	ble.n	8005690 <PRL_Received+0x1e2>
 8005688:	05e9      	lsls	r1, r5, #23
 800568a:	0dc9      	lsrs	r1, r1, #23
 800568c:	291a      	cmp	r1, #26
 800568e:	d821      	bhi.n	80056d4 <PRL_Received+0x226>
 8005690:	2100      	movs	r1, #0
 8005692:	042a      	lsls	r2, r5, #16
 8005694:	0ed2      	lsrs	r2, r2, #27
 8005696:	4010      	ands	r0, r2
 8005698:	221a      	movs	r2, #26
 800569a:	4342      	muls	r2, r0
 800569c:	2307      	movs	r3, #7
 800569e:	e007      	b.n	80056b0 <PRL_Received+0x202>
 80056a0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80056a2:	1d00      	adds	r0, r0, #4
 80056a4:	5c40      	ldrb	r0, [r0, r1]
 80056a6:	6aa4      	ldr	r4, [r4, #40]	; 0x28
 80056a8:	188f      	adds	r7, r1, r2
 80056aa:	55e0      	strb	r0, [r4, r7]
 80056ac:	1c49      	adds	r1, r1, #1
 80056ae:	b289      	uxth	r1, r1
 80056b0:	4668      	mov	r0, sp
 80056b2:	8880      	ldrh	r0, [r0, #4]
 80056b4:	0b00      	lsrs	r0, r0, #12
 80056b6:	4018      	ands	r0, r3
 80056b8:	0080      	lsls	r0, r0, #2
 80056ba:	1e80      	subs	r0, r0, #2
 80056bc:	6874      	ldr	r4, [r6, #4]
 80056be:	4281      	cmp	r1, r0
 80056c0:	dbee      	blt.n	80056a0 <PRL_Received+0x1f2>
 80056c2:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80056c4:	05e9      	lsls	r1, r5, #23
 80056c6:	0dc9      	lsrs	r1, r1, #23
 80056c8:	4288      	cmp	r0, r1
 80056ca:	da01      	bge.n	80056d0 <PRL_Received+0x222>
 80056cc:	8010      	strh	r0, [r2, #0]
 80056ce:	e060      	b.n	8005792 <PRL_Received+0x2e4>
 80056d0:	8011      	strh	r1, [r2, #0]
 80056d2:	e05e      	b.n	8005792 <PRL_Received+0x2e4>
 80056d4:	2001      	movs	r0, #1
 80056d6:	2123      	movs	r1, #35	; 0x23
 80056d8:	5458      	strb	r0, [r3, r1]
 80056da:	6870      	ldr	r0, [r6, #4]
 80056dc:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80056de:	1d09      	adds	r1, r1, #4
 80056e0:	5d09      	ldrb	r1, [r1, r4]
 80056e2:	6a80      	ldr	r0, [r0, #40]	; 0x28
 80056e4:	5501      	strb	r1, [r0, r4]
 80056e6:	1c64      	adds	r4, r4, #1
 80056e8:	2c1a      	cmp	r4, #26
 80056ea:	d3f6      	bcc.n	80056da <PRL_Received+0x22c>
 80056ec:	201a      	movs	r0, #26
 80056ee:	6871      	ldr	r1, [r6, #4]
 80056f0:	6a49      	ldr	r1, [r1, #36]	; 0x24
 80056f2:	8008      	strh	r0, [r1, #0]
 80056f4:	e04d      	b.n	8005792 <PRL_Received+0x2e4>
 80056f6:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80056f8:	8809      	ldrh	r1, [r1, #0]
 80056fa:	0092      	lsls	r2, r2, #2
 80056fc:	188a      	adds	r2, r1, r2
 80056fe:	1e92      	subs	r2, r2, #2
 8005700:	27ff      	movs	r7, #255	; 0xff
 8005702:	1dbf      	adds	r7, r7, #6
 8005704:	311a      	adds	r1, #26
 8005706:	42b9      	cmp	r1, r7
 8005708:	d21e      	bcs.n	8005748 <PRL_Received+0x29a>
 800570a:	05e9      	lsls	r1, r5, #23
 800570c:	0dc9      	lsrs	r1, r1, #23
 800570e:	428a      	cmp	r2, r1
 8005710:	da1a      	bge.n	8005748 <PRL_Received+0x29a>
 8005712:	2101      	movs	r1, #1
 8005714:	2223      	movs	r2, #35	; 0x23
 8005716:	5499      	strb	r1, [r3, r2]
 8005718:	0429      	lsls	r1, r5, #16
 800571a:	0ec9      	lsrs	r1, r1, #27
 800571c:	4008      	ands	r0, r1
 800571e:	211a      	movs	r1, #26
 8005720:	4341      	muls	r1, r0
 8005722:	2007      	movs	r0, #7
 8005724:	466a      	mov	r2, sp
 8005726:	8892      	ldrh	r2, [r2, #4]
 8005728:	0b12      	lsrs	r2, r2, #12
 800572a:	4002      	ands	r2, r0
 800572c:	0092      	lsls	r2, r2, #2
 800572e:	1e92      	subs	r2, r2, #2
 8005730:	4294      	cmp	r4, r2
 8005732:	da3a      	bge.n	80057aa <PRL_Received+0x2fc>
 8005734:	6872      	ldr	r2, [r6, #4]
 8005736:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8005738:	1d1b      	adds	r3, r3, #4
 800573a:	5d1b      	ldrb	r3, [r3, r4]
 800573c:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800573e:	1865      	adds	r5, r4, r1
 8005740:	5553      	strb	r3, [r2, r5]
 8005742:	1c64      	adds	r4, r4, #1
 8005744:	b2a4      	uxth	r4, r4
 8005746:	e7ed      	b.n	8005724 <PRL_Received+0x276>
 8005748:	42ba      	cmp	r2, r7
 800574a:	d21e      	bcs.n	800578a <PRL_Received+0x2dc>
 800574c:	05e9      	lsls	r1, r5, #23
 800574e:	0dc9      	lsrs	r1, r1, #23
 8005750:	428a      	cmp	r2, r1
 8005752:	db1a      	blt.n	800578a <PRL_Received+0x2dc>
 8005754:	2101      	movs	r1, #1
 8005756:	2223      	movs	r2, #35	; 0x23
 8005758:	5499      	strb	r1, [r3, r2]
 800575a:	0429      	lsls	r1, r5, #16
 800575c:	0ec9      	lsrs	r1, r1, #27
 800575e:	4008      	ands	r0, r1
 8005760:	211a      	movs	r1, #26
 8005762:	4341      	muls	r1, r0
 8005764:	2007      	movs	r0, #7
 8005766:	466a      	mov	r2, sp
 8005768:	8892      	ldrh	r2, [r2, #4]
 800576a:	0b12      	lsrs	r2, r2, #12
 800576c:	4002      	ands	r2, r0
 800576e:	0092      	lsls	r2, r2, #2
 8005770:	1e92      	subs	r2, r2, #2
 8005772:	4294      	cmp	r4, r2
 8005774:	da19      	bge.n	80057aa <PRL_Received+0x2fc>
 8005776:	6872      	ldr	r2, [r6, #4]
 8005778:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 800577a:	1d1b      	adds	r3, r3, #4
 800577c:	5d1b      	ldrb	r3, [r3, r4]
 800577e:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8005780:	1865      	adds	r5, r4, r1
 8005782:	5553      	strb	r3, [r2, r5]
 8005784:	1c64      	adds	r4, r4, #1
 8005786:	b2a4      	uxth	r4, r4
 8005788:	e7ed      	b.n	8005766 <PRL_Received+0x2b8>
 800578a:	2123      	movs	r1, #35	; 0x23
 800578c:	545c      	strb	r4, [r3, r1]
 800578e:	6870      	ldr	r0, [r6, #4]
 8005790:	7104      	strb	r4, [r0, #4]
 8005792:	aa01      	add	r2, sp, #4
 8005794:	4668      	mov	r0, sp
 8005796:	7c01      	ldrb	r1, [r0, #16]
 8005798:	7b00      	ldrb	r0, [r0, #12]
 800579a:	6873      	ldr	r3, [r6, #4]
 800579c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800579e:	681b      	ldr	r3, [r3, #0]
 80057a0:	4798      	blx	r3
 80057a2:	e000      	b.n	80057a6 <PRL_Received+0x2f8>
 80057a4:	7484      	strb	r4, [r0, #18]
 80057a6:	b005      	add	sp, #20
 80057a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80057aa:	6870      	ldr	r0, [r6, #4]
 80057ac:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80057ae:	8801      	ldrh	r1, [r0, #0]
 80057b0:	466a      	mov	r2, sp
 80057b2:	8892      	ldrh	r2, [r2, #4]
 80057b4:	0a92      	lsrs	r2, r2, #10
 80057b6:	231c      	movs	r3, #28
 80057b8:	4013      	ands	r3, r2
 80057ba:	1e9a      	subs	r2, r3, #2
 80057bc:	1889      	adds	r1, r1, r2
 80057be:	8001      	strh	r1, [r0, #0]
 80057c0:	e7e7      	b.n	8005792 <PRL_Received+0x2e4>
	...

080057c4 <.text_39>:
 80057c4:	0800c860 	.word	0x0800c860

080057c8 <.text_40>:
 80057c8:	200019c0 	.word	0x200019c0

080057cc <.text_41>:
 80057cc:	200019b8 	.word	0x200019b8

080057d0 <PRL_ResetIndicate>:
 80057d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80057d2:	0005      	movs	r5, r0
 80057d4:	000e      	movs	r6, r1
 80057d6:	4869      	ldr	r0, [pc, #420]	; (800597c <.text_53>)
 80057d8:	00a9      	lsls	r1, r5, #2
 80057da:	1844      	adds	r4, r0, r1
 80057dc:	2000      	movs	r0, #0
 80057de:	6861      	ldr	r1, [r4, #4]
 80057e0:	72c8      	strb	r0, [r1, #11]
 80057e2:	220f      	movs	r2, #15
 80057e4:	2103      	movs	r1, #3
 80057e6:	6860      	ldr	r0, [r4, #4]
 80057e8:	1d80      	adds	r0, r0, #6
 80057ea:	f006 fe92 	bl	800c512 <__aeabi_memset>
 80057ee:	2006      	movs	r0, #6
 80057f0:	6861      	ldr	r1, [r4, #4]
 80057f2:	7108      	strb	r0, [r1, #4]
 80057f4:	4862      	ldr	r0, [pc, #392]	; (8005980 <.text_54>)
 80057f6:	6807      	ldr	r7, [r0, #0]
 80057f8:	2f00      	cmp	r7, #0
 80057fa:	d006      	beq.n	800580a <PRL_ResetIndicate+0x3a>
 80057fc:	2000      	movs	r0, #0
 80057fe:	9000      	str	r0, [sp, #0]
 8005800:	2300      	movs	r3, #0
 8005802:	0032      	movs	r2, r6
 8005804:	0029      	movs	r1, r5
 8005806:	2001      	movs	r0, #1
 8005808:	47b8      	blx	r7
 800580a:	0031      	movs	r1, r6
 800580c:	0028      	movs	r0, r5
 800580e:	6862      	ldr	r2, [r4, #4]
 8005810:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8005812:	6892      	ldr	r2, [r2, #8]
 8005814:	4790      	blx	r2
 8005816:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}

08005818 <PRL_ResetCompleted>:
 8005818:	4958      	ldr	r1, [pc, #352]	; (800597c <.text_53>)
 800581a:	0080      	lsls	r0, r0, #2
 800581c:	1808      	adds	r0, r1, r0
 800581e:	6840      	ldr	r0, [r0, #4]
 8005820:	2101      	movs	r1, #1
 8005822:	7341      	strb	r1, [r0, #13]
 8005824:	4770      	bx	lr

08005826 <PRL_IdleAfterBusy>:
 8005826:	4955      	ldr	r1, [pc, #340]	; (800597c <.text_53>)
 8005828:	0080      	lsls	r0, r0, #2
 800582a:	1808      	adds	r0, r1, r0
 800582c:	6840      	ldr	r0, [r0, #4]
 800582e:	2101      	movs	r1, #1
 8005830:	7381      	strb	r1, [r0, #14]
 8005832:	4770      	bx	lr

08005834 <.text_45>:
 8005834:	0000f01f 	.word	0x0000f01f

08005838 <PRL_BistCompleted>:
 8005838:	b580      	push	{r7, lr}
 800583a:	4b50      	ldr	r3, [pc, #320]	; (800597c <.text_53>)
 800583c:	0082      	lsls	r2, r0, #2
 800583e:	189a      	adds	r2, r3, r2
 8005840:	6852      	ldr	r2, [r2, #4]
 8005842:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8005844:	68d2      	ldr	r2, [r2, #12]
 8005846:	4790      	blx	r2
 8005848:	bd01      	pop	{r0, pc}
	...

0800584c <.text_47>:
 800584c:	0000ffe0 	.word	0x0000ffe0

08005850 <.text_48>:
 8005850:	0000fedf 	.word	0x0000fedf

08005854 <PRL_TxCompleted>:
 8005854:	b538      	push	{r3, r4, r5, lr}
 8005856:	0005      	movs	r5, r0
 8005858:	4848      	ldr	r0, [pc, #288]	; (800597c <.text_53>)
 800585a:	00a9      	lsls	r1, r5, #2
 800585c:	1844      	adds	r4, r0, r1
 800585e:	6861      	ldr	r1, [r4, #4]
 8005860:	7c88      	ldrb	r0, [r1, #18]
 8005862:	2801      	cmp	r0, #1
 8005864:	d002      	beq.n	800586c <PRL_TxCompleted+0x18>
 8005866:	2802      	cmp	r0, #2
 8005868:	d005      	beq.n	8005876 <PRL_TxCompleted+0x22>
 800586a:	e010      	b.n	800588e <PRL_TxCompleted+0x3a>
 800586c:	0028      	movs	r0, r5
 800586e:	6b09      	ldr	r1, [r1, #48]	; 0x30
 8005870:	6849      	ldr	r1, [r1, #4]
 8005872:	4788      	blx	r1
 8005874:	e00b      	b.n	800588e <PRL_TxCompleted+0x3a>
 8005876:	0028      	movs	r0, r5
 8005878:	f003 feb8 	bl	80095ec <USBPD_PHY_GetRetryTimerValue>
 800587c:	2d00      	cmp	r5, #0
 800587e:	d101      	bne.n	8005884 <PRL_TxCompleted+0x30>
 8005880:	2201      	movs	r2, #1
 8005882:	e000      	b.n	8005886 <PRL_TxCompleted+0x32>
 8005884:	2203      	movs	r2, #3
 8005886:	b281      	uxth	r1, r0
 8005888:	0010      	movs	r0, r2
 800588a:	f005 fd47 	bl	800b31c <USBPD_TIM_Start>
 800588e:	2000      	movs	r0, #0
 8005890:	6861      	ldr	r1, [r4, #4]
 8005892:	7488      	strb	r0, [r1, #18]
 8005894:	bd31      	pop	{r0, r4, r5, pc}
	...

08005898 <.text_50>:
 8005898:	0000ff3f 	.word	0x0000ff3f

0800589c <USBPD_PRL_PrepareExtendedTxChunkSending>:
 800589c:	b570      	push	{r4, r5, r6, lr}
 800589e:	4c37      	ldr	r4, [pc, #220]	; (800597c <.text_53>)
 80058a0:	0080      	lsls	r0, r0, #2
 80058a2:	1820      	adds	r0, r4, r0
 80058a4:	6840      	ldr	r0, [r0, #4]
 80058a6:	2480      	movs	r4, #128	; 0x80
 80058a8:	0224      	lsls	r4, r4, #8
 80058aa:	8b45      	ldrh	r5, [r0, #26]
 80058ac:	4e35      	ldr	r6, [pc, #212]	; (8005984 <.text_55>)
 80058ae:	402e      	ands	r6, r5
 80058b0:	02c9      	lsls	r1, r1, #11
 80058b2:	4331      	orrs	r1, r6
 80058b4:	25fe      	movs	r5, #254	; 0xfe
 80058b6:	022d      	lsls	r5, r5, #8
 80058b8:	400d      	ands	r5, r1
 80058ba:	05d1      	lsls	r1, r2, #23
 80058bc:	0dc9      	lsrs	r1, r1, #23
 80058be:	4329      	orrs	r1, r5
 80058c0:	4321      	orrs	r1, r4
 80058c2:	8341      	strh	r1, [r0, #26]
 80058c4:	8a81      	ldrh	r1, [r0, #20]
 80058c6:	430c      	orrs	r4, r1
 80058c8:	8284      	strh	r4, [r0, #20]
 80058ca:	4a2f      	ldr	r2, [pc, #188]	; (8005988 <.text_56>)
 80058cc:	4022      	ands	r2, r4
 80058ce:	7f81      	ldrb	r1, [r0, #30]
 80058d0:	06c9      	lsls	r1, r1, #27
 80058d2:	0ec9      	lsrs	r1, r1, #27
 80058d4:	4311      	orrs	r1, r2
 80058d6:	8281      	strh	r1, [r0, #20]
 80058d8:	7019      	strb	r1, [r3, #0]
 80058da:	8a81      	ldrh	r1, [r0, #20]
 80058dc:	0a09      	lsrs	r1, r1, #8
 80058de:	7059      	strb	r1, [r3, #1]
 80058e0:	8b41      	ldrh	r1, [r0, #26]
 80058e2:	7099      	strb	r1, [r3, #2]
 80058e4:	8b40      	ldrh	r0, [r0, #26]
 80058e6:	0a00      	lsrs	r0, r0, #8
 80058e8:	70d8      	strb	r0, [r3, #3]
 80058ea:	bd70      	pop	{r4, r5, r6, pc}

080058ec <USBPD_PRL_ManageExtendedRx>:
 80058ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80058ee:	b084      	sub	sp, #16
 80058f0:	4a22      	ldr	r2, [pc, #136]	; (800597c <.text_53>)
 80058f2:	0083      	lsls	r3, r0, #2
 80058f4:	18d2      	adds	r2, r2, r3
 80058f6:	6853      	ldr	r3, [r2, #4]
 80058f8:	8b5a      	ldrh	r2, [r3, #26]
 80058fa:	2484      	movs	r4, #132	; 0x84
 80058fc:	0224      	lsls	r4, r4, #8
 80058fe:	4314      	orrs	r4, r2
 8005900:	835c      	strh	r4, [r3, #26]
 8005902:	2286      	movs	r2, #134	; 0x86
 8005904:	0212      	lsls	r2, r2, #8
 8005906:	4022      	ands	r2, r4
 8005908:	8b9c      	ldrh	r4, [r3, #28]
 800590a:	0ae4      	lsrs	r4, r4, #11
 800590c:	1c64      	adds	r4, r4, #1
 800590e:	02e4      	lsls	r4, r4, #11
 8005910:	25f0      	movs	r5, #240	; 0xf0
 8005912:	01ed      	lsls	r5, r5, #7
 8005914:	4025      	ands	r5, r4
 8005916:	4315      	orrs	r5, r2
 8005918:	835d      	strh	r5, [r3, #26]
 800591a:	8bdd      	ldrh	r5, [r3, #30]
 800591c:	221f      	movs	r2, #31
 800591e:	261f      	movs	r6, #31
 8005920:	402e      	ands	r6, r5
 8005922:	2480      	movs	r4, #128	; 0x80
 8005924:	4334      	orrs	r4, r6
 8005926:	8a9f      	ldrh	r7, [r3, #20]
 8005928:	4e18      	ldr	r6, [pc, #96]	; (800598c <.text_57>)
 800592a:	403e      	ands	r6, r7
 800592c:	2790      	movs	r7, #144	; 0x90
 800592e:	023f      	lsls	r7, r7, #8
 8005930:	4337      	orrs	r7, r6
 8005932:	829f      	strh	r7, [r3, #20]
 8005934:	4e14      	ldr	r6, [pc, #80]	; (8005988 <.text_56>)
 8005936:	403e      	ands	r6, r7
 8005938:	402a      	ands	r2, r5
 800593a:	4332      	orrs	r2, r6
 800593c:	829a      	strh	r2, [r3, #20]
 800593e:	2506      	movs	r5, #6
 8005940:	711d      	strb	r5, [r3, #4]
 8005942:	ad02      	add	r5, sp, #8
 8005944:	702a      	strb	r2, [r5, #0]
 8005946:	8a9a      	ldrh	r2, [r3, #20]
 8005948:	0a12      	lsrs	r2, r2, #8
 800594a:	706a      	strb	r2, [r5, #1]
 800594c:	8b5a      	ldrh	r2, [r3, #26]
 800594e:	70aa      	strb	r2, [r5, #2]
 8005950:	8b5a      	ldrh	r2, [r3, #26]
 8005952:	0a12      	lsrs	r2, r2, #8
 8005954:	70ea      	strb	r2, [r5, #3]
 8005956:	2200      	movs	r2, #0
 8005958:	80aa      	strh	r2, [r5, #4]
 800595a:	0006      	movs	r6, r0
 800595c:	000d      	movs	r5, r1
 800595e:	2000      	movs	r0, #0
 8005960:	9001      	str	r0, [sp, #4]
 8005962:	2006      	movs	r0, #6
 8005964:	9000      	str	r0, [sp, #0]
 8005966:	ab02      	add	r3, sp, #8
 8005968:	0022      	movs	r2, r4
 800596a:	0029      	movs	r1, r5
 800596c:	0030      	movs	r0, r6
 800596e:	f7ff fb29 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8005972:	2803      	cmp	r0, #3
 8005974:	d0f3      	beq.n	800595e <USBPD_PRL_ManageExtendedRx+0x72>
 8005976:	2000      	movs	r0, #0
 8005978:	b005      	add	sp, #20
 800597a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800597c <.text_53>:
 800597c:	200019c0 	.word	0x200019c0

08005980 <.text_54>:
 8005980:	200019b8 	.word	0x200019b8

08005984 <.text_55>:
 8005984:	000083ff 	.word	0x000083ff

08005988 <.text_56>:
 8005988:	0000ffe0 	.word	0x0000ffe0

0800598c <.text_57>:
 800598c:	00008fff 	.word	0x00008fff

08005990 <strlen>:
 8005990:	2300      	movs	r3, #0
 8005992:	5cc2      	ldrb	r2, [r0, r3]
 8005994:	3301      	adds	r3, #1
 8005996:	2a00      	cmp	r2, #0
 8005998:	d1fb      	bne.n	8005992 <strlen+0x2>
 800599a:	1e58      	subs	r0, r3, #1
 800599c:	4770      	bx	lr
	...

080059a0 <__gnu_thumb1_case_uqi>:
 80059a0:	b402      	push	{r1}
 80059a2:	4671      	mov	r1, lr
 80059a4:	0849      	lsrs	r1, r1, #1
 80059a6:	0049      	lsls	r1, r1, #1
 80059a8:	5c09      	ldrb	r1, [r1, r0]
 80059aa:	0049      	lsls	r1, r1, #1
 80059ac:	448e      	add	lr, r1
 80059ae:	bc02      	pop	{r1}
 80059b0:	4770      	bx	lr
 80059b2:	46c0      	nop			; (mov r8, r8)

080059b4 <__udivsi3>:
 80059b4:	2200      	movs	r2, #0
 80059b6:	0843      	lsrs	r3, r0, #1
 80059b8:	428b      	cmp	r3, r1
 80059ba:	d374      	bcc.n	8005aa6 <__udivsi3+0xf2>
 80059bc:	0903      	lsrs	r3, r0, #4
 80059be:	428b      	cmp	r3, r1
 80059c0:	d35f      	bcc.n	8005a82 <__udivsi3+0xce>
 80059c2:	0a03      	lsrs	r3, r0, #8
 80059c4:	428b      	cmp	r3, r1
 80059c6:	d344      	bcc.n	8005a52 <__udivsi3+0x9e>
 80059c8:	0b03      	lsrs	r3, r0, #12
 80059ca:	428b      	cmp	r3, r1
 80059cc:	d328      	bcc.n	8005a20 <__udivsi3+0x6c>
 80059ce:	0c03      	lsrs	r3, r0, #16
 80059d0:	428b      	cmp	r3, r1
 80059d2:	d30d      	bcc.n	80059f0 <__udivsi3+0x3c>
 80059d4:	22ff      	movs	r2, #255	; 0xff
 80059d6:	0209      	lsls	r1, r1, #8
 80059d8:	ba12      	rev	r2, r2
 80059da:	0c03      	lsrs	r3, r0, #16
 80059dc:	428b      	cmp	r3, r1
 80059de:	d302      	bcc.n	80059e6 <__udivsi3+0x32>
 80059e0:	1212      	asrs	r2, r2, #8
 80059e2:	0209      	lsls	r1, r1, #8
 80059e4:	d065      	beq.n	8005ab2 <__udivsi3+0xfe>
 80059e6:	0b03      	lsrs	r3, r0, #12
 80059e8:	428b      	cmp	r3, r1
 80059ea:	d319      	bcc.n	8005a20 <__udivsi3+0x6c>
 80059ec:	e000      	b.n	80059f0 <__udivsi3+0x3c>
 80059ee:	0a09      	lsrs	r1, r1, #8
 80059f0:	0bc3      	lsrs	r3, r0, #15
 80059f2:	428b      	cmp	r3, r1
 80059f4:	d301      	bcc.n	80059fa <__udivsi3+0x46>
 80059f6:	03cb      	lsls	r3, r1, #15
 80059f8:	1ac0      	subs	r0, r0, r3
 80059fa:	4152      	adcs	r2, r2
 80059fc:	0b83      	lsrs	r3, r0, #14
 80059fe:	428b      	cmp	r3, r1
 8005a00:	d301      	bcc.n	8005a06 <__udivsi3+0x52>
 8005a02:	038b      	lsls	r3, r1, #14
 8005a04:	1ac0      	subs	r0, r0, r3
 8005a06:	4152      	adcs	r2, r2
 8005a08:	0b43      	lsrs	r3, r0, #13
 8005a0a:	428b      	cmp	r3, r1
 8005a0c:	d301      	bcc.n	8005a12 <__udivsi3+0x5e>
 8005a0e:	034b      	lsls	r3, r1, #13
 8005a10:	1ac0      	subs	r0, r0, r3
 8005a12:	4152      	adcs	r2, r2
 8005a14:	0b03      	lsrs	r3, r0, #12
 8005a16:	428b      	cmp	r3, r1
 8005a18:	d301      	bcc.n	8005a1e <__udivsi3+0x6a>
 8005a1a:	030b      	lsls	r3, r1, #12
 8005a1c:	1ac0      	subs	r0, r0, r3
 8005a1e:	4152      	adcs	r2, r2
 8005a20:	0ac3      	lsrs	r3, r0, #11
 8005a22:	428b      	cmp	r3, r1
 8005a24:	d301      	bcc.n	8005a2a <__udivsi3+0x76>
 8005a26:	02cb      	lsls	r3, r1, #11
 8005a28:	1ac0      	subs	r0, r0, r3
 8005a2a:	4152      	adcs	r2, r2
 8005a2c:	0a83      	lsrs	r3, r0, #10
 8005a2e:	428b      	cmp	r3, r1
 8005a30:	d301      	bcc.n	8005a36 <__udivsi3+0x82>
 8005a32:	028b      	lsls	r3, r1, #10
 8005a34:	1ac0      	subs	r0, r0, r3
 8005a36:	4152      	adcs	r2, r2
 8005a38:	0a43      	lsrs	r3, r0, #9
 8005a3a:	428b      	cmp	r3, r1
 8005a3c:	d301      	bcc.n	8005a42 <__udivsi3+0x8e>
 8005a3e:	024b      	lsls	r3, r1, #9
 8005a40:	1ac0      	subs	r0, r0, r3
 8005a42:	4152      	adcs	r2, r2
 8005a44:	0a03      	lsrs	r3, r0, #8
 8005a46:	428b      	cmp	r3, r1
 8005a48:	d301      	bcc.n	8005a4e <__udivsi3+0x9a>
 8005a4a:	020b      	lsls	r3, r1, #8
 8005a4c:	1ac0      	subs	r0, r0, r3
 8005a4e:	4152      	adcs	r2, r2
 8005a50:	d2cd      	bcs.n	80059ee <__udivsi3+0x3a>
 8005a52:	09c3      	lsrs	r3, r0, #7
 8005a54:	428b      	cmp	r3, r1
 8005a56:	d301      	bcc.n	8005a5c <__udivsi3+0xa8>
 8005a58:	01cb      	lsls	r3, r1, #7
 8005a5a:	1ac0      	subs	r0, r0, r3
 8005a5c:	4152      	adcs	r2, r2
 8005a5e:	0983      	lsrs	r3, r0, #6
 8005a60:	428b      	cmp	r3, r1
 8005a62:	d301      	bcc.n	8005a68 <__udivsi3+0xb4>
 8005a64:	018b      	lsls	r3, r1, #6
 8005a66:	1ac0      	subs	r0, r0, r3
 8005a68:	4152      	adcs	r2, r2
 8005a6a:	0943      	lsrs	r3, r0, #5
 8005a6c:	428b      	cmp	r3, r1
 8005a6e:	d301      	bcc.n	8005a74 <__udivsi3+0xc0>
 8005a70:	014b      	lsls	r3, r1, #5
 8005a72:	1ac0      	subs	r0, r0, r3
 8005a74:	4152      	adcs	r2, r2
 8005a76:	0903      	lsrs	r3, r0, #4
 8005a78:	428b      	cmp	r3, r1
 8005a7a:	d301      	bcc.n	8005a80 <__udivsi3+0xcc>
 8005a7c:	010b      	lsls	r3, r1, #4
 8005a7e:	1ac0      	subs	r0, r0, r3
 8005a80:	4152      	adcs	r2, r2
 8005a82:	08c3      	lsrs	r3, r0, #3
 8005a84:	428b      	cmp	r3, r1
 8005a86:	d301      	bcc.n	8005a8c <__udivsi3+0xd8>
 8005a88:	00cb      	lsls	r3, r1, #3
 8005a8a:	1ac0      	subs	r0, r0, r3
 8005a8c:	4152      	adcs	r2, r2
 8005a8e:	0883      	lsrs	r3, r0, #2
 8005a90:	428b      	cmp	r3, r1
 8005a92:	d301      	bcc.n	8005a98 <__udivsi3+0xe4>
 8005a94:	008b      	lsls	r3, r1, #2
 8005a96:	1ac0      	subs	r0, r0, r3
 8005a98:	4152      	adcs	r2, r2
 8005a9a:	0843      	lsrs	r3, r0, #1
 8005a9c:	428b      	cmp	r3, r1
 8005a9e:	d301      	bcc.n	8005aa4 <__udivsi3+0xf0>
 8005aa0:	004b      	lsls	r3, r1, #1
 8005aa2:	1ac0      	subs	r0, r0, r3
 8005aa4:	4152      	adcs	r2, r2
 8005aa6:	1a41      	subs	r1, r0, r1
 8005aa8:	d200      	bcs.n	8005aac <__udivsi3+0xf8>
 8005aaa:	4601      	mov	r1, r0
 8005aac:	4152      	adcs	r2, r2
 8005aae:	4610      	mov	r0, r2
 8005ab0:	4770      	bx	lr
 8005ab2:	e7ff      	b.n	8005ab4 <__udivsi3+0x100>
 8005ab4:	b501      	push	{r0, lr}
 8005ab6:	2000      	movs	r0, #0
 8005ab8:	f000 f8f0 	bl	8005c9c <__aeabi_idiv0>
 8005abc:	bd02      	pop	{r1, pc}
 8005abe:	46c0      	nop			; (mov r8, r8)

08005ac0 <__aeabi_uidivmod>:
 8005ac0:	2900      	cmp	r1, #0
 8005ac2:	d0f7      	beq.n	8005ab4 <__udivsi3+0x100>
 8005ac4:	e776      	b.n	80059b4 <__udivsi3>
 8005ac6:	4770      	bx	lr

08005ac8 <__divsi3>:
 8005ac8:	4603      	mov	r3, r0
 8005aca:	430b      	orrs	r3, r1
 8005acc:	d47f      	bmi.n	8005bce <__divsi3+0x106>
 8005ace:	2200      	movs	r2, #0
 8005ad0:	0843      	lsrs	r3, r0, #1
 8005ad2:	428b      	cmp	r3, r1
 8005ad4:	d374      	bcc.n	8005bc0 <__divsi3+0xf8>
 8005ad6:	0903      	lsrs	r3, r0, #4
 8005ad8:	428b      	cmp	r3, r1
 8005ada:	d35f      	bcc.n	8005b9c <__divsi3+0xd4>
 8005adc:	0a03      	lsrs	r3, r0, #8
 8005ade:	428b      	cmp	r3, r1
 8005ae0:	d344      	bcc.n	8005b6c <__divsi3+0xa4>
 8005ae2:	0b03      	lsrs	r3, r0, #12
 8005ae4:	428b      	cmp	r3, r1
 8005ae6:	d328      	bcc.n	8005b3a <__divsi3+0x72>
 8005ae8:	0c03      	lsrs	r3, r0, #16
 8005aea:	428b      	cmp	r3, r1
 8005aec:	d30d      	bcc.n	8005b0a <__divsi3+0x42>
 8005aee:	22ff      	movs	r2, #255	; 0xff
 8005af0:	0209      	lsls	r1, r1, #8
 8005af2:	ba12      	rev	r2, r2
 8005af4:	0c03      	lsrs	r3, r0, #16
 8005af6:	428b      	cmp	r3, r1
 8005af8:	d302      	bcc.n	8005b00 <__divsi3+0x38>
 8005afa:	1212      	asrs	r2, r2, #8
 8005afc:	0209      	lsls	r1, r1, #8
 8005afe:	d065      	beq.n	8005bcc <__divsi3+0x104>
 8005b00:	0b03      	lsrs	r3, r0, #12
 8005b02:	428b      	cmp	r3, r1
 8005b04:	d319      	bcc.n	8005b3a <__divsi3+0x72>
 8005b06:	e000      	b.n	8005b0a <__divsi3+0x42>
 8005b08:	0a09      	lsrs	r1, r1, #8
 8005b0a:	0bc3      	lsrs	r3, r0, #15
 8005b0c:	428b      	cmp	r3, r1
 8005b0e:	d301      	bcc.n	8005b14 <__divsi3+0x4c>
 8005b10:	03cb      	lsls	r3, r1, #15
 8005b12:	1ac0      	subs	r0, r0, r3
 8005b14:	4152      	adcs	r2, r2
 8005b16:	0b83      	lsrs	r3, r0, #14
 8005b18:	428b      	cmp	r3, r1
 8005b1a:	d301      	bcc.n	8005b20 <__divsi3+0x58>
 8005b1c:	038b      	lsls	r3, r1, #14
 8005b1e:	1ac0      	subs	r0, r0, r3
 8005b20:	4152      	adcs	r2, r2
 8005b22:	0b43      	lsrs	r3, r0, #13
 8005b24:	428b      	cmp	r3, r1
 8005b26:	d301      	bcc.n	8005b2c <__divsi3+0x64>
 8005b28:	034b      	lsls	r3, r1, #13
 8005b2a:	1ac0      	subs	r0, r0, r3
 8005b2c:	4152      	adcs	r2, r2
 8005b2e:	0b03      	lsrs	r3, r0, #12
 8005b30:	428b      	cmp	r3, r1
 8005b32:	d301      	bcc.n	8005b38 <__divsi3+0x70>
 8005b34:	030b      	lsls	r3, r1, #12
 8005b36:	1ac0      	subs	r0, r0, r3
 8005b38:	4152      	adcs	r2, r2
 8005b3a:	0ac3      	lsrs	r3, r0, #11
 8005b3c:	428b      	cmp	r3, r1
 8005b3e:	d301      	bcc.n	8005b44 <__divsi3+0x7c>
 8005b40:	02cb      	lsls	r3, r1, #11
 8005b42:	1ac0      	subs	r0, r0, r3
 8005b44:	4152      	adcs	r2, r2
 8005b46:	0a83      	lsrs	r3, r0, #10
 8005b48:	428b      	cmp	r3, r1
 8005b4a:	d301      	bcc.n	8005b50 <__divsi3+0x88>
 8005b4c:	028b      	lsls	r3, r1, #10
 8005b4e:	1ac0      	subs	r0, r0, r3
 8005b50:	4152      	adcs	r2, r2
 8005b52:	0a43      	lsrs	r3, r0, #9
 8005b54:	428b      	cmp	r3, r1
 8005b56:	d301      	bcc.n	8005b5c <__divsi3+0x94>
 8005b58:	024b      	lsls	r3, r1, #9
 8005b5a:	1ac0      	subs	r0, r0, r3
 8005b5c:	4152      	adcs	r2, r2
 8005b5e:	0a03      	lsrs	r3, r0, #8
 8005b60:	428b      	cmp	r3, r1
 8005b62:	d301      	bcc.n	8005b68 <__divsi3+0xa0>
 8005b64:	020b      	lsls	r3, r1, #8
 8005b66:	1ac0      	subs	r0, r0, r3
 8005b68:	4152      	adcs	r2, r2
 8005b6a:	d2cd      	bcs.n	8005b08 <__divsi3+0x40>
 8005b6c:	09c3      	lsrs	r3, r0, #7
 8005b6e:	428b      	cmp	r3, r1
 8005b70:	d301      	bcc.n	8005b76 <__divsi3+0xae>
 8005b72:	01cb      	lsls	r3, r1, #7
 8005b74:	1ac0      	subs	r0, r0, r3
 8005b76:	4152      	adcs	r2, r2
 8005b78:	0983      	lsrs	r3, r0, #6
 8005b7a:	428b      	cmp	r3, r1
 8005b7c:	d301      	bcc.n	8005b82 <__divsi3+0xba>
 8005b7e:	018b      	lsls	r3, r1, #6
 8005b80:	1ac0      	subs	r0, r0, r3
 8005b82:	4152      	adcs	r2, r2
 8005b84:	0943      	lsrs	r3, r0, #5
 8005b86:	428b      	cmp	r3, r1
 8005b88:	d301      	bcc.n	8005b8e <__divsi3+0xc6>
 8005b8a:	014b      	lsls	r3, r1, #5
 8005b8c:	1ac0      	subs	r0, r0, r3
 8005b8e:	4152      	adcs	r2, r2
 8005b90:	0903      	lsrs	r3, r0, #4
 8005b92:	428b      	cmp	r3, r1
 8005b94:	d301      	bcc.n	8005b9a <__divsi3+0xd2>
 8005b96:	010b      	lsls	r3, r1, #4
 8005b98:	1ac0      	subs	r0, r0, r3
 8005b9a:	4152      	adcs	r2, r2
 8005b9c:	08c3      	lsrs	r3, r0, #3
 8005b9e:	428b      	cmp	r3, r1
 8005ba0:	d301      	bcc.n	8005ba6 <__divsi3+0xde>
 8005ba2:	00cb      	lsls	r3, r1, #3
 8005ba4:	1ac0      	subs	r0, r0, r3
 8005ba6:	4152      	adcs	r2, r2
 8005ba8:	0883      	lsrs	r3, r0, #2
 8005baa:	428b      	cmp	r3, r1
 8005bac:	d301      	bcc.n	8005bb2 <__divsi3+0xea>
 8005bae:	008b      	lsls	r3, r1, #2
 8005bb0:	1ac0      	subs	r0, r0, r3
 8005bb2:	4152      	adcs	r2, r2
 8005bb4:	0843      	lsrs	r3, r0, #1
 8005bb6:	428b      	cmp	r3, r1
 8005bb8:	d301      	bcc.n	8005bbe <__divsi3+0xf6>
 8005bba:	004b      	lsls	r3, r1, #1
 8005bbc:	1ac0      	subs	r0, r0, r3
 8005bbe:	4152      	adcs	r2, r2
 8005bc0:	1a41      	subs	r1, r0, r1
 8005bc2:	d200      	bcs.n	8005bc6 <__divsi3+0xfe>
 8005bc4:	4601      	mov	r1, r0
 8005bc6:	4152      	adcs	r2, r2
 8005bc8:	4610      	mov	r0, r2
 8005bca:	4770      	bx	lr
 8005bcc:	e05d      	b.n	8005c8a <__divsi3+0x1c2>
 8005bce:	0fca      	lsrs	r2, r1, #31
 8005bd0:	d000      	beq.n	8005bd4 <__divsi3+0x10c>
 8005bd2:	4249      	negs	r1, r1
 8005bd4:	1003      	asrs	r3, r0, #32
 8005bd6:	d300      	bcc.n	8005bda <__divsi3+0x112>
 8005bd8:	4240      	negs	r0, r0
 8005bda:	4053      	eors	r3, r2
 8005bdc:	2200      	movs	r2, #0
 8005bde:	469c      	mov	ip, r3
 8005be0:	0903      	lsrs	r3, r0, #4
 8005be2:	428b      	cmp	r3, r1
 8005be4:	d32d      	bcc.n	8005c42 <__divsi3+0x17a>
 8005be6:	0a03      	lsrs	r3, r0, #8
 8005be8:	428b      	cmp	r3, r1
 8005bea:	d312      	bcc.n	8005c12 <__divsi3+0x14a>
 8005bec:	22fc      	movs	r2, #252	; 0xfc
 8005bee:	0189      	lsls	r1, r1, #6
 8005bf0:	ba12      	rev	r2, r2
 8005bf2:	0a03      	lsrs	r3, r0, #8
 8005bf4:	428b      	cmp	r3, r1
 8005bf6:	d30c      	bcc.n	8005c12 <__divsi3+0x14a>
 8005bf8:	0189      	lsls	r1, r1, #6
 8005bfa:	1192      	asrs	r2, r2, #6
 8005bfc:	428b      	cmp	r3, r1
 8005bfe:	d308      	bcc.n	8005c12 <__divsi3+0x14a>
 8005c00:	0189      	lsls	r1, r1, #6
 8005c02:	1192      	asrs	r2, r2, #6
 8005c04:	428b      	cmp	r3, r1
 8005c06:	d304      	bcc.n	8005c12 <__divsi3+0x14a>
 8005c08:	0189      	lsls	r1, r1, #6
 8005c0a:	d03a      	beq.n	8005c82 <__divsi3+0x1ba>
 8005c0c:	1192      	asrs	r2, r2, #6
 8005c0e:	e000      	b.n	8005c12 <__divsi3+0x14a>
 8005c10:	0989      	lsrs	r1, r1, #6
 8005c12:	09c3      	lsrs	r3, r0, #7
 8005c14:	428b      	cmp	r3, r1
 8005c16:	d301      	bcc.n	8005c1c <__divsi3+0x154>
 8005c18:	01cb      	lsls	r3, r1, #7
 8005c1a:	1ac0      	subs	r0, r0, r3
 8005c1c:	4152      	adcs	r2, r2
 8005c1e:	0983      	lsrs	r3, r0, #6
 8005c20:	428b      	cmp	r3, r1
 8005c22:	d301      	bcc.n	8005c28 <__divsi3+0x160>
 8005c24:	018b      	lsls	r3, r1, #6
 8005c26:	1ac0      	subs	r0, r0, r3
 8005c28:	4152      	adcs	r2, r2
 8005c2a:	0943      	lsrs	r3, r0, #5
 8005c2c:	428b      	cmp	r3, r1
 8005c2e:	d301      	bcc.n	8005c34 <__divsi3+0x16c>
 8005c30:	014b      	lsls	r3, r1, #5
 8005c32:	1ac0      	subs	r0, r0, r3
 8005c34:	4152      	adcs	r2, r2
 8005c36:	0903      	lsrs	r3, r0, #4
 8005c38:	428b      	cmp	r3, r1
 8005c3a:	d301      	bcc.n	8005c40 <__divsi3+0x178>
 8005c3c:	010b      	lsls	r3, r1, #4
 8005c3e:	1ac0      	subs	r0, r0, r3
 8005c40:	4152      	adcs	r2, r2
 8005c42:	08c3      	lsrs	r3, r0, #3
 8005c44:	428b      	cmp	r3, r1
 8005c46:	d301      	bcc.n	8005c4c <__divsi3+0x184>
 8005c48:	00cb      	lsls	r3, r1, #3
 8005c4a:	1ac0      	subs	r0, r0, r3
 8005c4c:	4152      	adcs	r2, r2
 8005c4e:	0883      	lsrs	r3, r0, #2
 8005c50:	428b      	cmp	r3, r1
 8005c52:	d301      	bcc.n	8005c58 <__divsi3+0x190>
 8005c54:	008b      	lsls	r3, r1, #2
 8005c56:	1ac0      	subs	r0, r0, r3
 8005c58:	4152      	adcs	r2, r2
 8005c5a:	d2d9      	bcs.n	8005c10 <__divsi3+0x148>
 8005c5c:	0843      	lsrs	r3, r0, #1
 8005c5e:	428b      	cmp	r3, r1
 8005c60:	d301      	bcc.n	8005c66 <__divsi3+0x19e>
 8005c62:	004b      	lsls	r3, r1, #1
 8005c64:	1ac0      	subs	r0, r0, r3
 8005c66:	4152      	adcs	r2, r2
 8005c68:	1a41      	subs	r1, r0, r1
 8005c6a:	d200      	bcs.n	8005c6e <__divsi3+0x1a6>
 8005c6c:	4601      	mov	r1, r0
 8005c6e:	4663      	mov	r3, ip
 8005c70:	4152      	adcs	r2, r2
 8005c72:	105b      	asrs	r3, r3, #1
 8005c74:	4610      	mov	r0, r2
 8005c76:	d301      	bcc.n	8005c7c <__divsi3+0x1b4>
 8005c78:	4240      	negs	r0, r0
 8005c7a:	2b00      	cmp	r3, #0
 8005c7c:	d500      	bpl.n	8005c80 <__divsi3+0x1b8>
 8005c7e:	4249      	negs	r1, r1
 8005c80:	4770      	bx	lr
 8005c82:	4663      	mov	r3, ip
 8005c84:	105b      	asrs	r3, r3, #1
 8005c86:	d300      	bcc.n	8005c8a <__divsi3+0x1c2>
 8005c88:	4240      	negs	r0, r0
 8005c8a:	b501      	push	{r0, lr}
 8005c8c:	2000      	movs	r0, #0
 8005c8e:	f000 f805 	bl	8005c9c <__aeabi_idiv0>
 8005c92:	bd02      	pop	{r1, pc}

08005c94 <__aeabi_idivmod>:
 8005c94:	2900      	cmp	r1, #0
 8005c96:	d0f8      	beq.n	8005c8a <__divsi3+0x1c2>
 8005c98:	e716      	b.n	8005ac8 <__divsi3>
 8005c9a:	4770      	bx	lr

08005c9c <__aeabi_idiv0>:
 8005c9c:	4770      	bx	lr
 8005c9e:	46c0      	nop			; (mov r8, r8)

08005ca0 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8005ca0:	480d      	ldr	r0, [pc, #52]	; (8005cd8 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8005ca2:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 8005ca4:	2100      	movs	r1, #0
  b LoopCopyDataInit
 8005ca6:	e003      	b.n	8005cb0 <LoopCopyDataInit>

08005ca8 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 8005ca8:	4b0c      	ldr	r3, [pc, #48]	; (8005cdc <LoopForever+0x6>)
  ldr r3, [r3, r1]
 8005caa:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 8005cac:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 8005cae:	3104      	adds	r1, #4

08005cb0 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 8005cb0:	480b      	ldr	r0, [pc, #44]	; (8005ce0 <LoopForever+0xa>)
  ldr r3, =_edata
 8005cb2:	4b0c      	ldr	r3, [pc, #48]	; (8005ce4 <LoopForever+0xe>)
  adds r2, r0, r1
 8005cb4:	1842      	adds	r2, r0, r1
  cmp r2, r3
 8005cb6:	429a      	cmp	r2, r3
  bcc CopyDataInit
 8005cb8:	d3f6      	bcc.n	8005ca8 <CopyDataInit>
  ldr r2, =_sbss
 8005cba:	4a0b      	ldr	r2, [pc, #44]	; (8005ce8 <LoopForever+0x12>)
  b LoopFillZerobss
 8005cbc:	e002      	b.n	8005cc4 <LoopFillZerobss>

08005cbe <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 8005cbe:	2300      	movs	r3, #0
  str  r3, [r2]
 8005cc0:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8005cc2:	3204      	adds	r2, #4

08005cc4 <LoopFillZerobss>:


LoopFillZerobss:
  ldr r3, = _ebss
 8005cc4:	4b09      	ldr	r3, [pc, #36]	; (8005cec <LoopForever+0x16>)
  cmp r2, r3
 8005cc6:	429a      	cmp	r2, r3
  bcc FillZerobss
 8005cc8:	d3f9      	bcc.n	8005cbe <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 8005cca:	f001 f94d 	bl	8006f68 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 8005cce:	f006 fc27 	bl	800c520 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8005cd2:	f000 f80f 	bl	8005cf4 <main>

08005cd6 <LoopForever>:

LoopForever:
    b LoopForever
 8005cd6:	e7fe      	b.n	8005cd6 <LoopForever>
  ldr   r0, =_estack
 8005cd8:	20004000 	.word	0x20004000
  ldr r3, =_sidata
 8005cdc:	0800c890 	.word	0x0800c890
  ldr r0, =_sdata
 8005ce0:	20000000 	.word	0x20000000
  ldr r3, =_edata
 8005ce4:	200002a8 	.word	0x200002a8
  ldr r2, =_sbss
 8005ce8:	200002a8 	.word	0x200002a8
  ldr r3, = _ebss
 8005cec:	20001cec 	.word	0x20001cec

08005cf0 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8005cf0:	e7fe      	b.n	8005cf0 <ADC1_COMP_IRQHandler>
	...

08005cf4 <main>:
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
 8005cf4:	b510      	push	{r4, lr}
  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8005cf6:	f001 f979 	bl	8006fec <HAL_Init>
  *         @arg @ref LL_FLASH_LATENCY_1
  * @retval None
  */
__STATIC_INLINE void LL_FLASH_SetLatency(uint32_t Latency)
{
  MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
 8005cfa:	2101      	movs	r1, #1
 8005cfc:	4a2b      	ldr	r2, [pc, #172]	; (8005dac <main+0xb8>)
 8005cfe:	6813      	ldr	r3, [r2, #0]
 8005d00:	430b      	orrs	r3, r1
 8005d02:	6013      	str	r3, [r2, #0]
  * @rmtoll CR2          HSI48ON       LL_RCC_HSI48_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI48_Enable(void)
{
  SET_BIT(RCC->CR2, RCC_CR2_HSI48ON);
 8005d04:	2280      	movs	r2, #128	; 0x80
 8005d06:	4b2a      	ldr	r3, [pc, #168]	; (8005db0 <main+0xbc>)
 8005d08:	0252      	lsls	r2, r2, #9
 8005d0a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8005d0c:	430a      	orrs	r2, r1
 8005d0e:	635a      	str	r2, [r3, #52]	; 0x34
  * @rmtoll CR2          HSI48RDY      LL_RCC_HSI48_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI48_IsReady(void)
{
  return (READ_BIT(RCC->CR2, RCC_CR2_HSI48RDY) == (RCC_CR2_HSI48RDY));
 8005d10:	2280      	movs	r2, #128	; 0x80
 8005d12:	0292      	lsls	r2, r2, #10
 8005d14:	6b59      	ldr	r1, [r3, #52]	; 0x34
  /* Set FLASH latency */ 
  LL_FLASH_SetLatency(LL_FLASH_LATENCY_1);

  /* Enable HSI48 and wait for activation*/
  LL_RCC_HSI48_Enable(); 
  while(LL_RCC_HSI48_IsReady() != 1) 
 8005d16:	4211      	tst	r1, r2
 8005d18:	d0fc      	beq.n	8005d14 <main+0x20>
  *         @arg @ref LL_RCC_PREDIV_DIV_16
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_ConfigDomain_SYS(uint32_t Source, uint32_t PLLMul, uint32_t PLLDiv)
{
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL, Source | PLLMul);
 8005d1a:	685a      	ldr	r2, [r3, #4]
 8005d1c:	4925      	ldr	r1, [pc, #148]	; (8005db4 <main+0xc0>)
 8005d1e:	4011      	ands	r1, r2
 8005d20:	22c0      	movs	r2, #192	; 0xc0
 8005d22:	0252      	lsls	r2, r2, #9
 8005d24:	430a      	orrs	r2, r1
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, PLLDiv);
 8005d26:	210f      	movs	r1, #15
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL, Source | PLLMul);
 8005d28:	605a      	str	r2, [r3, #4]
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, PLLDiv);
 8005d2a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005d2c:	438a      	bics	r2, r1
 8005d2e:	0011      	movs	r1, r2
 8005d30:	2201      	movs	r2, #1
 8005d32:	430a      	orrs	r2, r1
 8005d34:	62da      	str	r2, [r3, #44]	; 0x2c
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 8005d36:	2280      	movs	r2, #128	; 0x80
 8005d38:	6819      	ldr	r1, [r3, #0]
 8005d3a:	0452      	lsls	r2, r2, #17
 8005d3c:	430a      	orrs	r2, r1
 8005d3e:	601a      	str	r2, [r3, #0]
  return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
 8005d40:	2280      	movs	r2, #128	; 0x80
 8005d42:	0492      	lsls	r2, r2, #18
 8005d44:	6819      	ldr	r1, [r3, #0]
  
  /* Main PLL configuration and activation */
  LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI48, LL_RCC_PLL_MUL_2, LL_RCC_PREDIV_DIV_2);
  
  LL_RCC_PLL_Enable();
  while(LL_RCC_PLL_IsReady() != 1)
 8005d46:	4211      	tst	r1, r2
 8005d48:	d0fc      	beq.n	8005d44 <main+0x50>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 8005d4a:	21f0      	movs	r1, #240	; 0xf0
 8005d4c:	685a      	ldr	r2, [r3, #4]
 8005d4e:	438a      	bics	r2, r1
 8005d50:	605a      	str	r2, [r3, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8005d52:	685a      	ldr	r2, [r3, #4]
 8005d54:	39ed      	subs	r1, #237	; 0xed
 8005d56:	438a      	bics	r2, r1
 8005d58:	0011      	movs	r1, r2
 8005d5a:	2202      	movs	r2, #2
 8005d5c:	430a      	orrs	r2, r1
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8005d5e:	210c      	movs	r1, #12
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8005d60:	605a      	str	r2, [r3, #4]
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8005d62:	685a      	ldr	r2, [r3, #4]
 8005d64:	400a      	ands	r2, r1
  };
  
  /* Sysclk activation on the main PLL */
  LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
  LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
  while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
 8005d66:	2a08      	cmp	r2, #8
 8005d68:	d1fb      	bne.n	8005d62 <main+0x6e>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, Prescaler);
 8005d6a:	685a      	ldr	r2, [r3, #4]
 8005d6c:	4912      	ldr	r1, [pc, #72]	; (8005db8 <main+0xc4>)
  LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);
  
  /* Set systick to 1ms in using frequency set to 48MHz */
  /* This frequency can be calculated through LL RCC macro */
  /* ex: __LL_RCC_CALC_PLLCLK_FREQ (HSI48_VALUE, LL_RCC_PLL_MUL_2, LL_RCC_PREDIV_DIV_2) */
  LL_Init1msTick(48000000);
 8005d6e:	4813      	ldr	r0, [pc, #76]	; (8005dbc <main+0xc8>)
 8005d70:	400a      	ands	r2, r1
 8005d72:	605a      	str	r2, [r3, #4]
 8005d74:	f003 f96c 	bl	8009050 <LL_Init1msTick>
  
  /* Update CMSIS variable (which can be updated also through SystemCoreClockUpdate function) */
  LL_SetSystemCoreClock(48000000);
 8005d78:	4810      	ldr	r0, [pc, #64]	; (8005dbc <main+0xc8>)
 8005d7a:	f003 f979 	bl	8009070 <LL_SetSystemCoreClock>
  HAL_NVIC_SetPriority(SysTick_IRQn, TICK_INT_PRIORITY ,0U);
 8005d7e:	2001      	movs	r0, #1
 8005d80:	2200      	movs	r2, #0
 8005d82:	4240      	negs	r0, r0
 8005d84:	2103      	movs	r1, #3
 8005d86:	f001 fbbb 	bl	8007500 <HAL_NVIC_SetPriority>
  * @rmtoll STK_CTRL     TICKINT       LL_SYSTICK_EnableIT
  * @retval None
  */
__STATIC_INLINE void LL_SYSTICK_EnableIT(void)
{
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 8005d8a:	2302      	movs	r3, #2
 8005d8c:	4a0c      	ldr	r2, [pc, #48]	; (8005dc0 <main+0xcc>)
 8005d8e:	6811      	ldr	r1, [r2, #0]
 8005d90:	430b      	orrs	r3, r1
 8005d92:	6013      	str	r3, [r2, #0]
  USBPD_BSP_LED_Init();
 8005d94:	f001 f8c0 	bl	8006f18 <USBPD_BSP_LED_Init>
  USBPD_HW_IF_GlobalHwInit();
 8005d98:	f004 f964 	bl	800a064 <USBPD_HW_IF_GlobalHwInit>
  if( USBPD_ERROR == USBPD_DPM_Init())
 8005d9c:	f003 fa0c 	bl	80091b8 <USBPD_DPM_Init>
 8005da0:	2802      	cmp	r0, #2
 8005da2:	d100      	bne.n	8005da6 <main+0xb2>
 8005da4:	e7fe      	b.n	8005da4 <main+0xb0>
}
 8005da6:	2000      	movs	r0, #0
 8005da8:	bd10      	pop	{r4, pc}
 8005daa:	46c0      	nop			; (mov r8, r8)
 8005dac:	40022000 	.word	0x40022000
 8005db0:	40021000 	.word	0x40021000
 8005db4:	ffc27fff 	.word	0xffc27fff
 8005db8:	fffff8ff 	.word	0xfffff8ff
 8005dbc:	02dc6c00 	.word	0x02dc6c00
 8005dc0:	e000e010 	.word	0xe000e010

08005dc4 <HAL_MspInit>:
  *         level initialization (GPIOs, clock, DMA, interrupt).
  * @retval None
  */
void HAL_MspInit(void)
{
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005dc4:	2001      	movs	r0, #1
 8005dc6:	4b1c      	ldr	r3, [pc, #112]	; (8005e38 <HAL_MspInit+0x74>)
{
 8005dc8:	b086      	sub	sp, #24
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005dca:	6999      	ldr	r1, [r3, #24]
 8005dcc:	4301      	orrs	r1, r0
 8005dce:	6199      	str	r1, [r3, #24]
 8005dd0:	699a      	ldr	r2, [r3, #24]
 8005dd2:	4002      	ands	r2, r0
  /* Enable the RCC peripheral clock associated to all the selected GPIOs */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8005dd4:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005dd6:	9200      	str	r2, [sp, #0]
 8005dd8:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8005dda:	6959      	ldr	r1, [r3, #20]
 8005ddc:	0280      	lsls	r0, r0, #10
 8005dde:	4301      	orrs	r1, r0
 8005de0:	6159      	str	r1, [r3, #20]
 8005de2:	695a      	ldr	r2, [r3, #20]
 8005de4:	4002      	ands	r2, r0
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8005de6:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8005de8:	9201      	str	r2, [sp, #4]
 8005dea:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8005dec:	6959      	ldr	r1, [r3, #20]
 8005dee:	02c0      	lsls	r0, r0, #11
 8005df0:	4301      	orrs	r1, r0
 8005df2:	6159      	str	r1, [r3, #20]
 8005df4:	695a      	ldr	r2, [r3, #20]
 8005df6:	4002      	ands	r2, r0
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8005df8:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8005dfa:	9202      	str	r2, [sp, #8]
 8005dfc:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8005dfe:	6959      	ldr	r1, [r3, #20]
 8005e00:	0300      	lsls	r0, r0, #12
 8005e02:	4301      	orrs	r1, r0
 8005e04:	6159      	str	r1, [r3, #20]
 8005e06:	695a      	ldr	r2, [r3, #20]
 8005e08:	4002      	ands	r2, r0
#if defined(GPIOD)
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e0a:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8005e0c:	9203      	str	r2, [sp, #12]
 8005e0e:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e10:	6959      	ldr	r1, [r3, #20]
 8005e12:	0340      	lsls	r0, r0, #13
 8005e14:	4301      	orrs	r1, r0
 8005e16:	6159      	str	r1, [r3, #20]
#endif /* GPIOD */
#if defined(GPIOF)
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8005e18:	2180      	movs	r1, #128	; 0x80
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e1a:	695a      	ldr	r2, [r3, #20]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8005e1c:	03c9      	lsls	r1, r1, #15
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e1e:	4002      	ands	r2, r0
 8005e20:	9204      	str	r2, [sp, #16]
 8005e22:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8005e24:	695a      	ldr	r2, [r3, #20]
 8005e26:	430a      	orrs	r2, r1
 8005e28:	615a      	str	r2, [r3, #20]
 8005e2a:	695b      	ldr	r3, [r3, #20]
 8005e2c:	400b      	ands	r3, r1
 8005e2e:	9305      	str	r3, [sp, #20]
 8005e30:	9b05      	ldr	r3, [sp, #20]
#endif /* GPIOD */
}
 8005e32:	b006      	add	sp, #24
 8005e34:	4770      	bx	lr
 8005e36:	46c0      	nop			; (mov r8, r8)
 8005e38:	40021000 	.word	0x40021000

08005e3c <HAL_ADC_MspInit>:
  * @brief ADC MSP Initialization
  * @param hadc: ADC handle pointer
  * @retval None
  */
void HAL_ADC_MspInit(ADC_HandleTypeDef *hadc)
{
 8005e3c:	b513      	push	{r0, r1, r4, lr}
  /* Enable clock of ADCx peripheral */
  ADCx_CLK_ENABLE();
 8005e3e:	2180      	movs	r1, #128	; 0x80
 8005e40:	4c0a      	ldr	r4, [pc, #40]	; (8005e6c <HAL_ADC_MspInit+0x30>)
 8005e42:	0089      	lsls	r1, r1, #2
 8005e44:	69a2      	ldr	r2, [r4, #24]
 8005e46:	430a      	orrs	r2, r1
 8005e48:	61a2      	str	r2, [r4, #24]
 8005e4a:	69a3      	ldr	r3, [r4, #24]
 8005e4c:	400b      	ands	r3, r1
 8005e4e:	9300      	str	r3, [sp, #0]
 8005e50:	9b00      	ldr	r3, [sp, #0]
  PHY_HW_IF_ADCAnalogGPIO_Init();
 8005e52:	f003 fe41 	bl	8009ad8 <PHY_HW_IF_ADCAnalogGPIO_Init>
  
  /* Enable clock of DMA associated to the peripheral */
  ADCx_DMA_CLK_ENABLE();
 8005e56:	2101      	movs	r1, #1
 8005e58:	6962      	ldr	r2, [r4, #20]
 8005e5a:	430a      	orrs	r2, r1
 8005e5c:	6162      	str	r2, [r4, #20]
 8005e5e:	6963      	ldr	r3, [r4, #20]
 8005e60:	400b      	ands	r3, r1
 8005e62:	9301      	str	r3, [sp, #4]
 8005e64:	9b01      	ldr	r3, [sp, #4]
  PHY_HW_IF_ADCDMA_Init();
 8005e66:	f003 fe55 	bl	8009b14 <PHY_HW_IF_ADCDMA_Init>
}
 8005e6a:	bd13      	pop	{r0, r1, r4, pc}
 8005e6c:	40021000 	.word	0x40021000

08005e70 <HAL_SPI_MspInit>:
  * @brief SPI MSP Initialization
  * @param hspi: SPI handle pointer
  * @retval None
  */
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8005e70:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  
  uint8_t port_num = GET_PORT_FROM_SPI(hspi);
 8005e72:	4b38      	ldr	r3, [pc, #224]	; (8005f54 <HAL_SPI_MspInit+0xe4>)
 8005e74:	6804      	ldr	r4, [r0, #0]
  
  /* Peripheral clock enable */
  SPI_CLK_ENABLE(port_num);
 8005e76:	4e38      	ldr	r6, [pc, #224]	; (8005f58 <HAL_SPI_MspInit+0xe8>)
  uint8_t port_num = GET_PORT_FROM_SPI(hspi);
 8005e78:	18e5      	adds	r5, r4, r3
 8005e7a:	1e6b      	subs	r3, r5, #1
 8005e7c:	419d      	sbcs	r5, r3
{
 8005e7e:	b089      	sub	sp, #36	; 0x24
  uint8_t port_num = GET_PORT_FROM_SPI(hspi);
 8005e80:	b2ed      	uxtb	r5, r5
 8005e82:	4a36      	ldr	r2, [pc, #216]	; (8005f5c <HAL_SPI_MspInit+0xec>)
  SPI_CLK_ENABLE(port_num);
 8005e84:	42b4      	cmp	r4, r6
 8005e86:	d159      	bne.n	8005f3c <HAL_SPI_MspInit+0xcc>
 8005e88:	2380      	movs	r3, #128	; 0x80
 8005e8a:	69d1      	ldr	r1, [r2, #28]
 8005e8c:	01db      	lsls	r3, r3, #7
 8005e8e:	4319      	orrs	r1, r3
 8005e90:	61d1      	str	r1, [r2, #28]
 8005e92:	69d2      	ldr	r2, [r2, #28]
 8005e94:	401a      	ands	r2, r3
 8005e96:	9201      	str	r2, [sp, #4]
 8005e98:	9a01      	ldr	r2, [sp, #4]
  
  GPIO_InitStruct.Pin = SPI_MISO_PIN(port_num);
 8005e9a:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005e9c:	2203      	movs	r2, #3
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005e9e:	2300      	movs	r3, #0
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005ea0:	2702      	movs	r7, #2
  GPIO_InitStruct.Alternate = SPI_MISO_ALTERNATE(port_num);
  HAL_GPIO_Init(SPI_MISO_PORT(port_num), &GPIO_InitStruct);
 8005ea2:	a903      	add	r1, sp, #12
 8005ea4:	482e      	ldr	r0, [pc, #184]	; (8005f60 <HAL_SPI_MspInit+0xf0>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005ea6:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = SPI_MISO_ALTERNATE(port_num);
 8005ea8:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005eaa:	9704      	str	r7, [sp, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005eac:	9206      	str	r2, [sp, #24]
  HAL_GPIO_Init(SPI_MISO_PORT(port_num), &GPIO_InitStruct);
 8005eae:	f001 fd01 	bl	80078b4 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = SPI_MOSI_PIN(port_num);
 8005eb2:	2320      	movs	r3, #32
 8005eb4:	42b4      	cmp	r4, r6
 8005eb6:	d101      	bne.n	8005ebc <HAL_SPI_MspInit+0x4c>
 8005eb8:	2380      	movs	r3, #128	; 0x80
 8005eba:	021b      	lsls	r3, r3, #8
 8005ebc:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005ebe:	2301      	movs	r3, #1
 8005ec0:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005ec2:	3302      	adds	r3, #2
 8005ec4:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Alternate = SPI_MOSI_ALTERNATE(port_num);
 8005ec6:	2300      	movs	r3, #0
  HAL_GPIO_Init(SPI_MOSI_PORT(port_num), &GPIO_InitStruct);
 8005ec8:	a903      	add	r1, sp, #12
 8005eca:	4825      	ldr	r0, [pc, #148]	; (8005f60 <HAL_SPI_MspInit+0xf0>)
  GPIO_InitStruct.Alternate = SPI_MOSI_ALTERNATE(port_num);
 8005ecc:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005ece:	9704      	str	r7, [sp, #16]
  HAL_GPIO_Init(SPI_MOSI_PORT(port_num), &GPIO_InitStruct);
 8005ed0:	f001 fcf0 	bl	80078b4 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = SPI_CLK_PIN(port_num);
 8005ed4:	2308      	movs	r3, #8
 8005ed6:	42b4      	cmp	r4, r6
 8005ed8:	d101      	bne.n	8005ede <HAL_SPI_MspInit+0x6e>
 8005eda:	2380      	movs	r3, #128	; 0x80
 8005edc:	019b      	lsls	r3, r3, #6
 8005ede:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005ee0:	2702      	movs	r7, #2
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005ee2:	2601      	movs	r6, #1
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005ee4:	2303      	movs	r3, #3
  GPIO_InitStruct.Alternate = SPI_CLK_ALTERNATE(port_num);
 8005ee6:	2200      	movs	r2, #0
  HAL_GPIO_Init(SPI_CLK_PORT(port_num), &GPIO_InitStruct);
 8005ee8:	a903      	add	r1, sp, #12
 8005eea:	481d      	ldr	r0, [pc, #116]	; (8005f60 <HAL_SPI_MspInit+0xf0>)
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005eec:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Alternate = SPI_CLK_ALTERNATE(port_num);
 8005eee:	9207      	str	r2, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005ef0:	9704      	str	r7, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005ef2:	9605      	str	r6, [sp, #20]
  HAL_GPIO_Init(SPI_CLK_PORT(port_num), &GPIO_InitStruct);
 8005ef4:	f001 fcde 	bl	80078b4 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = SPI_NSS_PIN(port_num);
 8005ef8:	4916      	ldr	r1, [pc, #88]	; (8005f54 <HAL_SPI_MspInit+0xe4>)
 8005efa:	4b1a      	ldr	r3, [pc, #104]	; (8005f64 <HAL_SPI_MspInit+0xf4>)
 8005efc:	1864      	adds	r4, r4, r1
 8005efe:	4260      	negs	r0, r4
 8005f00:	4160      	adcs	r0, r4
 8005f02:	2180      	movs	r1, #128	; 0x80
 8005f04:	4240      	negs	r0, r0
 8005f06:	4003      	ands	r3, r0
 8005f08:	0209      	lsls	r1, r1, #8
 8005f0a:	185b      	adds	r3, r3, r1
 8005f0c:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005f0e:	2303      	movs	r3, #3
  GPIO_InitStruct.Alternate = SPI_NSS_ALTERNATE(port_num);
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f10:	2480      	movs	r4, #128	; 0x80
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005f12:	9306      	str	r3, [sp, #24]
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f14:	2390      	movs	r3, #144	; 0x90
  GPIO_InitStruct.Alternate = SPI_NSS_ALTERNATE(port_num);
 8005f16:	2200      	movs	r2, #0
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f18:	00e4      	lsls	r4, r4, #3
 8005f1a:	05db      	lsls	r3, r3, #23
 8005f1c:	4020      	ands	r0, r4
 8005f1e:	18c0      	adds	r0, r0, r3
 8005f20:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Alternate = SPI_NSS_ALTERNATE(port_num);
 8005f22:	9207      	str	r2, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005f24:	9704      	str	r7, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005f26:	9605      	str	r6, [sp, #20]
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f28:	f001 fcc4 	bl	80078b4 <HAL_GPIO_Init>

  /* TX DMA Initialization */
  STUSB16xx_HW_IF_TX_DMA_Init(port_num);
 8005f2c:	0028      	movs	r0, r5
 8005f2e:	f004 fe23 	bl	800ab78 <STUSB16xx_HW_IF_TX_DMA_Init>

  /* RX DMA Initialization */
  STUSB16xx_HW_IF_RX_DMA_Init(port_num);  
 8005f32:	0028      	movs	r0, r5
 8005f34:	f004 fe5c 	bl	800abf0 <STUSB16xx_HW_IF_RX_DMA_Init>
}
 8005f38:	b009      	add	sp, #36	; 0x24
 8005f3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  SPI_CLK_ENABLE(port_num);
 8005f3c:	2080      	movs	r0, #128	; 0x80
 8005f3e:	6991      	ldr	r1, [r2, #24]
 8005f40:	0140      	lsls	r0, r0, #5
 8005f42:	4301      	orrs	r1, r0
 8005f44:	6191      	str	r1, [r2, #24]
 8005f46:	6993      	ldr	r3, [r2, #24]
 8005f48:	4003      	ands	r3, r0
 8005f4a:	9302      	str	r3, [sp, #8]
 8005f4c:	9b02      	ldr	r3, [sp, #8]
  GPIO_InitStruct.Pin = SPI_MISO_PIN(port_num);
 8005f4e:	2310      	movs	r3, #16
 8005f50:	e7a3      	b.n	8005e9a <HAL_SPI_MspInit+0x2a>
 8005f52:	46c0      	nop			; (mov r8, r8)
 8005f54:	bfffc800 	.word	0xbfffc800
 8005f58:	40003800 	.word	0x40003800
 8005f5c:	40021000 	.word	0x40021000
 8005f60:	48000400 	.word	0x48000400
 8005f64:	ffff9000 	.word	0xffff9000

08005f68 <HAL_I2C_MspInit>:
{
  GPIO_InitTypeDef GPIO_InitStruct;

  uint8_t port_num = GET_PORT_FROM_I2C(hi2c);

  GPIO_InitStruct.Pin       = I2C_SCL_PIN(port_num)|I2C_SDA_PIN(port_num);
 8005f68:	23c0      	movs	r3, #192	; 0xc0
{
 8005f6a:	b510      	push	{r4, lr}
  GPIO_InitStruct.Pin       = I2C_SCL_PIN(port_num)|I2C_SDA_PIN(port_num);
 8005f6c:	011b      	lsls	r3, r3, #4
{
 8005f6e:	b088      	sub	sp, #32
  GPIO_InitStruct.Pin       = I2C_SCL_PIN(port_num)|I2C_SDA_PIN(port_num);
 8005f70:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode      = I2C_MODE(port_num);
 8005f72:	2312      	movs	r3, #18
 8005f74:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pull      = I2C_PULL(port_num);
 8005f76:	2300      	movs	r3, #0
 8005f78:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Speed     = I2C_SPEED(port_num);
 8005f7a:	3303      	adds	r3, #3
  uint8_t port_num = GET_PORT_FROM_I2C(hi2c);
 8005f7c:	6804      	ldr	r4, [r0, #0]
  GPIO_InitStruct.Speed     = I2C_SPEED(port_num);
 8005f7e:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Alternate = I2C_ALTERNATE(port_num);
  HAL_GPIO_Init(I2C_PORT(port_num), &GPIO_InitStruct);
 8005f80:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Alternate = I2C_ALTERNATE(port_num);
 8005f82:	3b02      	subs	r3, #2
  HAL_GPIO_Init(I2C_PORT(port_num), &GPIO_InitStruct);
 8005f84:	480e      	ldr	r0, [pc, #56]	; (8005fc0 <HAL_I2C_MspInit+0x58>)
  GPIO_InitStruct.Alternate = I2C_ALTERNATE(port_num);
 8005f86:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(I2C_PORT(port_num), &GPIO_InitStruct);
 8005f88:	f001 fc94 	bl	80078b4 <HAL_GPIO_Init>

  /* Peripheral clock enable */
  I2C_CLK_ENABLE(port_num);
 8005f8c:	4a0d      	ldr	r2, [pc, #52]	; (8005fc4 <HAL_I2C_MspInit+0x5c>)
 8005f8e:	4b0e      	ldr	r3, [pc, #56]	; (8005fc8 <HAL_I2C_MspInit+0x60>)
 8005f90:	4294      	cmp	r4, r2
 8005f92:	d10a      	bne.n	8005faa <HAL_I2C_MspInit+0x42>
 8005f94:	2180      	movs	r1, #128	; 0x80
 8005f96:	69da      	ldr	r2, [r3, #28]
 8005f98:	03c9      	lsls	r1, r1, #15
 8005f9a:	430a      	orrs	r2, r1
 8005f9c:	61da      	str	r2, [r3, #28]
 8005f9e:	69db      	ldr	r3, [r3, #28]
 8005fa0:	400b      	ands	r3, r1
 8005fa2:	9301      	str	r3, [sp, #4]
 8005fa4:	9b01      	ldr	r3, [sp, #4]
  UNUSED(port_num);
}
 8005fa6:	b008      	add	sp, #32
 8005fa8:	bd10      	pop	{r4, pc}
  I2C_CLK_ENABLE(port_num);
 8005faa:	2180      	movs	r1, #128	; 0x80
 8005fac:	69da      	ldr	r2, [r3, #28]
 8005fae:	0389      	lsls	r1, r1, #14
 8005fb0:	430a      	orrs	r2, r1
 8005fb2:	61da      	str	r2, [r3, #28]
 8005fb4:	69db      	ldr	r3, [r3, #28]
 8005fb6:	400b      	ands	r3, r1
 8005fb8:	9302      	str	r3, [sp, #8]
 8005fba:	9b02      	ldr	r3, [sp, #8]
}
 8005fbc:	e7f3      	b.n	8005fa6 <HAL_I2C_MspInit+0x3e>
 8005fbe:	46c0      	nop			; (mov r8, r8)
 8005fc0:	48000400 	.word	0x48000400
 8005fc4:	40005800 	.word	0x40005800
 8005fc8:	40021000 	.word	0x40021000

08005fcc <HAL_CRC_MspInit>:
  * @retval None
  */
void HAL_CRC_MspInit(CRC_HandleTypeDef *hcrc)
{
  /* CRC Peripheral clock enable */
  __HAL_RCC_CRC_CLK_ENABLE();
 8005fcc:	2040      	movs	r0, #64	; 0x40
 8005fce:	4a05      	ldr	r2, [pc, #20]	; (8005fe4 <HAL_CRC_MspInit+0x18>)
{
 8005fd0:	b082      	sub	sp, #8
  __HAL_RCC_CRC_CLK_ENABLE();
 8005fd2:	6951      	ldr	r1, [r2, #20]
 8005fd4:	4301      	orrs	r1, r0
 8005fd6:	6151      	str	r1, [r2, #20]
 8005fd8:	6953      	ldr	r3, [r2, #20]
 8005fda:	4003      	ands	r3, r0
 8005fdc:	9301      	str	r3, [sp, #4]
 8005fde:	9b01      	ldr	r3, [sp, #4]
}
 8005fe0:	b002      	add	sp, #8
 8005fe2:	4770      	bx	lr
 8005fe4:	40021000 	.word	0x40021000

08005fe8 <HAL_TIM_Base_MspInit>:
  * @param htim_base: TIM handle pointer
  * @retval None
  */
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
  uint8_t port_num = GET_PORT_FROM_TIM(htim_base);
 8005fe8:	6803      	ldr	r3, [r0, #0]
  if(IS_RX_COUNTTIM(htim_base))  /* RX COUNT TIMER IDENTIFIED */
 8005fea:	4a13      	ldr	r2, [pc, #76]	; (8006038 <HAL_TIM_Base_MspInit+0x50>)
{
 8005fec:	b513      	push	{r0, r1, r4, lr}
  if(IS_RX_COUNTTIM(htim_base))  /* RX COUNT TIMER IDENTIFIED */
 8005fee:	4293      	cmp	r3, r2
 8005ff0:	d113      	bne.n	800601a <HAL_TIM_Base_MspInit+0x32>
  {
    /* Peripheral clock enable */
    RX_COUNTTIM_CLK_ENABLE(port_num);
 8005ff2:	2080      	movs	r0, #128	; 0x80

    /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(RX_COUNTTIM_IRQN(port_num), RX_COUNTTIMIRQ_PRIO(port_num), 0);
 8005ff4:	2415      	movs	r4, #21
    RX_COUNTTIM_CLK_ENABLE(port_num);
 8005ff6:	4a11      	ldr	r2, [pc, #68]	; (800603c <HAL_TIM_Base_MspInit+0x54>)
 8005ff8:	0280      	lsls	r0, r0, #10
 8005ffa:	6991      	ldr	r1, [r2, #24]
 8005ffc:	4301      	orrs	r1, r0
 8005ffe:	6191      	str	r1, [r2, #24]
 8006000:	6993      	ldr	r3, [r2, #24]
 8006002:	4003      	ands	r3, r0
 8006004:	9300      	str	r3, [sp, #0]
 8006006:	9b00      	ldr	r3, [sp, #0]
    HAL_NVIC_SetPriority(RX_COUNTTIM_IRQN(port_num), RX_COUNTTIMIRQ_PRIO(port_num), 0);
 8006008:	0020      	movs	r0, r4
 800600a:	2200      	movs	r2, #0
 800600c:	2101      	movs	r1, #1
 800600e:	f001 fa77 	bl	8007500 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RX_COUNTTIM_IRQN(port_num));
 8006012:	0020      	movs	r0, r4
 8006014:	f001 fa9e 	bl	8007554 <HAL_NVIC_EnableIRQ>
  }
  UNUSED(port_num);
}
 8006018:	bd13      	pop	{r0, r1, r4, pc}
  if(IS_RX_COUNTTIM(htim_base))  /* RX COUNT TIMER IDENTIFIED */
 800601a:	4a09      	ldr	r2, [pc, #36]	; (8006040 <HAL_TIM_Base_MspInit+0x58>)
 800601c:	4293      	cmp	r3, r2
 800601e:	d1fb      	bne.n	8006018 <HAL_TIM_Base_MspInit+0x30>
    RX_COUNTTIM_CLK_ENABLE(port_num);
 8006020:	2080      	movs	r0, #128	; 0x80
 8006022:	4a06      	ldr	r2, [pc, #24]	; (800603c <HAL_TIM_Base_MspInit+0x54>)
 8006024:	02c0      	lsls	r0, r0, #11
 8006026:	6991      	ldr	r1, [r2, #24]
    HAL_NVIC_SetPriority(RX_COUNTTIM_IRQN(port_num), RX_COUNTTIMIRQ_PRIO(port_num), 0);
 8006028:	2416      	movs	r4, #22
    RX_COUNTTIM_CLK_ENABLE(port_num);
 800602a:	4301      	orrs	r1, r0
 800602c:	6191      	str	r1, [r2, #24]
 800602e:	6993      	ldr	r3, [r2, #24]
 8006030:	4003      	ands	r3, r0
 8006032:	9301      	str	r3, [sp, #4]
 8006034:	9b01      	ldr	r3, [sp, #4]
 8006036:	e7e7      	b.n	8006008 <HAL_TIM_Base_MspInit+0x20>
 8006038:	40014400 	.word	0x40014400
 800603c:	40021000 	.word	0x40021000
 8006040:	40014800 	.word	0x40014800

08006044 <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
 8006044:	4770      	bx	lr

08006046 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8006046:	e7fe      	b.n	8006046 <HardFault_Handler>

08006048 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 8006048:	b510      	push	{r4, lr}
  HAL_IncTick();
 800604a:	f000 ffdf 	bl	800700c <HAL_IncTick>
  USBPD_DPM_TimerCounter();
 800604e:	f003 f91b 	bl	8009288 <USBPD_DPM_TimerCounter>
}
 8006052:	bd10      	pop	{r4, pc}

08006054 <EXTI0_1_IRQHandler>:
  * @brief  This function handles EXTI line 4_15 interrupts.
  * @param  None
  * @retval None
  */
void EXTI0_1_IRQHandler(void)
{
 8006054:	b510      	push	{r4, lr}
  HAL_GPIO_EXTI_IRQHandler(ALERT_GPIO_PIN(0));
 8006056:	2002      	movs	r0, #2
 8006058:	f001 fcf8 	bl	8007a4c <HAL_GPIO_EXTI_IRQHandler>
}
 800605c:	bd10      	pop	{r4, pc}

0800605e <EXTI2_3_IRQHandler>:
  * @brief  This function handles EXTI line 2 to 3 interrupts.
  * @param  None
  * @retval None
  */
void EXTI2_3_IRQHandler(void)
{  
 800605e:	b510      	push	{r4, lr}
  HAL_GPIO_EXTI_IRQHandler(ALERT_GPIO_PIN(1));
 8006060:	2004      	movs	r0, #4
 8006062:	f001 fcf3 	bl	8007a4c <HAL_GPIO_EXTI_IRQHandler>
  
}
 8006066:	bd10      	pop	{r4, pc}

08006068 <EXTI4_15_IRQHandler>:
  * @param  None
  * @retval None
  */
void EXTI4_15_IRQHandler(void)
{
  HAL_GPIO_EXTI_IRQHandler(USER_BUTTON_PIN);
 8006068:	2080      	movs	r0, #128	; 0x80
{
 800606a:	b510      	push	{r4, lr}
  HAL_GPIO_EXTI_IRQHandler(USER_BUTTON_PIN);
 800606c:	0180      	lsls	r0, r0, #6
 800606e:	f001 fced 	bl	8007a4c <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(SPI_NSS_PIN(0));
 8006072:	2080      	movs	r0, #128	; 0x80
 8006074:	0140      	lsls	r0, r0, #5
 8006076:	f001 fce9 	bl	8007a4c <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(SPI_NSS_PIN(1));
 800607a:	2080      	movs	r0, #128	; 0x80
 800607c:	0200      	lsls	r0, r0, #8
 800607e:	f001 fce5 	bl	8007a4c <HAL_GPIO_EXTI_IRQHandler>
}
 8006082:	bd10      	pop	{r4, pc}

08006084 <DMA1_Channel4_5_6_7_IRQHandler>:
  * @brief  This function handles DMA Channel 4 to 7 interrupts.
  * @param  None
  * @retval None
  */
void DMA1_Channel4_5_6_7_IRQHandler(void)
{
 8006084:	b510      	push	{r4, lr}
  USBPD_DMA_PORT0_IRQHandler();
 8006086:	f003 f965 	bl	8009354 <USBPD_DMA_PORT0_IRQHandler>
}
 800608a:	bd10      	pop	{r4, pc}

0800608c <TIM16_IRQHandler>:
  * @brief  This function handles TIM6 interrupt.
  * @param  None
  * @retval None
  */
void TIM16_IRQHandler(void)
{
 800608c:	b510      	push	{r4, lr}
  USBPD_RX_PORT0_COUNTTIM_IRQHandler();
 800608e:	f003 f9e9 	bl	8009464 <USBPD_RX_PORT0_COUNTTIM_IRQHandler>
}
 8006092:	bd10      	pop	{r4, pc}

08006094 <DPM_TurnOffPower.isra.0>:
/**
  * @brief  Turn Off power supply.
  * @param  PortNum The current port number
  * @retval USBPD_OK, USBPD_ERROR
  */
static USBPD_StatusTypeDef DPM_TurnOffPower(uint8_t PortNum, USBPD_PortPowerRole_TypeDef Role)
 8006094:	b510      	push	{r4, lr}
{
  USBPD_StatusTypeDef status = USBPD_OK;

  status = USBPD_PWR_IF_VBUSDisable(PortNum);
 8006096:	f000 fbb7 	bl	8006808 <USBPD_PWR_IF_VBUSDisable>
  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_OFF, 0);
 800609a:	2200      	movs	r2, #0
  status = USBPD_PWR_IF_VBUSDisable(PortNum);
 800609c:	0004      	movs	r4, r0
  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_OFF, 0);
 800609e:	0011      	movs	r1, r2
 80060a0:	2002      	movs	r0, #2
 80060a2:	f006 f97d 	bl	800c3a0 <Led_Set>
  return status;
}
 80060a6:	0020      	movs	r0, r4
 80060a8:	bd10      	pop	{r4, pc}
	...

080060ac <USBPD_DPM_UserInit>:
{
 80060ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80060ae:	b089      	sub	sp, #36	; 0x24
  Led_Init();
 80060b0:	f006 f960 	bl	800c374 <Led_Init>
          ((DPM_Settings[USBPD_PORT_0].PE_DefaultRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC),
 80060b4:	4b17      	ldr	r3, [pc, #92]	; (8006114 <USBPD_DPM_UserInit+0x68>)
  Led_Set(LED_PORT0_ROLE,
 80060b6:	2200      	movs	r2, #0
 80060b8:	7919      	ldrb	r1, [r3, #4]
 80060ba:	2304      	movs	r3, #4
 80060bc:	4019      	ands	r1, r3
 80060be:	424b      	negs	r3, r1
 80060c0:	4159      	adcs	r1, r3
 80060c2:	0010      	movs	r0, r2
 80060c4:	3104      	adds	r1, #4
 80060c6:	f006 f96b 	bl	800c3a0 <Led_Set>
  Led_Set(LED_PORT0_ROLE, LED_MODE_OFF, 0);
 80060ca:	2200      	movs	r2, #0
 80060cc:	0011      	movs	r1, r2
 80060ce:	0010      	movs	r0, r2
 80060d0:	f006 f966 	bl	800c3a0 <Led_Set>
  USBPD_PWR_IF_Init();
 80060d4:	f000 fab6 	bl	8006644 <USBPD_PWR_IF_Init>
  if(USBPD_OK != USBPD_PWR_IF_PowerResetGlobal()) return USBPD_ERROR;
 80060d8:	f000 fb68 	bl	80067ac <USBPD_PWR_IF_PowerResetGlobal>
 80060dc:	1e05      	subs	r5, r0, #0
 80060de:	d003      	beq.n	80060e8 <USBPD_DPM_UserInit+0x3c>
 80060e0:	2502      	movs	r5, #2
}
 80060e2:	0028      	movs	r0, r5
 80060e4:	b009      	add	sp, #36	; 0x24
 80060e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  osMessageQDef(MsgBox, DPM_BOX_MESSAGES_MAX, uint32_t);
 80060e8:	a801      	add	r0, sp, #4
 80060ea:	0003      	movs	r3, r0
 80060ec:	4c0a      	ldr	r4, [pc, #40]	; (8006118 <USBPD_DPM_UserInit+0x6c>)
 80060ee:	cc06      	ldmia	r4!, {r1, r2}
 80060f0:	c306      	stmia	r3!, {r1, r2}
  DPMMsgBox = osMessageCreate(osMessageQ(MsgBox), NULL);
 80060f2:	0029      	movs	r1, r5
 80060f4:	f005 f981 	bl	800b3fa <osMessageCreate>
 80060f8:	4908      	ldr	r1, [pc, #32]	; (800611c <USBPD_DPM_UserInit+0x70>)
 80060fa:	6008      	str	r0, [r1, #0]
  osThreadDef(DPM, USBPD_DPM_UserExecute, osPriorityLow, 0, 120);
 80060fc:	a803      	add	r0, sp, #12
 80060fe:	0003      	movs	r3, r0
 8006100:	ccc4      	ldmia	r4!, {r2, r6, r7}
 8006102:	c3c4      	stmia	r3!, {r2, r6, r7}
 8006104:	cc44      	ldmia	r4!, {r2, r6}
 8006106:	c344      	stmia	r3!, {r2, r6}
  if(NULL == osThreadCreate(osThread(DPM), &DPMMsgBox))
 8006108:	f005 f951 	bl	800b3ae <osThreadCreate>
 800610c:	2800      	cmp	r0, #0
 800610e:	d1e8      	bne.n	80060e2 <USBPD_DPM_UserInit+0x36>
 8006110:	e7e6      	b.n	80060e0 <USBPD_DPM_UserInit+0x34>
 8006112:	46c0      	nop			; (mov r8, r8)
 8006114:	0800c71c 	.word	0x0800c71c
 8006118:	0800c6bc 	.word	0x0800c6bc
 800611c:	200019d8 	.word	0x200019d8

08006120 <USBPD_DPM_UserTimerCounter>:
  if((DPM_Ports[PortNum].DPM_TimerSRCExtendedCapa & DPM_TIMER_READ_MSK) > 0)
 8006120:	2388      	movs	r3, #136	; 0x88
 8006122:	4343      	muls	r3, r0
 8006124:	4805      	ldr	r0, [pc, #20]	; (800613c <USBPD_DPM_UserTimerCounter+0x1c>)
 8006126:	18c0      	adds	r0, r0, r3
 8006128:	306a      	adds	r0, #106	; 0x6a
 800612a:	8803      	ldrh	r3, [r0, #0]
 800612c:	045b      	lsls	r3, r3, #17
 800612e:	d003      	beq.n	8006138 <USBPD_DPM_UserTimerCounter+0x18>
    DPM_Ports[PortNum].DPM_TimerSRCExtendedCapa--;
 8006130:	8803      	ldrh	r3, [r0, #0]
 8006132:	3b01      	subs	r3, #1
 8006134:	b29b      	uxth	r3, r3
 8006136:	8003      	strh	r3, [r0, #0]
}
 8006138:	4770      	bx	lr
 800613a:	46c0      	nop			; (mov r8, r8)
 800613c:	200002c4 	.word	0x200002c4

08006140 <USBPD_DPM_UserCableDetection>:
{
 8006140:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006142:	0007      	movs	r7, r0
 8006144:	000e      	movs	r6, r1
 8006146:	4d47      	ldr	r5, [pc, #284]	; (8006264 <USBPD_DPM_UserCableDetection+0x124>)
 8006148:	00c4      	lsls	r4, r0, #3
  switch(State)
 800614a:	2904      	cmp	r1, #4
 800614c:	d015      	beq.n	800617a <USBPD_DPM_UserCableDetection+0x3a>
 800614e:	2907      	cmp	r1, #7
 8006150:	d04a      	beq.n	80061e8 <USBPD_DPM_UserCableDetection+0xa8>
 8006152:	2902      	cmp	r1, #2
 8006154:	d164      	bne.n	8006220 <USBPD_DPM_UserCableDetection+0xe0>
    if(USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 8006156:	5d2b      	ldrb	r3, [r5, r4]
 8006158:	075b      	lsls	r3, r3, #29
 800615a:	d511      	bpl.n	8006180 <USBPD_DPM_UserCableDetection+0x40>
      if (USBPD_OK != USBPD_PWR_IF_VBUSEnable(PortNum))
 800615c:	f000 fb40 	bl	80067e0 <USBPD_PWR_IF_VBUSEnable>
 8006160:	2800      	cmp	r0, #0
 8006162:	d140      	bne.n	80061e6 <USBPD_DPM_UserCableDetection+0xa6>
 8006164:	003e      	movs	r6, r7
 8006166:	1e73      	subs	r3, r6, #1
 8006168:	419e      	sbcs	r6, r3
 800616a:	3628      	adds	r6, #40	; 0x28
      while (STUSB1602_VBUS_Valid_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_within_VALID_vrange)
 800616c:	0030      	movs	r0, r6
 800616e:	f000 fc0f 	bl	8006990 <STUSB1602_VBUS_Valid_Get>
 8006172:	2801      	cmp	r0, #1
 8006174:	d004      	beq.n	8006180 <USBPD_DPM_UserCableDetection+0x40>
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 8006176:	46c0      	nop			; (mov r8, r8)
 8006178:	e7f8      	b.n	800616c <USBPD_DPM_UserCableDetection+0x2c>
    if(USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 800617a:	5d2b      	ldrb	r3, [r5, r4]
 800617c:	075b      	lsls	r3, r3, #29
 800617e:	d422      	bmi.n	80061c6 <USBPD_DPM_UserCableDetection+0x86>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_CC : LED_PORT0_CC) , (DPM_Params[PortNum].ActiveCCIs == CC1 ? LED_MODE_BLINK_CC1 : LED_MODE_BLINK_CC2), 0);
 8006180:	192b      	adds	r3, r5, r4
 8006182:	7859      	ldrb	r1, [r3, #1]
 8006184:	2200      	movs	r2, #0
 8006186:	0789      	lsls	r1, r1, #30
 8006188:	0f89      	lsrs	r1, r1, #30
 800618a:	3901      	subs	r1, #1
 800618c:	1e4b      	subs	r3, r1, #1
 800618e:	4199      	sbcs	r1, r3
 8006190:	2003      	movs	r0, #3
 8006192:	3108      	adds	r1, #8
 8006194:	f006 f904 	bl	800c3a0 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_BLINK_VBUS, 0);
 8006198:	2200      	movs	r2, #0
 800619a:	2107      	movs	r1, #7
 800619c:	2002      	movs	r0, #2
 800619e:	f006 f8ff 	bl	800c3a0 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT0_ROLE) , ((DPM_Params[PortNum].PE_PowerRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC), 0);
 80061a2:	5d29      	ldrb	r1, [r5, r4]
 80061a4:	2200      	movs	r2, #0
 80061a6:	0749      	lsls	r1, r1, #29
 80061a8:	0fc9      	lsrs	r1, r1, #31
 80061aa:	424b      	negs	r3, r1
 80061ac:	4159      	adcs	r1, r3
 80061ae:	0010      	movs	r0, r2
 80061b0:	3104      	adds	r1, #4
 80061b2:	f006 f8f5 	bl	800c3a0 <Led_Set>
    DPM_Ports[PortNum].DPM_IsConnected = 1;
 80061b6:	2388      	movs	r3, #136	; 0x88
 80061b8:	437b      	muls	r3, r7
 80061ba:	4f2b      	ldr	r7, [pc, #172]	; (8006268 <USBPD_DPM_UserCableDetection+0x128>)
 80061bc:	18ff      	adds	r7, r7, r3
 80061be:	2301      	movs	r3, #1
 80061c0:	3764      	adds	r7, #100	; 0x64
 80061c2:	703b      	strb	r3, [r7, #0]
}
 80061c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (USBPD_OK != USBPD_PWR_IF_VBUSEnable(PortNum))
 80061c6:	f000 fb0b 	bl	80067e0 <USBPD_PWR_IF_VBUSEnable>
 80061ca:	2800      	cmp	r0, #0
 80061cc:	d10a      	bne.n	80061e4 <USBPD_DPM_UserCableDetection+0xa4>
 80061ce:	003e      	movs	r6, r7
 80061d0:	1e73      	subs	r3, r6, #1
 80061d2:	419e      	sbcs	r6, r3
 80061d4:	3628      	adds	r6, #40	; 0x28
      while (STUSB1602_VBUS_Valid_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_within_VALID_vrange)
 80061d6:	0030      	movs	r0, r6
 80061d8:	f000 fbda 	bl	8006990 <STUSB1602_VBUS_Valid_Get>
 80061dc:	2801      	cmp	r0, #1
 80061de:	d0cf      	beq.n	8006180 <USBPD_DPM_UserCableDetection+0x40>
 80061e0:	46c0      	nop			; (mov r8, r8)
 80061e2:	e7f8      	b.n	80061d6 <USBPD_DPM_UserCableDetection+0x96>
 80061e4:	e7fe      	b.n	80061e4 <USBPD_DPM_UserCableDetection+0xa4>
 80061e6:	e7fe      	b.n	80061e6 <USBPD_DPM_UserCableDetection+0xa6>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_CC : LED_PORT0_CC) , (DPM_Params[PortNum].ActiveCCIs == CC1 ? LED_MODE_BLINK_CC1 : LED_MODE_BLINK_CC2), 0);
 80061e8:	192b      	adds	r3, r5, r4
 80061ea:	7859      	ldrb	r1, [r3, #1]
 80061ec:	2200      	movs	r2, #0
 80061ee:	0789      	lsls	r1, r1, #30
 80061f0:	0f89      	lsrs	r1, r1, #30
 80061f2:	3901      	subs	r1, #1
 80061f4:	1e4b      	subs	r3, r1, #1
 80061f6:	4199      	sbcs	r1, r3
 80061f8:	2003      	movs	r0, #3
 80061fa:	3108      	adds	r1, #8
 80061fc:	f006 f8d0 	bl	800c3a0 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_BLINK_VBUS, 0);
 8006200:	0031      	movs	r1, r6
 8006202:	2200      	movs	r2, #0
 8006204:	2002      	movs	r0, #2
 8006206:	f006 f8cb 	bl	800c3a0 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT0_ROLE) , ((DPM_Params[PortNum].PE_PowerRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC), 0);
 800620a:	5d29      	ldrb	r1, [r5, r4]
            ((DPM_Settings[PortNum].PE_DefaultRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC),
 800620c:	0749      	lsls	r1, r1, #29
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT0_ROLE),
 800620e:	0fc9      	lsrs	r1, r1, #31
 8006210:	424b      	negs	r3, r1
 8006212:	4159      	adcs	r1, r3
 8006214:	2200      	movs	r2, #0
 8006216:	3104      	adds	r1, #4
 8006218:	0010      	movs	r0, r2
 800621a:	f006 f8c1 	bl	800c3a0 <Led_Set>
}
 800621e:	e7d1      	b.n	80061c4 <USBPD_DPM_UserCableDetection+0x84>
    memset(&DPM_Ports[PortNum], 0, sizeof(DPM_Ports[PortNum]));
 8006220:	2288      	movs	r2, #136	; 0x88
 8006222:	0010      	movs	r0, r2
 8006224:	4378      	muls	r0, r7
 8006226:	4b10      	ldr	r3, [pc, #64]	; (8006268 <USBPD_DPM_UserCableDetection+0x128>)
 8006228:	2100      	movs	r1, #0
 800622a:	18c0      	adds	r0, r0, r3
 800622c:	f006 f9af 	bl	800c58e <memset>
    if(USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 8006230:	5d2b      	ldrb	r3, [r5, r4]
 8006232:	075b      	lsls	r3, r3, #29
 8006234:	d505      	bpl.n	8006242 <USBPD_DPM_UserCableDetection+0x102>
      if (USBPD_OK != USBPD_PWR_IF_VBUSDisable(PortNum))
 8006236:	0038      	movs	r0, r7
 8006238:	f000 fae6 	bl	8006808 <USBPD_PWR_IF_VBUSDisable>
 800623c:	2800      	cmp	r0, #0
 800623e:	d000      	beq.n	8006242 <USBPD_DPM_UserCableDetection+0x102>
 8006240:	e7fe      	b.n	8006240 <USBPD_DPM_UserCableDetection+0x100>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_CC : LED_PORT0_CC) , LED_MODE_OFF, 0);
 8006242:	2200      	movs	r2, #0
 8006244:	2003      	movs	r0, #3
 8006246:	0011      	movs	r1, r2
 8006248:	f006 f8aa 	bl	800c3a0 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_OFF, 0);
 800624c:	2200      	movs	r2, #0
 800624e:	2002      	movs	r0, #2
 8006250:	0011      	movs	r1, r2
 8006252:	f006 f8a5 	bl	800c3a0 <Led_Set>
            ((DPM_Settings[PortNum].PE_DefaultRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC),
 8006256:	230c      	movs	r3, #12
 8006258:	437b      	muls	r3, r7
 800625a:	4f04      	ldr	r7, [pc, #16]	; (800626c <USBPD_DPM_UserCableDetection+0x12c>)
 800625c:	18ff      	adds	r7, r7, r3
 800625e:	7939      	ldrb	r1, [r7, #4]
 8006260:	e7d4      	b.n	800620c <USBPD_DPM_UserCableDetection+0xcc>
 8006262:	46c0      	nop			; (mov r8, r8)
 8006264:	20001b84 	.word	0x20001b84
 8006268:	200002c4 	.word	0x200002c4
 800626c:	0800c71c 	.word	0x0800c71c

08006270 <USBPD_DPM_HardReset>:
{
 8006270:	b570      	push	{r4, r5, r6, lr}
 8006272:	0004      	movs	r4, r0
 8006274:	000d      	movs	r5, r1
  switch(Status)
 8006276:	2a06      	cmp	r2, #6
 8006278:	d818      	bhi.n	80062ac <USBPD_DPM_HardReset+0x3c>
 800627a:	0010      	movs	r0, r2
 800627c:	f7ff fb90 	bl	80059a0 <__gnu_thumb1_case_uqi>
 8006280:	16161704 	.word	0x16161704
 8006284:	3223      	.short	0x3223
 8006286:	4a          	.byte	0x4a
 8006287:	00          	.byte	0x00
    if (USBPD_PORTPOWERROLE_SRC == CurrentRole)
 8006288:	2901      	cmp	r1, #1
 800628a:	d107      	bne.n	800629c <USBPD_DPM_HardReset+0x2c>
  * @param  PortNum The current port number
  * @retval None
  */
static void DPM_AssertRp(uint8_t PortNum)
{
  USBPD_CAD_AssertRp(PortNum);
 800628c:	0020      	movs	r0, r4
 800628e:	f7f9 ffd9 	bl	8000244 <USBPD_CAD_AssertRp>

  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT0_ROLE) , LED_MODE_BLINK_ROLE_SRC, 0);
 8006292:	2200      	movs	r2, #0
 8006294:	2104      	movs	r1, #4
 8006296:	0010      	movs	r0, r2
 8006298:	f006 f882 	bl	800c3a0 <Led_Set>
    USBPD_HW_IF_HR_Start(PortNum, CurrentRole, ACKNOWLEDGE);
 800629c:	2200      	movs	r2, #0
    USBPD_HW_IF_HR_Start(PortNum, CurrentRole, REQUEST);
 800629e:	0029      	movs	r1, r5
 80062a0:	0020      	movs	r0, r4
 80062a2:	f004 f871 	bl	800a388 <USBPD_HW_IF_HR_Start>
    DPM_TurnOffPower(PortNum, CurrentRole);
 80062a6:	0020      	movs	r0, r4
 80062a8:	f7ff fef4 	bl	8006094 <DPM_TurnOffPower.isra.0>
}
 80062ac:	bd70      	pop	{r4, r5, r6, pc}
    if (USBPD_PORTPOWERROLE_SRC == CurrentRole)
 80062ae:	2901      	cmp	r1, #1
 80062b0:	d107      	bne.n	80062c2 <USBPD_DPM_HardReset+0x52>
  USBPD_CAD_AssertRp(PortNum);
 80062b2:	0020      	movs	r0, r4
 80062b4:	f7f9 ffc6 	bl	8000244 <USBPD_CAD_AssertRp>
  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT0_ROLE) , LED_MODE_BLINK_ROLE_SRC, 0);
 80062b8:	2200      	movs	r2, #0
 80062ba:	2104      	movs	r1, #4
 80062bc:	0010      	movs	r0, r2
 80062be:	f006 f86f 	bl	800c3a0 <Led_Set>
    USBPD_HW_IF_HR_Start(PortNum, CurrentRole, REQUEST);
 80062c2:	2201      	movs	r2, #1
 80062c4:	e7eb      	b.n	800629e <USBPD_DPM_HardReset+0x2e>
    USBPD_HW_IF_HR_CheckVbusVSafe0V(PortNum, CurrentRole);
 80062c6:	0020      	movs	r0, r4
 80062c8:	f004 f8b2 	bl	800a430 <USBPD_HW_IF_HR_CheckVbusVSafe0V>
    if (CurrentRole == USBPD_PORTPOWERROLE_SNK)
 80062cc:	2d00      	cmp	r5, #0
 80062ce:	d1ed      	bne.n	80062ac <USBPD_DPM_HardReset+0x3c>
 80062d0:	1e63      	subs	r3, r4, #1
 80062d2:	419c      	sbcs	r4, r3
 80062d4:	3428      	adds	r4, #40	; 0x28
      while (STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_below_VSAFE0V_threshold)
 80062d6:	0020      	movs	r0, r4
 80062d8:	f000 fb66 	bl	80069a8 <STUSB1602_VBUS_VSAFE0V_Get>
 80062dc:	2801      	cmp	r0, #1
 80062de:	d0e5      	beq.n	80062ac <USBPD_DPM_HardReset+0x3c>
 80062e0:	46c0      	nop			; (mov r8, r8)
 80062e2:	e7f8      	b.n	80062d6 <USBPD_DPM_HardReset+0x66>
    USBPD_HW_IF_HR_End(PortNum, CurrentRole);
 80062e4:	0020      	movs	r0, r4
 80062e6:	f004 f8b5 	bl	800a454 <USBPD_HW_IF_HR_End>
  status = USBPD_PWR_IF_VBUSEnable(PortNum);
 80062ea:	0020      	movs	r0, r4
 80062ec:	f000 fa78 	bl	80067e0 <USBPD_PWR_IF_VBUSEnable>
  if(USBPD_PORTPOWERROLE_SRC == Role)
 80062f0:	2d01      	cmp	r5, #1
 80062f2:	d005      	beq.n	8006300 <USBPD_DPM_HardReset+0x90>
  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_BLINK_VBUS, 0);
 80062f4:	2200      	movs	r2, #0
 80062f6:	2107      	movs	r1, #7
 80062f8:	2002      	movs	r0, #2
 80062fa:	f006 f851 	bl	800c3a0 <Led_Set>
 80062fe:	e7d5      	b.n	80062ac <USBPD_DPM_HardReset+0x3c>
 8006300:	1e63      	subs	r3, r4, #1
 8006302:	419c      	sbcs	r4, r3
 8006304:	3428      	adds	r4, #40	; 0x28
    while (STUSB1602_VBUS_Valid_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_within_VALID_vrange)
 8006306:	0020      	movs	r0, r4
 8006308:	f000 fb42 	bl	8006990 <STUSB1602_VBUS_Valid_Get>
 800630c:	2801      	cmp	r0, #1
 800630e:	d0f1      	beq.n	80062f4 <USBPD_DPM_HardReset+0x84>
 8006310:	46c0      	nop			; (mov r8, r8)
 8006312:	e7f8      	b.n	8006306 <USBPD_DPM_HardReset+0x96>
    USBPD_HW_IF_HR_End(PortNum, CurrentRole);
 8006314:	0020      	movs	r0, r4
 8006316:	f004 f89d 	bl	800a454 <USBPD_HW_IF_HR_End>
}
 800631a:	e7c7      	b.n	80062ac <USBPD_DPM_HardReset+0x3c>

0800631c <USBPD_DPM_SetupNewPower>:
  rdoposition = DPM_Ports[PortNum].DPM_RDOPosition;
 800631c:	2288      	movs	r2, #136	; 0x88
 800631e:	4342      	muls	r2, r0
 8006320:	4b06      	ldr	r3, [pc, #24]	; (800633c <USBPD_DPM_SetupNewPower+0x20>)
{
 8006322:	b510      	push	{r4, lr}
  rdoposition = DPM_Ports[PortNum].DPM_RDOPosition;
 8006324:	189b      	adds	r3, r3, r2
 8006326:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006328:	b2d1      	uxtb	r1, r2
    status = USBPD_PWR_IF_SetProfile(PortNum, 0, 0);
 800632a:	1e0a      	subs	r2, r1, #0
  if (rdoposition > 0)
 800632c:	d003      	beq.n	8006336 <USBPD_DPM_SetupNewPower+0x1a>
  previous_rdoposition = DPM_Ports[PortNum].DPM_RDOPositionPrevious;
 800632e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    status = USBPD_PWR_IF_SetProfile(PortNum, rdoposition-1, previous_rdoposition);
 8006330:	3901      	subs	r1, #1
 8006332:	b2d2      	uxtb	r2, r2
 8006334:	b2c9      	uxtb	r1, r1
    status = USBPD_PWR_IF_SetProfile(PortNum, 0, 0);
 8006336:	f000 f991 	bl	800665c <USBPD_PWR_IF_SetProfile>
}
 800633a:	bd10      	pop	{r4, pc}
 800633c:	200002c4 	.word	0x200002c4

08006340 <USBPD_DPM_EvaluatePowerRoleSwap>:
}
 8006340:	200a      	movs	r0, #10
 8006342:	4770      	bx	lr

08006344 <USBPD_DPM_Notification>:
{
 8006344:	b510      	push	{r4, lr}
  switch(EventVal)
 8006346:	2910      	cmp	r1, #16
 8006348:	d104      	bne.n	8006354 <USBPD_DPM_Notification+0x10>
      Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_ON, 0);
 800634a:	2200      	movs	r2, #0
 800634c:	390f      	subs	r1, #15
 800634e:	2002      	movs	r0, #2
 8006350:	f006 f826 	bl	800c3a0 <Led_Set>
}
 8006354:	bd10      	pop	{r4, pc}

08006356 <USBPD_DPM_IsContractStillValid>:
}
 8006356:	2000      	movs	r0, #0
 8006358:	4770      	bx	lr
	...

0800635c <USBPD_DPM_GetDataInfo>:
{
 800635c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800635e:	0005      	movs	r5, r0
 8006360:	0016      	movs	r6, r2
 8006362:	001c      	movs	r4, r3
  switch (DataId)
 8006364:	290d      	cmp	r1, #13
 8006366:	d866      	bhi.n	8006436 <USBPD_DPM_GetDataInfo+0xda>
 8006368:	0008      	movs	r0, r1
 800636a:	f7ff fb19 	bl	80059a0 <__gnu_thumb1_case_uqi>
 800636e:	2424      	.short	0x2424
 8006370:	07162b64 	.word	0x07162b64
 8006374:	64393364 	.word	0x64393364
 8006378:	43646464 	.word	0x43646464
 800637c:	2188      	movs	r1, #136	; 0x88
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO; index++)
 800637e:	2200      	movs	r2, #0
 8006380:	434d      	muls	r5, r1
 8006382:	492e      	ldr	r1, [pc, #184]	; (800643c <USBPD_DPM_GetDataInfo+0xe0>)
 8006384:	1948      	adds	r0, r1, r5
 8006386:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8006388:	4293      	cmp	r3, r2
 800638a:	d918      	bls.n	80063be <USBPD_DPM_GetDataInfo+0x62>
 800638c:	0097      	lsls	r7, r2, #2
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSNKPDO[index];
 800638e:	19eb      	adds	r3, r5, r7
 8006390:	185b      	adds	r3, r3, r1
 8006392:	6a1b      	ldr	r3, [r3, #32]
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO; index++)
 8006394:	3201      	adds	r2, #1
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSNKPDO[index];
 8006396:	51f3      	str	r3, [r6, r7]
 8006398:	e7f5      	b.n	8006386 <USBPD_DPM_GetDataInfo+0x2a>
 800639a:	2188      	movs	r1, #136	; 0x88
 800639c:	434d      	muls	r5, r1
 800639e:	4927      	ldr	r1, [pc, #156]	; (800643c <USBPD_DPM_GetDataInfo+0xe0>)
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO; index++)
 80063a0:	2200      	movs	r2, #0
 80063a2:	186d      	adds	r5, r5, r1
 80063a4:	0029      	movs	r1, r5
 80063a6:	69cb      	ldr	r3, [r1, #28]
 80063a8:	4293      	cmp	r3, r2
 80063aa:	d908      	bls.n	80063be <USBPD_DPM_GetDataInfo+0x62>
 80063ac:	0093      	lsls	r3, r2, #2
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index];
 80063ae:	58e8      	ldr	r0, [r5, r3]
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO; index++)
 80063b0:	3201      	adds	r2, #1
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index];
 80063b2:	50f0      	str	r0, [r6, r3]
 80063b4:	e7f7      	b.n	80063a6 <USBPD_DPM_GetDataInfo+0x4a>
    USBPD_PWR_IF_GetPortPDOs(PortNum, DataId, Ptr, Size);
 80063b6:	0028      	movs	r0, r5
 80063b8:	f000 fa3a 	bl	8006830 <USBPD_PWR_IF_GetPortPDOs>
    *Size *= 4;
 80063bc:	6823      	ldr	r3, [r4, #0]
    *Size = (DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO * 4);
 80063be:	009b      	lsls	r3, r3, #2
    *Size = 0;
 80063c0:	6023      	str	r3, [r4, #0]
}
 80063c2:	e016      	b.n	80063f2 <USBPD_DPM_GetDataInfo+0x96>
    *Ptr = DPM_Ports[PortNum].DPM_RequestedVoltage;
 80063c4:	2188      	movs	r1, #136	; 0x88
 80063c6:	4369      	muls	r1, r5
 80063c8:	4d1c      	ldr	r5, [pc, #112]	; (800643c <USBPD_DPM_GetDataInfo+0xe0>)
 80063ca:	186d      	adds	r5, r5, r1
 80063cc:	6c6b      	ldr	r3, [r5, #68]	; 0x44
    *Ptr = DPM_Ports[PortNum].DPM_RequestDOMsg;
 80063ce:	6033      	str	r3, [r6, #0]
    *Size = 4;
 80063d0:	2304      	movs	r3, #4
 80063d2:	e7f5      	b.n	80063c0 <USBPD_DPM_GetDataInfo+0x64>
    *Ptr = DPM_Ports[PortNum].DPM_RequestDOMsg;
 80063d4:	2188      	movs	r1, #136	; 0x88
 80063d6:	4369      	muls	r1, r5
 80063d8:	4d18      	ldr	r5, [pc, #96]	; (800643c <USBPD_DPM_GetDataInfo+0xe0>)
 80063da:	186d      	adds	r5, r5, r1
 80063dc:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 80063de:	e7f6      	b.n	80063ce <USBPD_DPM_GetDataInfo+0x72>
      memcpy((uint8_t*)Ptr, (uint8_t *)&DPM_USER_Settings[PortNum].DPM_SRCExtendedCapa, *Size);
 80063e0:	2138      	movs	r1, #56	; 0x38
      *Size = sizeof(USBPD_SCEDB_TypeDef);
 80063e2:	2218      	movs	r2, #24
      memcpy((uint8_t*)Ptr, (uint8_t *)&DPM_USER_Settings[PortNum].DPM_SRCExtendedCapa, *Size);
 80063e4:	434d      	muls	r5, r1
 80063e6:	4916      	ldr	r1, [pc, #88]	; (8006440 <USBPD_DPM_GetDataInfo+0xe4>)
      *Size = sizeof(USBPD_SCEDB_TypeDef);
 80063e8:	601a      	str	r2, [r3, #0]
      memcpy((uint8_t*)Ptr, (uint8_t *)&DPM_USER_Settings[PortNum].DPM_SRCExtendedCapa, *Size);
 80063ea:	1869      	adds	r1, r5, r1
      memcpy((uint8_t*)Ptr, (uint8_t *)manu_info, *Size);
 80063ec:	0030      	movs	r0, r6
 80063ee:	f006 f8c5 	bl	800c57c <memcpy>
}
 80063f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 80063f4:	2188      	movs	r1, #136	; 0x88
 80063f6:	2338      	movs	r3, #56	; 0x38
 80063f8:	4369      	muls	r1, r5
 80063fa:	436b      	muls	r3, r5
 80063fc:	4d0f      	ldr	r5, [pc, #60]	; (800643c <USBPD_DPM_GetDataInfo+0xe0>)
      manu_info = (USBPD_MIDB_TypeDef*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort;
 80063fe:	001f      	movs	r7, r3
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 8006400:	186d      	adds	r5, r5, r1
 8006402:	0029      	movs	r1, r5
 8006404:	3184      	adds	r1, #132	; 0x84
      manu_info = (USBPD_MIDB_TypeDef*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort;
 8006406:	4a0e      	ldr	r2, [pc, #56]	; (8006440 <USBPD_DPM_GetDataInfo+0xe4>)
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 8006408:	7809      	ldrb	r1, [r1, #0]
      manu_info = (USBPD_MIDB_TypeDef*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort;
 800640a:	3718      	adds	r7, #24
 800640c:	18bf      	adds	r7, r7, r2
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 800640e:	2901      	cmp	r1, #1
 8006410:	d803      	bhi.n	800641a <USBPD_DPM_GetDataInfo+0xbe>
      || (DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoRef > USBPD_MANUFINFO_REF_MAX_VALUES))
 8006412:	3585      	adds	r5, #133	; 0x85
 8006414:	7828      	ldrb	r0, [r5, #0]
 8006416:	2807      	cmp	r0, #7
 8006418:	d904      	bls.n	8006424 <USBPD_DPM_GetDataInfo+0xc8>
        *Size = 4; /* VID (2) + .PID(2) */
 800641a:	2304      	movs	r3, #4
 800641c:	6023      	str	r3, [r4, #0]
      memcpy((uint8_t*)Ptr, (uint8_t *)manu_info, *Size);
 800641e:	6822      	ldr	r2, [r4, #0]
 8006420:	0039      	movs	r1, r7
 8006422:	e7e3      	b.n	80063ec <USBPD_DPM_GetDataInfo+0x90>
        if (USBPD_MANUFINFO_TARGET_PORT_CABLE_PLUG == DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget)
 8006424:	2900      	cmp	r1, #0
 8006426:	d1f8      	bne.n	800641a <USBPD_DPM_GetDataInfo+0xbe>
          *Size = 4 + strlen((char*)(DPM_USER_Settings[PortNum].DPM_ManuInfoPort.ManuString));
 8006428:	331c      	adds	r3, #28
 800642a:	1898      	adds	r0, r3, r2
 800642c:	f7ff fab0 	bl	8005990 <strlen>
 8006430:	3004      	adds	r0, #4
 8006432:	6020      	str	r0, [r4, #0]
 8006434:	e7f3      	b.n	800641e <USBPD_DPM_GetDataInfo+0xc2>
    *Size = 0;
 8006436:	2300      	movs	r3, #0
 8006438:	e7c2      	b.n	80063c0 <USBPD_DPM_GetDataInfo+0x64>
 800643a:	46c0      	nop			; (mov r8, r8)
 800643c:	200002c4 	.word	0x200002c4
 8006440:	0800c798 	.word	0x0800c798

08006444 <USBPD_DPM_SetDataInfo>:
{
 8006444:	b570      	push	{r4, r5, r6, lr}
 8006446:	0005      	movs	r5, r0
  switch (DataId)
 8006448:	1e88      	subs	r0, r1, #2
{
 800644a:	0014      	movs	r4, r2
  switch (DataId)
 800644c:	280a      	cmp	r0, #10
 800644e:	d811      	bhi.n	8006474 <USBPD_DPM_SetDataInfo+0x30>
 8006450:	f7ff faa6 	bl	80059a0 <__gnu_thumb1_case_uqi>
 8006454:	341a1106 	.word	0x341a1106
 8006458:	10584f4f 	.word	0x10584f4f
 800645c:	1010      	.short	0x1010
 800645e:	62          	.byte	0x62
 800645f:	00          	.byte	0x00
    if (Size == 4)
 8006460:	2b04      	cmp	r3, #4
 8006462:	d107      	bne.n	8006474 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_RDOPosition = *Ptr;
 8006464:	2088      	movs	r0, #136	; 0x88
 8006466:	4368      	muls	r0, r5
 8006468:	4d31      	ldr	r5, [pc, #196]	; (8006530 <USBPD_DPM_SetDataInfo+0xec>)
 800646a:	6813      	ldr	r3, [r2, #0]
 800646c:	182d      	adds	r5, r5, r0
 800646e:	642b      	str	r3, [r5, #64]	; 0x40
      DPM_Ports[PortNum].DPM_RDOPositionPrevious = *Ptr;
 8006470:	6813      	ldr	r3, [r2, #0]
 8006472:	652b      	str	r3, [r5, #80]	; 0x50
}
 8006474:	bd70      	pop	{r4, r5, r6, pc}
    if (Size == 4)
 8006476:	2b04      	cmp	r3, #4
 8006478:	d1fc      	bne.n	8006474 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_RequestedVoltage = *Ptr;
 800647a:	2088      	movs	r0, #136	; 0x88
 800647c:	4368      	muls	r0, r5
 800647e:	4d2c      	ldr	r5, [pc, #176]	; (8006530 <USBPD_DPM_SetDataInfo+0xec>)
 8006480:	6813      	ldr	r3, [r2, #0]
 8006482:	182d      	adds	r5, r5, r0
 8006484:	646b      	str	r3, [r5, #68]	; 0x44
 8006486:	e7f5      	b.n	8006474 <USBPD_DPM_SetDataInfo+0x30>
    if (Size <= (USBPD_MAX_NB_PDO * 4))
 8006488:	2b1c      	cmp	r3, #28
 800648a:	d8f3      	bhi.n	8006474 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO = (Size / 4);
 800648c:	2088      	movs	r0, #136	; 0x88
      for (index = 0; index < (Size / 4); index++)
 800648e:	2100      	movs	r1, #0
      DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO = (Size / 4);
 8006490:	4345      	muls	r5, r0
 8006492:	4827      	ldr	r0, [pc, #156]	; (8006530 <USBPD_DPM_SetDataInfo+0xec>)
 8006494:	089b      	lsrs	r3, r3, #2
 8006496:	1940      	adds	r0, r0, r5
 8006498:	61c3      	str	r3, [r0, #28]
      for (index = 0; index < (Size / 4); index++)
 800649a:	428b      	cmp	r3, r1
 800649c:	d0ea      	beq.n	8006474 <USBPD_DPM_SetDataInfo+0x30>
        DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index] = LE32(Ptr + index);
 800649e:	7862      	ldrb	r2, [r4, #1]
 80064a0:	78a6      	ldrb	r6, [r4, #2]
 80064a2:	0212      	lsls	r2, r2, #8
 80064a4:	0436      	lsls	r6, r6, #16
 80064a6:	1992      	adds	r2, r2, r6
 80064a8:	7826      	ldrb	r6, [r4, #0]
 80064aa:	008d      	lsls	r5, r1, #2
 80064ac:	1992      	adds	r2, r2, r6
 80064ae:	78e6      	ldrb	r6, [r4, #3]
      for (index = 0; index < (Size / 4); index++)
 80064b0:	3101      	adds	r1, #1
        DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index] = LE32(Ptr + index);
 80064b2:	0636      	lsls	r6, r6, #24
 80064b4:	1992      	adds	r2, r2, r6
 80064b6:	5142      	str	r2, [r0, r5]
 80064b8:	3404      	adds	r4, #4
 80064ba:	e7ee      	b.n	800649a <USBPD_DPM_SetDataInfo+0x56>
    if (Size <= (USBPD_MAX_NB_PDO * 4))
 80064bc:	2b1c      	cmp	r3, #28
 80064be:	d8d9      	bhi.n	8006474 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO = (Size / 4);
 80064c0:	2088      	movs	r0, #136	; 0x88
 80064c2:	4345      	muls	r5, r0
 80064c4:	4a1a      	ldr	r2, [pc, #104]	; (8006530 <USBPD_DPM_SetDataInfo+0xec>)
 80064c6:	089b      	lsrs	r3, r3, #2
 80064c8:	1951      	adds	r1, r2, r5
 80064ca:	63cb      	str	r3, [r1, #60]	; 0x3c
 80064cc:	3520      	adds	r5, #32
 80064ce:	009b      	lsls	r3, r3, #2
 80064d0:	18ad      	adds	r5, r5, r2
 80064d2:	18e3      	adds	r3, r4, r3
      for (index = 0; index < (Size / 4); index++)
 80064d4:	429c      	cmp	r4, r3
 80064d6:	d0cd      	beq.n	8006474 <USBPD_DPM_SetDataInfo+0x30>
        DPM_Ports[PortNum].DPM_ListOfRcvSNKPDO[index] = LE32(Ptr + index);
 80064d8:	7860      	ldrb	r0, [r4, #1]
 80064da:	78a2      	ldrb	r2, [r4, #2]
 80064dc:	0200      	lsls	r0, r0, #8
 80064de:	0412      	lsls	r2, r2, #16
 80064e0:	1880      	adds	r0, r0, r2
 80064e2:	7822      	ldrb	r2, [r4, #0]
 80064e4:	1880      	adds	r0, r0, r2
 80064e6:	78e2      	ldrb	r2, [r4, #3]
 80064e8:	3404      	adds	r4, #4
 80064ea:	0612      	lsls	r2, r2, #24
 80064ec:	1880      	adds	r0, r0, r2
 80064ee:	c501      	stmia	r5!, {r0}
 80064f0:	e7f0      	b.n	80064d4 <USBPD_DPM_SetDataInfo+0x90>
    if (Size == 4)
 80064f2:	2b04      	cmp	r3, #4
 80064f4:	d1be      	bne.n	8006474 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_RcvRequestDOMsg = *Ptr;
 80064f6:	2088      	movs	r0, #136	; 0x88
 80064f8:	4368      	muls	r0, r5
 80064fa:	4d0d      	ldr	r5, [pc, #52]	; (8006530 <USBPD_DPM_SetDataInfo+0xec>)
 80064fc:	6813      	ldr	r3, [r2, #0]
 80064fe:	182d      	adds	r5, r5, r0
 8006500:	65eb      	str	r3, [r5, #92]	; 0x5c
 8006502:	e7b7      	b.n	8006474 <USBPD_DPM_SetDataInfo+0x30>
      ext_capa = (uint8_t*)&DPM_Ports[PortNum].DPM_RcvSRCExtendedCapa;
 8006504:	2088      	movs	r0, #136	; 0x88
 8006506:	4368      	muls	r0, r5
 8006508:	4d09      	ldr	r5, [pc, #36]	; (8006530 <USBPD_DPM_SetDataInfo+0xec>)
 800650a:	306c      	adds	r0, #108	; 0x6c
 800650c:	1940      	adds	r0, r0, r5
      memcpy(ext_capa, Ptr, Size);
 800650e:	001a      	movs	r2, r3
 8006510:	0021      	movs	r1, r4
 8006512:	f006 f833 	bl	800c57c <memcpy>
    break;
 8006516:	e7ad      	b.n	8006474 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget = *temp;
 8006518:	2088      	movs	r0, #136	; 0x88
 800651a:	4368      	muls	r0, r5
 800651c:	4d04      	ldr	r5, [pc, #16]	; (8006530 <USBPD_DPM_SetDataInfo+0xec>)
 800651e:	7812      	ldrb	r2, [r2, #0]
 8006520:	182d      	adds	r5, r5, r0
 8006522:	002b      	movs	r3, r5
 8006524:	3384      	adds	r3, #132	; 0x84
 8006526:	701a      	strb	r2, [r3, #0]
      DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoRef    = *(temp + 1);
 8006528:	7863      	ldrb	r3, [r4, #1]
 800652a:	3585      	adds	r5, #133	; 0x85
 800652c:	702b      	strb	r3, [r5, #0]
}
 800652e:	e7a1      	b.n	8006474 <USBPD_DPM_SetDataInfo+0x30>
 8006530:	200002c4 	.word	0x200002c4

08006534 <USBPD_DPM_EvaluateRequest>:
{
 8006534:	b5f0      	push	{r4, r5, r6, r7, lr}
  rdo.d32 = pdhandle->DPM_RcvRequestDOMsg;
 8006536:	2488      	movs	r4, #136	; 0x88
 8006538:	4344      	muls	r4, r0
 800653a:	4b1a      	ldr	r3, [pc, #104]	; (80065a4 <USBPD_DPM_EvaluateRequest+0x70>)
{
 800653c:	b085      	sub	sp, #20
  rdo.d32 = pdhandle->DPM_RcvRequestDOMsg;
 800653e:	191c      	adds	r4, r3, r4
  pdhandle->DPM_RDOPosition = 0;
 8006540:	2300      	movs	r3, #0
  rdo.d32 = pdhandle->DPM_RcvRequestDOMsg;
 8006542:	6de5      	ldr	r5, [r4, #92]	; 0x5c
  if (USBPD_PWR_IF_SearchRequestedPDO(PortNum, rdoobjposition, &pdo.d32) != USBPD_OK)
 8006544:	af03      	add	r7, sp, #12
  rdoobjposition  = rdo.GenericRDO.ObjectPosition;
 8006546:	006e      	lsls	r6, r5, #1
 8006548:	0f76      	lsrs	r6, r6, #29
{
 800654a:	9101      	str	r1, [sp, #4]
  pdhandle->DPM_RDOPosition = 0;
 800654c:	6423      	str	r3, [r4, #64]	; 0x40
  if (USBPD_PWR_IF_SearchRequestedPDO(PortNum, rdoobjposition, &pdo.d32) != USBPD_OK)
 800654e:	003a      	movs	r2, r7
 8006550:	0031      	movs	r1, r6
 8006552:	f000 f989 	bl	8006868 <USBPD_PWR_IF_SearchRequestedPDO>
 8006556:	2800      	cmp	r0, #0
 8006558:	d001      	beq.n	800655e <USBPD_DPM_EvaluateRequest+0x2a>
      return USBPD_REJECT;
 800655a:	200c      	movs	r0, #12
 800655c:	e01f      	b.n	800659e <USBPD_DPM_EvaluateRequest+0x6a>
  switch(pdo.GenericPDO.PowerObject)
 800655e:	ab02      	add	r3, sp, #8
 8006560:	79da      	ldrb	r2, [r3, #7]
 8006562:	0992      	lsrs	r2, r2, #6
 8006564:	b2d3      	uxtb	r3, r2
 8006566:	2b00      	cmp	r3, #0
 8006568:	d1f7      	bne.n	800655a <USBPD_DPM_EvaluateRequest+0x26>
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 800656a:	200a      	movs	r0, #10
      pdomaxcurrent = pdo.SRCFixedPDO.MaxCurrentIn10mAunits;
 800656c:	883b      	ldrh	r3, [r7, #0]
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 800656e:	0007      	movs	r7, r0
      rdomaxcurrent = rdo.FixedVariableRDO.MaxOperatingCurrent10mAunits;
 8006570:	05a9      	lsls	r1, r5, #22
      rdoopcurrent  = rdo.FixedVariableRDO.OperatingCurrentIn10mAunits;
 8006572:	032d      	lsls	r5, r5, #12
 8006574:	0dad      	lsrs	r5, r5, #22
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 8006576:	436f      	muls	r7, r5
      pdomaxcurrent = pdo.SRCFixedPDO.MaxCurrentIn10mAunits;
 8006578:	059b      	lsls	r3, r3, #22
 800657a:	0d9b      	lsrs	r3, r3, #22
      rdomaxcurrent = rdo.FixedVariableRDO.MaxOperatingCurrent10mAunits;
 800657c:	0d89      	lsrs	r1, r1, #22
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 800657e:	64a7      	str	r7, [r4, #72]	; 0x48
      if(rdoopcurrent > pdomaxcurrent)
 8006580:	42ab      	cmp	r3, r5
 8006582:	d3ea      	bcc.n	800655a <USBPD_DPM_EvaluateRequest+0x26>
      if(rdomaxcurrent > pdomaxcurrent)
 8006584:	428b      	cmp	r3, r1
 8006586:	d3e8      	bcc.n	800655a <USBPD_DPM_EvaluateRequest+0x26>
  pdhandle->DPM_RequestedVoltage = pdo.SRCFixedPDO.VoltageIn50mVunits * 50;
 8006588:	2132      	movs	r1, #50	; 0x32
 800658a:	9b03      	ldr	r3, [sp, #12]
 800658c:	031b      	lsls	r3, r3, #12
 800658e:	0d9b      	lsrs	r3, r3, #22
 8006590:	434b      	muls	r3, r1
 8006592:	6463      	str	r3, [r4, #68]	; 0x44
  pdhandle->DPM_RDOPositionPrevious = pdhandle->DPM_RDOPosition;
 8006594:	6c23      	ldr	r3, [r4, #64]	; 0x40
  pdhandle->DPM_RDOPosition = rdoobjposition;
 8006596:	6426      	str	r6, [r4, #64]	; 0x40
  pdhandle->DPM_RDOPositionPrevious = pdhandle->DPM_RDOPosition;
 8006598:	6523      	str	r3, [r4, #80]	; 0x50
  *PtrPowerObject = pdo.GenericPDO.PowerObject;
 800659a:	9b01      	ldr	r3, [sp, #4]
 800659c:	701a      	strb	r2, [r3, #0]
}
 800659e:	b005      	add	sp, #20
 80065a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80065a2:	46c0      	nop			; (mov r8, r8)
 80065a4:	200002c4 	.word	0x200002c4

080065a8 <USBPD_DPM_ExtendedMessageReceived>:
}
 80065a8:	4770      	bx	lr

080065aa <USBPD_DPM_EnterErrorRecovery>:
{
 80065aa:	b510      	push	{r4, lr}
 80065ac:	0004      	movs	r4, r0
  DPM_TurnOffPower(PortNum, DPM_Params[PortNum].PE_PowerRole);
 80065ae:	f7ff fd71 	bl	8006094 <DPM_TurnOffPower.isra.0>
  USBPD_CAD_EnterErrorRecovery(PortNum);
 80065b2:	0020      	movs	r0, r4
 80065b4:	f7f9 fe4e 	bl	8000254 <USBPD_CAD_EnterErrorRecovery>
}
 80065b8:	bd10      	pop	{r4, pc}
	...

080065bc <USBPD_DPM_EvaluateDataRoleSwap>:
  if (USBPD_TRUE == DPM_USER_Settings[PortNum].PE_DataSwap)
 80065bc:	2238      	movs	r2, #56	; 0x38
 80065be:	4342      	muls	r2, r0
 80065c0:	4b06      	ldr	r3, [pc, #24]	; (80065dc <USBPD_DPM_EvaluateDataRoleSwap+0x20>)
{
 80065c2:	b510      	push	{r4, lr}
  if (USBPD_TRUE == DPM_USER_Settings[PortNum].PE_DataSwap)
 80065c4:	189b      	adds	r3, r3, r2
 80065c6:	3330      	adds	r3, #48	; 0x30
 80065c8:	789a      	ldrb	r2, [r3, #2]
  USBPD_StatusTypeDef status = USBPD_REJECT;
 80065ca:	230c      	movs	r3, #12
  if (USBPD_TRUE == DPM_USER_Settings[PortNum].PE_DataSwap)
 80065cc:	07d2      	lsls	r2, r2, #31
 80065ce:	d502      	bpl.n	80065d6 <USBPD_DPM_EvaluateDataRoleSwap+0x1a>
    STUSB16xx_HW_IF_DataRoleSwap(PortNum);
 80065d0:	f004 fe0c 	bl	800b1ec <STUSB16xx_HW_IF_DataRoleSwap>
    status = USBPD_ACCEPT;
 80065d4:	230a      	movs	r3, #10
}
 80065d6:	0018      	movs	r0, r3
 80065d8:	bd10      	pop	{r4, pc}
 80065da:	46c0      	nop			; (mov r8, r8)
 80065dc:	0800c798 	.word	0x0800c798

080065e0 <USBPD_DPM_IsPowerReady>:
{
 80065e0:	b510      	push	{r4, lr}
  return ((USBPD_OK == USBPD_PWR_IF_SupplyReady(PortNum, Vsafe)) ? USBPD_ENABLE : USBPD_DISABLE);
 80065e2:	f000 f8e5 	bl	80067b0 <USBPD_PWR_IF_SupplyReady>
 80065e6:	4243      	negs	r3, r0
 80065e8:	4158      	adcs	r0, r3
 80065ea:	b2c0      	uxtb	r0, r0
}
 80065ec:	bd10      	pop	{r4, pc}

080065ee <USBPD_DPM_RequestGetSourceCapabilityExt>:
{
 80065ee:	b510      	push	{r4, lr}
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_GET_SRC_CAPEXT, USBPD_SOPTYPE_SOP);
 80065f0:	2200      	movs	r2, #0
 80065f2:	2111      	movs	r1, #17
 80065f4:	f7fc fe34 	bl	8003260 <USBPD_PE_Request_CtrlMessage>
}
 80065f8:	bd10      	pop	{r4, pc}
	...

080065fc <USBPD_DPM_UserExecute>:
{
 80065fc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint32_t _timing = osWaitForever;
 80065fe:	2201      	movs	r2, #1
    switch (((DPM_USER_EVENT)event.value.v & 0xF))
 8006600:	250f      	movs	r5, #15
  osMessageQId  queue = *(osMessageQId *)argument;
 8006602:	6804      	ldr	r4, [r0, #0]
  uint32_t _timing = osWaitForever;
 8006604:	4252      	negs	r2, r2
    osEvent event = osMessageGet(queue, _timing);
 8006606:	a801      	add	r0, sp, #4
 8006608:	0021      	movs	r1, r4
 800660a:	f004 ff23 	bl	800b454 <osMessageGet>
    switch (((DPM_USER_EVENT)event.value.v & 0xF))
 800660e:	9802      	ldr	r0, [sp, #8]
 8006610:	4e09      	ldr	r6, [pc, #36]	; (8006638 <USBPD_DPM_UserExecute+0x3c>)
 8006612:	4028      	ands	r0, r5
 8006614:	d109      	bne.n	800662a <USBPD_DPM_UserExecute+0x2e>
      if (DPM_TIMER_ENABLE_MSK == DPM_Ports[USBPD_PORT_0].DPM_TimerSRCExtendedCapa)
 8006616:	0033      	movs	r3, r6
 8006618:	2280      	movs	r2, #128	; 0x80
 800661a:	336a      	adds	r3, #106	; 0x6a
 800661c:	8819      	ldrh	r1, [r3, #0]
 800661e:	0212      	lsls	r2, r2, #8
 8006620:	4291      	cmp	r1, r2
 8006622:	d102      	bne.n	800662a <USBPD_DPM_UserExecute+0x2e>
        DPM_Ports[USBPD_PORT_0].DPM_TimerSRCExtendedCapa = 0;
 8006624:	8018      	strh	r0, [r3, #0]
        USBPD_DPM_RequestGetSourceCapabilityExt(USBPD_PORT_0);
 8006626:	f7ff ffe2 	bl	80065ee <USBPD_DPM_RequestGetSourceCapabilityExt>
{
  uint32_t _timing = osWaitForever;
  uint32_t _current_timing;

  /* Calculate the minimum timers to wake-up DPM tasks */
  _current_timing = DPM_Ports[USBPD_PORT_0].DPM_TimerSRCExtendedCapa & DPM_TIMER_READ_MSK;
 800662a:	366a      	adds	r6, #106	; 0x6a
 800662c:	8832      	ldrh	r2, [r6, #0]
 800662e:	0452      	lsls	r2, r2, #17
 8006630:	0c52      	lsrs	r2, r2, #17
  if(_current_timing > 0)
 8006632:	d1e8      	bne.n	8006606 <USBPD_DPM_UserExecute+0xa>
  uint32_t _timing = osWaitForever;
 8006634:	3a01      	subs	r2, #1
  do{
 8006636:	e7e6      	b.n	8006606 <USBPD_DPM_UserExecute+0xa>
 8006638:	200002c4 	.word	0x200002c4

0800663c <HAL_GPIO_EXTI_Callback>:
{
 800663c:	b510      	push	{r4, lr}
  USBPD_HW_IF_EXTI_Callback(GPIO_Pin);
 800663e:	f002 fe63 	bl	8009308 <USBPD_HW_IF_EXTI_Callback>
}
 8006642:	bd10      	pop	{r4, pc}

08006644 <USBPD_PWR_IF_Init>:
{

  /* Set links to PDO values and number for Port 0 (defined in PDO arrays in H file).
   */
#if (PORT0_NB_SOURCEPDO > 0)
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.ListOfPDO = (uint32_t *) PORT0_PDO_ListSRC;
 8006644:	4b03      	ldr	r3, [pc, #12]	; (8006654 <USBPD_PWR_IF_Init+0x10>)
 8006646:	4a04      	ldr	r2, [pc, #16]	; (8006658 <USBPD_PWR_IF_Init+0x14>)
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.NumberOfPDO = PORT0_NB_SOURCEPDO;
#endif


  return USBPD_OK;
}
 8006648:	2000      	movs	r0, #0
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.ListOfPDO = (uint32_t *) PORT0_PDO_ListSRC;
 800664a:	601a      	str	r2, [r3, #0]
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.NumberOfPDO = PORT0_NB_SOURCEPDO;
 800664c:	2205      	movs	r2, #5
 800664e:	711a      	strb	r2, [r3, #4]
}
 8006650:	4770      	bx	lr
 8006652:	46c0      	nop			; (mov r8, r8)
 8006654:	200019dc 	.word	0x200019dc
 8006658:	0800c6d8 	.word	0x0800c6d8

0800665c <USBPD_PWR_IF_SetProfile>:
  * @param  Profile          Number of the required Power Data Objects
  * @param  PreviousPowerProfile  Number of the previous required Power Data Objects
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_PWR_IF_SetProfile(uint8_t PortNum, uint8_t Profile, uint8_t PreviousPowerProfile)
{
 800665c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t timeout_end;
#endif /* (PORT0_NB_SOURCEPDO >= 2)|| (PORT0_NB_SOURCEAPDO > 0) */
  USBPD_StatusTypeDef      ret = USBPD_ERROR;

  /* Check if valid port */
  if ( !USBPD_PORT_IsValid(PortNum) )
 800665e:	2800      	cmp	r0, #0
 8006660:	d141      	bne.n	80066e6 <USBPD_PWR_IF_SetProfile+0x8a>
  }

#if (PORT0_NB_SOURCEPDO >= 2)|| (PORT0_NB_SOURCEAPDO > 0)
  /* Check if profile nb is valid for this port */
  /* SRC Mode */
  if (USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 8006662:	4b4f      	ldr	r3, [pc, #316]	; (80067a0 <USBPD_PWR_IF_SetProfile+0x144>)
 8006664:	781b      	ldrb	r3, [r3, #0]
 8006666:	075b      	lsls	r3, r3, #29
 8006668:	d53d      	bpl.n	80066e6 <USBPD_PWR_IF_SetProfile+0x8a>
  {
    if (Profile >= PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO)
 800666a:	4b4e      	ldr	r3, [pc, #312]	; (80067a4 <USBPD_PWR_IF_SetProfile+0x148>)
 800666c:	791a      	ldrb	r2, [r3, #4]
 800666e:	428a      	cmp	r2, r1
 8006670:	d939      	bls.n	80066e6 <USBPD_PWR_IF_SetProfile+0x8a>
    {
      return ret;
    }
    if (0 == PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO)
 8006672:	2a00      	cmp	r2, #0
 8006674:	d037      	beq.n	80066e6 <USBPD_PWR_IF_SetProfile+0x8a>
    {
      return ret;
    }
    pdo.d32 = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO[Profile];
 8006676:	681b      	ldr	r3, [r3, #0]
 8006678:	0089      	lsls	r1, r1, #2
 800667a:	58cd      	ldr	r5, [r1, r3]

    {
      /* Case PDO is a fixed type */
      if (pdo.GenericPDO.PowerObject == USBPD_PDO_TYPE_FIXED)
 800667c:	233f      	movs	r3, #63	; 0x3f
 800667e:	0e2c      	lsrs	r4, r5, #24
 8006680:	439c      	bics	r4, r3
 8006682:	d130      	bne.n	80066e6 <USBPD_PWR_IF_SetProfile+0x8a>
      {
        vbusTargetInmv = (pdo.SRCFixedPDO.VoltageIn50mVunits * 50);
 8006684:	032d      	lsls	r5, r5, #12
  * @retval USBPD_ENABLE or USBPD_DISABLE
  */
USBPD_FunctionalState USBPD_PWR_IF_VBUSIsEnabled(uint8_t PortNum)
{
  /* Get the Status of the port */
  return USBPD_PORT_IsValid(PortNum) ? (USBPD_FunctionalState)HW_IF_PWR_VBUSIsEnabled(PortNum) : USBPD_DISABLE;
 8006686:	0020      	movs	r0, r4
        vbusTargetInmv = (pdo.SRCFixedPDO.VoltageIn50mVunits * 50);
 8006688:	0dad      	lsrs	r5, r5, #22
  return USBPD_PORT_IsValid(PortNum) ? (USBPD_FunctionalState)HW_IF_PWR_VBUSIsEnabled(PortNum) : USBPD_DISABLE;
 800668a:	f003 fe2b 	bl	800a2e4 <HW_IF_PWR_VBUSIsEnabled>
    if (USBPD_ENABLE == USBPD_PWR_IF_VBUSIsEnabled(PortNum))
 800668e:	2801      	cmp	r0, #1
 8006690:	d000      	beq.n	8006694 <USBPD_PWR_IF_SetProfile+0x38>
 8006692:	e079      	b.n	8006788 <USBPD_PWR_IF_SetProfile+0x12c>
        vbusTargetInmv = (pdo.SRCFixedPDO.VoltageIn50mVunits * 50);
 8006694:	3031      	adds	r0, #49	; 0x31
 8006696:	4345      	muls	r5, r0
      origine = (uint32_t) HW_IF_PWR_GetVoltage_from_reg(PortNum); /* store setting of previous step*/
 8006698:	0020      	movs	r0, r4
 800669a:	f003 fe02 	bl	800a2a2 <HW_IF_PWR_GetVoltage_from_reg>
 800669e:	0004      	movs	r4, r0
      if (origine != vbusTargetInmv)
 80066a0:	4285      	cmp	r5, r0
 80066a2:	d020      	beq.n	80066e6 <USBPD_PWR_IF_SetProfile+0x8a>
        if (vbusTargetInmv > origine)
 80066a4:	d921      	bls.n	80066ea <USBPD_PWR_IF_SetProfile+0x8e>
          delta_val = vbusTargetInmv - origine;
 80066a6:	1a2b      	subs	r3, r5, r0
        if ( (delta_val > 100) && (pos == 1) )
 80066a8:	2b64      	cmp	r3, #100	; 0x64
 80066aa:	d921      	bls.n	80066f0 <USBPD_PWR_IF_SetProfile+0x94>
            max = (110 * new_val)/100 ;
 80066ac:	206e      	movs	r0, #110	; 0x6e
            new_val = new_val + step;
 80066ae:	3464      	adds	r4, #100	; 0x64
            max = (110 * new_val)/100 ;
 80066b0:	2164      	movs	r1, #100	; 0x64
 80066b2:	4360      	muls	r0, r4
 80066b4:	f7ff f97e 	bl	80059b4 <__udivsi3>
 80066b8:	0007      	movs	r7, r0
            min = (90 * new_val)/100 ;
 80066ba:	205a      	movs	r0, #90	; 0x5a
 80066bc:	2164      	movs	r1, #100	; 0x64
 80066be:	4360      	muls	r0, r4
 80066c0:	f7ff f978 	bl	80059b4 <__udivsi3>
            HW_IF_PWR_SetVoltage(PortNum, new_val);
 80066c4:	b2a1      	uxth	r1, r4
            min = (90 * new_val)/100 ;
 80066c6:	0006      	movs	r6, r0
            HW_IF_PWR_SetVoltage(PortNum, new_val);
 80066c8:	2000      	movs	r0, #0
 80066ca:	f003 fd7d 	bl	800a1c8 <HW_IF_PWR_SetVoltage>
            while  (((  HW_IF_PWR_GetVoltage(PortNum)) > max ) || ((  HW_IF_PWR_GetVoltage(PortNum)) < min ))            
 80066ce:	2000      	movs	r0, #0
 80066d0:	f003 fde0 	bl	800a294 <HW_IF_PWR_GetVoltage>
 80066d4:	42b8      	cmp	r0, r7
 80066d6:	d822      	bhi.n	800671e <USBPD_PWR_IF_SetProfile+0xc2>
 80066d8:	2000      	movs	r0, #0
 80066da:	f003 fddb 	bl	800a294 <HW_IF_PWR_GetVoltage>
 80066de:	42b0      	cmp	r0, r6
 80066e0:	d31d      	bcc.n	800671e <USBPD_PWR_IF_SetProfile+0xc2>
          } while ( new_val < vbusTargetInmv);
 80066e2:	42a5      	cmp	r5, r4
 80066e4:	d8e2      	bhi.n	80066ac <USBPD_PWR_IF_SetProfile+0x50>
}
 80066e6:	2002      	movs	r0, #2
 80066e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          delta_val = origine - vbusTargetInmv;
 80066ea:	1b43      	subs	r3, r0, r5
        if ( (delta_val > 100) && (pos == 1) )
 80066ec:	2b64      	cmp	r3, #100	; 0x64
 80066ee:	d818      	bhi.n	8006722 <USBPD_PWR_IF_SetProfile+0xc6>
          HW_IF_PWR_SetVoltage(PortNum, vbusTargetInmv);
 80066f0:	b2a9      	uxth	r1, r5
 80066f2:	2000      	movs	r0, #0
 80066f4:	f003 fd68 	bl	800a1c8 <HW_IF_PWR_SetVoltage>
          HW_IF_PWR_GetVoltage_from_reg(PortNum);
 80066f8:	2000      	movs	r0, #0
 80066fa:	f003 fdd2 	bl	800a2a2 <HW_IF_PWR_GetVoltage_from_reg>
          vbusmin = 90* vbusTargetInmv /100;
 80066fe:	205a      	movs	r0, #90	; 0x5a
 8006700:	2164      	movs	r1, #100	; 0x64
 8006702:	4368      	muls	r0, r5
 8006704:	f7ff f956 	bl	80059b4 <__udivsi3>
 8006708:	0004      	movs	r4, r0
          vbusmax = 110* vbusTargetInmv / 100;
 800670a:	206e      	movs	r0, #110	; 0x6e
 800670c:	2164      	movs	r1, #100	; 0x64
 800670e:	4368      	muls	r0, r5
 8006710:	f7ff f950 	bl	80059b4 <__udivsi3>
 8006714:	0006      	movs	r6, r0
          timeout = HAL_GetTick();
 8006716:	f000 fc81 	bl	800701c <HAL_GetTick>
 800671a:	0005      	movs	r5, r0
          while  (((  HW_IF_PWR_GetVoltage_from_reg(PortNum)  ) > vbusmax) || ((  HW_IF_PWR_GetVoltage_from_reg(PortNum) ) < vbusmin))
 800671c:	e029      	b.n	8006772 <USBPD_PWR_IF_SetProfile+0x116>
 800671e:	46c0      	nop			; (mov r8, r8)
 8006720:	e7d5      	b.n	80066ce <USBPD_PWR_IF_SetProfile+0x72>
              max = (110 * new_val)/100 ;
 8006722:	206e      	movs	r0, #110	; 0x6e
              new_val = new_val - step;
 8006724:	3c64      	subs	r4, #100	; 0x64
              max = (110 * new_val)/100 ;
 8006726:	2164      	movs	r1, #100	; 0x64
 8006728:	4360      	muls	r0, r4
 800672a:	f7ff f943 	bl	80059b4 <__udivsi3>
 800672e:	0007      	movs	r7, r0
              min = (90 * new_val)/100 ;
 8006730:	205a      	movs	r0, #90	; 0x5a
 8006732:	2164      	movs	r1, #100	; 0x64
 8006734:	4360      	muls	r0, r4
 8006736:	f7ff f93d 	bl	80059b4 <__udivsi3>
              HW_IF_PWR_SetVoltage(PortNum, new_val);
 800673a:	b2a1      	uxth	r1, r4
              min = (90 * new_val)/100 ;
 800673c:	0006      	movs	r6, r0
              HW_IF_PWR_SetVoltage(PortNum, new_val);
 800673e:	2000      	movs	r0, #0
 8006740:	f003 fd42 	bl	800a1c8 <HW_IF_PWR_SetVoltage>
              while  (((  HW_IF_PWR_GetVoltage(PortNum)  ) > max ) || ((  HW_IF_PWR_GetVoltage(PortNum)) < min ))
 8006744:	2000      	movs	r0, #0
 8006746:	f003 fda5 	bl	800a294 <HW_IF_PWR_GetVoltage>
 800674a:	42b8      	cmp	r0, r7
 800674c:	d807      	bhi.n	800675e <USBPD_PWR_IF_SetProfile+0x102>
 800674e:	2000      	movs	r0, #0
 8006750:	f003 fda0 	bl	800a294 <HW_IF_PWR_GetVoltage>
 8006754:	42b0      	cmp	r0, r6
 8006756:	d302      	bcc.n	800675e <USBPD_PWR_IF_SetProfile+0x102>
            } while ( new_val > vbusTargetInmv);
 8006758:	42a5      	cmp	r5, r4
 800675a:	d3e2      	bcc.n	8006722 <USBPD_PWR_IF_SetProfile+0xc6>
 800675c:	e7c3      	b.n	80066e6 <USBPD_PWR_IF_SetProfile+0x8a>
 800675e:	46c0      	nop			; (mov r8, r8)
 8006760:	e7f0      	b.n	8006744 <USBPD_PWR_IF_SetProfile+0xe8>
            osDelay(1);
 8006762:	2001      	movs	r0, #1
 8006764:	f004 fe41 	bl	800b3ea <osDelay>
            if ((HAL_GetTick() - timeout) > timeout_end)
 8006768:	f000 fc58 	bl	800701c <HAL_GetTick>
 800676c:	1b40      	subs	r0, r0, r5
 800676e:	28fa      	cmp	r0, #250	; 0xfa
 8006770:	d8b9      	bhi.n	80066e6 <USBPD_PWR_IF_SetProfile+0x8a>
          while  (((  HW_IF_PWR_GetVoltage_from_reg(PortNum)  ) > vbusmax) || ((  HW_IF_PWR_GetVoltage_from_reg(PortNum) ) < vbusmin))
 8006772:	2000      	movs	r0, #0
 8006774:	f003 fd95 	bl	800a2a2 <HW_IF_PWR_GetVoltage_from_reg>
 8006778:	42b0      	cmp	r0, r6
 800677a:	d8f2      	bhi.n	8006762 <USBPD_PWR_IF_SetProfile+0x106>
 800677c:	2000      	movs	r0, #0
 800677e:	f003 fd90 	bl	800a2a2 <HW_IF_PWR_GetVoltage_from_reg>
 8006782:	42a0      	cmp	r0, r4
 8006784:	d3ed      	bcc.n	8006762 <USBPD_PWR_IF_SetProfile+0x106>
 8006786:	e7ae      	b.n	80066e6 <USBPD_PWR_IF_SetProfile+0x8a>
      HW_IF_PWR_SetVoltage(PortNum, 5000);
 8006788:	4907      	ldr	r1, [pc, #28]	; (80067a8 <USBPD_PWR_IF_SetProfile+0x14c>)
 800678a:	0020      	movs	r0, r4
 800678c:	f003 fd1c 	bl	800a1c8 <HW_IF_PWR_SetVoltage>
      HW_IF_PWR_GetVoltage(PortNum);
 8006790:	0020      	movs	r0, r4
 8006792:	f003 fd7f 	bl	800a294 <HW_IF_PWR_GetVoltage>
      HW_IF_PWR_SetVoltage(PortNum, 5000);
 8006796:	4904      	ldr	r1, [pc, #16]	; (80067a8 <USBPD_PWR_IF_SetProfile+0x14c>)
 8006798:	0020      	movs	r0, r4
 800679a:	f003 fd15 	bl	800a1c8 <HW_IF_PWR_SetVoltage>
 800679e:	e7a2      	b.n	80066e6 <USBPD_PWR_IF_SetProfile+0x8a>
 80067a0:	20001b84 	.word	0x20001b84
 80067a4:	200019dc 	.word	0x200019dc
 80067a8:	00001388 	.word	0x00001388

080067ac <USBPD_PWR_IF_PowerResetGlobal>:
}
 80067ac:	2000      	movs	r0, #0
 80067ae:	4770      	bx	lr

080067b0 <USBPD_PWR_IF_SupplyReady>:
{
 80067b0:	b510      	push	{r4, lr}
  if (!USBPD_PORT_IsValid(PortNum))
 80067b2:	2800      	cmp	r0, #0
 80067b4:	d10f      	bne.n	80067d6 <USBPD_PWR_IF_SupplyReady+0x26>
  if (USBPD_VSAFE_0V == Vsafe)
 80067b6:	2900      	cmp	r1, #0
 80067b8:	d107      	bne.n	80067ca <USBPD_PWR_IF_SupplyReady+0x1a>
    status = (HW_IF_PWR_GetVoltage(PortNum) < CAD_threshold_VBus? USBPD_OK: USBPD_ERROR);
 80067ba:	0008      	movs	r0, r1
 80067bc:	f003 fd6a 	bl	800a294 <HW_IF_PWR_GetVoltage>
 80067c0:	4b06      	ldr	r3, [pc, #24]	; (80067dc <USBPD_PWR_IF_SupplyReady+0x2c>)
 80067c2:	4298      	cmp	r0, r3
 80067c4:	d807      	bhi.n	80067d6 <USBPD_PWR_IF_SupplyReady+0x26>
 80067c6:	2000      	movs	r0, #0
}
 80067c8:	bd10      	pop	{r4, pc}
    status = (HW_IF_PWR_GetVoltage(PortNum) > CAD_threshold_VBus? USBPD_OK: USBPD_ERROR);
 80067ca:	f003 fd63 	bl	800a294 <HW_IF_PWR_GetVoltage>
 80067ce:	239b      	movs	r3, #155	; 0x9b
 80067d0:	009b      	lsls	r3, r3, #2
 80067d2:	4298      	cmp	r0, r3
 80067d4:	d8f7      	bhi.n	80067c6 <USBPD_PWR_IF_SupplyReady+0x16>
    status = (HW_IF_PWR_GetVoltage(PortNum) < CAD_threshold_VBus? USBPD_OK: USBPD_ERROR);
 80067d6:	2002      	movs	r0, #2
 80067d8:	e7f6      	b.n	80067c8 <USBPD_PWR_IF_SupplyReady+0x18>
 80067da:	46c0      	nop			; (mov r8, r8)
 80067dc:	0000026b 	.word	0x0000026b

080067e0 <USBPD_PWR_IF_VBUSEnable>:
{
 80067e0:	b507      	push	{r0, r1, r2, lr}
  USBPD_StatusTypeDef _status = USBPD_ERROR;
 80067e2:	2302      	movs	r3, #2
  if (USBPD_PORT_IsValid(PortNum))
 80067e4:	2800      	cmp	r0, #0
 80067e6:	d10a      	bne.n	80067fe <USBPD_PWR_IF_VBUSEnable+0x1e>
    _status = (USBPD_StatusTypeDef)HW_IF_PWR_Enable(PortNum, USBPD_ENABLE, DPM_Params[PortNum].VconnCCIs, DPM_Params[PortNum].VconnStatus, USBPD_PORTPOWERROLE_SRC);
 80067e8:	2101      	movs	r1, #1
 80067ea:	4b06      	ldr	r3, [pc, #24]	; (8006804 <USBPD_PWR_IF_VBUSEnable+0x24>)
 80067ec:	789a      	ldrb	r2, [r3, #2]
 80067ee:	9100      	str	r1, [sp, #0]
 80067f0:	0753      	lsls	r3, r2, #29
 80067f2:	0792      	lsls	r2, r2, #30
 80067f4:	0fdb      	lsrs	r3, r3, #31
 80067f6:	0f92      	lsrs	r2, r2, #30
 80067f8:	f003 fd58 	bl	800a2ac <HW_IF_PWR_Enable>
 80067fc:	0003      	movs	r3, r0
}
 80067fe:	0018      	movs	r0, r3
 8006800:	bd0e      	pop	{r1, r2, r3, pc}
 8006802:	46c0      	nop			; (mov r8, r8)
 8006804:	20001b84 	.word	0x20001b84

08006808 <USBPD_PWR_IF_VBUSDisable>:
{
 8006808:	b507      	push	{r0, r1, r2, lr}
  USBPD_StatusTypeDef _status = USBPD_ERROR;
 800680a:	2302      	movs	r3, #2
  if (USBPD_PORT_IsValid(PortNum))
 800680c:	2800      	cmp	r0, #0
 800680e:	d10b      	bne.n	8006828 <USBPD_PWR_IF_VBUSDisable+0x20>
    _status = (USBPD_StatusTypeDef)HW_IF_PWR_Enable(PortNum, USBPD_DISABLE, DPM_Params[PortNum].VconnCCIs, DPM_Params[PortNum].VconnStatus, USBPD_PORTPOWERROLE_SRC);
 8006810:	2101      	movs	r1, #1
 8006812:	4b06      	ldr	r3, [pc, #24]	; (800682c <USBPD_PWR_IF_VBUSDisable+0x24>)
 8006814:	789a      	ldrb	r2, [r3, #2]
 8006816:	9100      	str	r1, [sp, #0]
 8006818:	0753      	lsls	r3, r2, #29
 800681a:	0792      	lsls	r2, r2, #30
 800681c:	0fdb      	lsrs	r3, r3, #31
 800681e:	0f92      	lsrs	r2, r2, #30
 8006820:	0001      	movs	r1, r0
 8006822:	f003 fd43 	bl	800a2ac <HW_IF_PWR_Enable>
 8006826:	0003      	movs	r3, r0
}
 8006828:	0018      	movs	r0, r3
 800682a:	bd0e      	pop	{r1, r2, r3, pc}
 800682c:	20001b84 	.word	0x20001b84

08006830 <USBPD_PWR_IF_GetPortPDOs>:
  * @param  Ptr Pointer on address where PDO values should be written (u32 pointer)
  * @param  Size Pointer on nb of u32 written by PWR_IF (nb of PDOs)
  * @retval None
  */
void USBPD_PWR_IF_GetPortPDOs(uint8_t PortNum, USBPD_CORE_DataInfoType_TypeDef DataId, uint32_t *Ptr, uint32_t *Size)
{
 8006830:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t   nbpdo, index, nb_valid_pdo = 0;
  uint32_t   *ptpdoarray = NULL;

  /* Check if valid port */
  if (USBPD_PORT_IsValid(PortNum))
 8006832:	2800      	cmp	r0, #0
 8006834:	d10a      	bne.n	800684c <USBPD_PWR_IF_GetPortPDOs+0x1c>
    case USBPD_CORE_DATATYPE_SRC_PDO:
      nbpdo       = PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO;
      ptpdoarray  = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO;
      break;
    default:
      nbpdo = 0;
 8006836:	0006      	movs	r6, r0
    switch (DataId)
 8006838:	2900      	cmp	r1, #0
 800683a:	d102      	bne.n	8006842 <USBPD_PWR_IF_GetPortPDOs+0x12>
      nbpdo       = PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO;
 800683c:	4909      	ldr	r1, [pc, #36]	; (8006864 <USBPD_PWR_IF_GetPortPDOs+0x34>)
 800683e:	790e      	ldrb	r6, [r1, #4]
      ptpdoarray  = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO;
 8006840:	6808      	ldr	r0, [r1, #0]
 8006842:	00b4      	lsls	r4, r6, #2
 8006844:	1904      	adds	r4, r0, r4
      break;
    }

    /* Copy PDO data in output buffer */
    for (index = 0; index < nbpdo; index++)
 8006846:	42a0      	cmp	r0, r4
 8006848:	d101      	bne.n	800684e <USBPD_PWR_IF_GetPortPDOs+0x1e>
        nb_valid_pdo++;
      }
      ptpdoarray++;
    }
    /* Set nb of read PDO (nb of u32 elements); */
    *Size = nb_valid_pdo;
 800684a:	601e      	str	r6, [r3, #0]
  }
}
 800684c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800684e:	2100      	movs	r1, #0
        USPBPD_WRITE32((uint32_t *)(Ptr + nb_valid_pdo), *ptpdoarray);
 8006850:	6807      	ldr	r7, [r0, #0]
 8006852:	00cd      	lsls	r5, r1, #3
 8006854:	40ef      	lsrs	r7, r5
 8006856:	5457      	strb	r7, [r2, r1]
 8006858:	3101      	adds	r1, #1
 800685a:	2904      	cmp	r1, #4
 800685c:	d1f8      	bne.n	8006850 <USBPD_PWR_IF_GetPortPDOs+0x20>
      ptpdoarray++;
 800685e:	3004      	adds	r0, #4
 8006860:	3204      	adds	r2, #4
 8006862:	e7f0      	b.n	8006846 <USBPD_PWR_IF_GetPortPDOs+0x16>
 8006864:	200019dc 	.word	0x200019dc

08006868 <USBPD_PWR_IF_SearchRequestedPDO>:
  * @retval Status of search
  *         USBPD_OK : Src PDO found for requested DO position (output Pdo parameter is set)
  *         USBPD_FAIL : Position is not compliant with current Src PDO for this port (no corresponding PDO value)
  */
USBPD_StatusTypeDef USBPD_PWR_IF_SearchRequestedPDO(uint8_t PortNum, uint32_t RdoPosition, uint32_t *Pdo)
{
 8006868:	0003      	movs	r3, r0
 800686a:	b530      	push	{r4, r5, lr}
  if((RdoPosition == 0) || (RdoPosition > PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO))
  {
    /* Invalid PDO index */
    return USBPD_FAIL;
 800686c:	2010      	movs	r0, #16
  if((RdoPosition == 0) || (RdoPosition > PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO))
 800686e:	2900      	cmp	r1, #0
 8006870:	d00d      	beq.n	800688e <USBPD_PWR_IF_SearchRequestedPDO+0x26>
 8006872:	4c07      	ldr	r4, [pc, #28]	; (8006890 <USBPD_PWR_IF_SearchRequestedPDO+0x28>)
 8006874:	00db      	lsls	r3, r3, #3
 8006876:	18e0      	adds	r0, r4, r3
 8006878:	7905      	ldrb	r5, [r0, #4]
    return USBPD_FAIL;
 800687a:	2010      	movs	r0, #16
  if((RdoPosition == 0) || (RdoPosition > PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO))
 800687c:	428d      	cmp	r5, r1
 800687e:	d306      	bcc.n	800688e <USBPD_PWR_IF_SearchRequestedPDO+0x26>
  }

  *Pdo = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO[RdoPosition - 1];
 8006880:	4804      	ldr	r0, [pc, #16]	; (8006894 <USBPD_PWR_IF_SearchRequestedPDO+0x2c>)
 8006882:	591b      	ldr	r3, [r3, r4]
 8006884:	1809      	adds	r1, r1, r0
  return USBPD_OK;
 8006886:	2000      	movs	r0, #0
  *Pdo = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO[RdoPosition - 1];
 8006888:	0089      	lsls	r1, r1, #2
 800688a:	58cb      	ldr	r3, [r1, r3]
 800688c:	6013      	str	r3, [r2, #0]
}
 800688e:	bd30      	pop	{r4, r5, pc}
 8006890:	200019dc 	.word	0x200019dc
 8006894:	3fffffff 	.word	0x3fffffff

08006898 <STUSB1602_Driver_Init>:
  * @param  PortNum     Port number value
  * @param  I2CxHandle  External I2C handle
  * @retval None
  */
void STUSB1602_Driver_Init(uint8_t PortNum, I2C_HandleTypeDef I2CxHandle)
{
 8006898:	b084      	sub	sp, #16
 800689a:	b510      	push	{r4, lr}
 800689c:	9103      	str	r1, [sp, #12]
 800689e:	9204      	str	r2, [sp, #16]
 80068a0:	9305      	str	r3, [sp, #20]
  if (0 == PortNum)
  {
    STUSB16xx_I2CxHandle = I2CxHandle;
 80068a2:	224c      	movs	r2, #76	; 0x4c
 80068a4:	a903      	add	r1, sp, #12
  if (0 == PortNum)
 80068a6:	2800      	cmp	r0, #0
 80068a8:	d106      	bne.n	80068b8 <STUSB1602_Driver_Init+0x20>
    STUSB16xx_I2CxHandle = I2CxHandle;
 80068aa:	4804      	ldr	r0, [pc, #16]	; (80068bc <STUSB1602_Driver_Init+0x24>)
  }
  else
  {
    STUSB16xx_I2CxHandle_P1 = I2CxHandle;
 80068ac:	f005 fe66 	bl	800c57c <memcpy>
  }
}
 80068b0:	bc10      	pop	{r4}
 80068b2:	bc08      	pop	{r3}
 80068b4:	b004      	add	sp, #16
 80068b6:	4718      	bx	r3
    STUSB16xx_I2CxHandle_P1 = I2CxHandle;
 80068b8:	4801      	ldr	r0, [pc, #4]	; (80068c0 <STUSB1602_Driver_Init+0x28>)
 80068ba:	e7f7      	b.n	80068ac <STUSB1602_Driver_Init+0x14>
 80068bc:	200019e4 	.word	0x200019e4
 80068c0:	20001b34 	.word	0x20001b34

080068c4 <STUSB1602_ReadReg>:
  * @param Reg          Address of first register to be read
  * @param Size         Amount of bytes to be read
  * @retval STUSB1602_StatusTypeDef Allowed values are STUSB1602_OK, STUSB1602_ERROR, STUSB1602_BUSY, STUSB1602_TIMEOUT
  */
STUSB1602_StatusTypeDef STUSB1602_ReadReg(uint8_t* pBuffer, uint8_t Addr, uint8_t Reg, uint16_t Size)
  {
 80068c4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if (Addr == 0x29)
    {
      return STUSB1602_OK;
    }
#endif
    status = (STUSB1602_StatusTypeDef) HAL_I2C_Mem_Read(&STUSB16xx_I2CxHandle, (Addr<<1), (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size, TIMEOUT_MAX);
 80068c6:	24fa      	movs	r4, #250	; 0xfa
 80068c8:	00e4      	lsls	r4, r4, #3
 80068ca:	9301      	str	r3, [sp, #4]
 80068cc:	9000      	str	r0, [sp, #0]
 80068ce:	b292      	uxth	r2, r2
 80068d0:	0049      	lsls	r1, r1, #1
 80068d2:	9402      	str	r4, [sp, #8]
 80068d4:	2301      	movs	r3, #1
 80068d6:	4802      	ldr	r0, [pc, #8]	; (80068e0 <STUSB1602_ReadReg+0x1c>)
 80068d8:	f001 fb1a 	bl	8007f10 <HAL_I2C_Mem_Read>
    return status;
  }
 80068dc:	b004      	add	sp, #16
 80068de:	bd10      	pop	{r4, pc}
 80068e0:	200019e4 	.word	0x200019e4

080068e4 <STUSB1602_WriteReg>:
  * @param Reg          Address of first register to be write
  * @param Size         Amount of bytes to be write
  * @retval STUSB1602_StatusTypeDef Allowed values are STUSB1602_OK, STUSB1602_ERROR, STUSB1602_BUSY, STUSB1602_TIMEOUT
  */
STUSB1602_StatusTypeDef STUSB1602_WriteReg(uint8_t* pBuffer, uint8_t Addr, uint8_t Reg, uint16_t Size)
  {
 80068e4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
      return STUSB1602_OK;
    }
#endif
    STUSB1602_StatusTypeDef status = STUSB1602_OK;

    status = (STUSB1602_StatusTypeDef)HAL_I2C_Mem_Write(&STUSB16xx_I2CxHandle, (Addr<<1), (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size,
 80068e6:	24fa      	movs	r4, #250	; 0xfa
 80068e8:	00e4      	lsls	r4, r4, #3
 80068ea:	9301      	str	r3, [sp, #4]
 80068ec:	9000      	str	r0, [sp, #0]
 80068ee:	b292      	uxth	r2, r2
 80068f0:	0049      	lsls	r1, r1, #1
 80068f2:	9402      	str	r4, [sp, #8]
 80068f4:	2301      	movs	r3, #1
 80068f6:	4802      	ldr	r0, [pc, #8]	; (8006900 <STUSB1602_WriteReg+0x1c>)
 80068f8:	f001 fa50 	bl	8007d9c <HAL_I2C_Mem_Write>
                            TIMEOUT_MAX);
 
    return status;
  }
 80068fc:	b004      	add	sp, #16
 80068fe:	bd10      	pop	{r4, pc}
 8006900:	200019e4 	.word	0x200019e4

08006904 <STUSB1602_Alert_Monitoring_Get>:
  * @brief  Check registers from 0x0B to 0x12
  * @param  Addr I2C address of port controller device
  * @retval STUSB1602_ALERT_MONITORING_TypeDef 
  */ 
STUSB1602_ALERT_MONITORING_TypeDef STUSB1602_Alert_Monitoring_Get(uint8_t Addr)
{
 8006904:	b513      	push	{r0, r1, r4, lr}
 8006906:	0004      	movs	r4, r0
    STUSB1602_ALERT_MONITORING_TypeDef reg;

    STUSB1602_ReadReg(&reg.reg_0B.d8, Addr, STUSB1602_ALERT_STATUS_REG, 8); 
 8006908:	2308      	movs	r3, #8
 800690a:	220b      	movs	r2, #11
 800690c:	4668      	mov	r0, sp
 800690e:	f7ff ffd9 	bl	80068c4 <STUSB1602_ReadReg>

    return (reg);
 8006912:	2208      	movs	r2, #8
 8006914:	4669      	mov	r1, sp
 8006916:	0020      	movs	r0, r4
 8006918:	f005 fe30 	bl	800c57c <memcpy>
}
 800691c:	0020      	movs	r0, r4
 800691e:	bd16      	pop	{r1, r2, r4, pc}

08006920 <STUSB1602_CC_Detect_Alrt_Int_Mask_Set>:
  * @param  Addr I2C address of port controller device
  * @param  st Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */ 
STUSB1602_StatusTypeDef STUSB1602_CC_Detect_Alrt_Int_Mask_Set(uint8_t Addr, CC_Detect_Alrt_Int_Mask_Status_TypeDef st)
{
 8006920:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  

    STUSB1602_ALERT_STATUS_MASK_reg_TypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_ALERT_STATUS_MASK_REG, 1); 
 8006922:	ac01      	add	r4, sp, #4
{
 8006924:	0005      	movs	r5, r0
 8006926:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_ALERT_STATUS_MASK_REG, 1); 
 8006928:	2301      	movs	r3, #1
 800692a:	0001      	movs	r1, r0
 800692c:	220c      	movs	r2, #12
 800692e:	0020      	movs	r0, r4
 8006930:	f7ff ffc8 	bl	80068c4 <STUSB1602_ReadReg>

    reg.b.CC_DETECTION_STATUS_AL_MASK = st;
 8006934:	2301      	movs	r3, #1
 8006936:	2240      	movs	r2, #64	; 0x40
 8006938:	7821      	ldrb	r1, [r4, #0]
 800693a:	401e      	ands	r6, r3
 800693c:	01b6      	lsls	r6, r6, #6
 800693e:	4391      	bics	r1, r2
 8006940:	4331      	orrs	r1, r6
 8006942:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_ALERT_STATUS_MASK_REG, 1);
 8006944:	3a34      	subs	r2, #52	; 0x34
 8006946:	0029      	movs	r1, r5
 8006948:	0020      	movs	r0, r4
 800694a:	f7ff ffcb 	bl	80068e4 <STUSB1602_WriteReg>

    return status;
}
 800694e:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006950 <STUSB1602_Attach_State_Trans_Get>:
  * @brief  STUSB1602 Checks Attach State Transition Reg (Bit0 0x0D -- RC)
  * @param  Addr I2C address of port controller device
  * @retval Attach_State_Trans_TypeDef 
  */ 
Attach_State_Trans_TypeDef STUSB1602_Attach_State_Trans_Get(uint8_t Addr)
{
 8006950:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_DETECTION_STATUS_TRANS_RegTypeDef reg;

    /* Check if a Transition occurred on ATTACH_STATE bit */
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_TRANS_REG, 1); 
 8006952:	ac01      	add	r4, sp, #4
{
 8006954:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_TRANS_REG, 1); 
 8006956:	2301      	movs	r3, #1
 8006958:	220d      	movs	r2, #13
 800695a:	0020      	movs	r0, r4
 800695c:	f7ff ffb2 	bl	80068c4 <STUSB1602_ReadReg>

    return (Attach_State_Trans_TypeDef)(reg.b.ATTACH_STATE_TRANS);
 8006960:	7820      	ldrb	r0, [r4, #0]
 8006962:	07c0      	lsls	r0, r0, #31
 8006964:	0fc0      	lsrs	r0, r0, #31
}
 8006966:	bd16      	pop	{r1, r2, r4, pc}

08006968 <STUSB1602_CC_Detection_Status_Get>:
  * @brief  STUSB1602 CC Detection Status  (Register 0x0E -- RO)
  * @param  Addr I2C address of port controller device
  * @retval STUSB1602_CC_DETECTION_STATUS_RegTypeDef
  */ 
STUSB1602_CC_DETECTION_STATUS_RegTypeDef STUSB1602_CC_Detection_Status_Get(uint8_t Addr)
{
 8006968:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_DETECTION_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_REG, 1); 
 800696a:	ac01      	add	r4, sp, #4
{
 800696c:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_REG, 1); 
 800696e:	2301      	movs	r3, #1
 8006970:	220e      	movs	r2, #14
 8006972:	0020      	movs	r0, r4
 8006974:	f7ff ffa6 	bl	80068c4 <STUSB1602_ReadReg>

    return (reg);
 8006978:	7820      	ldrb	r0, [r4, #0]
}
 800697a:	bd16      	pop	{r1, r2, r4, pc}

0800697c <STUSB1602_Monitoring_Status_Trans_Reg_Get>:
  * @brief STUSB1602 checks the entire Monitoring_Status_Trans_Reg (bit0-7 0x0F -- RC)
  * @param Addr I2C address of port controller device 
  * @retval STUSB1602_MONITORING_STATUS_TRANS_RegTypeDef
  */ 
STUSB1602_MONITORING_STATUS_TRANS_RegTypeDef STUSB1602_Monitoring_Status_Trans_Reg_Get(uint8_t Addr)
{
 800697c:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_TRANS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_TRANS_REG, 1); 
 800697e:	ac01      	add	r4, sp, #4
{
 8006980:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_TRANS_REG, 1); 
 8006982:	2301      	movs	r3, #1
 8006984:	220f      	movs	r2, #15
 8006986:	0020      	movs	r0, r4
 8006988:	f7ff ff9c 	bl	80068c4 <STUSB1602_ReadReg>

    return (reg);
 800698c:	7820      	ldrb	r0, [r4, #0]
}
 800698e:	bd16      	pop	{r1, r2, r4, pc}

08006990 <STUSB1602_VBUS_Valid_Get>:
  * @brief STUSB1602 checks VBUS_Valid (bit3 0x10 -- RO)
  * @param Addr I2C address of port controller device  
  * @retval @ref VBUS_Valid_TypeDef
  */ 
VBUS_Valid_TypeDef STUSB1602_VBUS_Valid_Get(uint8_t Addr)
{
 8006990:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 8006992:	ac01      	add	r4, sp, #4
{
 8006994:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 8006996:	2301      	movs	r3, #1
 8006998:	2210      	movs	r2, #16
 800699a:	0020      	movs	r0, r4
 800699c:	f7ff ff92 	bl	80068c4 <STUSB1602_ReadReg>

    return (VBUS_Valid_TypeDef)(reg.b.VBUS_VALID);
 80069a0:	7820      	ldrb	r0, [r4, #0]
 80069a2:	0700      	lsls	r0, r0, #28
 80069a4:	0fc0      	lsrs	r0, r0, #31
}
 80069a6:	bd16      	pop	{r1, r2, r4, pc}

080069a8 <STUSB1602_VBUS_VSAFE0V_Get>:
  * @brief  STUSB1602 checks VBUS_VSAFE0V (bit2 0x10 -- RO)
  * @param Addr I2C address of port controller device   
  * @retval @ref VBUS_VSAFE0V_TypeDef
  */
VBUS_VSAFE0V_TypeDef STUSB1602_VBUS_VSAFE0V_Get(uint8_t Addr)
{
 80069a8:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 80069aa:	ac01      	add	r4, sp, #4
{
 80069ac:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 80069ae:	2301      	movs	r3, #1
 80069b0:	2210      	movs	r2, #16
 80069b2:	0020      	movs	r0, r4
 80069b4:	f7ff ff86 	bl	80068c4 <STUSB1602_ReadReg>

    return (VBUS_VSAFE0V_TypeDef)(reg.b.VBUS_VSAFE0V);
 80069b8:	7820      	ldrb	r0, [r4, #0]
 80069ba:	0740      	lsls	r0, r0, #29
 80069bc:	0fc0      	lsrs	r0, r0, #31
}
 80069be:	bd16      	pop	{r1, r2, r4, pc}

080069c0 <STUSB1602_VBUS_Presence_Get>:
  * @brief STUSB1602 checks VBUS_Presence (bit1 0x10 -- RO)
  * @param Addr I2C address of port controller device   
  * @retval VBUS_Presence_TypeDef
  */ 
VBUS_Presence_TypeDef STUSB1602_VBUS_Presence_Get(uint8_t Addr)
{
 80069c0:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 80069c2:	ac01      	add	r4, sp, #4
{
 80069c4:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 80069c6:	2301      	movs	r3, #1
 80069c8:	2210      	movs	r2, #16
 80069ca:	0020      	movs	r0, r4
 80069cc:	f7ff ff7a 	bl	80068c4 <STUSB1602_ReadReg>

    return (VBUS_Presence_TypeDef)(reg.b.VBUS_PRESENCE);
 80069d0:	7820      	ldrb	r0, [r4, #0]
 80069d2:	0780      	lsls	r0, r0, #30
 80069d4:	0fc0      	lsrs	r0, r0, #31
}
 80069d6:	bd16      	pop	{r1, r2, r4, pc}

080069d8 <STUSB1602_Sink_Power_State_Get>:
  * @brief STUSB1602 checks the Sink_Power_State mode (bit6-5 0x11 -- RO)
  * @param Addr I2C address of port controller device
  * @retval Sink_Power_State_TypeDef
  */ 
Sink_Power_State_TypeDef STUSB1602_Sink_Power_State_Get(uint8_t Addr)
{
 80069d8:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_CONNECTION_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 80069da:	ac01      	add	r4, sp, #4
{
 80069dc:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 80069de:	2301      	movs	r3, #1
 80069e0:	2211      	movs	r2, #17
 80069e2:	0020      	movs	r0, r4
 80069e4:	f7ff ff6e 	bl	80068c4 <STUSB1602_ReadReg>

    return (Sink_Power_State_TypeDef)(reg.b.SINK_POWER_STATE);
 80069e8:	7820      	ldrb	r0, [r4, #0]
 80069ea:	0640      	lsls	r0, r0, #25
 80069ec:	0f80      	lsrs	r0, r0, #30
}
 80069ee:	bd16      	pop	{r1, r2, r4, pc}

080069f0 <STUSB1602_TypeC_FSM_State_Get>:
  * @brief STUSB1602 checks the TypeC_FSM_State (bit4-0 0x11 -- RO)
  * @param Addr I2C address of port controller device
  * @retval TypeC_FSM_State_TypeDef
  */
TypeC_FSM_State_TypeDef STUSB1602_TypeC_FSM_State_Get(uint8_t Addr)
{
 80069f0:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_CONNECTION_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 80069f2:	ac01      	add	r4, sp, #4
{
 80069f4:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 80069f6:	2301      	movs	r3, #1
 80069f8:	2211      	movs	r2, #17
 80069fa:	0020      	movs	r0, r4
 80069fc:	f7ff ff62 	bl	80068c4 <STUSB1602_ReadReg>

    return (TypeC_FSM_State_TypeDef)(reg.b.TYPEC_FSM_STATE);
 8006a00:	7820      	ldrb	r0, [r4, #0]
 8006a02:	06c0      	lsls	r0, r0, #27
 8006a04:	0ec0      	lsrs	r0, r0, #27
}
 8006a06:	bd16      	pop	{r1, r2, r4, pc}

08006a08 <STUSB1602_Hard_Fault_Trans_Status_Get>:
  * @brief STUSB1602 checks the entire HW_FAULT_STATUS_TRANS reg (bit7 0x12 -- RC)
  * @param Addr Address of the used port
  * @retval     STUSB1602_HW_FAULT_STATUS_TRANS_RegTypeDef
  */
STUSB1602_HW_FAULT_STATUS_TRANS_RegTypeDef STUSB1602_Hard_Fault_Trans_Status_Get(uint8_t Addr)
{
 8006a08:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_HW_FAULT_STATUS_TRANS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_HW_FAULT_STATUS_TRANS_REG, 1); 
 8006a0a:	ac01      	add	r4, sp, #4
{
 8006a0c:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_HW_FAULT_STATUS_TRANS_REG, 1); 
 8006a0e:	2301      	movs	r3, #1
 8006a10:	2212      	movs	r2, #18
 8006a12:	0020      	movs	r0, r4
 8006a14:	f7ff ff56 	bl	80068c4 <STUSB1602_ReadReg>

    return (reg);
 8006a18:	7820      	ldrb	r0, [r4, #0]
}  
 8006a1a:	bd16      	pop	{r1, r2, r4, pc}

08006a1c <STUSB1602_Current_Advertised_Set>:
  * @param Addr I2C address of port controller device
  * @param curr_cap Current Capability Advertised  of the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_Current_Advertised_Set(uint8_t Addr, Current_Capability_Advertised_TypeDef curr_cap)
{
 8006a1c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006a1e:	ac01      	add	r4, sp, #4
{
 8006a20:	0005      	movs	r5, r0
 8006a22:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006a24:	2301      	movs	r3, #1
 8006a26:	0001      	movs	r1, r0
 8006a28:	2218      	movs	r2, #24
 8006a2a:	0020      	movs	r0, r4
 8006a2c:	f7ff ff4a 	bl	80068c4 <STUSB1602_ReadReg>
    
    reg.b.CC_CURRENT_ADVERTISED = curr_cap;
 8006a30:	233f      	movs	r3, #63	; 0x3f
 8006a32:	7821      	ldrb	r1, [r4, #0]
 8006a34:	01b6      	lsls	r6, r6, #6
 8006a36:	4019      	ands	r1, r3
 8006a38:	4331      	orrs	r1, r6
 8006a3a:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006a3c:	3b3e      	subs	r3, #62	; 0x3e
 8006a3e:	0029      	movs	r1, r5
 8006a40:	2218      	movs	r2, #24
 8006a42:	0020      	movs	r0, r4
 8006a44:	f7ff ff4e 	bl	80068e4 <STUSB1602_WriteReg>
       
    return status;
}
 8006a48:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006a4a <STUSB1602_SNK_Disconnect_Mode_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st SNK_DISCONNECT_MODE to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_SNK_Disconnect_Mode_Status_Set(uint8_t Addr, SNK_Disconnect_Mode_TypeDef st)
{
 8006a4a:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006a4c:	ac01      	add	r4, sp, #4
{
 8006a4e:	0005      	movs	r5, r0
 8006a50:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006a52:	2301      	movs	r3, #1
 8006a54:	0001      	movs	r1, r0
 8006a56:	2218      	movs	r2, #24
 8006a58:	0020      	movs	r0, r4
 8006a5a:	f7ff ff33 	bl	80068c4 <STUSB1602_ReadReg>

    reg.b.SNK_DISCONNECT_MODE = st;
 8006a5e:	2301      	movs	r3, #1
 8006a60:	2220      	movs	r2, #32
 8006a62:	7821      	ldrb	r1, [r4, #0]
 8006a64:	401e      	ands	r6, r3
 8006a66:	0176      	lsls	r6, r6, #5
 8006a68:	4391      	bics	r1, r2
 8006a6a:	4331      	orrs	r1, r6
 8006a6c:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006a6e:	3a08      	subs	r2, #8
 8006a70:	0029      	movs	r1, r5
 8006a72:	0020      	movs	r0, r4
 8006a74:	f7ff ff36 	bl	80068e4 <STUSB1602_WriteReg>

    return status;
}
 8006a78:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006a7a <STUSB1602_VCONN_Discharge_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st VCONN_Discharge_Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Discharge_Status_Set(uint8_t Addr, VCONN_Discharge_Status_TypeDef st)
{
 8006a7a:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006a7c:	ac01      	add	r4, sp, #4
{
 8006a7e:	0005      	movs	r5, r0
 8006a80:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006a82:	2301      	movs	r3, #1
 8006a84:	0001      	movs	r1, r0
 8006a86:	2218      	movs	r2, #24
 8006a88:	0020      	movs	r0, r4
 8006a8a:	f7ff ff1b 	bl	80068c4 <STUSB1602_ReadReg>
    
    reg.b.CC_VCONN_DISCHARGE_EN = st;
 8006a8e:	2301      	movs	r3, #1
 8006a90:	2210      	movs	r2, #16
 8006a92:	7821      	ldrb	r1, [r4, #0]
 8006a94:	401e      	ands	r6, r3
 8006a96:	0136      	lsls	r6, r6, #4
 8006a98:	4391      	bics	r1, r2
 8006a9a:	4331      	orrs	r1, r6
 8006a9c:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006a9e:	3208      	adds	r2, #8
 8006aa0:	0029      	movs	r1, r5
 8006aa2:	0020      	movs	r0, r4
 8006aa4:	f7ff ff1e 	bl	80068e4 <STUSB1602_WriteReg>
       
    return status;
}
 8006aa8:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006aaa <STUSB1602_Data_Role_Swap_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */ 
STUSB1602_StatusTypeDef STUSB1602_Data_Role_Swap_Status_Set(uint8_t Addr, Data_Role_Swap_TypeDef st)
{
 8006aaa:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 8006aac:	ac01      	add	r4, sp, #4
{
 8006aae:	0005      	movs	r5, r0
 8006ab0:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 8006ab2:	2301      	movs	r3, #1
 8006ab4:	0001      	movs	r1, r0
 8006ab6:	2218      	movs	r2, #24
 8006ab8:	0020      	movs	r0, r4
 8006aba:	f7ff ff03 	bl	80068c4 <STUSB1602_ReadReg>
    
    reg.b.DR_SWAP_EN = st;
 8006abe:	2301      	movs	r3, #1
 8006ac0:	2208      	movs	r2, #8
 8006ac2:	7821      	ldrb	r1, [r4, #0]
 8006ac4:	401e      	ands	r6, r3
 8006ac6:	00f6      	lsls	r6, r6, #3
 8006ac8:	4391      	bics	r1, r2
 8006aca:	4331      	orrs	r1, r6
 8006acc:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006ace:	3210      	adds	r2, #16
 8006ad0:	0029      	movs	r1, r5
 8006ad2:	0020      	movs	r0, r4
 8006ad4:	f7ff ff06 	bl	80068e4 <STUSB1602_WriteReg>
    
    return status;
}
 8006ad8:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006ada <STUSB1602_Power_Role_Swap_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */ 
STUSB1602_StatusTypeDef STUSB1602_Power_Role_Swap_Status_Set(uint8_t Addr, Power_Role_Swap_TypeDef st)
{
 8006ada:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 8006adc:	ac01      	add	r4, sp, #4
{
 8006ade:	0005      	movs	r5, r0
 8006ae0:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 8006ae2:	2301      	movs	r3, #1
 8006ae4:	0001      	movs	r1, r0
 8006ae6:	2218      	movs	r2, #24
 8006ae8:	0020      	movs	r0, r4
 8006aea:	f7ff feeb 	bl	80068c4 <STUSB1602_ReadReg>
    
    reg.b.PR_SWAP_EN = st;
 8006aee:	2301      	movs	r3, #1
 8006af0:	2204      	movs	r2, #4
 8006af2:	7821      	ldrb	r1, [r4, #0]
 8006af4:	401e      	ands	r6, r3
 8006af6:	00b6      	lsls	r6, r6, #2
 8006af8:	4391      	bics	r1, r2
 8006afa:	4331      	orrs	r1, r6
 8006afc:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006afe:	3214      	adds	r2, #20
 8006b00:	0029      	movs	r1, r5
 8006b02:	0020      	movs	r0, r4
 8006b04:	f7ff feee 	bl	80068e4 <STUSB1602_WriteReg>
    
    return status;
}
 8006b08:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006b0a <STUSB1602_VCONN_Supply_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st VCONN_Supply_Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Supply_Status_Set(uint8_t Addr, VCONN_Supply_Status_TypeDef st)
{
 8006b0a:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006b0c:	ac01      	add	r4, sp, #4
{
 8006b0e:	0005      	movs	r5, r0
 8006b10:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006b12:	2301      	movs	r3, #1
 8006b14:	0001      	movs	r1, r0
 8006b16:	2218      	movs	r2, #24
 8006b18:	0020      	movs	r0, r4
 8006b1a:	f7ff fed3 	bl	80068c4 <STUSB1602_ReadReg>
    
    reg.b.CC_VCONN_SUPPLY_EN = st;
 8006b1e:	2301      	movs	r3, #1
 8006b20:	7821      	ldrb	r1, [r4, #0]
 8006b22:	401e      	ands	r6, r3
 8006b24:	4399      	bics	r1, r3
 8006b26:	4331      	orrs	r1, r6
 8006b28:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006b2a:	2218      	movs	r2, #24
 8006b2c:	0029      	movs	r1, r5
 8006b2e:	0020      	movs	r0, r4
 8006b30:	f7ff fed8 	bl	80068e4 <STUSB1602_WriteReg>
       
    return status;
}
 8006b34:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006b36 <STUSB1602_VCONN_Switch_Current_Limit_Set>:
  * @param Addr I2C address of port controller device
  * @param curr_lim Current limit value to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Switch_Current_Limit_Set(uint8_t Addr, VCONN_Switch_Current_Limit_TypeDef curr_lim)
{
 8006b36:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_CC_VCONN_SWITCH_CTRL_RegTypeDef reg; 
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_VCONN_SWITCH_CTRL_REG, 1); 
 8006b38:	ac01      	add	r4, sp, #4
{
 8006b3a:	0005      	movs	r5, r0
 8006b3c:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_VCONN_SWITCH_CTRL_REG, 1); 
 8006b3e:	2301      	movs	r3, #1
 8006b40:	0001      	movs	r1, r0
 8006b42:	221e      	movs	r2, #30
 8006b44:	0020      	movs	r0, r4
 8006b46:	f7ff febd 	bl	80068c4 <STUSB1602_ReadReg>
  
    reg.b.CC_VCONN_SWITCH_ILIM = curr_lim;
 8006b4a:	230f      	movs	r3, #15
 8006b4c:	7821      	ldrb	r1, [r4, #0]
 8006b4e:	401e      	ands	r6, r3
 8006b50:	4399      	bics	r1, r3
 8006b52:	4331      	orrs	r1, r6
 8006b54:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_VCONN_SWITCH_CTRL_REG, 1);
 8006b56:	3b0e      	subs	r3, #14
 8006b58:	0029      	movs	r1, r5
 8006b5a:	221e      	movs	r2, #30
 8006b5c:	0020      	movs	r0, r4
 8006b5e:	f7ff fec1 	bl	80068e4 <STUSB1602_WriteReg>

    return status;
}
 8006b62:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006b64 <STUSB1602_Type_C_Control_Set>:
  * @param Addr I2C address of port controller device
  * @param Ctrl Control to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_Type_C_Control_Set(uint8_t Addr, Type_C_CTRL_TypeDef Ctrl)
{
 8006b64:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_CC_MODE_CTRL_RegTypeDef reg; 
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_MODE_CTRL_REG, 1); 
 8006b66:	ac01      	add	r4, sp, #4
{
 8006b68:	0005      	movs	r5, r0
 8006b6a:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_MODE_CTRL_REG, 1); 
 8006b6c:	2301      	movs	r3, #1
 8006b6e:	0001      	movs	r1, r0
 8006b70:	221f      	movs	r2, #31
 8006b72:	0020      	movs	r0, r4
 8006b74:	f7ff fea6 	bl	80068c4 <STUSB1602_ReadReg>
  
    reg.b.TYPEC_CTRL = Ctrl;
 8006b78:	230f      	movs	r3, #15
 8006b7a:	7821      	ldrb	r1, [r4, #0]
 8006b7c:	0136      	lsls	r6, r6, #4
 8006b7e:	4019      	ands	r1, r3
 8006b80:	4331      	orrs	r1, r6
 8006b82:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_MODE_CTRL_REG, 1);
 8006b84:	3b0e      	subs	r3, #14
 8006b86:	0029      	movs	r1, r5
 8006b88:	221f      	movs	r2, #31
 8006b8a:	0020      	movs	r0, r4
 8006b8c:	f7ff feaa 	bl	80068e4 <STUSB1602_WriteReg>

    return status;
}
 8006b90:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006b92 <STUSB1602_VCONN_Monitor_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st Power mode to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Monitor_Status_Set(uint8_t Addr, VCONN_Monitoring_TypeDef st)
{
 8006b92:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VCONN_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006b94:	ac01      	add	r4, sp, #4
{
 8006b96:	0005      	movs	r5, r0
 8006b98:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006b9a:	2301      	movs	r3, #1
 8006b9c:	0001      	movs	r1, r0
 8006b9e:	2220      	movs	r2, #32
 8006ba0:	0020      	movs	r0, r4
 8006ba2:	f7ff fe8f 	bl	80068c4 <STUSB1602_ReadReg>
  
    reg.b.VCONN_MONITORING_EN = st;
 8006ba6:	237f      	movs	r3, #127	; 0x7f
 8006ba8:	7821      	ldrb	r1, [r4, #0]
 8006baa:	01f6      	lsls	r6, r6, #7
 8006bac:	4019      	ands	r1, r3
 8006bae:	4331      	orrs	r1, r6
 8006bb0:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1);
 8006bb2:	3b7e      	subs	r3, #126	; 0x7e
 8006bb4:	0029      	movs	r1, r5
 8006bb6:	2220      	movs	r2, #32
 8006bb8:	0020      	movs	r0, r4
 8006bba:	f7ff fe93 	bl	80068e4 <STUSB1602_WriteReg>

    return status;
}
 8006bbe:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006bc0 <STUSB1602_VCONN_UVLO_Thresh_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param thr Power mode to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_UVLO_Thresh_Status_Set(uint8_t Addr, VCONN_UVLO_Threshold_TypeDef thr)
{
 8006bc0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VCONN_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006bc2:	ac01      	add	r4, sp, #4
{
 8006bc4:	0005      	movs	r5, r0
 8006bc6:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006bc8:	2301      	movs	r3, #1
 8006bca:	0001      	movs	r1, r0
 8006bcc:	2220      	movs	r2, #32
 8006bce:	0020      	movs	r0, r4
 8006bd0:	f7ff fe78 	bl	80068c4 <STUSB1602_ReadReg>
  
    reg.b.VCONN_UVLO_THRESHOLD = thr;
 8006bd4:	2301      	movs	r3, #1
 8006bd6:	2240      	movs	r2, #64	; 0x40
 8006bd8:	7821      	ldrb	r1, [r4, #0]
 8006bda:	401e      	ands	r6, r3
 8006bdc:	01b6      	lsls	r6, r6, #6
 8006bde:	4391      	bics	r1, r2
 8006be0:	4331      	orrs	r1, r6
 8006be2:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1);
 8006be4:	3a20      	subs	r2, #32
 8006be6:	0029      	movs	r1, r5
 8006be8:	0020      	movs	r0, r4
 8006bea:	f7ff fe7b 	bl	80068e4 <STUSB1602_WriteReg>

    return status;
}
 8006bee:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006bf0 <STUSB1602_VBUS_Select_Status_Get>:
  * @brief STUSB1602 checks the VBUS_SELECT (bit7:0 0x21 -- R/W)
  * @param Addr I2C address of port controller device
  * @retval uint16_t 
  */   
uint16_t STUSB1602_VBUS_Select_Status_Get(uint8_t Addr)
{
 8006bf0:	b513      	push	{r0, r1, r4, lr}
    uint8_t reg; /* first default value = 50 */
    uint16_t DAC_mV=0;
#ifndef __VVAR     
    STUSB1602_ReadReg(&reg, Addr, STUSB1602_VBUS_SELECT_REG, 1);
 8006bf2:	466b      	mov	r3, sp
 8006bf4:	1ddc      	adds	r4, r3, #7
{
 8006bf6:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg, Addr, STUSB1602_VBUS_SELECT_REG, 1);
 8006bf8:	2301      	movs	r3, #1
 8006bfa:	2221      	movs	r2, #33	; 0x21
 8006bfc:	0020      	movs	r0, r4
 8006bfe:	f7ff fe61 	bl	80068c4 <STUSB1602_ReadReg>
#else
    STUSB1602_ReadReg_P1(&reg, Addr+1, STUSB1602_VBUS_SELECT_REG, 1);
#endif
    DAC_mV=(uint16_t)(reg*100);
 8006c02:	2364      	movs	r3, #100	; 0x64
 8006c04:	7820      	ldrb	r0, [r4, #0]
 8006c06:	4358      	muls	r0, r3
    
    return DAC_mV;
}
 8006c08:	bd16      	pop	{r1, r2, r4, pc}
	...

08006c0c <STUSB1602_VBUS_Select_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param mV The value (expressed in mV) to set the internal reference DAC
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_Select_Status_Set(uint8_t Addr, uint16_t mV)
{
 8006c0c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8006c0e:	0004      	movs	r4, r0
 8006c10:	0008      	movs	r0, r1
    
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    uint8_t reg; /* first default value = 50 */     
    
    reg =(uint8_t)(mV/100);
 8006c12:	2164      	movs	r1, #100	; 0x64
 8006c14:	f7fe fece 	bl	80059b4 <__udivsi3>
 8006c18:	466b      	mov	r3, sp
    real_val[k] = reg;
 8006c1a:	4907      	ldr	r1, [pc, #28]	; (8006c38 <STUSB1602_VBUS_Select_Status_Set+0x2c>)
    reg =(uint8_t)(mV/100);
 8006c1c:	b2c2      	uxtb	r2, r0
    real_val[k] = reg;
 8006c1e:	4d07      	ldr	r5, [pc, #28]	; (8006c3c <STUSB1602_VBUS_Select_Status_Set+0x30>)
    reg =(uint8_t)(mV/100);
 8006c20:	1dd8      	adds	r0, r3, #7
    real_val[k] = reg;
 8006c22:	780b      	ldrb	r3, [r1, #0]
    reg =(uint8_t)(mV/100);
 8006c24:	7002      	strb	r2, [r0, #0]
    real_val[k] = reg;
 8006c26:	54ea      	strb	r2, [r5, r3]
      
    k++;
 8006c28:	3301      	adds	r3, #1
 8006c2a:	700b      	strb	r3, [r1, #0]
#ifdef __VVAR
    STUSB1602_WriteReg_P1(&reg, Addr+1, STUSB1602_VBUS_SELECT_REG, 1);
#endif
    status = STUSB1602_WriteReg(&reg, Addr, STUSB1602_VBUS_SELECT_REG, 1);
 8006c2c:	2221      	movs	r2, #33	; 0x21
 8006c2e:	2301      	movs	r3, #1
 8006c30:	0021      	movs	r1, r4
 8006c32:	f7ff fe57 	bl	80068e4 <STUSB1602_WriteReg>
             
    return status;
}
 8006c36:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8006c38:	20001a30 	.word	0x20001a30
 8006c3c:	20001a31 	.word	0x20001a31

08006c40 <STUSB1602_VBUS_VShift_High_Set>:
  * @param Addr I2C address of port controller device
  * @param Set The VShift_High value >= 5% (expressed in %) to set the high threshold value  
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_VShift_High_Set(uint8_t Addr, uint8_t Set)
{
 8006c40:	b573      	push	{r0, r1, r4, r5, r6, lr}
    
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VBUS_RANGE_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006c42:	ac01      	add	r4, sp, #4
{
 8006c44:	0005      	movs	r5, r0
 8006c46:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006c48:	2301      	movs	r3, #1
 8006c4a:	0001      	movs	r1, r0
 8006c4c:	2222      	movs	r2, #34	; 0x22
 8006c4e:	0020      	movs	r0, r4
 8006c50:	f7ff fe38 	bl	80068c4 <STUSB1602_ReadReg>
  
    reg.b.VBUS_VSHIFT_HIGH = (Set - 5);
 8006c54:	230f      	movs	r3, #15
 8006c56:	7821      	ldrb	r1, [r4, #0]
 8006c58:	3e05      	subs	r6, #5
 8006c5a:	0136      	lsls	r6, r6, #4
 8006c5c:	4019      	ands	r1, r3
 8006c5e:	4331      	orrs	r1, r6
 8006c60:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1);
 8006c62:	3b0e      	subs	r3, #14
 8006c64:	0029      	movs	r1, r5
 8006c66:	2222      	movs	r2, #34	; 0x22
 8006c68:	0020      	movs	r0, r4
 8006c6a:	f7ff fe3b 	bl	80068e4 <STUSB1602_WriteReg>
        
    return status;
}
 8006c6e:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006c70 <STUSB1602_VBUS_VShift_Low_Set>:
  * @param Addr I2C address of port controller device
  * @param Set The VShift_Low value <=5% (expressed in %) to set the low threshold value
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_VShift_Low_Set(uint8_t Addr, int8_t Set)
{
 8006c70:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8006c72:	000c      	movs	r4, r1
    Set = (Set>0) ? -Set : Set;
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VBUS_RANGE_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006c74:	ad01      	add	r5, sp, #4
{
 8006c76:	0006      	movs	r6, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006c78:	0001      	movs	r1, r0
 8006c7a:	2301      	movs	r3, #1
 8006c7c:	0028      	movs	r0, r5
 8006c7e:	2222      	movs	r2, #34	; 0x22
 8006c80:	f7ff fe20 	bl	80068c4 <STUSB1602_ReadReg>
  
    reg.b.VBUS_VSHIFT_LOW = (-Set - 5);
 8006c84:	220f      	movs	r2, #15
    Set = (Set>0) ? -Set : Set;
 8006c86:	17e3      	asrs	r3, r4, #31
 8006c88:	18e4      	adds	r4, r4, r3
 8006c8a:	405c      	eors	r4, r3
    reg.b.VBUS_VSHIFT_LOW = (-Set - 5);
 8006c8c:	782b      	ldrb	r3, [r5, #0]
 8006c8e:	3c05      	subs	r4, #5
 8006c90:	4393      	bics	r3, r2
 8006c92:	4014      	ands	r4, r2
 8006c94:	431c      	orrs	r4, r3
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1);
 8006c96:	0031      	movs	r1, r6
 8006c98:	0028      	movs	r0, r5
 8006c9a:	2301      	movs	r3, #1
 8006c9c:	3213      	adds	r2, #19
    reg.b.VBUS_VSHIFT_LOW = (-Set - 5);
 8006c9e:	702c      	strb	r4, [r5, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1);
 8006ca0:	f7ff fe20 	bl	80068e4 <STUSB1602_WriteReg>
        
    return status;
}
 8006ca4:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006ca6 <STUSB1602_SW_RESET_Set>:
  * @param Addr I2C address of port controller device
  * @param Rst Enable or Disable of the SW RST function
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_SW_RESET_Set(uint8_t Addr, SW_RESET_TypeDef Rst)
{  
 8006ca6:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
    STUSB1602_RESET_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_RESET_CTRL_REG, 1); 
 8006ca8:	ac01      	add	r4, sp, #4
{  
 8006caa:	0005      	movs	r5, r0
 8006cac:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_RESET_CTRL_REG, 1); 
 8006cae:	2301      	movs	r3, #1
 8006cb0:	0001      	movs	r1, r0
 8006cb2:	2223      	movs	r2, #35	; 0x23
 8006cb4:	0020      	movs	r0, r4
 8006cb6:	f7ff fe05 	bl	80068c4 <STUSB1602_ReadReg>
  
    reg.b.SW_RESET_EN = Rst;
 8006cba:	2301      	movs	r3, #1
 8006cbc:	7821      	ldrb	r1, [r4, #0]
 8006cbe:	401e      	ands	r6, r3
 8006cc0:	4399      	bics	r1, r3
 8006cc2:	4331      	orrs	r1, r6
 8006cc4:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_RESET_CTRL_REG, 1);
 8006cc6:	2223      	movs	r2, #35	; 0x23
 8006cc8:	0029      	movs	r1, r5
 8006cca:	0020      	movs	r0, r4
 8006ccc:	f7ff fe0a 	bl	80068e4 <STUSB1602_WriteReg>
             
    return status;
}
 8006cd0:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006cd2 <STUSB1602_Pwr_Acc_Detect_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_Pwr_Acc_Detect_Set(uint8_t Addr, Pwr_Acc_Detect_TypeDef st)
{    
 8006cd2:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
   STUSB1602_CC_POWERED_ACCESSORY_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_POWERED_ACCESSORY_CTRL_REG, 1);
 8006cd4:	ac01      	add	r4, sp, #4
{    
 8006cd6:	0005      	movs	r5, r0
 8006cd8:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_POWERED_ACCESSORY_CTRL_REG, 1);
 8006cda:	2301      	movs	r3, #1
 8006cdc:	0001      	movs	r1, r0
 8006cde:	2224      	movs	r2, #36	; 0x24
 8006ce0:	0020      	movs	r0, r4
 8006ce2:	f7ff fdef 	bl	80068c4 <STUSB1602_ReadReg>
  
   reg.b.PWR_ACC_DETECT_EN = st;    
 8006ce6:	2301      	movs	r3, #1
 8006ce8:	7821      	ldrb	r1, [r4, #0]
 8006cea:	401e      	ands	r6, r3
 8006cec:	4399      	bics	r1, r3
 8006cee:	4331      	orrs	r1, r6
 8006cf0:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_POWERED_ACCESSORY_CTRL_REG, 1);
 8006cf2:	2224      	movs	r2, #36	; 0x24
 8006cf4:	0029      	movs	r1, r5
 8006cf6:	0020      	movs	r0, r4
 8006cf8:	f7ff fdf4 	bl	80068e4 <STUSB1602_WriteReg>
             
   return status;
}
 8006cfc:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006cfe <STUSB1602_VBUS_Discharge_Time_to_0V_Set>:
  * @param Addr I2C address of port controller device
  * @param tim  VBUS discharge time in msec
  * @retval STUSB1602_StatusTypeDef
  */
STUSB1602_StatusTypeDef STUSB1602_VBUS_Discharge_Time_to_0V_Set(uint8_t Addr, uint16_t tim)
{
 8006cfe:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8006d00:	000e      	movs	r6, r1
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_DISCHARGE_TIME_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006d02:	ac01      	add	r4, sp, #4
{
 8006d04:	0005      	movs	r5, r0
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006d06:	2301      	movs	r3, #1
 8006d08:	2225      	movs	r2, #37	; 0x25
 8006d0a:	0001      	movs	r1, r0
 8006d0c:	0020      	movs	r0, r4
 8006d0e:	f7ff fdd9 	bl	80068c4 <STUSB1602_ReadReg>
   
   reg.b.VBUS_DISCHARGE_TIME_TO_0V = (uint8_t)(tim/84);
 8006d12:	0030      	movs	r0, r6
 8006d14:	2154      	movs	r1, #84	; 0x54
 8006d16:	f7fe fe4d 	bl	80059b4 <__udivsi3>
 8006d1a:	220f      	movs	r2, #15
 8006d1c:	0103      	lsls	r3, r0, #4
 8006d1e:	7820      	ldrb	r0, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1); 
 8006d20:	0029      	movs	r1, r5
   reg.b.VBUS_DISCHARGE_TIME_TO_0V = (uint8_t)(tim/84);
 8006d22:	4010      	ands	r0, r2
 8006d24:	4318      	orrs	r0, r3
 8006d26:	7020      	strb	r0, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1); 
 8006d28:	2301      	movs	r3, #1
 8006d2a:	3216      	adds	r2, #22
 8006d2c:	0020      	movs	r0, r4
 8006d2e:	f7ff fdd9 	bl	80068e4 <STUSB1602_WriteReg>
    
   return status;
}
 8006d32:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006d34 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>:
  * @param Addr I2C address of port controller device
  * @param tim VBUS discharge time in msec
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_Discharge_Time_to_PDO_Set(uint8_t Addr, uint16_t tim)
{
 8006d34:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8006d36:	000e      	movs	r6, r1
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_DISCHARGE_TIME_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006d38:	ac01      	add	r4, sp, #4
{
 8006d3a:	0005      	movs	r5, r0
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006d3c:	2301      	movs	r3, #1
 8006d3e:	2225      	movs	r2, #37	; 0x25
 8006d40:	0001      	movs	r1, r0
 8006d42:	0020      	movs	r0, r4
 8006d44:	f7ff fdbe 	bl	80068c4 <STUSB1602_ReadReg>
   
   reg.b.VBUS_DISCHARGE_TIME_TO_PDO = (uint8_t)(tim/20);
 8006d48:	0030      	movs	r0, r6
 8006d4a:	2114      	movs	r1, #20
 8006d4c:	f7fe fe32 	bl	80059b4 <__udivsi3>
 8006d50:	220f      	movs	r2, #15
 8006d52:	0003      	movs	r3, r0
 8006d54:	7820      	ldrb	r0, [r4, #0]
 8006d56:	4013      	ands	r3, r2
 8006d58:	4390      	bics	r0, r2
 8006d5a:	4318      	orrs	r0, r3
 8006d5c:	7020      	strb	r0, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1); 
 8006d5e:	0029      	movs	r1, r5
 8006d60:	2301      	movs	r3, #1
 8006d62:	3216      	adds	r2, #22
 8006d64:	0020      	movs	r0, r4
 8006d66:	f7ff fdbd 	bl	80068e4 <STUSB1602_WriteReg>
    
   return status;
}
 8006d6a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006d6c <STUSB1602_VBUS_Discharge_State_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set
  * @retval STUSB1602_StatusTypeDef 
  */
STUSB1602_StatusTypeDef STUSB1602_VBUS_Discharge_State_Set(uint8_t Addr, VBUS_Discharge_State_TypeDef st)
{    
 8006d6c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_DISCHARGE_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1); 
 8006d6e:	ac01      	add	r4, sp, #4
{    
 8006d70:	0005      	movs	r5, r0
 8006d72:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1); 
 8006d74:	2301      	movs	r3, #1
 8006d76:	0001      	movs	r1, r0
 8006d78:	2226      	movs	r2, #38	; 0x26
 8006d7a:	0020      	movs	r0, r4
 8006d7c:	f7ff fda2 	bl	80068c4 <STUSB1602_ReadReg>
   
   reg.b.VBUS_DISCHARGE_EN = st;
 8006d80:	237f      	movs	r3, #127	; 0x7f
 8006d82:	7821      	ldrb	r1, [r4, #0]
 8006d84:	01f6      	lsls	r6, r6, #7
 8006d86:	4019      	ands	r1, r3
 8006d88:	4331      	orrs	r1, r6
 8006d8a:	7021      	strb	r1, [r4, #0]
#ifdef __VVAR
   STUSB1602_WriteReg_P1(&reg.d8, Addr+1, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1);
#endif
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1);
 8006d8c:	3b7e      	subs	r3, #126	; 0x7e
 8006d8e:	0029      	movs	r1, r5
 8006d90:	2226      	movs	r2, #38	; 0x26
 8006d92:	0020      	movs	r0, r4
 8006d94:	f7ff fda6 	bl	80068e4 <STUSB1602_WriteReg>
   
   return status;   
}
 8006d98:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006d9a <STUSB1602_Power_Mode_Set>:
  * @param Addr I2C address of port controller device
  * @param Pwr Power mode to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_Power_Mode_Set(uint8_t Addr, Power_Mode_TypeDef Pwr)
{
 8006d9a:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_MODE_CTRL_RegTypeDef reg; 
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MODE_CTRL_REG, 1); 
 8006d9c:	ac01      	add	r4, sp, #4
{
 8006d9e:	0005      	movs	r5, r0
 8006da0:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MODE_CTRL_REG, 1); 
 8006da2:	2301      	movs	r3, #1
 8006da4:	0001      	movs	r1, r0
 8006da6:	2228      	movs	r2, #40	; 0x28
 8006da8:	0020      	movs	r0, r4
 8006daa:	f7ff fd8b 	bl	80068c4 <STUSB1602_ReadReg>
  
    reg.b.POWER_MODE = Pwr;
 8006dae:	2307      	movs	r3, #7
 8006db0:	7821      	ldrb	r1, [r4, #0]
 8006db2:	401e      	ands	r6, r3
 8006db4:	4399      	bics	r1, r3
 8006db6:	4331      	orrs	r1, r6
 8006db8:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_MODE_CTRL_REG, 1);
 8006dba:	3b06      	subs	r3, #6
 8006dbc:	0029      	movs	r1, r5
 8006dbe:	2228      	movs	r2, #40	; 0x28
 8006dc0:	0020      	movs	r0, r4
 8006dc2:	f7ff fd8f 	bl	80068e4 <STUSB1602_WriteReg>
             
    return status;
}
 8006dc6:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006dc8 <STUSB1602_NVM_OK_Get>:
  * @brief It checks if NVM is loaded correctly (bit0:1 0x2F -- R)
  * @param Addr I2C address of port controller device
  * @retval NVM_OK_TypeDef 
  */  
NVM_OK_TypeDef STUSB1602_NVM_OK_Get(uint8_t Addr)
{
 8006dc8:	b513      	push	{r0, r1, r4, lr}
   STUSB1602_DEVICE_CUT_RegTypeDef reg;
        
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006dca:	ac01      	add	r4, sp, #4
{
 8006dcc:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006dce:	2301      	movs	r3, #1
 8006dd0:	222f      	movs	r2, #47	; 0x2f
 8006dd2:	0020      	movs	r0, r4
 8006dd4:	f7ff fd76 	bl	80068c4 <STUSB1602_ReadReg>
      
    return (NVM_OK_TypeDef)(reg.b.Reserved_0_2);
 8006dd8:	7820      	ldrb	r0, [r4, #0]
 8006dda:	0780      	lsls	r0, r0, #30
 8006ddc:	0f80      	lsrs	r0, r0, #30
}
 8006dde:	bd16      	pop	{r1, r2, r4, pc}

08006de0 <STUSB1602_DEVICE_CUT_Get>:
  * @brief It gets the cut number (bit2:4 0x2F -- R)
  * @param Addr I2C address of port controller device
  * @retval DEVICE_CUT_TypeDef 
  */ 
DEVICE_CUT_TypeDef STUSB1602_DEVICE_CUT_Get(uint8_t Addr)
{
 8006de0:	b513      	push	{r0, r1, r4, lr}
   STUSB1602_DEVICE_CUT_RegTypeDef reg;
        
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006de2:	ac01      	add	r4, sp, #4
{
 8006de4:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006de6:	2301      	movs	r3, #1
 8006de8:	222f      	movs	r2, #47	; 0x2f
 8006dea:	0020      	movs	r0, r4
 8006dec:	f7ff fd6a 	bl	80068c4 <STUSB1602_ReadReg>
      
    return (DEVICE_CUT_TypeDef)(reg.b.DEVICE_CUT);
 8006df0:	7820      	ldrb	r0, [r4, #0]
 8006df2:	06c0      	lsls	r0, r0, #27
 8006df4:	0f40      	lsrs	r0, r0, #29
}
 8006df6:	bd16      	pop	{r1, r2, r4, pc}

08006df8 <STUSB1602_VDD_OVLO_Threshold_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VDD_OVLO_Threshold_Set(uint8_t Addr, VDD_OVLO_Threshold_TypeDef st)
{      
 8006df8:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006dfa:	ac01      	add	r4, sp, #4
{      
 8006dfc:	0005      	movs	r5, r0
 8006dfe:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006e00:	2301      	movs	r3, #1
 8006e02:	0001      	movs	r1, r0
 8006e04:	222e      	movs	r2, #46	; 0x2e
 8006e06:	0020      	movs	r0, r4
 8006e08:	f7ff fd5c 	bl	80068c4 <STUSB1602_ReadReg>
   
   reg.b.VDD_OVLO_DISABLE = st;
 8006e0c:	2301      	movs	r3, #1
 8006e0e:	2240      	movs	r2, #64	; 0x40
 8006e10:	7821      	ldrb	r1, [r4, #0]
 8006e12:	401e      	ands	r6, r3
 8006e14:	01b6      	lsls	r6, r6, #6
 8006e16:	4391      	bics	r1, r2
 8006e18:	4331      	orrs	r1, r6
 8006e1a:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006e1c:	3a12      	subs	r2, #18
 8006e1e:	0029      	movs	r1, r5
 8006e20:	0020      	movs	r0, r4
 8006e22:	f7ff fd5f 	bl	80068e4 <STUSB1602_WriteReg>
     
   return status;  
}
 8006e26:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006e28 <STUSB1602_VBUS_Range_State_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_Range_State_Set(uint8_t Addr, VBUS_Range_State_TypeDef st)
{      
 8006e28:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006e2a:	ac01      	add	r4, sp, #4
{      
 8006e2c:	0005      	movs	r5, r0
 8006e2e:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006e30:	2301      	movs	r3, #1
 8006e32:	0001      	movs	r1, r0
 8006e34:	222e      	movs	r2, #46	; 0x2e
 8006e36:	0020      	movs	r0, r4
 8006e38:	f7ff fd44 	bl	80068c4 <STUSB1602_ReadReg>
   
   reg.b.VBUS_RANGE_DISABLE = st;
 8006e3c:	2301      	movs	r3, #1
 8006e3e:	2210      	movs	r2, #16
 8006e40:	7821      	ldrb	r1, [r4, #0]
 8006e42:	401e      	ands	r6, r3
 8006e44:	0136      	lsls	r6, r6, #4
 8006e46:	4391      	bics	r1, r2
 8006e48:	4331      	orrs	r1, r6
 8006e4a:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006e4c:	321e      	adds	r2, #30
 8006e4e:	0029      	movs	r1, r5
 8006e50:	0020      	movs	r0, r4
 8006e52:	f7ff fd47 	bl	80068e4 <STUSB1602_WriteReg>
     
   return status;  
}
 8006e56:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006e58 <STUSB1602_VBUS_VSAFE0V_Threshold_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_VSAFE0V_Threshold_Set(uint8_t Addr, VBUS_VSAFE0V_Threshold_TypeDef st)
{      
 8006e58:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006e5a:	ac01      	add	r4, sp, #4
{      
 8006e5c:	0005      	movs	r5, r0
 8006e5e:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006e60:	2301      	movs	r3, #1
 8006e62:	0001      	movs	r1, r0
 8006e64:	222e      	movs	r2, #46	; 0x2e
 8006e66:	0020      	movs	r0, r4
 8006e68:	f7ff fd2c 	bl	80068c4 <STUSB1602_ReadReg>
   
   reg.b.VBUS_VSAFE0V_THRESHOLD = st;
 8006e6c:	2103      	movs	r1, #3
 8006e6e:	2306      	movs	r3, #6
 8006e70:	400e      	ands	r6, r1
 8006e72:	7821      	ldrb	r1, [r4, #0]
 8006e74:	0076      	lsls	r6, r6, #1
 8006e76:	4399      	bics	r1, r3
 8006e78:	4331      	orrs	r1, r6
 8006e7a:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006e7c:	3b05      	subs	r3, #5
 8006e7e:	0029      	movs	r1, r5
 8006e80:	222e      	movs	r2, #46	; 0x2e
 8006e82:	0020      	movs	r0, r4
 8006e84:	f7ff fd2e 	bl	80068e4 <STUSB1602_WriteReg>
     
   return status;  
}
 8006e88:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006e8a <STUSB1602_VDD_UVLO_Threshold_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VDD_UVLO_Threshold_Set(uint8_t Addr, VDD_UVLO_Threshold_TypeDef st)
{      
 8006e8a:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006e8c:	ac01      	add	r4, sp, #4
{      
 8006e8e:	0005      	movs	r5, r0
 8006e90:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006e92:	2301      	movs	r3, #1
 8006e94:	0001      	movs	r1, r0
 8006e96:	222e      	movs	r2, #46	; 0x2e
 8006e98:	0020      	movs	r0, r4
 8006e9a:	f7ff fd13 	bl	80068c4 <STUSB1602_ReadReg>
   
   reg.b.VDD_UVLO_DISABLE = st;
 8006e9e:	2301      	movs	r3, #1
 8006ea0:	7821      	ldrb	r1, [r4, #0]
 8006ea2:	401e      	ands	r6, r3
 8006ea4:	4399      	bics	r1, r3
 8006ea6:	4331      	orrs	r1, r6
 8006ea8:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006eaa:	222e      	movs	r2, #46	; 0x2e
 8006eac:	0029      	movs	r1, r5
 8006eae:	0020      	movs	r0, r4
 8006eb0:	f7ff fd18 	bl	80068e4 <STUSB1602_WriteReg>
     
   return status;  
}
 8006eb4:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006eb6 <STUSB1602_Type_C_Command>:
  * @param Addr I2C address of port controller device
  * @param Ctrl Control to be set
  * @retval STUSB1602_StatusTypeDef
  */
STUSB1602_StatusTypeDef STUSB1602_Type_C_Command(uint8_t Addr, Type_C_CTRL_TypeDef Ctrl)
{
 8006eb6:	b510      	push	{r4, lr}
    STUSB1602_StatusTypeDef ret = STUSB1602_Type_C_Control_Set(Addr, Ctrl); /* register */
 8006eb8:	f7ff fe54 	bl	8006b64 <STUSB1602_Type_C_Control_Set>
    return timeout > 0 ? ret : STUSB1602_TIMEOUT;
#else
    return ret;
#endif /* _DEBUG_ACK_ENABLE */

}
 8006ebc:	bd10      	pop	{r4, pc}
	...

08006ec0 <USBPD_BSP_LED_Set>:
  * @param  Value: value to set the led on or off.
  * @retval None
  */
  void USBPD_BSP_LED_Set(USBPD_BSP_Led_TypeDef Led, uint8_t Value)
  {
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, Value ? GPIO_PIN_RESET : GPIO_PIN_SET);
 8006ec0:	230c      	movs	r3, #12
 8006ec2:	424a      	negs	r2, r1
 8006ec4:	414a      	adcs	r2, r1
 8006ec6:	4358      	muls	r0, r3
  {
 8006ec8:	b510      	push	{r4, lr}
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, Value ? GPIO_PIN_RESET : GPIO_PIN_SET);
 8006eca:	4c04      	ldr	r4, [pc, #16]	; (8006edc <USBPD_BSP_LED_Set+0x1c>)
 8006ecc:	b2d2      	uxtb	r2, r2
 8006ece:	1823      	adds	r3, r4, r0
 8006ed0:	8899      	ldrh	r1, [r3, #4]
 8006ed2:	5900      	ldr	r0, [r0, r4]
 8006ed4:	f000 fdb0 	bl	8007a38 <HAL_GPIO_WritePin>
  }
 8006ed8:	bd10      	pop	{r4, pc}
 8006eda:	46c0      	nop			; (mov r8, r8)
 8006edc:	20000000 	.word	0x20000000

08006ee0 <USBPD_BSP_LED_On>:
  * @retval None
  */  
  
  void USBPD_BSP_LED_On(USBPD_BSP_Led_TypeDef Led)
  {
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_RESET);
 8006ee0:	230c      	movs	r3, #12
 8006ee2:	4358      	muls	r0, r3
  {
 8006ee4:	b510      	push	{r4, lr}
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_RESET);
 8006ee6:	4c04      	ldr	r4, [pc, #16]	; (8006ef8 <USBPD_BSP_LED_On+0x18>)
 8006ee8:	2200      	movs	r2, #0
 8006eea:	1823      	adds	r3, r4, r0
 8006eec:	8899      	ldrh	r1, [r3, #4]
 8006eee:	5900      	ldr	r0, [r0, r4]
 8006ef0:	f000 fda2 	bl	8007a38 <HAL_GPIO_WritePin>
  }
 8006ef4:	bd10      	pop	{r4, pc}
 8006ef6:	46c0      	nop			; (mov r8, r8)
 8006ef8:	20000000 	.word	0x20000000

08006efc <USBPD_BSP_LED_Off>:
  * @retval None
  */  
  
  void USBPD_BSP_LED_Off(USBPD_BSP_Led_TypeDef Led)
  {
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_SET);
 8006efc:	230c      	movs	r3, #12
 8006efe:	4358      	muls	r0, r3
  {
 8006f00:	b510      	push	{r4, lr}
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_SET);
 8006f02:	4c04      	ldr	r4, [pc, #16]	; (8006f14 <USBPD_BSP_LED_Off+0x18>)
 8006f04:	2201      	movs	r2, #1
 8006f06:	1823      	adds	r3, r4, r0
 8006f08:	8899      	ldrh	r1, [r3, #4]
 8006f0a:	5900      	ldr	r0, [r0, r4]
 8006f0c:	f000 fd94 	bl	8007a38 <HAL_GPIO_WritePin>
  }
 8006f10:	bd10      	pop	{r4, pc}
 8006f12:	46c0      	nop			; (mov r8, r8)
 8006f14:	20000000 	.word	0x20000000

08006f18 <USBPD_BSP_LED_Init>:
  {
 8006f18:	b530      	push	{r4, r5, lr}
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8006f1a:	2301      	movs	r3, #1
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006f1c:	2400      	movs	r4, #0
 8006f1e:	250c      	movs	r5, #12
  {
 8006f20:	b087      	sub	sp, #28
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8006f22:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006f24:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;    
 8006f26:	9404      	str	r4, [sp, #16]
 8006f28:	002a      	movs	r2, r5
 8006f2a:	4362      	muls	r2, r4
        GPIO_InitStruct.Pin = USBPD_BSP_LEDs[led].GPIO_Pin;
 8006f2c:	4b07      	ldr	r3, [pc, #28]	; (8006f4c <USBPD_BSP_LED_Init+0x34>)
 8006f2e:	1899      	adds	r1, r3, r2
 8006f30:	8889      	ldrh	r1, [r1, #4]
        HAL_GPIO_Init(USBPD_BSP_LEDs[led].GPIOx, &GPIO_InitStruct);
 8006f32:	58d0      	ldr	r0, [r2, r3]
        GPIO_InitStruct.Pin = USBPD_BSP_LEDs[led].GPIO_Pin;
 8006f34:	9101      	str	r1, [sp, #4]
        HAL_GPIO_Init(USBPD_BSP_LEDs[led].GPIOx, &GPIO_InitStruct);
 8006f36:	a901      	add	r1, sp, #4
 8006f38:	f000 fcbc 	bl	80078b4 <HAL_GPIO_Init>
        USBPD_BSP_LED_Off((USBPD_BSP_Led_TypeDef)led);
 8006f3c:	b260      	sxtb	r0, r4
 8006f3e:	3401      	adds	r4, #1
 8006f40:	f7ff ffdc 	bl	8006efc <USBPD_BSP_LED_Off>
    for(led=0;led<USBPD_BSP_LEDn;led++)
 8006f44:	2c04      	cmp	r4, #4
 8006f46:	d1ef      	bne.n	8006f28 <USBPD_BSP_LED_Init+0x10>
  }
 8006f48:	b007      	add	sp, #28
 8006f4a:	bd30      	pop	{r4, r5, pc}
 8006f4c:	20000000 	.word	0x20000000

08006f50 <USBPD_BSP_LED_Toggle>:
  * @retval None
  */ 
  
  void USBPD_BSP_LED_Toggle(USBPD_BSP_Led_TypeDef Led)
  {
    HAL_GPIO_TogglePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin);
 8006f50:	230c      	movs	r3, #12
 8006f52:	4358      	muls	r0, r3
  {
 8006f54:	b510      	push	{r4, lr}
    HAL_GPIO_TogglePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin);
 8006f56:	4a03      	ldr	r2, [pc, #12]	; (8006f64 <USBPD_BSP_LED_Toggle+0x14>)
 8006f58:	1813      	adds	r3, r2, r0
 8006f5a:	8899      	ldrh	r1, [r3, #4]
 8006f5c:	5880      	ldr	r0, [r0, r2]
 8006f5e:	f000 fd71 	bl	8007a44 <HAL_GPIO_TogglePin>
  }
 8006f62:	bd10      	pop	{r4, pc}
 8006f64:	20000000 	.word	0x20000000

08006f68 <SystemInit>:
  */
void SystemInit(void)
{
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001U;
 8006f68:	2101      	movs	r1, #1
 8006f6a:	4b11      	ldr	r3, [pc, #68]	; (8006fb0 <SystemInit+0x48>)
#if defined (STM32F051x8) || defined (STM32F058x8)
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE and MCOSEL[2:0] bits */
  RCC->CFGR &= (uint32_t)0xF8FFB80CU;
#else
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */
  RCC->CFGR &= (uint32_t)0x08FFB80CU;
 8006f6c:	4811      	ldr	r0, [pc, #68]	; (8006fb4 <SystemInit+0x4c>)
  RCC->CR |= (uint32_t)0x00000001U;
 8006f6e:	681a      	ldr	r2, [r3, #0]
 8006f70:	430a      	orrs	r2, r1
 8006f72:	601a      	str	r2, [r3, #0]
  RCC->CFGR &= (uint32_t)0x08FFB80CU;
 8006f74:	685a      	ldr	r2, [r3, #4]
 8006f76:	4002      	ands	r2, r0
 8006f78:	605a      	str	r2, [r3, #4]
#endif /* STM32F051x8 or STM32F058x8 */
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFFU;
 8006f7a:	681a      	ldr	r2, [r3, #0]
 8006f7c:	480e      	ldr	r0, [pc, #56]	; (8006fb8 <SystemInit+0x50>)
 8006f7e:	4002      	ands	r2, r0
 8006f80:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFFU;
 8006f82:	681a      	ldr	r2, [r3, #0]
 8006f84:	480d      	ldr	r0, [pc, #52]	; (8006fbc <SystemInit+0x54>)
 8006f86:	4002      	ands	r2, r0
 8006f88:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  RCC->CFGR &= (uint32_t)0xFFC0FFFFU;
 8006f8a:	685a      	ldr	r2, [r3, #4]
 8006f8c:	480c      	ldr	r0, [pc, #48]	; (8006fc0 <SystemInit+0x58>)
 8006f8e:	4002      	ands	r2, r0

  /* Reset PREDIV[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0U;
 8006f90:	200f      	movs	r0, #15
  RCC->CFGR &= (uint32_t)0xFFC0FFFFU;
 8006f92:	605a      	str	r2, [r3, #4]
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0U;
 8006f94:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8006f96:	4382      	bics	r2, r0
 8006f98:	62da      	str	r2, [r3, #44]	; 0x2c

#if defined (STM32F072xB) || defined (STM32F078xx)
  /* Reset USART2SW[1:0], USART1SW[1:0], I2C1SW, CECSW, USBSW and ADCSW bits */
  RCC->CFGR3 &= (uint32_t)0xFFFCFE2CU;
 8006f9a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006f9c:	4809      	ldr	r0, [pc, #36]	; (8006fc4 <SystemInit+0x5c>)
 8006f9e:	4002      	ands	r2, r0
 8006fa0:	631a      	str	r2, [r3, #48]	; 0x30
#else
 #warning "No target selected"
#endif

  /* Reset HSI14 bit */
  RCC->CR2 &= (uint32_t)0xFFFFFFFEU;
 8006fa2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8006fa4:	438a      	bics	r2, r1
 8006fa6:	635a      	str	r2, [r3, #52]	; 0x34

  /* Disable all interrupts */
  RCC->CIR = 0x00000000U;
 8006fa8:	2200      	movs	r2, #0
 8006faa:	609a      	str	r2, [r3, #8]

}
 8006fac:	4770      	bx	lr
 8006fae:	46c0      	nop			; (mov r8, r8)
 8006fb0:	40021000 	.word	0x40021000
 8006fb4:	08ffb80c 	.word	0x08ffb80c
 8006fb8:	fef6ffff 	.word	0xfef6ffff
 8006fbc:	fffbffff 	.word	0xfffbffff
 8006fc0:	ffc0ffff 	.word	0xffc0ffff
 8006fc4:	fffcfe2c 	.word	0xfffcfe2c

08006fc8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8006fc8:	b510      	push	{r4, lr}
 8006fca:	0004      	movs	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000U);
 8006fcc:	f001 f884 	bl	80080d8 <HAL_RCC_GetHCLKFreq>
 8006fd0:	21fa      	movs	r1, #250	; 0xfa
 8006fd2:	0089      	lsls	r1, r1, #2
 8006fd4:	f7fe fcee 	bl	80059b4 <__udivsi3>
 8006fd8:	f000 fac6 	bl	8007568 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 8006fdc:	2001      	movs	r0, #1
 8006fde:	2200      	movs	r2, #0
 8006fe0:	0021      	movs	r1, r4
 8006fe2:	4240      	negs	r0, r0
 8006fe4:	f000 fa8c 	bl	8007500 <HAL_NVIC_SetPriority>

   /* Return function status */
  return HAL_OK;
}
 8006fe8:	2000      	movs	r0, #0
 8006fea:	bd10      	pop	{r4, pc}

08006fec <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8006fec:	2310      	movs	r3, #16
 8006fee:	4a06      	ldr	r2, [pc, #24]	; (8007008 <HAL_Init+0x1c>)
{
 8006ff0:	b510      	push	{r4, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8006ff2:	6811      	ldr	r1, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 8006ff4:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8006ff6:	430b      	orrs	r3, r1
 8006ff8:	6013      	str	r3, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 8006ffa:	f7ff ffe5 	bl	8006fc8 <HAL_InitTick>
  HAL_MspInit();
 8006ffe:	f7fe fee1 	bl	8005dc4 <HAL_MspInit>
}
 8007002:	2000      	movs	r0, #0
 8007004:	bd10      	pop	{r4, pc}
 8007006:	46c0      	nop			; (mov r8, r8)
 8007008:	40022000 	.word	0x40022000

0800700c <HAL_IncTick>:
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 800700c:	4a02      	ldr	r2, [pc, #8]	; (8007018 <HAL_IncTick+0xc>)
 800700e:	6813      	ldr	r3, [r2, #0]
 8007010:	3301      	adds	r3, #1
 8007012:	6013      	str	r3, [r2, #0]
}
 8007014:	4770      	bx	lr
 8007016:	46c0      	nop			; (mov r8, r8)
 8007018:	20001b80 	.word	0x20001b80

0800701c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 800701c:	4b01      	ldr	r3, [pc, #4]	; (8007024 <HAL_GetTick+0x8>)
 800701e:	6818      	ldr	r0, [r3, #0]
}
 8007020:	4770      	bx	lr
 8007022:	46c0      	nop			; (mov r8, r8)
 8007024:	20001b80 	.word	0x20001b80

08007028 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 8007028:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800702a:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = HAL_GetTick();
 800702c:	f7ff fff6 	bl	800701c <HAL_GetTick>
  uint32_t wait = Delay;
 8007030:	9c01      	ldr	r4, [sp, #4]
  uint32_t tickstart = HAL_GetTick();
 8007032:	0005      	movs	r5, r0
  
  /* Add a period to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
  {
     wait++;
 8007034:	1c63      	adds	r3, r4, #1
 8007036:	1e5a      	subs	r2, r3, #1
 8007038:	4193      	sbcs	r3, r2
 800703a:	18e4      	adds	r4, r4, r3
  }
  
  while((HAL_GetTick() - tickstart) < wait)
 800703c:	f7ff ffee 	bl	800701c <HAL_GetTick>
 8007040:	1b40      	subs	r0, r0, r5
 8007042:	42a0      	cmp	r0, r4
 8007044:	d3fa      	bcc.n	800703c <HAL_Delay+0x14>
  {
  }
}
 8007046:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

08007048 <ADC_Enable>:
  * @retval HAL status.
  */
static HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
{
  uint32_t tickstart = 0U;
  __IO uint32_t wait_loop_index = 0U;
 8007048:	2300      	movs	r3, #0
{
 800704a:	b573      	push	{r0, r1, r4, r5, r6, lr}
  
  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (ADC_IS_ENABLE(hadc) == RESET)
 800704c:	2103      	movs	r1, #3
  __IO uint32_t wait_loop_index = 0U;
 800704e:	9301      	str	r3, [sp, #4]
  if (ADC_IS_ENABLE(hadc) == RESET)
 8007050:	6803      	ldr	r3, [r0, #0]
{
 8007052:	0004      	movs	r4, r0
  if (ADC_IS_ENABLE(hadc) == RESET)
 8007054:	689a      	ldr	r2, [r3, #8]
 8007056:	400a      	ands	r2, r1
 8007058:	2a01      	cmp	r2, #1
 800705a:	d107      	bne.n	800706c <ADC_Enable+0x24>
 800705c:	6819      	ldr	r1, [r3, #0]
 800705e:	4211      	tst	r1, r2
 8007060:	d001      	beq.n	8007066 <ADC_Enable+0x1e>
    }   
    
  }
   
  /* Return HAL status */
  return HAL_OK;
 8007062:	2000      	movs	r0, #0
}
 8007064:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
  if (ADC_IS_ENABLE(hadc) == RESET)
 8007066:	68da      	ldr	r2, [r3, #12]
 8007068:	0412      	lsls	r2, r2, #16
 800706a:	d4fa      	bmi.n	8007062 <ADC_Enable+0x1a>
    if (ADC_ENABLING_CONDITIONS(hadc) == RESET)
 800706c:	6899      	ldr	r1, [r3, #8]
 800706e:	4a19      	ldr	r2, [pc, #100]	; (80070d4 <ADC_Enable+0x8c>)
 8007070:	4211      	tst	r1, r2
 8007072:	d008      	beq.n	8007086 <ADC_Enable+0x3e>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007074:	2310      	movs	r3, #16
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007076:	2001      	movs	r0, #1
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007078:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800707a:	4313      	orrs	r3, r2
 800707c:	6463      	str	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800707e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8007080:	4303      	orrs	r3, r0
 8007082:	64a3      	str	r3, [r4, #72]	; 0x48
      return HAL_ERROR;
 8007084:	e7ee      	b.n	8007064 <ADC_Enable+0x1c>
    __HAL_ADC_ENABLE(hadc);
 8007086:	2201      	movs	r2, #1
 8007088:	6899      	ldr	r1, [r3, #8]
 800708a:	430a      	orrs	r2, r1
 800708c:	609a      	str	r2, [r3, #8]
    wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 800708e:	4b12      	ldr	r3, [pc, #72]	; (80070d8 <ADC_Enable+0x90>)
 8007090:	4912      	ldr	r1, [pc, #72]	; (80070dc <ADC_Enable+0x94>)
 8007092:	6818      	ldr	r0, [r3, #0]
 8007094:	f7fe fc8e 	bl	80059b4 <__udivsi3>
 8007098:	9001      	str	r0, [sp, #4]
    while(wait_loop_index != 0U)
 800709a:	9b01      	ldr	r3, [sp, #4]
 800709c:	2b00      	cmp	r3, #0
 800709e:	d115      	bne.n	80070cc <ADC_Enable+0x84>
    tickstart = HAL_GetTick();
 80070a0:	f7ff ffbc 	bl	800701c <HAL_GetTick>
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
 80070a4:	2501      	movs	r5, #1
    tickstart = HAL_GetTick();
 80070a6:	0006      	movs	r6, r0
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
 80070a8:	6823      	ldr	r3, [r4, #0]
 80070aa:	681b      	ldr	r3, [r3, #0]
 80070ac:	422b      	tst	r3, r5
 80070ae:	d1d8      	bne.n	8007062 <ADC_Enable+0x1a>
      if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 80070b0:	f7ff ffb4 	bl	800701c <HAL_GetTick>
 80070b4:	1b80      	subs	r0, r0, r6
 80070b6:	2802      	cmp	r0, #2
 80070b8:	d9f6      	bls.n	80070a8 <ADC_Enable+0x60>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80070ba:	2310      	movs	r3, #16
 80070bc:	6c62      	ldr	r2, [r4, #68]	; 0x44
        return HAL_ERROR;
 80070be:	2001      	movs	r0, #1
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80070c0:	4313      	orrs	r3, r2
 80070c2:	6463      	str	r3, [r4, #68]	; 0x44
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80070c4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80070c6:	432b      	orrs	r3, r5
 80070c8:	64a3      	str	r3, [r4, #72]	; 0x48
        return HAL_ERROR;
 80070ca:	e7cb      	b.n	8007064 <ADC_Enable+0x1c>
      wait_loop_index--;
 80070cc:	9b01      	ldr	r3, [sp, #4]
 80070ce:	3b01      	subs	r3, #1
 80070d0:	9301      	str	r3, [sp, #4]
 80070d2:	e7e2      	b.n	800709a <ADC_Enable+0x52>
 80070d4:	80000017 	.word	0x80000017
 80070d8:	20000030 	.word	0x20000030
 80070dc:	000f4240 	.word	0x000f4240

080070e0 <HAL_ADC_Init>:
{
 80070e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80070e2:	0004      	movs	r4, r0
    return HAL_ERROR;
 80070e4:	2001      	movs	r0, #1
  if(hadc == NULL)
 80070e6:	2c00      	cmp	r4, #0
 80070e8:	d07d      	beq.n	80071e6 <HAL_ADC_Init+0x106>
  if (hadc->State == HAL_ADC_STATE_RESET)
 80070ea:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80070ec:	2b00      	cmp	r3, #0
 80070ee:	d106      	bne.n	80070fe <HAL_ADC_Init+0x1e>
    hadc->Lock = HAL_UNLOCKED;
 80070f0:	0022      	movs	r2, r4
 80070f2:	3240      	adds	r2, #64	; 0x40
    ADC_CLEAR_ERRORCODE(hadc);
 80070f4:	64a3      	str	r3, [r4, #72]	; 0x48
    HAL_ADC_MspInit(hadc);
 80070f6:	0020      	movs	r0, r4
    hadc->Lock = HAL_UNLOCKED;
 80070f8:	7013      	strb	r3, [r2, #0]
    HAL_ADC_MspInit(hadc);
 80070fa:	f7fe fe9f 	bl	8005e3c <HAL_ADC_MspInit>
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
 80070fe:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007100:	06db      	lsls	r3, r3, #27
 8007102:	d500      	bpl.n	8007106 <HAL_ADC_Init+0x26>
 8007104:	e084      	b.n	8007210 <HAL_ADC_Init+0x130>
      (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)          )
 8007106:	2204      	movs	r2, #4
 8007108:	6823      	ldr	r3, [r4, #0]
 800710a:	6898      	ldr	r0, [r3, #8]
 800710c:	4010      	ands	r0, r2
      (tmp_hal_status == HAL_OK)                                &&
 800710e:	d000      	beq.n	8007112 <HAL_ADC_Init+0x32>
 8007110:	e07e      	b.n	8007210 <HAL_ADC_Init+0x130>
    ADC_STATE_CLR_SET(hadc->State,
 8007112:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8007114:	4941      	ldr	r1, [pc, #260]	; (800721c <HAL_ADC_Init+0x13c>)
 8007116:	4011      	ands	r1, r2
 8007118:	2202      	movs	r2, #2
 800711a:	430a      	orrs	r2, r1
    if (ADC_IS_ENABLE(hadc) == RESET)
 800711c:	2103      	movs	r1, #3
    ADC_STATE_CLR_SET(hadc->State,
 800711e:	6462      	str	r2, [r4, #68]	; 0x44
    if (ADC_IS_ENABLE(hadc) == RESET)
 8007120:	689a      	ldr	r2, [r3, #8]
 8007122:	400a      	ands	r2, r1
 8007124:	2a01      	cmp	r2, #1
 8007126:	d105      	bne.n	8007134 <HAL_ADC_Init+0x54>
 8007128:	6819      	ldr	r1, [r3, #0]
 800712a:	4211      	tst	r1, r2
 800712c:	d10e      	bne.n	800714c <HAL_ADC_Init+0x6c>
 800712e:	68da      	ldr	r2, [r3, #12]
 8007130:	0412      	lsls	r2, r2, #16
 8007132:	d40b      	bmi.n	800714c <HAL_ADC_Init+0x6c>
      MODIFY_REG(hadc->Instance->CFGR1,
 8007134:	2118      	movs	r1, #24
 8007136:	68da      	ldr	r2, [r3, #12]
 8007138:	438a      	bics	r2, r1
 800713a:	68a1      	ldr	r1, [r4, #8]
 800713c:	430a      	orrs	r2, r1
 800713e:	60da      	str	r2, [r3, #12]
      MODIFY_REG(hadc->Instance->CFGR2    ,
 8007140:	6919      	ldr	r1, [r3, #16]
 8007142:	6862      	ldr	r2, [r4, #4]
 8007144:	0089      	lsls	r1, r1, #2
 8007146:	0889      	lsrs	r1, r1, #2
 8007148:	4311      	orrs	r1, r2
 800714a:	6119      	str	r1, [r3, #16]
    hadc->Instance->CFGR1 &= ~( ADC_CFGR1_DISCEN  |
 800714c:	68da      	ldr	r2, [r3, #12]
 800714e:	4934      	ldr	r1, [pc, #208]	; (8007220 <HAL_ADC_Init+0x140>)
                 ADC_CFGR1_CONTINUOUS(hadc->Init.ContinuousConvMode)    |
 8007150:	6a25      	ldr	r5, [r4, #32]
    hadc->Instance->CFGR1 &= ~( ADC_CFGR1_DISCEN  |
 8007152:	400a      	ands	r2, r1
 8007154:	60da      	str	r2, [r3, #12]
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
 8007156:	69a2      	ldr	r2, [r4, #24]
                 ADC_CFGR1_CONTINUOUS(hadc->Init.ContinuousConvMode)    |
 8007158:	036f      	lsls	r7, r5, #13
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
 800715a:	0391      	lsls	r1, r2, #14
                 ADC_CFGR1_AUTOOFF(hadc->Init.LowPowerAutoPowerOff)     |
 800715c:	69e2      	ldr	r2, [r4, #28]
 800715e:	03d2      	lsls	r2, r2, #15
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
 8007160:	4311      	orrs	r1, r2
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                  |
 8007162:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8007164:	3a01      	subs	r2, #1
 8007166:	1e56      	subs	r6, r2, #1
 8007168:	41b2      	sbcs	r2, r6
 800716a:	0316      	lsls	r6, r2, #12
 800716c:	68e2      	ldr	r2, [r4, #12]
 800716e:	4311      	orrs	r1, r2
                 ADC_SCANDIR(hadc->Init.ScanConvMode)                   |
 8007170:	6922      	ldr	r2, [r4, #16]
 8007172:	430f      	orrs	r7, r1
 8007174:	2a02      	cmp	r2, #2
 8007176:	d100      	bne.n	800717a <HAL_ADC_Init+0x9a>
 8007178:	2004      	movs	r0, #4
                 ADC_CFGR1_DMACONTREQ(hadc->Init.DMAContinuousRequests)  );
 800717a:	6b22      	ldr	r2, [r4, #48]	; 0x30
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 800717c:	6a61      	ldr	r1, [r4, #36]	; 0x24
                 ADC_CFGR1_DMACONTREQ(hadc->Init.DMAContinuousRequests)  );
 800717e:	0052      	lsls	r2, r2, #1
                 ADC_SCANDIR(hadc->Init.ScanConvMode)                   |
 8007180:	433a      	orrs	r2, r7
 8007182:	4332      	orrs	r2, r6
 8007184:	4302      	orrs	r2, r0
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8007186:	2901      	cmp	r1, #1
 8007188:	d104      	bne.n	8007194 <HAL_ADC_Init+0xb4>
      if (hadc->Init.ContinuousConvMode == DISABLE)
 800718a:	2d00      	cmp	r5, #0
 800718c:	d12c      	bne.n	80071e8 <HAL_ADC_Init+0x108>
        tmpCFGR1 |= ADC_CFGR1_DISCEN;
 800718e:	2180      	movs	r1, #128	; 0x80
 8007190:	0249      	lsls	r1, r1, #9
 8007192:	430a      	orrs	r2, r1
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8007194:	20c2      	movs	r0, #194	; 0xc2
 8007196:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8007198:	30ff      	adds	r0, #255	; 0xff
 800719a:	4281      	cmp	r1, r0
 800719c:	d002      	beq.n	80071a4 <HAL_ADC_Init+0xc4>
      tmpCFGR1 |= ( hadc->Init.ExternalTrigConv    |
 800719e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80071a0:	4301      	orrs	r1, r0
 80071a2:	430a      	orrs	r2, r1
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80071a4:	2080      	movs	r0, #128	; 0x80
    hadc->Instance->CFGR1 |= tmpCFGR1;
 80071a6:	68d9      	ldr	r1, [r3, #12]
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80071a8:	0540      	lsls	r0, r0, #21
    hadc->Instance->CFGR1 |= tmpCFGR1;
 80071aa:	4311      	orrs	r1, r2
 80071ac:	60d9      	str	r1, [r3, #12]
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80071ae:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80071b0:	4281      	cmp	r1, r0
 80071b2:	d002      	beq.n	80071ba <HAL_ADC_Init+0xda>
 80071b4:	1e48      	subs	r0, r1, #1
 80071b6:	2806      	cmp	r0, #6
 80071b8:	d807      	bhi.n	80071ca <HAL_ADC_Init+0xea>
      hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 80071ba:	2507      	movs	r5, #7
 80071bc:	6958      	ldr	r0, [r3, #20]
      hadc->Instance->SMPR |= ADC_SMPR_SET(hadc->Init.SamplingTimeCommon);
 80071be:	4029      	ands	r1, r5
      hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 80071c0:	43a8      	bics	r0, r5
 80071c2:	6158      	str	r0, [r3, #20]
      hadc->Instance->SMPR |= ADC_SMPR_SET(hadc->Init.SamplingTimeCommon);
 80071c4:	6958      	ldr	r0, [r3, #20]
 80071c6:	4301      	orrs	r1, r0
 80071c8:	6159      	str	r1, [r3, #20]
    if ((hadc->Instance->CFGR1 & ~(ADC_CFGR1_AWDCH | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL | ADC_CFGR1_RES))
 80071ca:	68db      	ldr	r3, [r3, #12]
 80071cc:	4915      	ldr	r1, [pc, #84]	; (8007224 <HAL_ADC_Init+0x144>)
 80071ce:	400b      	ands	r3, r1
 80071d0:	4293      	cmp	r3, r2
 80071d2:	d111      	bne.n	80071f8 <HAL_ADC_Init+0x118>
      ADC_CLEAR_ERRORCODE(hadc);
 80071d4:	2000      	movs	r0, #0
      ADC_STATE_CLR_SET(hadc->State,
 80071d6:	2203      	movs	r2, #3
      ADC_CLEAR_ERRORCODE(hadc);
 80071d8:	64a0      	str	r0, [r4, #72]	; 0x48
      ADC_STATE_CLR_SET(hadc->State,
 80071da:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80071dc:	4393      	bics	r3, r2
 80071de:	001a      	movs	r2, r3
 80071e0:	2301      	movs	r3, #1
 80071e2:	4313      	orrs	r3, r2
 80071e4:	6463      	str	r3, [r4, #68]	; 0x44
}
 80071e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80071e8:	2020      	movs	r0, #32
 80071ea:	6c65      	ldr	r5, [r4, #68]	; 0x44
 80071ec:	4328      	orrs	r0, r5
 80071ee:	6460      	str	r0, [r4, #68]	; 0x44
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80071f0:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 80071f2:	4301      	orrs	r1, r0
 80071f4:	64a1      	str	r1, [r4, #72]	; 0x48
 80071f6:	e7cd      	b.n	8007194 <HAL_ADC_Init+0xb4>
      ADC_STATE_CLR_SET(hadc->State,
 80071f8:	2212      	movs	r2, #18
 80071fa:	6c63      	ldr	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80071fc:	2001      	movs	r0, #1
      ADC_STATE_CLR_SET(hadc->State,
 80071fe:	4393      	bics	r3, r2
 8007200:	001a      	movs	r2, r3
 8007202:	2310      	movs	r3, #16
 8007204:	4313      	orrs	r3, r2
 8007206:	6463      	str	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007208:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800720a:	4303      	orrs	r3, r0
 800720c:	64a3      	str	r3, [r4, #72]	; 0x48
 800720e:	e7ea      	b.n	80071e6 <HAL_ADC_Init+0x106>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007210:	2310      	movs	r3, #16
 8007212:	6c62      	ldr	r2, [r4, #68]	; 0x44
    tmp_hal_status = HAL_ERROR;
 8007214:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007216:	4313      	orrs	r3, r2
 8007218:	6463      	str	r3, [r4, #68]	; 0x44
 800721a:	e7e4      	b.n	80071e6 <HAL_ADC_Init+0x106>
 800721c:	fffffefd 	.word	0xfffffefd
 8007220:	fffe0219 	.word	0xfffe0219
 8007224:	833fffe7 	.word	0x833fffe7

08007228 <HAL_ADC_Start_DMA>:
{
 8007228:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 800722a:	6803      	ldr	r3, [r0, #0]
{
 800722c:	0004      	movs	r4, r0
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 800722e:	689b      	ldr	r3, [r3, #8]
{
 8007230:	000f      	movs	r7, r1
 8007232:	9201      	str	r2, [sp, #4]
    tmp_hal_status = HAL_BUSY;
 8007234:	2002      	movs	r0, #2
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8007236:	075b      	lsls	r3, r3, #29
 8007238:	d430      	bmi.n	800729c <HAL_ADC_Start_DMA+0x74>
    __HAL_LOCK(hadc);
 800723a:	0026      	movs	r6, r4
 800723c:	3640      	adds	r6, #64	; 0x40
 800723e:	7833      	ldrb	r3, [r6, #0]
 8007240:	2b01      	cmp	r3, #1
 8007242:	d02b      	beq.n	800729c <HAL_ADC_Start_DMA+0x74>
 8007244:	2301      	movs	r3, #1
 8007246:	7033      	strb	r3, [r6, #0]
    if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
 8007248:	69e3      	ldr	r3, [r4, #28]
 800724a:	2b01      	cmp	r3, #1
 800724c:	d127      	bne.n	800729e <HAL_ADC_Start_DMA+0x76>
      ADC_STATE_CLR_SET(hadc->State,
 800724e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007250:	4a16      	ldr	r2, [pc, #88]	; (80072ac <HAL_ADC_Start_DMA+0x84>)
      ADC_CLEAR_ERRORCODE(hadc);
 8007252:	2500      	movs	r5, #0
      ADC_STATE_CLR_SET(hadc->State,
 8007254:	401a      	ands	r2, r3
 8007256:	2380      	movs	r3, #128	; 0x80
 8007258:	005b      	lsls	r3, r3, #1
 800725a:	4313      	orrs	r3, r2
 800725c:	6463      	str	r3, [r4, #68]	; 0x44
      hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 800725e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8007260:	4b13      	ldr	r3, [pc, #76]	; (80072b0 <HAL_ADC_Start_DMA+0x88>)
      ADC_CLEAR_ERRORCODE(hadc);
 8007262:	64a5      	str	r5, [r4, #72]	; 0x48
      __HAL_UNLOCK(hadc);
 8007264:	7035      	strb	r5, [r6, #0]
      hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 8007266:	6283      	str	r3, [r0, #40]	; 0x28
      hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 8007268:	4b12      	ldr	r3, [pc, #72]	; (80072b4 <HAL_ADC_Start_DMA+0x8c>)
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 800726a:	6821      	ldr	r1, [r4, #0]
      hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 800726c:	62c3      	str	r3, [r0, #44]	; 0x2c
      hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 800726e:	4b12      	ldr	r3, [pc, #72]	; (80072b8 <HAL_ADC_Start_DMA+0x90>)
 8007270:	6303      	str	r3, [r0, #48]	; 0x30
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8007272:	231c      	movs	r3, #28
 8007274:	600b      	str	r3, [r1, #0]
      __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 8007276:	684a      	ldr	r2, [r1, #4]
 8007278:	3b0c      	subs	r3, #12
 800727a:	4313      	orrs	r3, r2
 800727c:	604b      	str	r3, [r1, #4]
      hadc->Instance->CFGR1 |= ADC_CFGR1_DMAEN;
 800727e:	2301      	movs	r3, #1
 8007280:	68ca      	ldr	r2, [r1, #12]
 8007282:	4313      	orrs	r3, r2
 8007284:	60cb      	str	r3, [r1, #12]
      HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 8007286:	003a      	movs	r2, r7
 8007288:	3140      	adds	r1, #64	; 0x40
 800728a:	9b01      	ldr	r3, [sp, #4]
 800728c:	f000 fac0 	bl	8007810 <HAL_DMA_Start_IT>
      hadc->Instance->CR |= ADC_CR_ADSTART;
 8007290:	2304      	movs	r3, #4
 8007292:	0028      	movs	r0, r5
 8007294:	6822      	ldr	r2, [r4, #0]
 8007296:	6891      	ldr	r1, [r2, #8]
 8007298:	430b      	orrs	r3, r1
 800729a:	6093      	str	r3, [r2, #8]
}
 800729c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      tmp_hal_status = ADC_Enable(hadc);
 800729e:	0020      	movs	r0, r4
 80072a0:	f7ff fed2 	bl	8007048 <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 80072a4:	2800      	cmp	r0, #0
 80072a6:	d0d2      	beq.n	800724e <HAL_ADC_Start_DMA+0x26>
 80072a8:	e7f8      	b.n	800729c <HAL_ADC_Start_DMA+0x74>
 80072aa:	46c0      	nop			; (mov r8, r8)
 80072ac:	fffff0fe 	.word	0xfffff0fe
 80072b0:	080072c1 	.word	0x080072c1
 80072b4:	08007333 	.word	0x08007333
 80072b8:	0800733f 	.word	0x0800733f

080072bc <HAL_ADC_ConvCpltCallback>:
 80072bc:	4770      	bx	lr
	...

080072c0 <ADC_DMAConvCplt>:
{
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Update state machine on conversion status if not in error state */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
 80072c0:	2250      	movs	r2, #80	; 0x50
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 80072c2:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
 80072c4:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
 80072c6:	6c59      	ldr	r1, [r3, #68]	; 0x44
 80072c8:	4211      	tst	r1, r2
 80072ca:	d12a      	bne.n	8007322 <ADC_DMAConvCplt+0x62>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
 80072cc:	6c59      	ldr	r1, [r3, #68]	; 0x44
 80072ce:	32b1      	adds	r2, #177	; 0xb1
 80072d0:	32ff      	adds	r2, #255	; 0xff
 80072d2:	430a      	orrs	r2, r1
    
    /* Determine whether any further conversion upcoming on group regular     */
    /* by external trigger, continuous mode or scan sequence on going.        */
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 80072d4:	21c0      	movs	r1, #192	; 0xc0
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
 80072d6:	645a      	str	r2, [r3, #68]	; 0x44
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 80072d8:	681a      	ldr	r2, [r3, #0]
 80072da:	0109      	lsls	r1, r1, #4
 80072dc:	68d0      	ldr	r0, [r2, #12]
 80072de:	4208      	tst	r0, r1
 80072e0:	d112      	bne.n	8007308 <ADC_DMAConvCplt+0x48>
 80072e2:	6a19      	ldr	r1, [r3, #32]
 80072e4:	2900      	cmp	r1, #0
 80072e6:	d10f      	bne.n	8007308 <ADC_DMAConvCplt+0x48>
       (hadc->Init.ContinuousConvMode == DISABLE)   )
    {
      /* If End of Sequence is reached, disable interrupts */
      if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )
 80072e8:	6811      	ldr	r1, [r2, #0]
 80072ea:	0709      	lsls	r1, r1, #28
 80072ec:	d50c      	bpl.n	8007308 <ADC_DMAConvCplt+0x48>
      {
        /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit           */
        /* ADSTART==0 (no conversion on going)                                */
        if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 80072ee:	6891      	ldr	r1, [r2, #8]
 80072f0:	0749      	lsls	r1, r1, #29
 80072f2:	d40d      	bmi.n	8007310 <ADC_DMAConvCplt+0x50>
        {
          /* Disable ADC end of single conversion interrupt on group regular */
          /* Note: Overrun interrupt was enabled with EOC interrupt in        */
          /* HAL_Start_IT(), but is not disabled here because can be used     */
          /* by overrun IRQ process below.                                    */
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 80072f4:	200c      	movs	r0, #12
 80072f6:	6851      	ldr	r1, [r2, #4]
 80072f8:	4381      	bics	r1, r0
 80072fa:	6051      	str	r1, [r2, #4]
          
          /* Set ADC state */
          ADC_STATE_CLR_SET(hadc->State,
 80072fc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80072fe:	490b      	ldr	r1, [pc, #44]	; (800732c <ADC_DMAConvCplt+0x6c>)
 8007300:	4011      	ands	r1, r2
 8007302:	2201      	movs	r2, #1
 8007304:	430a      	orrs	r2, r1
 8007306:	645a      	str	r2, [r3, #68]	; 0x44
        }
      }
    }

    /* Conversion complete callback */
    HAL_ADC_ConvCpltCallback(hadc); 
 8007308:	0018      	movs	r0, r3
 800730a:	f7ff ffd7 	bl	80072bc <HAL_ADC_ConvCpltCallback>
  {
    /* Call DMA error callback */
    hadc->DMA_Handle->XferErrorCallback(hdma);
  }

}
 800730e:	bd10      	pop	{r4, pc}
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8007310:	2220      	movs	r2, #32
 8007312:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8007314:	430a      	orrs	r2, r1
 8007316:	645a      	str	r2, [r3, #68]	; 0x44
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007318:	2201      	movs	r2, #1
 800731a:	6c99      	ldr	r1, [r3, #72]	; 0x48
 800731c:	430a      	orrs	r2, r1
 800731e:	649a      	str	r2, [r3, #72]	; 0x48
 8007320:	e7f2      	b.n	8007308 <ADC_DMAConvCplt+0x48>
    hadc->DMA_Handle->XferErrorCallback(hdma);
 8007322:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007324:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007326:	4798      	blx	r3
}
 8007328:	e7f1      	b.n	800730e <ADC_DMAConvCplt+0x4e>
 800732a:	46c0      	nop			; (mov r8, r8)
 800732c:	fffffefe 	.word	0xfffffefe

08007330 <HAL_ADC_ConvHalfCpltCallback>:
 8007330:	4770      	bx	lr

08007332 <ADC_DMAHalfConvCplt>:
  * @brief  DMA half transfer complete callback. 
  * @param  hdma: pointer to DMA handle.
  * @retval None
  */
static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
{
 8007332:	b510      	push	{r4, lr}
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Half conversion callback */
  HAL_ADC_ConvHalfCpltCallback(hadc); 
 8007334:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8007336:	f7ff fffb 	bl	8007330 <HAL_ADC_ConvHalfCpltCallback>
}
 800733a:	bd10      	pop	{r4, pc}

0800733c <HAL_ADC_ErrorCallback>:
 800733c:	4770      	bx	lr

0800733e <ADC_DMAError>:
{
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Set ADC state */
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 800733e:	2340      	movs	r3, #64	; 0x40
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8007340:	6a40      	ldr	r0, [r0, #36]	; 0x24
{
 8007342:	b510      	push	{r4, lr}
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 8007344:	6c42      	ldr	r2, [r0, #68]	; 0x44
 8007346:	4313      	orrs	r3, r2
 8007348:	6443      	str	r3, [r0, #68]	; 0x44
  
  /* Set ADC error code to DMA error */
  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
 800734a:	2304      	movs	r3, #4
 800734c:	6c82      	ldr	r2, [r0, #72]	; 0x48
 800734e:	4313      	orrs	r3, r2
 8007350:	6483      	str	r3, [r0, #72]	; 0x48
  
  /* Error callback */
  HAL_ADC_ErrorCallback(hadc); 
 8007352:	f7ff fff3 	bl	800733c <HAL_ADC_ErrorCallback>
}
 8007356:	bd10      	pop	{r4, pc}

08007358 <HAL_ADC_ConfigChannel>:
{
 8007358:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint32_t wait_loop_index = 0U;
 800735a:	2200      	movs	r2, #0
  __HAL_LOCK(hadc);
 800735c:	0004      	movs	r4, r0
  __IO uint32_t wait_loop_index = 0U;
 800735e:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 8007360:	3440      	adds	r4, #64	; 0x40
 8007362:	7822      	ldrb	r2, [r4, #0]
{
 8007364:	0003      	movs	r3, r0
  __HAL_LOCK(hadc);
 8007366:	2002      	movs	r0, #2
 8007368:	2a01      	cmp	r2, #1
 800736a:	d02b      	beq.n	80073c4 <HAL_ADC_ConfigChannel+0x6c>
 800736c:	2201      	movs	r2, #1
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 800736e:	681d      	ldr	r5, [r3, #0]
  if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8007370:	6b9e      	ldr	r6, [r3, #56]	; 0x38
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8007372:	68a8      	ldr	r0, [r5, #8]
  __HAL_LOCK(hadc);
 8007374:	7022      	strb	r2, [r4, #0]
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8007376:	0740      	lsls	r0, r0, #29
 8007378:	d45a      	bmi.n	8007430 <HAL_ADC_ConfigChannel+0xd8>
 800737a:	680b      	ldr	r3, [r1, #0]
    if (sConfig->Rank != ADC_RANK_NONE)
 800737c:	482f      	ldr	r0, [pc, #188]	; (800743c <HAL_ADC_ConfigChannel+0xe4>)
 800737e:	001f      	movs	r7, r3
 8007380:	4684      	mov	ip, r0
 8007382:	6848      	ldr	r0, [r1, #4]
 8007384:	409a      	lsls	r2, r3
 8007386:	3f10      	subs	r7, #16
 8007388:	4560      	cmp	r0, ip
 800738a:	d03b      	beq.n	8007404 <HAL_ADC_ConfigChannel+0xac>
      hadc->Instance->CHSELR |= ADC_CHSELR_CHANNEL(sConfig->Channel);
 800738c:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 800738e:	4310      	orrs	r0, r2
      if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8007390:	2280      	movs	r2, #128	; 0x80
      hadc->Instance->CHSELR |= ADC_CHSELR_CHANNEL(sConfig->Channel);
 8007392:	62a8      	str	r0, [r5, #40]	; 0x28
      if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8007394:	0552      	lsls	r2, r2, #21
 8007396:	4296      	cmp	r6, r2
 8007398:	d00f      	beq.n	80073ba <HAL_ADC_ConfigChannel+0x62>
 800739a:	3e01      	subs	r6, #1
 800739c:	2e06      	cmp	r6, #6
 800739e:	d90c      	bls.n	80073ba <HAL_ADC_ConfigChannel+0x62>
        if (sConfig->SamplingTime != ADC_GET_SAMPLINGTIME(hadc))
 80073a0:	688a      	ldr	r2, [r1, #8]
 80073a2:	2107      	movs	r1, #7
 80073a4:	6968      	ldr	r0, [r5, #20]
 80073a6:	4008      	ands	r0, r1
 80073a8:	4282      	cmp	r2, r0
 80073aa:	d006      	beq.n	80073ba <HAL_ADC_ConfigChannel+0x62>
          hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 80073ac:	6968      	ldr	r0, [r5, #20]
          hadc->Instance->SMPR |= ADC_SMPR_SET(sConfig->SamplingTime);
 80073ae:	400a      	ands	r2, r1
          hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 80073b0:	4388      	bics	r0, r1
 80073b2:	6168      	str	r0, [r5, #20]
          hadc->Instance->SMPR |= ADC_SMPR_SET(sConfig->SamplingTime);
 80073b4:	6968      	ldr	r0, [r5, #20]
 80073b6:	4302      	orrs	r2, r0
 80073b8:	616a      	str	r2, [r5, #20]
      if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 80073ba:	2f02      	cmp	r7, #2
 80073bc:	d903      	bls.n	80073c6 <HAL_ADC_ConfigChannel+0x6e>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80073be:	2000      	movs	r0, #0
  __HAL_UNLOCK(hadc);
 80073c0:	2300      	movs	r3, #0
 80073c2:	7023      	strb	r3, [r4, #0]
}
 80073c4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        ADC->CCR |= ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 80073c6:	4a1e      	ldr	r2, [pc, #120]	; (8007440 <HAL_ADC_ConfigChannel+0xe8>)
 80073c8:	2080      	movs	r0, #128	; 0x80
 80073ca:	6811      	ldr	r1, [r2, #0]
 80073cc:	2b10      	cmp	r3, #16
 80073ce:	d015      	beq.n	80073fc <HAL_ADC_ConfigChannel+0xa4>
 80073d0:	2b11      	cmp	r3, #17
 80073d2:	d115      	bne.n	8007400 <HAL_ADC_ConfigChannel+0xa8>
 80073d4:	03c0      	lsls	r0, r0, #15
 80073d6:	4301      	orrs	r1, r0
 80073d8:	6011      	str	r1, [r2, #0]
        if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80073da:	2b10      	cmp	r3, #16
 80073dc:	d1ef      	bne.n	80073be <HAL_ADC_ConfigChannel+0x66>
          wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 80073de:	4b19      	ldr	r3, [pc, #100]	; (8007444 <HAL_ADC_ConfigChannel+0xec>)
 80073e0:	4919      	ldr	r1, [pc, #100]	; (8007448 <HAL_ADC_ConfigChannel+0xf0>)
 80073e2:	6818      	ldr	r0, [r3, #0]
 80073e4:	f7fe fae6 	bl	80059b4 <__udivsi3>
 80073e8:	230a      	movs	r3, #10
 80073ea:	4358      	muls	r0, r3
 80073ec:	9001      	str	r0, [sp, #4]
          while(wait_loop_index != 0U)
 80073ee:	9b01      	ldr	r3, [sp, #4]
 80073f0:	2b00      	cmp	r3, #0
 80073f2:	d0e4      	beq.n	80073be <HAL_ADC_ConfigChannel+0x66>
            wait_loop_index--;
 80073f4:	9b01      	ldr	r3, [sp, #4]
 80073f6:	3b01      	subs	r3, #1
 80073f8:	9301      	str	r3, [sp, #4]
 80073fa:	e7f8      	b.n	80073ee <HAL_ADC_ConfigChannel+0x96>
        ADC->CCR |= ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 80073fc:	0400      	lsls	r0, r0, #16
 80073fe:	e7ea      	b.n	80073d6 <HAL_ADC_ConfigChannel+0x7e>
 8007400:	0440      	lsls	r0, r0, #17
 8007402:	e7e8      	b.n	80073d6 <HAL_ADC_ConfigChannel+0x7e>
      hadc->Instance->CHSELR &= ~ADC_CHSELR_CHANNEL(sConfig->Channel);
 8007404:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8007406:	4391      	bics	r1, r2
 8007408:	62a9      	str	r1, [r5, #40]	; 0x28
      if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 800740a:	2f02      	cmp	r7, #2
 800740c:	d8d7      	bhi.n	80073be <HAL_ADC_ConfigChannel+0x66>
        ADC->CCR &= ~ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 800740e:	4a0c      	ldr	r2, [pc, #48]	; (8007440 <HAL_ADC_ConfigChannel+0xe8>)
 8007410:	6811      	ldr	r1, [r2, #0]
 8007412:	2b10      	cmp	r3, #16
 8007414:	d00a      	beq.n	800742c <HAL_ADC_ConfigChannel+0xd4>
 8007416:	3b11      	subs	r3, #17
 8007418:	1e58      	subs	r0, r3, #1
 800741a:	4183      	sbcs	r3, r0
 800741c:	480b      	ldr	r0, [pc, #44]	; (800744c <HAL_ADC_ConfigChannel+0xf4>)
 800741e:	425b      	negs	r3, r3
 8007420:	4003      	ands	r3, r0
 8007422:	480b      	ldr	r0, [pc, #44]	; (8007450 <HAL_ADC_ConfigChannel+0xf8>)
 8007424:	181b      	adds	r3, r3, r0
 8007426:	400b      	ands	r3, r1
 8007428:	6013      	str	r3, [r2, #0]
 800742a:	e7c8      	b.n	80073be <HAL_ADC_ConfigChannel+0x66>
 800742c:	4b09      	ldr	r3, [pc, #36]	; (8007454 <HAL_ADC_ConfigChannel+0xfc>)
 800742e:	e7fa      	b.n	8007426 <HAL_ADC_ConfigChannel+0xce>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8007430:	2120      	movs	r1, #32
 8007432:	6c58      	ldr	r0, [r3, #68]	; 0x44
 8007434:	4301      	orrs	r1, r0
 8007436:	6459      	str	r1, [r3, #68]	; 0x44
    tmp_hal_status = HAL_ERROR;
 8007438:	0010      	movs	r0, r2
 800743a:	e7c1      	b.n	80073c0 <HAL_ADC_ConfigChannel+0x68>
 800743c:	00001001 	.word	0x00001001
 8007440:	40012708 	.word	0x40012708
 8007444:	20000030 	.word	0x20000030
 8007448:	000f4240 	.word	0x000f4240
 800744c:	ff400000 	.word	0xff400000
 8007450:	ffbfffff 	.word	0xffbfffff
 8007454:	ff7fffff 	.word	0xff7fffff

08007458 <HAL_ADCEx_Calibration_Start>:
  *         HAL_ADC_GetValue() (value on 7 bits: from DR[6;0]).
  * @param  hadc: ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef* hadc)
{
 8007458:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Process locked */
  __HAL_LOCK(hadc);
 800745a:	0006      	movs	r6, r0
 800745c:	3640      	adds	r6, #64	; 0x40
 800745e:	7833      	ldrb	r3, [r6, #0]
{
 8007460:	0004      	movs	r4, r0
  __HAL_LOCK(hadc);
 8007462:	2002      	movs	r0, #2
 8007464:	2b01      	cmp	r3, #1
 8007466:	d042      	beq.n	80074ee <HAL_ADCEx_Calibration_Start+0x96>
 8007468:	2301      	movs	r3, #1
  
  /* Calibration prerequisite: ADC must be disabled. */
  if (ADC_IS_ENABLE(hadc) == RESET)
 800746a:	2103      	movs	r1, #3
  __HAL_LOCK(hadc);
 800746c:	7033      	strb	r3, [r6, #0]
  if (ADC_IS_ENABLE(hadc) == RESET)
 800746e:	6823      	ldr	r3, [r4, #0]
 8007470:	689a      	ldr	r2, [r3, #8]
 8007472:	400a      	ands	r2, r1
 8007474:	2a01      	cmp	r2, #1
 8007476:	d105      	bne.n	8007484 <HAL_ADCEx_Calibration_Start+0x2c>
 8007478:	6819      	ldr	r1, [r3, #0]
 800747a:	4211      	tst	r1, r2
 800747c:	d138      	bne.n	80074f0 <HAL_ADCEx_Calibration_Start+0x98>
 800747e:	68da      	ldr	r2, [r3, #12]
 8007480:	0412      	lsls	r2, r2, #16
 8007482:	d435      	bmi.n	80074f0 <HAL_ADCEx_Calibration_Start+0x98>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State, 
 8007484:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8007486:	491d      	ldr	r1, [pc, #116]	; (80074fc <HAL_ADCEx_Calibration_Start+0xa4>)
 8007488:	4011      	ands	r1, r2
 800748a:	2202      	movs	r2, #2
 800748c:	430a      	orrs	r2, r1
    /*       available in data register and also transfered by DMA.           */
    /*       To not insert ADC calibration factor among ADC conversion data   */
    /*       in array variable, DMA transfer must be disabled during          */
    /*       calibration.                                                     */
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 800748e:	2103      	movs	r1, #3
    ADC_STATE_CLR_SET(hadc->State, 
 8007490:	6462      	str	r2, [r4, #68]	; 0x44
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 8007492:	68dd      	ldr	r5, [r3, #12]
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 8007494:	68da      	ldr	r2, [r3, #12]
 8007496:	438a      	bics	r2, r1
 8007498:	60da      	str	r2, [r3, #12]

    /* Start ADC calibration */
    hadc->Instance->CR |= ADC_CR_ADCAL;
 800749a:	2280      	movs	r2, #128	; 0x80
 800749c:	6899      	ldr	r1, [r3, #8]
 800749e:	0612      	lsls	r2, r2, #24
 80074a0:	430a      	orrs	r2, r1
 80074a2:	609a      	str	r2, [r3, #8]

    tickstart = HAL_GetTick();  
 80074a4:	f7ff fdba 	bl	800701c <HAL_GetTick>
 80074a8:	0007      	movs	r7, r0

    /* Wait for calibration completion */
    while(HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADCAL))
 80074aa:	6823      	ldr	r3, [r4, #0]
 80074ac:	689a      	ldr	r2, [r3, #8]
 80074ae:	2a00      	cmp	r2, #0
 80074b0:	db0e      	blt.n	80074d0 <HAL_ADCEx_Calibration_Start+0x78>
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 80074b2:	2203      	movs	r2, #3
        return HAL_ERROR;
      }
    }
    
    /* Restore ADC DMA transfer request after calibration */
    SET_BIT(hadc->Instance->CFGR1, backup_setting_adc_dma_transfer);
 80074b4:	68d9      	ldr	r1, [r3, #12]
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 80074b6:	4015      	ands	r5, r2
    SET_BIT(hadc->Instance->CFGR1, backup_setting_adc_dma_transfer);
 80074b8:	430d      	orrs	r5, r1
 80074ba:	60dd      	str	r5, [r3, #12]

    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 80074bc:	6c63      	ldr	r3, [r4, #68]	; 0x44
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80074be:	2000      	movs	r0, #0
    ADC_STATE_CLR_SET(hadc->State,
 80074c0:	4393      	bics	r3, r2
 80074c2:	001a      	movs	r2, r3
 80074c4:	2301      	movs	r3, #1
 80074c6:	4313      	orrs	r3, r2
 80074c8:	6463      	str	r3, [r4, #68]	; 0x44
    
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80074ca:	2300      	movs	r3, #0
 80074cc:	7033      	strb	r3, [r6, #0]
  
  /* Return function status */
  return tmp_hal_status;
 80074ce:	e00e      	b.n	80074ee <HAL_ADCEx_Calibration_Start+0x96>
      if((HAL_GetTick() - tickstart) > ADC_CALIBRATION_TIMEOUT)
 80074d0:	f7ff fda4 	bl	800701c <HAL_GetTick>
 80074d4:	1bc0      	subs	r0, r0, r7
 80074d6:	2802      	cmp	r0, #2
 80074d8:	d9e7      	bls.n	80074aa <HAL_ADCEx_Calibration_Start+0x52>
        ADC_STATE_CLR_SET(hadc->State,
 80074da:	2212      	movs	r2, #18
 80074dc:	6c63      	ldr	r3, [r4, #68]	; 0x44
        return HAL_ERROR;
 80074de:	2001      	movs	r0, #1
        ADC_STATE_CLR_SET(hadc->State,
 80074e0:	4393      	bics	r3, r2
 80074e2:	001a      	movs	r2, r3
 80074e4:	2310      	movs	r3, #16
 80074e6:	4313      	orrs	r3, r2
 80074e8:	6463      	str	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hadc);
 80074ea:	2300      	movs	r3, #0
 80074ec:	7033      	strb	r3, [r6, #0]
}
 80074ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80074f0:	2320      	movs	r3, #32
 80074f2:	6c62      	ldr	r2, [r4, #68]	; 0x44
    tmp_hal_status = HAL_ERROR;
 80074f4:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80074f6:	4313      	orrs	r3, r2
 80074f8:	6463      	str	r3, [r4, #68]	; 0x44
 80074fa:	e7e6      	b.n	80074ca <HAL_ADCEx_Calibration_Start+0x72>
 80074fc:	fffffefd 	.word	0xfffffefd

08007500 <HAL_NVIC_SetPriority>:
  *         with stm32f0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0 based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8007500:	b530      	push	{r4, r5, lr}
 8007502:	25ff      	movs	r5, #255	; 0xff
 8007504:	2403      	movs	r4, #3
 8007506:	002a      	movs	r2, r5
 8007508:	b2c3      	uxtb	r3, r0
 800750a:	401c      	ands	r4, r3
 800750c:	00e4      	lsls	r4, r4, #3
 800750e:	40a2      	lsls	r2, r4
 8007510:	0189      	lsls	r1, r1, #6
 8007512:	4029      	ands	r1, r5
 8007514:	43d2      	mvns	r2, r2
 8007516:	40a1      	lsls	r1, r4
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8007518:	2800      	cmp	r0, #0
 800751a:	da0b      	bge.n	8007534 <HAL_NVIC_SetPriority+0x34>
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800751c:	200f      	movs	r0, #15
 800751e:	4003      	ands	r3, r0
 8007520:	3b08      	subs	r3, #8
 8007522:	480a      	ldr	r0, [pc, #40]	; (800754c <HAL_NVIC_SetPriority+0x4c>)
 8007524:	089b      	lsrs	r3, r3, #2
 8007526:	009b      	lsls	r3, r3, #2
 8007528:	181b      	adds	r3, r3, r0
 800752a:	69d8      	ldr	r0, [r3, #28]
 800752c:	4002      	ands	r2, r0
 800752e:	4311      	orrs	r1, r2
 8007530:	61d9      	str	r1, [r3, #28]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
}
 8007532:	bd30      	pop	{r4, r5, pc}
 8007534:	4b06      	ldr	r3, [pc, #24]	; (8007550 <HAL_NVIC_SetPriority+0x50>)
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8007536:	0880      	lsrs	r0, r0, #2
 8007538:	0080      	lsls	r0, r0, #2
 800753a:	18c0      	adds	r0, r0, r3
 800753c:	23c0      	movs	r3, #192	; 0xc0
 800753e:	009b      	lsls	r3, r3, #2
 8007540:	58c4      	ldr	r4, [r0, r3]
 8007542:	4022      	ands	r2, r4
 8007544:	4311      	orrs	r1, r2
 8007546:	50c1      	str	r1, [r0, r3]
 8007548:	e7f3      	b.n	8007532 <HAL_NVIC_SetPriority+0x32>
 800754a:	46c0      	nop			; (mov r8, r8)
 800754c:	e000ed00 	.word	0xe000ed00
 8007550:	e000e100 	.word	0xe000e100

08007554 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8007554:	231f      	movs	r3, #31
 8007556:	4018      	ands	r0, r3
 8007558:	3b1e      	subs	r3, #30
 800755a:	4083      	lsls	r3, r0
 800755c:	4a01      	ldr	r2, [pc, #4]	; (8007564 <HAL_NVIC_EnableIRQ+0x10>)
 800755e:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8007560:	4770      	bx	lr
 8007562:	46c0      	nop			; (mov r8, r8)
 8007564:	e000e100 	.word	0xe000e100

08007568 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8007568:	4a09      	ldr	r2, [pc, #36]	; (8007590 <HAL_SYSTICK_Config+0x28>)
 800756a:	1e43      	subs	r3, r0, #1
  {
    return (1UL);                                                   /* Reload value impossible */
 800756c:	2001      	movs	r0, #1
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800756e:	4293      	cmp	r3, r2
 8007570:	d80d      	bhi.n	800758e <HAL_SYSTICK_Config+0x26>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8007572:	21c0      	movs	r1, #192	; 0xc0
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8007574:	4a07      	ldr	r2, [pc, #28]	; (8007594 <HAL_SYSTICK_Config+0x2c>)
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8007576:	4808      	ldr	r0, [pc, #32]	; (8007598 <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8007578:	6053      	str	r3, [r2, #4]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800757a:	6a03      	ldr	r3, [r0, #32]
 800757c:	0609      	lsls	r1, r1, #24
 800757e:	021b      	lsls	r3, r3, #8
 8007580:	0a1b      	lsrs	r3, r3, #8
 8007582:	430b      	orrs	r3, r1
 8007584:	6203      	str	r3, [r0, #32]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8007586:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8007588:	2307      	movs	r3, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800758a:	6090      	str	r0, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800758c:	6013      	str	r3, [r2, #0]
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 800758e:	4770      	bx	lr
 8007590:	00ffffff 	.word	0x00ffffff
 8007594:	e000e010 	.word	0xe000e010
 8007598:	e000ed00 	.word	0xe000ed00

0800759c <CRC_Handle_8>:
  * @param  pBuffer: pointer to the input data buffer
  * @param  BufferLength: input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 800759c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800759e:	000e      	movs	r6, r1
  uint32_t i = 0U; /* input data buffer index */
  
   /* Processing time optimization: 4 bytes are entered in a row with a single word write,
    * last bytes must be carefully fed to the CRC calculator to ensure a correct type
    * handling by the IP */
   for(i = 0U; i < (BufferLength/4U); i++)
 80075a0:	0895      	lsrs	r5, r2, #2
 80075a2:	00ad      	lsls	r5, r5, #2
 80075a4:	186b      	adds	r3, r5, r1
 80075a6:	9301      	str	r3, [sp, #4]
 80075a8:	6803      	ldr	r3, [r0, #0]
 80075aa:	9c01      	ldr	r4, [sp, #4]
 80075ac:	42a6      	cmp	r6, r4
 80075ae:	d107      	bne.n	80075c0 <CRC_Handle_8+0x24>
   {
      hcrc->Instance->DR = ((uint32_t)pBuffer[4U*i]<<24U) | ((uint32_t)pBuffer[4U*i+1]<<16U) | ((uint32_t)pBuffer[4U*i+2]<<8U) | (uint32_t)pBuffer[4U*i+3];      
   }
   /* last bytes specific handling */
   if ((BufferLength%4U) != 0U)
 80075b0:	2403      	movs	r4, #3
 80075b2:	4022      	ands	r2, r4
 80075b4:	d019      	beq.n	80075ea <CRC_Handle_8+0x4e>
   {
     if  (BufferLength%4U == 1U)
 80075b6:	2a01      	cmp	r2, #1
 80075b8:	d10f      	bne.n	80075da <CRC_Handle_8+0x3e>
     {
       *(uint8_t volatile*) (&hcrc->Instance->DR) = pBuffer[4*i];
 80075ba:	5d4a      	ldrb	r2, [r1, r5]
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
     }
     if  (BufferLength%4U == 3U)
     {
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
       *(uint8_t volatile*) (&hcrc->Instance->DR) = pBuffer[4*i+2];       
 80075bc:	701a      	strb	r2, [r3, #0]
 80075be:	e014      	b.n	80075ea <CRC_Handle_8+0x4e>
      hcrc->Instance->DR = ((uint32_t)pBuffer[4U*i]<<24U) | ((uint32_t)pBuffer[4U*i+1]<<16U) | ((uint32_t)pBuffer[4U*i+2]<<8U) | (uint32_t)pBuffer[4U*i+3];      
 80075c0:	7834      	ldrb	r4, [r6, #0]
 80075c2:	7877      	ldrb	r7, [r6, #1]
 80075c4:	0624      	lsls	r4, r4, #24
 80075c6:	043f      	lsls	r7, r7, #16
 80075c8:	433c      	orrs	r4, r7
 80075ca:	78f7      	ldrb	r7, [r6, #3]
 80075cc:	433c      	orrs	r4, r7
 80075ce:	78b7      	ldrb	r7, [r6, #2]
 80075d0:	3604      	adds	r6, #4
 80075d2:	023f      	lsls	r7, r7, #8
 80075d4:	433c      	orrs	r4, r7
 80075d6:	601c      	str	r4, [r3, #0]
 80075d8:	e7e7      	b.n	80075aa <CRC_Handle_8+0xe>
 80075da:	186c      	adds	r4, r5, r1
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
 80075dc:	5d49      	ldrb	r1, [r1, r5]
 80075de:	0209      	lsls	r1, r1, #8
     if  (BufferLength%4U == 2U)
 80075e0:	2a02      	cmp	r2, #2
 80075e2:	d105      	bne.n	80075f0 <CRC_Handle_8+0x54>
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
 80075e4:	7862      	ldrb	r2, [r4, #1]
 80075e6:	430a      	orrs	r2, r1
 80075e8:	801a      	strh	r2, [r3, #0]
     }
   }
  
  /* Return the CRC computed value */ 
  return hcrc->Instance->DR;
 80075ea:	6803      	ldr	r3, [r0, #0]
 80075ec:	6818      	ldr	r0, [r3, #0]
}
 80075ee:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
 80075f0:	7862      	ldrb	r2, [r4, #1]
 80075f2:	430a      	orrs	r2, r1
 80075f4:	801a      	strh	r2, [r3, #0]
       *(uint8_t volatile*) (&hcrc->Instance->DR) = pBuffer[4*i+2];       
 80075f6:	78a2      	ldrb	r2, [r4, #2]
 80075f8:	e7e0      	b.n	80075bc <CRC_Handle_8+0x20>

080075fa <CRC_Handle_16>:
  * @param  pBuffer: pointer to the input data buffer
  * @param  BufferLength: input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */  
static uint32_t CRC_Handle_16(CRC_HandleTypeDef *hcrc, uint16_t pBuffer[], uint32_t BufferLength)
{
 80075fa:	b5f0      	push	{r4, r5, r6, r7, lr}
 80075fc:	000d      	movs	r5, r1
  uint32_t i = 0U;  /* input data buffer index */
  
  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure 
   * a correct type handling by the IP */
  for(i = 0U; i < (BufferLength/2U); i++)
 80075fe:	2600      	movs	r6, #0
 8007600:	6800      	ldr	r0, [r0, #0]
 8007602:	0854      	lsrs	r4, r2, #1
 8007604:	42b4      	cmp	r4, r6
 8007606:	d106      	bne.n	8007616 <CRC_Handle_16+0x1c>
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U*i]<<16U) | (uint32_t)pBuffer[2U*i+1];     
  }
  if ((BufferLength%2U) != 0U)
 8007608:	07d3      	lsls	r3, r2, #31
 800760a:	d502      	bpl.n	8007612 <CRC_Handle_16+0x18>
  {
       *(uint16_t volatile*) (&hcrc->Instance->DR) = pBuffer[2*i]; 
 800760c:	00a4      	lsls	r4, r4, #2
 800760e:	5a63      	ldrh	r3, [r4, r1]
 8007610:	8003      	strh	r3, [r0, #0]
  }
   
  /* Return the CRC computed value */ 
  return hcrc->Instance->DR;
 8007612:	6800      	ldr	r0, [r0, #0]
}
 8007614:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U*i]<<16U) | (uint32_t)pBuffer[2U*i+1];     
 8007616:	882b      	ldrh	r3, [r5, #0]
 8007618:	886f      	ldrh	r7, [r5, #2]
 800761a:	041b      	lsls	r3, r3, #16
 800761c:	433b      	orrs	r3, r7
 800761e:	6003      	str	r3, [r0, #0]
  for(i = 0U; i < (BufferLength/2U); i++)
 8007620:	3601      	adds	r6, #1
 8007622:	3504      	adds	r5, #4
 8007624:	e7ee      	b.n	8007604 <CRC_Handle_16+0xa>

08007626 <HAL_CRC_Init>:
{
 8007626:	b510      	push	{r4, lr}
 8007628:	1e04      	subs	r4, r0, #0
  if(hcrc == NULL)
 800762a:	d101      	bne.n	8007630 <HAL_CRC_Init+0xa>
    return HAL_ERROR;
 800762c:	2001      	movs	r0, #1
}
 800762e:	bd10      	pop	{r4, pc}
  if(hcrc->State == HAL_CRC_STATE_RESET)
 8007630:	7f43      	ldrb	r3, [r0, #29]
 8007632:	b2db      	uxtb	r3, r3
 8007634:	2b00      	cmp	r3, #0
 8007636:	d102      	bne.n	800763e <HAL_CRC_Init+0x18>
    hcrc->Lock = HAL_UNLOCKED;
 8007638:	7703      	strb	r3, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 800763a:	f7fe fcc7 	bl	8005fcc <HAL_CRC_MspInit>
  hcrc->State = HAL_CRC_STATE_BUSY; 
 800763e:	2302      	movs	r3, #2
  if (HAL_CRCEx_Init(hcrc) != HAL_OK)
 8007640:	0020      	movs	r0, r4
  hcrc->State = HAL_CRC_STATE_BUSY; 
 8007642:	7763      	strb	r3, [r4, #29]
  if (HAL_CRCEx_Init(hcrc) != HAL_OK)
 8007644:	f000 f870 	bl	8007728 <HAL_CRCEx_Init>
 8007648:	2800      	cmp	r0, #0
 800764a:	d1ef      	bne.n	800762c <HAL_CRC_Init+0x6>
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 800764c:	7962      	ldrb	r2, [r4, #5]
 800764e:	6823      	ldr	r3, [r4, #0]
 8007650:	2a00      	cmp	r2, #0
 8007652:	d110      	bne.n	8007676 <HAL_CRC_Init+0x50>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);  
 8007654:	3a01      	subs	r2, #1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 8007656:	2160      	movs	r1, #96	; 0x60
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 8007658:	611a      	str	r2, [r3, #16]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 800765a:	689a      	ldr	r2, [r3, #8]
 800765c:	438a      	bics	r2, r1
 800765e:	6961      	ldr	r1, [r4, #20]
 8007660:	430a      	orrs	r2, r1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);  
 8007662:	2180      	movs	r1, #128	; 0x80
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 8007664:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);  
 8007666:	689a      	ldr	r2, [r3, #8]
 8007668:	438a      	bics	r2, r1
 800766a:	69a1      	ldr	r1, [r4, #24]
 800766c:	430a      	orrs	r2, r1
 800766e:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 8007670:	2301      	movs	r3, #1
 8007672:	7763      	strb	r3, [r4, #29]
  return HAL_OK;
 8007674:	e7db      	b.n	800762e <HAL_CRC_Init+0x8>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 8007676:	6922      	ldr	r2, [r4, #16]
 8007678:	e7ed      	b.n	8007656 <HAL_CRC_Init+0x30>

0800767a <HAL_CRC_Calculate>:
{
 800767a:	b570      	push	{r4, r5, r6, lr}
 800767c:	2502      	movs	r5, #2
  __HAL_LOCK(hcrc); 
 800767e:	7f03      	ldrb	r3, [r0, #28]
{
 8007680:	0004      	movs	r4, r0
  __HAL_LOCK(hcrc); 
 8007682:	0028      	movs	r0, r5
 8007684:	2b01      	cmp	r3, #1
 8007686:	d01b      	beq.n	80076c0 <HAL_CRC_Calculate+0x46>
 8007688:	2301      	movs	r3, #1
  __HAL_CRC_DR_RESET(hcrc);
 800768a:	6820      	ldr	r0, [r4, #0]
  hcrc->State = HAL_CRC_STATE_BUSY;
 800768c:	7765      	strb	r5, [r4, #29]
  __HAL_CRC_DR_RESET(hcrc);
 800768e:	6885      	ldr	r5, [r0, #8]
  __HAL_LOCK(hcrc); 
 8007690:	7723      	strb	r3, [r4, #28]
  __HAL_CRC_DR_RESET(hcrc);
 8007692:	432b      	orrs	r3, r5
 8007694:	6083      	str	r3, [r0, #8]
  switch (hcrc->InputDataFormat)
 8007696:	6a23      	ldr	r3, [r4, #32]
 8007698:	2b02      	cmp	r3, #2
 800769a:	d015      	beq.n	80076c8 <HAL_CRC_Calculate+0x4e>
 800769c:	2b03      	cmp	r3, #3
 800769e:	d006      	beq.n	80076ae <HAL_CRC_Calculate+0x34>
  uint32_t temp = 0U;  /* CRC output (read from hcrc->Instance->DR register) */
 80076a0:	2000      	movs	r0, #0
  switch (hcrc->InputDataFormat)
 80076a2:	2b01      	cmp	r3, #1
 80076a4:	d108      	bne.n	80076b8 <HAL_CRC_Calculate+0x3e>
      temp = CRC_Handle_8(hcrc, (uint8_t*)pBuffer, BufferLength);
 80076a6:	0020      	movs	r0, r4
 80076a8:	f7ff ff78 	bl	800759c <CRC_Handle_8>
      break;
 80076ac:	e004      	b.n	80076b8 <HAL_CRC_Calculate+0x3e>
 80076ae:	0092      	lsls	r2, r2, #2
 80076b0:	188a      	adds	r2, r1, r2
      for(index = 0U; index < BufferLength; index++)
 80076b2:	4291      	cmp	r1, r2
 80076b4:	d105      	bne.n	80076c2 <HAL_CRC_Calculate+0x48>
      temp = hcrc->Instance->DR;
 80076b6:	6800      	ldr	r0, [r0, #0]
  hcrc->State = HAL_CRC_STATE_READY; 
 80076b8:	2301      	movs	r3, #1
 80076ba:	7763      	strb	r3, [r4, #29]
  __HAL_UNLOCK(hcrc);
 80076bc:	2300      	movs	r3, #0
 80076be:	7723      	strb	r3, [r4, #28]
}
 80076c0:	bd70      	pop	{r4, r5, r6, pc}
        hcrc->Instance->DR = pBuffer[index];
 80076c2:	c908      	ldmia	r1!, {r3}
 80076c4:	6003      	str	r3, [r0, #0]
 80076c6:	e7f4      	b.n	80076b2 <HAL_CRC_Calculate+0x38>
      temp = CRC_Handle_16(hcrc, (uint16_t*)pBuffer, BufferLength);
 80076c8:	0020      	movs	r0, r4
 80076ca:	f7ff ff96 	bl	80075fa <CRC_Handle_16>
      break;
 80076ce:	e7f3      	b.n	80076b8 <HAL_CRC_Calculate+0x3e>

080076d0 <HAL_CRCEx_Polynomial_Set>:
  *          @arg CRC_POLYLENGTH_16B: 16-bit long CRC (generating polynomial of degree 16)
  *          @arg CRC_POLYLENGTH_32B: 32-bit long CRC (generating polynomial of degree 32)                
  * @retval HAL status
  */                                   
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
 80076d0:	b530      	push	{r4, r5, lr}
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 80076d2:	231f      	movs	r3, #31
{
 80076d4:	0004      	movs	r4, r0
   * definition. HAL_ERROR is reported if Pol degree is 
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while (((Pol & (1U << msb)) == 0U) && (msb-- > 0U))
 80076d6:	2001      	movs	r0, #1
 80076d8:	0005      	movs	r5, r0
 80076da:	409d      	lsls	r5, r3
 80076dc:	4229      	tst	r1, r5
 80076de:	d109      	bne.n	80076f4 <HAL_CRCEx_Polynomial_Set+0x24>
 80076e0:	3b01      	subs	r3, #1
 80076e2:	d2f9      	bcs.n	80076d8 <HAL_CRCEx_Polynomial_Set+0x8>
  {}

  switch (PolyLength)
 80076e4:	2a10      	cmp	r2, #16
 80076e6:	d003      	beq.n	80076f0 <HAL_CRCEx_Polynomial_Set+0x20>
 80076e8:	2a18      	cmp	r2, #24
 80076ea:	d001      	beq.n	80076f0 <HAL_CRCEx_Polynomial_Set+0x20>
 80076ec:	2a08      	cmp	r2, #8
 80076ee:	d112      	bne.n	8007716 <HAL_CRCEx_Polynomial_Set+0x46>
  {
    case CRC_POLYLENGTH_7B:
      if (msb >= HAL_CRC_LENGTH_7B)
      {
        return  HAL_ERROR;
 80076f0:	2001      	movs	r0, #1
 80076f2:	e00c      	b.n	800770e <HAL_CRCEx_Polynomial_Set+0x3e>
  switch (PolyLength)
 80076f4:	2a10      	cmp	r2, #16
 80076f6:	d00b      	beq.n	8007710 <HAL_CRCEx_Polynomial_Set+0x40>
 80076f8:	2a18      	cmp	r2, #24
 80076fa:	d005      	beq.n	8007708 <HAL_CRCEx_Polynomial_Set+0x38>
 80076fc:	2a08      	cmp	r2, #8
 80076fe:	d10a      	bne.n	8007716 <HAL_CRCEx_Polynomial_Set+0x46>
        return  HAL_ERROR;
 8007700:	2001      	movs	r0, #1
      { 
        return  HAL_ERROR;
      }
      break;
    case CRC_POLYLENGTH_16B:
      if (msb >= HAL_CRC_LENGTH_16B)
 8007702:	2b0f      	cmp	r3, #15
 8007704:	d907      	bls.n	8007716 <HAL_CRCEx_Polynomial_Set+0x46>
 8007706:	e002      	b.n	800770e <HAL_CRCEx_Polynomial_Set+0x3e>
        return  HAL_ERROR;
 8007708:	2001      	movs	r0, #1
      if (msb >= HAL_CRC_LENGTH_7B)
 800770a:	2b06      	cmp	r3, #6
 800770c:	d903      	bls.n	8007716 <HAL_CRCEx_Polynomial_Set+0x46>
  /* set generating polynomial size */
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);  
  
  /* Return function status */
  return HAL_OK;
}
 800770e:	bd30      	pop	{r4, r5, pc}
        return  HAL_ERROR;
 8007710:	2001      	movs	r0, #1
      if (msb >= HAL_CRC_LENGTH_8B)
 8007712:	2b07      	cmp	r3, #7
 8007714:	d8fb      	bhi.n	800770e <HAL_CRCEx_Polynomial_Set+0x3e>
  WRITE_REG(hcrc->Instance->POL, Pol);
 8007716:	6820      	ldr	r0, [r4, #0]
 8007718:	6141      	str	r1, [r0, #20]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);  
 800771a:	2118      	movs	r1, #24
 800771c:	6883      	ldr	r3, [r0, #8]
 800771e:	438b      	bics	r3, r1
 8007720:	431a      	orrs	r2, r3
 8007722:	6082      	str	r2, [r0, #8]
 8007724:	2000      	movs	r0, #0
 8007726:	e7f2      	b.n	800770e <HAL_CRCEx_Polynomial_Set+0x3e>

08007728 <HAL_CRCEx_Init>:
{
 8007728:	b510      	push	{r4, lr}
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 800772a:	7903      	ldrb	r3, [r0, #4]
 800772c:	2b00      	cmp	r3, #0
 800772e:	d108      	bne.n	8007742 <HAL_CRCEx_Init+0x1a>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);  
 8007730:	6802      	ldr	r2, [r0, #0]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 8007732:	2018      	movs	r0, #24
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);  
 8007734:	4907      	ldr	r1, [pc, #28]	; (8007754 <HAL_CRCEx_Init+0x2c>)
 8007736:	6151      	str	r1, [r2, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 8007738:	6891      	ldr	r1, [r2, #8]
 800773a:	4381      	bics	r1, r0
   return HAL_OK;
 800773c:	0018      	movs	r0, r3
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 800773e:	6091      	str	r1, [r2, #8]
}
 8007740:	bd10      	pop	{r4, pc}
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 8007742:	68c2      	ldr	r2, [r0, #12]
 8007744:	6881      	ldr	r1, [r0, #8]
 8007746:	f7ff ffc3 	bl	80076d0 <HAL_CRCEx_Polynomial_Set>
 800774a:	1e43      	subs	r3, r0, #1
 800774c:	4198      	sbcs	r0, r3
      return HAL_ERROR;
 800774e:	b2c0      	uxtb	r0, r0
 8007750:	e7f6      	b.n	8007740 <HAL_CRCEx_Init+0x18>
 8007752:	46c0      	nop			; (mov r8, r8)
 8007754:	04c11db7 	.word	0x04c11db7

08007758 <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
 8007758:	b570      	push	{r4, r5, r6, lr}
 800775a:	0004      	movs	r4, r0
  uint32_t tmp = 0U;
  
  /* Check the DMA handle allocation */
  if(NULL == hdma)
  {
    return HAL_ERROR;
 800775c:	2501      	movs	r5, #1
  if(NULL == hdma)
 800775e:	2800      	cmp	r0, #0
 8007760:	d028      	beq.n	80077b4 <HAL_DMA_Init+0x5c>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
  
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8007762:	2302      	movs	r3, #2
 8007764:	1c86      	adds	r6, r0, #2

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 8007766:	6800      	ldr	r0, [r0, #0]
  hdma->State = HAL_DMA_STATE_BUSY;
 8007768:	77f3      	strb	r3, [r6, #31]
  tmp = hdma->Instance->CCR;
 800776a:	6802      	ldr	r2, [r0, #0]
  
  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 800776c:	4b12      	ldr	r3, [pc, #72]	; (80077b8 <HAL_DMA_Init+0x60>)
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 800776e:	68a1      	ldr	r1, [r4, #8]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8007770:	401a      	ands	r2, r3
  tmp |=  hdma->Init.Direction        |
 8007772:	6863      	ldr	r3, [r4, #4]
 8007774:	430b      	orrs	r3, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8007776:	68e1      	ldr	r1, [r4, #12]
 8007778:	430b      	orrs	r3, r1
 800777a:	6921      	ldr	r1, [r4, #16]
 800777c:	430b      	orrs	r3, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800777e:	6961      	ldr	r1, [r4, #20]
 8007780:	430b      	orrs	r3, r1
 8007782:	69a1      	ldr	r1, [r4, #24]
 8007784:	430b      	orrs	r3, r1
          hdma->Init.Mode                | hdma->Init.Priority;
 8007786:	69e1      	ldr	r1, [r4, #28]
 8007788:	430b      	orrs	r3, r1
  tmp |=  hdma->Init.Direction        |
 800778a:	4313      	orrs	r3, r2

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;  
 800778c:	6003      	str	r3, [r0, #0]
    hdma->DmaBaseAddress = DMA2;
  }
#else
  /* calculation of the channel index */
  /* DMA1 */
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 800778e:	4b0b      	ldr	r3, [pc, #44]	; (80077bc <HAL_DMA_Init+0x64>)
 8007790:	2114      	movs	r1, #20
 8007792:	18c0      	adds	r0, r0, r3
 8007794:	f7fe f90e 	bl	80059b4 <__udivsi3>
  hdma->DmaBaseAddress = DMA1;
 8007798:	4b09      	ldr	r3, [pc, #36]	; (80077c0 <HAL_DMA_Init+0x68>)
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 800779a:	0080      	lsls	r0, r0, #2
  hdma->DmaBaseAddress = DMA1;
 800779c:	63e3      	str	r3, [r4, #60]	; 0x3c
  hdma->XferCpltCallback = NULL;
 800779e:	2300      	movs	r3, #0
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80077a0:	6420      	str	r0, [r4, #64]	; 0x40
  hdma->XferCpltCallback = NULL;
 80077a2:	62a3      	str	r3, [r4, #40]	; 0x28
  hdma->XferHalfCpltCallback = NULL;
 80077a4:	62e3      	str	r3, [r4, #44]	; 0x2c
  hdma->XferErrorCallback = NULL;
 80077a6:	6323      	str	r3, [r4, #48]	; 0x30
  hdma->XferAbortCallback = NULL;
 80077a8:	6363      	str	r3, [r4, #52]	; 0x34
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80077aa:	63a3      	str	r3, [r4, #56]	; 0x38
  hdma->State = HAL_DMA_STATE_READY;
 80077ac:	77f5      	strb	r5, [r6, #31]
  hdma->Lock = HAL_UNLOCKED;
 80077ae:	1964      	adds	r4, r4, r5
  return HAL_OK;
 80077b0:	001d      	movs	r5, r3
  hdma->Lock = HAL_UNLOCKED;
 80077b2:	77e3      	strb	r3, [r4, #31]
}  
 80077b4:	0028      	movs	r0, r5
 80077b6:	bd70      	pop	{r4, r5, r6, pc}
 80077b8:	ffffc00f 	.word	0xffffc00f
 80077bc:	bffdfff8 	.word	0xbffdfff8
 80077c0:	40020000 	.word	0x40020000

080077c4 <HAL_DMA_DeInit>:
{
 80077c4:	b570      	push	{r4, r5, r6, lr}
 80077c6:	0004      	movs	r4, r0
 80077c8:	2601      	movs	r6, #1
  if(NULL == hdma)
 80077ca:	2800      	cmp	r0, #0
 80077cc:	d019      	beq.n	8007802 <HAL_DMA_DeInit+0x3e>
  hdma->Instance->CCR  = 0U;
 80077ce:	2500      	movs	r5, #0
  hdma->Instance->CCR &= ~DMA_CCR_EN;
 80077d0:	6800      	ldr	r0, [r0, #0]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80077d2:	2114      	movs	r1, #20
  hdma->Instance->CCR &= ~DMA_CCR_EN;
 80077d4:	6803      	ldr	r3, [r0, #0]
 80077d6:	43b3      	bics	r3, r6
 80077d8:	6003      	str	r3, [r0, #0]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80077da:	4b0b      	ldr	r3, [pc, #44]	; (8007808 <HAL_DMA_DeInit+0x44>)
  hdma->Instance->CCR  = 0U;
 80077dc:	6005      	str	r5, [r0, #0]
  hdma->Instance->CNDTR = 0U;
 80077de:	6045      	str	r5, [r0, #4]
  hdma->Instance->CPAR  = 0U;
 80077e0:	6085      	str	r5, [r0, #8]
  hdma->Instance->CMAR = 0U;
 80077e2:	60c5      	str	r5, [r0, #12]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80077e4:	18c0      	adds	r0, r0, r3
 80077e6:	f7fe f8e5 	bl	80059b4 <__udivsi3>
 80077ea:	0080      	lsls	r0, r0, #2
  hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 80077ec:	4086      	lsls	r6, r0
  hdma->DmaBaseAddress = DMA1;
 80077ee:	4b07      	ldr	r3, [pc, #28]	; (800780c <HAL_DMA_DeInit+0x48>)
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80077f0:	6420      	str	r0, [r4, #64]	; 0x40
  hdma->DmaBaseAddress = DMA1;
 80077f2:	63e3      	str	r3, [r4, #60]	; 0x3c
  hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 80077f4:	605e      	str	r6, [r3, #4]
  return HAL_OK;
 80077f6:	002e      	movs	r6, r5
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80077f8:	63a5      	str	r5, [r4, #56]	; 0x38
  hdma->State = HAL_DMA_STATE_RESET;
 80077fa:	1ca3      	adds	r3, r4, #2
  __HAL_UNLOCK(hdma);
 80077fc:	3401      	adds	r4, #1
  hdma->State = HAL_DMA_STATE_RESET;
 80077fe:	77dd      	strb	r5, [r3, #31]
  __HAL_UNLOCK(hdma);
 8007800:	77e5      	strb	r5, [r4, #31]
}
 8007802:	0030      	movs	r0, r6
 8007804:	bd70      	pop	{r4, r5, r6, pc}
 8007806:	46c0      	nop			; (mov r8, r8)
 8007808:	bffdfff8 	.word	0xbffdfff8
 800780c:	40020000 	.word	0x40020000

08007810 <HAL_DMA_Start_IT>:
{
 8007810:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(hdma);
 8007812:	1c44      	adds	r4, r0, #1
 8007814:	7fe6      	ldrb	r6, [r4, #31]
{
 8007816:	0005      	movs	r5, r0
  __HAL_LOCK(hdma);
 8007818:	2002      	movs	r0, #2
 800781a:	2e01      	cmp	r6, #1
 800781c:	d027      	beq.n	800786e <HAL_DMA_Start_IT+0x5e>
 800781e:	3801      	subs	r0, #1
 8007820:	77e0      	strb	r0, [r4, #31]
  if(HAL_DMA_STATE_READY == hdma->State)
 8007822:	1ca8      	adds	r0, r5, #2
 8007824:	7fc6      	ldrb	r6, [r0, #31]
 8007826:	4684      	mov	ip, r0
 8007828:	b2f6      	uxtb	r6, r6
 800782a:	2002      	movs	r0, #2
 800782c:	2700      	movs	r7, #0
 800782e:	2e01      	cmp	r6, #1
 8007830:	d128      	bne.n	8007884 <HAL_DMA_Start_IT+0x74>
  	hdma->State = HAL_DMA_STATE_BUSY;
 8007832:	4664      	mov	r4, ip
 8007834:	77e0      	strb	r0, [r4, #31]
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8007836:	682c      	ldr	r4, [r5, #0]
  	hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8007838:	63af      	str	r7, [r5, #56]	; 0x38
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 800783a:	6820      	ldr	r0, [r4, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 800783c:	6c2f      	ldr	r7, [r5, #64]	; 0x40
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 800783e:	43b0      	bics	r0, r6
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8007840:	40be      	lsls	r6, r7
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8007842:	6020      	str	r0, [r4, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8007844:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 8007846:	6046      	str	r6, [r0, #4]
  hdma->Instance->CNDTR = DataLength;
 8007848:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 800784a:	686b      	ldr	r3, [r5, #4]
 800784c:	6828      	ldr	r0, [r5, #0]
 800784e:	2b10      	cmp	r3, #16
 8007850:	d10e      	bne.n	8007870 <HAL_DMA_Start_IT+0x60>
    hdma->Instance->CPAR = DstAddress;
 8007852:	60a2      	str	r2, [r4, #8]
    hdma->Instance->CMAR = SrcAddress;
 8007854:	60e1      	str	r1, [r4, #12]
    if(NULL != hdma->XferHalfCpltCallback )
 8007856:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
      hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8007858:	6822      	ldr	r2, [r4, #0]
    if(NULL != hdma->XferHalfCpltCallback )
 800785a:	2b00      	cmp	r3, #0
 800785c:	d00b      	beq.n	8007876 <HAL_DMA_Start_IT+0x66>
      hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800785e:	230e      	movs	r3, #14
 8007860:	4313      	orrs	r3, r2
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 8007862:	6023      	str	r3, [r4, #0]
  	hdma->Instance->CCR |= DMA_CCR_EN;
 8007864:	2301      	movs	r3, #1
 8007866:	6802      	ldr	r2, [r0, #0]
 8007868:	4313      	orrs	r3, r2
 800786a:	6003      	str	r3, [r0, #0]
	HAL_StatusTypeDef status = HAL_OK;
 800786c:	2000      	movs	r0, #0
} 
 800786e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hdma->Instance->CPAR = SrcAddress;
 8007870:	60a1      	str	r1, [r4, #8]
    hdma->Instance->CMAR = DstAddress;
 8007872:	60e2      	str	r2, [r4, #12]
 8007874:	e7ef      	b.n	8007856 <HAL_DMA_Start_IT+0x46>
  		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
 8007876:	230a      	movs	r3, #10
 8007878:	4313      	orrs	r3, r2
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 800787a:	2204      	movs	r2, #4
  		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
 800787c:	6023      	str	r3, [r4, #0]
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 800787e:	6823      	ldr	r3, [r4, #0]
 8007880:	4393      	bics	r3, r2
 8007882:	e7ee      	b.n	8007862 <HAL_DMA_Start_IT+0x52>
    __HAL_UNLOCK(hdma); 
 8007884:	77e7      	strb	r7, [r4, #31]
 8007886:	e7f2      	b.n	800786e <HAL_DMA_Start_IT+0x5e>

08007888 <HAL_DMA_Abort>:
	 hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8007888:	210e      	movs	r1, #14
 800788a:	6803      	ldr	r3, [r0, #0]
{
 800788c:	b510      	push	{r4, lr}
	 hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800788e:	681a      	ldr	r2, [r3, #0]
	hdma->DmaBaseAddress->IFCR = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8007890:	6c04      	ldr	r4, [r0, #64]	; 0x40
	 hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8007892:	438a      	bics	r2, r1
 8007894:	601a      	str	r2, [r3, #0]
	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8007896:	2201      	movs	r2, #1
 8007898:	6819      	ldr	r1, [r3, #0]
 800789a:	4391      	bics	r1, r2
 800789c:	6019      	str	r1, [r3, #0]
	hdma->DmaBaseAddress->IFCR = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 800789e:	0011      	movs	r1, r2
 80078a0:	40a1      	lsls	r1, r4
 80078a2:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 80078a4:	6059      	str	r1, [r3, #4]
	hdma->State = HAL_DMA_STATE_READY; 
 80078a6:	1c83      	adds	r3, r0, #2
 80078a8:	77da      	strb	r2, [r3, #31]
	__HAL_UNLOCK(hdma);
 80078aa:	1883      	adds	r3, r0, r2
 80078ac:	2000      	movs	r0, #0
 80078ae:	77d8      	strb	r0, [r3, #31]
}
 80078b0:	bd10      	pop	{r4, pc}
	...

080078b4 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{ 
 80078b4:	b5f0      	push	{r4, r5, r6, r7, lr}
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
  
        temp = SYSCFG->EXTICR[position >> 2];
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80078b6:	4a56      	ldr	r2, [pc, #344]	; (8007a10 <HAL_GPIO_Init+0x15c>)
  while (((GPIO_Init->Pin) >> position) != RESET)
 80078b8:	680b      	ldr	r3, [r1, #0]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80078ba:	1882      	adds	r2, r0, r2
 80078bc:	1e54      	subs	r4, r2, #1
 80078be:	41a2      	sbcs	r2, r4
{ 
 80078c0:	b089      	sub	sp, #36	; 0x24
  while (((GPIO_Init->Pin) >> position) != RESET)
 80078c2:	9303      	str	r3, [sp, #12]
  uint32_t position = 0x00U;
 80078c4:	2300      	movs	r3, #0
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80078c6:	3204      	adds	r2, #4
 80078c8:	9205      	str	r2, [sp, #20]
  while (((GPIO_Init->Pin) >> position) != RESET)
 80078ca:	9a03      	ldr	r2, [sp, #12]
 80078cc:	40da      	lsrs	r2, r3
 80078ce:	d101      	bne.n	80078d4 <HAL_GPIO_Init+0x20>
      }
    }
    
    position++;
  } 
}
 80078d0:	b009      	add	sp, #36	; 0x24
 80078d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 80078d4:	2201      	movs	r2, #1
 80078d6:	409a      	lsls	r2, r3
 80078d8:	4694      	mov	ip, r2
 80078da:	4664      	mov	r4, ip
 80078dc:	9a03      	ldr	r2, [sp, #12]
 80078de:	4022      	ands	r2, r4
 80078e0:	9202      	str	r2, [sp, #8]
    if(iocurrent)
 80078e2:	d100      	bne.n	80078e6 <HAL_GPIO_Init+0x32>
 80078e4:	e092      	b.n	8007a0c <HAL_GPIO_Init+0x158>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
 80078e6:	684a      	ldr	r2, [r1, #4]
 80078e8:	9201      	str	r2, [sp, #4]
 80078ea:	2210      	movs	r2, #16
 80078ec:	9e01      	ldr	r6, [sp, #4]
 80078ee:	4396      	bics	r6, r2
 80078f0:	2e02      	cmp	r6, #2
 80078f2:	d10d      	bne.n	8007910 <HAL_GPIO_Init+0x5c>
        CLEAR_BIT(temp, 0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;      
 80078f4:	2407      	movs	r4, #7
 80078f6:	270f      	movs	r7, #15
 80078f8:	401c      	ands	r4, r3
 80078fa:	00a4      	lsls	r4, r4, #2
 80078fc:	40a7      	lsls	r7, r4
        temp = GPIOx->AFR[position >> 3];
 80078fe:	08da      	lsrs	r2, r3, #3
 8007900:	0092      	lsls	r2, r2, #2
 8007902:	1882      	adds	r2, r0, r2
 8007904:	6a15      	ldr	r5, [r2, #32]
        CLEAR_BIT(temp, 0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;      
 8007906:	43bd      	bics	r5, r7
        SET_BIT(temp, (uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));       
 8007908:	690f      	ldr	r7, [r1, #16]
 800790a:	40a7      	lsls	r7, r4
 800790c:	433d      	orrs	r5, r7
        GPIOx->AFR[position >> 3U] = temp;
 800790e:	6215      	str	r5, [r2, #32]
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
 8007910:	2203      	movs	r2, #3
 8007912:	0014      	movs	r4, r2
 8007914:	005d      	lsls	r5, r3, #1
 8007916:	40ac      	lsls	r4, r5
 8007918:	43e4      	mvns	r4, r4
      temp = GPIOx->MODER;
 800791a:	6807      	ldr	r7, [r0, #0]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800791c:	3e01      	subs	r6, #1
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
 800791e:	4027      	ands	r7, r4
 8007920:	9704      	str	r7, [sp, #16]
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8007922:	9f01      	ldr	r7, [sp, #4]
 8007924:	403a      	ands	r2, r7
 8007926:	40aa      	lsls	r2, r5
 8007928:	9f04      	ldr	r7, [sp, #16]
 800792a:	433a      	orrs	r2, r7
      GPIOx->MODER = temp;
 800792c:	6002      	str	r2, [r0, #0]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800792e:	2e01      	cmp	r6, #1
 8007930:	d80e      	bhi.n	8007950 <HAL_GPIO_Init+0x9c>
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 8007932:	68ca      	ldr	r2, [r1, #12]
        temp = GPIOx->OSPEEDR; 
 8007934:	6886      	ldr	r6, [r0, #8]
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 8007936:	40aa      	lsls	r2, r5
        CLEAR_BIT(temp, GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8007938:	4026      	ands	r6, r4
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 800793a:	4332      	orrs	r2, r6
        GPIOx->OSPEEDR = temp;
 800793c:	6082      	str	r2, [r0, #8]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 800793e:	4662      	mov	r2, ip
        temp = GPIOx->OTYPER;
 8007940:	6846      	ldr	r6, [r0, #4]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 8007942:	4396      	bics	r6, r2
        SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8007944:	9a01      	ldr	r2, [sp, #4]
 8007946:	06d2      	lsls	r2, r2, #27
 8007948:	0fd2      	lsrs	r2, r2, #31
 800794a:	409a      	lsls	r2, r3
 800794c:	4332      	orrs	r2, r6
        GPIOx->OTYPER = temp;
 800794e:	6042      	str	r2, [r0, #4]
      temp = GPIOx->PUPDR;
 8007950:	68c2      	ldr	r2, [r0, #12]
      CLEAR_BIT(temp, GPIO_PUPDR_PUPDR0 << (position * 2U));
 8007952:	4014      	ands	r4, r2
      SET_BIT(temp, (GPIO_Init->Pull) << (position * 2U));
 8007954:	688a      	ldr	r2, [r1, #8]
 8007956:	40aa      	lsls	r2, r5
 8007958:	4314      	orrs	r4, r2
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 800795a:	9a01      	ldr	r2, [sp, #4]
      GPIOx->PUPDR = temp;
 800795c:	60c4      	str	r4, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 800795e:	00d2      	lsls	r2, r2, #3
 8007960:	d554      	bpl.n	8007a0c <HAL_GPIO_Init+0x158>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8007962:	2601      	movs	r6, #1
 8007964:	4a2b      	ldr	r2, [pc, #172]	; (8007a14 <HAL_GPIO_Init+0x160>)
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 8007966:	001d      	movs	r5, r3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8007968:	6994      	ldr	r4, [r2, #24]
 800796a:	4334      	orrs	r4, r6
 800796c:	6194      	str	r4, [r2, #24]
 800796e:	6992      	ldr	r2, [r2, #24]
        temp = SYSCFG->EXTICR[position >> 2];
 8007970:	089c      	lsrs	r4, r3, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8007972:	4032      	ands	r2, r6
 8007974:	9207      	str	r2, [sp, #28]
 8007976:	9a07      	ldr	r2, [sp, #28]
 8007978:	4a27      	ldr	r2, [pc, #156]	; (8007a18 <HAL_GPIO_Init+0x164>)
 800797a:	00a4      	lsls	r4, r4, #2
 800797c:	18a4      	adds	r4, r4, r2
        temp = SYSCFG->EXTICR[position >> 2];
 800797e:	68a2      	ldr	r2, [r4, #8]
 8007980:	4694      	mov	ip, r2
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 8007982:	2203      	movs	r2, #3
 8007984:	4015      	ands	r5, r2
 8007986:	00ad      	lsls	r5, r5, #2
 8007988:	320c      	adds	r2, #12
 800798a:	40aa      	lsls	r2, r5
 800798c:	4667      	mov	r7, ip
 800798e:	4397      	bics	r7, r2
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8007990:	2290      	movs	r2, #144	; 0x90
 8007992:	05d2      	lsls	r2, r2, #23
 8007994:	4694      	mov	ip, r2
 8007996:	2200      	movs	r2, #0
 8007998:	4560      	cmp	r0, ip
 800799a:	d00d      	beq.n	80079b8 <HAL_GPIO_Init+0x104>
 800799c:	4a1f      	ldr	r2, [pc, #124]	; (8007a1c <HAL_GPIO_Init+0x168>)
 800799e:	4694      	mov	ip, r2
 80079a0:	0032      	movs	r2, r6
 80079a2:	4560      	cmp	r0, ip
 80079a4:	d008      	beq.n	80079b8 <HAL_GPIO_Init+0x104>
 80079a6:	4e1e      	ldr	r6, [pc, #120]	; (8007a20 <HAL_GPIO_Init+0x16c>)
 80079a8:	1892      	adds	r2, r2, r2
 80079aa:	42b0      	cmp	r0, r6
 80079ac:	d004      	beq.n	80079b8 <HAL_GPIO_Init+0x104>
 80079ae:	4e1d      	ldr	r6, [pc, #116]	; (8007a24 <HAL_GPIO_Init+0x170>)
 80079b0:	3201      	adds	r2, #1
 80079b2:	42b0      	cmp	r0, r6
 80079b4:	d000      	beq.n	80079b8 <HAL_GPIO_Init+0x104>
 80079b6:	9a05      	ldr	r2, [sp, #20]
 80079b8:	40aa      	lsls	r2, r5
 80079ba:	433a      	orrs	r2, r7
        SYSCFG->EXTICR[position >> 2] = temp;
 80079bc:	60a2      	str	r2, [r4, #8]
        temp = EXTI->IMR;
 80079be:	4a1a      	ldr	r2, [pc, #104]	; (8007a28 <HAL_GPIO_Init+0x174>)
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 80079c0:	9c02      	ldr	r4, [sp, #8]
        temp = EXTI->IMR;
 80079c2:	6816      	ldr	r6, [r2, #0]
          SET_BIT(temp, iocurrent); 
 80079c4:	9d02      	ldr	r5, [sp, #8]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80079c6:	9f01      	ldr	r7, [sp, #4]
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 80079c8:	43e4      	mvns	r4, r4
          SET_BIT(temp, iocurrent); 
 80079ca:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80079cc:	03ff      	lsls	r7, r7, #15
 80079ce:	d401      	bmi.n	80079d4 <HAL_GPIO_Init+0x120>
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 80079d0:	0035      	movs	r5, r6
 80079d2:	4025      	ands	r5, r4
        EXTI->IMR = temp;
 80079d4:	6015      	str	r5, [r2, #0]
        temp = EXTI->EMR;
 80079d6:	6856      	ldr	r6, [r2, #4]
          SET_BIT(temp, iocurrent); 
 80079d8:	9d02      	ldr	r5, [sp, #8]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80079da:	9f01      	ldr	r7, [sp, #4]
          SET_BIT(temp, iocurrent); 
 80079dc:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 80079de:	03bf      	lsls	r7, r7, #14
 80079e0:	d401      	bmi.n	80079e6 <HAL_GPIO_Init+0x132>
        CLEAR_BIT(temp, (uint32_t)iocurrent);      
 80079e2:	0035      	movs	r5, r6
 80079e4:	4025      	ands	r5, r4
        EXTI->EMR = temp;
 80079e6:	6055      	str	r5, [r2, #4]
        temp = EXTI->RTSR;
 80079e8:	6896      	ldr	r6, [r2, #8]
          SET_BIT(temp, iocurrent); 
 80079ea:	9d02      	ldr	r5, [sp, #8]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80079ec:	9f01      	ldr	r7, [sp, #4]
          SET_BIT(temp, iocurrent); 
 80079ee:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 80079f0:	02ff      	lsls	r7, r7, #11
 80079f2:	d401      	bmi.n	80079f8 <HAL_GPIO_Init+0x144>
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 80079f4:	0035      	movs	r5, r6
 80079f6:	4025      	ands	r5, r4
        EXTI->RTSR = temp;
 80079f8:	6095      	str	r5, [r2, #8]
        temp = EXTI->FTSR;
 80079fa:	68d5      	ldr	r5, [r2, #12]
          SET_BIT(temp, iocurrent); 
 80079fc:	9e02      	ldr	r6, [sp, #8]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 80079fe:	9f01      	ldr	r7, [sp, #4]
          SET_BIT(temp, iocurrent); 
 8007a00:	432e      	orrs	r6, r5
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8007a02:	02bf      	lsls	r7, r7, #10
 8007a04:	d401      	bmi.n	8007a0a <HAL_GPIO_Init+0x156>
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 8007a06:	4025      	ands	r5, r4
 8007a08:	002e      	movs	r6, r5
        EXTI->FTSR = temp;
 8007a0a:	60d6      	str	r6, [r2, #12]
    position++;
 8007a0c:	3301      	adds	r3, #1
 8007a0e:	e75c      	b.n	80078ca <HAL_GPIO_Init+0x16>
 8007a10:	b7fff000 	.word	0xb7fff000
 8007a14:	40021000 	.word	0x40021000
 8007a18:	40010000 	.word	0x40010000
 8007a1c:	48000400 	.word	0x48000400
 8007a20:	48000800 	.word	0x48000800
 8007a24:	48000c00 	.word	0x48000c00
 8007a28:	40010400 	.word	0x40010400

08007a2c <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8007a2c:	6900      	ldr	r0, [r0, #16]
 8007a2e:	4008      	ands	r0, r1
 8007a30:	1e41      	subs	r1, r0, #1
 8007a32:	4188      	sbcs	r0, r1
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
 8007a34:	b2c0      	uxtb	r0, r0
  }
 8007a36:	4770      	bx	lr

08007a38 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8007a38:	2a00      	cmp	r2, #0
 8007a3a:	d001      	beq.n	8007a40 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8007a3c:	6181      	str	r1, [r0, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 8007a3e:	4770      	bx	lr
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8007a40:	6281      	str	r1, [r0, #40]	; 0x28
}
 8007a42:	e7fc      	b.n	8007a3e <HAL_GPIO_WritePin+0x6>

08007a44 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8007a44:	6943      	ldr	r3, [r0, #20]
 8007a46:	4059      	eors	r1, r3
 8007a48:	6141      	str	r1, [r0, #20]
}
 8007a4a:	4770      	bx	lr

08007a4c <HAL_GPIO_EXTI_IRQHandler>:
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) 
 8007a4c:	4b04      	ldr	r3, [pc, #16]	; (8007a60 <HAL_GPIO_EXTI_IRQHandler+0x14>)
{
 8007a4e:	b510      	push	{r4, lr}
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) 
 8007a50:	695a      	ldr	r2, [r3, #20]
 8007a52:	4210      	tst	r0, r2
 8007a54:	d002      	beq.n	8007a5c <HAL_GPIO_EXTI_IRQHandler+0x10>
  { 
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8007a56:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8007a58:	f7fe fdf0 	bl	800663c <HAL_GPIO_EXTI_Callback>
  }
}
 8007a5c:	bd10      	pop	{r4, pc}
 8007a5e:	46c0      	nop			; (mov r8, r8)
 8007a60:	40010400 	.word	0x40010400

08007a64 <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8007a64:	6803      	ldr	r3, [r0, #0]
 8007a66:	699a      	ldr	r2, [r3, #24]
 8007a68:	0792      	lsls	r2, r2, #30
 8007a6a:	d501      	bpl.n	8007a70 <I2C_Flush_TXDR+0xc>
  {
     hi2c->Instance->TXDR = 0x00U;
 8007a6c:	2200      	movs	r2, #0
 8007a6e:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8007a70:	2201      	movs	r2, #1
 8007a72:	6999      	ldr	r1, [r3, #24]
 8007a74:	4211      	tst	r1, r2
 8007a76:	d102      	bne.n	8007a7e <I2C_Flush_TXDR+0x1a>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8007a78:	6999      	ldr	r1, [r3, #24]
 8007a7a:	430a      	orrs	r2, r1
 8007a7c:	619a      	str	r2, [r3, #24]
  }
}
 8007a7e:	4770      	bx	lr

08007a80 <I2C_TransferConfig>:
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8007a80:	6800      	ldr	r0, [r0, #0]
{
 8007a82:	b530      	push	{r4, r5, lr}
  tmpreg = hi2c->Instance->CR2;
 8007a84:	6845      	ldr	r5, [r0, #4]

  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8007a86:	4c06      	ldr	r4, [pc, #24]	; (8007aa0 <I2C_TransferConfig+0x20>)

  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8007a88:	0412      	lsls	r2, r2, #16
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8007a8a:	402c      	ands	r4, r5
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8007a8c:	9d03      	ldr	r5, [sp, #12]
 8007a8e:	0589      	lsls	r1, r1, #22
 8007a90:	432b      	orrs	r3, r5
 8007a92:	431a      	orrs	r2, r3
 8007a94:	0d89      	lsrs	r1, r1, #22
 8007a96:	430a      	orrs	r2, r1
 8007a98:	4322      	orrs	r2, r4
            (uint32_t)Mode | (uint32_t)Request);

  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;
 8007a9a:	6042      	str	r2, [r0, #4]
}
 8007a9c:	bd30      	pop	{r4, r5, pc}
 8007a9e:	46c0      	nop			; (mov r8, r8)
 8007aa0:	fc009800 	.word	0xfc009800

08007aa4 <I2C_WaitOnFlagUntilTimeout>:
{
 8007aa4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007aa6:	0004      	movs	r4, r0
 8007aa8:	000e      	movs	r6, r1
 8007aaa:	0017      	movs	r7, r2
 8007aac:	001d      	movs	r5, r3
  while(__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8007aae:	6822      	ldr	r2, [r4, #0]
 8007ab0:	6993      	ldr	r3, [r2, #24]
 8007ab2:	4033      	ands	r3, r6
 8007ab4:	1b9b      	subs	r3, r3, r6
 8007ab6:	4259      	negs	r1, r3
 8007ab8:	414b      	adcs	r3, r1
 8007aba:	42bb      	cmp	r3, r7
 8007abc:	d001      	beq.n	8007ac2 <I2C_WaitOnFlagUntilTimeout+0x1e>
  return HAL_OK;
 8007abe:	2000      	movs	r0, #0
 8007ac0:	e00e      	b.n	8007ae0 <I2C_WaitOnFlagUntilTimeout+0x3c>
    if(Timeout != HAL_MAX_DELAY)
 8007ac2:	1c6b      	adds	r3, r5, #1
 8007ac4:	d0f4      	beq.n	8007ab0 <I2C_WaitOnFlagUntilTimeout+0xc>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8007ac6:	2d00      	cmp	r5, #0
 8007ac8:	d10b      	bne.n	8007ae2 <I2C_WaitOnFlagUntilTimeout+0x3e>
        hi2c->State= HAL_I2C_STATE_READY;
 8007aca:	0023      	movs	r3, r4
 8007acc:	2220      	movs	r2, #32
 8007ace:	3341      	adds	r3, #65	; 0x41
 8007ad0:	701a      	strb	r2, [r3, #0]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007ad2:	0022      	movs	r2, r4
 8007ad4:	2300      	movs	r3, #0
        return HAL_TIMEOUT;
 8007ad6:	2003      	movs	r0, #3
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007ad8:	3242      	adds	r2, #66	; 0x42
        __HAL_UNLOCK(hi2c);
 8007ada:	3440      	adds	r4, #64	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007adc:	7013      	strb	r3, [r2, #0]
        __HAL_UNLOCK(hi2c);
 8007ade:	7023      	strb	r3, [r4, #0]
}
 8007ae0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8007ae2:	f7ff fa9b 	bl	800701c <HAL_GetTick>
 8007ae6:	9b06      	ldr	r3, [sp, #24]
 8007ae8:	1ac0      	subs	r0, r0, r3
 8007aea:	42a8      	cmp	r0, r5
 8007aec:	d9df      	bls.n	8007aae <I2C_WaitOnFlagUntilTimeout+0xa>
 8007aee:	e7ec      	b.n	8007aca <I2C_WaitOnFlagUntilTimeout+0x26>

08007af0 <I2C_IsAcknowledgeFailed>:
{
 8007af0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007af2:	6803      	ldr	r3, [r0, #0]
{
 8007af4:	0004      	movs	r4, r0
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007af6:	6998      	ldr	r0, [r3, #24]
 8007af8:	2310      	movs	r3, #16
{
 8007afa:	000e      	movs	r6, r1
 8007afc:	0017      	movs	r7, r2
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007afe:	4018      	ands	r0, r3
    while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007b00:	2520      	movs	r5, #32
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007b02:	2800      	cmp	r0, #0
 8007b04:	d115      	bne.n	8007b32 <I2C_IsAcknowledgeFailed+0x42>
}
 8007b06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(Timeout != HAL_MAX_DELAY)
 8007b08:	1c72      	adds	r2, r6, #1
 8007b0a:	d013      	beq.n	8007b34 <I2C_IsAcknowledgeFailed+0x44>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007b0c:	2e00      	cmp	r6, #0
 8007b0e:	d004      	beq.n	8007b1a <I2C_IsAcknowledgeFailed+0x2a>
 8007b10:	f7ff fa84 	bl	800701c <HAL_GetTick>
 8007b14:	1bc0      	subs	r0, r0, r7
 8007b16:	4286      	cmp	r6, r0
 8007b18:	d20b      	bcs.n	8007b32 <I2C_IsAcknowledgeFailed+0x42>
          hi2c->State= HAL_I2C_STATE_READY;
 8007b1a:	0023      	movs	r3, r4
 8007b1c:	2220      	movs	r2, #32
 8007b1e:	3341      	adds	r3, #65	; 0x41
 8007b20:	701a      	strb	r2, [r3, #0]
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8007b22:	0022      	movs	r2, r4
 8007b24:	2300      	movs	r3, #0
 8007b26:	3242      	adds	r2, #66	; 0x42
          __HAL_UNLOCK(hi2c);
 8007b28:	3440      	adds	r4, #64	; 0x40
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8007b2a:	7013      	strb	r3, [r2, #0]
          return HAL_TIMEOUT;
 8007b2c:	2003      	movs	r0, #3
          __HAL_UNLOCK(hi2c);
 8007b2e:	7023      	strb	r3, [r4, #0]
 8007b30:	e7e9      	b.n	8007b06 <I2C_IsAcknowledgeFailed+0x16>
    while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007b32:	6823      	ldr	r3, [r4, #0]
 8007b34:	699a      	ldr	r2, [r3, #24]
 8007b36:	422a      	tst	r2, r5
 8007b38:	d0e6      	beq.n	8007b08 <I2C_IsAcknowledgeFailed+0x18>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007b3a:	2210      	movs	r2, #16
    I2C_Flush_TXDR(hi2c);
 8007b3c:	0020      	movs	r0, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007b3e:	61da      	str	r2, [r3, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007b40:	61dd      	str	r5, [r3, #28]
    I2C_Flush_TXDR(hi2c);
 8007b42:	f7ff ff8f 	bl	8007a64 <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
 8007b46:	6822      	ldr	r2, [r4, #0]
 8007b48:	4908      	ldr	r1, [pc, #32]	; (8007b6c <I2C_IsAcknowledgeFailed+0x7c>)
 8007b4a:	6853      	ldr	r3, [r2, #4]
    return HAL_ERROR;
 8007b4c:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
 8007b4e:	400b      	ands	r3, r1
 8007b50:	6053      	str	r3, [r2, #4]
    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8007b52:	2304      	movs	r3, #4
 8007b54:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State= HAL_I2C_STATE_READY;
 8007b56:	0023      	movs	r3, r4
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8007b58:	0022      	movs	r2, r4
    hi2c->State= HAL_I2C_STATE_READY;
 8007b5a:	3341      	adds	r3, #65	; 0x41
 8007b5c:	701d      	strb	r5, [r3, #0]
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8007b5e:	2300      	movs	r3, #0
 8007b60:	3242      	adds	r2, #66	; 0x42
    __HAL_UNLOCK(hi2c);
 8007b62:	3440      	adds	r4, #64	; 0x40
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8007b64:	7013      	strb	r3, [r2, #0]
    __HAL_UNLOCK(hi2c);
 8007b66:	7023      	strb	r3, [r4, #0]
 8007b68:	e7cd      	b.n	8007b06 <I2C_IsAcknowledgeFailed+0x16>
 8007b6a:	46c0      	nop			; (mov r8, r8)
 8007b6c:	fe00e800 	.word	0xfe00e800

08007b70 <I2C_WaitOnTXISFlagUntilTimeout>:
{
 8007b70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007b72:	0004      	movs	r4, r0
 8007b74:	000d      	movs	r5, r1
 8007b76:	0016      	movs	r6, r2
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8007b78:	2702      	movs	r7, #2
 8007b7a:	6823      	ldr	r3, [r4, #0]
 8007b7c:	699b      	ldr	r3, [r3, #24]
 8007b7e:	423b      	tst	r3, r7
 8007b80:	d001      	beq.n	8007b86 <I2C_WaitOnTXISFlagUntilTimeout+0x16>
  return HAL_OK;
 8007b82:	2000      	movs	r0, #0
 8007b84:	e018      	b.n	8007bb8 <I2C_WaitOnTXISFlagUntilTimeout+0x48>
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8007b86:	0032      	movs	r2, r6
 8007b88:	0029      	movs	r1, r5
 8007b8a:	0020      	movs	r0, r4
 8007b8c:	f7ff ffb0 	bl	8007af0 <I2C_IsAcknowledgeFailed>
 8007b90:	2800      	cmp	r0, #0
 8007b92:	d118      	bne.n	8007bc6 <I2C_WaitOnTXISFlagUntilTimeout+0x56>
    if(Timeout != HAL_MAX_DELAY)
 8007b94:	1c6b      	adds	r3, r5, #1
 8007b96:	d0f0      	beq.n	8007b7a <I2C_WaitOnTXISFlagUntilTimeout+0xa>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007b98:	2d00      	cmp	r5, #0
 8007b9a:	d10e      	bne.n	8007bba <I2C_WaitOnTXISFlagUntilTimeout+0x4a>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007b9c:	2220      	movs	r2, #32
 8007b9e:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8007ba0:	2003      	movs	r0, #3
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007ba2:	4313      	orrs	r3, r2
 8007ba4:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State= HAL_I2C_STATE_READY;
 8007ba6:	0023      	movs	r3, r4
 8007ba8:	3341      	adds	r3, #65	; 0x41
 8007baa:	701a      	strb	r2, [r3, #0]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007bac:	0022      	movs	r2, r4
 8007bae:	2300      	movs	r3, #0
 8007bb0:	3242      	adds	r2, #66	; 0x42
        __HAL_UNLOCK(hi2c);
 8007bb2:	3440      	adds	r4, #64	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007bb4:	7013      	strb	r3, [r2, #0]
        __HAL_UNLOCK(hi2c);
 8007bb6:	7023      	strb	r3, [r4, #0]
}
 8007bb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007bba:	f7ff fa2f 	bl	800701c <HAL_GetTick>
 8007bbe:	1b80      	subs	r0, r0, r6
 8007bc0:	42a8      	cmp	r0, r5
 8007bc2:	d9da      	bls.n	8007b7a <I2C_WaitOnTXISFlagUntilTimeout+0xa>
 8007bc4:	e7ea      	b.n	8007b9c <I2C_WaitOnTXISFlagUntilTimeout+0x2c>
      return HAL_ERROR;
 8007bc6:	2001      	movs	r0, #1
 8007bc8:	e7f6      	b.n	8007bb8 <I2C_WaitOnTXISFlagUntilTimeout+0x48>

08007bca <I2C_RequestMemoryWrite>:
{
 8007bca:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8007bcc:	0015      	movs	r5, r2
 8007bce:	001e      	movs	r6, r3
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8007bd0:	b2da      	uxtb	r2, r3
 8007bd2:	2380      	movs	r3, #128	; 0x80
 8007bd4:	019b      	lsls	r3, r3, #6
 8007bd6:	9300      	str	r3, [sp, #0]
 8007bd8:	2380      	movs	r3, #128	; 0x80
{
 8007bda:	0004      	movs	r4, r0
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8007bdc:	045b      	lsls	r3, r3, #17
 8007bde:	f7ff ff4f 	bl	8007a80 <I2C_TransferConfig>
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007be2:	9a07      	ldr	r2, [sp, #28]
 8007be4:	9906      	ldr	r1, [sp, #24]
 8007be6:	0020      	movs	r0, r4
 8007be8:	f7ff ffc2 	bl	8007b70 <I2C_WaitOnTXISFlagUntilTimeout>
 8007bec:	2800      	cmp	r0, #0
 8007bee:	d005      	beq.n	8007bfc <I2C_RequestMemoryWrite+0x32>
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007bf0:	6c63      	ldr	r3, [r4, #68]	; 0x44
      return HAL_ERROR;
 8007bf2:	2001      	movs	r0, #1
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007bf4:	2b04      	cmp	r3, #4
 8007bf6:	d000      	beq.n	8007bfa <I2C_RequestMemoryWrite+0x30>
      return HAL_TIMEOUT;
 8007bf8:	2003      	movs	r0, #3
}
 8007bfa:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 8007bfc:	6823      	ldr	r3, [r4, #0]
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8007bfe:	2e01      	cmp	r6, #1
 8007c00:	d10c      	bne.n	8007c1c <I2C_RequestMemoryWrite+0x52>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007c02:	b2ed      	uxtb	r5, r5
 8007c04:	629d      	str	r5, [r3, #40]	; 0x28
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 8007c06:	9b07      	ldr	r3, [sp, #28]
 8007c08:	2200      	movs	r2, #0
 8007c0a:	9300      	str	r3, [sp, #0]
 8007c0c:	2180      	movs	r1, #128	; 0x80
 8007c0e:	9b06      	ldr	r3, [sp, #24]
 8007c10:	0020      	movs	r0, r4
 8007c12:	f7ff ff47 	bl	8007aa4 <I2C_WaitOnFlagUntilTimeout>
 8007c16:	2800      	cmp	r0, #0
 8007c18:	d0ef      	beq.n	8007bfa <I2C_RequestMemoryWrite+0x30>
 8007c1a:	e7ed      	b.n	8007bf8 <I2C_RequestMemoryWrite+0x2e>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8007c1c:	0a2a      	lsrs	r2, r5, #8
 8007c1e:	629a      	str	r2, [r3, #40]	; 0x28
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007c20:	9906      	ldr	r1, [sp, #24]
 8007c22:	9a07      	ldr	r2, [sp, #28]
 8007c24:	0020      	movs	r0, r4
 8007c26:	f7ff ffa3 	bl	8007b70 <I2C_WaitOnTXISFlagUntilTimeout>
 8007c2a:	2800      	cmp	r0, #0
 8007c2c:	d1e0      	bne.n	8007bf0 <I2C_RequestMemoryWrite+0x26>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007c2e:	6823      	ldr	r3, [r4, #0]
 8007c30:	e7e7      	b.n	8007c02 <I2C_RequestMemoryWrite+0x38>

08007c32 <I2C_RequestMemoryRead>:
{
 8007c32:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8007c34:	0015      	movs	r5, r2
 8007c36:	001e      	movs	r6, r3
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8007c38:	b2da      	uxtb	r2, r3
 8007c3a:	2380      	movs	r3, #128	; 0x80
{
 8007c3c:	0004      	movs	r4, r0
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8007c3e:	019b      	lsls	r3, r3, #6
 8007c40:	9300      	str	r3, [sp, #0]
 8007c42:	2300      	movs	r3, #0
 8007c44:	f7ff ff1c 	bl	8007a80 <I2C_TransferConfig>
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007c48:	9a07      	ldr	r2, [sp, #28]
 8007c4a:	9906      	ldr	r1, [sp, #24]
 8007c4c:	0020      	movs	r0, r4
 8007c4e:	f7ff ff8f 	bl	8007b70 <I2C_WaitOnTXISFlagUntilTimeout>
 8007c52:	2800      	cmp	r0, #0
 8007c54:	d005      	beq.n	8007c62 <I2C_RequestMemoryRead+0x30>
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007c56:	6c63      	ldr	r3, [r4, #68]	; 0x44
      return HAL_ERROR;
 8007c58:	2001      	movs	r0, #1
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007c5a:	2b04      	cmp	r3, #4
 8007c5c:	d000      	beq.n	8007c60 <I2C_RequestMemoryRead+0x2e>
      return HAL_TIMEOUT;
 8007c5e:	2003      	movs	r0, #3
}
 8007c60:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 8007c62:	6823      	ldr	r3, [r4, #0]
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8007c64:	2e01      	cmp	r6, #1
 8007c66:	d10c      	bne.n	8007c82 <I2C_RequestMemoryRead+0x50>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007c68:	b2ed      	uxtb	r5, r5
 8007c6a:	629d      	str	r5, [r3, #40]	; 0x28
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 8007c6c:	9b07      	ldr	r3, [sp, #28]
 8007c6e:	2200      	movs	r2, #0
 8007c70:	9300      	str	r3, [sp, #0]
 8007c72:	2140      	movs	r1, #64	; 0x40
 8007c74:	9b06      	ldr	r3, [sp, #24]
 8007c76:	0020      	movs	r0, r4
 8007c78:	f7ff ff14 	bl	8007aa4 <I2C_WaitOnFlagUntilTimeout>
 8007c7c:	2800      	cmp	r0, #0
 8007c7e:	d0ef      	beq.n	8007c60 <I2C_RequestMemoryRead+0x2e>
 8007c80:	e7ed      	b.n	8007c5e <I2C_RequestMemoryRead+0x2c>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8007c82:	0a2a      	lsrs	r2, r5, #8
 8007c84:	629a      	str	r2, [r3, #40]	; 0x28
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007c86:	9906      	ldr	r1, [sp, #24]
 8007c88:	9a07      	ldr	r2, [sp, #28]
 8007c8a:	0020      	movs	r0, r4
 8007c8c:	f7ff ff70 	bl	8007b70 <I2C_WaitOnTXISFlagUntilTimeout>
 8007c90:	2800      	cmp	r0, #0
 8007c92:	d1e0      	bne.n	8007c56 <I2C_RequestMemoryRead+0x24>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007c94:	6823      	ldr	r3, [r4, #0]
 8007c96:	e7e7      	b.n	8007c68 <I2C_RequestMemoryRead+0x36>

08007c98 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 8007c98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007c9a:	0004      	movs	r4, r0
 8007c9c:	000d      	movs	r5, r1
 8007c9e:	0016      	movs	r6, r2
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007ca0:	2720      	movs	r7, #32
 8007ca2:	6823      	ldr	r3, [r4, #0]
 8007ca4:	699b      	ldr	r3, [r3, #24]
 8007ca6:	423b      	tst	r3, r7
 8007ca8:	d001      	beq.n	8007cae <I2C_WaitOnSTOPFlagUntilTimeout+0x16>
  return HAL_OK;
 8007caa:	2000      	movs	r0, #0
 8007cac:	e016      	b.n	8007cdc <I2C_WaitOnSTOPFlagUntilTimeout+0x44>
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8007cae:	0032      	movs	r2, r6
 8007cb0:	0029      	movs	r1, r5
 8007cb2:	0020      	movs	r0, r4
 8007cb4:	f7ff ff1c 	bl	8007af0 <I2C_IsAcknowledgeFailed>
 8007cb8:	2800      	cmp	r0, #0
 8007cba:	d116      	bne.n	8007cea <I2C_WaitOnSTOPFlagUntilTimeout+0x52>
    if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007cbc:	2d00      	cmp	r5, #0
 8007cbe:	d10e      	bne.n	8007cde <I2C_WaitOnSTOPFlagUntilTimeout+0x46>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007cc0:	2220      	movs	r2, #32
 8007cc2:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8007cc4:	2003      	movs	r0, #3
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007cc6:	4313      	orrs	r3, r2
 8007cc8:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State= HAL_I2C_STATE_READY;
 8007cca:	0023      	movs	r3, r4
 8007ccc:	3341      	adds	r3, #65	; 0x41
 8007cce:	701a      	strb	r2, [r3, #0]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007cd0:	0022      	movs	r2, r4
 8007cd2:	2300      	movs	r3, #0
 8007cd4:	3242      	adds	r2, #66	; 0x42
        __HAL_UNLOCK(hi2c);
 8007cd6:	3440      	adds	r4, #64	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007cd8:	7013      	strb	r3, [r2, #0]
        __HAL_UNLOCK(hi2c);
 8007cda:	7023      	strb	r3, [r4, #0]
}
 8007cdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007cde:	f7ff f99d 	bl	800701c <HAL_GetTick>
 8007ce2:	1b80      	subs	r0, r0, r6
 8007ce4:	42a8      	cmp	r0, r5
 8007ce6:	d9dc      	bls.n	8007ca2 <I2C_WaitOnSTOPFlagUntilTimeout+0xa>
 8007ce8:	e7ea      	b.n	8007cc0 <I2C_WaitOnSTOPFlagUntilTimeout+0x28>
      return HAL_ERROR;
 8007cea:	2001      	movs	r0, #1
 8007cec:	e7f6      	b.n	8007cdc <I2C_WaitOnSTOPFlagUntilTimeout+0x44>
	...

08007cf0 <HAL_I2C_Init>:
{
 8007cf0:	b570      	push	{r4, r5, r6, lr}
 8007cf2:	0004      	movs	r4, r0
    return HAL_ERROR;
 8007cf4:	2001      	movs	r0, #1
  if(hi2c == NULL)
 8007cf6:	2c00      	cmp	r4, #0
 8007cf8:	d03f      	beq.n	8007d7a <HAL_I2C_Init+0x8a>
  if(hi2c->State == HAL_I2C_STATE_RESET)
 8007cfa:	0025      	movs	r5, r4
 8007cfc:	3541      	adds	r5, #65	; 0x41
 8007cfe:	782b      	ldrb	r3, [r5, #0]
 8007d00:	b2db      	uxtb	r3, r3
 8007d02:	2b00      	cmp	r3, #0
 8007d04:	d105      	bne.n	8007d12 <HAL_I2C_Init+0x22>
    hi2c->Lock = HAL_UNLOCKED;
 8007d06:	0022      	movs	r2, r4
 8007d08:	3240      	adds	r2, #64	; 0x40
 8007d0a:	7013      	strb	r3, [r2, #0]
    HAL_I2C_MspInit(hi2c);
 8007d0c:	0020      	movs	r0, r4
 8007d0e:	f7fe f92b 	bl	8005f68 <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8007d12:	2324      	movs	r3, #36	; 0x24
  __HAL_I2C_DISABLE(hi2c);
 8007d14:	2101      	movs	r1, #1
  hi2c->State = HAL_I2C_STATE_BUSY;
 8007d16:	702b      	strb	r3, [r5, #0]
  __HAL_I2C_DISABLE(hi2c);
 8007d18:	6823      	ldr	r3, [r4, #0]
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8007d1a:	68e0      	ldr	r0, [r4, #12]
  __HAL_I2C_DISABLE(hi2c);
 8007d1c:	681a      	ldr	r2, [r3, #0]
 8007d1e:	68a6      	ldr	r6, [r4, #8]
 8007d20:	438a      	bics	r2, r1
 8007d22:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8007d24:	6861      	ldr	r1, [r4, #4]
 8007d26:	4a1a      	ldr	r2, [pc, #104]	; (8007d90 <HAL_I2C_Init+0xa0>)
 8007d28:	400a      	ands	r2, r1
 8007d2a:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8007d2c:	6899      	ldr	r1, [r3, #8]
 8007d2e:	4a19      	ldr	r2, [pc, #100]	; (8007d94 <HAL_I2C_Init+0xa4>)
 8007d30:	4011      	ands	r1, r2
 8007d32:	6099      	str	r1, [r3, #8]
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8007d34:	2801      	cmp	r0, #1
 8007d36:	d121      	bne.n	8007d7c <HAL_I2C_Init+0x8c>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8007d38:	2180      	movs	r1, #128	; 0x80
 8007d3a:	0209      	lsls	r1, r1, #8
 8007d3c:	4331      	orrs	r1, r6
 8007d3e:	6099      	str	r1, [r3, #8]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8007d40:	6858      	ldr	r0, [r3, #4]
 8007d42:	4915      	ldr	r1, [pc, #84]	; (8007d98 <HAL_I2C_Init+0xa8>)
 8007d44:	4301      	orrs	r1, r0
 8007d46:	6059      	str	r1, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8007d48:	68d9      	ldr	r1, [r3, #12]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007d4a:	2000      	movs	r0, #0
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8007d4c:	400a      	ands	r2, r1
 8007d4e:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8007d50:	6961      	ldr	r1, [r4, #20]
 8007d52:	6922      	ldr	r2, [r4, #16]
 8007d54:	430a      	orrs	r2, r1
 8007d56:	69a1      	ldr	r1, [r4, #24]
 8007d58:	0209      	lsls	r1, r1, #8
 8007d5a:	430a      	orrs	r2, r1
 8007d5c:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8007d5e:	6a21      	ldr	r1, [r4, #32]
 8007d60:	69e2      	ldr	r2, [r4, #28]
 8007d62:	430a      	orrs	r2, r1
 8007d64:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 8007d66:	2201      	movs	r2, #1
 8007d68:	6819      	ldr	r1, [r3, #0]
 8007d6a:	430a      	orrs	r2, r1
 8007d6c:	601a      	str	r2, [r3, #0]
  hi2c->State = HAL_I2C_STATE_READY;
 8007d6e:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007d70:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8007d72:	702b      	strb	r3, [r5, #0]
  hi2c->PreviousState = I2C_STATE_NONE;
 8007d74:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007d76:	3442      	adds	r4, #66	; 0x42
 8007d78:	7020      	strb	r0, [r4, #0]
}
 8007d7a:	bd70      	pop	{r4, r5, r6, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8007d7c:	2184      	movs	r1, #132	; 0x84
 8007d7e:	0209      	lsls	r1, r1, #8
 8007d80:	4331      	orrs	r1, r6
 8007d82:	6099      	str	r1, [r3, #8]
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8007d84:	2802      	cmp	r0, #2
 8007d86:	d1db      	bne.n	8007d40 <HAL_I2C_Init+0x50>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8007d88:	2180      	movs	r1, #128	; 0x80
 8007d8a:	0109      	lsls	r1, r1, #4
 8007d8c:	6059      	str	r1, [r3, #4]
 8007d8e:	e7d7      	b.n	8007d40 <HAL_I2C_Init+0x50>
 8007d90:	f0ffffff 	.word	0xf0ffffff
 8007d94:	ffff7fff 	.word	0xffff7fff
 8007d98:	02008000 	.word	0x02008000

08007d9c <HAL_I2C_Mem_Write>:
{
 8007d9c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007d9e:	b089      	sub	sp, #36	; 0x24
 8007da0:	9307      	str	r3, [sp, #28]
 8007da2:	ab0e      	add	r3, sp, #56	; 0x38
 8007da4:	9206      	str	r2, [sp, #24]
 8007da6:	cb04      	ldmia	r3!, {r2}
 8007da8:	0004      	movs	r4, r0
 8007daa:	881b      	ldrh	r3, [r3, #0]
 8007dac:	9203      	str	r2, [sp, #12]
 8007dae:	9304      	str	r3, [sp, #16]
  if(hi2c->State == HAL_I2C_STATE_READY)
 8007db0:	0003      	movs	r3, r0
 8007db2:	3341      	adds	r3, #65	; 0x41
 8007db4:	9305      	str	r3, [sp, #20]
 8007db6:	781b      	ldrb	r3, [r3, #0]
{
 8007db8:	000d      	movs	r5, r1
    return HAL_BUSY;
 8007dba:	2002      	movs	r0, #2
  if(hi2c->State == HAL_I2C_STATE_READY)
 8007dbc:	2b20      	cmp	r3, #32
 8007dbe:	d102      	bne.n	8007dc6 <HAL_I2C_Mem_Write+0x2a>
    if((pData == NULL) || (Size == 0U))
 8007dc0:	2a00      	cmp	r2, #0
 8007dc2:	d102      	bne.n	8007dca <HAL_I2C_Mem_Write+0x2e>
        return HAL_ERROR;
 8007dc4:	2001      	movs	r0, #1
}
 8007dc6:	b009      	add	sp, #36	; 0x24
 8007dc8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((pData == NULL) || (Size == 0U))
 8007dca:	9b04      	ldr	r3, [sp, #16]
 8007dcc:	2b00      	cmp	r3, #0
 8007dce:	d0f9      	beq.n	8007dc4 <HAL_I2C_Mem_Write+0x28>
    __HAL_LOCK(hi2c);
 8007dd0:	0027      	movs	r7, r4
 8007dd2:	3740      	adds	r7, #64	; 0x40
 8007dd4:	783b      	ldrb	r3, [r7, #0]
 8007dd6:	2b01      	cmp	r3, #1
 8007dd8:	d0f5      	beq.n	8007dc6 <HAL_I2C_Mem_Write+0x2a>
 8007dda:	2301      	movs	r3, #1
 8007ddc:	703b      	strb	r3, [r7, #0]
    tickstart = HAL_GetTick();
 8007dde:	f7ff f91d 	bl	800701c <HAL_GetTick>
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8007de2:	2180      	movs	r1, #128	; 0x80
    tickstart = HAL_GetTick();
 8007de4:	9002      	str	r0, [sp, #8]
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8007de6:	9000      	str	r0, [sp, #0]
 8007de8:	2319      	movs	r3, #25
 8007dea:	2201      	movs	r2, #1
 8007dec:	0209      	lsls	r1, r1, #8
 8007dee:	0020      	movs	r0, r4
 8007df0:	f7ff fe58 	bl	8007aa4 <I2C_WaitOnFlagUntilTimeout>
 8007df4:	1e06      	subs	r6, r0, #0
 8007df6:	d11e      	bne.n	8007e36 <HAL_I2C_Mem_Write+0x9a>
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8007df8:	2321      	movs	r3, #33	; 0x21
 8007dfa:	9a05      	ldr	r2, [sp, #20]
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8007dfc:	0029      	movs	r1, r5
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8007dfe:	7013      	strb	r3, [r2, #0]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8007e00:	0023      	movs	r3, r4
 8007e02:	3342      	adds	r3, #66	; 0x42
 8007e04:	9305      	str	r3, [sp, #20]
 8007e06:	2340      	movs	r3, #64	; 0x40
 8007e08:	9a05      	ldr	r2, [sp, #20]
 8007e0a:	7013      	strb	r3, [r2, #0]
    hi2c->pBuffPtr  = pData;
 8007e0c:	9b03      	ldr	r3, [sp, #12]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007e0e:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->pBuffPtr  = pData;
 8007e10:	6263      	str	r3, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
 8007e12:	9b04      	ldr	r3, [sp, #16]
    hi2c->XferISR   = NULL;
 8007e14:	6360      	str	r0, [r4, #52]	; 0x34
    hi2c->XferCount = Size;
 8007e16:	8563      	strh	r3, [r4, #42]	; 0x2a
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8007e18:	9b02      	ldr	r3, [sp, #8]
 8007e1a:	9a06      	ldr	r2, [sp, #24]
 8007e1c:	9301      	str	r3, [sp, #4]
 8007e1e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007e20:	0020      	movs	r0, r4
 8007e22:	9300      	str	r3, [sp, #0]
 8007e24:	9b07      	ldr	r3, [sp, #28]
 8007e26:	f7ff fed0 	bl	8007bca <I2C_RequestMemoryWrite>
 8007e2a:	2800      	cmp	r0, #0
 8007e2c:	d005      	beq.n	8007e3a <HAL_I2C_Mem_Write+0x9e>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007e2e:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8007e30:	703e      	strb	r6, [r7, #0]
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007e32:	2b04      	cmp	r3, #4
 8007e34:	d0c6      	beq.n	8007dc4 <HAL_I2C_Mem_Write+0x28>
          return HAL_TIMEOUT;
 8007e36:	2003      	movs	r0, #3
 8007e38:	e7c5      	b.n	8007dc6 <HAL_I2C_Mem_Write+0x2a>
    if(hi2c->XferCount > MAX_NBYTE_SIZE)
 8007e3a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007e3c:	2bff      	cmp	r3, #255	; 0xff
 8007e3e:	d914      	bls.n	8007e6a <HAL_I2C_Mem_Write+0xce>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8007e40:	22ff      	movs	r2, #255	; 0xff
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007e42:	2380      	movs	r3, #128	; 0x80
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8007e44:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007e46:	045b      	lsls	r3, r3, #17
 8007e48:	9000      	str	r0, [sp, #0]
 8007e4a:	0029      	movs	r1, r5
 8007e4c:	0020      	movs	r0, r4
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007e4e:	2680      	movs	r6, #128	; 0x80
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007e50:	f7ff fe16 	bl	8007a80 <I2C_TransferConfig>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8007e54:	27ff      	movs	r7, #255	; 0xff
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007e56:	04b6      	lsls	r6, r6, #18
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8007e58:	9a02      	ldr	r2, [sp, #8]
 8007e5a:	9910      	ldr	r1, [sp, #64]	; 0x40
 8007e5c:	0020      	movs	r0, r4
 8007e5e:	f7ff fe87 	bl	8007b70 <I2C_WaitOnTXISFlagUntilTimeout>
 8007e62:	2800      	cmp	r0, #0
 8007e64:	d009      	beq.n	8007e7a <HAL_I2C_Mem_Write+0xde>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007e66:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007e68:	e7e3      	b.n	8007e32 <HAL_I2C_Mem_Write+0x96>
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007e6a:	2380      	movs	r3, #128	; 0x80
      hi2c->XferSize = hi2c->XferCount;
 8007e6c:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007e6e:	049b      	lsls	r3, r3, #18
      hi2c->XferSize = hi2c->XferCount;
 8007e70:	b292      	uxth	r2, r2
 8007e72:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007e74:	b2d2      	uxtb	r2, r2
 8007e76:	9000      	str	r0, [sp, #0]
 8007e78:	e7e7      	b.n	8007e4a <HAL_I2C_Mem_Write+0xae>
      hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
 8007e7a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007e7c:	1c5a      	adds	r2, r3, #1
 8007e7e:	6262      	str	r2, [r4, #36]	; 0x24
 8007e80:	781b      	ldrb	r3, [r3, #0]
 8007e82:	6822      	ldr	r2, [r4, #0]
 8007e84:	6293      	str	r3, [r2, #40]	; 0x28
      hi2c->XferCount--;
 8007e86:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007e88:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007e8a:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 8007e8c:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 8007e8e:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8007e90:	b292      	uxth	r2, r2
      hi2c->XferCount--;
 8007e92:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007e94:	8522      	strh	r2, [r4, #40]	; 0x28
      if((hi2c->XferSize == 0U) && (hi2c->XferCount!=0U))
 8007e96:	2a00      	cmp	r2, #0
 8007e98:	d117      	bne.n	8007eca <HAL_I2C_Mem_Write+0x12e>
 8007e9a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007e9c:	2b00      	cmp	r3, #0
 8007e9e:	d014      	beq.n	8007eca <HAL_I2C_Mem_Write+0x12e>
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8007ea0:	9b02      	ldr	r3, [sp, #8]
 8007ea2:	2180      	movs	r1, #128	; 0x80
 8007ea4:	9300      	str	r3, [sp, #0]
 8007ea6:	0020      	movs	r0, r4
 8007ea8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007eaa:	f7ff fdfb 	bl	8007aa4 <I2C_WaitOnFlagUntilTimeout>
 8007eae:	2800      	cmp	r0, #0
 8007eb0:	d1c1      	bne.n	8007e36 <HAL_I2C_Mem_Write+0x9a>
        if(hi2c->XferCount > MAX_NBYTE_SIZE)
 8007eb2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007eb4:	2bff      	cmp	r3, #255	; 0xff
 8007eb6:	d921      	bls.n	8007efc <HAL_I2C_Mem_Write+0x160>
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007eb8:	2380      	movs	r3, #128	; 0x80
 8007eba:	22ff      	movs	r2, #255	; 0xff
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8007ebc:	8527      	strh	r7, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007ebe:	045b      	lsls	r3, r3, #17
 8007ec0:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007ec2:	0029      	movs	r1, r5
 8007ec4:	0020      	movs	r0, r4
 8007ec6:	f7ff fddb 	bl	8007a80 <I2C_TransferConfig>
    }while(hi2c->XferCount > 0U);
 8007eca:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007ecc:	2b00      	cmp	r3, #0
 8007ece:	d1c3      	bne.n	8007e58 <HAL_I2C_Mem_Write+0xbc>
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8007ed0:	9a02      	ldr	r2, [sp, #8]
 8007ed2:	9910      	ldr	r1, [sp, #64]	; 0x40
 8007ed4:	0020      	movs	r0, r4
 8007ed6:	f7ff fedf 	bl	8007c98 <I2C_WaitOnSTOPFlagUntilTimeout>
 8007eda:	2800      	cmp	r0, #0
 8007edc:	d1c3      	bne.n	8007e66 <HAL_I2C_Mem_Write+0xca>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007ede:	2120      	movs	r1, #32
 8007ee0:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
 8007ee2:	4d0a      	ldr	r5, [pc, #40]	; (8007f0c <HAL_I2C_Mem_Write+0x170>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007ee4:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8007ee6:	685a      	ldr	r2, [r3, #4]
 8007ee8:	402a      	ands	r2, r5
 8007eea:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8007eec:	0023      	movs	r3, r4
 8007eee:	3341      	adds	r3, #65	; 0x41
 8007ef0:	7019      	strb	r1, [r3, #0]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8007ef2:	9b05      	ldr	r3, [sp, #20]
    __HAL_UNLOCK(hi2c);
 8007ef4:	3440      	adds	r4, #64	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8007ef6:	7018      	strb	r0, [r3, #0]
    __HAL_UNLOCK(hi2c);
 8007ef8:	7020      	strb	r0, [r4, #0]
    return HAL_OK;
 8007efa:	e764      	b.n	8007dc6 <HAL_I2C_Mem_Write+0x2a>
          hi2c->XferSize = hi2c->XferCount;
 8007efc:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007efe:	0033      	movs	r3, r6
          hi2c->XferSize = hi2c->XferCount;
 8007f00:	b292      	uxth	r2, r2
 8007f02:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f04:	b2d2      	uxtb	r2, r2
 8007f06:	9000      	str	r0, [sp, #0]
 8007f08:	e7db      	b.n	8007ec2 <HAL_I2C_Mem_Write+0x126>
 8007f0a:	46c0      	nop			; (mov r8, r8)
 8007f0c:	fe00e800 	.word	0xfe00e800

08007f10 <HAL_I2C_Mem_Read>:
{
 8007f10:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007f12:	b089      	sub	sp, #36	; 0x24
 8007f14:	9307      	str	r3, [sp, #28]
 8007f16:	ab0e      	add	r3, sp, #56	; 0x38
 8007f18:	9206      	str	r2, [sp, #24]
 8007f1a:	cb04      	ldmia	r3!, {r2}
 8007f1c:	0004      	movs	r4, r0
 8007f1e:	881b      	ldrh	r3, [r3, #0]
 8007f20:	9203      	str	r2, [sp, #12]
 8007f22:	9304      	str	r3, [sp, #16]
  if(hi2c->State == HAL_I2C_STATE_READY)
 8007f24:	0003      	movs	r3, r0
 8007f26:	3341      	adds	r3, #65	; 0x41
 8007f28:	9305      	str	r3, [sp, #20]
 8007f2a:	781b      	ldrb	r3, [r3, #0]
{
 8007f2c:	000d      	movs	r5, r1
    return HAL_BUSY;
 8007f2e:	2002      	movs	r0, #2
  if(hi2c->State == HAL_I2C_STATE_READY)
 8007f30:	2b20      	cmp	r3, #32
 8007f32:	d102      	bne.n	8007f3a <HAL_I2C_Mem_Read+0x2a>
    if((pData == NULL) || (Size == 0U))
 8007f34:	2a00      	cmp	r2, #0
 8007f36:	d102      	bne.n	8007f3e <HAL_I2C_Mem_Read+0x2e>
        return HAL_ERROR;
 8007f38:	2001      	movs	r0, #1
}
 8007f3a:	b009      	add	sp, #36	; 0x24
 8007f3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((pData == NULL) || (Size == 0U))
 8007f3e:	9b04      	ldr	r3, [sp, #16]
 8007f40:	2b00      	cmp	r3, #0
 8007f42:	d0f9      	beq.n	8007f38 <HAL_I2C_Mem_Read+0x28>
    __HAL_LOCK(hi2c);
 8007f44:	0027      	movs	r7, r4
 8007f46:	3740      	adds	r7, #64	; 0x40
 8007f48:	783b      	ldrb	r3, [r7, #0]
 8007f4a:	2b01      	cmp	r3, #1
 8007f4c:	d0f5      	beq.n	8007f3a <HAL_I2C_Mem_Read+0x2a>
 8007f4e:	2301      	movs	r3, #1
 8007f50:	703b      	strb	r3, [r7, #0]
    tickstart = HAL_GetTick();
 8007f52:	f7ff f863 	bl	800701c <HAL_GetTick>
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8007f56:	2180      	movs	r1, #128	; 0x80
    tickstart = HAL_GetTick();
 8007f58:	9002      	str	r0, [sp, #8]
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8007f5a:	9000      	str	r0, [sp, #0]
 8007f5c:	2319      	movs	r3, #25
 8007f5e:	2201      	movs	r2, #1
 8007f60:	0209      	lsls	r1, r1, #8
 8007f62:	0020      	movs	r0, r4
 8007f64:	f7ff fd9e 	bl	8007aa4 <I2C_WaitOnFlagUntilTimeout>
 8007f68:	1e06      	subs	r6, r0, #0
 8007f6a:	d11e      	bne.n	8007faa <HAL_I2C_Mem_Read+0x9a>
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8007f6c:	2322      	movs	r3, #34	; 0x22
 8007f6e:	9a05      	ldr	r2, [sp, #20]
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8007f70:	0029      	movs	r1, r5
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8007f72:	7013      	strb	r3, [r2, #0]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8007f74:	0023      	movs	r3, r4
 8007f76:	3342      	adds	r3, #66	; 0x42
 8007f78:	9305      	str	r3, [sp, #20]
 8007f7a:	2340      	movs	r3, #64	; 0x40
 8007f7c:	9a05      	ldr	r2, [sp, #20]
 8007f7e:	7013      	strb	r3, [r2, #0]
    hi2c->pBuffPtr  = pData;
 8007f80:	9b03      	ldr	r3, [sp, #12]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007f82:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->pBuffPtr  = pData;
 8007f84:	6263      	str	r3, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
 8007f86:	9b04      	ldr	r3, [sp, #16]
    hi2c->XferISR   = NULL;
 8007f88:	6360      	str	r0, [r4, #52]	; 0x34
    hi2c->XferCount = Size;
 8007f8a:	8563      	strh	r3, [r4, #42]	; 0x2a
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8007f8c:	9b02      	ldr	r3, [sp, #8]
 8007f8e:	9a06      	ldr	r2, [sp, #24]
 8007f90:	9301      	str	r3, [sp, #4]
 8007f92:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007f94:	0020      	movs	r0, r4
 8007f96:	9300      	str	r3, [sp, #0]
 8007f98:	9b07      	ldr	r3, [sp, #28]
 8007f9a:	f7ff fe4a 	bl	8007c32 <I2C_RequestMemoryRead>
 8007f9e:	2800      	cmp	r0, #0
 8007fa0:	d005      	beq.n	8007fae <HAL_I2C_Mem_Read+0x9e>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007fa2:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8007fa4:	703e      	strb	r6, [r7, #0]
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007fa6:	2b04      	cmp	r3, #4
 8007fa8:	d0c6      	beq.n	8007f38 <HAL_I2C_Mem_Read+0x28>
        return HAL_TIMEOUT;
 8007faa:	2003      	movs	r0, #3
 8007fac:	e7c5      	b.n	8007f3a <HAL_I2C_Mem_Read+0x2a>
 8007fae:	2390      	movs	r3, #144	; 0x90
    if(hi2c->XferCount > MAX_NBYTE_SIZE)
 8007fb0:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8007fb2:	019b      	lsls	r3, r3, #6
 8007fb4:	2aff      	cmp	r2, #255	; 0xff
 8007fb6:	d949      	bls.n	800804c <HAL_I2C_Mem_Read+0x13c>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8007fb8:	22ff      	movs	r2, #255	; 0xff
 8007fba:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 8007fbc:	9300      	str	r3, [sp, #0]
 8007fbe:	2380      	movs	r3, #128	; 0x80
 8007fc0:	045b      	lsls	r3, r3, #17
 8007fc2:	0029      	movs	r1, r5
 8007fc4:	0020      	movs	r0, r4
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007fc6:	2680      	movs	r6, #128	; 0x80
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 8007fc8:	f7ff fd5a 	bl	8007a80 <I2C_TransferConfig>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8007fcc:	27ff      	movs	r7, #255	; 0xff
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007fce:	04b6      	lsls	r6, r6, #18
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 8007fd0:	9b02      	ldr	r3, [sp, #8]
 8007fd2:	2200      	movs	r2, #0
 8007fd4:	9300      	str	r3, [sp, #0]
 8007fd6:	2104      	movs	r1, #4
 8007fd8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007fda:	0020      	movs	r0, r4
 8007fdc:	f7ff fd62 	bl	8007aa4 <I2C_WaitOnFlagUntilTimeout>
 8007fe0:	2800      	cmp	r0, #0
 8007fe2:	d1e2      	bne.n	8007faa <HAL_I2C_Mem_Read+0x9a>
      (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
 8007fe4:	6823      	ldr	r3, [r4, #0]
 8007fe6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8007fe8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007fea:	1c59      	adds	r1, r3, #1
 8007fec:	6261      	str	r1, [r4, #36]	; 0x24
 8007fee:	701a      	strb	r2, [r3, #0]
      hi2c->XferSize--;
 8007ff0:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007ff2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007ff4:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 8007ff6:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 8007ff8:	b292      	uxth	r2, r2
      hi2c->XferCount--;
 8007ffa:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8007ffc:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007ffe:	8563      	strh	r3, [r4, #42]	; 0x2a
      if((hi2c->XferSize == 0U) && (hi2c->XferCount != 0U))
 8008000:	2a00      	cmp	r2, #0
 8008002:	d117      	bne.n	8008034 <HAL_I2C_Mem_Read+0x124>
 8008004:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8008006:	2b00      	cmp	r3, #0
 8008008:	d014      	beq.n	8008034 <HAL_I2C_Mem_Read+0x124>
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800800a:	9b02      	ldr	r3, [sp, #8]
 800800c:	2180      	movs	r1, #128	; 0x80
 800800e:	9300      	str	r3, [sp, #0]
 8008010:	0020      	movs	r0, r4
 8008012:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8008014:	f7ff fd46 	bl	8007aa4 <I2C_WaitOnFlagUntilTimeout>
 8008018:	2800      	cmp	r0, #0
 800801a:	d1c6      	bne.n	8007faa <HAL_I2C_Mem_Read+0x9a>
        if(hi2c->XferCount > MAX_NBYTE_SIZE)
 800801c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800801e:	2bff      	cmp	r3, #255	; 0xff
 8008020:	d91c      	bls.n	800805c <HAL_I2C_Mem_Read+0x14c>
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8008022:	2380      	movs	r3, #128	; 0x80
 8008024:	22ff      	movs	r2, #255	; 0xff
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8008026:	8527      	strh	r7, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8008028:	045b      	lsls	r3, r3, #17
 800802a:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800802c:	0029      	movs	r1, r5
 800802e:	0020      	movs	r0, r4
 8008030:	f7ff fd26 	bl	8007a80 <I2C_TransferConfig>
    }while(hi2c->XferCount > 0U);
 8008034:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8008036:	2b00      	cmp	r3, #0
 8008038:	d1ca      	bne.n	8007fd0 <HAL_I2C_Mem_Read+0xc0>
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800803a:	9a02      	ldr	r2, [sp, #8]
 800803c:	9910      	ldr	r1, [sp, #64]	; 0x40
 800803e:	0020      	movs	r0, r4
 8008040:	f7ff fe2a 	bl	8007c98 <I2C_WaitOnSTOPFlagUntilTimeout>
 8008044:	2800      	cmp	r0, #0
 8008046:	d010      	beq.n	800806a <HAL_I2C_Mem_Read+0x15a>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8008048:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800804a:	e7ac      	b.n	8007fa6 <HAL_I2C_Mem_Read+0x96>
      hi2c->XferSize = hi2c->XferCount;
 800804c:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 800804e:	b292      	uxth	r2, r2
 8008050:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 8008052:	9300      	str	r3, [sp, #0]
 8008054:	2380      	movs	r3, #128	; 0x80
 8008056:	b2d2      	uxtb	r2, r2
 8008058:	049b      	lsls	r3, r3, #18
 800805a:	e7b2      	b.n	8007fc2 <HAL_I2C_Mem_Read+0xb2>
          hi2c->XferSize = hi2c->XferCount;
 800805c:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800805e:	0033      	movs	r3, r6
          hi2c->XferSize = hi2c->XferCount;
 8008060:	b292      	uxth	r2, r2
 8008062:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8008064:	b2d2      	uxtb	r2, r2
 8008066:	9000      	str	r0, [sp, #0]
 8008068:	e7e0      	b.n	800802c <HAL_I2C_Mem_Read+0x11c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800806a:	2120      	movs	r1, #32
 800806c:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
 800806e:	4d06      	ldr	r5, [pc, #24]	; (8008088 <HAL_I2C_Mem_Read+0x178>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8008070:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8008072:	685a      	ldr	r2, [r3, #4]
 8008074:	402a      	ands	r2, r5
 8008076:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8008078:	0023      	movs	r3, r4
 800807a:	3341      	adds	r3, #65	; 0x41
 800807c:	7019      	strb	r1, [r3, #0]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800807e:	9b05      	ldr	r3, [sp, #20]
    __HAL_UNLOCK(hi2c);
 8008080:	3440      	adds	r4, #64	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8008082:	7018      	strb	r0, [r3, #0]
    __HAL_UNLOCK(hi2c);
 8008084:	7020      	strb	r0, [r4, #0]
    return HAL_OK;
 8008086:	e758      	b.n	8007f3a <HAL_I2C_Mem_Read+0x2a>
 8008088:	fe00e800 	.word	0xfe00e800

0800808c <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 800808c:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if(hi2c->State == HAL_I2C_STATE_READY)
 800808e:	0004      	movs	r4, r0
 8008090:	3441      	adds	r4, #65	; 0x41
 8008092:	7822      	ldrb	r2, [r4, #0]
{
 8008094:	0003      	movs	r3, r0
  if(hi2c->State == HAL_I2C_STATE_READY)
 8008096:	b2d2      	uxtb	r2, r2

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8008098:	2002      	movs	r0, #2
  if(hi2c->State == HAL_I2C_STATE_READY)
 800809a:	2a20      	cmp	r2, #32
 800809c:	d118      	bne.n	80080d0 <HAL_I2CEx_ConfigAnalogFilter+0x44>
    __HAL_LOCK(hi2c);
 800809e:	001d      	movs	r5, r3
 80080a0:	3540      	adds	r5, #64	; 0x40
 80080a2:	782e      	ldrb	r6, [r5, #0]
 80080a4:	2e01      	cmp	r6, #1
 80080a6:	d013      	beq.n	80080d0 <HAL_I2CEx_ConfigAnalogFilter+0x44>
    __HAL_I2C_DISABLE(hi2c);
 80080a8:	681b      	ldr	r3, [r3, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 80080aa:	3022      	adds	r0, #34	; 0x22
 80080ac:	7020      	strb	r0, [r4, #0]
    __HAL_I2C_DISABLE(hi2c);
 80080ae:	681e      	ldr	r6, [r3, #0]
 80080b0:	3823      	subs	r0, #35	; 0x23
 80080b2:	4386      	bics	r6, r0
 80080b4:	601e      	str	r6, [r3, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 80080b6:	681e      	ldr	r6, [r3, #0]
 80080b8:	4f06      	ldr	r7, [pc, #24]	; (80080d4 <HAL_I2CEx_ConfigAnalogFilter+0x48>)
 80080ba:	403e      	ands	r6, r7
 80080bc:	601e      	str	r6, [r3, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
 80080be:	681e      	ldr	r6, [r3, #0]
 80080c0:	4331      	orrs	r1, r6
 80080c2:	6019      	str	r1, [r3, #0]
    __HAL_I2C_ENABLE(hi2c);
 80080c4:	6819      	ldr	r1, [r3, #0]
 80080c6:	4308      	orrs	r0, r1
 80080c8:	6018      	str	r0, [r3, #0]
    __HAL_UNLOCK(hi2c);
 80080ca:	2000      	movs	r0, #0
    hi2c->State = HAL_I2C_STATE_READY;
 80080cc:	7022      	strb	r2, [r4, #0]
    __HAL_UNLOCK(hi2c);
 80080ce:	7028      	strb	r0, [r5, #0]
  }
}
 80080d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80080d2:	46c0      	nop			; (mov r8, r8)
 80080d4:	ffffefff 	.word	0xffffefff

080080d8 <HAL_RCC_GetHCLKFreq>:
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
 80080d8:	4b01      	ldr	r3, [pc, #4]	; (80080e0 <HAL_RCC_GetHCLKFreq+0x8>)
 80080da:	6818      	ldr	r0, [r3, #0]
}
 80080dc:	4770      	bx	lr
 80080de:	46c0      	nop			; (mov r8, r8)
 80080e0:	20000030 	.word	0x20000030

080080e4 <SPI_WaitFifoStateUntilTimeout.part.1>:
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80080e4:	21e0      	movs	r1, #224	; 0xe0
 80080e6:	6803      	ldr	r3, [r0, #0]
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State,
 80080e8:	b510      	push	{r4, lr}
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80080ea:	685a      	ldr	r2, [r3, #4]
 80080ec:	438a      	bics	r2, r1
 80080ee:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80080f0:	2282      	movs	r2, #130	; 0x82
 80080f2:	6841      	ldr	r1, [r0, #4]
 80080f4:	0052      	lsls	r2, r2, #1
 80080f6:	4291      	cmp	r1, r2
 80080f8:	d10c      	bne.n	8008114 <SPI_WaitFifoStateUntilTimeout.part.1+0x30>
 80080fa:	2180      	movs	r1, #128	; 0x80
 80080fc:	6882      	ldr	r2, [r0, #8]
 80080fe:	0209      	lsls	r1, r1, #8
 8008100:	428a      	cmp	r2, r1
 8008102:	d003      	beq.n	800810c <SPI_WaitFifoStateUntilTimeout.part.1+0x28>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8008104:	2180      	movs	r1, #128	; 0x80
 8008106:	00c9      	lsls	r1, r1, #3
 8008108:	428a      	cmp	r2, r1
 800810a:	d103      	bne.n	8008114 <SPI_WaitFifoStateUntilTimeout.part.1+0x30>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 800810c:	2140      	movs	r1, #64	; 0x40
 800810e:	681a      	ldr	r2, [r3, #0]
 8008110:	438a      	bics	r2, r1
 8008112:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008114:	2180      	movs	r1, #128	; 0x80
 8008116:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8008118:	0189      	lsls	r1, r1, #6
 800811a:	428a      	cmp	r2, r1
 800811c:	d106      	bne.n	800812c <SPI_WaitFifoStateUntilTimeout.part.1+0x48>
        {
          SPI_RESET_CRC(hspi);
 800811e:	6819      	ldr	r1, [r3, #0]
 8008120:	4c07      	ldr	r4, [pc, #28]	; (8008140 <SPI_WaitFifoStateUntilTimeout.part.1+0x5c>)
 8008122:	4021      	ands	r1, r4
 8008124:	6019      	str	r1, [r3, #0]
 8008126:	6819      	ldr	r1, [r3, #0]
 8008128:	430a      	orrs	r2, r1
 800812a:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 800812c:	0003      	movs	r3, r0
 800812e:	2201      	movs	r2, #1
 8008130:	335d      	adds	r3, #93	; 0x5d
 8008132:	701a      	strb	r2, [r3, #0]

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8008134:	2300      	movs	r3, #0
 8008136:	305c      	adds	r0, #92	; 0x5c
 8008138:	7003      	strb	r3, [r0, #0]
      }
    }
  }

  return HAL_OK;
}
 800813a:	2003      	movs	r0, #3
 800813c:	bd10      	pop	{r4, pc}
 800813e:	46c0      	nop			; (mov r8, r8)
 8008140:	ffffdfff 	.word	0xffffdfff

08008144 <SPI_WaitFlagStateUntilTimeout>:
{
 8008144:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008146:	0006      	movs	r6, r0
 8008148:	000d      	movs	r5, r1
 800814a:	0017      	movs	r7, r2
 800814c:	001c      	movs	r4, r3
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 800814e:	6832      	ldr	r2, [r6, #0]
 8008150:	6893      	ldr	r3, [r2, #8]
 8008152:	402b      	ands	r3, r5
 8008154:	1b5b      	subs	r3, r3, r5
 8008156:	4259      	negs	r1, r3
 8008158:	414b      	adcs	r3, r1
 800815a:	429f      	cmp	r7, r3
 800815c:	d101      	bne.n	8008162 <SPI_WaitFlagStateUntilTimeout+0x1e>
  return HAL_OK;
 800815e:	2000      	movs	r0, #0
 8008160:	e006      	b.n	8008170 <SPI_WaitFlagStateUntilTimeout+0x2c>
    if (Timeout != HAL_MAX_DELAY)
 8008162:	1c63      	adds	r3, r4, #1
 8008164:	d0f4      	beq.n	8008150 <SPI_WaitFlagStateUntilTimeout+0xc>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 8008166:	2c00      	cmp	r4, #0
 8008168:	d103      	bne.n	8008172 <SPI_WaitFlagStateUntilTimeout+0x2e>
 800816a:	0030      	movs	r0, r6
 800816c:	f7ff ffba 	bl	80080e4 <SPI_WaitFifoStateUntilTimeout.part.1>
}
 8008170:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 8008172:	f7fe ff53 	bl	800701c <HAL_GetTick>
 8008176:	9b06      	ldr	r3, [sp, #24]
 8008178:	1ac0      	subs	r0, r0, r3
 800817a:	42a0      	cmp	r0, r4
 800817c:	d3e7      	bcc.n	800814e <SPI_WaitFlagStateUntilTimeout+0xa>
 800817e:	e7f4      	b.n	800816a <SPI_WaitFlagStateUntilTimeout+0x26>

08008180 <SPI_WaitFifoStateUntilTimeout>:
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8008180:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8008182:	0007      	movs	r7, r0
 8008184:	000e      	movs	r6, r1
 8008186:	0015      	movs	r5, r2
 8008188:	001c      	movs	r4, r3

  while ((hspi->Instance->SR & Fifo) != State)
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
    {
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 800818a:	466b      	mov	r3, sp
  while ((hspi->Instance->SR & Fifo) != State)
 800818c:	6839      	ldr	r1, [r7, #0]
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 800818e:	1dda      	adds	r2, r3, #7
  while ((hspi->Instance->SR & Fifo) != State)
 8008190:	688b      	ldr	r3, [r1, #8]
 8008192:	4033      	ands	r3, r6
 8008194:	42ab      	cmp	r3, r5
 8008196:	d101      	bne.n	800819c <SPI_WaitFifoStateUntilTimeout+0x1c>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 8008198:	2000      	movs	r0, #0
 800819a:	e010      	b.n	80081be <SPI_WaitFifoStateUntilTimeout+0x3e>
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 800819c:	23c0      	movs	r3, #192	; 0xc0
 800819e:	00db      	lsls	r3, r3, #3
 80081a0:	429e      	cmp	r6, r3
 80081a2:	d105      	bne.n	80081b0 <SPI_WaitFifoStateUntilTimeout+0x30>
 80081a4:	2d00      	cmp	r5, #0
 80081a6:	d103      	bne.n	80081b0 <SPI_WaitFifoStateUntilTimeout+0x30>
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 80081a8:	7b0b      	ldrb	r3, [r1, #12]
 80081aa:	b2db      	uxtb	r3, r3
 80081ac:	7013      	strb	r3, [r2, #0]
      UNUSED(tmpreg);
 80081ae:	7813      	ldrb	r3, [r2, #0]
    if (Timeout != HAL_MAX_DELAY)
 80081b0:	1c63      	adds	r3, r4, #1
 80081b2:	d0ed      	beq.n	8008190 <SPI_WaitFifoStateUntilTimeout+0x10>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 80081b4:	2c00      	cmp	r4, #0
 80081b6:	d103      	bne.n	80081c0 <SPI_WaitFifoStateUntilTimeout+0x40>
 80081b8:	0038      	movs	r0, r7
 80081ba:	f7ff ff93 	bl	80080e4 <SPI_WaitFifoStateUntilTimeout.part.1>
}
 80081be:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 80081c0:	f7fe ff2c 	bl	800701c <HAL_GetTick>
 80081c4:	9b08      	ldr	r3, [sp, #32]
 80081c6:	1ac0      	subs	r0, r0, r3
 80081c8:	42a0      	cmp	r0, r4
 80081ca:	d3de      	bcc.n	800818a <SPI_WaitFifoStateUntilTimeout+0xa>
 80081cc:	e7f4      	b.n	80081b8 <SPI_WaitFifoStateUntilTimeout+0x38>

080081ce <SPI_EndRxTransaction>:
  * @param  Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
{
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80081ce:	2382      	movs	r3, #130	; 0x82
{
 80081d0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80081d2:	0017      	movs	r7, r2
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80081d4:	6842      	ldr	r2, [r0, #4]
{
 80081d6:	0004      	movs	r4, r0
 80081d8:	000e      	movs	r6, r1
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80081da:	005b      	lsls	r3, r3, #1
 80081dc:	429a      	cmp	r2, r3
 80081de:	d10d      	bne.n	80081fc <SPI_EndRxTransaction+0x2e>
 80081e0:	2280      	movs	r2, #128	; 0x80
 80081e2:	6883      	ldr	r3, [r0, #8]
 80081e4:	0212      	lsls	r2, r2, #8
 80081e6:	4293      	cmp	r3, r2
 80081e8:	d003      	beq.n	80081f2 <SPI_EndRxTransaction+0x24>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80081ea:	2280      	movs	r2, #128	; 0x80
 80081ec:	00d2      	lsls	r2, r2, #3
 80081ee:	4293      	cmp	r3, r2
 80081f0:	d104      	bne.n	80081fc <SPI_EndRxTransaction+0x2e>
  {
    /* Disable SPI peripheral */
    __HAL_SPI_DISABLE(hspi);
 80081f2:	2140      	movs	r1, #64	; 0x40
 80081f4:	6822      	ldr	r2, [r4, #0]
 80081f6:	6813      	ldr	r3, [r2, #0]
 80081f8:	438b      	bics	r3, r1
 80081fa:	6013      	str	r3, [r2, #0]
  }

  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 80081fc:	9700      	str	r7, [sp, #0]
 80081fe:	0033      	movs	r3, r6
 8008200:	2200      	movs	r2, #0
 8008202:	2180      	movs	r1, #128	; 0x80
 8008204:	0020      	movs	r0, r4
 8008206:	f7ff ff9d 	bl	8008144 <SPI_WaitFlagStateUntilTimeout>
 800820a:	1e05      	subs	r5, r0, #0
 800820c:	d005      	beq.n	800821a <SPI_EndRxTransaction+0x4c>
  }

  /* Control if the RX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800820e:	2320      	movs	r3, #32
 8008210:	6e22      	ldr	r2, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 8008212:	2503      	movs	r5, #3
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8008214:	4313      	orrs	r3, r2
 8008216:	6623      	str	r3, [r4, #96]	; 0x60
 8008218:	e017      	b.n	800824a <SPI_EndRxTransaction+0x7c>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800821a:	2382      	movs	r3, #130	; 0x82
 800821c:	6862      	ldr	r2, [r4, #4]
 800821e:	005b      	lsls	r3, r3, #1
 8008220:	429a      	cmp	r2, r3
 8008222:	d112      	bne.n	800824a <SPI_EndRxTransaction+0x7c>
 8008224:	2280      	movs	r2, #128	; 0x80
 8008226:	68a3      	ldr	r3, [r4, #8]
 8008228:	0212      	lsls	r2, r2, #8
 800822a:	4293      	cmp	r3, r2
 800822c:	d003      	beq.n	8008236 <SPI_EndRxTransaction+0x68>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800822e:	2280      	movs	r2, #128	; 0x80
 8008230:	00d2      	lsls	r2, r2, #3
 8008232:	4293      	cmp	r3, r2
 8008234:	d109      	bne.n	800824a <SPI_EndRxTransaction+0x7c>
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8008236:	21c0      	movs	r1, #192	; 0xc0
 8008238:	9700      	str	r7, [sp, #0]
 800823a:	0033      	movs	r3, r6
 800823c:	2200      	movs	r2, #0
 800823e:	00c9      	lsls	r1, r1, #3
 8008240:	0020      	movs	r0, r4
 8008242:	f7ff ff9d 	bl	8008180 <SPI_WaitFifoStateUntilTimeout>
 8008246:	2800      	cmp	r0, #0
 8008248:	d1e1      	bne.n	800820e <SPI_EndRxTransaction+0x40>
}
 800824a:	0028      	movs	r0, r5
 800824c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

0800824e <SPI_EndRxTxTransaction>:
{
 800824e:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8008250:	000b      	movs	r3, r1
{
 8008252:	000d      	movs	r5, r1
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8008254:	21c0      	movs	r1, #192	; 0xc0
 8008256:	9200      	str	r2, [sp, #0]
{
 8008258:	0016      	movs	r6, r2
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 800825a:	0149      	lsls	r1, r1, #5
 800825c:	2200      	movs	r2, #0
{
 800825e:	0004      	movs	r4, r0
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8008260:	f7ff ff8e 	bl	8008180 <SPI_WaitFifoStateUntilTimeout>
 8008264:	1e02      	subs	r2, r0, #0
 8008266:	d005      	beq.n	8008274 <SPI_EndRxTxTransaction+0x26>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8008268:	2320      	movs	r3, #32
 800826a:	6e22      	ldr	r2, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 800826c:	2003      	movs	r0, #3
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800826e:	4313      	orrs	r3, r2
 8008270:	6623      	str	r3, [r4, #96]	; 0x60
 8008272:	e010      	b.n	8008296 <SPI_EndRxTxTransaction+0x48>
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8008274:	9600      	str	r6, [sp, #0]
 8008276:	002b      	movs	r3, r5
 8008278:	2180      	movs	r1, #128	; 0x80
 800827a:	0020      	movs	r0, r4
 800827c:	f7ff ff62 	bl	8008144 <SPI_WaitFlagStateUntilTimeout>
 8008280:	1e02      	subs	r2, r0, #0
 8008282:	d1f1      	bne.n	8008268 <SPI_EndRxTxTransaction+0x1a>
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8008284:	21c0      	movs	r1, #192	; 0xc0
 8008286:	9600      	str	r6, [sp, #0]
 8008288:	002b      	movs	r3, r5
 800828a:	00c9      	lsls	r1, r1, #3
 800828c:	0020      	movs	r0, r4
 800828e:	f7ff ff77 	bl	8008180 <SPI_WaitFifoStateUntilTimeout>
 8008292:	2800      	cmp	r0, #0
 8008294:	d1e8      	bne.n	8008268 <SPI_EndRxTxTransaction+0x1a>
  }
  return HAL_OK;
}
 8008296:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08008298 <HAL_SPI_Init>:
{
 8008298:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800829a:	0004      	movs	r4, r0
    return HAL_ERROR;
 800829c:	2001      	movs	r0, #1
  if (hspi == NULL)
 800829e:	2c00      	cmp	r4, #0
 80082a0:	d05f      	beq.n	8008362 <HAL_SPI_Init+0xca>
  if (hspi->State == HAL_SPI_STATE_RESET)
 80082a2:	0025      	movs	r5, r4
 80082a4:	355d      	adds	r5, #93	; 0x5d
 80082a6:	782b      	ldrb	r3, [r5, #0]
 80082a8:	b2db      	uxtb	r3, r3
 80082aa:	2b00      	cmp	r3, #0
 80082ac:	d105      	bne.n	80082ba <HAL_SPI_Init+0x22>
    hspi->Lock = HAL_UNLOCKED;
 80082ae:	0022      	movs	r2, r4
 80082b0:	325c      	adds	r2, #92	; 0x5c
 80082b2:	7013      	strb	r3, [r2, #0]
    HAL_SPI_MspInit(hspi);
 80082b4:	0020      	movs	r0, r4
 80082b6:	f7fd fddb 	bl	8005e70 <HAL_SPI_MspInit>
  hspi->State = HAL_SPI_STATE_BUSY;
 80082ba:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);
 80082bc:	2140      	movs	r1, #64	; 0x40
 80082be:	6822      	ldr	r2, [r4, #0]
  hspi->State = HAL_SPI_STATE_BUSY;
 80082c0:	702b      	strb	r3, [r5, #0]
  __HAL_SPI_DISABLE(hspi);
 80082c2:	6813      	ldr	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80082c4:	68e0      	ldr	r0, [r4, #12]
  __HAL_SPI_DISABLE(hspi);
 80082c6:	438b      	bics	r3, r1
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80082c8:	21e0      	movs	r1, #224	; 0xe0
  __HAL_SPI_DISABLE(hspi);
 80082ca:	6013      	str	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80082cc:	00c9      	lsls	r1, r1, #3
 80082ce:	2300      	movs	r3, #0
 80082d0:	4288      	cmp	r0, r1
 80082d2:	d847      	bhi.n	8008364 <HAL_SPI_Init+0xcc>
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 80082d4:	2680      	movs	r6, #128	; 0x80
 80082d6:	0176      	lsls	r6, r6, #5
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 80082d8:	4288      	cmp	r0, r1
 80082da:	d101      	bne.n	80082e0 <HAL_SPI_Init+0x48>
 80082dc:	e001      	b.n	80082e2 <HAL_SPI_Init+0x4a>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 80082de:	001e      	movs	r6, r3
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80082e0:	62a3      	str	r3, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 80082e2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80082e4:	2b00      	cmp	r3, #0
 80082e6:	d104      	bne.n	80082f2 <HAL_SPI_Init+0x5a>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 80082e8:	3302      	adds	r3, #2
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80082ea:	4288      	cmp	r0, r1
 80082ec:	d800      	bhi.n	80082f0 <HAL_SPI_Init+0x58>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 80082ee:	2301      	movs	r3, #1
 80082f0:	6323      	str	r3, [r4, #48]	; 0x30
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 80082f2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80082f4:	68a7      	ldr	r7, [r4, #8]
 80082f6:	9301      	str	r3, [sp, #4]
 80082f8:	6863      	ldr	r3, [r4, #4]
 80082fa:	69a1      	ldr	r1, [r4, #24]
 80082fc:	433b      	orrs	r3, r7
 80082fe:	6927      	ldr	r7, [r4, #16]
 8008300:	433b      	orrs	r3, r7
 8008302:	6967      	ldr	r7, [r4, #20]
 8008304:	433b      	orrs	r3, r7
 8008306:	69e7      	ldr	r7, [r4, #28]
 8008308:	433b      	orrs	r3, r7
 800830a:	6a27      	ldr	r7, [r4, #32]
 800830c:	433b      	orrs	r3, r7
 800830e:	9f01      	ldr	r7, [sp, #4]
 8008310:	433b      	orrs	r3, r7
 8008312:	2780      	movs	r7, #128	; 0x80
 8008314:	00bf      	lsls	r7, r7, #2
 8008316:	400f      	ands	r7, r1
 8008318:	433b      	orrs	r3, r7
 800831a:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 800831c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800831e:	2b02      	cmp	r3, #2
 8008320:	d106      	bne.n	8008330 <HAL_SPI_Init+0x98>
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
 8008322:	6813      	ldr	r3, [r2, #0]
 8008324:	469c      	mov	ip, r3
 8008326:	2380      	movs	r3, #128	; 0x80
 8008328:	4667      	mov	r7, ip
 800832a:	011b      	lsls	r3, r3, #4
 800832c:	433b      	orrs	r3, r7
 800832e:	6013      	str	r3, [r2, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8008330:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008332:	0c09      	lsrs	r1, r1, #16
 8008334:	4318      	orrs	r0, r3
 8008336:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8008338:	4318      	orrs	r0, r3
 800833a:	2304      	movs	r3, #4
 800833c:	4019      	ands	r1, r3
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800833e:	2380      	movs	r3, #128	; 0x80
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8008340:	4301      	orrs	r1, r0
 8008342:	430e      	orrs	r6, r1
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008344:	9901      	ldr	r1, [sp, #4]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8008346:	6056      	str	r6, [r2, #4]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008348:	019b      	lsls	r3, r3, #6
 800834a:	4299      	cmp	r1, r3
 800834c:	d101      	bne.n	8008352 <HAL_SPI_Init+0xba>
    WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
 800834e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8008350:	6113      	str	r3, [r2, #16]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8008352:	69d3      	ldr	r3, [r2, #28]
 8008354:	4906      	ldr	r1, [pc, #24]	; (8008370 <HAL_SPI_Init+0xd8>)
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8008356:	2000      	movs	r0, #0
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8008358:	400b      	ands	r3, r1
 800835a:	61d3      	str	r3, [r2, #28]
  hspi->State     = HAL_SPI_STATE_READY;
 800835c:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800835e:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8008360:	702b      	strb	r3, [r5, #0]
}
 8008362:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8008364:	26f0      	movs	r6, #240	; 0xf0
 8008366:	0136      	lsls	r6, r6, #4
 8008368:	42b0      	cmp	r0, r6
 800836a:	d1b8      	bne.n	80082de <HAL_SPI_Init+0x46>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 800836c:	001e      	movs	r6, r3
 800836e:	e7b8      	b.n	80082e2 <HAL_SPI_Init+0x4a>
 8008370:	fffff7ff 	.word	0xfffff7ff

08008374 <HAL_SPI_Transmit_DMA>:
{
 8008374:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hspi);
 8008376:	0005      	movs	r5, r0
 8008378:	355c      	adds	r5, #92	; 0x5c
 800837a:	782b      	ldrb	r3, [r5, #0]
{
 800837c:	0004      	movs	r4, r0
  __HAL_LOCK(hspi);
 800837e:	2002      	movs	r0, #2
 8008380:	2b01      	cmp	r3, #1
 8008382:	d069      	beq.n	8008458 <HAL_SPI_Transmit_DMA+0xe4>
 8008384:	2301      	movs	r3, #1
  if (hspi->State != HAL_SPI_STATE_READY)
 8008386:	0026      	movs	r6, r4
  __HAL_LOCK(hspi);
 8008388:	702b      	strb	r3, [r5, #0]
  if (hspi->State != HAL_SPI_STATE_READY)
 800838a:	365d      	adds	r6, #93	; 0x5d
 800838c:	7833      	ldrb	r3, [r6, #0]
 800838e:	b2db      	uxtb	r3, r3
 8008390:	2b01      	cmp	r3, #1
 8008392:	d15f      	bne.n	8008454 <HAL_SPI_Transmit_DMA+0xe0>
    errorcode = HAL_ERROR;
 8008394:	0018      	movs	r0, r3
  if ((pData == NULL) || (Size == 0U))
 8008396:	2900      	cmp	r1, #0
 8008398:	d05c      	beq.n	8008454 <HAL_SPI_Transmit_DMA+0xe0>
 800839a:	2a00      	cmp	r2, #0
 800839c:	d05a      	beq.n	8008454 <HAL_SPI_Transmit_DMA+0xe0>
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 800839e:	3302      	adds	r3, #2
 80083a0:	7033      	strb	r3, [r6, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80083a2:	2300      	movs	r3, #0
  hspi->TxXferSize  = Size;
 80083a4:	87a2      	strh	r2, [r4, #60]	; 0x3c
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80083a6:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->TxXferCount = Size;
 80083a8:	87e2      	strh	r2, [r4, #62]	; 0x3e
  hspi->RxXferSize  = 0U;
 80083aa:	1da2      	adds	r2, r4, #6
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 80083ac:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->TxISR       = NULL;
 80083ae:	6523      	str	r3, [r4, #80]	; 0x50
  hspi->RxISR       = NULL;
 80083b0:	64e3      	str	r3, [r4, #76]	; 0x4c
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 80083b2:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->RxXferCount = 0U;
 80083b4:	3202      	adds	r2, #2
  hspi->RxXferSize  = 0U;
 80083b6:	8793      	strh	r3, [r2, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 80083b8:	87d3      	strh	r3, [r2, #62]	; 0x3e
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80083ba:	2380      	movs	r3, #128	; 0x80
 80083bc:	68a0      	ldr	r0, [r4, #8]
 80083be:	6822      	ldr	r2, [r4, #0]
 80083c0:	021b      	lsls	r3, r3, #8
 80083c2:	4298      	cmp	r0, r3
 80083c4:	d104      	bne.n	80083d0 <HAL_SPI_Transmit_DMA+0x5c>
    SPI_1LINE_TX(hspi);
 80083c6:	2380      	movs	r3, #128	; 0x80
 80083c8:	6810      	ldr	r0, [r2, #0]
 80083ca:	01db      	lsls	r3, r3, #7
 80083cc:	4303      	orrs	r3, r0
 80083ce:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80083d0:	2080      	movs	r0, #128	; 0x80
 80083d2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80083d4:	0180      	lsls	r0, r0, #6
 80083d6:	4283      	cmp	r3, r0
 80083d8:	d106      	bne.n	80083e8 <HAL_SPI_Transmit_DMA+0x74>
    SPI_RESET_CRC(hspi);
 80083da:	6810      	ldr	r0, [r2, #0]
 80083dc:	4e23      	ldr	r6, [pc, #140]	; (800846c <HAL_SPI_Transmit_DMA+0xf8>)
 80083de:	4030      	ands	r0, r6
 80083e0:	6010      	str	r0, [r2, #0]
 80083e2:	6810      	ldr	r0, [r2, #0]
 80083e4:	4303      	orrs	r3, r0
 80083e6:	6013      	str	r3, [r2, #0]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 80083e8:	6d60      	ldr	r0, [r4, #84]	; 0x54
 80083ea:	4b21      	ldr	r3, [pc, #132]	; (8008470 <HAL_SPI_Transmit_DMA+0xfc>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80083ec:	6856      	ldr	r6, [r2, #4]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 80083ee:	62c3      	str	r3, [r0, #44]	; 0x2c
  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
 80083f0:	4b20      	ldr	r3, [pc, #128]	; (8008474 <HAL_SPI_Transmit_DMA+0x100>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80083f2:	4f21      	ldr	r7, [pc, #132]	; (8008478 <HAL_SPI_Transmit_DMA+0x104>)
  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
 80083f4:	6283      	str	r3, [r0, #40]	; 0x28
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 80083f6:	4b21      	ldr	r3, [pc, #132]	; (800847c <HAL_SPI_Transmit_DMA+0x108>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80083f8:	403e      	ands	r6, r7
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 80083fa:	6303      	str	r3, [r0, #48]	; 0x30
  hspi->hdmatx->XferAbortCallback = NULL;
 80083fc:	2300      	movs	r3, #0
 80083fe:	6343      	str	r3, [r0, #52]	; 0x34
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 8008400:	23e0      	movs	r3, #224	; 0xe0
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8008402:	6056      	str	r6, [r2, #4]
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 8008404:	68e6      	ldr	r6, [r4, #12]
 8008406:	00db      	lsls	r3, r3, #3
 8008408:	429e      	cmp	r6, r3
 800840a:	d80d      	bhi.n	8008428 <HAL_SPI_Transmit_DMA+0xb4>
 800840c:	2380      	movs	r3, #128	; 0x80
 800840e:	6946      	ldr	r6, [r0, #20]
 8008410:	00db      	lsls	r3, r3, #3
 8008412:	429e      	cmp	r6, r3
 8008414:	d108      	bne.n	8008428 <HAL_SPI_Transmit_DMA+0xb4>
    if ((hspi->TxXferCount & 0x1U) == 0U)
 8008416:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8008418:	07db      	lsls	r3, r3, #31
 800841a:	d41e      	bmi.n	800845a <HAL_SPI_Transmit_DMA+0xe6>
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 800841c:	6853      	ldr	r3, [r2, #4]
 800841e:	403b      	ands	r3, r7
 8008420:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U);
 8008422:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8008424:	085b      	lsrs	r3, r3, #1
      hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 8008426:	87e3      	strh	r3, [r4, #62]	; 0x3e
  HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
 8008428:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800842a:	320c      	adds	r2, #12
 800842c:	b29b      	uxth	r3, r3
 800842e:	f7ff f9ef 	bl	8007810 <HAL_DMA_Start_IT>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8008432:	2240      	movs	r2, #64	; 0x40
 8008434:	6823      	ldr	r3, [r4, #0]
 8008436:	6819      	ldr	r1, [r3, #0]
 8008438:	4211      	tst	r1, r2
 800843a:	d102      	bne.n	8008442 <HAL_SPI_Transmit_DMA+0xce>
    __HAL_SPI_ENABLE(hspi);
 800843c:	6819      	ldr	r1, [r3, #0]
 800843e:	430a      	orrs	r2, r1
 8008440:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 8008442:	2220      	movs	r2, #32
 8008444:	6859      	ldr	r1, [r3, #4]
  HAL_StatusTypeDef errorcode = HAL_OK;
 8008446:	2000      	movs	r0, #0
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 8008448:	430a      	orrs	r2, r1
 800844a:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 800844c:	2202      	movs	r2, #2
 800844e:	6859      	ldr	r1, [r3, #4]
 8008450:	430a      	orrs	r2, r1
 8008452:	605a      	str	r2, [r3, #4]
  __HAL_UNLOCK(hspi);
 8008454:	2300      	movs	r3, #0
 8008456:	702b      	strb	r3, [r5, #0]
}
 8008458:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 800845a:	2380      	movs	r3, #128	; 0x80
 800845c:	6856      	ldr	r6, [r2, #4]
 800845e:	01db      	lsls	r3, r3, #7
 8008460:	4333      	orrs	r3, r6
 8008462:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 8008464:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8008466:	085b      	lsrs	r3, r3, #1
 8008468:	3301      	adds	r3, #1
 800846a:	e7dc      	b.n	8008426 <HAL_SPI_Transmit_DMA+0xb2>
 800846c:	ffffdfff 	.word	0xffffdfff
 8008470:	080087cd 	.word	0x080087cd
 8008474:	08008815 	.word	0x08008815
 8008478:	ffffbfff 	.word	0xffffbfff
 800847c:	080087f1 	.word	0x080087f1

08008480 <HAL_SPI_TransmitReceive_DMA>:
{
 8008480:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __HAL_LOCK(hspi);
 8008482:	0006      	movs	r6, r0
 8008484:	365c      	adds	r6, #92	; 0x5c
 8008486:	9601      	str	r6, [sp, #4]
 8008488:	7835      	ldrb	r5, [r6, #0]
{
 800848a:	0004      	movs	r4, r0
  __HAL_LOCK(hspi);
 800848c:	2002      	movs	r0, #2
 800848e:	2d01      	cmp	r5, #1
 8008490:	d07d      	beq.n	800858e <HAL_SPI_TransmitReceive_DMA+0x10e>
 8008492:	0035      	movs	r5, r6
 8008494:	3801      	subs	r0, #1
 8008496:	7030      	strb	r0, [r6, #0]
  tmp  = hspi->State;
 8008498:	3501      	adds	r5, #1
 800849a:	782f      	ldrb	r7, [r5, #0]
 800849c:	b2ff      	uxtb	r7, r7
  if (!((tmp == HAL_SPI_STATE_READY) ||
 800849e:	4287      	cmp	r7, r0
 80084a0:	d00c      	beq.n	80084bc <HAL_SPI_TransmitReceive_DMA+0x3c>
 80084a2:	3004      	adds	r0, #4
 80084a4:	30ff      	adds	r0, #255	; 0xff
 80084a6:	4684      	mov	ip, r0
 80084a8:	6866      	ldr	r6, [r4, #4]
    errorcode = HAL_BUSY;
 80084aa:	3803      	subs	r0, #3
 80084ac:	38ff      	subs	r0, #255	; 0xff
  if (!((tmp == HAL_SPI_STATE_READY) ||
 80084ae:	4566      	cmp	r6, ip
 80084b0:	d16a      	bne.n	8008588 <HAL_SPI_TransmitReceive_DMA+0x108>
        ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
 80084b2:	68a6      	ldr	r6, [r4, #8]
 80084b4:	2e00      	cmp	r6, #0
 80084b6:	d167      	bne.n	8008588 <HAL_SPI_TransmitReceive_DMA+0x108>
 80084b8:	2f04      	cmp	r7, #4
 80084ba:	d165      	bne.n	8008588 <HAL_SPI_TransmitReceive_DMA+0x108>
    errorcode = HAL_ERROR;
 80084bc:	2001      	movs	r0, #1
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 80084be:	2900      	cmp	r1, #0
 80084c0:	d062      	beq.n	8008588 <HAL_SPI_TransmitReceive_DMA+0x108>
 80084c2:	2a00      	cmp	r2, #0
 80084c4:	d060      	beq.n	8008588 <HAL_SPI_TransmitReceive_DMA+0x108>
 80084c6:	2b00      	cmp	r3, #0
 80084c8:	d05e      	beq.n	8008588 <HAL_SPI_TransmitReceive_DMA+0x108>
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 80084ca:	7828      	ldrb	r0, [r5, #0]
 80084cc:	2804      	cmp	r0, #4
 80084ce:	d001      	beq.n	80084d4 <HAL_SPI_TransmitReceive_DMA+0x54>
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 80084d0:	2005      	movs	r0, #5
 80084d2:	7028      	strb	r0, [r5, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80084d4:	2000      	movs	r0, #0
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80084d6:	2780      	movs	r7, #128	; 0x80
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 80084d8:	6422      	str	r2, [r4, #64]	; 0x40
  hspi->RxXferSize  = Size;
 80084da:	1da2      	adds	r2, r4, #6
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 80084dc:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 80084de:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->TxXferSize  = Size;
 80084e0:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
 80084e2:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->RxXferCount = Size;
 80084e4:	3202      	adds	r2, #2
  hspi->RxXferSize  = Size;
 80084e6:	8793      	strh	r3, [r2, #60]	; 0x3c
  hspi->RxXferCount = Size;
 80084e8:	87d3      	strh	r3, [r2, #62]	; 0x3e
  hspi->RxISR       = NULL;
 80084ea:	64e0      	str	r0, [r4, #76]	; 0x4c
  hspi->TxISR       = NULL;
 80084ec:	6520      	str	r0, [r4, #80]	; 0x50
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80084ee:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80084f0:	6821      	ldr	r1, [r4, #0]
 80084f2:	01bf      	lsls	r7, r7, #6
 80084f4:	42b8      	cmp	r0, r7
 80084f6:	d106      	bne.n	8008506 <HAL_SPI_TransmitReceive_DMA+0x86>
    SPI_RESET_CRC(hspi);
 80084f8:	680f      	ldr	r7, [r1, #0]
 80084fa:	4e45      	ldr	r6, [pc, #276]	; (8008610 <HAL_SPI_TransmitReceive_DMA+0x190>)
 80084fc:	4037      	ands	r7, r6
 80084fe:	600f      	str	r7, [r1, #0]
 8008500:	680f      	ldr	r7, [r1, #0]
 8008502:	4338      	orrs	r0, r7
 8008504:	6008      	str	r0, [r1, #0]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
 8008506:	6848      	ldr	r0, [r1, #4]
 8008508:	4f42      	ldr	r7, [pc, #264]	; (8008614 <HAL_SPI_TransmitReceive_DMA+0x194>)
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800850a:	68e6      	ldr	r6, [r4, #12]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
 800850c:	4038      	ands	r0, r7
 800850e:	6048      	str	r0, [r1, #4]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008510:	20e0      	movs	r0, #224	; 0xe0
 8008512:	00c0      	lsls	r0, r0, #3
 8008514:	4286      	cmp	r6, r0
 8008516:	d93b      	bls.n	8008590 <HAL_SPI_TransmitReceive_DMA+0x110>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8008518:	684b      	ldr	r3, [r1, #4]
 800851a:	483f      	ldr	r0, [pc, #252]	; (8008618 <HAL_SPI_TransmitReceive_DMA+0x198>)
 800851c:	4003      	ands	r3, r0
 800851e:	604b      	str	r3, [r1, #4]
  if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 8008520:	782b      	ldrb	r3, [r5, #0]
 8008522:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8008524:	2b04      	cmp	r3, #4
 8008526:	d000      	beq.n	800852a <HAL_SPI_TransmitReceive_DMA+0xaa>
 8008528:	e06d      	b.n	8008606 <HAL_SPI_TransmitReceive_DMA+0x186>
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 800852a:	4b3c      	ldr	r3, [pc, #240]	; (800861c <HAL_SPI_TransmitReceive_DMA+0x19c>)
 800852c:	62c3      	str	r3, [r0, #44]	; 0x2c
    hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
 800852e:	4b3c      	ldr	r3, [pc, #240]	; (8008620 <HAL_SPI_TransmitReceive_DMA+0x1a0>)
  hspi->hdmarx->XferAbortCallback = NULL;
 8008530:	2500      	movs	r5, #0
    hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
 8008532:	6283      	str	r3, [r0, #40]	; 0x28
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 8008534:	4b3b      	ldr	r3, [pc, #236]	; (8008624 <HAL_SPI_TransmitReceive_DMA+0x1a4>)
  hspi->hdmarx->XferAbortCallback = NULL;
 8008536:	6345      	str	r5, [r0, #52]	; 0x34
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 8008538:	6303      	str	r3, [r0, #48]	; 0x30
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 800853a:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 800853c:	310c      	adds	r1, #12
 800853e:	b29b      	uxth	r3, r3
 8008540:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8008542:	f7ff f965 	bl	8007810 <HAL_DMA_Start_IT>
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 8008546:	2301      	movs	r3, #1
 8008548:	6822      	ldr	r2, [r4, #0]
  hspi->hdmatx->XferHalfCpltCallback = NULL;
 800854a:	6d60      	ldr	r0, [r4, #84]	; 0x54
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 800854c:	6851      	ldr	r1, [r2, #4]
 800854e:	430b      	orrs	r3, r1
 8008550:	6053      	str	r3, [r2, #4]
  hspi->hdmatx->XferHalfCpltCallback = NULL;
 8008552:	62c5      	str	r5, [r0, #44]	; 0x2c
  hspi->hdmatx->XferCpltCallback     = NULL;
 8008554:	6285      	str	r5, [r0, #40]	; 0x28
  hspi->hdmatx->XferErrorCallback    = NULL;
 8008556:	6305      	str	r5, [r0, #48]	; 0x30
  hspi->hdmatx->XferAbortCallback    = NULL;
 8008558:	6345      	str	r5, [r0, #52]	; 0x34
  HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
 800855a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800855c:	320c      	adds	r2, #12
 800855e:	b29b      	uxth	r3, r3
 8008560:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8008562:	f7ff f955 	bl	8007810 <HAL_DMA_Start_IT>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8008566:	2240      	movs	r2, #64	; 0x40
 8008568:	6823      	ldr	r3, [r4, #0]
 800856a:	6819      	ldr	r1, [r3, #0]
 800856c:	4211      	tst	r1, r2
 800856e:	d102      	bne.n	8008576 <HAL_SPI_TransmitReceive_DMA+0xf6>
    __HAL_SPI_ENABLE(hspi);
 8008570:	6819      	ldr	r1, [r3, #0]
 8008572:	430a      	orrs	r2, r1
 8008574:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 8008576:	2220      	movs	r2, #32
 8008578:	6859      	ldr	r1, [r3, #4]
  HAL_StatusTypeDef errorcode = HAL_OK;
 800857a:	2000      	movs	r0, #0
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 800857c:	430a      	orrs	r2, r1
 800857e:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8008580:	2202      	movs	r2, #2
 8008582:	6859      	ldr	r1, [r3, #4]
 8008584:	430a      	orrs	r2, r1
 8008586:	605a      	str	r2, [r3, #4]
  __HAL_UNLOCK(hspi);
 8008588:	2300      	movs	r3, #0
 800858a:	9a01      	ldr	r2, [sp, #4]
 800858c:	7013      	strb	r3, [r2, #0]
}
 800858e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8008590:	2080      	movs	r0, #128	; 0x80
 8008592:	684f      	ldr	r7, [r1, #4]
 8008594:	0140      	lsls	r0, r0, #5
 8008596:	4338      	orrs	r0, r7
 8008598:	6048      	str	r0, [r1, #4]
    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 800859a:	2080      	movs	r0, #128	; 0x80
 800859c:	6d67      	ldr	r7, [r4, #84]	; 0x54
 800859e:	00c0      	lsls	r0, r0, #3
 80085a0:	697f      	ldr	r7, [r7, #20]
 80085a2:	4287      	cmp	r7, r0
 80085a4:	d108      	bne.n	80085b8 <HAL_SPI_TransmitReceive_DMA+0x138>
      if ((hspi->TxXferSize & 0x1U) == 0x0U)
 80085a6:	07db      	lsls	r3, r3, #31
 80085a8:	d41b      	bmi.n	80085e2 <HAL_SPI_TransmitReceive_DMA+0x162>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80085aa:	684b      	ldr	r3, [r1, #4]
 80085ac:	481e      	ldr	r0, [pc, #120]	; (8008628 <HAL_SPI_TransmitReceive_DMA+0x1a8>)
 80085ae:	4003      	ands	r3, r0
 80085b0:	604b      	str	r3, [r1, #4]
        hspi->TxXferCount = hspi->TxXferCount >> 1U;
 80085b2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80085b4:	085b      	lsrs	r3, r3, #1
        hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 80085b6:	87e3      	strh	r3, [r4, #62]	; 0x3e
    if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 80085b8:	2380      	movs	r3, #128	; 0x80
 80085ba:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80085bc:	00db      	lsls	r3, r3, #3
 80085be:	6940      	ldr	r0, [r0, #20]
 80085c0:	4298      	cmp	r0, r3
 80085c2:	d1ad      	bne.n	8008520 <HAL_SPI_TransmitReceive_DMA+0xa0>
      CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80085c4:	684b      	ldr	r3, [r1, #4]
 80085c6:	4814      	ldr	r0, [pc, #80]	; (8008618 <HAL_SPI_TransmitReceive_DMA+0x198>)
 80085c8:	4003      	ands	r3, r0
 80085ca:	604b      	str	r3, [r1, #4]
      if ((hspi->RxXferCount & 0x1U) == 0x0U)
 80085cc:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 80085ce:	07db      	lsls	r3, r3, #31
 80085d0:	d410      	bmi.n	80085f4 <HAL_SPI_TransmitReceive_DMA+0x174>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 80085d2:	684b      	ldr	r3, [r1, #4]
 80085d4:	480e      	ldr	r0, [pc, #56]	; (8008610 <HAL_SPI_TransmitReceive_DMA+0x190>)
 80085d6:	4003      	ands	r3, r0
 80085d8:	604b      	str	r3, [r1, #4]
        hspi->RxXferCount = hspi->RxXferCount >> 1U;
 80085da:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 80085dc:	085b      	lsrs	r3, r3, #1
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 80085de:	87d3      	strh	r3, [r2, #62]	; 0x3e
 80085e0:	e79e      	b.n	8008520 <HAL_SPI_TransmitReceive_DMA+0xa0>
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80085e2:	2380      	movs	r3, #128	; 0x80
 80085e4:	6848      	ldr	r0, [r1, #4]
 80085e6:	01db      	lsls	r3, r3, #7
 80085e8:	4303      	orrs	r3, r0
 80085ea:	604b      	str	r3, [r1, #4]
        hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 80085ec:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80085ee:	085b      	lsrs	r3, r3, #1
 80085f0:	3301      	adds	r3, #1
 80085f2:	e7e0      	b.n	80085b6 <HAL_SPI_TransmitReceive_DMA+0x136>
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 80085f4:	2380      	movs	r3, #128	; 0x80
 80085f6:	6848      	ldr	r0, [r1, #4]
 80085f8:	019b      	lsls	r3, r3, #6
 80085fa:	4303      	orrs	r3, r0
 80085fc:	604b      	str	r3, [r1, #4]
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 80085fe:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 8008600:	085b      	lsrs	r3, r3, #1
 8008602:	3301      	adds	r3, #1
 8008604:	e7eb      	b.n	80085de <HAL_SPI_TransmitReceive_DMA+0x15e>
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
 8008606:	4b09      	ldr	r3, [pc, #36]	; (800862c <HAL_SPI_TransmitReceive_DMA+0x1ac>)
 8008608:	62c3      	str	r3, [r0, #44]	; 0x2c
    hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
 800860a:	4b09      	ldr	r3, [pc, #36]	; (8008630 <HAL_SPI_TransmitReceive_DMA+0x1b0>)
 800860c:	e790      	b.n	8008530 <HAL_SPI_TransmitReceive_DMA+0xb0>
 800860e:	46c0      	nop			; (mov r8, r8)
 8008610:	ffffdfff 	.word	0xffffdfff
 8008614:	ffff9fff 	.word	0xffff9fff
 8008618:	ffffefff 	.word	0xffffefff
 800861c:	080087d9 	.word	0x080087d9
 8008620:	08008885 	.word	0x08008885
 8008624:	080087f1 	.word	0x080087f1
 8008628:	ffffbfff 	.word	0xffffbfff
 800862c:	080087e5 	.word	0x080087e5
 8008630:	08008969 	.word	0x08008969

08008634 <HAL_SPI_Receive_DMA>:
  if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 8008634:	6883      	ldr	r3, [r0, #8]
{
 8008636:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8008638:	0005      	movs	r5, r0
  if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 800863a:	2b00      	cmp	r3, #0
 800863c:	d10f      	bne.n	800865e <HAL_SPI_Receive_DMA+0x2a>
 800863e:	2082      	movs	r0, #130	; 0x82
 8008640:	686c      	ldr	r4, [r5, #4]
 8008642:	0040      	lsls	r0, r0, #1
 8008644:	4284      	cmp	r4, r0
 8008646:	d10a      	bne.n	800865e <HAL_SPI_Receive_DMA+0x2a>
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 8008648:	002b      	movs	r3, r5
 800864a:	3801      	subs	r0, #1
 800864c:	335d      	adds	r3, #93	; 0x5d
 800864e:	38ff      	subs	r0, #255	; 0xff
 8008650:	7018      	strb	r0, [r3, #0]
    return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
 8008652:	0013      	movs	r3, r2
 8008654:	0028      	movs	r0, r5
 8008656:	000a      	movs	r2, r1
 8008658:	f7ff ff12 	bl	8008480 <HAL_SPI_TransmitReceive_DMA>
}
 800865c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(hspi);
 800865e:	002e      	movs	r6, r5
 8008660:	365c      	adds	r6, #92	; 0x5c
 8008662:	7834      	ldrb	r4, [r6, #0]
 8008664:	2002      	movs	r0, #2
 8008666:	2c01      	cmp	r4, #1
 8008668:	d0f8      	beq.n	800865c <HAL_SPI_Receive_DMA+0x28>
  if (hspi->State != HAL_SPI_STATE_READY)
 800866a:	002f      	movs	r7, r5
  __HAL_LOCK(hspi);
 800866c:	3801      	subs	r0, #1
 800866e:	7030      	strb	r0, [r6, #0]
  if (hspi->State != HAL_SPI_STATE_READY)
 8008670:	375d      	adds	r7, #93	; 0x5d
 8008672:	783c      	ldrb	r4, [r7, #0]
    errorcode = HAL_BUSY;
 8008674:	3001      	adds	r0, #1
  if (hspi->State != HAL_SPI_STATE_READY)
 8008676:	b2e4      	uxtb	r4, r4
 8008678:	2c01      	cmp	r4, #1
 800867a:	d156      	bne.n	800872a <HAL_SPI_Receive_DMA+0xf6>
    errorcode = HAL_ERROR;
 800867c:	0020      	movs	r0, r4
  if ((pData == NULL) || (Size == 0U))
 800867e:	2900      	cmp	r1, #0
 8008680:	d053      	beq.n	800872a <HAL_SPI_Receive_DMA+0xf6>
 8008682:	2a00      	cmp	r2, #0
 8008684:	d051      	beq.n	800872a <HAL_SPI_Receive_DMA+0xf6>
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 8008686:	3003      	adds	r0, #3
 8008688:	7038      	strb	r0, [r7, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800868a:	2000      	movs	r0, #0
  hspi->RxXferCount = Size;
 800868c:	3f55      	subs	r7, #85	; 0x55
  hspi->RxXferSize  = Size;
 800868e:	1dac      	adds	r4, r5, #6
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8008690:	6628      	str	r0, [r5, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 8008692:	6429      	str	r1, [r5, #64]	; 0x40
  hspi->RxXferSize  = Size;
 8008694:	87e2      	strh	r2, [r4, #62]	; 0x3e
  hspi->RxXferCount = Size;
 8008696:	87fa      	strh	r2, [r7, #62]	; 0x3e
  hspi->RxISR       = NULL;
 8008698:	64e8      	str	r0, [r5, #76]	; 0x4c
  hspi->TxISR       = NULL;
 800869a:	6528      	str	r0, [r5, #80]	; 0x50
  hspi->TxXferSize  = 0U;
 800869c:	87a8      	strh	r0, [r5, #60]	; 0x3c
  hspi->TxXferCount = 0U;
 800869e:	87e8      	strh	r0, [r5, #62]	; 0x3e
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80086a0:	2080      	movs	r0, #128	; 0x80
  hspi->RxXferCount = Size;
 80086a2:	9701      	str	r7, [sp, #4]
 80086a4:	682a      	ldr	r2, [r5, #0]
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80086a6:	0200      	lsls	r0, r0, #8
 80086a8:	4283      	cmp	r3, r0
 80086aa:	d103      	bne.n	80086b4 <HAL_SPI_Receive_DMA+0x80>
    SPI_1LINE_RX(hspi);
 80086ac:	6813      	ldr	r3, [r2, #0]
 80086ae:	4834      	ldr	r0, [pc, #208]	; (8008780 <HAL_SPI_Receive_DMA+0x14c>)
 80086b0:	4003      	ands	r3, r0
 80086b2:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80086b4:	2080      	movs	r0, #128	; 0x80
 80086b6:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80086b8:	0180      	lsls	r0, r0, #6
 80086ba:	4c32      	ldr	r4, [pc, #200]	; (8008784 <HAL_SPI_Receive_DMA+0x150>)
 80086bc:	4283      	cmp	r3, r0
 80086be:	d105      	bne.n	80086cc <HAL_SPI_Receive_DMA+0x98>
    SPI_RESET_CRC(hspi);
 80086c0:	6810      	ldr	r0, [r2, #0]
 80086c2:	4020      	ands	r0, r4
 80086c4:	6010      	str	r0, [r2, #0]
 80086c6:	6810      	ldr	r0, [r2, #0]
 80086c8:	4303      	orrs	r3, r0
 80086ca:	6013      	str	r3, [r2, #0]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 80086cc:	6853      	ldr	r3, [r2, #4]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80086ce:	68ef      	ldr	r7, [r5, #12]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 80086d0:	4023      	ands	r3, r4
 80086d2:	6053      	str	r3, [r2, #4]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80086d4:	23e0      	movs	r3, #224	; 0xe0
 80086d6:	6da8      	ldr	r0, [r5, #88]	; 0x58
 80086d8:	00db      	lsls	r3, r3, #3
 80086da:	429f      	cmp	r7, r3
 80086dc:	d928      	bls.n	8008730 <HAL_SPI_Receive_DMA+0xfc>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80086de:	6853      	ldr	r3, [r2, #4]
 80086e0:	4c29      	ldr	r4, [pc, #164]	; (8008788 <HAL_SPI_Receive_DMA+0x154>)
 80086e2:	4023      	ands	r3, r4
 80086e4:	6053      	str	r3, [r2, #4]
  hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 80086e6:	4b29      	ldr	r3, [pc, #164]	; (800878c <HAL_SPI_Receive_DMA+0x158>)
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 80086e8:	320c      	adds	r2, #12
  hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 80086ea:	62c3      	str	r3, [r0, #44]	; 0x2c
  hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
 80086ec:	4b28      	ldr	r3, [pc, #160]	; (8008790 <HAL_SPI_Receive_DMA+0x15c>)
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 80086ee:	0014      	movs	r4, r2
  hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
 80086f0:	6283      	str	r3, [r0, #40]	; 0x28
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 80086f2:	4b28      	ldr	r3, [pc, #160]	; (8008794 <HAL_SPI_Receive_DMA+0x160>)
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 80086f4:	000a      	movs	r2, r1
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 80086f6:	6303      	str	r3, [r0, #48]	; 0x30
  hspi->hdmarx->XferAbortCallback = NULL;
 80086f8:	2300      	movs	r3, #0
 80086fa:	6343      	str	r3, [r0, #52]	; 0x34
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 80086fc:	9b01      	ldr	r3, [sp, #4]
 80086fe:	0021      	movs	r1, r4
 8008700:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 8008702:	b29b      	uxth	r3, r3
 8008704:	f7ff f884 	bl	8007810 <HAL_DMA_Start_IT>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8008708:	2240      	movs	r2, #64	; 0x40
 800870a:	682b      	ldr	r3, [r5, #0]
 800870c:	6819      	ldr	r1, [r3, #0]
 800870e:	4211      	tst	r1, r2
 8008710:	d102      	bne.n	8008718 <HAL_SPI_Receive_DMA+0xe4>
    __HAL_SPI_ENABLE(hspi);
 8008712:	6819      	ldr	r1, [r3, #0]
 8008714:	430a      	orrs	r2, r1
 8008716:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 8008718:	2220      	movs	r2, #32
 800871a:	6859      	ldr	r1, [r3, #4]
  HAL_StatusTypeDef errorcode = HAL_OK;
 800871c:	2000      	movs	r0, #0
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 800871e:	430a      	orrs	r2, r1
 8008720:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 8008722:	2201      	movs	r2, #1
 8008724:	6859      	ldr	r1, [r3, #4]
 8008726:	430a      	orrs	r2, r1
 8008728:	605a      	str	r2, [r3, #4]
  __HAL_UNLOCK(hspi);
 800872a:	2300      	movs	r3, #0
 800872c:	7033      	strb	r3, [r6, #0]
  return errorcode;
 800872e:	e795      	b.n	800865c <HAL_SPI_Receive_DMA+0x28>
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8008730:	6853      	ldr	r3, [r2, #4]
 8008732:	469c      	mov	ip, r3
 8008734:	2380      	movs	r3, #128	; 0x80
 8008736:	4667      	mov	r7, ip
 8008738:	015b      	lsls	r3, r3, #5
 800873a:	433b      	orrs	r3, r7
 800873c:	6053      	str	r3, [r2, #4]
    if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 800873e:	2380      	movs	r3, #128	; 0x80
 8008740:	6947      	ldr	r7, [r0, #20]
 8008742:	00db      	lsls	r3, r3, #3
 8008744:	429f      	cmp	r7, r3
 8008746:	d1ce      	bne.n	80086e6 <HAL_SPI_Receive_DMA+0xb2>
      CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8008748:	6853      	ldr	r3, [r2, #4]
 800874a:	4f0f      	ldr	r7, [pc, #60]	; (8008788 <HAL_SPI_Receive_DMA+0x154>)
 800874c:	403b      	ands	r3, r7
 800874e:	6053      	str	r3, [r2, #4]
      if ((hspi->RxXferCount & 0x1U) == 0x0U)
 8008750:	002b      	movs	r3, r5
 8008752:	3308      	adds	r3, #8
 8008754:	8fdf      	ldrh	r7, [r3, #62]	; 0x3e
 8008756:	07ff      	lsls	r7, r7, #31
 8008758:	d406      	bmi.n	8008768 <HAL_SPI_Receive_DMA+0x134>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 800875a:	6857      	ldr	r7, [r2, #4]
 800875c:	403c      	ands	r4, r7
 800875e:	6054      	str	r4, [r2, #4]
        hspi->RxXferCount = hspi->RxXferCount >> 1U;
 8008760:	8fdc      	ldrh	r4, [r3, #62]	; 0x3e
 8008762:	0864      	lsrs	r4, r4, #1
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 8008764:	87dc      	strh	r4, [r3, #62]	; 0x3e
 8008766:	e7be      	b.n	80086e6 <HAL_SPI_Receive_DMA+0xb2>
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 8008768:	6854      	ldr	r4, [r2, #4]
 800876a:	46a4      	mov	ip, r4
 800876c:	2480      	movs	r4, #128	; 0x80
 800876e:	4667      	mov	r7, ip
 8008770:	01a4      	lsls	r4, r4, #6
 8008772:	433c      	orrs	r4, r7
 8008774:	6054      	str	r4, [r2, #4]
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 8008776:	8fdc      	ldrh	r4, [r3, #62]	; 0x3e
 8008778:	0864      	lsrs	r4, r4, #1
 800877a:	3401      	adds	r4, #1
 800877c:	e7f2      	b.n	8008764 <HAL_SPI_Receive_DMA+0x130>
 800877e:	46c0      	nop			; (mov r8, r8)
 8008780:	ffffbfff 	.word	0xffffbfff
 8008784:	ffffdfff 	.word	0xffffdfff
 8008788:	ffffefff 	.word	0xffffefff
 800878c:	080087d9 	.word	0x080087d9
 8008790:	08008885 	.word	0x08008885
 8008794:	080087f1 	.word	0x080087f1

08008798 <HAL_SPI_DMAStop>:
{
 8008798:	b510      	push	{r4, lr}
 800879a:	0004      	movs	r4, r0
  if (hspi->hdmatx != NULL)
 800879c:	6d40      	ldr	r0, [r0, #84]	; 0x54
 800879e:	2800      	cmp	r0, #0
 80087a0:	d001      	beq.n	80087a6 <HAL_SPI_DMAStop+0xe>
    HAL_DMA_Abort(hspi->hdmatx);
 80087a2:	f7ff f871 	bl	8007888 <HAL_DMA_Abort>
  if (hspi->hdmarx != NULL)
 80087a6:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80087a8:	2800      	cmp	r0, #0
 80087aa:	d001      	beq.n	80087b0 <HAL_SPI_DMAStop+0x18>
    HAL_DMA_Abort(hspi->hdmarx);
 80087ac:	f7ff f86c 	bl	8007888 <HAL_DMA_Abort>
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 80087b0:	2103      	movs	r1, #3
 80087b2:	6822      	ldr	r2, [r4, #0]
  hspi->State = HAL_SPI_STATE_READY;
 80087b4:	345d      	adds	r4, #93	; 0x5d
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 80087b6:	6853      	ldr	r3, [r2, #4]
}
 80087b8:	2000      	movs	r0, #0
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 80087ba:	438b      	bics	r3, r1
 80087bc:	6053      	str	r3, [r2, #4]
  hspi->State = HAL_SPI_STATE_READY;
 80087be:	2301      	movs	r3, #1
 80087c0:	7023      	strb	r3, [r4, #0]
}
 80087c2:	bd10      	pop	{r4, pc}

080087c4 <HAL_SPI_TxCpltCallback>:
 80087c4:	4770      	bx	lr

080087c6 <HAL_SPI_RxCpltCallback>:
 80087c6:	4770      	bx	lr

080087c8 <HAL_SPI_TxRxCpltCallback>:
 80087c8:	4770      	bx	lr

080087ca <HAL_SPI_TxHalfCpltCallback>:
 80087ca:	4770      	bx	lr

080087cc <SPI_DMAHalfTransmitCplt>:
{
 80087cc:	b510      	push	{r4, lr}
  HAL_SPI_TxHalfCpltCallback(hspi);
 80087ce:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80087d0:	f7ff fffb 	bl	80087ca <HAL_SPI_TxHalfCpltCallback>
}
 80087d4:	bd10      	pop	{r4, pc}

080087d6 <HAL_SPI_RxHalfCpltCallback>:
 80087d6:	4770      	bx	lr

080087d8 <SPI_DMAHalfReceiveCplt>:
{
 80087d8:	b510      	push	{r4, lr}
  HAL_SPI_RxHalfCpltCallback(hspi);
 80087da:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80087dc:	f7ff fffb 	bl	80087d6 <HAL_SPI_RxHalfCpltCallback>
}
 80087e0:	bd10      	pop	{r4, pc}

080087e2 <HAL_SPI_TxRxHalfCpltCallback>:
 80087e2:	4770      	bx	lr

080087e4 <SPI_DMAHalfTransmitReceiveCplt>:
{
 80087e4:	b510      	push	{r4, lr}
  HAL_SPI_TxRxHalfCpltCallback(hspi);
 80087e6:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80087e8:	f7ff fffb 	bl	80087e2 <HAL_SPI_TxRxHalfCpltCallback>
}
 80087ec:	bd10      	pop	{r4, pc}

080087ee <HAL_SPI_ErrorCallback>:
 80087ee:	4770      	bx	lr

080087f0 <SPI_DMAError>:
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 80087f0:	2103      	movs	r1, #3
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80087f2:	6a40      	ldr	r0, [r0, #36]	; 0x24
{
 80087f4:	b510      	push	{r4, lr}
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 80087f6:	6802      	ldr	r2, [r0, #0]
 80087f8:	6853      	ldr	r3, [r2, #4]
 80087fa:	438b      	bics	r3, r1
 80087fc:	6053      	str	r3, [r2, #4]
  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 80087fe:	2310      	movs	r3, #16
 8008800:	6e02      	ldr	r2, [r0, #96]	; 0x60
 8008802:	4313      	orrs	r3, r2
 8008804:	6603      	str	r3, [r0, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_READY;
 8008806:	0003      	movs	r3, r0
 8008808:	2201      	movs	r2, #1
 800880a:	335d      	adds	r3, #93	; 0x5d
 800880c:	701a      	strb	r2, [r3, #0]
  HAL_SPI_ErrorCallback(hspi);
 800880e:	f7ff ffee 	bl	80087ee <HAL_SPI_ErrorCallback>
}
 8008812:	bd10      	pop	{r4, pc}

08008814 <SPI_DMATransmitCplt>:
{
 8008814:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8008816:	0005      	movs	r5, r0
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008818:	6a44      	ldr	r4, [r0, #36]	; 0x24
  tickstart = HAL_GetTick();
 800881a:	f7fe fbff 	bl	800701c <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 800881e:	682b      	ldr	r3, [r5, #0]
 8008820:	2520      	movs	r5, #32
 8008822:	681b      	ldr	r3, [r3, #0]
  tickstart = HAL_GetTick();
 8008824:	0002      	movs	r2, r0
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8008826:	422b      	tst	r3, r5
 8008828:	d127      	bne.n	800887a <SPI_DMATransmitCplt+0x66>
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 800882a:	2002      	movs	r0, #2
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 800882c:	6823      	ldr	r3, [r4, #0]
 800882e:	6859      	ldr	r1, [r3, #4]
 8008830:	43a9      	bics	r1, r5
 8008832:	6059      	str	r1, [r3, #4]
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8008834:	6859      	ldr	r1, [r3, #4]
 8008836:	4381      	bics	r1, r0
 8008838:	6059      	str	r1, [r3, #4]
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 800883a:	0020      	movs	r0, r4
 800883c:	2164      	movs	r1, #100	; 0x64
 800883e:	f7ff fd06 	bl	800824e <SPI_EndRxTxTransaction>
 8008842:	2800      	cmp	r0, #0
 8008844:	d002      	beq.n	800884c <SPI_DMATransmitCplt+0x38>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8008846:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8008848:	431d      	orrs	r5, r3
 800884a:	6625      	str	r5, [r4, #96]	; 0x60
    if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 800884c:	68a3      	ldr	r3, [r4, #8]
 800884e:	2b00      	cmp	r3, #0
 8008850:	d106      	bne.n	8008860 <SPI_DMATransmitCplt+0x4c>
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8008852:	9301      	str	r3, [sp, #4]
 8008854:	6823      	ldr	r3, [r4, #0]
 8008856:	68da      	ldr	r2, [r3, #12]
 8008858:	9201      	str	r2, [sp, #4]
 800885a:	689b      	ldr	r3, [r3, #8]
 800885c:	9301      	str	r3, [sp, #4]
 800885e:	9b01      	ldr	r3, [sp, #4]
    hspi->TxXferCount = 0U;
 8008860:	2300      	movs	r3, #0
 8008862:	87e3      	strh	r3, [r4, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 8008864:	0023      	movs	r3, r4
 8008866:	2201      	movs	r2, #1
 8008868:	335d      	adds	r3, #93	; 0x5d
 800886a:	701a      	strb	r2, [r3, #0]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 800886c:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800886e:	2b00      	cmp	r3, #0
 8008870:	d003      	beq.n	800887a <SPI_DMATransmitCplt+0x66>
      HAL_SPI_ErrorCallback(hspi);
 8008872:	0020      	movs	r0, r4
 8008874:	f7ff ffbb 	bl	80087ee <HAL_SPI_ErrorCallback>
}
 8008878:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
  HAL_SPI_TxCpltCallback(hspi);
 800887a:	0020      	movs	r0, r4
 800887c:	f7ff ffa2 	bl	80087c4 <HAL_SPI_TxCpltCallback>
 8008880:	e7fa      	b.n	8008878 <SPI_DMATransmitCplt+0x64>
	...

08008884 <SPI_DMAReceiveCplt>:
{
 8008884:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO uint16_t tmpreg = 0U;
 8008886:	250e      	movs	r5, #14
 8008888:	2300      	movs	r3, #0
{
 800888a:	0006      	movs	r6, r0
 800888c:	b085      	sub	sp, #20
  __IO uint16_t tmpreg = 0U;
 800888e:	446d      	add	r5, sp
 8008890:	802b      	strh	r3, [r5, #0]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008892:	6a44      	ldr	r4, [r0, #36]	; 0x24
  tickstart = HAL_GetTick();
 8008894:	f7fe fbc2 	bl	800701c <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8008898:	2120      	movs	r1, #32
 800889a:	6833      	ldr	r3, [r6, #0]
  tickstart = HAL_GetTick();
 800889c:	0007      	movs	r7, r0
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 800889e:	681b      	ldr	r3, [r3, #0]
 80088a0:	420b      	tst	r3, r1
 80088a2:	d15b      	bne.n	800895c <SPI_DMAReceiveCplt+0xd8>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 80088a4:	6822      	ldr	r2, [r4, #0]
 80088a6:	6853      	ldr	r3, [r2, #4]
 80088a8:	438b      	bics	r3, r1
 80088aa:	6053      	str	r3, [r2, #4]
    if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80088ac:	2380      	movs	r3, #128	; 0x80
 80088ae:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80088b0:	019b      	lsls	r3, r3, #6
 80088b2:	429a      	cmp	r2, r3
 80088b4:	d116      	bne.n	80088e4 <SPI_DMAReceiveCplt+0x60>
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 80088b6:	2201      	movs	r2, #1
 80088b8:	9000      	str	r0, [sp, #0]
 80088ba:	2364      	movs	r3, #100	; 0x64
 80088bc:	0011      	movs	r1, r2
 80088be:	0020      	movs	r0, r4
 80088c0:	f7ff fc40 	bl	8008144 <SPI_WaitFlagStateUntilTimeout>
 80088c4:	2800      	cmp	r0, #0
 80088c6:	d003      	beq.n	80088d0 <SPI_DMAReceiveCplt+0x4c>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 80088c8:	2302      	movs	r3, #2
 80088ca:	6e22      	ldr	r2, [r4, #96]	; 0x60
 80088cc:	4313      	orrs	r3, r2
 80088ce:	6623      	str	r3, [r4, #96]	; 0x60
      if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80088d0:	22e0      	movs	r2, #224	; 0xe0
 80088d2:	68e1      	ldr	r1, [r4, #12]
 80088d4:	6823      	ldr	r3, [r4, #0]
 80088d6:	00d2      	lsls	r2, r2, #3
 80088d8:	4291      	cmp	r1, r2
 80088da:	d92a      	bls.n	8008932 <SPI_DMAReceiveCplt+0xae>
        tmpreg = hspi->Instance->DR;
 80088dc:	68db      	ldr	r3, [r3, #12]
 80088de:	b29b      	uxth	r3, r3
          tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 80088e0:	802b      	strh	r3, [r5, #0]
          UNUSED(tmpreg);
 80088e2:	882b      	ldrh	r3, [r5, #0]
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 80088e4:	2103      	movs	r1, #3
 80088e6:	6822      	ldr	r2, [r4, #0]
    if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 80088e8:	0020      	movs	r0, r4
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 80088ea:	6853      	ldr	r3, [r2, #4]
 80088ec:	438b      	bics	r3, r1
 80088ee:	6053      	str	r3, [r2, #4]
    if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 80088f0:	3161      	adds	r1, #97	; 0x61
 80088f2:	003a      	movs	r2, r7
 80088f4:	f7ff fc6b 	bl	80081ce <SPI_EndRxTransaction>
 80088f8:	2800      	cmp	r0, #0
 80088fa:	d001      	beq.n	8008900 <SPI_DMAReceiveCplt+0x7c>
      hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 80088fc:	2320      	movs	r3, #32
 80088fe:	6623      	str	r3, [r4, #96]	; 0x60
    hspi->RxXferCount = 0U;
 8008900:	0023      	movs	r3, r4
 8008902:	2200      	movs	r2, #0
 8008904:	3308      	adds	r3, #8
 8008906:	87da      	strh	r2, [r3, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 8008908:	3201      	adds	r2, #1
 800890a:	3355      	adds	r3, #85	; 0x55
 800890c:	701a      	strb	r2, [r3, #0]
    if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 800890e:	6822      	ldr	r2, [r4, #0]
 8008910:	6893      	ldr	r3, [r2, #8]
 8008912:	06db      	lsls	r3, r3, #27
 8008914:	d505      	bpl.n	8008922 <SPI_DMAReceiveCplt+0x9e>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008916:	2302      	movs	r3, #2
 8008918:	6e21      	ldr	r1, [r4, #96]	; 0x60
 800891a:	430b      	orrs	r3, r1
 800891c:	6623      	str	r3, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 800891e:	4b11      	ldr	r3, [pc, #68]	; (8008964 <SPI_DMAReceiveCplt+0xe0>)
 8008920:	6093      	str	r3, [r2, #8]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8008922:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8008924:	2b00      	cmp	r3, #0
 8008926:	d019      	beq.n	800895c <SPI_DMAReceiveCplt+0xd8>
      HAL_SPI_ErrorCallback(hspi);
 8008928:	0020      	movs	r0, r4
 800892a:	f7ff ff60 	bl	80087ee <HAL_SPI_ErrorCallback>
}
 800892e:	b005      	add	sp, #20
 8008930:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8008932:	7b1b      	ldrb	r3, [r3, #12]
        if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8008934:	6b26      	ldr	r6, [r4, #48]	; 0x30
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8008936:	802b      	strh	r3, [r5, #0]
        UNUSED(tmpreg);
 8008938:	882b      	ldrh	r3, [r5, #0]
        if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 800893a:	2e02      	cmp	r6, #2
 800893c:	d1d2      	bne.n	80088e4 <SPI_DMAReceiveCplt+0x60>
          if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 800893e:	2201      	movs	r2, #1
 8008940:	9700      	str	r7, [sp, #0]
 8008942:	2364      	movs	r3, #100	; 0x64
 8008944:	0011      	movs	r1, r2
 8008946:	0020      	movs	r0, r4
 8008948:	f7ff fbfc 	bl	8008144 <SPI_WaitFlagStateUntilTimeout>
 800894c:	2800      	cmp	r0, #0
 800894e:	d002      	beq.n	8008956 <SPI_DMAReceiveCplt+0xd2>
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008950:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8008952:	431e      	orrs	r6, r3
 8008954:	6626      	str	r6, [r4, #96]	; 0x60
          tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8008956:	6823      	ldr	r3, [r4, #0]
 8008958:	7b1b      	ldrb	r3, [r3, #12]
 800895a:	e7c1      	b.n	80088e0 <SPI_DMAReceiveCplt+0x5c>
  HAL_SPI_RxCpltCallback(hspi);
 800895c:	0020      	movs	r0, r4
 800895e:	f7ff ff32 	bl	80087c6 <HAL_SPI_RxCpltCallback>
 8008962:	e7e4      	b.n	800892e <SPI_DMAReceiveCplt+0xaa>
 8008964:	0000ffef 	.word	0x0000ffef

08008968 <SPI_DMATransmitReceiveCplt>:
{
 8008968:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO int16_t tmpreg = 0U;
 800896a:	250e      	movs	r5, #14
 800896c:	2300      	movs	r3, #0
{
 800896e:	0007      	movs	r7, r0
 8008970:	b085      	sub	sp, #20
  __IO int16_t tmpreg = 0U;
 8008972:	446d      	add	r5, sp
 8008974:	802b      	strh	r3, [r5, #0]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008976:	6a44      	ldr	r4, [r0, #36]	; 0x24
  tickstart = HAL_GetTick();
 8008978:	f7fe fb50 	bl	800701c <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 800897c:	2120      	movs	r1, #32
 800897e:	683b      	ldr	r3, [r7, #0]
  tickstart = HAL_GetTick();
 8008980:	0006      	movs	r6, r0
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8008982:	681b      	ldr	r3, [r3, #0]
 8008984:	420b      	tst	r3, r1
 8008986:	d160      	bne.n	8008a4a <SPI_DMATransmitReceiveCplt+0xe2>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 8008988:	6822      	ldr	r2, [r4, #0]
 800898a:	6853      	ldr	r3, [r2, #4]
 800898c:	438b      	bics	r3, r1
 800898e:	6053      	str	r3, [r2, #4]
    if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008990:	2380      	movs	r3, #128	; 0x80
 8008992:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8008994:	019b      	lsls	r3, r3, #6
 8008996:	429a      	cmp	r2, r3
 8008998:	d11a      	bne.n	80089d0 <SPI_DMATransmitReceiveCplt+0x68>
      if ((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_8BIT))
 800899a:	23e0      	movs	r3, #224	; 0xe0
 800899c:	68e2      	ldr	r2, [r4, #12]
 800899e:	00db      	lsls	r3, r3, #3
 80089a0:	429a      	cmp	r2, r3
 80089a2:	d13f      	bne.n	8008a24 <SPI_DMATransmitReceiveCplt+0xbc>
 80089a4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80089a6:	2b01      	cmp	r3, #1
 80089a8:	d13c      	bne.n	8008a24 <SPI_DMATransmitReceiveCplt+0xbc>
        if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_QUARTER_FULL, SPI_DEFAULT_TIMEOUT,
 80089aa:	2280      	movs	r2, #128	; 0x80
 80089ac:	21c0      	movs	r1, #192	; 0xc0
 80089ae:	9000      	str	r0, [sp, #0]
 80089b0:	3363      	adds	r3, #99	; 0x63
 80089b2:	0092      	lsls	r2, r2, #2
 80089b4:	00c9      	lsls	r1, r1, #3
 80089b6:	0020      	movs	r0, r4
 80089b8:	f7ff fbe2 	bl	8008180 <SPI_WaitFifoStateUntilTimeout>
 80089bc:	2800      	cmp	r0, #0
 80089be:	d003      	beq.n	80089c8 <SPI_DMATransmitReceiveCplt+0x60>
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 80089c0:	2302      	movs	r3, #2
 80089c2:	6e22      	ldr	r2, [r4, #96]	; 0x60
 80089c4:	4313      	orrs	r3, r2
 80089c6:	6623      	str	r3, [r4, #96]	; 0x60
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 80089c8:	6823      	ldr	r3, [r4, #0]
 80089ca:	7b1b      	ldrb	r3, [r3, #12]
        tmpreg = hspi->Instance->DR;
 80089cc:	802b      	strh	r3, [r5, #0]
        UNUSED(tmpreg);
 80089ce:	882b      	ldrh	r3, [r5, #0]
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 80089d0:	0032      	movs	r2, r6
 80089d2:	2164      	movs	r1, #100	; 0x64
 80089d4:	0020      	movs	r0, r4
 80089d6:	f7ff fc3a 	bl	800824e <SPI_EndRxTxTransaction>
 80089da:	2800      	cmp	r0, #0
 80089dc:	d003      	beq.n	80089e6 <SPI_DMATransmitReceiveCplt+0x7e>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80089de:	2320      	movs	r3, #32
 80089e0:	6e22      	ldr	r2, [r4, #96]	; 0x60
 80089e2:	4313      	orrs	r3, r2
 80089e4:	6623      	str	r3, [r4, #96]	; 0x60
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 80089e6:	2103      	movs	r1, #3
 80089e8:	6823      	ldr	r3, [r4, #0]
 80089ea:	685a      	ldr	r2, [r3, #4]
 80089ec:	438a      	bics	r2, r1
    hspi->RxXferCount = 0U;
 80089ee:	0021      	movs	r1, r4
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 80089f0:	605a      	str	r2, [r3, #4]
    hspi->TxXferCount = 0U;
 80089f2:	2200      	movs	r2, #0
    hspi->RxXferCount = 0U;
 80089f4:	3108      	adds	r1, #8
    hspi->TxXferCount = 0U;
 80089f6:	87e2      	strh	r2, [r4, #62]	; 0x3e
    hspi->RxXferCount = 0U;
 80089f8:	87ca      	strh	r2, [r1, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 80089fa:	0022      	movs	r2, r4
 80089fc:	2101      	movs	r1, #1
 80089fe:	325d      	adds	r2, #93	; 0x5d
 8008a00:	7011      	strb	r1, [r2, #0]
    if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 8008a02:	689a      	ldr	r2, [r3, #8]
 8008a04:	06d2      	lsls	r2, r2, #27
 8008a06:	d505      	bpl.n	8008a14 <SPI_DMATransmitReceiveCplt+0xac>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008a08:	2202      	movs	r2, #2
 8008a0a:	6e21      	ldr	r1, [r4, #96]	; 0x60
 8008a0c:	430a      	orrs	r2, r1
 8008a0e:	6622      	str	r2, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 8008a10:	4a10      	ldr	r2, [pc, #64]	; (8008a54 <SPI_DMATransmitReceiveCplt+0xec>)
 8008a12:	609a      	str	r2, [r3, #8]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8008a14:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8008a16:	2b00      	cmp	r3, #0
 8008a18:	d017      	beq.n	8008a4a <SPI_DMATransmitReceiveCplt+0xe2>
      HAL_SPI_ErrorCallback(hspi);
 8008a1a:	0020      	movs	r0, r4
 8008a1c:	f7ff fee7 	bl	80087ee <HAL_SPI_ErrorCallback>
}
 8008a20:	b005      	add	sp, #20
 8008a22:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_HALF_FULL, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008a24:	2280      	movs	r2, #128	; 0x80
 8008a26:	21c0      	movs	r1, #192	; 0xc0
 8008a28:	9600      	str	r6, [sp, #0]
 8008a2a:	2364      	movs	r3, #100	; 0x64
 8008a2c:	00d2      	lsls	r2, r2, #3
 8008a2e:	00c9      	lsls	r1, r1, #3
 8008a30:	0020      	movs	r0, r4
 8008a32:	f7ff fba5 	bl	8008180 <SPI_WaitFifoStateUntilTimeout>
 8008a36:	2800      	cmp	r0, #0
 8008a38:	d003      	beq.n	8008a42 <SPI_DMATransmitReceiveCplt+0xda>
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008a3a:	2302      	movs	r3, #2
 8008a3c:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8008a3e:	4313      	orrs	r3, r2
 8008a40:	6623      	str	r3, [r4, #96]	; 0x60
        tmpreg = hspi->Instance->DR;
 8008a42:	6823      	ldr	r3, [r4, #0]
 8008a44:	68db      	ldr	r3, [r3, #12]
 8008a46:	b21b      	sxth	r3, r3
 8008a48:	e7c0      	b.n	80089cc <SPI_DMATransmitReceiveCplt+0x64>
  HAL_SPI_TxRxCpltCallback(hspi);
 8008a4a:	0020      	movs	r0, r4
 8008a4c:	f7ff febc 	bl	80087c8 <HAL_SPI_TxRxCpltCallback>
 8008a50:	e7e6      	b.n	8008a20 <SPI_DMATransmitReceiveCplt+0xb8>
 8008a52:	46c0      	nop			; (mov r8, r8)
 8008a54:	0000ffef 	.word	0x0000ffef

08008a58 <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx = 0U;
  uint32_t tmpccer = 0U;
  uint32_t tmpcr2 = 0U;

   /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8008a58:	2201      	movs	r2, #1
 8008a5a:	6a03      	ldr	r3, [r0, #32]
{
 8008a5c:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8008a5e:	4393      	bics	r3, r2
 8008a60:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8008a62:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8008a64:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8008a66:	6985      	ldr	r5, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8008a68:	3272      	adds	r2, #114	; 0x72
 8008a6a:	4395      	bics	r5, r2
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8008a6c:	680a      	ldr	r2, [r1, #0]
 8008a6e:	4315      	orrs	r5, r2

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 8008a70:	2202      	movs	r2, #2
 8008a72:	4393      	bics	r3, r2
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8008a74:	688a      	ldr	r2, [r1, #8]
 8008a76:	4313      	orrs	r3, r2

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8008a78:	4a14      	ldr	r2, [pc, #80]	; (8008acc <TIM_OC1_SetConfig+0x74>)
 8008a7a:	4290      	cmp	r0, r2
 8008a7c:	d008      	beq.n	8008a90 <TIM_OC1_SetConfig+0x38>
 8008a7e:	4e14      	ldr	r6, [pc, #80]	; (8008ad0 <TIM_OC1_SetConfig+0x78>)
 8008a80:	42b0      	cmp	r0, r6
 8008a82:	d005      	beq.n	8008a90 <TIM_OC1_SetConfig+0x38>
 8008a84:	4e13      	ldr	r6, [pc, #76]	; (8008ad4 <TIM_OC1_SetConfig+0x7c>)
 8008a86:	42b0      	cmp	r0, r6
 8008a88:	d002      	beq.n	8008a90 <TIM_OC1_SetConfig+0x38>
 8008a8a:	4e13      	ldr	r6, [pc, #76]	; (8008ad8 <TIM_OC1_SetConfig+0x80>)
 8008a8c:	42b0      	cmp	r0, r6
 8008a8e:	d116      	bne.n	8008abe <TIM_OC1_SetConfig+0x66>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 8008a90:	2608      	movs	r6, #8
 8008a92:	43b3      	bics	r3, r6
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8008a94:	68ce      	ldr	r6, [r1, #12]
 8008a96:	4333      	orrs	r3, r6
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 8008a98:	2604      	movs	r6, #4
 8008a9a:	43b3      	bics	r3, r6
  }

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8008a9c:	4290      	cmp	r0, r2
 8008a9e:	d008      	beq.n	8008ab2 <TIM_OC1_SetConfig+0x5a>
 8008aa0:	4a0b      	ldr	r2, [pc, #44]	; (8008ad0 <TIM_OC1_SetConfig+0x78>)
 8008aa2:	4290      	cmp	r0, r2
 8008aa4:	d005      	beq.n	8008ab2 <TIM_OC1_SetConfig+0x5a>
 8008aa6:	4a0b      	ldr	r2, [pc, #44]	; (8008ad4 <TIM_OC1_SetConfig+0x7c>)
 8008aa8:	4290      	cmp	r0, r2
 8008aaa:	d002      	beq.n	8008ab2 <TIM_OC1_SetConfig+0x5a>
 8008aac:	4a0a      	ldr	r2, [pc, #40]	; (8008ad8 <TIM_OC1_SetConfig+0x80>)
 8008aae:	4290      	cmp	r0, r2
 8008ab0:	d105      	bne.n	8008abe <TIM_OC1_SetConfig+0x66>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8008ab2:	4a0a      	ldr	r2, [pc, #40]	; (8008adc <TIM_OC1_SetConfig+0x84>)
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8008ab4:	698e      	ldr	r6, [r1, #24]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8008ab6:	4022      	ands	r2, r4
    tmpcr2 |= OC_Config->OCNIdleState;
 8008ab8:	694c      	ldr	r4, [r1, #20]
 8008aba:	4334      	orrs	r4, r6
 8008abc:	4314      	orrs	r4, r2

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8008abe:	684a      	ldr	r2, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8008ac0:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 8008ac2:	6185      	str	r5, [r0, #24]
  TIMx->CCR1 = OC_Config->Pulse;
 8008ac4:	6342      	str	r2, [r0, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8008ac6:	6203      	str	r3, [r0, #32]
}
 8008ac8:	bd70      	pop	{r4, r5, r6, pc}
 8008aca:	46c0      	nop			; (mov r8, r8)
 8008acc:	40012c00 	.word	0x40012c00
 8008ad0:	40014000 	.word	0x40014000
 8008ad4:	40014400 	.word	0x40014400
 8008ad8:	40014800 	.word	0x40014800
 8008adc:	fffffcff 	.word	0xfffffcff

08008ae0 <TIM_OC3_SetConfig>:
  * @param  TIMx  to select the TIM peripheral
  * @param  OC_Config : The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8008ae0:	b570      	push	{r4, r5, r6, lr}
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8008ae2:	2573      	movs	r5, #115	; 0x73
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8008ae4:	6a03      	ldr	r3, [r0, #32]
 8008ae6:	4a17      	ldr	r2, [pc, #92]	; (8008b44 <TIM_OC3_SetConfig+0x64>)
 8008ae8:	4013      	ands	r3, r2
 8008aea:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8008aec:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 8008aee:	6842      	ldr	r2, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
 8008af0:	69c4      	ldr	r4, [r0, #28]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8008af2:	43ac      	bics	r4, r5
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8008af4:	680d      	ldr	r5, [r1, #0]
 8008af6:	432c      	orrs	r4, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8008af8:	4d13      	ldr	r5, [pc, #76]	; (8008b48 <TIM_OC3_SetConfig+0x68>)
 8008afa:	402b      	ands	r3, r5
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8008afc:	688d      	ldr	r5, [r1, #8]
 8008afe:	022d      	lsls	r5, r5, #8
 8008b00:	432b      	orrs	r3, r5

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8008b02:	4d12      	ldr	r5, [pc, #72]	; (8008b4c <TIM_OC3_SetConfig+0x6c>)
 8008b04:	42a8      	cmp	r0, r5
 8008b06:	d10e      	bne.n	8008b26 <TIM_OC3_SetConfig+0x46>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 8008b08:	4d11      	ldr	r5, [pc, #68]	; (8008b50 <TIM_OC3_SetConfig+0x70>)
 8008b0a:	401d      	ands	r5, r3
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8008b0c:	68cb      	ldr	r3, [r1, #12]
 8008b0e:	021b      	lsls	r3, r3, #8
 8008b10:	432b      	orrs	r3, r5
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 8008b12:	4d10      	ldr	r5, [pc, #64]	; (8008b54 <TIM_OC3_SetConfig+0x74>)
 8008b14:	402b      	ands	r3, r5
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8008b16:	4d10      	ldr	r5, [pc, #64]	; (8008b58 <TIM_OC3_SetConfig+0x78>)
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8008b18:	694e      	ldr	r6, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8008b1a:	4015      	ands	r5, r2
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8008b1c:	698a      	ldr	r2, [r1, #24]
 8008b1e:	4332      	orrs	r2, r6
 8008b20:	0112      	lsls	r2, r2, #4
 8008b22:	432a      	orrs	r2, r5
 8008b24:	e008      	b.n	8008b38 <TIM_OC3_SetConfig+0x58>
  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8008b26:	4d0d      	ldr	r5, [pc, #52]	; (8008b5c <TIM_OC3_SetConfig+0x7c>)
 8008b28:	42a8      	cmp	r0, r5
 8008b2a:	d0f4      	beq.n	8008b16 <TIM_OC3_SetConfig+0x36>
 8008b2c:	4d0c      	ldr	r5, [pc, #48]	; (8008b60 <TIM_OC3_SetConfig+0x80>)
 8008b2e:	42a8      	cmp	r0, r5
 8008b30:	d0f1      	beq.n	8008b16 <TIM_OC3_SetConfig+0x36>
 8008b32:	4d0c      	ldr	r5, [pc, #48]	; (8008b64 <TIM_OC3_SetConfig+0x84>)
 8008b34:	42a8      	cmp	r0, r5
 8008b36:	d0ee      	beq.n	8008b16 <TIM_OC3_SetConfig+0x36>
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8008b38:	6042      	str	r2, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8008b3a:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 8008b3c:	61c4      	str	r4, [r0, #28]
  TIMx->CCR3 = OC_Config->Pulse;
 8008b3e:	63c2      	str	r2, [r0, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8008b40:	6203      	str	r3, [r0, #32]
}
 8008b42:	bd70      	pop	{r4, r5, r6, pc}
 8008b44:	fffffeff 	.word	0xfffffeff
 8008b48:	fffffdff 	.word	0xfffffdff
 8008b4c:	40012c00 	.word	0x40012c00
 8008b50:	fffff7ff 	.word	0xfffff7ff
 8008b54:	fffffbff 	.word	0xfffffbff
 8008b58:	ffffcfff 	.word	0xffffcfff
 8008b5c:	40014000 	.word	0x40014000
 8008b60:	40014400 	.word	0x40014400
 8008b64:	40014800 	.word	0x40014800

08008b68 <TIM_OC4_SetConfig>:
  uint32_t tmpccmrx = 0U;
  uint32_t tmpccer = 0U;
  uint32_t tmpcr2 = 0U;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8008b68:	6a03      	ldr	r3, [r0, #32]
 8008b6a:	4a14      	ldr	r2, [pc, #80]	; (8008bbc <TIM_OC4_SetConfig+0x54>)
{
 8008b6c:	b530      	push	{r4, r5, lr}
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8008b6e:	4013      	ands	r3, r2
 8008b70:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8008b72:	6a02      	ldr	r2, [r0, #32]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8008b74:	4c12      	ldr	r4, [pc, #72]	; (8008bc0 <TIM_OC4_SetConfig+0x58>)
  tmpcr2 =  TIMx->CR2;
 8008b76:	6843      	ldr	r3, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
 8008b78:	69c5      	ldr	r5, [r0, #28]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8008b7a:	4025      	ands	r5, r4

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8008b7c:	680c      	ldr	r4, [r1, #0]
 8008b7e:	0224      	lsls	r4, r4, #8
 8008b80:	4325      	orrs	r5, r4

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8008b82:	4c10      	ldr	r4, [pc, #64]	; (8008bc4 <TIM_OC4_SetConfig+0x5c>)
 8008b84:	4022      	ands	r2, r4
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8008b86:	688c      	ldr	r4, [r1, #8]
 8008b88:	0324      	lsls	r4, r4, #12
 8008b8a:	4322      	orrs	r2, r4

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8008b8c:	4c0e      	ldr	r4, [pc, #56]	; (8008bc8 <TIM_OC4_SetConfig+0x60>)
 8008b8e:	42a0      	cmp	r0, r4
 8008b90:	d008      	beq.n	8008ba4 <TIM_OC4_SetConfig+0x3c>
 8008b92:	4c0e      	ldr	r4, [pc, #56]	; (8008bcc <TIM_OC4_SetConfig+0x64>)
 8008b94:	42a0      	cmp	r0, r4
 8008b96:	d005      	beq.n	8008ba4 <TIM_OC4_SetConfig+0x3c>
 8008b98:	4c0d      	ldr	r4, [pc, #52]	; (8008bd0 <TIM_OC4_SetConfig+0x68>)
 8008b9a:	42a0      	cmp	r0, r4
 8008b9c:	d002      	beq.n	8008ba4 <TIM_OC4_SetConfig+0x3c>
 8008b9e:	4c0d      	ldr	r4, [pc, #52]	; (8008bd4 <TIM_OC4_SetConfig+0x6c>)
 8008ba0:	42a0      	cmp	r0, r4
 8008ba2:	d104      	bne.n	8008bae <TIM_OC4_SetConfig+0x46>
  {
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

   /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 8008ba4:	4c0c      	ldr	r4, [pc, #48]	; (8008bd8 <TIM_OC4_SetConfig+0x70>)
 8008ba6:	4023      	ands	r3, r4
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8008ba8:	694c      	ldr	r4, [r1, #20]
 8008baa:	01a4      	lsls	r4, r4, #6
 8008bac:	4323      	orrs	r3, r4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8008bae:	6043      	str	r3, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8008bb0:	684b      	ldr	r3, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 8008bb2:	61c5      	str	r5, [r0, #28]
  TIMx->CCR4 = OC_Config->Pulse;
 8008bb4:	6403      	str	r3, [r0, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8008bb6:	6202      	str	r2, [r0, #32]
}
 8008bb8:	bd30      	pop	{r4, r5, pc}
 8008bba:	46c0      	nop			; (mov r8, r8)
 8008bbc:	ffffefff 	.word	0xffffefff
 8008bc0:	ffff8cff 	.word	0xffff8cff
 8008bc4:	ffffdfff 	.word	0xffffdfff
 8008bc8:	40012c00 	.word	0x40012c00
 8008bcc:	40014000 	.word	0x40014000
 8008bd0:	40014400 	.word	0x40014400
 8008bd4:	40014800 	.word	0x40014800
 8008bd8:	ffffbfff 	.word	0xffffbfff

08008bdc <HAL_TIM_Base_Stop_IT>:
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 8008bdc:	2101      	movs	r1, #1
 8008bde:	6803      	ldr	r3, [r0, #0]
 8008be0:	68da      	ldr	r2, [r3, #12]
 8008be2:	438a      	bics	r2, r1
 8008be4:	60da      	str	r2, [r3, #12]
  __HAL_TIM_DISABLE(htim);
 8008be6:	6a18      	ldr	r0, [r3, #32]
 8008be8:	4a05      	ldr	r2, [pc, #20]	; (8008c00 <HAL_TIM_Base_Stop_IT+0x24>)
 8008bea:	4210      	tst	r0, r2
 8008bec:	d106      	bne.n	8008bfc <HAL_TIM_Base_Stop_IT+0x20>
 8008bee:	6a18      	ldr	r0, [r3, #32]
 8008bf0:	4a04      	ldr	r2, [pc, #16]	; (8008c04 <HAL_TIM_Base_Stop_IT+0x28>)
 8008bf2:	4210      	tst	r0, r2
 8008bf4:	d102      	bne.n	8008bfc <HAL_TIM_Base_Stop_IT+0x20>
 8008bf6:	681a      	ldr	r2, [r3, #0]
 8008bf8:	438a      	bics	r2, r1
 8008bfa:	601a      	str	r2, [r3, #0]
}
 8008bfc:	2000      	movs	r0, #0
 8008bfe:	4770      	bx	lr
 8008c00:	00001111 	.word	0x00001111
 8008c04:	00000444 	.word	0x00000444

08008c08 <HAL_TIM_OC_MspInit>:
 8008c08:	4770      	bx	lr
	...

08008c0c <TIM_Base_SetConfig>:
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8008c0c:	4a20      	ldr	r2, [pc, #128]	; (8008c90 <TIM_Base_SetConfig+0x84>)
{
 8008c0e:	b510      	push	{r4, lr}
  tmpcr1 = TIMx->CR1;
 8008c10:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8008c12:	4290      	cmp	r0, r2
 8008c14:	d006      	beq.n	8008c24 <TIM_Base_SetConfig+0x18>
 8008c16:	2480      	movs	r4, #128	; 0x80
 8008c18:	05e4      	lsls	r4, r4, #23
 8008c1a:	42a0      	cmp	r0, r4
 8008c1c:	d002      	beq.n	8008c24 <TIM_Base_SetConfig+0x18>
 8008c1e:	4c1d      	ldr	r4, [pc, #116]	; (8008c94 <TIM_Base_SetConfig+0x88>)
 8008c20:	42a0      	cmp	r0, r4
 8008c22:	d10c      	bne.n	8008c3e <TIM_Base_SetConfig+0x32>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8008c24:	2470      	movs	r4, #112	; 0x70
 8008c26:	43a3      	bics	r3, r4
    tmpcr1 |= Structure->CounterMode;
 8008c28:	684c      	ldr	r4, [r1, #4]
 8008c2a:	4323      	orrs	r3, r4
  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8008c2c:	4290      	cmp	r0, r2
 8008c2e:	d012      	beq.n	8008c56 <TIM_Base_SetConfig+0x4a>
 8008c30:	2480      	movs	r4, #128	; 0x80
 8008c32:	05e4      	lsls	r4, r4, #23
 8008c34:	42a0      	cmp	r0, r4
 8008c36:	d00e      	beq.n	8008c56 <TIM_Base_SetConfig+0x4a>
 8008c38:	4c16      	ldr	r4, [pc, #88]	; (8008c94 <TIM_Base_SetConfig+0x88>)
 8008c3a:	42a0      	cmp	r0, r4
 8008c3c:	d00b      	beq.n	8008c56 <TIM_Base_SetConfig+0x4a>
 8008c3e:	4c16      	ldr	r4, [pc, #88]	; (8008c98 <TIM_Base_SetConfig+0x8c>)
 8008c40:	42a0      	cmp	r0, r4
 8008c42:	d008      	beq.n	8008c56 <TIM_Base_SetConfig+0x4a>
 8008c44:	4c15      	ldr	r4, [pc, #84]	; (8008c9c <TIM_Base_SetConfig+0x90>)
 8008c46:	42a0      	cmp	r0, r4
 8008c48:	d005      	beq.n	8008c56 <TIM_Base_SetConfig+0x4a>
 8008c4a:	4c15      	ldr	r4, [pc, #84]	; (8008ca0 <TIM_Base_SetConfig+0x94>)
 8008c4c:	42a0      	cmp	r0, r4
 8008c4e:	d002      	beq.n	8008c56 <TIM_Base_SetConfig+0x4a>
 8008c50:	4c14      	ldr	r4, [pc, #80]	; (8008ca4 <TIM_Base_SetConfig+0x98>)
 8008c52:	42a0      	cmp	r0, r4
 8008c54:	d103      	bne.n	8008c5e <TIM_Base_SetConfig+0x52>
    tmpcr1 &= ~TIM_CR1_CKD;
 8008c56:	4c14      	ldr	r4, [pc, #80]	; (8008ca8 <TIM_Base_SetConfig+0x9c>)
 8008c58:	4023      	ands	r3, r4
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8008c5a:	68cc      	ldr	r4, [r1, #12]
 8008c5c:	4323      	orrs	r3, r4
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8008c5e:	2480      	movs	r4, #128	; 0x80
 8008c60:	43a3      	bics	r3, r4
 8008c62:	694c      	ldr	r4, [r1, #20]
 8008c64:	4323      	orrs	r3, r4
  TIMx->CR1 = tmpcr1;
 8008c66:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8008c68:	688b      	ldr	r3, [r1, #8]
 8008c6a:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8008c6c:	680b      	ldr	r3, [r1, #0]
 8008c6e:	6283      	str	r3, [r0, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8008c70:	4290      	cmp	r0, r2
 8008c72:	d008      	beq.n	8008c86 <TIM_Base_SetConfig+0x7a>
 8008c74:	4b09      	ldr	r3, [pc, #36]	; (8008c9c <TIM_Base_SetConfig+0x90>)
 8008c76:	4298      	cmp	r0, r3
 8008c78:	d005      	beq.n	8008c86 <TIM_Base_SetConfig+0x7a>
 8008c7a:	4b09      	ldr	r3, [pc, #36]	; (8008ca0 <TIM_Base_SetConfig+0x94>)
 8008c7c:	4298      	cmp	r0, r3
 8008c7e:	d002      	beq.n	8008c86 <TIM_Base_SetConfig+0x7a>
 8008c80:	4b08      	ldr	r3, [pc, #32]	; (8008ca4 <TIM_Base_SetConfig+0x98>)
 8008c82:	4298      	cmp	r0, r3
 8008c84:	d101      	bne.n	8008c8a <TIM_Base_SetConfig+0x7e>
    TIMx->RCR = Structure->RepetitionCounter;
 8008c86:	690b      	ldr	r3, [r1, #16]
 8008c88:	6303      	str	r3, [r0, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 8008c8a:	2301      	movs	r3, #1
 8008c8c:	6143      	str	r3, [r0, #20]
}
 8008c8e:	bd10      	pop	{r4, pc}
 8008c90:	40012c00 	.word	0x40012c00
 8008c94:	40000400 	.word	0x40000400
 8008c98:	40002000 	.word	0x40002000
 8008c9c:	40014000 	.word	0x40014000
 8008ca0:	40014400 	.word	0x40014400
 8008ca4:	40014800 	.word	0x40014800
 8008ca8:	fffffcff 	.word	0xfffffcff

08008cac <HAL_TIM_Base_Init>:
{
 8008cac:	b570      	push	{r4, r5, r6, lr}
 8008cae:	0004      	movs	r4, r0
    return HAL_ERROR;
 8008cb0:	2001      	movs	r0, #1
  if(htim == NULL)
 8008cb2:	2c00      	cmp	r4, #0
 8008cb4:	d014      	beq.n	8008ce0 <HAL_TIM_Base_Init+0x34>
  if(htim->State == HAL_TIM_STATE_RESET)
 8008cb6:	0025      	movs	r5, r4
 8008cb8:	353d      	adds	r5, #61	; 0x3d
 8008cba:	782b      	ldrb	r3, [r5, #0]
 8008cbc:	b2db      	uxtb	r3, r3
 8008cbe:	2b00      	cmp	r3, #0
 8008cc0:	d105      	bne.n	8008cce <HAL_TIM_Base_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 8008cc2:	0022      	movs	r2, r4
 8008cc4:	323c      	adds	r2, #60	; 0x3c
 8008cc6:	7013      	strb	r3, [r2, #0]
    HAL_TIM_Base_MspInit(htim);
 8008cc8:	0020      	movs	r0, r4
 8008cca:	f7fd f98d 	bl	8005fe8 <HAL_TIM_Base_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 8008cce:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8008cd0:	6820      	ldr	r0, [r4, #0]
  htim->State= HAL_TIM_STATE_BUSY;
 8008cd2:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8008cd4:	1d21      	adds	r1, r4, #4
 8008cd6:	f7ff ff99 	bl	8008c0c <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8008cda:	2301      	movs	r3, #1
  return HAL_OK;
 8008cdc:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 8008cde:	702b      	strb	r3, [r5, #0]
}
 8008ce0:	bd70      	pop	{r4, r5, r6, pc}

08008ce2 <HAL_TIM_OC_Init>:
{
 8008ce2:	b570      	push	{r4, r5, r6, lr}
 8008ce4:	0004      	movs	r4, r0
    return HAL_ERROR;
 8008ce6:	2001      	movs	r0, #1
  if(htim == NULL)
 8008ce8:	2c00      	cmp	r4, #0
 8008cea:	d014      	beq.n	8008d16 <HAL_TIM_OC_Init+0x34>
  if(htim->State == HAL_TIM_STATE_RESET)
 8008cec:	0025      	movs	r5, r4
 8008cee:	353d      	adds	r5, #61	; 0x3d
 8008cf0:	782b      	ldrb	r3, [r5, #0]
 8008cf2:	b2db      	uxtb	r3, r3
 8008cf4:	2b00      	cmp	r3, #0
 8008cf6:	d105      	bne.n	8008d04 <HAL_TIM_OC_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 8008cf8:	0022      	movs	r2, r4
 8008cfa:	323c      	adds	r2, #60	; 0x3c
 8008cfc:	7013      	strb	r3, [r2, #0]
    HAL_TIM_OC_MspInit(htim);
 8008cfe:	0020      	movs	r0, r4
 8008d00:	f7ff ff82 	bl	8008c08 <HAL_TIM_OC_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 8008d04:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 8008d06:	6820      	ldr	r0, [r4, #0]
  htim->State= HAL_TIM_STATE_BUSY;
 8008d08:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 8008d0a:	1d21      	adds	r1, r4, #4
 8008d0c:	f7ff ff7e 	bl	8008c0c <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8008d10:	2301      	movs	r3, #1
  return HAL_OK;
 8008d12:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 8008d14:	702b      	strb	r3, [r5, #0]
}
 8008d16:	bd70      	pop	{r4, r5, r6, pc}

08008d18 <TIM_OC2_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8008d18:	2210      	movs	r2, #16
 8008d1a:	6a03      	ldr	r3, [r0, #32]
{
 8008d1c:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8008d1e:	4393      	bics	r3, r2
 8008d20:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8008d22:	6a02      	ldr	r2, [r0, #32]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8008d24:	4d16      	ldr	r5, [pc, #88]	; (8008d80 <TIM_OC2_SetConfig+0x68>)
  tmpcr2 =  TIMx->CR2;
 8008d26:	6843      	ldr	r3, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 8008d28:	6984      	ldr	r4, [r0, #24]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8008d2a:	402c      	ands	r4, r5
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8008d2c:	680d      	ldr	r5, [r1, #0]
 8008d2e:	022d      	lsls	r5, r5, #8
 8008d30:	432c      	orrs	r4, r5
  tmpccer &= ~TIM_CCER_CC2P;
 8008d32:	2520      	movs	r5, #32
 8008d34:	43aa      	bics	r2, r5
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8008d36:	688d      	ldr	r5, [r1, #8]
 8008d38:	012d      	lsls	r5, r5, #4
 8008d3a:	432a      	orrs	r2, r5
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8008d3c:	4d11      	ldr	r5, [pc, #68]	; (8008d84 <TIM_OC2_SetConfig+0x6c>)
 8008d3e:	42a8      	cmp	r0, r5
 8008d40:	d10f      	bne.n	8008d62 <TIM_OC2_SetConfig+0x4a>
    tmpccer &= ~TIM_CCER_CC2NP;
 8008d42:	2580      	movs	r5, #128	; 0x80
 8008d44:	43aa      	bics	r2, r5
 8008d46:	0015      	movs	r5, r2
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8008d48:	68ca      	ldr	r2, [r1, #12]
 8008d4a:	0112      	lsls	r2, r2, #4
 8008d4c:	432a      	orrs	r2, r5
    tmpccer &= ~TIM_CCER_CC2NE;
 8008d4e:	2540      	movs	r5, #64	; 0x40
 8008d50:	43aa      	bics	r2, r5
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8008d52:	4d0d      	ldr	r5, [pc, #52]	; (8008d88 <TIM_OC2_SetConfig+0x70>)
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8008d54:	694e      	ldr	r6, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8008d56:	401d      	ands	r5, r3
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8008d58:	698b      	ldr	r3, [r1, #24]
 8008d5a:	4333      	orrs	r3, r6
 8008d5c:	009b      	lsls	r3, r3, #2
 8008d5e:	432b      	orrs	r3, r5
 8008d60:	e008      	b.n	8008d74 <TIM_OC2_SetConfig+0x5c>
  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8008d62:	4d0a      	ldr	r5, [pc, #40]	; (8008d8c <TIM_OC2_SetConfig+0x74>)
 8008d64:	42a8      	cmp	r0, r5
 8008d66:	d0f4      	beq.n	8008d52 <TIM_OC2_SetConfig+0x3a>
 8008d68:	4d09      	ldr	r5, [pc, #36]	; (8008d90 <TIM_OC2_SetConfig+0x78>)
 8008d6a:	42a8      	cmp	r0, r5
 8008d6c:	d0f1      	beq.n	8008d52 <TIM_OC2_SetConfig+0x3a>
 8008d6e:	4d09      	ldr	r5, [pc, #36]	; (8008d94 <TIM_OC2_SetConfig+0x7c>)
 8008d70:	42a8      	cmp	r0, r5
 8008d72:	d0ee      	beq.n	8008d52 <TIM_OC2_SetConfig+0x3a>
  TIMx->CR2 = tmpcr2;
 8008d74:	6043      	str	r3, [r0, #4]
  TIMx->CCR2 = OC_Config->Pulse;
 8008d76:	684b      	ldr	r3, [r1, #4]
  TIMx->CCMR1 = tmpccmrx;
 8008d78:	6184      	str	r4, [r0, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8008d7a:	6383      	str	r3, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
 8008d7c:	6202      	str	r2, [r0, #32]
}
 8008d7e:	bd70      	pop	{r4, r5, r6, pc}
 8008d80:	ffff8cff 	.word	0xffff8cff
 8008d84:	40012c00 	.word	0x40012c00
 8008d88:	fffff3ff 	.word	0xfffff3ff
 8008d8c:	40014000 	.word	0x40014000
 8008d90:	40014400 	.word	0x40014400
 8008d94:	40014800 	.word	0x40014800

08008d98 <HAL_TIM_OC_ConfigChannel>:
{
 8008d98:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(htim);
 8008d9a:	0004      	movs	r4, r0
 8008d9c:	2602      	movs	r6, #2
 8008d9e:	343c      	adds	r4, #60	; 0x3c
 8008da0:	7825      	ldrb	r5, [r4, #0]
{
 8008da2:	0003      	movs	r3, r0
  __HAL_LOCK(htim);
 8008da4:	0030      	movs	r0, r6
 8008da6:	2d01      	cmp	r5, #1
 8008da8:	d017      	beq.n	8008dda <HAL_TIM_OC_ConfigChannel+0x42>
  htim->State = HAL_TIM_STATE_BUSY;
 8008daa:	001d      	movs	r5, r3
  __HAL_LOCK(htim);
 8008dac:	3801      	subs	r0, #1
  htim->State = HAL_TIM_STATE_BUSY;
 8008dae:	353d      	adds	r5, #61	; 0x3d
  __HAL_LOCK(htim);
 8008db0:	7020      	strb	r0, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8008db2:	702e      	strb	r6, [r5, #0]
  switch (Channel)
 8008db4:	2a0c      	cmp	r2, #12
 8008db6:	d80c      	bhi.n	8008dd2 <HAL_TIM_OC_ConfigChannel+0x3a>
 8008db8:	0010      	movs	r0, r2
 8008dba:	f7fc fdf1 	bl	80059a0 <__gnu_thumb1_case_uqi>
 8008dbe:	0a07      	.short	0x0a07
 8008dc0:	0a0f0a0a 	.word	0x0a0f0a0a
 8008dc4:	0a130a0a 	.word	0x0a130a0a
 8008dc8:	0a0a      	.short	0x0a0a
 8008dca:	17          	.byte	0x17
 8008dcb:	00          	.byte	0x00
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8008dcc:	6818      	ldr	r0, [r3, #0]
 8008dce:	f7ff fe43 	bl	8008a58 <TIM_OC1_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
 8008dd2:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
 8008dd4:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8008dd6:	702b      	strb	r3, [r5, #0]
  __HAL_UNLOCK(htim);
 8008dd8:	7020      	strb	r0, [r4, #0]
}
 8008dda:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8008ddc:	6818      	ldr	r0, [r3, #0]
 8008dde:	f7ff ff9b 	bl	8008d18 <TIM_OC2_SetConfig>
    break;
 8008de2:	e7f6      	b.n	8008dd2 <HAL_TIM_OC_ConfigChannel+0x3a>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8008de4:	6818      	ldr	r0, [r3, #0]
 8008de6:	f7ff fe7b 	bl	8008ae0 <TIM_OC3_SetConfig>
    break;
 8008dea:	e7f2      	b.n	8008dd2 <HAL_TIM_OC_ConfigChannel+0x3a>
       TIM_OC4_SetConfig(htim->Instance, sConfig);
 8008dec:	6818      	ldr	r0, [r3, #0]
 8008dee:	f7ff febb 	bl	8008b68 <TIM_OC4_SetConfig>
    break;
 8008df2:	e7ee      	b.n	8008dd2 <HAL_TIM_OC_ConfigChannel+0x3a>

08008df4 <TIM_CCxChannelCmd>:
  * @param  ChannelState : specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
{
 8008df4:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << Channel;
 8008df6:	2401      	movs	r4, #1
 8008df8:	408c      	lsls	r4, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;

  /* Set or reset the CCxE Bit */
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 8008dfa:	408a      	lsls	r2, r1
  TIMx->CCER &= ~tmp;
 8008dfc:	6a03      	ldr	r3, [r0, #32]
 8008dfe:	43a3      	bics	r3, r4
 8008e00:	6203      	str	r3, [r0, #32]
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 8008e02:	6a03      	ldr	r3, [r0, #32]
 8008e04:	431a      	orrs	r2, r3
 8008e06:	6202      	str	r2, [r0, #32]
}
 8008e08:	bd10      	pop	{r4, pc}
	...

08008e0c <HAL_TIM_OC_Start_IT>:
{
 8008e0c:	b510      	push	{r4, lr}
 8008e0e:	6803      	ldr	r3, [r0, #0]
 8008e10:	0004      	movs	r4, r0
  switch (Channel)
 8008e12:	290c      	cmp	r1, #12
 8008e14:	d80d      	bhi.n	8008e32 <HAL_TIM_OC_Start_IT+0x26>
 8008e16:	0008      	movs	r0, r1
 8008e18:	f7fc fdc2 	bl	80059a0 <__gnu_thumb1_case_uqi>
 8008e1c:	0b0b0b07 	.word	0x0b0b0b07
 8008e20:	0b0b0b27 	.word	0x0b0b0b27
 8008e24:	0b0b0b2a 	.word	0x0b0b0b2a
 8008e28:	2d          	.byte	0x2d
 8008e29:	00          	.byte	0x00
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 8008e2a:	2202      	movs	r2, #2
 8008e2c:	68d8      	ldr	r0, [r3, #12]
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 8008e2e:	4302      	orrs	r2, r0
 8008e30:	60da      	str	r2, [r3, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8008e32:	2201      	movs	r2, #1
 8008e34:	0018      	movs	r0, r3
 8008e36:	f7ff ffdd 	bl	8008df4 <TIM_CCxChannelCmd>
  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8008e3a:	6823      	ldr	r3, [r4, #0]
 8008e3c:	4a0f      	ldr	r2, [pc, #60]	; (8008e7c <HAL_TIM_OC_Start_IT+0x70>)
 8008e3e:	4293      	cmp	r3, r2
 8008e40:	d008      	beq.n	8008e54 <HAL_TIM_OC_Start_IT+0x48>
 8008e42:	4a0f      	ldr	r2, [pc, #60]	; (8008e80 <HAL_TIM_OC_Start_IT+0x74>)
 8008e44:	4293      	cmp	r3, r2
 8008e46:	d005      	beq.n	8008e54 <HAL_TIM_OC_Start_IT+0x48>
 8008e48:	4a0e      	ldr	r2, [pc, #56]	; (8008e84 <HAL_TIM_OC_Start_IT+0x78>)
 8008e4a:	4293      	cmp	r3, r2
 8008e4c:	d002      	beq.n	8008e54 <HAL_TIM_OC_Start_IT+0x48>
 8008e4e:	4a0e      	ldr	r2, [pc, #56]	; (8008e88 <HAL_TIM_OC_Start_IT+0x7c>)
 8008e50:	4293      	cmp	r3, r2
 8008e52:	d104      	bne.n	8008e5e <HAL_TIM_OC_Start_IT+0x52>
    __HAL_TIM_MOE_ENABLE(htim);
 8008e54:	2280      	movs	r2, #128	; 0x80
 8008e56:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8008e58:	0212      	lsls	r2, r2, #8
 8008e5a:	430a      	orrs	r2, r1
 8008e5c:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_ENABLE(htim);
 8008e5e:	2201      	movs	r2, #1
 8008e60:	6819      	ldr	r1, [r3, #0]
}
 8008e62:	2000      	movs	r0, #0
  __HAL_TIM_ENABLE(htim);
 8008e64:	430a      	orrs	r2, r1
 8008e66:	601a      	str	r2, [r3, #0]
}
 8008e68:	bd10      	pop	{r4, pc}
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 8008e6a:	68d8      	ldr	r0, [r3, #12]
 8008e6c:	2204      	movs	r2, #4
 8008e6e:	e7de      	b.n	8008e2e <HAL_TIM_OC_Start_IT+0x22>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 8008e70:	68d8      	ldr	r0, [r3, #12]
 8008e72:	2208      	movs	r2, #8
 8008e74:	e7db      	b.n	8008e2e <HAL_TIM_OC_Start_IT+0x22>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 8008e76:	68d8      	ldr	r0, [r3, #12]
 8008e78:	2210      	movs	r2, #16
 8008e7a:	e7d8      	b.n	8008e2e <HAL_TIM_OC_Start_IT+0x22>
 8008e7c:	40012c00 	.word	0x40012c00
 8008e80:	40014000 	.word	0x40014000
 8008e84:	40014400 	.word	0x40014400
 8008e88:	40014800 	.word	0x40014800

08008e8c <HAL_TIM_OC_Stop_IT>:
{
 8008e8c:	b510      	push	{r4, lr}
 8008e8e:	6803      	ldr	r3, [r0, #0]
 8008e90:	0004      	movs	r4, r0
  switch (Channel)
 8008e92:	290c      	cmp	r1, #12
 8008e94:	d80d      	bhi.n	8008eb2 <HAL_TIM_OC_Stop_IT+0x26>
 8008e96:	0008      	movs	r0, r1
 8008e98:	f7fc fd82 	bl	80059a0 <__gnu_thumb1_case_uqi>
 8008e9c:	0b0b0b07 	.word	0x0b0b0b07
 8008ea0:	0b0b0b35 	.word	0x0b0b0b35
 8008ea4:	0b0b0b38 	.word	0x0b0b0b38
 8008ea8:	3b          	.byte	0x3b
 8008ea9:	00          	.byte	0x00
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 8008eaa:	2002      	movs	r0, #2
 8008eac:	68da      	ldr	r2, [r3, #12]
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 8008eae:	4382      	bics	r2, r0
 8008eb0:	60da      	str	r2, [r3, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 8008eb2:	2200      	movs	r2, #0
 8008eb4:	0018      	movs	r0, r3
 8008eb6:	f7ff ff9d 	bl	8008df4 <TIM_CCxChannelCmd>
  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8008eba:	6823      	ldr	r3, [r4, #0]
 8008ebc:	4a16      	ldr	r2, [pc, #88]	; (8008f18 <HAL_TIM_OC_Stop_IT+0x8c>)
 8008ebe:	4917      	ldr	r1, [pc, #92]	; (8008f1c <HAL_TIM_OC_Stop_IT+0x90>)
 8008ec0:	4293      	cmp	r3, r2
 8008ec2:	d008      	beq.n	8008ed6 <HAL_TIM_OC_Stop_IT+0x4a>
 8008ec4:	4a16      	ldr	r2, [pc, #88]	; (8008f20 <HAL_TIM_OC_Stop_IT+0x94>)
 8008ec6:	4293      	cmp	r3, r2
 8008ec8:	d005      	beq.n	8008ed6 <HAL_TIM_OC_Stop_IT+0x4a>
 8008eca:	4a16      	ldr	r2, [pc, #88]	; (8008f24 <HAL_TIM_OC_Stop_IT+0x98>)
 8008ecc:	4293      	cmp	r3, r2
 8008ece:	d002      	beq.n	8008ed6 <HAL_TIM_OC_Stop_IT+0x4a>
 8008ed0:	4a15      	ldr	r2, [pc, #84]	; (8008f28 <HAL_TIM_OC_Stop_IT+0x9c>)
 8008ed2:	4293      	cmp	r3, r2
 8008ed4:	d10a      	bne.n	8008eec <HAL_TIM_OC_Stop_IT+0x60>
    __HAL_TIM_MOE_DISABLE(htim);
 8008ed6:	6a1a      	ldr	r2, [r3, #32]
 8008ed8:	420a      	tst	r2, r1
 8008eda:	d107      	bne.n	8008eec <HAL_TIM_OC_Stop_IT+0x60>
 8008edc:	6a18      	ldr	r0, [r3, #32]
 8008ede:	4a13      	ldr	r2, [pc, #76]	; (8008f2c <HAL_TIM_OC_Stop_IT+0xa0>)
 8008ee0:	4210      	tst	r0, r2
 8008ee2:	d103      	bne.n	8008eec <HAL_TIM_OC_Stop_IT+0x60>
 8008ee4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8008ee6:	4812      	ldr	r0, [pc, #72]	; (8008f30 <HAL_TIM_OC_Stop_IT+0xa4>)
 8008ee8:	4002      	ands	r2, r0
 8008eea:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_DISABLE(htim);
 8008eec:	6a1a      	ldr	r2, [r3, #32]
 8008eee:	420a      	tst	r2, r1
 8008ef0:	d107      	bne.n	8008f02 <HAL_TIM_OC_Stop_IT+0x76>
 8008ef2:	6a19      	ldr	r1, [r3, #32]
 8008ef4:	4a0d      	ldr	r2, [pc, #52]	; (8008f2c <HAL_TIM_OC_Stop_IT+0xa0>)
 8008ef6:	4211      	tst	r1, r2
 8008ef8:	d103      	bne.n	8008f02 <HAL_TIM_OC_Stop_IT+0x76>
 8008efa:	2101      	movs	r1, #1
 8008efc:	681a      	ldr	r2, [r3, #0]
 8008efe:	438a      	bics	r2, r1
 8008f00:	601a      	str	r2, [r3, #0]
}
 8008f02:	2000      	movs	r0, #0
 8008f04:	bd10      	pop	{r4, pc}
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 8008f06:	68da      	ldr	r2, [r3, #12]
 8008f08:	2004      	movs	r0, #4
 8008f0a:	e7d0      	b.n	8008eae <HAL_TIM_OC_Stop_IT+0x22>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
 8008f0c:	68da      	ldr	r2, [r3, #12]
 8008f0e:	2008      	movs	r0, #8
 8008f10:	e7cd      	b.n	8008eae <HAL_TIM_OC_Stop_IT+0x22>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 8008f12:	68da      	ldr	r2, [r3, #12]
 8008f14:	2010      	movs	r0, #16
 8008f16:	e7ca      	b.n	8008eae <HAL_TIM_OC_Stop_IT+0x22>
 8008f18:	40012c00 	.word	0x40012c00
 8008f1c:	00001111 	.word	0x00001111
 8008f20:	40014000 	.word	0x40014000
 8008f24:	40014400 	.word	0x40014400
 8008f28:	40014800 	.word	0x40014800
 8008f2c:	00000444 	.word	0x00000444
 8008f30:	ffff7fff 	.word	0xffff7fff

08008f34 <HAL_TIMEx_ConfigBreakDeadTime>:
  *         contains the BDTR Register configuration  information for the TIM peripheral.
  * @retval HAL status
  */    
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
                                                TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
{
 8008f34:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));

  /* Process Locked */
  __HAL_LOCK(htim);
 8008f36:	0004      	movs	r4, r0
 8008f38:	2302      	movs	r3, #2
 8008f3a:	343c      	adds	r4, #60	; 0x3c
 8008f3c:	7825      	ldrb	r5, [r4, #0]
{
 8008f3e:	0002      	movs	r2, r0
  __HAL_LOCK(htim);
 8008f40:	0018      	movs	r0, r3
 8008f42:	2d01      	cmp	r5, #1
 8008f44:	d024      	beq.n	8008f90 <HAL_TIMEx_ConfigBreakDeadTime+0x5c>

  htim->State = HAL_TIM_STATE_BUSY;
 8008f46:	0010      	movs	r0, r2
 8008f48:	303d      	adds	r0, #61	; 0x3d
  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  
  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8008f4a:	68cd      	ldr	r5, [r1, #12]
  htim->State = HAL_TIM_STATE_BUSY;
 8008f4c:	7003      	strb	r3, [r0, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8008f4e:	4b11      	ldr	r3, [pc, #68]	; (8008f94 <HAL_TIMEx_ConfigBreakDeadTime+0x60>)
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
  
  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
 8008f50:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8008f52:	402b      	ands	r3, r5
 8008f54:	688d      	ldr	r5, [r1, #8]
 8008f56:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 8008f58:	4d0f      	ldr	r5, [pc, #60]	; (8008f98 <HAL_TIMEx_ConfigBreakDeadTime+0x64>)
 8008f5a:	402b      	ands	r3, r5
 8008f5c:	684d      	ldr	r5, [r1, #4]
 8008f5e:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8008f60:	4d0e      	ldr	r5, [pc, #56]	; (8008f9c <HAL_TIMEx_ConfigBreakDeadTime+0x68>)
 8008f62:	402b      	ands	r3, r5
 8008f64:	680d      	ldr	r5, [r1, #0]
 8008f66:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8008f68:	4d0d      	ldr	r5, [pc, #52]	; (8008fa0 <HAL_TIMEx_ConfigBreakDeadTime+0x6c>)
 8008f6a:	402b      	ands	r3, r5
 8008f6c:	690d      	ldr	r5, [r1, #16]
 8008f6e:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8008f70:	4d0c      	ldr	r5, [pc, #48]	; (8008fa4 <HAL_TIMEx_ConfigBreakDeadTime+0x70>)
 8008f72:	402b      	ands	r3, r5
 8008f74:	694d      	ldr	r5, [r1, #20]
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8008f76:	6989      	ldr	r1, [r1, #24]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8008f78:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8008f7a:	4d0b      	ldr	r5, [pc, #44]	; (8008fa8 <HAL_TIMEx_ConfigBreakDeadTime+0x74>)
 8008f7c:	402b      	ands	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
 8008f7e:	4d0b      	ldr	r5, [pc, #44]	; (8008fac <HAL_TIMEx_ConfigBreakDeadTime+0x78>)
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8008f80:	430b      	orrs	r3, r1
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
 8008f82:	402b      	ands	r3, r5
 8008f84:	430b      	orrs	r3, r1
  htim->Instance->BDTR = tmpbdtr;
 8008f86:	6453      	str	r3, [r2, #68]	; 0x44
  
  htim->State = HAL_TIM_STATE_READY;
 8008f88:	2301      	movs	r3, #1
 8008f8a:	7003      	strb	r3, [r0, #0]

  __HAL_UNLOCK(htim);
 8008f8c:	2000      	movs	r0, #0
 8008f8e:	7020      	strb	r0, [r4, #0]

  return HAL_OK;
}
 8008f90:	bd30      	pop	{r4, r5, pc}
 8008f92:	46c0      	nop			; (mov r8, r8)
 8008f94:	fffffcff 	.word	0xfffffcff
 8008f98:	fffffbff 	.word	0xfffffbff
 8008f9c:	fffff7ff 	.word	0xfffff7ff
 8008fa0:	ffffefff 	.word	0xffffefff
 8008fa4:	ffffdfff 	.word	0xffffdfff
 8008fa8:	ffffbfff 	.word	0xffffbfff
 8008fac:	ffff7fff 	.word	0xffff7fff

08008fb0 <LL_EXTI_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: EXTI registers are initialized
  *          - ERROR: not applicable
  */
uint32_t LL_EXTI_Init(LL_EXTI_InitTypeDef *EXTI_InitStruct)
{
 8008fb0:	b510      	push	{r4, lr}
  assert_param(IS_LL_EXTI_LINE_0_31(EXTI_InitStruct->Line_0_31));
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->LineCommand));
  assert_param(IS_LL_EXTI_MODE(EXTI_InitStruct->Mode));

  /* ENABLE LineCommand */
  if (EXTI_InitStruct->LineCommand != DISABLE)
 8008fb2:	7902      	ldrb	r2, [r0, #4]
 8008fb4:	6803      	ldr	r3, [r0, #0]
 8008fb6:	2a00      	cmp	r2, #0
 8008fb8:	d03c      	beq.n	8009034 <LL_EXTI_Init+0x84>
  ErrorStatus status = SUCCESS;
 8008fba:	2201      	movs	r2, #1
  {
    assert_param(IS_LL_EXTI_TRIGGER(EXTI_InitStruct->Trigger));

    /* Configure EXTI Lines in range from 0 to 31 */
    if (EXTI_InitStruct->Line_0_31 != LL_EXTI_LINE_NONE)
 8008fbc:	2b00      	cmp	r3, #0
 8008fbe:	d01f      	beq.n	8009000 <LL_EXTI_Init+0x50>
    {
      switch (EXTI_InitStruct->Mode)
 8008fc0:	7941      	ldrb	r1, [r0, #5]
 8008fc2:	4291      	cmp	r1, r2
 8008fc4:	d01e      	beq.n	8009004 <LL_EXTI_Init+0x54>
 8008fc6:	2900      	cmp	r1, #0
 8008fc8:	d003      	beq.n	8008fd2 <LL_EXTI_Init+0x22>
 8008fca:	2902      	cmp	r1, #2
 8008fcc:	d022      	beq.n	8009014 <LL_EXTI_Init+0x64>
          /* Directly Enable IT & Event on provided Lines */
          LL_EXTI_EnableIT_0_31(EXTI_InitStruct->Line_0_31);
          LL_EXTI_EnableEvent_0_31(EXTI_InitStruct->Line_0_31);
          break;
        default:
          status = ERROR;
 8008fce:	2200      	movs	r2, #0
 8008fd0:	e006      	b.n	8008fe0 <LL_EXTI_Init+0x30>
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableEvent_0_31(uint32_t ExtiLine)
{
  CLEAR_BIT(EXTI->EMR, ExtiLine);
 8008fd2:	491e      	ldr	r1, [pc, #120]	; (800904c <LL_EXTI_Init+0x9c>)
 8008fd4:	684c      	ldr	r4, [r1, #4]
 8008fd6:	439c      	bics	r4, r3
 8008fd8:	604c      	str	r4, [r1, #4]
  SET_BIT(EXTI->IMR, ExtiLine);
 8008fda:	680c      	ldr	r4, [r1, #0]
 8008fdc:	431c      	orrs	r4, r3
 8008fde:	600c      	str	r4, [r1, #0]
          break;
      }
      if (EXTI_InitStruct->Trigger != LL_EXTI_TRIGGER_NONE)
 8008fe0:	7981      	ldrb	r1, [r0, #6]
 8008fe2:	2900      	cmp	r1, #0
 8008fe4:	d00c      	beq.n	8009000 <LL_EXTI_Init+0x50>
      {
        switch (EXTI_InitStruct->Trigger)
 8008fe6:	2902      	cmp	r1, #2
 8008fe8:	d018      	beq.n	800901c <LL_EXTI_Init+0x6c>
 8008fea:	2903      	cmp	r1, #3
 8008fec:	d01e      	beq.n	800902c <LL_EXTI_Init+0x7c>
 8008fee:	2901      	cmp	r1, #1
 8008ff0:	d12a      	bne.n	8009048 <LL_EXTI_Init+0x98>
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableFallingTrig_0_31(uint32_t ExtiLine)
{
  CLEAR_BIT(EXTI->FTSR, ExtiLine);
 8008ff2:	4916      	ldr	r1, [pc, #88]	; (800904c <LL_EXTI_Init+0x9c>)
 8008ff4:	68c8      	ldr	r0, [r1, #12]
 8008ff6:	4398      	bics	r0, r3
 8008ff8:	60c8      	str	r0, [r1, #12]
  SET_BIT(EXTI->RTSR, ExtiLine);
 8008ffa:	6888      	ldr	r0, [r1, #8]
 8008ffc:	4303      	orrs	r3, r0
 8008ffe:	608b      	str	r3, [r1, #8]
    /* De-configure EXTI Lines in range from 0 to 31 */
    LL_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);
    LL_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);
  }
  return status;
}
 8009000:	0010      	movs	r0, r2
 8009002:	bd10      	pop	{r4, pc}
  CLEAR_BIT(EXTI->IMR, ExtiLine);
 8009004:	4911      	ldr	r1, [pc, #68]	; (800904c <LL_EXTI_Init+0x9c>)
 8009006:	680c      	ldr	r4, [r1, #0]
 8009008:	439c      	bics	r4, r3
  SET_BIT(EXTI->IMR, ExtiLine);
 800900a:	600c      	str	r4, [r1, #0]
  SET_BIT(EXTI->EMR, ExtiLine);
 800900c:	684c      	ldr	r4, [r1, #4]
 800900e:	431c      	orrs	r4, r3
 8009010:	604c      	str	r4, [r1, #4]
 8009012:	e7e5      	b.n	8008fe0 <LL_EXTI_Init+0x30>
  SET_BIT(EXTI->IMR, ExtiLine);
 8009014:	490d      	ldr	r1, [pc, #52]	; (800904c <LL_EXTI_Init+0x9c>)
 8009016:	680c      	ldr	r4, [r1, #0]
 8009018:	431c      	orrs	r4, r3
 800901a:	e7f6      	b.n	800900a <LL_EXTI_Init+0x5a>
  CLEAR_BIT(EXTI->RTSR, ExtiLine);
 800901c:	490b      	ldr	r1, [pc, #44]	; (800904c <LL_EXTI_Init+0x9c>)
 800901e:	6888      	ldr	r0, [r1, #8]
 8009020:	4398      	bics	r0, r3
  SET_BIT(EXTI->RTSR, ExtiLine);
 8009022:	6088      	str	r0, [r1, #8]
  SET_BIT(EXTI->FTSR, ExtiLine);
 8009024:	68c8      	ldr	r0, [r1, #12]
 8009026:	4303      	orrs	r3, r0
 8009028:	60cb      	str	r3, [r1, #12]
 800902a:	e7e9      	b.n	8009000 <LL_EXTI_Init+0x50>
  SET_BIT(EXTI->RTSR, ExtiLine);
 800902c:	4907      	ldr	r1, [pc, #28]	; (800904c <LL_EXTI_Init+0x9c>)
 800902e:	6888      	ldr	r0, [r1, #8]
 8009030:	4318      	orrs	r0, r3
 8009032:	e7f6      	b.n	8009022 <LL_EXTI_Init+0x72>
  CLEAR_BIT(EXTI->IMR, ExtiLine);
 8009034:	43db      	mvns	r3, r3
 8009036:	4a05      	ldr	r2, [pc, #20]	; (800904c <LL_EXTI_Init+0x9c>)
 8009038:	6811      	ldr	r1, [r2, #0]
 800903a:	4019      	ands	r1, r3
 800903c:	6011      	str	r1, [r2, #0]
  CLEAR_BIT(EXTI->EMR, ExtiLine);
 800903e:	6851      	ldr	r1, [r2, #4]
 8009040:	400b      	ands	r3, r1
 8009042:	6053      	str	r3, [r2, #4]
  ErrorStatus status = SUCCESS;
 8009044:	2201      	movs	r2, #1
 8009046:	e7db      	b.n	8009000 <LL_EXTI_Init+0x50>
            status = ERROR;
 8009048:	2200      	movs	r2, #0
 800904a:	e7d9      	b.n	8009000 <LL_EXTI_Init+0x50>
 800904c:	40010400 	.word	0x40010400

08009050 <LL_Init1msTick>:
  * @retval None
  */
__STATIC_INLINE void LL_InitTick(uint32_t HCLKFrequency, uint32_t Ticks)
{
  /* Configure the SysTick to have interrupt in 1ms time base */
  SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
 8009050:	21fa      	movs	r1, #250	; 0xfa
  * @param  HCLKFrequency HCLK frequency in Hz
  * @note   HCLK frequency can be calculated thanks to RCC helper macro or function @ref LL_RCC_GetSystemClocksFreq
  * @retval None
  */
void LL_Init1msTick(uint32_t HCLKFrequency)
{
 8009052:	b510      	push	{r4, lr}
 8009054:	0089      	lsls	r1, r1, #2
 8009056:	f7fc fcad 	bl	80059b4 <__udivsi3>
  SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
 800905a:	2200      	movs	r2, #0
  SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
 800905c:	4b03      	ldr	r3, [pc, #12]	; (800906c <LL_Init1msTick+0x1c>)
 800905e:	3801      	subs	r0, #1
 8009060:	6058      	str	r0, [r3, #4]
  SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
 8009062:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8009064:	3205      	adds	r2, #5
 8009066:	601a      	str	r2, [r3, #0]
  /* Use frequency provided in argument */
  LL_InitTick(HCLKFrequency, 1000U);
}
 8009068:	bd10      	pop	{r4, pc}
 800906a:	46c0      	nop			; (mov r8, r8)
 800906c:	e000e010 	.word	0xe000e010

08009070 <LL_SetSystemCoreClock>:
  * @retval None
  */
void LL_SetSystemCoreClock(uint32_t HCLKFrequency)
{
  /* HCLK clock frequency */
  SystemCoreClock = HCLKFrequency;
 8009070:	4b01      	ldr	r3, [pc, #4]	; (8009078 <LL_SetSystemCoreClock+0x8>)
 8009072:	6018      	str	r0, [r3, #0]
}
 8009074:	4770      	bx	lr
 8009076:	46c0      	nop			; (mov r8, r8)
 8009078:	20000030 	.word	0x20000030

0800907c <USBPD_PE_TaskWakeUp>:
  * @retval None
  */
static void USBPD_PE_TaskWakeUp(uint8_t PortNum)
{
#ifdef _RTOS
  osMessagePut(PEQueueId[PortNum], 0xFFFF, osWaitForever);
 800907c:	2201      	movs	r2, #1
{
 800907e:	b510      	push	{r4, lr}
  osMessagePut(PEQueueId[PortNum], 0xFFFF, osWaitForever);
 8009080:	4b03      	ldr	r3, [pc, #12]	; (8009090 <USBPD_PE_TaskWakeUp+0x14>)
 8009082:	0080      	lsls	r0, r0, #2
 8009084:	4252      	negs	r2, r2
 8009086:	4903      	ldr	r1, [pc, #12]	; (8009094 <USBPD_PE_TaskWakeUp+0x18>)
 8009088:	58c0      	ldr	r0, [r0, r3]
 800908a:	f002 f9bd 	bl	800b408 <osMessagePut>
#endif
}
 800908e:	bd10      	pop	{r4, pc}
 8009090:	2000034c 	.word	0x2000034c
 8009094:	0000ffff 	.word	0x0000ffff

08009098 <USBPD_DPM_CADTaskWakeUp>:
  * @retval None
  */
static void USBPD_DPM_CADTaskWakeUp(void)
{
#ifdef _RTOS
  osMessagePut(CADQueueId, 0xFFFF, osWaitForever);
 8009098:	2201      	movs	r2, #1
{
 800909a:	b510      	push	{r4, lr}
  osMessagePut(CADQueueId, 0xFFFF, osWaitForever);
 800909c:	4b03      	ldr	r3, [pc, #12]	; (80090ac <USBPD_DPM_CADTaskWakeUp+0x14>)
 800909e:	4252      	negs	r2, r2
 80090a0:	4903      	ldr	r1, [pc, #12]	; (80090b0 <USBPD_DPM_CADTaskWakeUp+0x18>)
 80090a2:	6858      	ldr	r0, [r3, #4]
 80090a4:	f002 f9b0 	bl	800b408 <osMessagePut>
#endif
}
 80090a8:	bd10      	pop	{r4, pc}
 80090aa:	46c0      	nop			; (mov r8, r8)
 80090ac:	2000034c 	.word	0x2000034c
 80090b0:	0000ffff 	.word	0x0000ffff

080090b4 <USBPD_PE_Task>:
  * @brief  Main task for PE layer
  * @param  argument Not used
  * @retval None
  */
void USBPD_PE_Task(void const *argument)
{
 80090b4:	b530      	push	{r4, r5, lr}
#elif defined(_SRC)
    USBPD_PE_StateMachine_SRC(_port);
#elif defined(_SNK)
    USBPD_PE_StateMachine_SNK(_port);
#endif
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 80090b6:	b2c4      	uxtb	r4, r0
{
 80090b8:	b085      	sub	sp, #20
  uint8_t _port = (uint32_t)argument;
 80090ba:	b2c5      	uxtb	r5, r0
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 80090bc:	00a4      	lsls	r4, r4, #2
    USBPD_PE_StateMachine_SRC(_port);
 80090be:	0028      	movs	r0, r5
 80090c0:	f7f7 fa24 	bl	800050c <USBPD_PE_StateMachine_SRC>
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 80090c4:	4b03      	ldr	r3, [pc, #12]	; (80090d4 <USBPD_PE_Task+0x20>)
    USBPD_PE_StateMachine_SRC(_port);
 80090c6:	0002      	movs	r2, r0
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 80090c8:	58e1      	ldr	r1, [r4, r3]
 80090ca:	4668      	mov	r0, sp
 80090cc:	f002 f9c2 	bl	800b454 <osMessageGet>
 80090d0:	e7f5      	b.n	80090be <USBPD_PE_Task+0xa>
 80090d2:	46c0      	nop			; (mov r8, r8)
 80090d4:	2000034c 	.word	0x2000034c

080090d8 <USBPD_CAD_Task>:
  * @brief  Main task for CAD layer
  * @param  argument Not used
  * @retval None
  */
void USBPD_CAD_Task(void const *argument)
{
 80090d8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  for(;;)
  {
    DPM_Sleep_time[USBPD_THREAD_CAD] = USBPD_CAD_Process();
 80090da:	f7f7 f857 	bl	800018c <USBPD_CAD_Process>
    osMessageGet(CADQueueId, DPM_Sleep_time[USBPD_THREAD_CAD]);
 80090de:	4b03      	ldr	r3, [pc, #12]	; (80090ec <USBPD_CAD_Task+0x14>)
    DPM_Sleep_time[USBPD_THREAD_CAD] = USBPD_CAD_Process();
 80090e0:	0002      	movs	r2, r0
    osMessageGet(CADQueueId, DPM_Sleep_time[USBPD_THREAD_CAD]);
 80090e2:	6859      	ldr	r1, [r3, #4]
 80090e4:	4668      	mov	r0, sp
 80090e6:	f002 f9b5 	bl	800b454 <osMessageGet>
 80090ea:	e7f6      	b.n	80090da <USBPD_CAD_Task+0x2>
 80090ec:	2000034c 	.word	0x2000034c

080090f0 <USBPD_DPM_CADCallback>:
  * @param  State     CAD state
  * @param  Cc        The Communication Channel for the USBPD communication
  * @retval None
  */
void USBPD_DPM_CADCallback(uint8_t PortNum, USBPD_CAD_EVENT State, CCxPin_TypeDef Cc)
{
 80090f0:	b570      	push	{r4, r5, r6, lr}
 80090f2:	0004      	movs	r4, r0
#ifdef _TRACE
  USBPD_TRACE_Add(USBPD_TRACE_CADEVENT, PortNum, State, NULL, 0);
#endif /* _TRACE */

  switch(State)
 80090f4:	1e48      	subs	r0, r1, #1
{
 80090f6:	000d      	movs	r5, r1
  switch(State)
 80090f8:	2806      	cmp	r0, #6
 80090fa:	d827      	bhi.n	800914c <USBPD_DPM_CADCallback+0x5c>
 80090fc:	f7fc fc50 	bl	80059a0 <__gnu_thumb1_case_uqi>
 8009100:	04280428 	.word	0x04280428
 8009104:	2626      	.short	0x2626
 8009106:	42          	.byte	0x42
 8009107:	00          	.byte	0x00
  case USBPD_CAD_EVENT_ATTACHED :
#ifdef _VCONN_SUPPORT
    if(CC1 == Cc) DPM_Params[PortNum].VconnCCIs = CC2;
    if(CC2 == Cc) DPM_Params[PortNum].VconnCCIs = CC1;
#endif /* _VCONN_SUPPORT */
    DPM_Params[PortNum].ActiveCCIs = Cc;
 8009108:	2003      	movs	r0, #3
 800910a:	4928      	ldr	r1, [pc, #160]	; (80091ac <USBPD_DPM_CADCallback+0xbc>)
 800910c:	00e3      	lsls	r3, r4, #3
 800910e:	18c9      	adds	r1, r1, r3
 8009110:	784b      	ldrb	r3, [r1, #1]
 8009112:	4002      	ands	r2, r0
 8009114:	4383      	bics	r3, r0
 8009116:	431a      	orrs	r2, r3
 8009118:	704a      	strb	r2, [r1, #1]
    USBPD_PE_IsCableConnected(PortNum, 1);
 800911a:	0020      	movs	r0, r4
 800911c:	2101      	movs	r1, #1
 800911e:	f7f7 f9cc 	bl	80004ba <USBPD_PE_IsCableConnected>

    USBPD_DPM_UserCableDetection(PortNum, State);
 8009122:	0029      	movs	r1, r5
 8009124:	0020      	movs	r0, r4
 8009126:	f7fd f80b 	bl	8006140 <USBPD_DPM_UserCableDetection>
    USBPD_DPM_WaitForTime(6);
#endif /* USBPD_TCPM_MODULE_ENABLED */

#ifdef _RTOS
    /* Create PE task */
    if (DPM_Thread_Table[PortNum] == NULL)
 800912a:	4d21      	ldr	r5, [pc, #132]	; (80091b0 <USBPD_DPM_CADCallback+0xc0>)
 800912c:	00a6      	lsls	r6, r4, #2
 800912e:	19ab      	adds	r3, r5, r6
 8009130:	689b      	ldr	r3, [r3, #8]
 8009132:	2b00      	cmp	r3, #0
 8009134:	d10a      	bne.n	800914c <USBPD_DPM_CADCallback+0x5c>
 8009136:	481f      	ldr	r0, [pc, #124]	; (80091b4 <USBPD_DPM_CADCallback+0xc4>)
    {
      DPM_Thread_Table[PortNum] = osThreadCreate(OSTHREAD_PE(PortNum), (void *)((uint32_t)PortNum));
 8009138:	2c00      	cmp	r4, #0
 800913a:	d000      	beq.n	800913e <USBPD_DPM_CADCallback+0x4e>
 800913c:	3014      	adds	r0, #20
 800913e:	0021      	movs	r1, r4
 8009140:	f002 f935 	bl	800b3ae <osThreadCreate>
      if (DPM_Thread_Table[PortNum] == NULL)
 8009144:	2800      	cmp	r0, #0
 8009146:	d002      	beq.n	800914e <USBPD_DPM_CADCallback+0x5e>
      DPM_Thread_Table[PortNum] = osThreadCreate(OSTHREAD_PE(PortNum), (void *)((uint32_t)PortNum));
 8009148:	19ad      	adds	r5, r5, r6
 800914a:	60a8      	str	r0, [r5, #8]
    break;
  default :
    /* nothing to do */
    break;
  }
}
 800914c:	bd70      	pop	{r4, r5, r6, pc}
 800914e:	e7fe      	b.n	800914e <USBPD_DPM_CADCallback+0x5e>
    USBPD_PE_IsCableConnected(PortNum, 0);
 8009150:	2100      	movs	r1, #0
 8009152:	0020      	movs	r0, r4
 8009154:	f7f7 f9b1 	bl	80004ba <USBPD_PE_IsCableConnected>
    if (DPM_Thread_Table[PortNum] != NULL)
 8009158:	4e15      	ldr	r6, [pc, #84]	; (80091b0 <USBPD_DPM_CADCallback+0xc0>)
 800915a:	00a3      	lsls	r3, r4, #2
 800915c:	18f6      	adds	r6, r6, r3
 800915e:	68b0      	ldr	r0, [r6, #8]
 8009160:	2800      	cmp	r0, #0
 8009162:	d003      	beq.n	800916c <USBPD_DPM_CADCallback+0x7c>
      osThreadTerminate(DPM_Thread_Table[PortNum]);
 8009164:	f002 f93c 	bl	800b3e0 <osThreadTerminate>
      DPM_Thread_Table[PortNum] = NULL;
 8009168:	2300      	movs	r3, #0
 800916a:	60b3      	str	r3, [r6, #8]
    USBPD_DPM_UserCableDetection(PortNum, State);
 800916c:	0020      	movs	r0, r4
 800916e:	0029      	movs	r1, r5
 8009170:	f7fc ffe6 	bl	8006140 <USBPD_DPM_UserCableDetection>
    DPM_Params[PortNum].PE_Power   = USBPD_POWER_NO;
 8009174:	228c      	movs	r2, #140	; 0x8c
    DPM_Params[PortNum].ActiveCCIs = CCNONE;
 8009176:	4b0d      	ldr	r3, [pc, #52]	; (80091ac <USBPD_DPM_CADCallback+0xbc>)
 8009178:	00e4      	lsls	r4, r4, #3
 800917a:	191c      	adds	r4, r3, r4
 800917c:	7863      	ldrb	r3, [r4, #1]
    DPM_Params[PortNum].PE_Power   = USBPD_POWER_NO;
 800917e:	4013      	ands	r3, r2
 8009180:	7063      	strb	r3, [r4, #1]
    break;
 8009182:	e7e3      	b.n	800914c <USBPD_DPM_CADCallback+0x5c>
    DPM_Params[PortNum].ActiveCCIs  = Cc;
 8009184:	4909      	ldr	r1, [pc, #36]	; (80091ac <USBPD_DPM_CADCallback+0xbc>)
 8009186:	00e3      	lsls	r3, r4, #3
 8009188:	18c9      	adds	r1, r1, r3
 800918a:	2003      	movs	r0, #3
 800918c:	0013      	movs	r3, r2
 800918e:	784a      	ldrb	r2, [r1, #1]
 8009190:	4003      	ands	r3, r0
 8009192:	4382      	bics	r2, r0
    DPM_Params[PortNum].PE_Power    = USBPD_POWER_DEFAULT5V;
 8009194:	431a      	orrs	r2, r3
 8009196:	2370      	movs	r3, #112	; 0x70
 8009198:	439a      	bics	r2, r3
 800919a:	3b60      	subs	r3, #96	; 0x60
 800919c:	431a      	orrs	r2, r3
 800919e:	704a      	strb	r2, [r1, #1]
    USBPD_DPM_UserCableDetection(PortNum, State);
 80091a0:	0020      	movs	r0, r4
 80091a2:	2107      	movs	r1, #7
 80091a4:	f7fc ffcc 	bl	8006140 <USBPD_DPM_UserCableDetection>
}
 80091a8:	e7d0      	b.n	800914c <USBPD_DPM_CADCallback+0x5c>
 80091aa:	46c0      	nop			; (mov r8, r8)
 80091ac:	20001b84 	.word	0x20001b84
 80091b0:	2000034c 	.word	0x2000034c
 80091b4:	0800c6f4 	.word	0x0800c6f4

080091b8 <USBPD_DPM_Init>:
{
 80091b8:	b5f0      	push	{r4, r5, r6, r7, lr}
  if( USBPD_TRUE != USBPD_PE_CheckLIB(_LIB_ID))
 80091ba:	482e      	ldr	r0, [pc, #184]	; (8009274 <USBPD_DPM_Init+0xbc>)
{
 80091bc:	b089      	sub	sp, #36	; 0x24
  if( USBPD_TRUE != USBPD_PE_CheckLIB(_LIB_ID))
 80091be:	f7f7 f8eb 	bl	8000398 <USBPD_PE_CheckLIB>
 80091c2:	9001      	str	r0, [sp, #4]
 80091c4:	2801      	cmp	r0, #1
 80091c6:	d003      	beq.n	80091d0 <USBPD_DPM_Init+0x18>
    return USBPD_ERROR;
 80091c8:	2602      	movs	r6, #2
}
 80091ca:	0030      	movs	r0, r6
 80091cc:	b009      	add	sp, #36	; 0x24
 80091ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
  stack_dynamemsize = USBPD_PE_GetMemoryConsumption();
 80091d0:	f7f7 f8e9 	bl	80003a6 <USBPD_PE_GetMemoryConsumption>
  DPM_Params[USBPD_PORT_0].PE_SpecRevision  = DPM_Settings[USBPD_PORT_0].PE_SpecRevision;
 80091d4:	2203      	movs	r2, #3
  DPM_Params[USBPD_PORT_0].PE_PowerRole     = DPM_Settings[USBPD_PORT_0].PE_DefaultRole;
 80091d6:	2302      	movs	r3, #2
  DPM_Params[USBPD_PORT_0].DPM_Initialized = USBPD_FALSE;
 80091d8:	4c27      	ldr	r4, [pc, #156]	; (8009278 <USBPD_DPM_Init+0xc0>)
 80091da:	2504      	movs	r5, #4
  DPM_Params[USBPD_PORT_0].PE_SpecRevision  = DPM_Settings[USBPD_PORT_0].PE_SpecRevision;
 80091dc:	7820      	ldrb	r0, [r4, #0]
  DPM_Params[USBPD_PORT_0].DPM_Initialized = USBPD_FALSE;
 80091de:	7861      	ldrb	r1, [r4, #1]
  DPM_Params[USBPD_PORT_0].PE_SpecRevision  = DPM_Settings[USBPD_PORT_0].PE_SpecRevision;
 80091e0:	4390      	bics	r0, r2
  DPM_Params[USBPD_PORT_0].PE_PowerRole     = DPM_Settings[USBPD_PORT_0].PE_DefaultRole;
 80091e2:	4303      	orrs	r3, r0
  DPM_Params[USBPD_PORT_0].PE_SwapOngoing   = 0;
 80091e4:	2010      	movs	r0, #16
 80091e6:	432b      	orrs	r3, r5
 80091e8:	4383      	bics	r3, r0
 80091ea:	7023      	strb	r3, [r4, #0]
  DPM_Params[USBPD_PORT_0].ActiveCCIs       = CCNONE;
 80091ec:	000b      	movs	r3, r1
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 80091ee:	4e23      	ldr	r6, [pc, #140]	; (800927c <USBPD_DPM_Init+0xc4>)
  DPM_Params[USBPD_PORT_0].ActiveCCIs       = CCNONE;
 80091f0:	43ab      	bics	r3, r5
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 80091f2:	0037      	movs	r7, r6
 80091f4:	0031      	movs	r1, r6
  DPM_Params[USBPD_PORT_0].ActiveCCIs       = CCNONE;
 80091f6:	4393      	bics	r3, r2
 80091f8:	7063      	strb	r3, [r4, #1]
  DPM_Params[USBPD_PORT_0].VconnCCIs        = CCNONE;
 80091fa:	78a3      	ldrb	r3, [r4, #2]
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 80091fc:	3728      	adds	r7, #40	; 0x28
  DPM_Params[USBPD_PORT_0].VconnStatus      = USBPD_FALSE;
 80091fe:	4393      	bics	r3, r2
 8009200:	43ab      	bics	r3, r5
 8009202:	70a3      	strb	r3, [r4, #2]
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 8009204:	3134      	adds	r1, #52	; 0x34
 8009206:	0023      	movs	r3, r4
 8009208:	003a      	movs	r2, r7
 800920a:	2000      	movs	r0, #0
 800920c:	f7f6 ff7c 	bl	8000108 <USBPD_CAD_Init>
 8009210:	2800      	cmp	r0, #0
 8009212:	d1d9      	bne.n	80091c8 <USBPD_DPM_Init+0x10>
  CHECK_PE_FUNCTION_CALL(USBPD_PE_Init(USBPD_PORT_0, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0], &dpmCallbacks));
 8009214:	0033      	movs	r3, r6
 8009216:	0022      	movs	r2, r4
 8009218:	333c      	adds	r3, #60	; 0x3c
 800921a:	0039      	movs	r1, r7
 800921c:	f7f7 f824 	bl	8000268 <USBPD_PE_Init>
 8009220:	1e06      	subs	r6, r0, #0
 8009222:	d1d1      	bne.n	80091c8 <USBPD_DPM_Init+0x10>
  DPM_Params[USBPD_PORT_0].DPM_Initialized = USBPD_TRUE;
 8009224:	7863      	ldrb	r3, [r4, #1]
 8009226:	431d      	orrs	r5, r3
 8009228:	7065      	strb	r5, [r4, #1]
  USBPD_DPM_UserInit();
 800922a:	f7fc ff3f 	bl	80060ac <USBPD_DPM_UserInit>
  USBPD_CAD_PortEnable(USBPD_PORT_0, USBPD_CAD_ENABLE);
 800922e:	9901      	ldr	r1, [sp, #4]
 8009230:	0030      	movs	r0, r6
 8009232:	f7f6 ffa3 	bl	800017c <USBPD_CAD_PortEnable>
  osThreadDef(CAD, USBPD_CAD_Task, osPriorityNormal, 0, 150);
 8009236:	4c12      	ldr	r4, [pc, #72]	; (8009280 <USBPD_DPM_Init+0xc8>)
 8009238:	a803      	add	r0, sp, #12
 800923a:	0003      	movs	r3, r0
 800923c:	0022      	movs	r2, r4
 800923e:	caa2      	ldmia	r2!, {r1, r5, r7}
 8009240:	c3a2      	stmia	r3!, {r1, r5, r7}
 8009242:	ca22      	ldmia	r2!, {r1, r5}
 8009244:	c322      	stmia	r3!, {r1, r5}
  if((DPM_Thread_Table[USBPD_THREAD_CAD] = osThreadCreate(osThread(CAD), NULL)) == NULL)
 8009246:	0031      	movs	r1, r6
 8009248:	f002 f8b1 	bl	800b3ae <osThreadCreate>
 800924c:	4d0d      	ldr	r5, [pc, #52]	; (8009284 <USBPD_DPM_Init+0xcc>)
 800924e:	60e8      	str	r0, [r5, #12]
 8009250:	2800      	cmp	r0, #0
 8009252:	d0b9      	beq.n	80091c8 <USBPD_DPM_Init+0x10>
  CADQueueId = osMessageCreate(osMessageQ(queueCAD), NULL);
 8009254:	0020      	movs	r0, r4
 8009256:	0031      	movs	r1, r6
 8009258:	3014      	adds	r0, #20
 800925a:	f002 f8ce 	bl	800b3fa <osMessageCreate>
 800925e:	6068      	str	r0, [r5, #4]
  PEQueueId[0] = osMessageCreate(osMessageQ(queuePE), NULL);
 8009260:	0020      	movs	r0, r4
 8009262:	0031      	movs	r1, r6
 8009264:	301c      	adds	r0, #28
 8009266:	f002 f8c8 	bl	800b3fa <osMessageCreate>
  DPM_Thread_Table[USBPD_THREAD_PORT_0] = NULL;
 800926a:	60ae      	str	r6, [r5, #8]
  PEQueueId[0] = osMessageCreate(osMessageQ(queuePE), NULL);
 800926c:	6028      	str	r0, [r5, #0]
  osKernelStart();
 800926e:	f002 f899 	bl	800b3a4 <osKernelStart>
  return USBPD_OK;
 8009272:	e7aa      	b.n	80091ca <USBPD_DPM_Init+0x12>
 8009274:	30210001 	.word	0x30210001
 8009278:	20001b84 	.word	0x20001b84
 800927c:	0800c6f4 	.word	0x0800c6f4
 8009280:	0800c774 	.word	0x0800c774
 8009284:	2000034c 	.word	0x2000034c

08009288 <USBPD_DPM_TimerCounter>:
  if (USBPD_TRUE == DPM_Params[USBPD_PORT_0].DPM_Initialized)
 8009288:	4b0a      	ldr	r3, [pc, #40]	; (80092b4 <USBPD_DPM_TimerCounter+0x2c>)
{
 800928a:	b510      	push	{r4, lr}
  if (USBPD_TRUE == DPM_Params[USBPD_PORT_0].DPM_Initialized)
 800928c:	785b      	ldrb	r3, [r3, #1]
 800928e:	075b      	lsls	r3, r3, #29
 8009290:	d508      	bpl.n	80092a4 <USBPD_DPM_TimerCounter+0x1c>
    USBPD_DPM_UserTimerCounter(USBPD_PORT_0);
 8009292:	2000      	movs	r0, #0
 8009294:	f7fc ff44 	bl	8006120 <USBPD_DPM_UserTimerCounter>
    USBPD_PE_TimerCounter(USBPD_PORT_0);
 8009298:	2000      	movs	r0, #0
 800929a:	f7f7 f88f 	bl	80003bc <USBPD_PE_TimerCounter>
    USBPD_PRL_TimerCounter(USBPD_PORT_0);
 800929e:	2000      	movs	r0, #0
 80092a0:	f7fb fdbc 	bl	8004e1c <USBPD_PRL_TimerCounter>
  if (uxTaskGetNumberOfTasks() != 0)
 80092a4:	f002 fd14 	bl	800bcd0 <uxTaskGetNumberOfTasks>
 80092a8:	2800      	cmp	r0, #0
 80092aa:	d001      	beq.n	80092b0 <USBPD_DPM_TimerCounter+0x28>
    osSystickHandler();
 80092ac:	f002 f90c 	bl	800b4c8 <osSystickHandler>
}
 80092b0:	bd10      	pop	{r4, pc}
 80092b2:	46c0      	nop			; (mov r8, r8)
 80092b4:	20001b84 	.word	0x20001b84

080092b8 <CAD_Init>:
void CAD_Init(uint8_t PortNum, USBPD_SettingsTypeDef *Settings, USBPD_ParamsTypeDef *Params,  void (*WakeUp)(void))
{
  CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
  
  /* store the settings and parameters */
  _handle->params = Params;
 80092b8:	2318      	movs	r3, #24
 80092ba:	4343      	muls	r3, r0
{
 80092bc:	b570      	push	{r4, r5, r6, lr}
  _handle->params = Params;
 80092be:	4d0e      	ldr	r5, [pc, #56]	; (80092f8 <CAD_Init+0x40>)
{
 80092c0:	0004      	movs	r4, r0
  _handle->settings = Settings;
 80092c2:	5159      	str	r1, [r3, r5]
  _handle->params = Params;
 80092c4:	18e8      	adds	r0, r5, r3
  _handle->state = USBPD_CAD_STATE_RESET;
  _handle->cc = CCNONE;
 80092c6:	25c0      	movs	r5, #192	; 0xc0
  _handle->state = USBPD_CAD_STATE_RESET;
 80092c8:	7c01      	ldrb	r1, [r0, #16]
  _handle->params = Params;
 80092ca:	6042      	str	r2, [r0, #4]
  _handle->cc = CCNONE;
 80092cc:	4029      	ands	r1, r5
 80092ce:	7401      	strb	r1, [r0, #16]
  _handle->CurrentHWcondition = _handle->OldHWCondtion = HW_Detachment;
 80092d0:	490a      	ldr	r1, [pc, #40]	; (80092fc <CAD_Init+0x44>)
  _handle->SNK_Source_Current_Adv = vRd_Undefined;
  
  if(_handle->params->PE_PowerRole == USBPD_PORTPOWERROLE_SRC)
  {
    USBPDM1_DeAssertRd(PortNum);
 80092d2:	0020      	movs	r0, r4
  _handle->CurrentHWcondition = _handle->OldHWCondtion = HW_Detachment;
 80092d4:	185b      	adds	r3, r3, r1
 80092d6:	2100      	movs	r1, #0
 80092d8:	7059      	strb	r1, [r3, #1]
  if(_handle->params->PE_PowerRole == USBPD_PORTPOWERROLE_SRC)
 80092da:	7813      	ldrb	r3, [r2, #0]
 80092dc:	075b      	lsls	r3, r3, #29
 80092de:	d505      	bpl.n	80092ec <CAD_Init+0x34>
    USBPDM1_DeAssertRd(PortNum);
 80092e0:	f001 f851 	bl	800a386 <USBPDM1_DeAssertRd>
    USBPDM1_AssertRp(PortNum);
 80092e4:	0020      	movs	r0, r4
 80092e6:	f001 f84b 	bl	800a380 <USBPDM1_AssertRp>
  else
  {
    USBPDM1_DeAssertRp(PortNum);
    USBPDM1_AssertRd(PortNum);
  }
}
 80092ea:	bd70      	pop	{r4, r5, r6, pc}
    USBPDM1_DeAssertRp(PortNum);
 80092ec:	f001 f849 	bl	800a382 <USBPDM1_DeAssertRp>
    USBPDM1_AssertRd(PortNum);
 80092f0:	0020      	movs	r0, r4
 80092f2:	f001 f847 	bl	800a384 <USBPDM1_AssertRd>
}
 80092f6:	e7f8      	b.n	80092ea <CAD_Init+0x32>
 80092f8:	20001b8c 	.word	0x20001b8c
 80092fc:	20001b9c 	.word	0x20001b9c

08009300 <CAD_Enter_ErrorRecovery>:
  * @brief  CAD enters in error recovery mode 
  * @param  PortNum  Number of the port
  * @retval None
  */ 
void CAD_Enter_ErrorRecovery(uint8_t PortNum)
{
 8009300:	b510      	push	{r4, lr}
  /* remove resistor terminaison 
     switch CAD_StateMachine to Error Recovery state
     wakeup CAD task */
  USBPD_HW_IF_ErrorRecovery(PortNum);
 8009302:	f001 f8c7 	bl	800a494 <USBPD_HW_IF_ErrorRecovery>
}
 8009306:	bd10      	pop	{r4, pc}

08009308 <USBPD_HW_IF_EXTI_Callback>:
  * @arg     ALERT_GPIO_PIN(1)    ** Defined in usbpd_porthandle.h **
  * @arg     SPI_NSS_PIN(1)       ** Defined in usbpd_porthandle.h **
  * @retval None
  */
void USBPD_HW_IF_EXTI_Callback(uint16_t GPIO_Pin)
{
 8009308:	b570      	push	{r4, r5, r6, lr}
 800930a:	0001      	movs	r1, r0
  uint8_t PortNum=0;
  GPIO_PinState NSSCurrentState;
  switch (GPIO_Pin)
 800930c:	2802      	cmp	r0, #2
 800930e:	d005      	beq.n	800931c <USBPD_HW_IF_EXTI_Callback+0x14>
 8009310:	2380      	movs	r3, #128	; 0x80
 8009312:	015b      	lsls	r3, r3, #5
 8009314:	4298      	cmp	r0, r3
 8009316:	d005      	beq.n	8009324 <USBPD_HW_IF_EXTI_Callback+0x1c>
 8009318:	46c0      	nop			; (mov r8, r8)
    
  default:
    __NOP();
    break;
  }
}
 800931a:	e002      	b.n	8009322 <USBPD_HW_IF_EXTI_Callback+0x1a>
    STUSB16xx_HW_IF_Alert_Check(ALERT_PORT_INDEX(0));
 800931c:	2000      	movs	r0, #0
 800931e:	f001 fd75 	bl	800ae0c <STUSB16xx_HW_IF_Alert_Check>
}
 8009322:	bd70      	pop	{r4, r5, r6, pc}
    NSSCurrentState = HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum));
 8009324:	4809      	ldr	r0, [pc, #36]	; (800934c <USBPD_HW_IF_EXTI_Callback+0x44>)
 8009326:	f7fe fb81 	bl	8007a2c <HAL_GPIO_ReadPin>
 800932a:	4d09      	ldr	r5, [pc, #36]	; (8009350 <USBPD_HW_IF_EXTI_Callback+0x48>)
 800932c:	0004      	movs	r4, r0
    if( NSSCurrentState == GPIO_PIN_SET || RxNSSStatus[PortNum] == GPIO_PIN_RESET) 
 800932e:	2801      	cmp	r0, #1
 8009330:	d002      	beq.n	8009338 <USBPD_HW_IF_EXTI_Callback+0x30>
 8009332:	782b      	ldrb	r3, [r5, #0]
 8009334:	2b00      	cmp	r3, #0
 8009336:	d102      	bne.n	800933e <USBPD_HW_IF_EXTI_Callback+0x36>
      PHY_HW_IF_RX_Stop(PortNum);
 8009338:	2000      	movs	r0, #0
 800933a:	f000 fc0f 	bl	8009b5c <PHY_HW_IF_RX_Stop>
    if( NSSCurrentState == GPIO_PIN_RESET )
 800933e:	2c00      	cmp	r4, #0
 8009340:	d102      	bne.n	8009348 <USBPD_HW_IF_EXTI_Callback+0x40>
      PHY_HW_IF_RX_Start(PortNum);
 8009342:	0020      	movs	r0, r4
 8009344:	f000 fec8 	bl	800a0d8 <PHY_HW_IF_RX_Start>
    RxNSSStatus[PortNum] = NSSCurrentState;
 8009348:	702c      	strb	r4, [r5, #0]
    break;    
 800934a:	e7ea      	b.n	8009322 <USBPD_HW_IF_EXTI_Callback+0x1a>
 800934c:	48000400 	.word	0x48000400
 8009350:	20000034 	.word	0x20000034

08009354 <USBPD_DMA_PORT0_IRQHandler>:
/**
  * @brief   This function handles DMA interrupts on channels 4, 5, 6 and 7
  * @retval  None
  */
void USBPD_DMA_PORT0_IRQHandler(void)
{
 8009354:	b570      	push	{r4, r5, r6, lr}
  uint8_t *end;
  
  /* Handler DMA TX PORT 0  */
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmatx)) != RESET)
 8009356:	4d39      	ldr	r5, [pc, #228]	; (800943c <USBPD_DMA_PORT0_IRQHandler+0xe8>)
 8009358:	4c39      	ldr	r4, [pc, #228]	; (8009440 <USBPD_DMA_PORT0_IRQHandler+0xec>)
 800935a:	002b      	movs	r3, r5
 800935c:	33a4      	adds	r3, #164	; 0xa4
 800935e:	681a      	ldr	r2, [r3, #0]
 8009360:	4838      	ldr	r0, [pc, #224]	; (8009444 <USBPD_DMA_PORT0_IRQHandler+0xf0>)
 8009362:	6821      	ldr	r1, [r4, #0]
 8009364:	2302      	movs	r3, #2
 8009366:	4282      	cmp	r2, r0
 8009368:	d016      	beq.n	8009398 <USBPD_DMA_PORT0_IRQHandler+0x44>
 800936a:	4e37      	ldr	r6, [pc, #220]	; (8009448 <USBPD_DMA_PORT0_IRQHandler+0xf4>)
 800936c:	331e      	adds	r3, #30
 800936e:	42b2      	cmp	r2, r6
 8009370:	d012      	beq.n	8009398 <USBPD_DMA_PORT0_IRQHandler+0x44>
 8009372:	4b36      	ldr	r3, [pc, #216]	; (800944c <USBPD_DMA_PORT0_IRQHandler+0xf8>)
 8009374:	429a      	cmp	r2, r3
 8009376:	d01a      	beq.n	80093ae <USBPD_DMA_PORT0_IRQHandler+0x5a>
 8009378:	4b35      	ldr	r3, [pc, #212]	; (8009450 <USBPD_DMA_PORT0_IRQHandler+0xfc>)
 800937a:	429a      	cmp	r2, r3
 800937c:	d01a      	beq.n	80093b4 <USBPD_DMA_PORT0_IRQHandler+0x60>
 800937e:	4b35      	ldr	r3, [pc, #212]	; (8009454 <USBPD_DMA_PORT0_IRQHandler+0x100>)
 8009380:	429a      	cmp	r2, r3
 8009382:	d01a      	beq.n	80093ba <USBPD_DMA_PORT0_IRQHandler+0x66>
 8009384:	4b34      	ldr	r3, [pc, #208]	; (8009458 <USBPD_DMA_PORT0_IRQHandler+0x104>)
 8009386:	18d2      	adds	r2, r2, r3
 8009388:	4253      	negs	r3, r2
 800938a:	4153      	adcs	r3, r2
 800938c:	4a33      	ldr	r2, [pc, #204]	; (800945c <USBPD_DMA_PORT0_IRQHandler+0x108>)
 800938e:	425b      	negs	r3, r3
 8009390:	4013      	ands	r3, r2
 8009392:	2280      	movs	r2, #128	; 0x80
 8009394:	0492      	lsls	r2, r2, #18
 8009396:	189b      	adds	r3, r3, r2
 8009398:	420b      	tst	r3, r1
 800939a:	d025      	beq.n	80093e8 <USBPD_DMA_PORT0_IRQHandler+0x94>
  {
    /* Transfer complete interrupt is used to end the transmission */
    if (Ports[0].State!=HAL_USBPD_PORT_STATE_BIST)
 800939c:	7e6b      	ldrb	r3, [r5, #25]
 800939e:	2b08      	cmp	r3, #8
 80093a0:	d00e      	beq.n	80093c0 <USBPD_DMA_PORT0_IRQHandler+0x6c>
    {
      PHY_HW_IF_TX_Done(0);
 80093a2:	2000      	movs	r0, #0
 80093a4:	f000 fd4e 	bl	8009e44 <PHY_HW_IF_TX_Done>
  else if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmarx)) != RESET)
  {
    __NOP();
  }
  
  __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 80093a8:	4b2d      	ldr	r3, [pc, #180]	; (8009460 <USBPD_DMA_PORT0_IRQHandler+0x10c>)
 80093aa:	6063      	str	r3, [r4, #4]
}
 80093ac:	bd70      	pop	{r4, r5, r6, pc}
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmatx)) != RESET)
 80093ae:	2380      	movs	r3, #128	; 0x80
 80093b0:	009b      	lsls	r3, r3, #2
 80093b2:	e7f1      	b.n	8009398 <USBPD_DMA_PORT0_IRQHandler+0x44>
 80093b4:	2380      	movs	r3, #128	; 0x80
 80093b6:	019b      	lsls	r3, r3, #6
 80093b8:	e7ee      	b.n	8009398 <USBPD_DMA_PORT0_IRQHandler+0x44>
 80093ba:	2380      	movs	r3, #128	; 0x80
 80093bc:	029b      	lsls	r3, r3, #10
 80093be:	e7eb      	b.n	8009398 <USBPD_DMA_PORT0_IRQHandler+0x44>
      Ports[0].BIST_index+=1;
 80093c0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80093c2:	3301      	adds	r3, #1
 80093c4:	626b      	str	r3, [r5, #36]	; 0x24
      if(Ports[0].BIST_index == BIST_MAX_LENGTH) 
 80093c6:	2b1e      	cmp	r3, #30
 80093c8:	d105      	bne.n	80093d6 <USBPD_DMA_PORT0_IRQHandler+0x82>
        end[(TX_BUFFER_LEN)*2 - 1] = 0;
 80093ca:	2000      	movs	r0, #0
 80093cc:	686b      	ldr	r3, [r5, #4]
 80093ce:	3337      	adds	r3, #55	; 0x37
 80093d0:	7018      	strb	r0, [r3, #0]
        STUSB16xx_HW_IF_Set_DMA_Normal_Mode(0); 
 80093d2:	f001 fc45 	bl	800ac60 <STUSB16xx_HW_IF_Set_DMA_Normal_Mode>
      if(Ports[0].BIST_index > BIST_MAX_LENGTH) 
 80093d6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80093d8:	2b1e      	cmp	r3, #30
 80093da:	d9e5      	bls.n	80093a8 <USBPD_DMA_PORT0_IRQHandler+0x54>
        PHY_HW_IF_TX_Done(0);
 80093dc:	2000      	movs	r0, #0
 80093de:	f000 fd31 	bl	8009e44 <PHY_HW_IF_TX_Done>
        Ports[0].BIST_index=0;
 80093e2:	2300      	movs	r3, #0
 80093e4:	626b      	str	r3, [r5, #36]	; 0x24
 80093e6:	e7df      	b.n	80093a8 <USBPD_DMA_PORT0_IRQHandler+0x54>
  else if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmarx)) != RESET)
 80093e8:	35e8      	adds	r5, #232	; 0xe8
 80093ea:	682a      	ldr	r2, [r5, #0]
 80093ec:	6821      	ldr	r1, [r4, #0]
 80093ee:	2302      	movs	r3, #2
 80093f0:	4282      	cmp	r2, r0
 80093f2:	d016      	beq.n	8009422 <USBPD_DMA_PORT0_IRQHandler+0xce>
 80093f4:	4814      	ldr	r0, [pc, #80]	; (8009448 <USBPD_DMA_PORT0_IRQHandler+0xf4>)
 80093f6:	331e      	adds	r3, #30
 80093f8:	4282      	cmp	r2, r0
 80093fa:	d012      	beq.n	8009422 <USBPD_DMA_PORT0_IRQHandler+0xce>
 80093fc:	4b13      	ldr	r3, [pc, #76]	; (800944c <USBPD_DMA_PORT0_IRQHandler+0xf8>)
 80093fe:	429a      	cmp	r2, r3
 8009400:	d013      	beq.n	800942a <USBPD_DMA_PORT0_IRQHandler+0xd6>
 8009402:	4b13      	ldr	r3, [pc, #76]	; (8009450 <USBPD_DMA_PORT0_IRQHandler+0xfc>)
 8009404:	429a      	cmp	r2, r3
 8009406:	d013      	beq.n	8009430 <USBPD_DMA_PORT0_IRQHandler+0xdc>
 8009408:	4b12      	ldr	r3, [pc, #72]	; (8009454 <USBPD_DMA_PORT0_IRQHandler+0x100>)
 800940a:	429a      	cmp	r2, r3
 800940c:	d013      	beq.n	8009436 <USBPD_DMA_PORT0_IRQHandler+0xe2>
 800940e:	4b12      	ldr	r3, [pc, #72]	; (8009458 <USBPD_DMA_PORT0_IRQHandler+0x104>)
 8009410:	18d2      	adds	r2, r2, r3
 8009412:	4253      	negs	r3, r2
 8009414:	4153      	adcs	r3, r2
 8009416:	4a11      	ldr	r2, [pc, #68]	; (800945c <USBPD_DMA_PORT0_IRQHandler+0x108>)
 8009418:	425b      	negs	r3, r3
 800941a:	4013      	ands	r3, r2
 800941c:	2280      	movs	r2, #128	; 0x80
 800941e:	0492      	lsls	r2, r2, #18
 8009420:	189b      	adds	r3, r3, r2
 8009422:	420b      	tst	r3, r1
 8009424:	d0c0      	beq.n	80093a8 <USBPD_DMA_PORT0_IRQHandler+0x54>
 8009426:	46c0      	nop			; (mov r8, r8)
 8009428:	e7be      	b.n	80093a8 <USBPD_DMA_PORT0_IRQHandler+0x54>
 800942a:	2380      	movs	r3, #128	; 0x80
 800942c:	009b      	lsls	r3, r3, #2
 800942e:	e7f8      	b.n	8009422 <USBPD_DMA_PORT0_IRQHandler+0xce>
 8009430:	2380      	movs	r3, #128	; 0x80
 8009432:	019b      	lsls	r3, r3, #6
 8009434:	e7f5      	b.n	8009422 <USBPD_DMA_PORT0_IRQHandler+0xce>
 8009436:	2380      	movs	r3, #128	; 0x80
 8009438:	029b      	lsls	r3, r3, #10
 800943a:	e7f2      	b.n	8009422 <USBPD_DMA_PORT0_IRQHandler+0xce>
 800943c:	20000058 	.word	0x20000058
 8009440:	40020000 	.word	0x40020000
 8009444:	40020008 	.word	0x40020008
 8009448:	4002001c 	.word	0x4002001c
 800944c:	40020030 	.word	0x40020030
 8009450:	40020044 	.word	0x40020044
 8009454:	40020058 	.word	0x40020058
 8009458:	bffdff94 	.word	0xbffdff94
 800945c:	fe200000 	.word	0xfe200000
 8009460:	0fffffff 	.word	0x0fffffff

08009464 <USBPD_RX_PORT0_COUNTTIM_IRQHandler>:
  * @brief   This function handles interrupts of RX timer associated to port 0
  * @details This timer is used to trigger the data decoding procedure on port 0
  * @retval  None
  */
void USBPD_RX_PORT0_COUNTTIM_IRQHandler(void)
{
 8009464:	b570      	push	{r4, r5, r6, lr}
  * @retval None
  */
static inline void SINGLE_TIM_IRQHandler(TIM_HandleTypeDef *htim, uint32_t Flag, uint32_t Timit)
{
  /* Capture compare event */
  if(__HAL_TIM_GET_FLAG(htim, Flag) != RESET)
 8009466:	4c0b      	ldr	r4, [pc, #44]	; (8009494 <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x30>)
 8009468:	2202      	movs	r2, #2
 800946a:	0023      	movs	r3, r4
 800946c:	33fc      	adds	r3, #252	; 0xfc
 800946e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009470:	6919      	ldr	r1, [r3, #16]
 8009472:	4211      	tst	r1, r2
 8009474:	d00d      	beq.n	8009492 <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x2e>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, Timit) != RESET)
 8009476:	68d9      	ldr	r1, [r3, #12]
 8009478:	4211      	tst	r1, r2
 800947a:	d00a      	beq.n	8009492 <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x2e>
    {
        __HAL_TIM_CLEAR_IT(htim, Timit);
 800947c:	3a05      	subs	r2, #5
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800947e:	25ca      	movs	r5, #202	; 0xca
        __HAL_TIM_CLEAR_IT(htim, Timit);
 8009480:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8009482:	2301      	movs	r3, #1
 8009484:	006d      	lsls	r5, r5, #1
 8009486:	5563      	strb	r3, [r4, r5]
        /* Output compare event */
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8009488:	4803      	ldr	r0, [pc, #12]	; (8009498 <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x34>)
 800948a:	f000 fc0b 	bl	8009ca4 <HAL_TIM_OC_DelayElapsedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800948e:	2300      	movs	r3, #0
 8009490:	5563      	strb	r3, [r4, r5]
}
 8009492:	bd70      	pop	{r4, r5, r6, pc}
 8009494:	20000058 	.word	0x20000058
 8009498:	200001d0 	.word	0x200001d0

0800949c <PHY_BistCompleted>:
 * @param  bistmode  Modality of the BIST
 * @retval none.
 */
void PHY_BistCompleted(uint8_t PortNum, USBPD_BISTMsg_TypeDef bistmode)
{
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_BistCompleted)
 800949c:	237c      	movs	r3, #124	; 0x7c
 800949e:	4343      	muls	r3, r0
 80094a0:	4a03      	ldr	r2, [pc, #12]	; (80094b0 <PHY_BistCompleted+0x14>)
{
 80094a2:	b510      	push	{r4, lr}
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_BistCompleted)
 80094a4:	589b      	ldr	r3, [r3, r2]
 80094a6:	691b      	ldr	r3, [r3, #16]
 80094a8:	2b00      	cmp	r3, #0
 80094aa:	d000      	beq.n	80094ae <PHY_BistCompleted+0x12>
  {
    PHY_Ports[PortNum].cbs->USBPD_PHY_BistCompleted(PortNum,bistmode);
 80094ac:	4798      	blx	r3
  }
}
 80094ae:	bd10      	pop	{r4, pc}
 80094b0:	2000035c 	.word	0x2000035c

080094b4 <PHY_TxCompleted>:
 * @param  PortNum  Number of the port.
 * @retval none.
 */
void PHY_TxCompleted(uint8_t PortNum)
{
  PHY_Ports[PortNum].State = PHY_StateNone;
 80094b4:	237c      	movs	r3, #124	; 0x7c
{
 80094b6:	b510      	push	{r4, lr}
  PHY_Ports[PortNum].State = PHY_StateNone;
 80094b8:	2400      	movs	r4, #0
 80094ba:	4343      	muls	r3, r0
 80094bc:	4a04      	ldr	r2, [pc, #16]	; (80094d0 <PHY_TxCompleted+0x1c>)
 80094be:	18d1      	adds	r1, r2, r3
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_TxCompleted)
 80094c0:	589b      	ldr	r3, [r3, r2]
  PHY_Ports[PortNum].State = PHY_StateNone;
 80094c2:	720c      	strb	r4, [r1, #8]
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_TxCompleted)
 80094c4:	695b      	ldr	r3, [r3, #20]
 80094c6:	42a3      	cmp	r3, r4
 80094c8:	d000      	beq.n	80094cc <PHY_TxCompleted+0x18>
  {
    PHY_Ports[PortNum].cbs->USBPD_PHY_TxCompleted(PortNum);
 80094ca:	4798      	blx	r3
  }
}
 80094cc:	bd10      	pop	{r4, pc}
 80094ce:	46c0      	nop			; (mov r8, r8)
 80094d0:	2000035c 	.word	0x2000035c

080094d4 <PHY_Rx_Reset>:
{
  /* Get the pointer to the decoding structure */
  PHY_RxDecodingTypeDef *pRxData = (PHY_RxDecodingTypeDef *)&PHY_Ports[PortNum].RxDec;

  /* reset the status of the RX process */
  pRxData->Status = USBPD_PHY_RX_STATUS_NONE;
 80094d4:	237c      	movs	r3, #124	; 0x7c
 80094d6:	4358      	muls	r0, r3
 80094d8:	4a0a      	ldr	r2, [pc, #40]	; (8009504 <PHY_Rx_Reset+0x30>)
{
 80094da:	b570      	push	{r4, r5, r6, lr}
  pRxData->Status = USBPD_PHY_RX_STATUS_NONE;
 80094dc:	1814      	adds	r4, r2, r0
 80094de:	0026      	movs	r6, r4
 80094e0:	2500      	movs	r5, #0
 80094e2:	3640      	adds	r6, #64	; 0x40

  /* reset the variable of count and memory */
  pRxData->DataCount = 0;
  memset(pRxData->Data, 0, __RX_DATA_LEN);
 80094e4:	3049      	adds	r0, #73	; 0x49
  pRxData->Status = USBPD_PHY_RX_STATUS_NONE;
 80094e6:	7035      	strb	r5, [r6, #0]
  pRxData->DataCount = 0;
 80094e8:	6765      	str	r5, [r4, #116]	; 0x74
  memset(pRxData->Data, 0, __RX_DATA_LEN);
 80094ea:	0029      	movs	r1, r5
 80094ec:	1810      	adds	r0, r2, r0
 80094ee:	2228      	movs	r2, #40	; 0x28
 80094f0:	f003 f84d 	bl	800c58e <memset>

  /* reset the type of SOP */
  pRxData->MsgType = USBPD_SOPTYPE_INVALID;
 80094f4:	0023      	movs	r3, r4
 80094f6:	22ff      	movs	r2, #255	; 0xff
 80094f8:	3348      	adds	r3, #72	; 0x48

  /* reset the type of OrderSet received */
  pRxData->OrderSet = 0x00;
 80094fa:	6465      	str	r5, [r4, #68]	; 0x44
  pRxData->MsgType = USBPD_SOPTYPE_INVALID;
 80094fc:	701a      	strb	r2, [r3, #0]

  return pRxData->Status;
 80094fe:	7830      	ldrb	r0, [r6, #0]
}
 8009500:	bd70      	pop	{r4, r5, r6, pc}
 8009502:	46c0      	nop			; (mov r8, r8)
 8009504:	2000035c 	.word	0x2000035c

08009508 <PHY_Rx_Completed>:
  * @brief  Callback to notify the end of the current reception
  * @param  PortNum  Number of the port
  * @retval Status of current reception
  */
USBPD_PHY_RX_Status_TypeDef PHY_Rx_Completed(uint8_t PortNum)
{
 8009508:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t crc_read,crc_calc;
  PHY_RxDecodingTypeDef * pRxData = (PHY_RxDecodingTypeDef *)&PHY_Ports[PortNum].RxDec;
  if (pRxData->Status != USBPD_PHY_RX_STATUS_MESSAGE_READY)
 800950a:	257c      	movs	r5, #124	; 0x7c
 800950c:	4345      	muls	r5, r0
 800950e:	4e2b      	ldr	r6, [pc, #172]	; (80095bc <PHY_Rx_Completed+0xb4>)
{
 8009510:	0007      	movs	r7, r0
  if (pRxData->Status != USBPD_PHY_RX_STATUS_MESSAGE_READY)
 8009512:	1974      	adds	r4, r6, r5
 8009514:	0023      	movs	r3, r4
 8009516:	3340      	adds	r3, #64	; 0x40
 8009518:	7818      	ldrb	r0, [r3, #0]
{
 800951a:	b085      	sub	sp, #20
  if (pRxData->Status != USBPD_PHY_RX_STATUS_MESSAGE_READY)
 800951c:	9301      	str	r3, [sp, #4]
 800951e:	2804      	cmp	r0, #4
 8009520:	d111      	bne.n	8009546 <PHY_Rx_Completed+0x3e>
  {
    return pRxData->Status;
  }

  if (pRxData->MsgType == USBPD_SOPTYPE_HARD_RESET || pRxData->MsgType == USBPD_SOPTYPE_CABLE_RESET)
 8009522:	3308      	adds	r3, #8
 8009524:	7819      	ldrb	r1, [r3, #0]
 8009526:	9302      	str	r3, [sp, #8]
 8009528:	1f4b      	subs	r3, r1, #5
 800952a:	2b01      	cmp	r3, #1
 800952c:	d80d      	bhi.n	800954a <PHY_Rx_Completed+0x42>
  {
    /* received a hard reset, call the callback, no other checks */
    if (PHY_Ports[PortNum].cbs->USBPD_PHY_ResetIndication != NULL)
 800952e:	59ab      	ldr	r3, [r5, r6]
 8009530:	685b      	ldr	r3, [r3, #4]
 8009532:	2b00      	cmp	r3, #0
 8009534:	d001      	beq.n	800953a <PHY_Rx_Completed+0x32>
    {
      PHY_Ports[PortNum].cbs->USBPD_PHY_ResetIndication(PortNum, pRxData->MsgType);
 8009536:	0038      	movs	r0, r7
 8009538:	4798      	blx	r3
    }
    return pRxData->Status = USBPD_PHY_RX_STATUS_OK;
 800953a:	237c      	movs	r3, #124	; 0x7c
 800953c:	2001      	movs	r0, #1
 800953e:	435f      	muls	r7, r3
 8009540:	19f6      	adds	r6, r6, r7
 8009542:	3640      	adds	r6, #64	; 0x40
 8009544:	7030      	strb	r0, [r6, #0]
  {
    PHY_Ports[PortNum].cbs->USBPD_PHY_MessageReceived(PortNum, pRxData->MsgType);
  }

  return pRxData->Status = USBPD_PHY_RX_STATUS_OK;
}
 8009546:	b005      	add	sp, #20
 8009548:	bdf0      	pop	{r4, r5, r6, r7, pc}
  uint8_t *pRxBuffer = PHY_Ports[PortNum].pRxBuffer;
 800954a:	6863      	ldr	r3, [r4, #4]
 800954c:	9303      	str	r3, [sp, #12]
  crc_calc = USBPD_HW_IF_CRC_Calculate(pRxData->Data, pRxData->DataCount - 4);
 800954e:	002b      	movs	r3, r5
 8009550:	3349      	adds	r3, #73	; 0x49
 8009552:	18f3      	adds	r3, r6, r3
 8009554:	9300      	str	r3, [sp, #0]
 8009556:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8009558:	9800      	ldr	r0, [sp, #0]
 800955a:	1f19      	subs	r1, r3, #4
 800955c:	b2c9      	uxtb	r1, r1
 800955e:	f000 fa3d 	bl	80099dc <USBPD_HW_IF_CRC_Calculate>
 8009562:	4684      	mov	ip, r0
  uint8_t *pCrcField = &pRxData->Data[pRxData->DataCount - 4];
 8009564:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8009566:	1f1a      	subs	r2, r3, #4
 8009568:	1951      	adds	r1, r2, r5
 800956a:	3149      	adds	r1, #73	; 0x49
 800956c:	1871      	adds	r1, r6, r1
  crc_read = *pCrcField;
 800956e:	18a4      	adds	r4, r4, r2
  crc_read |= ((*pCrcField) << 8);
 8009570:	784b      	ldrb	r3, [r1, #1]
  crc_read |= ((*pCrcField) << 16);
 8009572:	7888      	ldrb	r0, [r1, #2]
  crc_read = *pCrcField;
 8009574:	3449      	adds	r4, #73	; 0x49
 8009576:	7824      	ldrb	r4, [r4, #0]
  crc_read |= ((*pCrcField) << 8);
 8009578:	021b      	lsls	r3, r3, #8
  crc_read |= ((*pCrcField) << 16);
 800957a:	0400      	lsls	r0, r0, #16
 800957c:	4303      	orrs	r3, r0
 800957e:	4323      	orrs	r3, r4
  crc_read |= ((*pCrcField) << 24);
 8009580:	78cc      	ldrb	r4, [r1, #3]
 8009582:	0624      	lsls	r4, r4, #24
 8009584:	431c      	orrs	r4, r3
  if (crc_read != crc_calc)
 8009586:	45a4      	cmp	ip, r4
 8009588:	d003      	beq.n	8009592 <PHY_Rx_Completed+0x8a>
    return pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_CRC_FAILED;
 800958a:	200a      	movs	r0, #10
 800958c:	9b01      	ldr	r3, [sp, #4]
 800958e:	7018      	strb	r0, [r3, #0]
 8009590:	e7d9      	b.n	8009546 <PHY_Rx_Completed+0x3e>
  memcpy(pRxBuffer, pRxData->Data, pRxData->DataCount - 4);
 8009592:	9900      	ldr	r1, [sp, #0]
 8009594:	9803      	ldr	r0, [sp, #12]
 8009596:	f002 fff1 	bl	800c57c <memcpy>
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_MessageReceived != NULL)
 800959a:	59ab      	ldr	r3, [r5, r6]
 800959c:	681b      	ldr	r3, [r3, #0]
 800959e:	2b00      	cmp	r3, #0
 80095a0:	d003      	beq.n	80095aa <PHY_Rx_Completed+0xa2>
    PHY_Ports[PortNum].cbs->USBPD_PHY_MessageReceived(PortNum, pRxData->MsgType);
 80095a2:	9a02      	ldr	r2, [sp, #8]
 80095a4:	0038      	movs	r0, r7
 80095a6:	7811      	ldrb	r1, [r2, #0]
 80095a8:	4798      	blx	r3
  return pRxData->Status = USBPD_PHY_RX_STATUS_OK;
 80095aa:	267c      	movs	r6, #124	; 0x7c
 80095ac:	2001      	movs	r0, #1
 80095ae:	437e      	muls	r6, r7
 80095b0:	4f02      	ldr	r7, [pc, #8]	; (80095bc <PHY_Rx_Completed+0xb4>)
 80095b2:	19bf      	adds	r7, r7, r6
 80095b4:	3740      	adds	r7, #64	; 0x40
 80095b6:	7038      	strb	r0, [r7, #0]
 80095b8:	e7c5      	b.n	8009546 <PHY_Rx_Completed+0x3e>
 80095ba:	46c0      	nop			; (mov r8, r8)
 80095bc:	2000035c 	.word	0x2000035c

080095c0 <PHY_Encode5b_Short>:
{
 80095c0:	b510      	push	{r4, lr}
  return coding4b5b[val & 0x0F] | (coding4b5b[(val >> 4) & 0x0F] << 5);
 80095c2:	240f      	movs	r4, #15
 80095c4:	4908      	ldr	r1, [pc, #32]	; (80095e8 <PHY_Encode5b_Short+0x28>)
  return PHY_Encode5b_Byte(val & 0x00FF) | (PHY_Encode5b_Byte((val >> 8) & 0x00FF) << 10);
 80095c6:	b2c2      	uxtb	r2, r0
 80095c8:	0a00      	lsrs	r0, r0, #8
  return coding4b5b[val & 0x0F] | (coding4b5b[(val >> 4) & 0x0F] << 5);
 80095ca:	0903      	lsrs	r3, r0, #4
 80095cc:	5ccb      	ldrb	r3, [r1, r3]
 80095ce:	4020      	ands	r0, r4
 80095d0:	5c08      	ldrb	r0, [r1, r0]
 80095d2:	015b      	lsls	r3, r3, #5
 80095d4:	4303      	orrs	r3, r0
 80095d6:	0910      	lsrs	r0, r2, #4
 80095d8:	5c08      	ldrb	r0, [r1, r0]
 80095da:	4022      	ands	r2, r4
 80095dc:	5c8a      	ldrb	r2, [r1, r2]
 80095de:	0140      	lsls	r0, r0, #5
  return PHY_Encode5b_Byte(val & 0x00FF) | (PHY_Encode5b_Byte((val >> 8) & 0x00FF) << 10);
 80095e0:	029b      	lsls	r3, r3, #10
  return coding4b5b[val & 0x0F] | (coding4b5b[(val >> 4) & 0x0F] << 5);
 80095e2:	4310      	orrs	r0, r2
  return PHY_Encode5b_Byte(val & 0x00FF) | (PHY_Encode5b_Byte((val >> 8) & 0x00FF) << 10);
 80095e4:	4318      	orrs	r0, r3
}
 80095e6:	bd10      	pop	{r4, pc}
 80095e8:	0800c7d0 	.word	0x0800c7d0

080095ec <USBPD_PHY_GetRetryTimerValue>:
  return 920u;
 80095ec:	20e6      	movs	r0, #230	; 0xe6
}
 80095ee:	0080      	lsls	r0, r0, #2
 80095f0:	4770      	bx	lr
	...

080095f4 <USBPD_PHY_Send_BIST_Pattern>:
  PHY_Ports[PortNum].State = PHY_StateBusyBIST_Tx;
 80095f4:	237c      	movs	r3, #124	; 0x7c
 80095f6:	4343      	muls	r3, r0
{
 80095f8:	b510      	push	{r4, lr}
  PHY_Ports[PortNum].State = PHY_StateBusyBIST_Tx;
 80095fa:	4c04      	ldr	r4, [pc, #16]	; (800960c <USBPD_PHY_Send_BIST_Pattern+0x18>)
 80095fc:	18e4      	adds	r4, r4, r3
 80095fe:	2305      	movs	r3, #5
 8009600:	7223      	strb	r3, [r4, #8]
  USBPD_HW_IF_Send_BIST_Pattern(PortNum);
 8009602:	f000 fa2b 	bl	8009a5c <USBPD_HW_IF_Send_BIST_Pattern>
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009606:	2000      	movs	r0, #0
 8009608:	7220      	strb	r0, [r4, #8]
}
 800960a:	bd10      	pop	{r4, pc}
 800960c:	2000035c 	.word	0x2000035c

08009610 <USBPD_PHY_ExitTransmit>:
}
 8009610:	2000      	movs	r0, #0
 8009612:	4770      	bx	lr

08009614 <USBPD_PHY_SetResistor_SinkTxNG>:
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_1_5_A);
 8009614:	1e43      	subs	r3, r0, #1
 8009616:	4198      	sbcs	r0, r3
{
 8009618:	b510      	push	{r4, lr}
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_1_5_A);
 800961a:	3028      	adds	r0, #40	; 0x28
 800961c:	2101      	movs	r1, #1
 800961e:	f7fd f9fd 	bl	8006a1c <STUSB1602_Current_Advertised_Set>
}
 8009622:	bd10      	pop	{r4, pc}

08009624 <USBPD_PHY_SetResistor_SinkTxOK>:
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 8009624:	1e43      	subs	r3, r0, #1
 8009626:	4198      	sbcs	r0, r3
{
 8009628:	b510      	push	{r4, lr}
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 800962a:	3028      	adds	r0, #40	; 0x28
 800962c:	2102      	movs	r1, #2
 800962e:	f7fd f9f5 	bl	8006a1c <STUSB1602_Current_Advertised_Set>
}
 8009632:	bd10      	pop	{r4, pc}

08009634 <USBPD_PHY_SOPSupported>:
}
 8009634:	4770      	bx	lr

08009636 <USBPD_PHY_IsResistor_SinkTxOk>:
{
 8009636:	b510      	push	{r4, lr}
  return USBPD_16xx_IsResistor_SinkTxOk(PortNum);
 8009638:	f001 fdf6 	bl	800b228 <USBPD_16xx_IsResistor_SinkTxOk>
}
 800963c:	bd10      	pop	{r4, pc}

0800963e <USBPD_PHY_FastRoleSwapSignalling>:
 800963e:	4770      	bx	lr

08009640 <PHY_TxBuffer_Reset>:
{
 8009640:	b570      	push	{r4, r5, r6, lr}
  memset((void *)PHY_Ports[PortNum].TxBuffer, 0, __TX_BUFF_SIZE);
 8009642:	257c      	movs	r5, #124	; 0x7c
 8009644:	4345      	muls	r5, r0
 8009646:	0028      	movs	r0, r5
 8009648:	4c05      	ldr	r4, [pc, #20]	; (8009660 <PHY_TxBuffer_Reset+0x20>)
 800964a:	300c      	adds	r0, #12
 800964c:	1820      	adds	r0, r4, r0
 800964e:	2230      	movs	r2, #48	; 0x30
 8009650:	2100      	movs	r1, #0
 8009652:	f002 ff9c 	bl	800c58e <memset>
  PHY_Ports[PortNum].TxDatabitLen = 0;
 8009656:	2300      	movs	r3, #0
 8009658:	1964      	adds	r4, r4, r5
 800965a:	63e3      	str	r3, [r4, #60]	; 0x3c
}
 800965c:	bd70      	pop	{r4, r5, r6, pc}
 800965e:	46c0      	nop			; (mov r8, r8)
 8009660:	2000035c 	.word	0x2000035c

08009664 <USBPD_PHY_Reset>:
{
 8009664:	b510      	push	{r4, lr}
  PHY_TxBuffer_Reset(PortNum);
 8009666:	f7ff ffeb 	bl	8009640 <PHY_TxBuffer_Reset>
}
 800966a:	bd10      	pop	{r4, pc}

0800966c <USBPD_PHY_Init>:
{
 800966c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800966e:	0016      	movs	r6, r2
  hwif_cbs.USBPD_HW_IF_RX_Reset       = PHY_Rx_Reset;
 8009670:	4a11      	ldr	r2, [pc, #68]	; (80096b8 <USBPD_PHY_Init+0x4c>)
{
 8009672:	b08b      	sub	sp, #44	; 0x2c
  hwif_cbs.USBPD_HW_IF_RX_Reset       = PHY_Rx_Reset;
 8009674:	9207      	str	r2, [sp, #28]
  hwif_cbs.USBPD_HW_IF_RX_Accumulate  = PHY_Rx_Accumulate;
 8009676:	4a11      	ldr	r2, [pc, #68]	; (80096bc <USBPD_PHY_Init+0x50>)
{
 8009678:	0004      	movs	r4, r0
  hwif_cbs.USBPD_HW_IF_RX_Accumulate  = PHY_Rx_Accumulate;
 800967a:	9208      	str	r2, [sp, #32]
  hwif_cbs.USBPD_HW_IF_RX_Completed   = PHY_Rx_Completed;
 800967c:	4a10      	ldr	r2, [pc, #64]	; (80096c0 <USBPD_PHY_Init+0x54>)
  USBPD_HW_IF_PortHwInit(PortNum, hwif_cbs, PowerRole);
 800967e:	9303      	str	r3, [sp, #12]
  hwif_cbs.USBPD_HW_IF_RX_Completed   = PHY_Rx_Completed;
 8009680:	9209      	str	r2, [sp, #36]	; 0x24
  USBPD_HW_IF_PortHwInit(PortNum, hwif_cbs, PowerRole);
 8009682:	466a      	mov	r2, sp
 8009684:	ab07      	add	r3, sp, #28
{
 8009686:	000d      	movs	r5, r1
  USBPD_HW_IF_PortHwInit(PortNum, hwif_cbs, PowerRole);
 8009688:	cb83      	ldmia	r3!, {r0, r1, r7}
 800968a:	c283      	stmia	r2!, {r0, r1, r7}
 800968c:	4a0d      	ldr	r2, [pc, #52]	; (80096c4 <USBPD_PHY_Init+0x58>)
 800968e:	9904      	ldr	r1, [sp, #16]
 8009690:	4b0d      	ldr	r3, [pc, #52]	; (80096c8 <USBPD_PHY_Init+0x5c>)
 8009692:	0020      	movs	r0, r4
 8009694:	f001 fb4e 	bl	800ad34 <USBPD_HW_IF_PortHwInit>
  PHY_Ports[PortNum].pRxBuffer    = pRxBuffer;
 8009698:	237c      	movs	r3, #124	; 0x7c
 800969a:	4363      	muls	r3, r4
 800969c:	4a0b      	ldr	r2, [pc, #44]	; (80096cc <USBPD_PHY_Init+0x60>)
  PHY_Ports[PortNum].SupportedSOP = SupportedSOP;
 800969e:	9910      	ldr	r1, [sp, #64]	; 0x40
  PHY_Ports[PortNum].pRxBuffer    = pRxBuffer;
 80096a0:	18d7      	adds	r7, r2, r3
  PHY_TxBuffer_Reset(PortNum);
 80096a2:	0020      	movs	r0, r4
  PHY_Ports[PortNum].pRxBuffer    = pRxBuffer;
 80096a4:	607e      	str	r6, [r7, #4]
  PHY_Ports[PortNum].SupportedSOP = SupportedSOP;
 80096a6:	67b9      	str	r1, [r7, #120]	; 0x78
  PHY_Ports[PortNum].cbs = pCallback;
 80096a8:	509d      	str	r5, [r3, r2]
  PHY_TxBuffer_Reset(PortNum);
 80096aa:	f7ff ffc9 	bl	8009640 <PHY_TxBuffer_Reset>
  PHY_Ports[PortNum].State = PHY_StateNone;
 80096ae:	2000      	movs	r0, #0
 80096b0:	7238      	strb	r0, [r7, #8]
}
 80096b2:	b00b      	add	sp, #44	; 0x2c
 80096b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80096b6:	46c0      	nop			; (mov r8, r8)
 80096b8:	080094d5 	.word	0x080094d5
 80096bc:	08009901 	.word	0x08009901
 80096c0:	08009509 	.word	0x08009509
 80096c4:	080094b5 	.word	0x080094b5
 80096c8:	0800949d 	.word	0x0800949d
 80096cc:	2000035c 	.word	0x2000035c

080096d0 <PHY_TxBuffer_Append>:
{
 80096d0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 80096d2:	247c      	movs	r4, #124	; 0x7c
  uint32_t map = __BITMASK(nbit);
 80096d4:	2601      	movs	r6, #1
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 80096d6:	4344      	muls	r4, r0
  uint32_t bit = *pOffset % __SIZEBIT;
 80096d8:	271f      	movs	r7, #31
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 80096da:	0023      	movs	r3, r4
  uint32_t map = __BITMASK(nbit);
 80096dc:	4096      	lsls	r6, r2
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 80096de:	4d16      	ldr	r5, [pc, #88]	; (8009738 <PHY_TxBuffer_Append+0x68>)
 80096e0:	330c      	adds	r3, #12
  uint32_t pos = *pOffset / __SIZEBIT;
 80096e2:	192c      	adds	r4, r5, r4
 80096e4:	6be4      	ldr	r4, [r4, #60]	; 0x3c
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 80096e6:	18eb      	adds	r3, r5, r3
  uint32_t bit = *pOffset % __SIZEBIT;
 80096e8:	4027      	ands	r7, r4
  uint32_t pos = *pOffset / __SIZEBIT;
 80096ea:	0964      	lsrs	r4, r4, #5
  uint32_t map = __BITMASK(nbit);
 80096ec:	3e01      	subs	r6, #1
  pBuffer[pos] |= (value << bit);
 80096ee:	00a4      	lsls	r4, r4, #2
  uint32_t value = val & map;
 80096f0:	4031      	ands	r1, r6
  pBuffer[pos] |= (value << bit);
 80096f2:	191e      	adds	r6, r3, r4
 80096f4:	46b4      	mov	ip, r6
 80096f6:	000e      	movs	r6, r1
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 80096f8:	9301      	str	r3, [sp, #4]
  pBuffer[pos] |= (value << bit);
 80096fa:	4663      	mov	r3, ip
 80096fc:	40be      	lsls	r6, r7
 80096fe:	681b      	ldr	r3, [r3, #0]
 8009700:	431e      	orrs	r6, r3
 8009702:	4663      	mov	r3, ip
 8009704:	601e      	str	r6, [r3, #0]
  if (bit > (__SIZEBIT - MIN(nbit, __SIZEBIT)))
 8009706:	1c16      	adds	r6, r2, #0
 8009708:	2a20      	cmp	r2, #32
 800970a:	d900      	bls.n	800970e <PHY_TxBuffer_Append+0x3e>
 800970c:	2620      	movs	r6, #32
 800970e:	b2f3      	uxtb	r3, r6
 8009710:	2620      	movs	r6, #32
 8009712:	1af3      	subs	r3, r6, r3
 8009714:	42bb      	cmp	r3, r7
 8009716:	d207      	bcs.n	8009728 <PHY_TxBuffer_Append+0x58>
    pBuffer[pos + 1] |= (value >> (__SIZEBIT - bit));
 8009718:	1bf7      	subs	r7, r6, r7
 800971a:	40f9      	lsrs	r1, r7
 800971c:	9b01      	ldr	r3, [sp, #4]
 800971e:	3404      	adds	r4, #4
 8009720:	191b      	adds	r3, r3, r4
 8009722:	681c      	ldr	r4, [r3, #0]
 8009724:	4321      	orrs	r1, r4
 8009726:	6019      	str	r1, [r3, #0]
  *pOffset += nbit;
 8009728:	237c      	movs	r3, #124	; 0x7c
 800972a:	4358      	muls	r0, r3
 800972c:	182d      	adds	r5, r5, r0
 800972e:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8009730:	189a      	adds	r2, r3, r2
 8009732:	63ea      	str	r2, [r5, #60]	; 0x3c
}
 8009734:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8009736:	46c0      	nop			; (mov r8, r8)
 8009738:	2000035c 	.word	0x2000035c

0800973c <PHY_PreparePacket>:
{
 800973c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint8_t resetRequired = Type == USBPD_SOPTYPE_HARD_RESET || Type == USBPD_SOPTYPE_CABLE_RESET;
 800973e:	1f4c      	subs	r4, r1, #5
 8009740:	b2e4      	uxtb	r4, r4
{
 8009742:	000f      	movs	r7, r1
 8009744:	0015      	movs	r5, r2
 8009746:	001e      	movs	r6, r3
  if (!resetRequired  && ((Size < 2) || (Size > 30) || (( (Size - 2) % __SIZE) != 0))) 
 8009748:	2c01      	cmp	r4, #1
 800974a:	d95f      	bls.n	800980c <PHY_PreparePacket+0xd0>
 800974c:	3b02      	subs	r3, #2
 800974e:	b2da      	uxtb	r2, r3
 8009750:	2a1c      	cmp	r2, #28
 8009752:	d801      	bhi.n	8009758 <PHY_PreparePacket+0x1c>
 8009754:	079b      	lsls	r3, r3, #30
 8009756:	d00e      	beq.n	8009776 <PHY_PreparePacket+0x3a>
  return FRAME_5B_BitSizeIsValid(*pOffset) ? USBPD_OK : USBPD_ERROR;
 8009758:	2002      	movs	r0, #2
 800975a:	e056      	b.n	800980a <PHY_PreparePacket+0xce>
      val16 = pBuffer[i] | (pBuffer[i + 1] << 8);
 800975c:	7863      	ldrb	r3, [r4, #1]
 800975e:	7820      	ldrb	r0, [r4, #0]
 8009760:	021b      	lsls	r3, r3, #8
      value = PHY_Encode5b_Short(val16);
 8009762:	4318      	orrs	r0, r3
 8009764:	f7ff ff2c 	bl	80095c0 <PHY_Encode5b_Short>
      PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 8009768:	2214      	movs	r2, #20
      value = PHY_Encode5b_Short(val16);
 800976a:	0001      	movs	r1, r0
      PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 800976c:	2000      	movs	r0, #0
 800976e:	f7ff ffaf 	bl	80096d0 <PHY_TxBuffer_Append>
 8009772:	3402      	adds	r4, #2
 8009774:	e016      	b.n	80097a4 <PHY_PreparePacket+0x68>
  if (!USBPD_PORT_IsValid(PortNum) || (!resetRequired && pBuffer == NULL))
 8009776:	2800      	cmp	r0, #0
 8009778:	d1ee      	bne.n	8009758 <PHY_PreparePacket+0x1c>
 800977a:	2d00      	cmp	r5, #0
 800977c:	d0ec      	beq.n	8009758 <PHY_PreparePacket+0x1c>
  PHY_TxBuffer_Reset(PortNum);
 800977e:	2000      	movs	r0, #0
 8009780:	f7ff ff5e 	bl	8009640 <PHY_TxBuffer_Reset>
  PHY_TxBuffer_Append(PortNum, OrderSets[(uint8_t)Type], OS_BITSIZE);
 8009784:	4b23      	ldr	r3, [pc, #140]	; (8009814 <PHY_PreparePacket+0xd8>)
 8009786:	00bf      	lsls	r7, r7, #2
 8009788:	19df      	adds	r7, r3, r7
 800978a:	2214      	movs	r2, #20
 800978c:	6939      	ldr	r1, [r7, #16]
 800978e:	2000      	movs	r0, #0
 8009790:	f7ff ff9e 	bl	80096d0 <PHY_TxBuffer_Append>
  if (!resetRequired)
 8009794:	2c01      	cmp	r4, #1
 8009796:	d91d      	bls.n	80097d4 <PHY_PreparePacket+0x98>
    crc_value = USBPD_HW_IF_CRC_Calculate(pBuffer, Size);
 8009798:	0031      	movs	r1, r6
 800979a:	0028      	movs	r0, r5
 800979c:	f000 f91e 	bl	80099dc <USBPD_HW_IF_CRC_Calculate>
    for (i = 0; i < Size; i += 2)
 80097a0:	002c      	movs	r4, r5
    crc_value = USBPD_HW_IF_CRC_Calculate(pBuffer, Size);
 80097a2:	0007      	movs	r7, r0
    for (i = 0; i < Size; i += 2)
 80097a4:	1b63      	subs	r3, r4, r5
 80097a6:	429e      	cmp	r6, r3
 80097a8:	d8d8      	bhi.n	800975c <PHY_PreparePacket+0x20>
    value = PHY_Encode5b_Short(crc_value & 0x0000FFFF);
 80097aa:	b2b8      	uxth	r0, r7
 80097ac:	f7ff ff08 	bl	80095c0 <PHY_Encode5b_Short>
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 80097b0:	2214      	movs	r2, #20
    value = PHY_Encode5b_Short(crc_value & 0x0000FFFF);
 80097b2:	0001      	movs	r1, r0
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 80097b4:	2000      	movs	r0, #0
 80097b6:	f7ff ff8b 	bl	80096d0 <PHY_TxBuffer_Append>
    value = PHY_Encode5b_Short((crc_value >> 16) & 0x0000FFFF);
 80097ba:	0c38      	lsrs	r0, r7, #16
 80097bc:	f7ff ff00 	bl	80095c0 <PHY_Encode5b_Short>
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 80097c0:	2214      	movs	r2, #20
    value = PHY_Encode5b_Short((crc_value >> 16) & 0x0000FFFF);
 80097c2:	0001      	movs	r1, r0
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 80097c4:	2000      	movs	r0, #0
 80097c6:	f7ff ff83 	bl	80096d0 <PHY_TxBuffer_Append>
    PHY_TxBuffer_Append(PortNum, KC_S_EOP, CODE_5B_ITEM1_BITSIZE);
 80097ca:	2205      	movs	r2, #5
 80097cc:	210d      	movs	r1, #13
 80097ce:	2000      	movs	r0, #0
 80097d0:	f7ff ff7e 	bl	80096d0 <PHY_TxBuffer_Append>
  return FRAME_5B_BitSizeIsValid(*pOffset) ? USBPD_OK : USBPD_ERROR;
 80097d4:	4b10      	ldr	r3, [pc, #64]	; (8009818 <PHY_PreparePacket+0xdc>)
 80097d6:	2000      	movs	r0, #0
 80097d8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80097da:	2b14      	cmp	r3, #20
 80097dc:	d015      	beq.n	800980a <PHY_PreparePacket+0xce>
 80097de:	2b55      	cmp	r3, #85	; 0x55
 80097e0:	d013      	beq.n	800980a <PHY_PreparePacket+0xce>
 80097e2:	2b7d      	cmp	r3, #125	; 0x7d
 80097e4:	d011      	beq.n	800980a <PHY_PreparePacket+0xce>
 80097e6:	2ba5      	cmp	r3, #165	; 0xa5
 80097e8:	d00f      	beq.n	800980a <PHY_PreparePacket+0xce>
 80097ea:	2bcd      	cmp	r3, #205	; 0xcd
 80097ec:	d00d      	beq.n	800980a <PHY_PreparePacket+0xce>
 80097ee:	2bf5      	cmp	r3, #245	; 0xf5
 80097f0:	d00b      	beq.n	800980a <PHY_PreparePacket+0xce>
 80097f2:	221e      	movs	r2, #30
 80097f4:	32ff      	adds	r2, #255	; 0xff
 80097f6:	4293      	cmp	r3, r2
 80097f8:	d007      	beq.n	800980a <PHY_PreparePacket+0xce>
 80097fa:	2246      	movs	r2, #70	; 0x46
 80097fc:	32ff      	adds	r2, #255	; 0xff
 80097fe:	4293      	cmp	r3, r2
 8009800:	d003      	beq.n	800980a <PHY_PreparePacket+0xce>
 8009802:	226e      	movs	r2, #110	; 0x6e
 8009804:	32ff      	adds	r2, #255	; 0xff
 8009806:	4293      	cmp	r3, r2
 8009808:	d1a6      	bne.n	8009758 <PHY_PreparePacket+0x1c>
}
 800980a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (!USBPD_PORT_IsValid(PortNum) || (!resetRequired && pBuffer == NULL))
 800980c:	2800      	cmp	r0, #0
 800980e:	d1a3      	bne.n	8009758 <PHY_PreparePacket+0x1c>
 8009810:	e7b5      	b.n	800977e <PHY_PreparePacket+0x42>
 8009812:	46c0      	nop			; (mov r8, r8)
 8009814:	0800c7d0 	.word	0x0800c7d0
 8009818:	2000035c 	.word	0x2000035c

0800981c <USBPD_PHY_SendMessage>:
{
 800981c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (PHY_Ports[PortNum].State != PHY_StateNone)
 800981e:	247c      	movs	r4, #124	; 0x7c
 8009820:	4344      	muls	r4, r0
{
 8009822:	0006      	movs	r6, r0
  if (PHY_Ports[PortNum].State != PHY_StateNone)
 8009824:	480c      	ldr	r0, [pc, #48]	; (8009858 <USBPD_PHY_SendMessage+0x3c>)
 8009826:	1905      	adds	r5, r0, r4
 8009828:	7a2f      	ldrb	r7, [r5, #8]
    return USBPD_BUSY;
 800982a:	2003      	movs	r0, #3
  if (PHY_Ports[PortNum].State != PHY_StateNone)
 800982c:	2f00      	cmp	r7, #0
 800982e:	d112      	bne.n	8009856 <USBPD_PHY_SendMessage+0x3a>
  res = PHY_PreparePacket(PortNum, Type, pBuffer, Size);
 8009830:	b2db      	uxtb	r3, r3
 8009832:	0030      	movs	r0, r6
 8009834:	f7ff ff82 	bl	800973c <PHY_PreparePacket>
 8009838:	0007      	movs	r7, r0
    return USBPD_ERROR;
 800983a:	2002      	movs	r0, #2
  if (res == USBPD_OK)
 800983c:	2f00      	cmp	r7, #0
 800983e:	d10a      	bne.n	8009856 <USBPD_PHY_SendMessage+0x3a>
    PHY_Ports[PortNum].State = PHY_StateBusyTxStart;
 8009840:	2303      	movs	r3, #3
    res = USBPD_HW_IF_SendBuffer(PortNum, (uint8_t *)PHY_Ports[PortNum].TxBuffer,  PHY_Ports[PortNum].TxDatabitLen);
 8009842:	0021      	movs	r1, r4
    PHY_Ports[PortNum].State = PHY_StateBusyTxStart;
 8009844:	722b      	strb	r3, [r5, #8]
    res = USBPD_HW_IF_SendBuffer(PortNum, (uint8_t *)PHY_Ports[PortNum].TxBuffer,  PHY_Ports[PortNum].TxDatabitLen);
 8009846:	4b04      	ldr	r3, [pc, #16]	; (8009858 <USBPD_PHY_SendMessage+0x3c>)
 8009848:	310c      	adds	r1, #12
 800984a:	1859      	adds	r1, r3, r1
 800984c:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 800984e:	0030      	movs	r0, r6
 8009850:	f000 f8ce 	bl	80099f0 <USBPD_HW_IF_SendBuffer>
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009854:	722f      	strb	r7, [r5, #8]
}
 8009856:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009858:	2000035c 	.word	0x2000035c

0800985c <USBPD_PHY_ResetRequest>:
  if (USBPD_PHY_SendMessage(PortNum, Type, NULL, 0) != USBPD_OK)
 800985c:	2300      	movs	r3, #0
{
 800985e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (USBPD_PHY_SendMessage(PortNum, Type, NULL, 0) != USBPD_OK)
 8009860:	001a      	movs	r2, r3
{
 8009862:	0004      	movs	r4, r0
 8009864:	9101      	str	r1, [sp, #4]
  if (USBPD_PHY_SendMessage(PortNum, Type, NULL, 0) != USBPD_OK)
 8009866:	f7ff ffd9 	bl	800981c <USBPD_PHY_SendMessage>
 800986a:	1e06      	subs	r6, r0, #0
 800986c:	d116      	bne.n	800989c <USBPD_PHY_ResetRequest+0x40>
  PHY_Ports[PortNum].State = PHY_StateBusy;
 800986e:	257c      	movs	r5, #124	; 0x7c
 8009870:	2202      	movs	r2, #2
 8009872:	4365      	muls	r5, r4
 8009874:	4f0a      	ldr	r7, [pc, #40]	; (80098a0 <USBPD_PHY_ResetRequest+0x44>)
  PHY_TxBuffer_Reset(PortNum);
 8009876:	0020      	movs	r0, r4
  PHY_Ports[PortNum].State = PHY_StateBusy;
 8009878:	197b      	adds	r3, r7, r5
 800987a:	721a      	strb	r2, [r3, #8]
  PHY_TxBuffer_Reset(PortNum);
 800987c:	f7ff fee0 	bl	8009640 <PHY_TxBuffer_Reset>
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_ResetCompleted != NULL)
 8009880:	59eb      	ldr	r3, [r5, r7]
 8009882:	689b      	ldr	r3, [r3, #8]
 8009884:	2b00      	cmp	r3, #0
 8009886:	d002      	beq.n	800988e <USBPD_PHY_ResetRequest+0x32>
    PHY_Ports[PortNum].cbs->USBPD_PHY_ResetCompleted(PortNum, Type);
 8009888:	9901      	ldr	r1, [sp, #4]
 800988a:	0020      	movs	r0, r4
 800988c:	4798      	blx	r3
  PHY_Ports[PortNum].State = PHY_StateNone;
 800988e:	237c      	movs	r3, #124	; 0x7c
 8009890:	435c      	muls	r4, r3
 8009892:	2300      	movs	r3, #0
 8009894:	193c      	adds	r4, r7, r4
 8009896:	7223      	strb	r3, [r4, #8]
}
 8009898:	0030      	movs	r0, r6
 800989a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    return USBPD_ERROR;
 800989c:	2602      	movs	r6, #2
 800989e:	e7fb      	b.n	8009898 <USBPD_PHY_ResetRequest+0x3c>
 80098a0:	2000035c 	.word	0x2000035c

080098a4 <PHY_SopDetect>:
    temp = OrderSets[index] ^ OrderSet;
 80098a4:	4b15      	ldr	r3, [pc, #84]	; (80098fc <PHY_SopDetect+0x58>)
{
 80098a6:	b5f0      	push	{r4, r5, r6, r7, lr}
    temp = OrderSets[index] ^ OrderSet;
 80098a8:	3310      	adds	r3, #16
      if (temp & 0x00007C00)
 80098aa:	26f8      	movs	r6, #248	; 0xf8
      if (temp & 0x000003E0)
 80098ac:	27f8      	movs	r7, #248	; 0xf8
  for (index = 0; index < OS_NUM; index++)
 80098ae:	2000      	movs	r0, #0
    temp = OrderSets[index] ^ OrderSet;
 80098b0:	469c      	mov	ip, r3
      if (temp & 0x00007C00)
 80098b2:	01f6      	lsls	r6, r6, #7
      if (temp & 0x000003E0)
 80098b4:	00bf      	lsls	r7, r7, #2
    temp = OrderSets[index] ^ OrderSet;
 80098b6:	4662      	mov	r2, ip
 80098b8:	0083      	lsls	r3, r0, #2
 80098ba:	589b      	ldr	r3, [r3, r2]
 80098bc:	001a      	movs	r2, r3
 80098be:	404a      	eors	r2, r1
    if (temp)
 80098c0:	428b      	cmp	r3, r1
 80098c2:	d014      	beq.n	80098ee <PHY_SopDetect+0x4a>
      if (temp & 0x000F8000)
 80098c4:	23f8      	movs	r3, #248	; 0xf8
 80098c6:	0014      	movs	r4, r2
 80098c8:	031b      	lsls	r3, r3, #12
 80098ca:	401c      	ands	r4, r3
    count = 0;
 80098cc:	0023      	movs	r3, r4
 80098ce:	1e5d      	subs	r5, r3, #1
 80098d0:	41ab      	sbcs	r3, r5
      if (temp & 0x00007C00)
 80098d2:	4232      	tst	r2, r6
 80098d4:	d002      	beq.n	80098dc <PHY_SopDetect+0x38>
      if (count > 1)
 80098d6:	2c00      	cmp	r4, #0
 80098d8:	d10b      	bne.n	80098f2 <PHY_SopDetect+0x4e>
 80098da:	2301      	movs	r3, #1
      if (temp & 0x000003E0)
 80098dc:	423a      	tst	r2, r7
 80098de:	d002      	beq.n	80098e6 <PHY_SopDetect+0x42>
      if (count > 1)
 80098e0:	2b01      	cmp	r3, #1
 80098e2:	d006      	beq.n	80098f2 <PHY_SopDetect+0x4e>
 80098e4:	2301      	movs	r3, #1
      if (temp & 0x0000001F)
 80098e6:	06d2      	lsls	r2, r2, #27
 80098e8:	d001      	beq.n	80098ee <PHY_SopDetect+0x4a>
      if (count > 1)
 80098ea:	2b01      	cmp	r3, #1
 80098ec:	d001      	beq.n	80098f2 <PHY_SopDetect+0x4e>
    type = (USBPD_SOPType_TypeDef)index;
 80098ee:	b2c0      	uxtb	r0, r0
}
 80098f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (index = 0; index < OS_NUM; index++)
 80098f2:	3001      	adds	r0, #1
 80098f4:	2807      	cmp	r0, #7
 80098f6:	d1de      	bne.n	80098b6 <PHY_SopDetect+0x12>
  USBPD_SOPType_TypeDef type = USBPD_SOPTYPE_INVALID;
 80098f8:	30f8      	adds	r0, #248	; 0xf8
 80098fa:	e7f9      	b.n	80098f0 <PHY_SopDetect+0x4c>
 80098fc:	0800c7d0 	.word	0x0800c7d0

08009900 <PHY_Rx_Accumulate>:
{
 8009900:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009902:	0006      	movs	r6, r0
  switch (pRxData->Status)
 8009904:	207c      	movs	r0, #124	; 0x7c
 8009906:	4370      	muls	r0, r6
 8009908:	4c32      	ldr	r4, [pc, #200]	; (80099d4 <PHY_Rx_Accumulate+0xd4>)
 800990a:	1825      	adds	r5, r4, r0
 800990c:	002f      	movs	r7, r5
 800990e:	3740      	adds	r7, #64	; 0x40
 8009910:	783b      	ldrb	r3, [r7, #0]
 8009912:	2b02      	cmp	r3, #2
 8009914:	d00c      	beq.n	8009930 <PHY_Rx_Accumulate+0x30>
 8009916:	2b03      	cmp	r3, #3
 8009918:	d034      	beq.n	8009984 <PHY_Rx_Accumulate+0x84>
 800991a:	2b00      	cmp	r3, #0
 800991c:	d151      	bne.n	80099c2 <PHY_Rx_Accumulate+0xc2>
    pRxData->OrderSet = data;
 800991e:	6469      	str	r1, [r5, #68]	; 0x44
    pRxData->Status = USBPD_PHY_RX_STATUS_SOP_DETECTING;
 8009920:	3302      	adds	r3, #2
      pRxData->Status = USBPD_PHY_RX_STATUS_MESSAGE_READY;
 8009922:	703b      	strb	r3, [r7, #0]
  return pRxData->Status;
 8009924:	237c      	movs	r3, #124	; 0x7c
 8009926:	435e      	muls	r6, r3
 8009928:	19a4      	adds	r4, r4, r6
 800992a:	3440      	adds	r4, #64	; 0x40
 800992c:	7820      	ldrb	r0, [r4, #0]
}
 800992e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pRxData->OrderSet |= data<<10;
 8009930:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8009932:	0289      	lsls	r1, r1, #10
 8009934:	4319      	orrs	r1, r3
 8009936:	6469      	str	r1, [r5, #68]	; 0x44
    pRxData->MsgType = PHY_SopDetect(PortNum, pRxData->OrderSet);
 8009938:	0030      	movs	r0, r6
 800993a:	f7ff ffb3 	bl	80098a4 <PHY_SopDetect>
 800993e:	3548      	adds	r5, #72	; 0x48
 8009940:	7028      	strb	r0, [r5, #0]
    switch(pRxData->MsgType)
 8009942:	2806      	cmp	r0, #6
 8009944:	d81c      	bhi.n	8009980 <PHY_Rx_Accumulate+0x80>
 8009946:	237c      	movs	r3, #124	; 0x7c
      if(PHY_Ports[PortNum].SupportedSOP & 0x1E)
 8009948:	4373      	muls	r3, r6
 800994a:	18e3      	adds	r3, r4, r3
    switch(pRxData->MsgType)
 800994c:	f7fc f828 	bl	80059a0 <__gnu_thumb1_case_uqi>
 8009950:	0f0f0f0f 	.word	0x0f0f0f0f
 8009954:	040f      	.short	0x040f
 8009956:	08          	.byte	0x08
 8009957:	00          	.byte	0x00
      pRxData->Status = USBPD_PHY_RX_STATUS_MESSAGE_READY;
 8009958:	3340      	adds	r3, #64	; 0x40
 800995a:	2204      	movs	r2, #4
        pRxData->Data[pRxData->DataCount++] = data4b_temp;
 800995c:	701a      	strb	r2, [r3, #0]
 800995e:	e7e1      	b.n	8009924 <PHY_Rx_Accumulate+0x24>
      if(PHY_Ports[PortNum].SupportedSOP & 0x1E)
 8009960:	221e      	movs	r2, #30
 8009962:	6f99      	ldr	r1, [r3, #120]	; 0x78
 8009964:	3340      	adds	r3, #64	; 0x40
 8009966:	4211      	tst	r1, r2
 8009968:	d1f7      	bne.n	800995a <PHY_Rx_Accumulate+0x5a>
        pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_UNSUPPORTED_SOP;
 800996a:	2206      	movs	r2, #6
 800996c:	e7f6      	b.n	800995c <PHY_Rx_Accumulate+0x5c>
      if(PHY_Ports[PortNum].SupportedSOP & (0x1 << pRxData->MsgType))
 800996e:	2101      	movs	r1, #1
 8009970:	4081      	lsls	r1, r0
 8009972:	000a      	movs	r2, r1
 8009974:	6f99      	ldr	r1, [r3, #120]	; 0x78
 8009976:	3340      	adds	r3, #64	; 0x40
 8009978:	4211      	tst	r1, r2
 800997a:	d0f6      	beq.n	800996a <PHY_Rx_Accumulate+0x6a>
        pRxData->Status = USBPD_PHY_RX_STATUS_DATA;
 800997c:	2203      	movs	r2, #3
 800997e:	e7ed      	b.n	800995c <PHY_Rx_Accumulate+0x5c>
      pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_INVALID_SOP;
 8009980:	2307      	movs	r3, #7
 8009982:	e7ce      	b.n	8009922 <PHY_Rx_Accumulate+0x22>
    if ((data & CODE_5B_ITEM1_MASK) == KC_S_EOP)
 8009984:	201f      	movs	r0, #31
 8009986:	000a      	movs	r2, r1
 8009988:	4002      	ands	r2, r0
 800998a:	2a0d      	cmp	r2, #13
 800998c:	d101      	bne.n	8009992 <PHY_Rx_Accumulate+0x92>
      pRxData->Status = USBPD_PHY_RX_STATUS_MESSAGE_READY;
 800998e:	2304      	movs	r3, #4
 8009990:	e7c7      	b.n	8009922 <PHY_Rx_Accumulate+0x22>
  v0 = decoding5b4b[(value >>  0) & 0x1F]; /* decoding first nibble */
 8009992:	4b11      	ldr	r3, [pc, #68]	; (80099d8 <PHY_Rx_Accumulate+0xd8>)
  v1 = decoding5b4b[(value >>  5) & 0x1F]; /* decoding second nibble */
 8009994:	0949      	lsrs	r1, r1, #5
  v0 = decoding5b4b[(value >>  0) & 0x1F]; /* decoding first nibble */
 8009996:	332c      	adds	r3, #44	; 0x2c
 8009998:	5c9a      	ldrb	r2, [r3, r2]
  v1 = decoding5b4b[(value >>  5) & 0x1F]; /* decoding second nibble */
 800999a:	4001      	ands	r1, r0
 800999c:	5c59      	ldrb	r1, [r3, r1]
  if (v0 == CODE_5B_INVALID || v1 == CODE_5B_INVALID) 
 800999e:	2aff      	cmp	r2, #255	; 0xff
 80099a0:	d009      	beq.n	80099b6 <PHY_Rx_Accumulate+0xb6>
 80099a2:	29ff      	cmp	r1, #255	; 0xff
 80099a4:	d007      	beq.n	80099b6 <PHY_Rx_Accumulate+0xb6>
        pRxData->Data[pRxData->DataCount++] = data4b_temp;
 80099a6:	6f6b      	ldr	r3, [r5, #116]	; 0x74
  return v0 | (v1<<4);
 80099a8:	0109      	lsls	r1, r1, #4
        pRxData->Data[pRxData->DataCount++] = data4b_temp;
 80099aa:	1c58      	adds	r0, r3, #1
 80099ac:	18eb      	adds	r3, r5, r3
 80099ae:	6768      	str	r0, [r5, #116]	; 0x74
 80099b0:	3349      	adds	r3, #73	; 0x49
  return v0 | (v1<<4);
 80099b2:	430a      	orrs	r2, r1
 80099b4:	e7d2      	b.n	800995c <PHY_Rx_Accumulate+0x5c>
        pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_INVALID_SYMBOL;
 80099b6:	237c      	movs	r3, #124	; 0x7c
 80099b8:	4373      	muls	r3, r6
 80099ba:	18e3      	adds	r3, r4, r3
 80099bc:	3340      	adds	r3, #64	; 0x40
 80099be:	2208      	movs	r2, #8
 80099c0:	e7cc      	b.n	800995c <PHY_Rx_Accumulate+0x5c>
    pRxData->DataCount = 0;
 80099c2:	2100      	movs	r1, #0
    memset(pRxData->Data, 0, __RX_DATA_LEN);
 80099c4:	3049      	adds	r0, #73	; 0x49
    pRxData->DataCount = 0;
 80099c6:	6769      	str	r1, [r5, #116]	; 0x74
    memset(pRxData->Data, 0, __RX_DATA_LEN);
 80099c8:	1820      	adds	r0, r4, r0
 80099ca:	2228      	movs	r2, #40	; 0x28
 80099cc:	f002 fddf 	bl	800c58e <memset>
    break;
 80099d0:	e7a8      	b.n	8009924 <PHY_Rx_Accumulate+0x24>
 80099d2:	46c0      	nop			; (mov r8, r8)
 80099d4:	2000035c 	.word	0x2000035c
 80099d8:	0800c7d0 	.word	0x0800c7d0

080099dc <USBPD_HW_IF_CRC_Calculate>:
  * @param  *pBuffer    Pointer to the input data buffer
  * @param  len         Input data buffer length
  * @retval uint32_t    CRC value
  */
uint32_t USBPD_HW_IF_CRC_Calculate(uint8_t *pBuffer, uint8_t len)
{
 80099dc:	b510      	push	{r4, lr}
 80099de:	000a      	movs	r2, r1
  uint32_t crc;

  crc = HAL_CRC_Calculate(&hcrc, (uint32_t *)pBuffer, len);
 80099e0:	0001      	movs	r1, r0
 80099e2:	4802      	ldr	r0, [pc, #8]	; (80099ec <USBPD_HW_IF_CRC_Calculate+0x10>)
 80099e4:	f7fd fe49 	bl	800767a <HAL_CRC_Calculate>
  crc ^= 0xFFFFFFFF;
 80099e8:	43c0      	mvns	r0, r0
  return crc;
}
 80099ea:	bd10      	pop	{r4, pc}
 80099ec:	20001c00 	.word	0x20001c00

080099f0 <USBPD_HW_IF_SendBuffer>:
* @param  *pBuffer      Pointer to the TX data buffer
* @param  Bitsize:      Amount of bits to be transmitted
* @retval USBPD status
*/
USBPD_StatusTypeDef USBPD_HW_IF_SendBuffer(uint8_t PortNum, uint8_t *pBuffer, uint32_t Bitsize)
{
 80099f0:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check if the port is still receiving */
  if (Ports[PortNum].State == HAL_USBPD_PORT_STATE_BUSY_RX)
 80099f2:	24f0      	movs	r4, #240	; 0xf0
 80099f4:	0064      	lsls	r4, r4, #1
 80099f6:	4344      	muls	r4, r0
 80099f8:	4b17      	ldr	r3, [pc, #92]	; (8009a58 <USBPD_HW_IF_SendBuffer+0x68>)
{
 80099fa:	b085      	sub	sp, #20
  if (Ports[PortNum].State == HAL_USBPD_PORT_STATE_BUSY_RX)
 80099fc:	191c      	adds	r4, r3, r4
 80099fe:	7e63      	ldrb	r3, [r4, #25]
{
 8009a00:	0006      	movs	r6, r0
 8009a02:	9103      	str	r1, [sp, #12]
 8009a04:	9202      	str	r2, [sp, #8]
    return USBPD_BUSY;
 8009a06:	2003      	movs	r0, #3
  if (Ports[PortNum].State == HAL_USBPD_PORT_STATE_BUSY_RX)
 8009a08:	2b04      	cmp	r3, #4
 8009a0a:	d022      	beq.n	8009a52 <USBPD_HW_IF_SendBuffer+0x62>

  uint8_t *pTxBuffer = (uint8_t *)Ports[PortNum].pTxBuffPtr;
  uint16_t size = DIV_ROUND_UP(Bitsize, 8)+TX_PREAMBLE_SIZE;
 8009a0c:	0013      	movs	r3, r2
  uint8_t *pTxBuffer = (uint8_t *)Ports[PortNum].pTxBuffPtr;
 8009a0e:	6865      	ldr	r5, [r4, #4]
  uint16_t size = DIV_ROUND_UP(Bitsize, 8)+TX_PREAMBLE_SIZE;
 8009a10:	3307      	adds	r3, #7
 8009a12:	40c3      	lsrs	r3, r0
 8009a14:	002f      	movs	r7, r5
 8009a16:	3308      	adds	r3, #8
 8009a18:	3708      	adds	r7, #8
 8009a1a:	b29b      	uxth	r3, r3

  memset((uint8_t *)pTxBuffer, 0x00, TX_BUFFER_SIZE);
 8009a1c:	2230      	movs	r2, #48	; 0x30
 8009a1e:	2100      	movs	r1, #0
 8009a20:	0038      	movs	r0, r7
  uint16_t size = DIV_ROUND_UP(Bitsize, 8)+TX_PREAMBLE_SIZE;
 8009a22:	9301      	str	r3, [sp, #4]
  memset((uint8_t *)pTxBuffer, 0x00, TX_BUFFER_SIZE);
 8009a24:	f002 fdb3 	bl	800c58e <memset>
  memset((uint8_t *)pTxBuffer, TX_PREAMBLE, TX_PREAMBLE_SIZE);                          /* preamble is added */
 8009a28:	2208      	movs	r2, #8
 8009a2a:	21aa      	movs	r1, #170	; 0xaa
 8009a2c:	0028      	movs	r0, r5
 8009a2e:	f002 fdae 	bl	800c58e <memset>
  memcpy((uint8_t *)(pTxBuffer+TX_PREAMBLE_SIZE), pBuffer, (size-TX_PREAMBLE_SIZE));    /* data are added */
 8009a32:	9a01      	ldr	r2, [sp, #4]
 8009a34:	9903      	ldr	r1, [sp, #12]
 8009a36:	3a08      	subs	r2, #8
 8009a38:	0038      	movs	r0, r7
 8009a3a:	f002 fd9f 	bl	800c57c <memcpy>

  /* Spare clock cycles at the end of transmission are calculated */
  Ports[PortNum].TxSpareBits = (Bitsize % 8);
 8009a3e:	2307      	movs	r3, #7
 8009a40:	9a02      	ldr	r2, [sp, #8]
 8009a42:	342a      	adds	r4, #42	; 0x2a
 8009a44:	4013      	ands	r3, r2
 8009a46:	7023      	strb	r3, [r4, #0]

  /* Packet is ready to be sent to SPI */
  USBPD_StatusTypeDef ret = USBPD_OK;
  ret = STUSB16xx_HW_IF_Send_Packet(PortNum, pTxBuffer, size);
 8009a48:	9a01      	ldr	r2, [sp, #4]
 8009a4a:	0029      	movs	r1, r5
 8009a4c:	0030      	movs	r0, r6
 8009a4e:	f001 fb9f 	bl	800b190 <STUSB16xx_HW_IF_Send_Packet>
  return ret;
}
 8009a52:	b005      	add	sp, #20
 8009a54:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009a56:	46c0      	nop			; (mov r8, r8)
 8009a58:	20000058 	.word	0x20000058

08009a5c <USBPD_HW_IF_Send_BIST_Pattern>:
* @brief  It sends BIST pattern  
* @param  PortNum       The port index
* @retval USBPD status
*/
USBPD_StatusTypeDef USBPD_HW_IF_Send_BIST_Pattern(uint8_t PortNum)
{
 8009a5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USBPD_StatusTypeDef ret = USBPD_ERROR;
  
  /* BIST Carrier mode flag set */
  Ports[PortNum].State=HAL_USBPD_PORT_STATE_BIST;
 8009a5e:	24f0      	movs	r4, #240	; 0xf0
 8009a60:	0064      	lsls	r4, r4, #1
 8009a62:	4344      	muls	r4, r0
 8009a64:	4b15      	ldr	r3, [pc, #84]	; (8009abc <USBPD_HW_IF_Send_BIST_Pattern+0x60>)
{
 8009a66:	0005      	movs	r5, r0
  Ports[PortNum].State=HAL_USBPD_PORT_STATE_BIST;
 8009a68:	191f      	adds	r7, r3, r4
 8009a6a:	2308      	movs	r3, #8
  STUSB16xx_HW_IF_Set_DMA_Circular_Mode(PortNum);
  
  /* Set the SPI in TX mode */
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
  
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 8009a6c:	0026      	movs	r6, r4
  Ports[PortNum].State=HAL_USBPD_PORT_STATE_BIST;
 8009a6e:	767b      	strb	r3, [r7, #25]
  memset(Ports[PortNum].pTxBuffPtr, 0xAA, TX_BUFFER_LEN*2);
 8009a70:	2238      	movs	r2, #56	; 0x38
 8009a72:	21aa      	movs	r1, #170	; 0xaa
 8009a74:	6878      	ldr	r0, [r7, #4]
 8009a76:	f002 fd8a 	bl	800c58e <memset>
  STUSB16xx_HW_IF_Set_DMA_Circular_Mode(PortNum);
 8009a7a:	0028      	movs	r0, r5
 8009a7c:	f001 f90a 	bl	800ac94 <STUSB16xx_HW_IF_Set_DMA_Circular_Mode>
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 8009a80:	2100      	movs	r1, #0
 8009a82:	0028      	movs	r0, r5
 8009a84:	f001 f92a 	bl	800acdc <STUSB16xx_HW_IF_Switch_Mode>
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 8009a88:	4b0c      	ldr	r3, [pc, #48]	; (8009abc <USBPD_HW_IF_Send_BIST_Pattern+0x60>)
 8009a8a:	3640      	adds	r6, #64	; 0x40
 8009a8c:	18f6      	adds	r6, r6, r3
 8009a8e:	0030      	movs	r0, r6
 8009a90:	f7fe fe82 	bl	8008798 <HAL_SPI_DMAStop>
  HAL_DMA_Abort(&Ports[PortNum].hdmarx);
 8009a94:	0020      	movs	r0, r4
 8009a96:	4b09      	ldr	r3, [pc, #36]	; (8009abc <USBPD_HW_IF_Send_BIST_Pattern+0x60>)
 8009a98:	30e8      	adds	r0, #232	; 0xe8
 8009a9a:	18c0      	adds	r0, r0, r3
 8009a9c:	f7fd fef4 	bl	8007888 <HAL_DMA_Abort>
  __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 8009aa0:	4b07      	ldr	r3, [pc, #28]	; (8009ac0 <USBPD_HW_IF_Send_BIST_Pattern+0x64>)
 8009aa2:	4a08      	ldr	r2, [pc, #32]	; (8009ac4 <USBPD_HW_IF_Send_BIST_Pattern+0x68>)
  
  /* Send TX Buffer by SPI DMA */
  HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, (uint8_t*)(Ports[PortNum].pTxBuffPtr), TX_BUFFER_LEN*2);
 8009aa4:	6879      	ldr	r1, [r7, #4]
  __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 8009aa6:	605a      	str	r2, [r3, #4]
  HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, (uint8_t*)(Ports[PortNum].pTxBuffPtr), TX_BUFFER_LEN*2);
 8009aa8:	0030      	movs	r0, r6
 8009aaa:	2238      	movs	r2, #56	; 0x38
 8009aac:	f7fe fc62 	bl	8008374 <HAL_SPI_Transmit_DMA>
  
  /* Start transmission */
  STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_SET);
 8009ab0:	0028      	movs	r0, r5
 8009ab2:	2101      	movs	r1, #1
 8009ab4:	f001 f920 	bl	800acf8 <STUSB16xx_HW_IF_TX_EN_Status>
  
  ret = USBPD_OK;
  return ret;
}
 8009ab8:	2000      	movs	r0, #0
 8009aba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009abc:	20000058 	.word	0x20000058
 8009ac0:	40020000 	.word	0x40020000
 8009ac4:	0fffffff 	.word	0x0fffffff

08009ac8 <USBPD_HW_IF_GPIO_Off>:
 * @brief   It resets the state of GPIO pin
 * @param   gpio The GPIO structure
 * @retval  None
 */
void USBPD_HW_IF_GPIO_Off(USBPD_BSP_GPIOPins_TypeDef gpio)
{
 8009ac8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  HAL_GPIO_WritePin(gpio.GPIOx, gpio.GPIO_Pin, PinState);
 8009aca:	b289      	uxth	r1, r1
 8009acc:	2200      	movs	r2, #0
 8009ace:	f7fd ffb3 	bl	8007a38 <HAL_GPIO_WritePin>
  /* Resets the pin */
  USBPD_HW_IF_GPIO_Set(gpio, GPIO_PIN_RESET);
}
 8009ad2:	b005      	add	sp, #20
 8009ad4:	bd00      	pop	{pc}
	...

08009ad8 <PHY_HW_IF_ADCAnalogGPIO_Init>:
{
  GPIO_InitTypeDef      GPIO_InitStruct;
  uint8_t ch = 0;

  /* Configure all GPIO port pins in Analog mode */
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009ad8:	2303      	movs	r3, #3
{
 8009ada:	b510      	push	{r4, lr}
 8009adc:	b086      	sub	sp, #24
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009ade:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009ae0:	2300      	movs	r3, #0

  for(ch=0;ch<USBPD_ADCn;ch++)
  {
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009ae2:	4c0b      	ldr	r4, [pc, #44]	; (8009b10 <PHY_HW_IF_ADCAnalogGPIO_Init+0x38>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009ae4:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009ae6:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 8009ae8:	3310      	adds	r3, #16
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009aea:	0020      	movs	r0, r4
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 8009aec:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009aee:	f7fd fee1 	bl	80078b4 <HAL_GPIO_Init>
 8009af2:	2090      	movs	r0, #144	; 0x90
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 8009af4:	2380      	movs	r3, #128	; 0x80
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009af6:	a901      	add	r1, sp, #4
 8009af8:	05c0      	lsls	r0, r0, #23
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 8009afa:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009afc:	f7fd feda 	bl	80078b4 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 8009b00:	2301      	movs	r3, #1
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009b02:	a901      	add	r1, sp, #4
 8009b04:	0020      	movs	r0, r4
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 8009b06:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 8009b08:	f7fd fed4 	bl	80078b4 <HAL_GPIO_Init>
  }
}
 8009b0c:	b006      	add	sp, #24
 8009b0e:	bd10      	pop	{r4, pc}
 8009b10:	48000800 	.word	0x48000800

08009b14 <PHY_HW_IF_ADCDMA_Init>:
/**
  * @brief  Initialization of the ADC DMA
  * @retval None
  */
void PHY_HW_IF_ADCDMA_Init(void)
{
 8009b14:	b510      	push	{r4, lr}
  /* Configuration of DMA parameters */
  DmaHandle.Instance = ADCx_DMA;
 8009b16:	4b0e      	ldr	r3, [pc, #56]	; (8009b50 <PHY_HW_IF_ADCDMA_Init+0x3c>)
 8009b18:	4c0e      	ldr	r4, [pc, #56]	; (8009b54 <PHY_HW_IF_ADCDMA_Init+0x40>)
 8009b1a:	6023      	str	r3, [r4, #0]

  DmaHandle.Init.Direction           = DMA_PERIPH_TO_MEMORY;
 8009b1c:	2300      	movs	r3, #0
 8009b1e:	6063      	str	r3, [r4, #4]
  DmaHandle.Init.PeriphInc           = DMA_PINC_DISABLE;
 8009b20:	60a3      	str	r3, [r4, #8]
  DmaHandle.Init.MemInc              = DMA_MINC_ENABLE;
 8009b22:	3380      	adds	r3, #128	; 0x80
 8009b24:	60e3      	str	r3, [r4, #12]
  DmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;   /* Transfer from ADC by half-word to match with ADC configuration: ADC resolution 10 or 12 bits */
 8009b26:	3380      	adds	r3, #128	; 0x80
 8009b28:	6123      	str	r3, [r4, #16]
  DmaHandle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;       /* Transfer to memory by half-word to match with buffer variable type: half-word */
 8009b2a:	2380      	movs	r3, #128	; 0x80
 8009b2c:	011b      	lsls	r3, r3, #4
 8009b2e:	6163      	str	r3, [r4, #20]
  DmaHandle.Init.Mode                = DMA_CIRCULAR;              /* DMA in circular mode to match with ADC configuration: DMA continuous requests */
 8009b30:	2320      	movs	r3, #32
 8009b32:	61a3      	str	r3, [r4, #24]
  DmaHandle.Init.Priority            = DMA_PRIORITY_HIGH;
 8009b34:	2380      	movs	r3, #128	; 0x80

  /* Initialization of the DMA associated to the peripheral */
  HAL_DMA_DeInit(&DmaHandle);
 8009b36:	0020      	movs	r0, r4
  DmaHandle.Init.Priority            = DMA_PRIORITY_HIGH;
 8009b38:	019b      	lsls	r3, r3, #6
 8009b3a:	61e3      	str	r3, [r4, #28]
  HAL_DMA_DeInit(&DmaHandle);
 8009b3c:	f7fd fe42 	bl	80077c4 <HAL_DMA_DeInit>
  HAL_DMA_Init(&DmaHandle);
 8009b40:	0020      	movs	r0, r4
 8009b42:	f7fd fe09 	bl	8007758 <HAL_DMA_Init>

  /* Association of the initialized DMA handle to the ADC handle */
  __HAL_LINKDMA(&usbpdm1_hadc, DMA_Handle, DmaHandle);
 8009b46:	4b04      	ldr	r3, [pc, #16]	; (8009b58 <PHY_HW_IF_ADCDMA_Init+0x44>)
 8009b48:	63dc      	str	r4, [r3, #60]	; 0x3c
 8009b4a:	6263      	str	r3, [r4, #36]	; 0x24
}
 8009b4c:	bd10      	pop	{r4, pc}
 8009b4e:	46c0      	nop			; (mov r8, r8)
 8009b50:	40020008 	.word	0x40020008
 8009b54:	20001c60 	.word	0x20001c60
 8009b58:	20001ba8 	.word	0x20001ba8

08009b5c <PHY_HW_IF_RX_Stop>:
  * @brief  PHY accomplishes the data receiving phase
  * @param  PortNum The port index
  * @retval None
  */
void PHY_HW_IF_RX_Stop(uint8_t PortNum)
{
 8009b5c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009b5e:	0005      	movs	r5, r0
   * 3 - PHY_HW_IF_RX_Stop function is ongoing
   */

  UnwrapData_TypeDef* ud = &(Ports[PortNum].unwrapdata);
  
  if (ud->exed_flag == 3)
 8009b60:	20f0      	movs	r0, #240	; 0xf0
 8009b62:	0040      	lsls	r0, r0, #1
 8009b64:	4368      	muls	r0, r5
 8009b66:	4c49      	ldr	r4, [pc, #292]	; (8009c8c <PHY_HW_IF_RX_Stop+0x130>)
 8009b68:	0002      	movs	r2, r0
 8009b6a:	1826      	adds	r6, r4, r0
 8009b6c:	0033      	movs	r3, r6
 8009b6e:	3279      	adds	r2, #121	; 0x79
 8009b70:	332c      	adds	r3, #44	; 0x2c
 8009b72:	32ff      	adds	r2, #255	; 0xff
 8009b74:	781f      	ldrb	r7, [r3, #0]
{
 8009b76:	b089      	sub	sp, #36	; 0x24
 8009b78:	1912      	adds	r2, r2, r4
  if (ud->exed_flag == 3)
 8009b7a:	9001      	str	r0, [sp, #4]
 8009b7c:	9202      	str	r2, [sp, #8]
 8009b7e:	2f03      	cmp	r7, #3
 8009b80:	d105      	bne.n	8009b8e <PHY_HW_IF_RX_Stop+0x32>
  {
    HAL_TIM_OC_Stop_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 8009b82:	2100      	movs	r1, #0
 8009b84:	0010      	movs	r0, r2
 8009b86:	f7ff f981 	bl	8008e8c <HAL_TIM_OC_Stop_IT>
  /* Callback core phy completed */
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed != NULL)
  {
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed(PortNum);
  }
}
 8009b8a:	b009      	add	sp, #36	; 0x24
 8009b8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  ud->exed_flag = 3;
 8009b8e:	2203      	movs	r2, #3
{
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Disable the TIM Capture/Compare 1 interrupt */
  __HAL_TIM_DISABLE_IT(htim, tim_it);
 8009b90:	36fc      	adds	r6, #252	; 0xfc
 8009b92:	6ff0      	ldr	r0, [r6, #124]	; 0x7c
  ud->exed_flag = 3;
 8009b94:	701a      	strb	r2, [r3, #0]
  __HAL_TIM_DISABLE_IT(htim, tim_it);
 8009b96:	68c3      	ldr	r3, [r0, #12]
 8009b98:	3a01      	subs	r2, #1
 8009b9a:	4393      	bics	r3, r2

  /* Disable the Output compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 8009b9c:	2200      	movs	r2, #0
  __HAL_TIM_DISABLE_IT(htim, tim_it);
 8009b9e:	60c3      	str	r3, [r0, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 8009ba0:	0011      	movs	r1, r2
 8009ba2:	f7ff f927 	bl	8008df4 <TIM_CCxChannelCmd>

  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8009ba6:	6ff3      	ldr	r3, [r6, #124]	; 0x7c
 8009ba8:	4a39      	ldr	r2, [pc, #228]	; (8009c90 <PHY_HW_IF_RX_Stop+0x134>)
 8009baa:	483a      	ldr	r0, [pc, #232]	; (8009c94 <PHY_HW_IF_RX_Stop+0x138>)
 8009bac:	4293      	cmp	r3, r2
 8009bae:	d008      	beq.n	8009bc2 <PHY_HW_IF_RX_Stop+0x66>
 8009bb0:	4a39      	ldr	r2, [pc, #228]	; (8009c98 <PHY_HW_IF_RX_Stop+0x13c>)
 8009bb2:	4293      	cmp	r3, r2
 8009bb4:	d005      	beq.n	8009bc2 <PHY_HW_IF_RX_Stop+0x66>
 8009bb6:	4a39      	ldr	r2, [pc, #228]	; (8009c9c <PHY_HW_IF_RX_Stop+0x140>)
 8009bb8:	4293      	cmp	r3, r2
 8009bba:	d002      	beq.n	8009bc2 <PHY_HW_IF_RX_Stop+0x66>
 8009bbc:	4a38      	ldr	r2, [pc, #224]	; (8009ca0 <PHY_HW_IF_RX_Stop+0x144>)
 8009bbe:	4293      	cmp	r3, r2
 8009bc0:	d102      	bne.n	8009bc8 <PHY_HW_IF_RX_Stop+0x6c>
  {
    /* Disable the Main Ouput */
    htim->Instance->BDTR &= ~(TIM_BDTR_MOE);
 8009bc2:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8009bc4:	4001      	ands	r1, r0
 8009bc6:	6459      	str	r1, [r3, #68]	; 0x44
  }
  /* Disable the Peripheral */
  htim->Instance->BDTR &= ~(TIM_BDTR_MOE);
 8009bc8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8009bca:	4002      	ands	r2, r0
 8009bcc:	645a      	str	r2, [r3, #68]	; 0x44
  if (ud_ef == 0)
 8009bce:	2f00      	cmp	r7, #0
 8009bd0:	d13f      	bne.n	8009c52 <PHY_HW_IF_RX_Stop+0xf6>
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 8009bd2:	23f0      	movs	r3, #240	; 0xf0
 8009bd4:	005b      	lsls	r3, r3, #1
 8009bd6:	436b      	muls	r3, r5
 8009bd8:	18e4      	adds	r4, r4, r3
 8009bda:	68e2      	ldr	r2, [r4, #12]
  uint32_t temp_data = 0;
 8009bdc:	9707      	str	r7, [sp, #28]
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 8009bde:	9203      	str	r2, [sp, #12]
  uint16_t lastindex = (RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR);
 8009be0:	0022      	movs	r2, r4
 8009be2:	32e8      	adds	r2, #232	; 0xe8
 8009be4:	6812      	ldr	r2, [r2, #0]
 8009be6:	6852      	ldr	r2, [r2, #4]
 8009be8:	9204      	str	r2, [sp, #16]
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate == NULL)
 8009bea:	0022      	movs	r2, r4
 8009bec:	32c9      	adds	r2, #201	; 0xc9
 8009bee:	32ff      	adds	r2, #255	; 0xff
 8009bf0:	6812      	ldr	r2, [r2, #0]
 8009bf2:	2a00      	cmp	r2, #0
 8009bf4:	d02c      	beq.n	8009c50 <PHY_HW_IF_RX_Stop+0xf4>
  while(ud->index <= lastindex)
 8009bf6:	9305      	str	r3, [sp, #20]
  uint16_t lastindex = (RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR);
 8009bf8:	233c      	movs	r3, #60	; 0x3c
 8009bfa:	9a04      	ldr	r2, [sp, #16]
  while(ud->index <= lastindex)
 8009bfc:	6ba6      	ldr	r6, [r4, #56]	; 0x38
  uint16_t lastindex = (RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR);
 8009bfe:	1a9b      	subs	r3, r3, r2
  while(ud->index <= lastindex)
 8009c00:	b29b      	uxth	r3, r3
 8009c02:	429e      	cmp	r6, r3
 8009c04:	d825      	bhi.n	8009c52 <PHY_HW_IF_RX_Stop+0xf6>
    memcpy(&temp_data, &pbuff_in[ud->index], 3);
 8009c06:	9b03      	ldr	r3, [sp, #12]
 8009c08:	2203      	movs	r2, #3
 8009c0a:	1999      	adds	r1, r3, r6
 8009c0c:	a807      	add	r0, sp, #28
 8009c0e:	f002 fcb5 	bl	800c57c <memcpy>
    ud->index += ud->offset <= 5 ? 1 : 2;
 8009c12:	2305      	movs	r3, #5
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009c14:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8009c16:	9f07      	ldr	r7, [sp, #28]
    ud->index += ud->offset <= 5 ? 1 : 2;
 8009c18:	4293      	cmp	r3, r2
 8009c1a:	419b      	sbcs	r3, r3
 8009c1c:	425b      	negs	r3, r3
 8009c1e:	3301      	adds	r3, #1
 8009c20:	469c      	mov	ip, r3
 8009c22:	481a      	ldr	r0, [pc, #104]	; (8009c8c <PHY_HW_IF_RX_Stop+0x130>)
 8009c24:	9b05      	ldr	r3, [sp, #20]
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009c26:	40d7      	lsrs	r7, r2
    ud->index += ud->offset <= 5 ? 1 : 2;
 8009c28:	18c0      	adds	r0, r0, r3
    ud->offset = (ud->offset + 2) & 7;
 8009c2a:	2307      	movs	r3, #7
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009c2c:	05b9      	lsls	r1, r7, #22
    ud->offset = (ud->offset + 2) & 7;
 8009c2e:	3202      	adds	r2, #2
 8009c30:	401a      	ands	r2, r3
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009c32:	0d89      	lsrs	r1, r1, #22
    ud->index += ud->offset <= 5 ? 1 : 2;
 8009c34:	4466      	add	r6, ip
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009c36:	9107      	str	r1, [sp, #28]
    ud->index += ud->offset <= 5 ? 1 : 2;
 8009c38:	6386      	str	r6, [r0, #56]	; 0x38
    ud->offset = (ud->offset + 2) & 7;
 8009c3a:	63c2      	str	r2, [r0, #60]	; 0x3c
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate(PortNum, temp_data);
 8009c3c:	30c9      	adds	r0, #201	; 0xc9
 8009c3e:	30ff      	adds	r0, #255	; 0xff
 8009c40:	6803      	ldr	r3, [r0, #0]
 8009c42:	0028      	movs	r0, r5
 8009c44:	4798      	blx	r3
    if ((temp_data & 0x1F) == 0x0D)
 8009c46:	231f      	movs	r3, #31
 8009c48:	401f      	ands	r7, r3
 8009c4a:	2f0d      	cmp	r7, #13
 8009c4c:	d1d4      	bne.n	8009bf8 <PHY_HW_IF_RX_Stop+0x9c>
 8009c4e:	e000      	b.n	8009c52 <PHY_HW_IF_RX_Stop+0xf6>
 8009c50:	46c0      	nop			; (mov r8, r8)
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 8009c52:	24f0      	movs	r4, #240	; 0xf0
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 8009c54:	9801      	ldr	r0, [sp, #4]
 8009c56:	4e0d      	ldr	r6, [pc, #52]	; (8009c8c <PHY_HW_IF_RX_Stop+0x130>)
 8009c58:	3040      	adds	r0, #64	; 0x40
 8009c5a:	1980      	adds	r0, r0, r6
 8009c5c:	f7fe fd9c 	bl	8008798 <HAL_SPI_DMAStop>
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 8009c60:	2301      	movs	r3, #1
 8009c62:	0064      	lsls	r4, r4, #1
 8009c64:	436c      	muls	r4, r5
 8009c66:	1934      	adds	r4, r6, r4
 8009c68:	7663      	strb	r3, [r4, #25]
  HAL_TIM_Base_Stop_IT(&(Ports[PortNum].htimcountrx));
 8009c6a:	9802      	ldr	r0, [sp, #8]
 8009c6c:	f7fe ffb6 	bl	8008bdc <HAL_TIM_Base_Stop_IT>
  Ports[PortNum].htimcountrx.Instance->CNT = 0;
 8009c70:	0023      	movs	r3, r4
 8009c72:	2200      	movs	r2, #0
 8009c74:	33fc      	adds	r3, #252	; 0xfc
 8009c76:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed != NULL)
 8009c78:	34cd      	adds	r4, #205	; 0xcd
 8009c7a:	34ff      	adds	r4, #255	; 0xff
  Ports[PortNum].htimcountrx.Instance->CNT = 0;
 8009c7c:	625a      	str	r2, [r3, #36]	; 0x24
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed != NULL)
 8009c7e:	6823      	ldr	r3, [r4, #0]
 8009c80:	4293      	cmp	r3, r2
 8009c82:	d100      	bne.n	8009c86 <PHY_HW_IF_RX_Stop+0x12a>
 8009c84:	e781      	b.n	8009b8a <PHY_HW_IF_RX_Stop+0x2e>
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed(PortNum);
 8009c86:	0028      	movs	r0, r5
 8009c88:	4798      	blx	r3
 8009c8a:	e77e      	b.n	8009b8a <PHY_HW_IF_RX_Stop+0x2e>
 8009c8c:	20000058 	.word	0x20000058
 8009c90:	40012c00 	.word	0x40012c00
 8009c94:	ffff7fff 	.word	0xffff7fff
 8009c98:	40014000 	.word	0x40014000
 8009c9c:	40014400 	.word	0x40014400
 8009ca0:	40014800 	.word	0x40014800

08009ca4 <HAL_TIM_OC_DelayElapsedCallback>:
  uint32_t temp_data = 0;
 8009ca4:	2300      	movs	r3, #0
{
 8009ca6:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 8009ca8:	4c62      	ldr	r4, [pc, #392]	; (8009e34 <HAL_TIM_OC_DelayElapsedCallback+0x190>)
{
 8009caa:	b085      	sub	sp, #20
  uint32_t temp_data = 0;
 8009cac:	9303      	str	r3, [sp, #12]
  uint32_t tim_count = Ports[PortNum].htimcountrx.Instance->CNT;
 8009cae:	0023      	movs	r3, r4
 8009cb0:	33fc      	adds	r3, #252	; 0xfc
 8009cb2:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 8009cb4:	68e6      	ldr	r6, [r4, #12]
  uint32_t tim_count = Ports[PortNum].htimcountrx.Instance->CNT;
 8009cb6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009cb8:	9301      	str	r3, [sp, #4]
         (ud->exed_flag == 0) &&
 8009cba:	0022      	movs	r2, r4
 8009cbc:	322c      	adds	r2, #44	; 0x2c
  while (
 8009cbe:	7812      	ldrb	r2, [r2, #0]
 8009cc0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009cc2:	2a00      	cmp	r2, #0
 8009cc4:	d100      	bne.n	8009cc8 <HAL_TIM_OC_DelayElapsedCallback+0x24>
 8009cc6:	e084      	b.n	8009dd2 <HAL_TIM_OC_DelayElapsedCallback+0x12e>
  Ports[PortNum].ud_index_current[Ports[PortNum].modulo] = ud->index ;
 8009cc8:	27ee      	movs	r7, #238	; 0xee
 8009cca:	007f      	lsls	r7, r7, #1
 8009ccc:	5de0      	ldrb	r0, [r4, r7]
 8009cce:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 8009cd0:	1823      	adds	r3, r4, r0
 8009cd2:	33da      	adds	r3, #218	; 0xda
 8009cd4:	33ff      	adds	r3, #255	; 0xff
  Ports[PortNum].modulo++;
 8009cd6:	3001      	adds	r0, #1
  Ports[PortNum].ud_index_current[Ports[PortNum].modulo] = ud->index ;
 8009cd8:	701e      	strb	r6, [r3, #0]
  Ports[PortNum].modulo = Ports[PortNum].modulo%3;
 8009cda:	b2c0      	uxtb	r0, r0
 8009cdc:	2103      	movs	r1, #3
 8009cde:	f7fb feef 	bl	8005ac0 <__aeabi_uidivmod>
 8009ce2:	b2cd      	uxtb	r5, r1
      (Ports[PortNum].ud_index_current[Ports[PortNum].modulo] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3]) &&
 8009ce4:	1963      	adds	r3, r4, r5
 8009ce6:	33da      	adds	r3, #218	; 0xda
  Ports[PortNum].modulo = Ports[PortNum].modulo%3;
 8009ce8:	55e5      	strb	r5, [r4, r7]
      (Ports[PortNum].ud_index_current[Ports[PortNum].modulo] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3]) &&
 8009cea:	33ff      	adds	r3, #255	; 0xff
 8009cec:	781b      	ldrb	r3, [r3, #0]
 8009cee:	1c68      	adds	r0, r5, #1
 8009cf0:	2103      	movs	r1, #3
 8009cf2:	9301      	str	r3, [sp, #4]
 8009cf4:	f7fb ffce 	bl	8005c94 <__aeabi_idivmod>
 8009cf8:	1861      	adds	r1, r4, r1
 8009cfa:	31da      	adds	r1, #218	; 0xda
 8009cfc:	31ff      	adds	r1, #255	; 0xff
  if (
 8009cfe:	780f      	ldrb	r7, [r1, #0]
 8009d00:	9b01      	ldr	r3, [sp, #4]
 8009d02:	429f      	cmp	r7, r3
 8009d04:	d10f      	bne.n	8009d26 <HAL_TIM_OC_DelayElapsedCallback+0x82>
        (Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+2)%3]) &&
 8009d06:	1ca8      	adds	r0, r5, #2
 8009d08:	2103      	movs	r1, #3
 8009d0a:	f7fb ffc3 	bl	8005c94 <__aeabi_idivmod>
 8009d0e:	1861      	adds	r1, r4, r1
 8009d10:	31da      	adds	r1, #218	; 0xda
 8009d12:	31ff      	adds	r1, #255	; 0xff
      (Ports[PortNum].ud_index_current[Ports[PortNum].modulo] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3]) &&
 8009d14:	780b      	ldrb	r3, [r1, #0]
 8009d16:	42bb      	cmp	r3, r7
 8009d18:	d105      	bne.n	8009d26 <HAL_TIM_OC_DelayElapsedCallback+0x82>
        (Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+2)%3]) &&
 8009d1a:	2e05      	cmp	r6, #5
 8009d1c:	d903      	bls.n	8009d26 <HAL_TIM_OC_DelayElapsedCallback+0x82>
    ud->exed_flag = 3;
 8009d1e:	0023      	movs	r3, r4
 8009d20:	2203      	movs	r2, #3
 8009d22:	332c      	adds	r3, #44	; 0x2c
 8009d24:	701a      	strb	r2, [r3, #0]
  if (ud->exed_flag == 2)
 8009d26:	342c      	adds	r4, #44	; 0x2c
 8009d28:	7823      	ldrb	r3, [r4, #0]
 8009d2a:	2b02      	cmp	r3, #2
 8009d2c:	d102      	bne.n	8009d34 <HAL_TIM_OC_DelayElapsedCallback+0x90>
    PHY_HW_IF_RX_Stop(PortNum);
 8009d2e:	2000      	movs	r0, #0
 8009d30:	f7ff ff14 	bl	8009b5c <PHY_HW_IF_RX_Stop>
}
 8009d34:	b005      	add	sp, #20
 8009d36:	bdf0      	pop	{r4, r5, r6, r7, pc}
          curr_bit = (pbuff_in[ud->index]>>ud->offset) & 0x01;
 8009d38:	2701      	movs	r7, #1
        prev_bit = (pbuff_in[ud->index-1]>>7) & 0x01;
 8009d3a:	3a01      	subs	r2, #1
 8009d3c:	5cb0      	ldrb	r0, [r6, r2]
 8009d3e:	09c0      	lsrs	r0, r0, #7
        while (ud->offset < 8)
 8009d40:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8009d42:	2b07      	cmp	r3, #7
 8009d44:	d8b9      	bhi.n	8009cba <HAL_TIM_OC_DelayElapsedCallback+0x16>
          curr_bit = (pbuff_in[ud->index]>>ud->offset) & 0x01;
 8009d46:	7829      	ldrb	r1, [r5, #0]
 8009d48:	4119      	asrs	r1, r3
 8009d4a:	4039      	ands	r1, r7
          if (prev_bit == curr_bit)
 8009d4c:	4288      	cmp	r0, r1
 8009d4e:	d114      	bne.n	8009d7a <HAL_TIM_OC_DelayElapsedCallback+0xd6>
            if (curr_bit == 0)
 8009d50:	2800      	cmp	r0, #0
 8009d52:	d104      	bne.n	8009d5e <HAL_TIM_OC_DelayElapsedCallback+0xba>
              if (ud->offset == 0)
 8009d54:	2b00      	cmp	r3, #0
 8009d56:	d10d      	bne.n	8009d74 <HAL_TIM_OC_DelayElapsedCallback+0xd0>
                ud->offset = 7;
 8009d58:	3307      	adds	r3, #7
 8009d5a:	63e3      	str	r3, [r4, #60]	; 0x3c
                ud->index--;
 8009d5c:	63a2      	str	r2, [r4, #56]	; 0x38
            ud->preamble = 1;
 8009d5e:	0023      	movs	r3, r4
 8009d60:	2201      	movs	r2, #1
 8009d62:	332d      	adds	r3, #45	; 0x2d
 8009d64:	701a      	strb	r2, [r3, #0]
            preamble_offset = ud->offset;
 8009d66:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8009d68:	4b33      	ldr	r3, [pc, #204]	; (8009e38 <HAL_TIM_OC_DelayElapsedCallback+0x194>)
 8009d6a:	701a      	strb	r2, [r3, #0]
            preamble_index = ud->index;
 8009d6c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8009d6e:	4b33      	ldr	r3, [pc, #204]	; (8009e3c <HAL_TIM_OC_DelayElapsedCallback+0x198>)
        ud->exed_flag = 2;
 8009d70:	701a      	strb	r2, [r3, #0]
 8009d72:	e7a2      	b.n	8009cba <HAL_TIM_OC_DelayElapsedCallback+0x16>
                ud->offset--;
 8009d74:	3b01      	subs	r3, #1
 8009d76:	63e3      	str	r3, [r4, #60]	; 0x3c
 8009d78:	e7f1      	b.n	8009d5e <HAL_TIM_OC_DelayElapsedCallback+0xba>
          ud->offset++;
 8009d7a:	3301      	adds	r3, #1
 8009d7c:	63e3      	str	r3, [r4, #60]	; 0x3c
 8009d7e:	0008      	movs	r0, r1
 8009d80:	e7de      	b.n	8009d40 <HAL_TIM_OC_DelayElapsedCallback+0x9c>
 8009d82:	46c0      	nop			; (mov r8, r8)
      memcpy(&temp_data, &pbuff_in[ud->index], 3);
 8009d84:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 8009d86:	2203      	movs	r2, #3
 8009d88:	19f1      	adds	r1, r6, r7
 8009d8a:	a803      	add	r0, sp, #12
 8009d8c:	f002 fbf6 	bl	800c57c <memcpy>
      ud->index += ud->offset <= 5 ? 1 : 2;
 8009d90:	2205      	movs	r2, #5
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009d92:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8009d94:	9d03      	ldr	r5, [sp, #12]
      ud->index += ud->offset <= 5 ? 1 : 2;
 8009d96:	429a      	cmp	r2, r3
 8009d98:	4192      	sbcs	r2, r2
 8009d9a:	4252      	negs	r2, r2
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009d9c:	40dd      	lsrs	r5, r3
      ud->index += ud->offset <= 5 ? 1 : 2;
 8009d9e:	3201      	adds	r2, #1
 8009da0:	18bf      	adds	r7, r7, r2
      ud->offset = (ud->offset + 2) & 7;
 8009da2:	2207      	movs	r2, #7
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009da4:	05a9      	lsls	r1, r5, #22
      ud->offset = (ud->offset + 2) & 7;
 8009da6:	3302      	adds	r3, #2
 8009da8:	4013      	ands	r3, r2
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 8009daa:	0d89      	lsrs	r1, r1, #22
 8009dac:	9103      	str	r1, [sp, #12]
      ud->offset = (ud->offset + 2) & 7;
 8009dae:	63e3      	str	r3, [r4, #60]	; 0x3c
      if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate != NULL)
 8009db0:	23e4      	movs	r3, #228	; 0xe4
 8009db2:	005b      	lsls	r3, r3, #1
 8009db4:	58e3      	ldr	r3, [r4, r3]
      ud->index += ud->offset <= 5 ? 1 : 2;
 8009db6:	63a7      	str	r7, [r4, #56]	; 0x38
      if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate != NULL)
 8009db8:	2b00      	cmp	r3, #0
 8009dba:	d001      	beq.n	8009dc0 <HAL_TIM_OC_DelayElapsedCallback+0x11c>
        Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate(PortNum, temp_data);
 8009dbc:	2000      	movs	r0, #0
 8009dbe:	4798      	blx	r3
      if ((temp_data & 0x1F) == 0x0D) /* EOP */
 8009dc0:	231f      	movs	r3, #31
 8009dc2:	401d      	ands	r5, r3
 8009dc4:	2d0d      	cmp	r5, #13
 8009dc6:	d000      	beq.n	8009dca <HAL_TIM_OC_DelayElapsedCallback+0x126>
 8009dc8:	e777      	b.n	8009cba <HAL_TIM_OC_DelayElapsedCallback+0x16>
        ud->exed_flag = 2;
 8009dca:	0023      	movs	r3, r4
 8009dcc:	2202      	movs	r2, #2
 8009dce:	332c      	adds	r3, #44	; 0x2c
 8009dd0:	e7ce      	b.n	8009d70 <HAL_TIM_OC_DelayElapsedCallback+0xcc>
           ((RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR)>(ud->index + 2)) &&                /* checking if in the buffer the are enough data */
 8009dd2:	0022      	movs	r2, r4
 8009dd4:	213c      	movs	r1, #60	; 0x3c
 8009dd6:	32e8      	adds	r2, #232	; 0xe8
 8009dd8:	6812      	ldr	r2, [r2, #0]
 8009dda:	3302      	adds	r3, #2
 8009ddc:	6852      	ldr	r2, [r2, #4]
 8009dde:	1a8a      	subs	r2, r1, r2
         (ud->exed_flag == 0) &&
 8009de0:	429a      	cmp	r2, r3
 8009de2:	d800      	bhi.n	8009de6 <HAL_TIM_OC_DelayElapsedCallback+0x142>
 8009de4:	e770      	b.n	8009cc8 <HAL_TIM_OC_DelayElapsedCallback+0x24>
             (Ports[PortNum].htimcountrx.Instance->CNT < tim_count + DMA_TIME_TASK) &&
 8009de6:	0023      	movs	r3, r4
 8009de8:	33fc      	adds	r3, #252	; 0xfc
 8009dea:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009dec:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8009dee:	9b01      	ldr	r3, [sp, #4]
 8009df0:	3314      	adds	r3, #20
           ((RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR)>(ud->index + 2)) &&                /* checking if in the buffer the are enough data */
 8009df2:	429a      	cmp	r2, r3
 8009df4:	d300      	bcc.n	8009df8 <HAL_TIM_OC_DelayElapsedCallback+0x154>
 8009df6:	e767      	b.n	8009cc8 <HAL_TIM_OC_DelayElapsedCallback+0x24>
               (HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET)        /* stopping the decoding in case of NSS is high */
 8009df8:	2180      	movs	r1, #128	; 0x80
 8009dfa:	4811      	ldr	r0, [pc, #68]	; (8009e40 <HAL_TIM_OC_DelayElapsedCallback+0x19c>)
 8009dfc:	0149      	lsls	r1, r1, #5
 8009dfe:	f7fd fe15 	bl	8007a2c <HAL_GPIO_ReadPin>
             (Ports[PortNum].htimcountrx.Instance->CNT < tim_count + DMA_TIME_TASK) &&
 8009e02:	2800      	cmp	r0, #0
 8009e04:	d000      	beq.n	8009e08 <HAL_TIM_OC_DelayElapsedCallback+0x164>
 8009e06:	e75f      	b.n	8009cc8 <HAL_TIM_OC_DelayElapsedCallback+0x24>
    if (pbuff_in[ud->index]==0xFF)
 8009e08:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009e0a:	5cf3      	ldrb	r3, [r6, r3]
 8009e0c:	2bff      	cmp	r3, #255	; 0xff
 8009e0e:	d100      	bne.n	8009e12 <HAL_TIM_OC_DelayElapsedCallback+0x16e>
 8009e10:	46c0      	nop			; (mov r8, r8)
    if (!ud->preamble)                  /* The end of preamble hasn't identified yet */ 
 8009e12:	0023      	movs	r3, r4
 8009e14:	332d      	adds	r3, #45	; 0x2d
 8009e16:	781b      	ldrb	r3, [r3, #0]
 8009e18:	2b00      	cmp	r3, #0
 8009e1a:	d1b2      	bne.n	8009d82 <HAL_TIM_OC_DelayElapsedCallback+0xde>
      r = pbuff_in[ud->index]^0xAA;
 8009e1c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8009e1e:	3b56      	subs	r3, #86	; 0x56
 8009e20:	18b5      	adds	r5, r6, r2
 8009e22:	7829      	ldrb	r1, [r5, #0]
 8009e24:	404b      	eors	r3, r1
      if (r == 0x00 || r == 0xFF)       /* The end of preamble is not part of the received data */ 
 8009e26:	3b01      	subs	r3, #1
 8009e28:	b2db      	uxtb	r3, r3
 8009e2a:	2bfd      	cmp	r3, #253	; 0xfd
 8009e2c:	d984      	bls.n	8009d38 <HAL_TIM_OC_DelayElapsedCallback+0x94>
        ud->index++;
 8009e2e:	3201      	adds	r2, #1
 8009e30:	63a2      	str	r2, [r4, #56]	; 0x38
 8009e32:	e742      	b.n	8009cba <HAL_TIM_OC_DelayElapsedCallback+0x16>
 8009e34:	20000058 	.word	0x20000058
 8009e38:	20001ba4 	.word	0x20001ba4
 8009e3c:	20001ca4 	.word	0x20001ca4
 8009e40:	48000400 	.word	0x48000400

08009e44 <PHY_HW_IF_TX_Done>:
  if (Ports[PortNum].TxSpareBits == 0)
 8009e44:	23f0      	movs	r3, #240	; 0xf0
 8009e46:	005b      	lsls	r3, r3, #1
 8009e48:	4343      	muls	r3, r0
{
 8009e4a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (Ports[PortNum].TxSpareBits == 0)
 8009e4c:	4d5e      	ldr	r5, [pc, #376]	; (8009fc8 <PHY_HW_IF_TX_Done+0x184>)
{
 8009e4e:	0004      	movs	r4, r0
  if (Ports[PortNum].TxSpareBits == 0)
 8009e50:	18eb      	adds	r3, r5, r3
 8009e52:	001a      	movs	r2, r3
 8009e54:	322a      	adds	r2, #42	; 0x2a
 8009e56:	7812      	ldrb	r2, [r2, #0]
    while (((((Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL)) >> SPI_SR_FTLVL_Pos) & 0x03) > 1)
 8009e58:	2103      	movs	r1, #3
  if (Ports[PortNum].TxSpareBits == 0)
 8009e5a:	2a00      	cmp	r2, #0
 8009e5c:	d143      	bne.n	8009ee6 <PHY_HW_IF_TX_Done+0xa2>
 8009e5e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    if (Ports[PortNum].Device_cut == Cut_1)
 8009e60:	33d9      	adds	r3, #217	; 0xd9
 8009e62:	33ff      	adds	r3, #255	; 0xff
 8009e64:	7819      	ldrb	r1, [r3, #0]
 8009e66:	2903      	cmp	r1, #3
 8009e68:	d005      	beq.n	8009e76 <PHY_HW_IF_TX_Done+0x32>
      while ( (Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL) != 0);  /* != 0x0800 */
 8009e6a:	23c0      	movs	r3, #192	; 0xc0
 8009e6c:	015b      	lsls	r3, r3, #5
 8009e6e:	6891      	ldr	r1, [r2, #8]
 8009e70:	4219      	tst	r1, r3
 8009e72:	d1fc      	bne.n	8009e6e <PHY_HW_IF_TX_Done+0x2a>
 8009e74:	e004      	b.n	8009e80 <PHY_HW_IF_TX_Done+0x3c>
      while (((((Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL)) >> SPI_SR_FTLVL_Pos) & 0x03) > 1);
 8009e76:	6893      	ldr	r3, [r2, #8]
 8009e78:	0adb      	lsrs	r3, r3, #11
 8009e7a:	400b      	ands	r3, r1
 8009e7c:	2b01      	cmp	r3, #1
 8009e7e:	d8fa      	bhi.n	8009e76 <PHY_HW_IF_TX_Done+0x32>
  while ( (Ports[PortNum].hspi.Instance->SR & SPI_SR_BSY) > 0);
 8009e80:	23f0      	movs	r3, #240	; 0xf0
 8009e82:	005b      	lsls	r3, r3, #1
 8009e84:	001a      	movs	r2, r3
 8009e86:	4362      	muls	r2, r4
 8009e88:	18aa      	adds	r2, r5, r2
 8009e8a:	6c10      	ldr	r0, [r2, #64]	; 0x40
 8009e8c:	2280      	movs	r2, #128	; 0x80
 8009e8e:	6881      	ldr	r1, [r0, #8]
 8009e90:	4211      	tst	r1, r2
 8009e92:	d1fc      	bne.n	8009e8e <PHY_HW_IF_TX_Done+0x4a>
  if (Ports[PortNum].Device_cut == Cut_1)
 8009e94:	4363      	muls	r3, r4
 8009e96:	18eb      	adds	r3, r5, r3
 8009e98:	001a      	movs	r2, r3
 8009e9a:	32d9      	adds	r2, #217	; 0xd9
 8009e9c:	32ff      	adds	r2, #255	; 0xff
 8009e9e:	7812      	ldrb	r2, [r2, #0]
 8009ea0:	2a03      	cmp	r2, #3
 8009ea2:	d027      	beq.n	8009ef4 <PHY_HW_IF_TX_Done+0xb0>
 8009ea4:	2708      	movs	r7, #8
 8009ea6:	2c00      	cmp	r4, #0
 8009ea8:	d101      	bne.n	8009eae <PHY_HW_IF_TX_Done+0x6a>
 8009eaa:	4b48      	ldr	r3, [pc, #288]	; (8009fcc <PHY_HW_IF_TX_Done+0x188>)
 8009eac:	881f      	ldrh	r7, [r3, #0]
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 8009eae:	23f0      	movs	r3, #240	; 0xf0
 8009eb0:	2600      	movs	r6, #0
 8009eb2:	005b      	lsls	r3, r3, #1
 8009eb4:	4363      	muls	r3, r4
 8009eb6:	18eb      	adds	r3, r5, r3
 8009eb8:	332a      	adds	r3, #42	; 0x2a
 8009eba:	b2bf      	uxth	r7, r7
 8009ebc:	9301      	str	r3, [sp, #4]
 8009ebe:	9b01      	ldr	r3, [sp, #4]
 8009ec0:	781b      	ldrb	r3, [r3, #0]
 8009ec2:	42b3      	cmp	r3, r6
 8009ec4:	d933      	bls.n	8009f2e <PHY_HW_IF_TX_Done+0xea>
      while (!HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 8009ec6:	0039      	movs	r1, r7
 8009ec8:	4841      	ldr	r0, [pc, #260]	; (8009fd0 <PHY_HW_IF_TX_Done+0x18c>)
 8009eca:	f7fd fdaf 	bl	8007a2c <HAL_GPIO_ReadPin>
 8009ece:	2800      	cmp	r0, #0
 8009ed0:	d0f9      	beq.n	8009ec6 <PHY_HW_IF_TX_Done+0x82>
      while (HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 8009ed2:	0039      	movs	r1, r7
 8009ed4:	483e      	ldr	r0, [pc, #248]	; (8009fd0 <PHY_HW_IF_TX_Done+0x18c>)
 8009ed6:	f7fd fda9 	bl	8007a2c <HAL_GPIO_ReadPin>
 8009eda:	2800      	cmp	r0, #0
 8009edc:	d1f9      	bne.n	8009ed2 <PHY_HW_IF_TX_Done+0x8e>
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 8009ede:	3601      	adds	r6, #1
 8009ee0:	b2f6      	uxtb	r6, r6
 8009ee2:	e7ec      	b.n	8009ebe <PHY_HW_IF_TX_Done+0x7a>
 8009ee4:	46c0      	nop			; (mov r8, r8)
    while (((((Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL)) >> SPI_SR_FTLVL_Pos) & 0x03) > 1)
 8009ee6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8009ee8:	6892      	ldr	r2, [r2, #8]
 8009eea:	0ad2      	lsrs	r2, r2, #11
 8009eec:	400a      	ands	r2, r1
 8009eee:	2a01      	cmp	r2, #1
 8009ef0:	d8f8      	bhi.n	8009ee4 <PHY_HW_IF_TX_Done+0xa0>
 8009ef2:	e7c5      	b.n	8009e80 <PHY_HW_IF_TX_Done+0x3c>
 8009ef4:	332a      	adds	r3, #42	; 0x2a
 8009ef6:	781a      	ldrb	r2, [r3, #0]
    if (Ports[PortNum].TxSpareBits == 0)
 8009ef8:	2a00      	cmp	r2, #0
 8009efa:	d14f      	bne.n	8009f9c <PHY_HW_IF_TX_Done+0x158>
      Ports[PortNum].TxSpareBits = 7;
 8009efc:	3207      	adds	r2, #7
      Ports[PortNum].TxSpareBits = (Ports[PortNum].TxSpareBits - 1);
 8009efe:	701a      	strb	r2, [r3, #0]
 8009f00:	2608      	movs	r6, #8
 8009f02:	2c00      	cmp	r4, #0
 8009f04:	d101      	bne.n	8009f0a <PHY_HW_IF_TX_Done+0xc6>
 8009f06:	4b31      	ldr	r3, [pc, #196]	; (8009fcc <PHY_HW_IF_TX_Done+0x188>)
 8009f08:	881e      	ldrh	r6, [r3, #0]
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 8009f0a:	23f0      	movs	r3, #240	; 0xf0
{
 8009f0c:	2700      	movs	r7, #0
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 8009f0e:	005b      	lsls	r3, r3, #1
 8009f10:	4363      	muls	r3, r4
 8009f12:	18eb      	adds	r3, r5, r3
 8009f14:	332a      	adds	r3, #42	; 0x2a
 8009f16:	b2b6      	uxth	r6, r6
 8009f18:	9301      	str	r3, [sp, #4]
 8009f1a:	9b01      	ldr	r3, [sp, #4]
 8009f1c:	781b      	ldrb	r3, [r3, #0]
 8009f1e:	42bb      	cmp	r3, r7
 8009f20:	d83e      	bhi.n	8009fa0 <PHY_HW_IF_TX_Done+0x15c>
    while (HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 8009f22:	0031      	movs	r1, r6
 8009f24:	482a      	ldr	r0, [pc, #168]	; (8009fd0 <PHY_HW_IF_TX_Done+0x18c>)
 8009f26:	f7fd fd81 	bl	8007a2c <HAL_GPIO_ReadPin>
 8009f2a:	2800      	cmp	r0, #0
 8009f2c:	d1f9      	bne.n	8009f22 <PHY_HW_IF_TX_Done+0xde>
  STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_RESET);
 8009f2e:	2100      	movs	r1, #0
 8009f30:	0020      	movs	r0, r4
 8009f32:	f000 fee1 	bl	800acf8 <STUSB16xx_HW_IF_TX_EN_Status>
  __HAL_SPI_DISABLE(&Ports[PortNum].hspi);
 8009f36:	23f0      	movs	r3, #240	; 0xf0
 8009f38:	005b      	lsls	r3, r3, #1
 8009f3a:	001a      	movs	r2, r3
 8009f3c:	2040      	movs	r0, #64	; 0x40
 8009f3e:	4362      	muls	r2, r4
 8009f40:	18aa      	adds	r2, r5, r2
 8009f42:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8009f44:	6811      	ldr	r1, [r2, #0]
 8009f46:	4381      	bics	r1, r0
 8009f48:	6011      	str	r1, [r2, #0]
  while ((Ports[PortNum].hspi.Instance->SR & SPI_SR_FRLVL) != 0)
 8009f4a:	21c0      	movs	r1, #192	; 0xc0
 8009f4c:	00c9      	lsls	r1, r1, #3
 8009f4e:	6896      	ldr	r6, [r2, #8]
 8009f50:	400e      	ands	r6, r1
 8009f52:	d134      	bne.n	8009fbe <PHY_HW_IF_TX_Done+0x17a>
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 8009f54:	4363      	muls	r3, r4
 8009f56:	0018      	movs	r0, r3
 8009f58:	001f      	movs	r7, r3
 8009f5a:	3040      	adds	r0, #64	; 0x40
 8009f5c:	1828      	adds	r0, r5, r0
  if(Ports[PortNum].State==HAL_USBPD_PORT_STATE_BIST)
 8009f5e:	19ef      	adds	r7, r5, r7
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 8009f60:	f7fe fc1a 	bl	8008798 <HAL_SPI_DMAStop>
  if(Ports[PortNum].State==HAL_USBPD_PORT_STATE_BIST)
 8009f64:	7e7a      	ldrb	r2, [r7, #25]
 8009f66:	2a08      	cmp	r2, #8
 8009f68:	d12b      	bne.n	8009fc2 <PHY_HW_IF_TX_Done+0x17e>
    Ports[PortNum].State=HAL_USBPD_PORT_STATE_RESET;
 8009f6a:	767e      	strb	r6, [r7, #25]
    if ((Ports[PortNum].cbs.USBPD_HW_IF_BistCompleted != NULL) )
 8009f6c:	37c1      	adds	r7, #193	; 0xc1
 8009f6e:	37ff      	adds	r7, #255	; 0xff
 8009f70:	683b      	ldr	r3, [r7, #0]
 8009f72:	2b00      	cmp	r3, #0
 8009f74:	d002      	beq.n	8009f7c <PHY_HW_IF_TX_Done+0x138>
      Ports[PortNum].cbs.USBPD_HW_IF_BistCompleted(PortNum,USBPD_BIST_CARRIER_MODE2);
 8009f76:	2105      	movs	r1, #5
 8009f78:	0020      	movs	r0, r4
 8009f7a:	4798      	blx	r3
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_RX);
 8009f7c:	2101      	movs	r1, #1
 8009f7e:	0020      	movs	r0, r4
 8009f80:	f000 feac 	bl	800acdc <STUSB16xx_HW_IF_Switch_Mode>
  if (Ports[PortNum].cbs.USBPD_HW_IF_TxCompleted != NULL)
 8009f84:	23f0      	movs	r3, #240	; 0xf0
 8009f86:	005b      	lsls	r3, r3, #1
 8009f88:	4363      	muls	r3, r4
 8009f8a:	18ed      	adds	r5, r5, r3
 8009f8c:	35bd      	adds	r5, #189	; 0xbd
 8009f8e:	35ff      	adds	r5, #255	; 0xff
 8009f90:	682b      	ldr	r3, [r5, #0]
 8009f92:	2b00      	cmp	r3, #0
 8009f94:	d001      	beq.n	8009f9a <PHY_HW_IF_TX_Done+0x156>
    Ports[PortNum].cbs.USBPD_HW_IF_TxCompleted(PortNum);
 8009f96:	0020      	movs	r0, r4
 8009f98:	4798      	blx	r3
}
 8009f9a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
      Ports[PortNum].TxSpareBits = (Ports[PortNum].TxSpareBits - 1);
 8009f9c:	3a01      	subs	r2, #1
 8009f9e:	e7ae      	b.n	8009efe <PHY_HW_IF_TX_Done+0xba>
      while (HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 8009fa0:	0031      	movs	r1, r6
 8009fa2:	480b      	ldr	r0, [pc, #44]	; (8009fd0 <PHY_HW_IF_TX_Done+0x18c>)
 8009fa4:	f7fd fd42 	bl	8007a2c <HAL_GPIO_ReadPin>
 8009fa8:	2800      	cmp	r0, #0
 8009faa:	d1f9      	bne.n	8009fa0 <PHY_HW_IF_TX_Done+0x15c>
      while (!HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 8009fac:	0031      	movs	r1, r6
 8009fae:	4808      	ldr	r0, [pc, #32]	; (8009fd0 <PHY_HW_IF_TX_Done+0x18c>)
 8009fb0:	f7fd fd3c 	bl	8007a2c <HAL_GPIO_ReadPin>
 8009fb4:	2800      	cmp	r0, #0
 8009fb6:	d0f9      	beq.n	8009fac <PHY_HW_IF_TX_Done+0x168>
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 8009fb8:	3701      	adds	r7, #1
 8009fba:	b2ff      	uxtb	r7, r7
 8009fbc:	e7ad      	b.n	8009f1a <PHY_HW_IF_TX_Done+0xd6>
    dummyDR= *(__IO uint8_t *)&Ports[PortNum].hspi.Instance->DR;
 8009fbe:	7b10      	ldrb	r0, [r2, #12]
 8009fc0:	e7c5      	b.n	8009f4e <PHY_HW_IF_TX_Done+0x10a>
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_WAITING;
 8009fc2:	2205      	movs	r2, #5
 8009fc4:	767a      	strb	r2, [r7, #25]
 8009fc6:	e7d9      	b.n	8009f7c <PHY_HW_IF_TX_Done+0x138>
 8009fc8:	20000058 	.word	0x20000058
 8009fcc:	0800c874 	.word	0x0800c874
 8009fd0:	48000400 	.word	0x48000400

08009fd4 <HW_IF_CRC_Init>:
  hcrc.Instance = CRC;
 8009fd4:	4807      	ldr	r0, [pc, #28]	; (8009ff4 <HW_IF_CRC_Init+0x20>)
 8009fd6:	4b08      	ldr	r3, [pc, #32]	; (8009ff8 <HW_IF_CRC_Init+0x24>)
{
 8009fd8:	b510      	push	{r4, lr}
  hcrc.Instance = CRC;
 8009fda:	6003      	str	r3, [r0, #0]
 8009fdc:	2300      	movs	r3, #0
 8009fde:	8083      	strh	r3, [r0, #4]
  hcrc.Init.InputDataInversionMode =   CRC_INPUTDATA_INVERSION_BYTE;           /* The input data are inverted by WORD */
 8009fe0:	3320      	adds	r3, #32
 8009fe2:	6143      	str	r3, [r0, #20]
  hcrc.Init.OutputDataInversionMode =   CRC_OUTPUTDATA_INVERSION_ENABLE;        /* The output data are Bit-reversed format */
 8009fe4:	3360      	adds	r3, #96	; 0x60
 8009fe6:	6183      	str	r3, [r0, #24]
  hcrc.InputDataFormat =           CRC_INPUTDATA_FORMAT_BYTES;             /* The input data are 32 bits lenght */
 8009fe8:	3b7f      	subs	r3, #127	; 0x7f
 8009fea:	6203      	str	r3, [r0, #32]
  HAL_CRC_Init(&hcrc);
 8009fec:	f7fd fb1b 	bl	8007626 <HAL_CRC_Init>
}
 8009ff0:	bd10      	pop	{r4, pc}
 8009ff2:	46c0      	nop			; (mov r8, r8)
 8009ff4:	20001c00 	.word	0x20001c00
 8009ff8:	40023000 	.word	0x40023000

08009ffc <HW_IF_ADC_Init>:
{
 8009ffc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  usbpdm1_hadc.Instance = HW_IF_ADC;
 8009ffe:	4c17      	ldr	r4, [pc, #92]	; (800a05c <HW_IF_ADC_Init+0x60>)
 800a000:	4b17      	ldr	r3, [pc, #92]	; (800a060 <HW_IF_ADC_Init+0x64>)
  usbpdm1_hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 800a002:	2201      	movs	r2, #1
  usbpdm1_hadc.Instance = HW_IF_ADC;
 800a004:	6023      	str	r3, [r4, #0]
  usbpdm1_hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 800a006:	2104      	movs	r1, #4
  usbpdm1_hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 800a008:	2300      	movs	r3, #0
  HAL_ADC_Init(&usbpdm1_hadc);
 800a00a:	0020      	movs	r0, r4
  usbpdm1_hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 800a00c:	6122      	str	r2, [r4, #16]
  usbpdm1_hadc.Init.ContinuousConvMode = ENABLE;
 800a00e:	6222      	str	r2, [r4, #32]
  usbpdm1_hadc.Init.DMAContinuousRequests = ENABLE;
 800a010:	6322      	str	r2, [r4, #48]	; 0x30
  usbpdm1_hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 800a012:	6362      	str	r2, [r4, #52]	; 0x34
  usbpdm1_hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 800a014:	6063      	str	r3, [r4, #4]
  usbpdm1_hadc.Init.Resolution = ADC_RESOLUTION_12B;
 800a016:	60a3      	str	r3, [r4, #8]
  usbpdm1_hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 800a018:	60e3      	str	r3, [r4, #12]
  usbpdm1_hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 800a01a:	6161      	str	r1, [r4, #20]
  usbpdm1_hadc.Init.LowPowerAutoWait = DISABLE;
 800a01c:	61a3      	str	r3, [r4, #24]
  usbpdm1_hadc.Init.LowPowerAutoPowerOff = DISABLE;
 800a01e:	61e3      	str	r3, [r4, #28]
  usbpdm1_hadc.Init.DiscontinuousConvMode = DISABLE;
 800a020:	6263      	str	r3, [r4, #36]	; 0x24
  usbpdm1_hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 800a022:	62e3      	str	r3, [r4, #44]	; 0x2c
  HAL_ADC_Init(&usbpdm1_hadc);
 800a024:	f7fd f85c 	bl	80070e0 <HAL_ADC_Init>
  sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 800a028:	2380      	movs	r3, #128	; 0x80
 800a02a:	015b      	lsls	r3, r3, #5
 800a02c:	9302      	str	r3, [sp, #8]
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 800a02e:	2380      	movs	r3, #128	; 0x80
 800a030:	055b      	lsls	r3, r3, #21
 800a032:	9303      	str	r3, [sp, #12]
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a034:	230e      	movs	r3, #14
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a036:	a901      	add	r1, sp, #4
 800a038:	0020      	movs	r0, r4
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a03a:	9301      	str	r3, [sp, #4]
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a03c:	f7fd f98c 	bl	8007358 <HAL_ADC_ConfigChannel>
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a040:	2307      	movs	r3, #7
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a042:	a901      	add	r1, sp, #4
 800a044:	0020      	movs	r0, r4
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a046:	9301      	str	r3, [sp, #4]
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a048:	f7fd f986 	bl	8007358 <HAL_ADC_ConfigChannel>
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a04c:	230a      	movs	r3, #10
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a04e:	a901      	add	r1, sp, #4
 800a050:	0020      	movs	r0, r4
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a052:	9301      	str	r3, [sp, #4]
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a054:	f7fd f980 	bl	8007358 <HAL_ADC_ConfigChannel>
}
 800a058:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 800a05a:	46c0      	nop			; (mov r8, r8)
 800a05c:	20001ba8 	.word	0x20001ba8
 800a060:	40012400 	.word	0x40012400

0800a064 <USBPD_HW_IF_GlobalHwInit>:
{
 800a064:	b510      	push	{r4, lr}
  HW_IF_ADC_Init();
 800a066:	f7ff ffc9 	bl	8009ffc <HW_IF_ADC_Init>
  HAL_ADCEx_Calibration_Start(&usbpdm1_hadc);
 800a06a:	4c08      	ldr	r4, [pc, #32]	; (800a08c <USBPD_HW_IF_GlobalHwInit+0x28>)
 800a06c:	0020      	movs	r0, r4
 800a06e:	f7fd f9f3 	bl	8007458 <HAL_ADCEx_Calibration_Start>
  HAL_ADC_Start_DMA(&usbpdm1_hadc, ADCxConvertedValues, ADCCONVERTEDVALUES_BUFFER_SIZE);
 800a072:	2203      	movs	r2, #3
 800a074:	4906      	ldr	r1, [pc, #24]	; (800a090 <USBPD_HW_IF_GlobalHwInit+0x2c>)
 800a076:	0020      	movs	r0, r4
 800a078:	f7fd f8d6 	bl	8007228 <HAL_ADC_Start_DMA>
  HW_IF_CRC_Init();
 800a07c:	f7ff ffaa 	bl	8009fd4 <HW_IF_CRC_Init>
  HW_IF_PWR_DigitalGPIO_Init();
 800a080:	f000 f87a 	bl	800a178 <HW_IF_PWR_DigitalGPIO_Init>
  USBPD_TIM_Init();
 800a084:	f001 f8e8 	bl	800b258 <USBPD_TIM_Init>
}
 800a088:	bd10      	pop	{r4, pc}
 800a08a:	46c0      	nop			; (mov r8, r8)
 800a08c:	20001ba8 	.word	0x20001ba8
 800a090:	20001bf4 	.word	0x20001bf4

0800a094 <HW_IF_UnwrapData_Init>:
  ud->exed_flag =       0;
 800a094:	22f0      	movs	r2, #240	; 0xf0
 800a096:	0052      	lsls	r2, r2, #1
 800a098:	4342      	muls	r2, r0
 800a09a:	490a      	ldr	r1, [pc, #40]	; (800a0c4 <HW_IF_UnwrapData_Init+0x30>)
  ud->dataindex =       0;
 800a09c:	480a      	ldr	r0, [pc, #40]	; (800a0c8 <HW_IF_UnwrapData_Init+0x34>)
  ud->exed_flag =       0;
 800a09e:	2300      	movs	r3, #0
  ud->dataindex =       0;
 800a0a0:	1880      	adds	r0, r0, r2
  ud->exed_flag =       0;
 800a0a2:	1851      	adds	r1, r2, r1
  ud->index =           2;      /* It discards first two bytes */
 800a0a4:	2202      	movs	r2, #2
  ud->exed_flag =       0;
 800a0a6:	808b      	strh	r3, [r1, #4]
  ud->index =           2;      /* It discards first two bytes */
 800a0a8:	6382      	str	r2, [r0, #56]	; 0x38
  preamble_offset = 0;
 800a0aa:	4a08      	ldr	r2, [pc, #32]	; (800a0cc <HW_IF_UnwrapData_Init+0x38>)
  ud->dataindex =       0;
 800a0ac:	6303      	str	r3, [r0, #48]	; 0x30
  ud->dataoffset =      0;
 800a0ae:	6343      	str	r3, [r0, #52]	; 0x34
  ud->offset =          0;
 800a0b0:	63c3      	str	r3, [r0, #60]	; 0x3c
  preamble_offset = 0;
 800a0b2:	7013      	strb	r3, [r2, #0]
  preamble_index = 0;
 800a0b4:	4a06      	ldr	r2, [pc, #24]	; (800a0d0 <HW_IF_UnwrapData_Init+0x3c>)
 800a0b6:	7013      	strb	r3, [r2, #0]
  preamble_counter++;
 800a0b8:	4a06      	ldr	r2, [pc, #24]	; (800a0d4 <HW_IF_UnwrapData_Init+0x40>)
 800a0ba:	6813      	ldr	r3, [r2, #0]
 800a0bc:	3301      	adds	r3, #1
 800a0be:	6013      	str	r3, [r2, #0]
}
 800a0c0:	4770      	bx	lr
 800a0c2:	46c0      	nop			; (mov r8, r8)
 800a0c4:	20000080 	.word	0x20000080
 800a0c8:	20000058 	.word	0x20000058
 800a0cc:	20001ba4 	.word	0x20001ba4
 800a0d0:	20001ca4 	.word	0x20001ca4
 800a0d4:	200003d8 	.word	0x200003d8

0800a0d8 <PHY_HW_IF_RX_Start>:
{
 800a0d8:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset != NULL)
 800a0da:	25f0      	movs	r5, #240	; 0xf0
 800a0dc:	006d      	lsls	r5, r5, #1
 800a0de:	002b      	movs	r3, r5
 800a0e0:	4343      	muls	r3, r0
 800a0e2:	4e24      	ldr	r6, [pc, #144]	; (800a174 <PHY_HW_IF_RX_Start+0x9c>)
{
 800a0e4:	b085      	sub	sp, #20
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset != NULL)
 800a0e6:	18f3      	adds	r3, r6, r3
 800a0e8:	33c5      	adds	r3, #197	; 0xc5
 800a0ea:	33ff      	adds	r3, #255	; 0xff
 800a0ec:	681b      	ldr	r3, [r3, #0]
{
 800a0ee:	0004      	movs	r4, r0
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset != NULL)
 800a0f0:	2b00      	cmp	r3, #0
 800a0f2:	d000      	beq.n	800a0f6 <PHY_HW_IF_RX_Start+0x1e>
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset(PortNum);
 800a0f4:	4798      	blx	r3
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_RX;
 800a0f6:	2304      	movs	r3, #4
 800a0f8:	4365      	muls	r5, r4
 800a0fa:	9501      	str	r5, [sp, #4]
 800a0fc:	1975      	adds	r5, r6, r5
 800a0fe:	766b      	strb	r3, [r5, #25]
  HW_IF_UnwrapData_Init(PortNum);
 800a100:	0020      	movs	r0, r4
 800a102:	f7ff ffc7 	bl	800a094 <HW_IF_UnwrapData_Init>
    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a106:	9f01      	ldr	r7, [sp, #4]
 800a108:	3740      	adds	r7, #64	; 0x40
 800a10a:	19f7      	adds	r7, r6, r7
 800a10c:	0038      	movs	r0, r7
 800a10e:	f7fe fb43 	bl	8008798 <HAL_SPI_DMAStop>
  __IO uint32_t a = 0x0;
 800a112:	2300      	movs	r3, #0
 800a114:	9303      	str	r3, [sp, #12]
  while(local_hspi->Instance->SR & 0x01)
 800a116:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800a118:	2201      	movs	r2, #1
 800a11a:	689d      	ldr	r5, [r3, #8]
 800a11c:	4015      	ands	r5, r2
 800a11e:	d125      	bne.n	800a16c <PHY_HW_IF_RX_Start+0x94>
  memset(Ports[PortNum].pRxBuffPtr, 0x00, RX_BUFFER_SIZE);
 800a120:	23f0      	movs	r3, #240	; 0xf0
 800a122:	005b      	lsls	r3, r3, #1
 800a124:	435c      	muls	r4, r3
 800a126:	1934      	adds	r4, r6, r4
 800a128:	0029      	movs	r1, r5
 800a12a:	323b      	adds	r2, #59	; 0x3b
 800a12c:	68e0      	ldr	r0, [r4, #12]
 800a12e:	f002 fa2e 	bl	800c58e <memset>
  HAL_SPI_Receive_DMA(&Ports[PortNum].hspi, (uint8_t*)Ports[PortNum].pRxBuffPtr, RX_BUFFER_SIZE);
 800a132:	68e1      	ldr	r1, [r4, #12]
 800a134:	223c      	movs	r2, #60	; 0x3c
 800a136:	0038      	movs	r0, r7
 800a138:	f7fe fa7c 	bl	8008634 <HAL_SPI_Receive_DMA>
  Ports[PortNum].modulo = 0;
 800a13c:	0023      	movs	r3, r4
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a13e:	2101      	movs	r1, #1
  Ports[PortNum].modulo = 0;
 800a140:	33dd      	adds	r3, #221	; 0xdd
 800a142:	33ff      	adds	r3, #255	; 0xff
 800a144:	701d      	strb	r5, [r3, #0]
  Ports[PortNum].ud_index_current[0]=0;
 800a146:	3b03      	subs	r3, #3
 800a148:	701d      	strb	r5, [r3, #0]
  Ports[PortNum].ud_index_current[1]=0;
 800a14a:	705d      	strb	r5, [r3, #1]
  Ports[PortNum].ud_index_current[2]=0;
 800a14c:	709d      	strb	r5, [r3, #2]
  (Ports[PortNum].htimcountrx).Instance->CNT = 0;
 800a14e:	34fc      	adds	r4, #252	; 0xfc
 800a150:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a152:	9801      	ldr	r0, [sp, #4]
  (Ports[PortNum].htimcountrx).Instance->CNT = 0;
 800a154:	6255      	str	r5, [r2, #36]	; 0x24
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a156:	6953      	ldr	r3, [r2, #20]
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a158:	3079      	adds	r0, #121	; 0x79
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a15a:	430b      	orrs	r3, r1
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a15c:	30ff      	adds	r0, #255	; 0xff
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a15e:	6153      	str	r3, [r2, #20]
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a160:	1830      	adds	r0, r6, r0
 800a162:	0029      	movs	r1, r5
 800a164:	f7fe fe52 	bl	8008e0c <HAL_TIM_OC_Start_IT>
}
 800a168:	b005      	add	sp, #20
 800a16a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a = local_hspi->Instance->DR;
 800a16c:	68da      	ldr	r2, [r3, #12]
 800a16e:	9203      	str	r2, [sp, #12]
    UNUSED(a);
 800a170:	9a03      	ldr	r2, [sp, #12]
 800a172:	e7d1      	b.n	800a118 <PHY_HW_IF_RX_Start+0x40>
 800a174:	20000058 	.word	0x20000058

0800a178 <HW_IF_PWR_DigitalGPIO_Init>:
/**
  * @brief  Inititialization of the Power Pins.
  * @retval HAL Status
  */
HAL_StatusTypeDef HW_IF_PWR_DigitalGPIO_Init()
{
 800a178:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a17a:	2500      	movs	r5, #0
 800a17c:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef  GPIO_InitStruct;
  uint8_t index = 0;
  for(index=0;index<USBPD_POWSELn;index++)
  {
    USBPD_BSP_GPIOPins_TypeDef gpio = USBPD_POWSELs[index];
 800a17e:	ac02      	add	r4, sp, #8
 800a180:	0021      	movs	r1, r4
 800a182:	4b10      	ldr	r3, [pc, #64]	; (800a1c4 <HW_IF_PWR_DigitalGPIO_Init+0x4c>)
 800a184:	195a      	adds	r2, r3, r5
 800a186:	cac1      	ldmia	r2!, {r0, r6, r7}
 800a188:	c1c1      	stmia	r1!, {r0, r6, r7}
 800a18a:	58ee      	ldr	r6, [r5, r3]
 800a18c:	195b      	adds	r3, r3, r5
 800a18e:	889b      	ldrh	r3, [r3, #4]

    /* Configure the powsels pin */
    GPIO_InitStruct.Pin = gpio.GPIO_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a190:	2700      	movs	r7, #0
    USBPD_BSP_GPIOPins_TypeDef gpio = USBPD_POWSELs[index];
 800a192:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pin = gpio.GPIO_Pin;
 800a194:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a196:	2301      	movs	r3, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;

    HAL_GPIO_Init(gpio.GPIOx, &GPIO_InitStruct);
 800a198:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a19a:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(gpio.GPIOx, &GPIO_InitStruct);
 800a19c:	0030      	movs	r0, r6
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800a19e:	3302      	adds	r3, #2
 800a1a0:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a1a2:	9707      	str	r7, [sp, #28]
    HAL_GPIO_Init(gpio.GPIOx, &GPIO_InitStruct);
 800a1a4:	f7fd fb86 	bl	80078b4 <HAL_GPIO_Init>

    /* Turn the pin off */
    USBPD_HW_IF_GPIO_Off(gpio);
 800a1a8:	9b01      	ldr	r3, [sp, #4]
 800a1aa:	0030      	movs	r0, r6
 800a1ac:	80a3      	strh	r3, [r4, #4]
 800a1ae:	6861      	ldr	r1, [r4, #4]
 800a1b0:	68a2      	ldr	r2, [r4, #8]
 800a1b2:	350c      	adds	r5, #12
 800a1b4:	9602      	str	r6, [sp, #8]
 800a1b6:	f7ff fc87 	bl	8009ac8 <USBPD_HW_IF_GPIO_Off>
  for(index=0;index<USBPD_POWSELn;index++)
 800a1ba:	2d30      	cmp	r5, #48	; 0x30
 800a1bc:	d1df      	bne.n	800a17e <HW_IF_PWR_DigitalGPIO_Init+0x6>
  }

  return HAL_OK;
}
 800a1be:	0038      	movs	r0, r7
 800a1c0:	b00b      	add	sp, #44	; 0x2c
 800a1c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a1c4:	0800c81c 	.word	0x0800c81c

0800a1c8 <HW_IF_PWR_SetVoltage>:
   * |  0   |  1   |  0   |  0   | 15V  |
   * |  1   |  0   |  0   |  0   | 20V  |
   * +------+------+------+------+------+
   */

 switch (voltage)
 800a1c8:	4b2e      	ldr	r3, [pc, #184]	; (800a284 <HW_IF_PWR_SetVoltage+0xbc>)
{
 800a1ca:	b510      	push	{r4, lr}
 switch (voltage)
 800a1cc:	4299      	cmp	r1, r3
 800a1ce:	d03f      	beq.n	800a250 <HW_IF_PWR_SetVoltage+0x88>
 800a1d0:	d821      	bhi.n	800a216 <HW_IF_PWR_SetVoltage+0x4e>
 800a1d2:	4b2d      	ldr	r3, [pc, #180]	; (800a288 <HW_IF_PWR_SetVoltage+0xc0>)
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 0);
       break;
   case 9000:
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  1);
 800a1d4:	2201      	movs	r2, #1
 switch (voltage)
 800a1d6:	4299      	cmp	r1, r3
 800a1d8:	d000      	beq.n	800a1dc <HW_IF_PWR_SetVoltage+0x14>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a1da:	2200      	movs	r2, #0
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  1);
 800a1dc:	2180      	movs	r1, #128	; 0x80
 800a1de:	2090      	movs	r0, #144	; 0x90
 800a1e0:	0049      	lsls	r1, r1, #1
 800a1e2:	05c0      	lsls	r0, r0, #23
 800a1e4:	f7fd fc28 	bl	8007a38 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
 800a1e8:	2200      	movs	r2, #0
 800a1ea:	2180      	movs	r1, #128	; 0x80
 800a1ec:	2090      	movs	r0, #144	; 0x90
 800a1ee:	0089      	lsls	r1, r1, #2
 800a1f0:	05c0      	lsls	r0, r0, #23
 800a1f2:	f7fd fc21 	bl	8007a38 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
 800a1f6:	2200      	movs	r2, #0
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 0);
       break;
   case 15000:
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 1);
 800a1f8:	2180      	movs	r1, #128	; 0x80
 800a1fa:	2090      	movs	r0, #144	; 0x90
 800a1fc:	00c9      	lsls	r1, r1, #3
 800a1fe:	05c0      	lsls	r0, r0, #23
 800a200:	f7fd fc1a 	bl	8007a38 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 0);
 800a204:	2200      	movs	r2, #0
       break;
   case 20000:
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 1);
 800a206:	2180      	movs	r1, #128	; 0x80
 800a208:	2090      	movs	r0, #144	; 0x90
 800a20a:	0109      	lsls	r1, r1, #4
 800a20c:	05c0      	lsls	r0, r0, #23
 800a20e:	f7fd fc13 	bl	8007a38 <HAL_GPIO_WritePin>

  ret=(USBPD_StatusTypeDef)STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum),voltage);

#endif
  return ret;
}
 800a212:	2000      	movs	r0, #0
 800a214:	bd10      	pop	{r4, pc}
 switch (voltage)
 800a216:	4b1d      	ldr	r3, [pc, #116]	; (800a28c <HW_IF_PWR_SetVoltage+0xc4>)
 800a218:	4299      	cmp	r1, r3
 800a21a:	d022      	beq.n	800a262 <HW_IF_PWR_SetVoltage+0x9a>
 800a21c:	4b1c      	ldr	r3, [pc, #112]	; (800a290 <HW_IF_PWR_SetVoltage+0xc8>)
 800a21e:	4299      	cmp	r1, r3
 800a220:	d1db      	bne.n	800a1da <HW_IF_PWR_SetVoltage+0x12>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a222:	2180      	movs	r1, #128	; 0x80
 800a224:	2090      	movs	r0, #144	; 0x90
 800a226:	2200      	movs	r2, #0
 800a228:	0049      	lsls	r1, r1, #1
 800a22a:	05c0      	lsls	r0, r0, #23
 800a22c:	f7fd fc04 	bl	8007a38 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
 800a230:	2180      	movs	r1, #128	; 0x80
 800a232:	2090      	movs	r0, #144	; 0x90
 800a234:	2200      	movs	r2, #0
 800a236:	0089      	lsls	r1, r1, #2
 800a238:	05c0      	lsls	r0, r0, #23
 800a23a:	f7fd fbfd 	bl	8007a38 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
 800a23e:	2180      	movs	r1, #128	; 0x80
 800a240:	2090      	movs	r0, #144	; 0x90
 800a242:	2200      	movs	r2, #0
 800a244:	00c9      	lsls	r1, r1, #3
 800a246:	05c0      	lsls	r0, r0, #23
 800a248:	f7fd fbf6 	bl	8007a38 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 1);
 800a24c:	2201      	movs	r2, #1
 800a24e:	e7da      	b.n	800a206 <HW_IF_PWR_SetVoltage+0x3e>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a250:	2180      	movs	r1, #128	; 0x80
 800a252:	2090      	movs	r0, #144	; 0x90
 800a254:	2200      	movs	r2, #0
 800a256:	0049      	lsls	r1, r1, #1
 800a258:	05c0      	lsls	r0, r0, #23
 800a25a:	f7fd fbed 	bl	8007a38 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  1);
 800a25e:	2201      	movs	r2, #1
 800a260:	e7c3      	b.n	800a1ea <HW_IF_PWR_SetVoltage+0x22>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a262:	2180      	movs	r1, #128	; 0x80
 800a264:	2090      	movs	r0, #144	; 0x90
 800a266:	2200      	movs	r2, #0
 800a268:	0049      	lsls	r1, r1, #1
 800a26a:	05c0      	lsls	r0, r0, #23
 800a26c:	f7fd fbe4 	bl	8007a38 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
 800a270:	2180      	movs	r1, #128	; 0x80
 800a272:	2090      	movs	r0, #144	; 0x90
 800a274:	2200      	movs	r2, #0
 800a276:	0089      	lsls	r1, r1, #2
 800a278:	05c0      	lsls	r0, r0, #23
 800a27a:	f7fd fbdd 	bl	8007a38 <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 1);
 800a27e:	2201      	movs	r2, #1
 800a280:	e7ba      	b.n	800a1f8 <HW_IF_PWR_SetVoltage+0x30>
 800a282:	46c0      	nop			; (mov r8, r8)
 800a284:	00002ee0 	.word	0x00002ee0
 800a288:	00002328 	.word	0x00002328
 800a28c:	00003a98 	.word	0x00003a98
 800a290:	00004e20 	.word	0x00004e20

0800a294 <HW_IF_PWR_GetVoltage>:
uint16_t HW_IF_PWR_GetVoltage(uint8_t PortNum)
{
#ifdef __VVAR
   return (uint16_t)MVOLT(ADCxConvertedValues[VBUS_INDEX(PortNum)]);
#else
  return (uint16_t)(STUSB1602_VBUS_Select_Status_Get(STUSB1602_I2C_Add(PortNum)));
 800a294:	1e43      	subs	r3, r0, #1
 800a296:	4198      	sbcs	r0, r3
{
 800a298:	b510      	push	{r4, lr}
  return (uint16_t)(STUSB1602_VBUS_Select_Status_Get(STUSB1602_I2C_Add(PortNum)));
 800a29a:	3028      	adds	r0, #40	; 0x28
 800a29c:	f7fc fca8 	bl	8006bf0 <STUSB1602_VBUS_Select_Status_Get>
#endif
}
 800a2a0:	bd10      	pop	{r4, pc}

0800a2a2 <HW_IF_PWR_GetVoltage_from_reg>:
 800a2a2:	b510      	push	{r4, lr}
 800a2a4:	f7ff fff6 	bl	800a294 <HW_IF_PWR_GetVoltage>
 800a2a8:	bd10      	pop	{r4, pc}
	...

0800a2ac <HW_IF_PWR_Enable>:
  * @param  VconnState VCONN state
  * @param  role       Power role
  * @retval USBPD status
  */
HAL_StatusTypeDef HW_IF_PWR_Enable(uint8_t PortNum, USBPD_FunctionalState state, CCxPin_TypeDef Cc, uint32_t VconnState, USBPD_PortPowerRole_TypeDef role)
{
 800a2ac:	b570      	push	{r4, r5, r6, lr}
  HAL_StatusTypeDef ret = HAL_ERROR;
#if defined(CONF_NORMAL) || defined(CONF_DEMO_FPGA)
  uint32_t offset_port = (PortNum == 0) ? 0 : 2;
 800a2ae:	0004      	movs	r4, r0
    ret = HAL_OK; /* To allow compatibility with other type-c controllers */
  }

#ifdef CONF_NORMAL
  /* both pin are set off */
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a2b0:	260c      	movs	r6, #12
  uint32_t offset_port = (PortNum == 0) ? 0 : 2;
 800a2b2:	1e60      	subs	r0, r4, #1
 800a2b4:	4184      	sbcs	r4, r0
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a2b6:	0033      	movs	r3, r6
  uint32_t offset_port = (PortNum == 0) ? 0 : 2;
 800a2b8:	0064      	lsls	r4, r4, #1
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a2ba:	4363      	muls	r3, r4
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
 800a2bc:	3401      	adds	r4, #1
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a2be:	4d08      	ldr	r5, [pc, #32]	; (800a2e0 <HW_IF_PWR_Enable+0x34>)
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
 800a2c0:	4366      	muls	r6, r4
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a2c2:	5958      	ldr	r0, [r3, r5]
 800a2c4:	18eb      	adds	r3, r5, r3
 800a2c6:	6859      	ldr	r1, [r3, #4]
 800a2c8:	689a      	ldr	r2, [r3, #8]
 800a2ca:	f7ff fbfd 	bl	8009ac8 <USBPD_HW_IF_GPIO_Off>
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
 800a2ce:	5970      	ldr	r0, [r6, r5]
 800a2d0:	19ad      	adds	r5, r5, r6
 800a2d2:	6869      	ldr	r1, [r5, #4]
 800a2d4:	68aa      	ldr	r2, [r5, #8]
 800a2d6:	f7ff fbf7 	bl	8009ac8 <USBPD_HW_IF_GPIO_Off>
  /* set SEL1 according to the selected voltage and the table STCH2 Voltage Output */
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
#endif

  return ret;
}
 800a2da:	2000      	movs	r0, #0
 800a2dc:	bd70      	pop	{r4, r5, r6, pc}
 800a2de:	46c0      	nop			; (mov r8, r8)
 800a2e0:	0800c81c 	.word	0x0800c81c

0800a2e4 <HW_IF_PWR_VBUSIsEnabled>:
//  {
//    ret = (HAL_GPIO_ReadPin(USBPDM1_GPIOs[PWREN_P1].GPIOx, USBPDM1_GPIOs[PWREN_P1].GPIO_Pin) == GPIO_PIN_SET) ? USBPD_ENABLE : USBPD_DISABLE ;
//  }
//#endif
  return ret;
}
 800a2e4:	2000      	movs	r0, #0
 800a2e6:	4770      	bx	lr

0800a2e8 <LL_SYSCFG_SetEXTISource>:
{
 800a2e8:	b510      	push	{r4, lr}
  MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], SYSCFG_EXTICR1_EXTI0 << (Line >> 16), Port << (Line >> 16));
 800a2ea:	240f      	movs	r4, #15
 800a2ec:	b2cb      	uxtb	r3, r1
 800a2ee:	0c09      	lsrs	r1, r1, #16
 800a2f0:	408c      	lsls	r4, r1
 800a2f2:	4088      	lsls	r0, r1
 800a2f4:	4a03      	ldr	r2, [pc, #12]	; (800a304 <LL_SYSCFG_SetEXTISource+0x1c>)
 800a2f6:	009b      	lsls	r3, r3, #2
 800a2f8:	189b      	adds	r3, r3, r2
 800a2fa:	689a      	ldr	r2, [r3, #8]
 800a2fc:	43a2      	bics	r2, r4
 800a2fe:	4310      	orrs	r0, r2
 800a300:	6098      	str	r0, [r3, #8]
}
 800a302:	bd10      	pop	{r4, pc}
 800a304:	40010000 	.word	0x40010000

0800a308 <HW_IF_COMM_WAIT>:
{
  USBPD_StatusTypeDef ret = USBPD_ERROR;
  int16_t timeout = Timeout;
  while (1)
  {
    if (Ports[PortNum].CommLock == 0)
 800a308:	23f0      	movs	r3, #240	; 0xf0
 800a30a:	005b      	lsls	r3, r3, #1
 800a30c:	001a      	movs	r2, r3
 800a30e:	4342      	muls	r2, r0
{
 800a310:	b510      	push	{r4, lr}
    if (Ports[PortNum].CommLock == 0)
 800a312:	4c0b      	ldr	r4, [pc, #44]	; (800a340 <HW_IF_COMM_WAIT+0x38>)
 800a314:	18a2      	adds	r2, r4, r2
 800a316:	32d2      	adds	r2, #210	; 0xd2
 800a318:	32ff      	adds	r2, #255	; 0xff
 800a31a:	7812      	ldrb	r2, [r2, #0]
 800a31c:	2a00      	cmp	r2, #0
 800a31e:	d107      	bne.n	800a330 <HW_IF_COMM_WAIT+0x28>
    {
      /* the resource is free */
      Ports[PortNum].CommLock = 1;
 800a320:	2101      	movs	r1, #1
 800a322:	4343      	muls	r3, r0
      ret = USBPD_OK;
 800a324:	0010      	movs	r0, r2
      Ports[PortNum].CommLock = 1;
 800a326:	18e3      	adds	r3, r4, r3
 800a328:	33d2      	adds	r3, #210	; 0xd2
 800a32a:	33ff      	adds	r3, #255	; 0xff
 800a32c:	7019      	strb	r1, [r3, #0]
    {
      timeout--;
    }
  }
  return ret;
}
 800a32e:	bd10      	pop	{r4, pc}
    if (timeout == 0)
 800a330:	2900      	cmp	r1, #0
 800a332:	d002      	beq.n	800a33a <HW_IF_COMM_WAIT+0x32>
 800a334:	3901      	subs	r1, #1
 800a336:	b209      	sxth	r1, r1
 800a338:	e7f0      	b.n	800a31c <HW_IF_COMM_WAIT+0x14>
      ret = USBPD_TIMEOUT;
 800a33a:	2004      	movs	r0, #4
 800a33c:	e7f7      	b.n	800a32e <HW_IF_COMM_WAIT+0x26>
 800a33e:	46c0      	nop			; (mov r8, r8)
 800a340:	20000058 	.word	0x20000058

0800a344 <HW_IF_COMM_RELEASE>:
  * @param   PortNum The port index
  * @retval  USBPD status 
*/
static USBPD_StatusTypeDef HW_IF_COMM_RELEASE(uint8_t PortNum)
{
  if (Ports[PortNum].CommLock == 0)
 800a344:	23f0      	movs	r3, #240	; 0xf0
 800a346:	005b      	lsls	r3, r3, #1
 800a348:	4358      	muls	r0, r3
 800a34a:	4b05      	ldr	r3, [pc, #20]	; (800a360 <HW_IF_COMM_RELEASE+0x1c>)
 800a34c:	181b      	adds	r3, r3, r0
 800a34e:	33d2      	adds	r3, #210	; 0xd2
 800a350:	33ff      	adds	r3, #255	; 0xff
 800a352:	781a      	ldrb	r2, [r3, #0]
  {
    /* no change, the resource is already free */
    return USBPD_ERROR;
 800a354:	2002      	movs	r0, #2
  if (Ports[PortNum].CommLock == 0)
 800a356:	2a00      	cmp	r2, #0
 800a358:	d001      	beq.n	800a35e <HW_IF_COMM_RELEASE+0x1a>
  }

  /* release the resource */
  Ports[PortNum].CommLock = 0;
 800a35a:	2000      	movs	r0, #0
 800a35c:	7018      	strb	r0, [r3, #0]
  return USBPD_OK;
}
 800a35e:	4770      	bx	lr
 800a360:	20000058 	.word	0x20000058

0800a364 <LL_APB1_GRP2_EnableClock.constprop.7>:
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP2_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 800a364:	2001      	movs	r0, #1
 800a366:	4a05      	ldr	r2, [pc, #20]	; (800a37c <LL_APB1_GRP2_EnableClock.constprop.7+0x18>)
__STATIC_INLINE void LL_APB1_GRP2_EnableClock(uint32_t Periphs)
 800a368:	b082      	sub	sp, #8
  SET_BIT(RCC->APB2ENR, Periphs);
 800a36a:	6991      	ldr	r1, [r2, #24]
 800a36c:	4301      	orrs	r1, r0
 800a36e:	6191      	str	r1, [r2, #24]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 800a370:	6993      	ldr	r3, [r2, #24]
 800a372:	4003      	ands	r3, r0
 800a374:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 800a376:	9b01      	ldr	r3, [sp, #4]
}
 800a378:	b002      	add	sp, #8
 800a37a:	4770      	bx	lr
 800a37c:	40021000 	.word	0x40021000

0800a380 <USBPDM1_AssertRp>:
}
 800a380:	4770      	bx	lr

0800a382 <USBPDM1_DeAssertRp>:
 800a382:	4770      	bx	lr

0800a384 <USBPDM1_AssertRd>:
 800a384:	4770      	bx	lr

0800a386 <USBPDM1_DeAssertRd>:
 800a386:	4770      	bx	lr

0800a388 <USBPD_HW_IF_HR_Start>:
{
 800a388:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800a38a:	2164      	movs	r1, #100	; 0x64
{
 800a38c:	0006      	movs	r6, r0
 800a38e:	0017      	movs	r7, r2
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800a390:	f7ff ffba 	bl	800a308 <HW_IF_COMM_WAIT>
 800a394:	1e05      	subs	r5, r0, #0
  if (ret != USBPD_OK)
 800a396:	d144      	bne.n	800a422 <USBPD_HW_IF_HR_Start+0x9a>
  if (Ports[PortNum].Device_cut == Cut_1)
 800a398:	22f0      	movs	r2, #240	; 0xf0
 800a39a:	0052      	lsls	r2, r2, #1
 800a39c:	4372      	muls	r2, r6
 800a39e:	4b22      	ldr	r3, [pc, #136]	; (800a428 <USBPD_HW_IF_HR_Start+0xa0>)
 800a3a0:	189b      	adds	r3, r3, r2
 800a3a2:	33d9      	adds	r3, #217	; 0xd9
 800a3a4:	33ff      	adds	r3, #255	; 0xff
 800a3a6:	781b      	ldrb	r3, [r3, #0]
 800a3a8:	2b03      	cmp	r3, #3
 800a3aa:	d106      	bne.n	800a3ba <USBPD_HW_IF_HR_Start+0x32>
    STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Disable);
 800a3ac:	0030      	movs	r0, r6
 800a3ae:	1e43      	subs	r3, r0, #1
 800a3b0:	4198      	sbcs	r0, r3
 800a3b2:	2101      	movs	r1, #1
 800a3b4:	3028      	adds	r0, #40	; 0x28
 800a3b6:	f7fc fd37 	bl	8006e28 <STUSB1602_VBUS_Range_State_Set>
  STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000);
 800a3ba:	0034      	movs	r4, r6
 800a3bc:	1e63      	subs	r3, r4, #1
 800a3be:	419c      	sbcs	r4, r3
 800a3c0:	3428      	adds	r4, #40	; 0x28
 800a3c2:	491a      	ldr	r1, [pc, #104]	; (800a42c <USBPD_HW_IF_HR_Start+0xa4>)
 800a3c4:	0020      	movs	r0, r4
 800a3c6:	f7fc fc21 	bl	8006c0c <STUSB1602_VBUS_Select_Status_Set>
  ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), Mode == ACKNOWLEDGE ? PD_HARD_RESET_RECEIVED_REQ : PD_HARD_RESET_SEND_REQ);
 800a3ca:	0039      	movs	r1, r7
 800a3cc:	1e4b      	subs	r3, r1, #1
 800a3ce:	4199      	sbcs	r1, r3
 800a3d0:	0020      	movs	r0, r4
 800a3d2:	310e      	adds	r1, #14
 800a3d4:	f7fc fd6f 	bl	8006eb6 <STUSB1602_Type_C_Command>
 800a3d8:	0005      	movs	r5, r0
  if (Mode == ACKNOWLEDGE)
 800a3da:	2f00      	cmp	r7, #0
 800a3dc:	d105      	bne.n	800a3ea <USBPD_HW_IF_HR_Start+0x62>
 800a3de:	23c8      	movs	r3, #200	; 0xc8
 800a3e0:	46c0      	nop			; (mov r8, r8)
 800a3e2:	3b01      	subs	r3, #1
 800a3e4:	b29b      	uxth	r3, r3
    for(uint16_t i=0;i<200;i++)
 800a3e6:	2b00      	cmp	r3, #0
 800a3e8:	d1fa      	bne.n	800a3e0 <USBPD_HW_IF_HR_Start+0x58>
  if (ret == USBPD_OK)
 800a3ea:	2800      	cmp	r0, #0
 800a3ec:	d116      	bne.n	800a41c <USBPD_HW_IF_HR_Start+0x94>
  STUSB1602_CC_DETECTION_STATUS_Value = STUSB1602_CC_Detection_Status_Get(STUSB1602_I2C_Add(PortNum));
 800a3ee:	0020      	movs	r0, r4
 800a3f0:	f7fc faba 	bl	8006968 <STUSB1602_CC_Detection_Status_Get>
  if (STUSB1602_CC_DETECTION_STATUS_Value.b.CC_VCONN_SUPPLY_STATE == VCONN_supplied_on_unused_CC_pin)
 800a3f4:	2102      	movs	r1, #2
 800a3f6:	b2c7      	uxtb	r7, r0
 800a3f8:	420f      	tst	r7, r1
 800a3fa:	d003      	beq.n	800a404 <USBPD_HW_IF_HR_Start+0x7c>
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_TURN_OFF_VCONN_REQ);
 800a3fc:	0020      	movs	r0, r4
 800a3fe:	f7fc fd5a 	bl	8006eb6 <STUSB1602_Type_C_Command>
 800a402:	0005      	movs	r5, r0
      (((Power_Role_TypeDef)STUSB1602_CC_DETECTION_STATUS_Value.b.CC_POWER_ROLE == Source) &&
 800a404:	210c      	movs	r1, #12
 800a406:	4039      	ands	r1, r7
  if (
 800a408:	2908      	cmp	r1, #8
 800a40a:	d105      	bne.n	800a418 <USBPD_HW_IF_HR_Start+0x90>
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_PORT_CHANGE_2_DFP_REQ);
 800a40c:	3905      	subs	r1, #5
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_PORT_CHANGE_2_UFP_REQ);
 800a40e:	0020      	movs	r0, r4
 800a410:	f7fc fd51 	bl	8006eb6 <STUSB1602_Type_C_Command>
 800a414:	0005      	movs	r5, r0
 800a416:	e001      	b.n	800a41c <USBPD_HW_IF_HR_Start+0x94>
  if (
 800a418:	2904      	cmp	r1, #4
 800a41a:	d0f8      	beq.n	800a40e <USBPD_HW_IF_HR_Start+0x86>
  HW_IF_COMM_RELEASE(PortNum);
 800a41c:	0030      	movs	r0, r6
 800a41e:	f7ff ff91 	bl	800a344 <HW_IF_COMM_RELEASE>
}
 800a422:	0028      	movs	r0, r5
 800a424:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a426:	46c0      	nop			; (mov r8, r8)
 800a428:	20000058 	.word	0x20000058
 800a42c:	00001388 	.word	0x00001388

0800a430 <USBPD_HW_IF_HR_CheckVbusVSafe0V>:
{
 800a430:	b510      	push	{r4, lr}
  if (CurrentRole == USBPD_PORTPOWERROLE_SRC)
 800a432:	2901      	cmp	r1, #1
 800a434:	d102      	bne.n	800a43c <USBPD_HW_IF_HR_CheckVbusVSafe0V+0xc>
    return USBPD_OK;
 800a436:	2300      	movs	r3, #0
}
 800a438:	0018      	movs	r0, r3
 800a43a:	bd10      	pop	{r4, pc}
  return USBPD_ERROR;
 800a43c:	2302      	movs	r3, #2
  if (CurrentRole == USBPD_PORTPOWERROLE_SNK)
 800a43e:	2900      	cmp	r1, #0
 800a440:	d1fa      	bne.n	800a438 <USBPD_HW_IF_HR_CheckVbusVSafe0V+0x8>
    return STUSB1602_VBUS_Presence_Get(STUSB1602_I2C_Add(PortNum)) == VBUS_below_UVLO_threshold ? USBPD_OK : USBPD_BUSY;
 800a442:	1e43      	subs	r3, r0, #1
 800a444:	4198      	sbcs	r0, r3
 800a446:	3028      	adds	r0, #40	; 0x28
 800a448:	f7fc faba 	bl	80069c0 <STUSB1602_VBUS_Presence_Get>
 800a44c:	2800      	cmp	r0, #0
 800a44e:	d0f2      	beq.n	800a436 <USBPD_HW_IF_HR_CheckVbusVSafe0V+0x6>
 800a450:	2303      	movs	r3, #3
 800a452:	e7f1      	b.n	800a438 <USBPD_HW_IF_HR_CheckVbusVSafe0V+0x8>

0800a454 <USBPD_HW_IF_HR_End>:
{
 800a454:	b570      	push	{r4, r5, r6, lr}
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800a456:	2164      	movs	r1, #100	; 0x64
{
 800a458:	0006      	movs	r6, r0
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800a45a:	f7ff ff55 	bl	800a308 <HW_IF_COMM_WAIT>
 800a45e:	1e05      	subs	r5, r0, #0
  if (ret != USBPD_OK)
 800a460:	d113      	bne.n	800a48a <USBPD_HW_IF_HR_End+0x36>
  ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_COMPLETE_REQ);    
 800a462:	0034      	movs	r4, r6
 800a464:	1e63      	subs	r3, r4, #1
 800a466:	419c      	sbcs	r4, r3
 800a468:	3428      	adds	r4, #40	; 0x28
 800a46a:	2101      	movs	r1, #1
 800a46c:	0020      	movs	r0, r4
 800a46e:	f7fc fd22 	bl	8006eb6 <STUSB1602_Type_C_Command>
  ret = (USBPD_StatusTypeDef)STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000);
 800a472:	4907      	ldr	r1, [pc, #28]	; (800a490 <USBPD_HW_IF_HR_End+0x3c>)
 800a474:	0020      	movs	r0, r4
 800a476:	f7fc fbc9 	bl	8006c0c <STUSB1602_VBUS_Select_Status_Set>
  STUSB1602_CC_Detect_Alrt_Int_Mask_Set(STUSB1602_I2C_Add(PortNum), CC_Detect_Int_UNMASKED);
 800a47a:	2100      	movs	r1, #0
  ret = (USBPD_StatusTypeDef)STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000);
 800a47c:	0005      	movs	r5, r0
  STUSB1602_CC_Detect_Alrt_Int_Mask_Set(STUSB1602_I2C_Add(PortNum), CC_Detect_Int_UNMASKED);
 800a47e:	0020      	movs	r0, r4
 800a480:	f7fc fa4e 	bl	8006920 <STUSB1602_CC_Detect_Alrt_Int_Mask_Set>
  HW_IF_COMM_RELEASE(PortNum);
 800a484:	0030      	movs	r0, r6
 800a486:	f7ff ff5d 	bl	800a344 <HW_IF_COMM_RELEASE>
}
 800a48a:	0028      	movs	r0, r5
 800a48c:	bd70      	pop	{r4, r5, r6, pc}
 800a48e:	46c0      	nop			; (mov r8, r8)
 800a490:	00001388 	.word	0x00001388

0800a494 <USBPD_HW_IF_ErrorRecovery>:
{
 800a494:	b510      	push	{r4, lr}
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), SW_RST);
 800a496:	1e44      	subs	r4, r0, #1
 800a498:	41a0      	sbcs	r0, r4
 800a49a:	3028      	adds	r0, #40	; 0x28
 800a49c:	0004      	movs	r4, r0
 800a49e:	2101      	movs	r1, #1
 800a4a0:	f7fc fc01 	bl	8006ca6 <STUSB1602_SW_RESET_Set>
  HAL_Delay(27); // need to be 25ms min
 800a4a4:	201b      	movs	r0, #27
 800a4a6:	f7fc fdbf 	bl	8007028 <HAL_Delay>
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), No_SW_RST);
 800a4aa:	2100      	movs	r1, #0
 800a4ac:	0020      	movs	r0, r4
 800a4ae:	f7fc fbfa 	bl	8006ca6 <STUSB1602_SW_RESET_Set>
}
 800a4b2:	2000      	movs	r0, #0
 800a4b4:	bd10      	pop	{r4, pc}
	...

0800a4b8 <HW_IF_SPI_Init>:
  * @retval None
  */ 
void HW_IF_SPI_Init(uint8_t PortNum)
{
  /* Get the peripheral handler variable */
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800a4b8:	21f0      	movs	r1, #240	; 0xf0
 800a4ba:	0049      	lsls	r1, r1, #1
 800a4bc:	4341      	muls	r1, r0
{
 800a4be:	0002      	movs	r2, r0
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800a4c0:	0008      	movs	r0, r1
 800a4c2:	4b11      	ldr	r3, [pc, #68]	; (800a508 <HW_IF_SPI_Init+0x50>)
{
 800a4c4:	b510      	push	{r4, lr}
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800a4c6:	3040      	adds	r0, #64	; 0x40
  
  phspi->Instance =           SPI_Instance(PortNum);
 800a4c8:	4254      	negs	r4, r2
 800a4ca:	4162      	adcs	r2, r4
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800a4cc:	18c0      	adds	r0, r0, r3
  phspi->Instance =           SPI_Instance(PortNum);
 800a4ce:	185b      	adds	r3, r3, r1
  phspi->Init.Mode =           SPI_MODE_SLAVE;
  phspi->Init.Direction =  SPI_DIRECTION_2LINES;
  phspi->Init.DataSize =   SPI_DATASIZE_8BIT;
 800a4d0:	21e0      	movs	r1, #224	; 0xe0
  phspi->Instance =           SPI_Instance(PortNum);
 800a4d2:	4c0e      	ldr	r4, [pc, #56]	; (800a50c <HW_IF_SPI_Init+0x54>)
 800a4d4:	4252      	negs	r2, r2
 800a4d6:	4022      	ands	r2, r4
  phspi->Init.DataSize =   SPI_DATASIZE_8BIT;
 800a4d8:	00c9      	lsls	r1, r1, #3
  phspi->Instance =           SPI_Instance(PortNum);
 800a4da:	4c0d      	ldr	r4, [pc, #52]	; (800a510 <HW_IF_SPI_Init+0x58>)
  phspi->Init.DataSize =   SPI_DATASIZE_8BIT;
 800a4dc:	64d9      	str	r1, [r3, #76]	; 0x4c
  phspi->Init.CLKPolarity =     SPI_POLARITY_HIGH;
 800a4de:	2102      	movs	r1, #2
  phspi->Instance =           SPI_Instance(PortNum);
 800a4e0:	1912      	adds	r2, r2, r4
 800a4e2:	641a      	str	r2, [r3, #64]	; 0x40
  phspi->Init.Mode =           SPI_MODE_SLAVE;
 800a4e4:	2200      	movs	r2, #0
  phspi->Init.CLKPolarity =     SPI_POLARITY_HIGH;
 800a4e6:	6519      	str	r1, [r3, #80]	; 0x50
  phspi->Init.CLKPhase =   SPI_PHASE_1EDGE;
  phspi->Init.NSS =     SPI_NSS_HARD_INPUT;
  phspi->Init.FirstBit =   SPI_FIRSTBIT_LSB;
 800a4e8:	317e      	adds	r1, #126	; 0x7e
 800a4ea:	6619      	str	r1, [r3, #96]	; 0x60
  phspi->Init.TIMode =     SPI_TIMODE_DISABLE;
  phspi->Init.CRCCalculation =  SPI_CRCCALCULATION_DISABLE;
  phspi->Init.CRCPolynomial =   7;
 800a4ec:	3979      	subs	r1, #121	; 0x79
  phspi->Init.Mode =           SPI_MODE_SLAVE;
 800a4ee:	645a      	str	r2, [r3, #68]	; 0x44
  phspi->Init.Direction =  SPI_DIRECTION_2LINES;
 800a4f0:	649a      	str	r2, [r3, #72]	; 0x48
  phspi->Init.CLKPhase =   SPI_PHASE_1EDGE;
 800a4f2:	655a      	str	r2, [r3, #84]	; 0x54
  phspi->Init.NSS =     SPI_NSS_HARD_INPUT;
 800a4f4:	659a      	str	r2, [r3, #88]	; 0x58
  phspi->Init.TIMode =     SPI_TIMODE_DISABLE;
 800a4f6:	665a      	str	r2, [r3, #100]	; 0x64
  phspi->Init.CRCCalculation =  SPI_CRCCALCULATION_DISABLE;
 800a4f8:	669a      	str	r2, [r3, #104]	; 0x68
  phspi->Init.CRCPolynomial =   7;
 800a4fa:	66d9      	str	r1, [r3, #108]	; 0x6c
  phspi->Init.CRCLength =   SPI_CRC_LENGTH_DATASIZE;
 800a4fc:	671a      	str	r2, [r3, #112]	; 0x70
  phspi->Init.NSSPMode =   SPI_NSS_PULSE_DISABLE;
 800a4fe:	675a      	str	r2, [r3, #116]	; 0x74
  
  HAL_SPI_Init(phspi);
 800a500:	f7fd feca 	bl	8008298 <HAL_SPI_Init>
}
 800a504:	bd10      	pop	{r4, pc}
 800a506:	46c0      	nop			; (mov r8, r8)
 800a508:	20000058 	.word	0x20000058
 800a50c:	ffff0800 	.word	0xffff0800
 800a510:	40013000 	.word	0x40013000

0800a514 <HW_IF_SPI_Mode>:
  * @param  PortNum The port index
  * @param  mode Two allowed values: STUSB16xx_SPI_Mode_TX or STUSB16xx_SPI_Mode_RX
  * @retval None
  */ 
void HW_IF_SPI_Mode(uint8_t PortNum, STUSB1602_SPI_Mode_TypeDef mode)
{
 800a514:	b570      	push	{r4, r5, r6, lr}
  /* Stop the SPI DMA before changing SPI mode */
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a516:	25f0      	movs	r5, #240	; 0xf0
 800a518:	006d      	lsls	r5, r5, #1
 800a51a:	4345      	muls	r5, r0
 800a51c:	0028      	movs	r0, r5
 800a51e:	4e1d      	ldr	r6, [pc, #116]	; (800a594 <HW_IF_SPI_Mode+0x80>)
 800a520:	3040      	adds	r0, #64	; 0x40
 800a522:	1980      	adds	r0, r0, r6
{
 800a524:	000c      	movs	r4, r1
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a526:	f7fe f937 	bl	8008798 <HAL_SPI_DMAStop>
  
  /* Disable SPI peripheral */
  __HAL_SPI_DISABLE(&Ports[PortNum].hspi);
 800a52a:	2140      	movs	r1, #64	; 0x40
 800a52c:	1970      	adds	r0, r6, r5
 800a52e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800a530:	681a      	ldr	r2, [r3, #0]
 800a532:	438a      	bics	r2, r1
 800a534:	601a      	str	r2, [r3, #0]
  
  CR1Value = phspi->Instance->CR1;
  
  /* If cut 1.2 is used, SPI is configured to sample data
     on rising edge on TX phase as well as on falling edge on RX phase */
  if (Ports[PortNum].Device_cut== Cut_1)
 800a536:	0002      	movs	r2, r0
 800a538:	32d9      	adds	r2, #217	; 0xd9
 800a53a:	32ff      	adds	r2, #255	; 0xff
 800a53c:	7812      	ldrb	r2, [r2, #0]
  CR1Value = phspi->Instance->CR1;
 800a53e:	6819      	ldr	r1, [r3, #0]
  if (Ports[PortNum].Device_cut== Cut_1)
 800a540:	2a03      	cmp	r2, #3
 800a542:	d110      	bne.n	800a566 <HW_IF_SPI_Mode+0x52>
  {  
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^mode)&1;
 800a544:	2501      	movs	r5, #1
 800a546:	0849      	lsrs	r1, r1, #1
    phspi->Instance->CR1 &= ~1;
 800a548:	681a      	ldr	r2, [r3, #0]
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^mode)&1;
 800a54a:	4029      	ands	r1, r5
 800a54c:	4061      	eors	r1, r4
    phspi->Instance->CR1 &= ~1;
 800a54e:	43aa      	bics	r2, r5
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^mode)&1;
 800a550:	4029      	ands	r1, r5
 800a552:	6541      	str	r1, [r0, #84]	; 0x54
    phspi->Instance->CR1 &= ~1;
 800a554:	601a      	str	r2, [r3, #0]
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^mode)&1;
 800a556:	681a      	ldr	r2, [r3, #0]
    phspi->Instance->CR1 &= ~1;
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^1)&1;

    /* SPI NSS software or hardware according to the mode value */
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800a558:	4311      	orrs	r1, r2
 800a55a:	6019      	str	r1, [r3, #0]
  }
  
  /* Enable SPI peripheral */
  __HAL_SPI_ENABLE(&Ports[PortNum].hspi);
 800a55c:	2240      	movs	r2, #64	; 0x40
 800a55e:	6819      	ldr	r1, [r3, #0]
 800a560:	430a      	orrs	r2, r1
 800a562:	601a      	str	r2, [r3, #0]
}
 800a564:	bd70      	pop	{r4, r5, r6, pc}
  if (Ports[PortNum].Device_cut == Cut_1_A)
 800a566:	2a04      	cmp	r2, #4
 800a568:	d1f8      	bne.n	800a55c <HW_IF_SPI_Mode+0x48>
 800a56a:	2501      	movs	r5, #1
 800a56c:	002e      	movs	r6, r5
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^1)&1;
 800a56e:	0849      	lsrs	r1, r1, #1
 800a570:	438e      	bics	r6, r1
    phspi->Instance->CR1 &= ~1;
 800a572:	6819      	ldr	r1, [r3, #0]
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^1)&1;
 800a574:	6546      	str	r6, [r0, #84]	; 0x54
    phspi->Instance->CR1 &= ~1;
 800a576:	43a9      	bics	r1, r5
 800a578:	6019      	str	r1, [r3, #0]
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^1)&1;
 800a57a:	681a      	ldr	r2, [r3, #0]
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800a57c:	4906      	ldr	r1, [pc, #24]	; (800a598 <HW_IF_SPI_Mode+0x84>)
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^1)&1;
 800a57e:	4332      	orrs	r2, r6
 800a580:	601a      	str	r2, [r3, #0]
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800a582:	681a      	ldr	r2, [r3, #0]
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800a584:	402c      	ands	r4, r5
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800a586:	400a      	ands	r2, r1
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800a588:	4261      	negs	r1, r4
 800a58a:	4161      	adcs	r1, r4
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800a58c:	601a      	str	r2, [r3, #0]
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800a58e:	681a      	ldr	r2, [r3, #0]
 800a590:	0249      	lsls	r1, r1, #9
 800a592:	e7e1      	b.n	800a558 <HW_IF_SPI_Mode+0x44>
 800a594:	20000058 	.word	0x20000058
 800a598:	fffffdff 	.word	0xfffffdff

0800a59c <HW_IF_DMA_Init>:
  * @brief  DMA init function
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_DMA_Init(uint8_t PortNum)
{
 800a59c:	b507      	push	{r0, r1, r2, lr}
 800a59e:	2201      	movs	r2, #1
 800a5a0:	4b09      	ldr	r3, [pc, #36]	; (800a5c8 <HW_IF_DMA_Init+0x2c>)
  /* DMA controller clock enable */
  DMA_CLK_ENABLE(PortNum);
 800a5a2:	6959      	ldr	r1, [r3, #20]
 800a5a4:	4311      	orrs	r1, r2
 800a5a6:	6159      	str	r1, [r3, #20]
 800a5a8:	695b      	ldr	r3, [r3, #20]
 800a5aa:	401a      	ands	r2, r3
 800a5ac:	2800      	cmp	r0, #0
 800a5ae:	d107      	bne.n	800a5c0 <HW_IF_DMA_Init+0x24>
 800a5b0:	9200      	str	r2, [sp, #0]
 800a5b2:	9b00      	ldr	r3, [sp, #0]

  /* NVIC configuration for DMA */
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800a5b4:	300b      	adds	r0, #11
 800a5b6:	2200      	movs	r2, #0
 800a5b8:	0011      	movs	r1, r2
 800a5ba:	f7fc ffa1 	bl	8007500 <HAL_NVIC_SetPriority>
}
 800a5be:	bd07      	pop	{r0, r1, r2, pc}
  DMA_CLK_ENABLE(PortNum);
 800a5c0:	9201      	str	r2, [sp, #4]
 800a5c2:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800a5c4:	200a      	movs	r0, #10
 800a5c6:	e7f6      	b.n	800a5b6 <HW_IF_DMA_Init+0x1a>
 800a5c8:	40021000 	.word	0x40021000

0800a5cc <HW_IF_STUSB16xx_I2C_Init>:
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_STUSB16xx_I2C_Init(uint8_t PortNum)
{
  I2C_HandleTypeDef*           phi2c = &(Ports[PortNum].hi2c);
 800a5cc:	23f0      	movs	r3, #240	; 0xf0
 800a5ce:	005b      	lsls	r3, r3, #1
 800a5d0:	4358      	muls	r0, r3
{
 800a5d2:	b570      	push	{r4, r5, r6, lr}
  I2C_HandleTypeDef*           phi2c = &(Ports[PortNum].hi2c);
 800a5d4:	0004      	movs	r4, r0
 800a5d6:	4b0d      	ldr	r3, [pc, #52]	; (800a60c <HW_IF_STUSB16xx_I2C_Init+0x40>)
 800a5d8:	342d      	adds	r4, #45	; 0x2d
 800a5da:	34ff      	adds	r4, #255	; 0xff
 800a5dc:	18e4      	adds	r4, r4, r3
  
  phi2c->Instance = I2C_INSTANCE(PortNum);
 800a5de:	1818      	adds	r0, r3, r0
 800a5e0:	4b0b      	ldr	r3, [pc, #44]	; (800a610 <HW_IF_STUSB16xx_I2C_Init+0x44>)
 800a5e2:	30fc      	adds	r0, #252	; 0xfc
 800a5e4:	6303      	str	r3, [r0, #48]	; 0x30
  phi2c->Init.Timing =  I2C_TIMING(PortNum); 
 800a5e6:	4b0b      	ldr	r3, [pc, #44]	; (800a614 <HW_IF_STUSB16xx_I2C_Init+0x48>)
  phi2c->Init.OwnAddress1 = 0;
 800a5e8:	2500      	movs	r5, #0
  phi2c->Init.Timing =  I2C_TIMING(PortNum); 
 800a5ea:	6343      	str	r3, [r0, #52]	; 0x34
  phi2c->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800a5ec:	2301      	movs	r3, #1
  phi2c->Init.OwnAddress1 = 0;
 800a5ee:	6385      	str	r5, [r0, #56]	; 0x38
  phi2c->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800a5f0:	63c3      	str	r3, [r0, #60]	; 0x3c
  phi2c->Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 800a5f2:	6405      	str	r5, [r0, #64]	; 0x40
  phi2c->Init.OwnAddress2 = 0;
 800a5f4:	6445      	str	r5, [r0, #68]	; 0x44
  phi2c->Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 800a5f6:	6485      	str	r5, [r0, #72]	; 0x48
  phi2c->Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 800a5f8:	64c5      	str	r5, [r0, #76]	; 0x4c
  phi2c->Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 800a5fa:	6505      	str	r5, [r0, #80]	; 0x50

  HAL_I2C_Init(phi2c);
 800a5fc:	0020      	movs	r0, r4
 800a5fe:	f7fd fb77 	bl	8007cf0 <HAL_I2C_Init>
  
  HAL_I2CEx_ConfigAnalogFilter(phi2c, I2C_ANALOGFILTER_ENABLE);
 800a602:	0029      	movs	r1, r5
 800a604:	0020      	movs	r0, r4
 800a606:	f7fd fd41 	bl	800808c <HAL_I2CEx_ConfigAnalogFilter>
}
 800a60a:	bd70      	pop	{r4, r5, r6, pc}
 800a60c:	20000058 	.word	0x20000058
 800a610:	40005800 	.word	0x40005800
 800a614:	20100917 	.word	0x20100917

0800a618 <HW_IF_STUSB1602_IO_Init>:
  * @brief  Configuration of STUSB1602 GPIO pins
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_STUSB1602_IO_Init(uint8_t PortNum)
{
 800a618:	b530      	push	{r4, r5, lr}
  GPIO_InitTypeDef GPIO_InitStruct;

  /* Configure GPIO pin : ALERT */
  GPIO_InitStruct.Pin = ALERT_GPIO_PIN(PortNum);
 800a61a:	2302      	movs	r3, #2
{
 800a61c:	b087      	sub	sp, #28
 800a61e:	1e04      	subs	r4, r0, #0
  GPIO_InitStruct.Pin = ALERT_GPIO_PIN(PortNum);
 800a620:	d000      	beq.n	800a624 <HW_IF_STUSB1602_IO_Init+0xc>
 800a622:	18db      	adds	r3, r3, r3
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(ALERT_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800a624:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a626:	2500      	movs	r5, #0
  GPIO_InitStruct.Pin = ALERT_GPIO_PIN(PortNum);
 800a628:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800a62a:	4b2a      	ldr	r3, [pc, #168]	; (800a6d4 <HW_IF_STUSB1602_IO_Init+0xbc>)
  HAL_GPIO_Init(ALERT_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800a62c:	a901      	add	r1, sp, #4
 800a62e:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800a630:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a632:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(ALERT_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800a634:	f7fd f93e 	bl	80078b4 <HAL_GPIO_Init>
  
  /* Configure GPIO pin : A_B_SIDE */
  GPIO_InitStruct.Pin = A_B_Side_GPIO_PIN(PortNum);
 800a638:	2301      	movs	r3, #1
 800a63a:	42ac      	cmp	r4, r5
 800a63c:	d000      	beq.n	800a640 <HW_IF_STUSB1602_IO_Init+0x28>
 800a63e:	3307      	adds	r3, #7
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(A_B_Side_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800a640:	2090      	movs	r0, #144	; 0x90
 800a642:	a901      	add	r1, sp, #4
 800a644:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = A_B_Side_GPIO_PIN(PortNum);
 800a646:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800a648:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a64a:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(A_B_Side_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800a64c:	f7fd f932 	bl	80078b4 <HAL_GPIO_Init>

  /* Configure GPIO pin : TX_EN */
  GPIO_InitStruct.Pin = TX_EN_GPIO_PIN(PortNum);
 800a650:	2304      	movs	r3, #4
 800a652:	2c00      	cmp	r4, #0
 800a654:	d000      	beq.n	800a658 <HW_IF_STUSB1602_IO_Init+0x40>
 800a656:	18db      	adds	r3, r3, r3
 800a658:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a65a:	2501      	movs	r5, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a65c:	2300      	movs	r3, #0
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(TX_EN_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800a65e:	a901      	add	r1, sp, #4
 800a660:	481d      	ldr	r0, [pc, #116]	; (800a6d8 <HW_IF_STUSB1602_IO_Init+0xc0>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a662:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800a664:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a666:	9502      	str	r5, [sp, #8]
  HAL_GPIO_Init(TX_EN_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800a668:	f7fd f924 	bl	80078b4 <HAL_GPIO_Init>
  
  /* Configure GPIO pins : RESET */
  GPIO_InitStruct.Pin = RESET_GPIO_PIN(PortNum);
 800a66c:	2340      	movs	r3, #64	; 0x40
 800a66e:	2c00      	cmp	r4, #0
 800a670:	d000      	beq.n	800a674 <HW_IF_STUSB1602_IO_Init+0x5c>
 800a672:	18db      	adds	r3, r3, r3
 800a674:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(RESET_GPIO_PORT(PortNum), &GPIO_InitStruct);

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(ALERT_GPIO_IRQHANDLER(PortNum), ALERT_GPIO_IRQPRIORITY(PortNum), 0);
 800a676:	1e63      	subs	r3, r4, #1
 800a678:	419c      	sbcs	r4, r3
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a67a:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a67c:	2500      	movs	r5, #0
  HAL_GPIO_Init(RESET_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800a67e:	a901      	add	r1, sp, #4
  HAL_NVIC_SetPriority(ALERT_GPIO_IRQHANDLER(PortNum), ALERT_GPIO_IRQPRIORITY(PortNum), 0);
 800a680:	3405      	adds	r4, #5
  HAL_GPIO_Init(RESET_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800a682:	4815      	ldr	r0, [pc, #84]	; (800a6d8 <HW_IF_STUSB1602_IO_Init+0xc0>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a684:	9503      	str	r5, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800a686:	9504      	str	r5, [sp, #16]
  HAL_GPIO_Init(RESET_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800a688:	f7fd f914 	bl	80078b4 <HAL_GPIO_Init>
  HAL_NVIC_SetPriority(ALERT_GPIO_IRQHANDLER(PortNum), ALERT_GPIO_IRQPRIORITY(PortNum), 0);
 800a68c:	002a      	movs	r2, r5
 800a68e:	2101      	movs	r1, #1
 800a690:	0020      	movs	r0, r4
 800a692:	f7fc ff35 	bl	8007500 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(ALERT_GPIO_IRQHANDLER(PortNum));
 800a696:	0020      	movs	r0, r4
 800a698:	f7fc ff5c 	bl	8007554 <HAL_NVIC_EnableIRQ>
 
  /* pin for ADC*/
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_4;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a69c:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800a69e:	2403      	movs	r4, #3
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_4;
 800a6a0:	2390      	movs	r3, #144	; 0x90
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a6a2:	a901      	add	r1, sp, #4
 800a6a4:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_4;
 800a6a6:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800a6a8:	9402      	str	r4, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a6aa:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a6ac:	f7fd f902 	bl	80078b4 <HAL_GPIO_Init>
  
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
 800a6b0:	2311      	movs	r3, #17
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800a6b2:	a901      	add	r1, sp, #4
 800a6b4:	4808      	ldr	r0, [pc, #32]	; (800a6d8 <HW_IF_STUSB1602_IO_Init+0xc0>)
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
 800a6b6:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800a6b8:	9402      	str	r4, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a6ba:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800a6bc:	f7fd f8fa 	bl	80078b4 <HAL_GPIO_Init>
  
  GPIO_InitStruct.Pin = GPIO_PIN_0;
 800a6c0:	2301      	movs	r3, #1
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800a6c2:	a901      	add	r1, sp, #4
 800a6c4:	4805      	ldr	r0, [pc, #20]	; (800a6dc <HW_IF_STUSB1602_IO_Init+0xc4>)
  GPIO_InitStruct.Pin = GPIO_PIN_0;
 800a6c6:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800a6c8:	9402      	str	r4, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a6ca:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800a6cc:	f7fd f8f2 	bl	80078b4 <HAL_GPIO_Init>
//    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
//    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
//    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
//    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
//  }
}
 800a6d0:	b007      	add	sp, #28
 800a6d2:	bd30      	pop	{r4, r5, pc}
 800a6d4:	10210000 	.word	0x10210000
 800a6d8:	48000800 	.word	0x48000800
 800a6dc:	48000400 	.word	0x48000400

0800a6e0 <HW_IF_RESET_CTRL>:
  * @brief  STUSB16xx software reset
  * @param  PortNum The port index
  * @retval None
*/ 
void HW_IF_RESET_CTRL(uint8_t PortNum)
{
 800a6e0:	b510      	push	{r4, lr}
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), SW_RST);
 800a6e2:	1e44      	subs	r4, r0, #1
 800a6e4:	41a0      	sbcs	r0, r4
 800a6e6:	2101      	movs	r1, #1
 800a6e8:	3028      	adds	r0, #40	; 0x28
 800a6ea:	0004      	movs	r4, r0
 800a6ec:	f7fc fadb 	bl	8006ca6 <STUSB1602_SW_RESET_Set>
 800a6f0:	2164      	movs	r1, #100	; 0x64
 800a6f2:	46c0      	nop			; (mov r8, r8)
 800a6f4:	3901      	subs	r1, #1
 800a6f6:	b289      	uxth	r1, r1
  for(uint16_t i=0; i<100; i++)
 800a6f8:	2900      	cmp	r1, #0
 800a6fa:	d1fa      	bne.n	800a6f2 <HW_IF_RESET_CTRL+0x12>
  {
    __NOP();
  }  
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), No_SW_RST);
 800a6fc:	0020      	movs	r0, r4
 800a6fe:	f7fc fad2 	bl	8006ca6 <STUSB1602_SW_RESET_Set>
}
 800a702:	bd10      	pop	{r4, pc}

0800a704 <HW_IF_RESET_Assert>:
  * @brief  Assert STUSB16xx hardware reset
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_RESET_Assert(uint8_t PortNum)
{
 800a704:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(RESET_GPIO_PORT(PortNum), RESET_GPIO_PIN(PortNum), GPIO_PIN_SET);
 800a706:	2140      	movs	r1, #64	; 0x40
 800a708:	2800      	cmp	r0, #0
 800a70a:	d000      	beq.n	800a70e <HW_IF_RESET_Assert+0xa>
 800a70c:	1849      	adds	r1, r1, r1
 800a70e:	2201      	movs	r2, #1
 800a710:	4801      	ldr	r0, [pc, #4]	; (800a718 <HW_IF_RESET_Assert+0x14>)
 800a712:	f7fd f991 	bl	8007a38 <HAL_GPIO_WritePin>
}
 800a716:	bd10      	pop	{r4, pc}
 800a718:	48000800 	.word	0x48000800

0800a71c <HW_IF_RESET_Deassert>:
  * @brief  Desert STUSB16xx hardware reset
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_RESET_Deassert(uint8_t PortNum)
{
 800a71c:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(RESET_GPIO_PORT(PortNum), RESET_GPIO_PIN(PortNum), GPIO_PIN_RESET);
 800a71e:	2140      	movs	r1, #64	; 0x40
 800a720:	2800      	cmp	r0, #0
 800a722:	d000      	beq.n	800a726 <HW_IF_RESET_Deassert+0xa>
 800a724:	1849      	adds	r1, r1, r1
 800a726:	2200      	movs	r2, #0
 800a728:	4801      	ldr	r0, [pc, #4]	; (800a730 <HW_IF_RESET_Deassert+0x14>)
 800a72a:	f7fd f985 	bl	8007a38 <HAL_GPIO_WritePin>
}
 800a72e:	bd10      	pop	{r4, pc}
 800a730:	48000800 	.word	0x48000800

0800a734 <HW_IF_RX_Enable>:
  * @retval None
  */
void HW_IF_RX_Enable(uint8_t PortNum)
{
  /* Set the port state to waiting */
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_WAITING;
 800a734:	23f0      	movs	r3, #240	; 0xf0
 800a736:	005b      	lsls	r3, r3, #1
 800a738:	4343      	muls	r3, r0
 800a73a:	4805      	ldr	r0, [pc, #20]	; (800a750 <HW_IF_RX_Enable+0x1c>)
 800a73c:	18c0      	adds	r0, r0, r3
 800a73e:	2305      	movs	r3, #5
 800a740:	7643      	strb	r3, [r0, #25]

  if (Ports[PortNum].cbs.USBPD_HW_IF_ReceiveMessage != NULL)
 800a742:	30b9      	adds	r0, #185	; 0xb9
 800a744:	30ff      	adds	r0, #255	; 0xff
 800a746:	6803      	ldr	r3, [r0, #0]
 800a748:	2b00      	cmp	r3, #0
 800a74a:	d000      	beq.n	800a74e <HW_IF_RX_Enable+0x1a>
 800a74c:	46c0      	nop			; (mov r8, r8)
  {
    __NOP();
  }
}
 800a74e:	4770      	bx	lr
 800a750:	20000058 	.word	0x20000058

0800a754 <HW_IF_RX_Disable>:
  * @retval None
  */
void HW_IF_RX_Disable(uint8_t PortNum)
{
  /* The port is ready to transmit */
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800a754:	23f0      	movs	r3, #240	; 0xf0
 800a756:	005b      	lsls	r3, r3, #1
 800a758:	4343      	muls	r3, r0
 800a75a:	4805      	ldr	r0, [pc, #20]	; (800a770 <HW_IF_RX_Disable+0x1c>)
 800a75c:	18c0      	adds	r0, r0, r3
 800a75e:	2301      	movs	r3, #1
 800a760:	7643      	strb	r3, [r0, #25]
  
  if (Ports[PortNum].cbs.USBPD_HW_IF_ReceiveMessage != NULL)
 800a762:	30b9      	adds	r0, #185	; 0xb9
 800a764:	30ff      	adds	r0, #255	; 0xff
 800a766:	6803      	ldr	r3, [r0, #0]
 800a768:	2b00      	cmp	r3, #0
 800a76a:	d000      	beq.n	800a76e <HW_IF_RX_Disable+0x1a>
 800a76c:	46c0      	nop			; (mov r8, r8)
  {
    __NOP();
  }
}
 800a76e:	4770      	bx	lr
 800a770:	20000058 	.word	0x20000058

0800a774 <HW_IF_Port_SetInitialRole>:
  * @param  PortNum The port index
  * @param  role
  * @retval None
  */ 
void HW_IF_Port_SetInitialRole(uint8_t PortNum,USBPD_PortPowerRole_TypeDef role)
{
 800a774:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
  
  if (USBPD_TRUE == _handle->settings->CAD_RoleToggle)
 800a776:	2318      	movs	r3, #24
 800a778:	2601      	movs	r6, #1
 800a77a:	4343      	muls	r3, r0
 800a77c:	4a98      	ldr	r2, [pc, #608]	; (800a9e0 <HW_IF_Port_SetInitialRole+0x26c>)
{
 800a77e:	000f      	movs	r7, r1
  if (USBPD_TRUE == _handle->settings->CAD_RoleToggle)
 800a780:	589b      	ldr	r3, [r3, r2]
 800a782:	7a9d      	ldrb	r5, [r3, #10]
 800a784:	4035      	ands	r5, r6
 800a786:	d04a      	beq.n	800a81e <HW_IF_Port_SetInitialRole+0xaa>
    /* Dual Role */
    /*0x18*/  
#if defined(CONF_DEMO)
    STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_1_5_A);
#else
    STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 800a788:	1e44      	subs	r4, r0, #1
 800a78a:	41a0      	sbcs	r0, r4
 800a78c:	3028      	adds	r0, #40	; 0x28
 800a78e:	0004      	movs	r4, r0
 800a790:	2102      	movs	r1, #2
 800a792:	f7fc f943 	bl	8006a1c <STUSB1602_Current_Advertised_Set>
#endif
    STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800a796:	0031      	movs	r1, r6
 800a798:	0020      	movs	r0, r4
 800a79a:	f7fc f96e 	bl	8006a7a <STUSB1602_VCONN_Discharge_Status_Set>
#ifdef _APPLI_VCONN_SUPPORT
    STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Enable_on_CC_pin);    
#else
    STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800a79e:	2100      	movs	r1, #0
 800a7a0:	0020      	movs	r0, r4
 800a7a2:	f7fc f9b2 	bl	8006b0a <STUSB1602_VCONN_Supply_Status_Set>
#endif
    STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);    
 800a7a6:	2100      	movs	r1, #0
 800a7a8:	0020      	movs	r0, r4
 800a7aa:	f7fc f97e 	bl	8006aaa <STUSB1602_Data_Role_Swap_Status_Set>
    STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);    
 800a7ae:	2100      	movs	r1, #0
 800a7b0:	0020      	movs	r0, r4
 800a7b2:	f7fc f992 	bl	8006ada <STUSB1602_Power_Role_Swap_Status_Set>

    /*0x1E*/
    STUSB1602_VCONN_Switch_Current_Limit_Set(STUSB1602_I2C_Add(PortNum), ILIM_350_ma);
 800a7b6:	2100      	movs	r1, #0
 800a7b8:	0020      	movs	r0, r4
 800a7ba:	f7fc f9bc 	bl	8006b36 <STUSB1602_VCONN_Switch_Current_Limit_Set>

    /*0x1F*/
    STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), DRP_w_accessory_supp);  
 800a7be:	2103      	movs	r1, #3
 800a7c0:	0020      	movs	r0, r4
 800a7c2:	f7fc faea 	bl	8006d9a <STUSB1602_Power_Mode_Set>

    /*0x20*/
    STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800a7c6:	2100      	movs	r1, #0
 800a7c8:	0020      	movs	r0, r4
 800a7ca:	f7fc f9e2 	bl	8006b92 <STUSB1602_VCONN_Monitor_Status_Set>
    STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800a7ce:	2100      	movs	r1, #0
 800a7d0:	0020      	movs	r0, r4
 800a7d2:	f7fc f9f5 	bl	8006bc0 <STUSB1602_VCONN_UVLO_Thresh_Status_Set>

    /*0x21*/
    STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800a7d6:	4983      	ldr	r1, [pc, #524]	; (800a9e4 <HW_IF_Port_SetInitialRole+0x270>)
 800a7d8:	0020      	movs	r0, r4
 800a7da:	f7fc fa17 	bl	8006c0c <STUSB1602_VBUS_Select_Status_Set>

    /*0x22*/
    STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20); 
 800a7de:	2114      	movs	r1, #20
 800a7e0:	0020      	movs	r0, r4
 800a7e2:	f7fc fa2d 	bl	8006c40 <STUSB1602_VBUS_VShift_High_Set>
    STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800a7e6:	2114      	movs	r1, #20
 800a7e8:	0020      	movs	r0, r4
 800a7ea:	4249      	negs	r1, r1
 800a7ec:	f7fc fa40 	bl	8006c70 <STUSB1602_VBUS_VShift_Low_Set>

    /*0x25*/
    STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800a7f0:	2193      	movs	r1, #147	; 0x93
 800a7f2:	0020      	movs	r0, r4
 800a7f4:	0089      	lsls	r1, r1, #2
 800a7f6:	f7fc fa82 	bl	8006cfe <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
    STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800a7fa:	21c8      	movs	r1, #200	; 0xc8
 800a7fc:	0020      	movs	r0, r4
 800a7fe:	f7fc fa99 	bl	8006d34 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>

    /*0x2E*/
    STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
 800a802:	2100      	movs	r1, #0
 800a804:	0020      	movs	r0, r4
 800a806:	f7fc faf7 	bl	8006df8 <STUSB1602_VDD_OVLO_Threshold_Set>

#if defined(CONF_DEMO)
    STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Disable);
#else
 //   STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
    STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Disable);
 800a80a:	0031      	movs	r1, r6
 800a80c:	0020      	movs	r0, r4
 800a80e:	f7fc fb0b 	bl	8006e28 <STUSB1602_VBUS_Range_State_Set>
#endif

    STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V); /* default value is VBUS_vSafe0V_Thr_0_6V, VBUS_vSafe0V_Thr_1_8V */
 800a812:	2100      	movs	r1, #0

      /*0x2E*/
      STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);

      STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V); /* default value is VBUS_vSafe0V_Thr_0_6V, VBUS_vSafe0V_Thr_1_8V */
 800a814:	0020      	movs	r0, r4
 800a816:	f7fc fb1f 	bl	8006e58 <STUSB1602_VBUS_VSAFE0V_Threshold_Set>
      STUSB1602_VDD_UVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_UVLO_Disable);
 800a81a:	0031      	movs	r1, r6
 800a81c:	e0db      	b.n	800a9d6 <HW_IF_Port_SetInitialRole+0x262>
    switch (role)
 800a81e:	2900      	cmp	r1, #0
 800a820:	d04d      	beq.n	800a8be <HW_IF_Port_SetInitialRole+0x14a>
 800a822:	2901      	cmp	r1, #1
 800a824:	d100      	bne.n	800a828 <HW_IF_Port_SetInitialRole+0xb4>
 800a826:	e088      	b.n	800a93a <HW_IF_Port_SetInitialRole+0x1c6>
      STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 800a828:	1e44      	subs	r4, r0, #1
 800a82a:	41a0      	sbcs	r0, r4
 800a82c:	3028      	adds	r0, #40	; 0x28
 800a82e:	0004      	movs	r4, r0
 800a830:	2102      	movs	r1, #2
 800a832:	f7fc f8f3 	bl	8006a1c <STUSB1602_Current_Advertised_Set>
      STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800a836:	0031      	movs	r1, r6
 800a838:	0020      	movs	r0, r4
 800a83a:	f7fc f91e 	bl	8006a7a <STUSB1602_VCONN_Discharge_Status_Set>
      STUSB1602_SNK_Disconnect_Mode_Status_Set(STUSB1602_I2C_Add(PortNum), VBUS_or_SRC_removed);
 800a83e:	0029      	movs	r1, r5
 800a840:	0020      	movs	r0, r4
 800a842:	f7fc f902 	bl	8006a4a <STUSB1602_SNK_Disconnect_Mode_Status_Set>
      STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800a846:	0029      	movs	r1, r5
 800a848:	0020      	movs	r0, r4
 800a84a:	f7fc f95e 	bl	8006b0a <STUSB1602_VCONN_Supply_Status_Set>
      STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);
 800a84e:	0029      	movs	r1, r5
 800a850:	0020      	movs	r0, r4
 800a852:	f7fc f92a 	bl	8006aaa <STUSB1602_Data_Role_Swap_Status_Set>
      STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);
 800a856:	0029      	movs	r1, r5
 800a858:	0020      	movs	r0, r4
 800a85a:	f7fc f93e 	bl	8006ada <STUSB1602_Power_Role_Swap_Status_Set>
      STUSB1602_VCONN_Switch_Current_Limit_Set(STUSB1602_I2C_Add(PortNum), ILIM_350_ma);
 800a85e:	0029      	movs	r1, r5
 800a860:	0020      	movs	r0, r4
 800a862:	f7fc f968 	bl	8006b36 <STUSB1602_VCONN_Switch_Current_Limit_Set>
      STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), DRP_w_accessory_supp);  
 800a866:	2103      	movs	r1, #3
 800a868:	0020      	movs	r0, r4
 800a86a:	f7fc fa96 	bl	8006d9a <STUSB1602_Power_Mode_Set>
      STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800a86e:	0029      	movs	r1, r5
 800a870:	0020      	movs	r0, r4
 800a872:	f7fc f98e 	bl	8006b92 <STUSB1602_VCONN_Monitor_Status_Set>
      STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800a876:	0029      	movs	r1, r5
 800a878:	0020      	movs	r0, r4
 800a87a:	f7fc f9a1 	bl	8006bc0 <STUSB1602_VCONN_UVLO_Thresh_Status_Set>
      STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800a87e:	4959      	ldr	r1, [pc, #356]	; (800a9e4 <HW_IF_Port_SetInitialRole+0x270>)
 800a880:	0020      	movs	r0, r4
 800a882:	f7fc f9c3 	bl	8006c0c <STUSB1602_VBUS_Select_Status_Set>
      STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20); 
 800a886:	2114      	movs	r1, #20
 800a888:	0020      	movs	r0, r4
 800a88a:	f7fc f9d9 	bl	8006c40 <STUSB1602_VBUS_VShift_High_Set>
      STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800a88e:	2114      	movs	r1, #20
 800a890:	0020      	movs	r0, r4
 800a892:	4249      	negs	r1, r1
 800a894:	f7fc f9ec 	bl	8006c70 <STUSB1602_VBUS_VShift_Low_Set>
      STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800a898:	2193      	movs	r1, #147	; 0x93
 800a89a:	0020      	movs	r0, r4
 800a89c:	0089      	lsls	r1, r1, #2
 800a89e:	f7fc fa2e 	bl	8006cfe <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
      STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800a8a2:	21c8      	movs	r1, #200	; 0xc8
 800a8a4:	0020      	movs	r0, r4
 800a8a6:	f7fc fa45 	bl	8006d34 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>
      STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
 800a8aa:	0029      	movs	r1, r5
 800a8ac:	0020      	movs	r0, r4
 800a8ae:	f7fc faa3 	bl	8006df8 <STUSB1602_VDD_OVLO_Threshold_Set>
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
 800a8b2:	0029      	movs	r1, r5
 800a8b4:	0020      	movs	r0, r4
 800a8b6:	f7fc fab7 	bl	8006e28 <STUSB1602_VBUS_Range_State_Set>
      STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V); /* default value is VBUS_vSafe0V_Thr_0_6V, VBUS_vSafe0V_Thr_1_8V */
 800a8ba:	0029      	movs	r1, r5
 800a8bc:	e7aa      	b.n	800a814 <HW_IF_Port_SetInitialRole+0xa0>
      STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);
 800a8be:	1e44      	subs	r4, r0, #1
 800a8c0:	41a0      	sbcs	r0, r4
 800a8c2:	3028      	adds	r0, #40	; 0x28
 800a8c4:	0004      	movs	r4, r0
 800a8c6:	f7fc f8f0 	bl	8006aaa <STUSB1602_Data_Role_Swap_Status_Set>
      STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);
 800a8ca:	0039      	movs	r1, r7
 800a8cc:	0020      	movs	r0, r4
 800a8ce:	f7fc f904 	bl	8006ada <STUSB1602_Power_Role_Swap_Status_Set>
      STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800a8d2:	0031      	movs	r1, r6
 800a8d4:	0020      	movs	r0, r4
 800a8d6:	f7fc f8d0 	bl	8006a7a <STUSB1602_VCONN_Discharge_Status_Set>
      STUSB1602_SNK_Disconnect_Mode_Status_Set(STUSB1602_I2C_Add(PortNum), VBUS_or_SRC_removed);
 800a8da:	0039      	movs	r1, r7
 800a8dc:	0020      	movs	r0, r4
 800a8de:	f7fc f8b4 	bl	8006a4a <STUSB1602_SNK_Disconnect_Mode_Status_Set>
      STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800a8e2:	0039      	movs	r1, r7
 800a8e4:	0020      	movs	r0, r4
 800a8e6:	f7fc f910 	bl	8006b0a <STUSB1602_VCONN_Supply_Status_Set>
      STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), SNK_without_accessory_supp);  
 800a8ea:	2102      	movs	r1, #2
 800a8ec:	0020      	movs	r0, r4
 800a8ee:	f7fc fa54 	bl	8006d9a <STUSB1602_Power_Mode_Set>
      STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800a8f2:	0039      	movs	r1, r7
 800a8f4:	0020      	movs	r0, r4
 800a8f6:	f7fc f94c 	bl	8006b92 <STUSB1602_VCONN_Monitor_Status_Set>
      STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800a8fa:	0039      	movs	r1, r7
 800a8fc:	0020      	movs	r0, r4
 800a8fe:	f7fc f95f 	bl	8006bc0 <STUSB1602_VCONN_UVLO_Thresh_Status_Set>
      STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800a902:	4938      	ldr	r1, [pc, #224]	; (800a9e4 <HW_IF_Port_SetInitialRole+0x270>)
 800a904:	0020      	movs	r0, r4
 800a906:	f7fc f981 	bl	8006c0c <STUSB1602_VBUS_Select_Status_Set>
      STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20); 
 800a90a:	2114      	movs	r1, #20
 800a90c:	0020      	movs	r0, r4
 800a90e:	f7fc f997 	bl	8006c40 <STUSB1602_VBUS_VShift_High_Set>
      STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800a912:	2114      	movs	r1, #20
 800a914:	0020      	movs	r0, r4
 800a916:	4249      	negs	r1, r1
 800a918:	f7fc f9aa 	bl	8006c70 <STUSB1602_VBUS_VShift_Low_Set>
      STUSB1602_Pwr_Acc_Detect_Set(STUSB1602_I2C_Add(PortNum), Pwr_Acc_Detect_Disable); 
 800a91c:	0039      	movs	r1, r7
 800a91e:	0020      	movs	r0, r4
 800a920:	f7fc f9d7 	bl	8006cd2 <STUSB1602_Pwr_Acc_Detect_Set>
      STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800a924:	2193      	movs	r1, #147	; 0x93
 800a926:	0020      	movs	r0, r4
 800a928:	0089      	lsls	r1, r1, #2
 800a92a:	f7fc f9e8 	bl	8006cfe <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
      STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800a92e:	21c8      	movs	r1, #200	; 0xc8
 800a930:	0020      	movs	r0, r4
 800a932:	f7fc f9ff 	bl	8006d34 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
 800a936:	0039      	movs	r1, r7
 800a938:	e768      	b.n	800a80c <HW_IF_Port_SetInitialRole+0x98>
      STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A); /* USB_C_Current_3_A */
 800a93a:	1e44      	subs	r4, r0, #1
 800a93c:	41a0      	sbcs	r0, r4
 800a93e:	3028      	adds	r0, #40	; 0x28
 800a940:	0004      	movs	r4, r0
 800a942:	2102      	movs	r1, #2
 800a944:	f7fc f86a 	bl	8006a1c <STUSB1602_Current_Advertised_Set>
      STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800a948:	0039      	movs	r1, r7
 800a94a:	0020      	movs	r0, r4
 800a94c:	f7fc f895 	bl	8006a7a <STUSB1602_VCONN_Discharge_Status_Set>
      STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800a950:	0029      	movs	r1, r5
 800a952:	0020      	movs	r0, r4
 800a954:	f7fc f8d9 	bl	8006b0a <STUSB1602_VCONN_Supply_Status_Set>
      STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);
 800a958:	0029      	movs	r1, r5
 800a95a:	0020      	movs	r0, r4
 800a95c:	f7fc f8a5 	bl	8006aaa <STUSB1602_Data_Role_Swap_Status_Set>
      STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);
 800a960:	0029      	movs	r1, r5
 800a962:	0020      	movs	r0, r4
 800a964:	f7fc f8b9 	bl	8006ada <STUSB1602_Power_Role_Swap_Status_Set>
      STUSB1602_VCONN_Switch_Current_Limit_Set(STUSB1602_I2C_Add(PortNum), ILIM_350_ma);
 800a968:	0029      	movs	r1, r5
 800a96a:	0020      	movs	r0, r4
 800a96c:	f7fc f8e3 	bl	8006b36 <STUSB1602_VCONN_Switch_Current_Limit_Set>
      STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), SRC_with_accessory_supp);  
 800a970:	0029      	movs	r1, r5
 800a972:	0020      	movs	r0, r4
 800a974:	f7fc fa11 	bl	8006d9a <STUSB1602_Power_Mode_Set>
      STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800a978:	0029      	movs	r1, r5
 800a97a:	0020      	movs	r0, r4
 800a97c:	f7fc f909 	bl	8006b92 <STUSB1602_VCONN_Monitor_Status_Set>
      STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800a980:	0029      	movs	r1, r5
 800a982:	0020      	movs	r0, r4
 800a984:	f7fc f91c 	bl	8006bc0 <STUSB1602_VCONN_UVLO_Thresh_Status_Set>
      STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800a988:	4916      	ldr	r1, [pc, #88]	; (800a9e4 <HW_IF_Port_SetInitialRole+0x270>)
 800a98a:	0020      	movs	r0, r4
 800a98c:	f7fc f93e 	bl	8006c0c <STUSB1602_VBUS_Select_Status_Set>
      STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20);
 800a990:	2114      	movs	r1, #20
 800a992:	0020      	movs	r0, r4
 800a994:	f7fc f954 	bl	8006c40 <STUSB1602_VBUS_VShift_High_Set>
      STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800a998:	2114      	movs	r1, #20
 800a99a:	0020      	movs	r0, r4
 800a99c:	4249      	negs	r1, r1
 800a99e:	f7fc f967 	bl	8006c70 <STUSB1602_VBUS_VShift_Low_Set>
      STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800a9a2:	2193      	movs	r1, #147	; 0x93
 800a9a4:	0020      	movs	r0, r4
 800a9a6:	0089      	lsls	r1, r1, #2
 800a9a8:	f7fc f9a9 	bl	8006cfe <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
      STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800a9ac:	21c8      	movs	r1, #200	; 0xc8
 800a9ae:	0020      	movs	r0, r4
 800a9b0:	f7fc f9c0 	bl	8006d34 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>
      STUSB1602_VBUS_Discharge_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Discharge_Path_Enable); 
 800a9b4:	0039      	movs	r1, r7
 800a9b6:	0020      	movs	r0, r4
 800a9b8:	f7fc f9d8 	bl	8006d6c <STUSB1602_VBUS_Discharge_State_Set>
      STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
 800a9bc:	0029      	movs	r1, r5
 800a9be:	0020      	movs	r0, r4
 800a9c0:	f7fc fa1a 	bl	8006df8 <STUSB1602_VDD_OVLO_Threshold_Set>
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
 800a9c4:	0029      	movs	r1, r5
 800a9c6:	0020      	movs	r0, r4
 800a9c8:	f7fc fa2e 	bl	8006e28 <STUSB1602_VBUS_Range_State_Set>
      STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V);
 800a9cc:	0029      	movs	r1, r5
 800a9ce:	0020      	movs	r0, r4
 800a9d0:	f7fc fa42 	bl	8006e58 <STUSB1602_VBUS_VSAFE0V_Threshold_Set>
      STUSB1602_VDD_UVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_UVLO_Disable);
 800a9d4:	0039      	movs	r1, r7
      STUSB1602_VDD_UVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_UVLO_Disable);
 800a9d6:	0020      	movs	r0, r4
 800a9d8:	f7fc fa57 	bl	8006e8a <STUSB1602_VDD_UVLO_Threshold_Set>
    break;
    }
  }
}
 800a9dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a9de:	46c0      	nop			; (mov r8, r8)
 800a9e0:	20001b8c 	.word	0x20001b8c
 800a9e4:	00001388 	.word	0x00001388

0800a9e8 <HW_IF_check_bus_idle>:
  * @param  PortNum The port index
  * @retval USBPD_StatusTypeDef
  */
USBPD_StatusTypeDef HW_IF_check_bus_idle(uint8_t PortNum)
{
  return (((Ports[PortNum].CCx == CCNONE) || ((HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET))) ? USBPD_BUSY : USBPD_OK);
 800a9e8:	22f0      	movs	r2, #240	; 0xf0
 800a9ea:	0052      	lsls	r2, r2, #1
 800a9ec:	4342      	muls	r2, r0
 800a9ee:	4b0c      	ldr	r3, [pc, #48]	; (800aa20 <HW_IF_check_bus_idle+0x38>)
{
 800a9f0:	b510      	push	{r4, lr}
  return (((Ports[PortNum].CCx == CCNONE) || ((HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET))) ? USBPD_BUSY : USBPD_OK);
 800a9f2:	189b      	adds	r3, r3, r2
 800a9f4:	7d9b      	ldrb	r3, [r3, #22]
 800a9f6:	2b00      	cmp	r3, #0
 800a9f8:	d00a      	beq.n	800aa10 <HW_IF_check_bus_idle+0x28>
 800a9fa:	2800      	cmp	r0, #0
 800a9fc:	d00b      	beq.n	800aa16 <HW_IF_check_bus_idle+0x2e>
 800a9fe:	2090      	movs	r0, #144	; 0x90
 800aa00:	2180      	movs	r1, #128	; 0x80
 800aa02:	05c0      	lsls	r0, r0, #23
 800aa04:	0209      	lsls	r1, r1, #8
 800aa06:	f7fd f811 	bl	8007a2c <HAL_GPIO_ReadPin>
 800aa0a:	2300      	movs	r3, #0
 800aa0c:	4298      	cmp	r0, r3
 800aa0e:	d100      	bne.n	800aa12 <HW_IF_check_bus_idle+0x2a>
 800aa10:	2303      	movs	r3, #3
}
 800aa12:	0018      	movs	r0, r3
 800aa14:	bd10      	pop	{r4, pc}
  return (((Ports[PortNum].CCx == CCNONE) || ((HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET))) ? USBPD_BUSY : USBPD_OK);
 800aa16:	2180      	movs	r1, #128	; 0x80
 800aa18:	4802      	ldr	r0, [pc, #8]	; (800aa24 <HW_IF_check_bus_idle+0x3c>)
 800aa1a:	0149      	lsls	r1, r1, #5
 800aa1c:	e7f3      	b.n	800aa06 <HW_IF_check_bus_idle+0x1e>
 800aa1e:	46c0      	nop			; (mov r8, r8)
 800aa20:	20000058 	.word	0x20000058
 800aa24:	48000400 	.word	0x48000400

0800aa28 <HW_IF_NSS_RisingFalling_Interrupt>:
  * @param  PortNum The port index
  * @param  status Two allowed values: ENABLE or DISABLE
  * @retval None
  */ 
void HW_IF_NSS_RisingFalling_Interrupt (uint8_t PortNum ,FunctionalState status)
{
 800aa28:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800aa2a:	0004      	movs	r4, r0
 800aa2c:	000d      	movs	r5, r1
  LL_EXTI_InitTypeDef EXTI_InitStruct;

  if (status == ENABLE)
 800aa2e:	2901      	cmp	r1, #1
 800aa30:	d12a      	bne.n	800aa88 <HW_IF_NSS_RisingFalling_Interrupt+0x60>
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800aa32:	2380      	movs	r3, #128	; 0x80
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800aa34:	20c1      	movs	r0, #193	; 0xc1
 800aa36:	2180      	movs	r1, #128	; 0x80
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800aa38:	4a20      	ldr	r2, [pc, #128]	; (800aabc <HW_IF_NSS_RisingFalling_Interrupt+0x94>)
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800aa3a:	0080      	lsls	r0, r0, #2
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800aa3c:	6013      	str	r3, [r2, #0]
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800aa3e:	5813      	ldr	r3, [r2, r0]
 800aa40:	0609      	lsls	r1, r1, #24
 800aa42:	021b      	lsls	r3, r3, #8
 800aa44:	0a1b      	lsrs	r3, r3, #8
 800aa46:	430b      	orrs	r3, r1
 800aa48:	5013      	str	r3, [r2, r0]
    /* NVIC configuration*/
    NVIC_EnableIRQ(SPI_NSS_LL_IRQHANDLER(PortNum));
    NVIC_SetPriority(SPI_NSS_LL_IRQHANDLER(PortNum),SPI_NSS_LL_IRQPRIORITY(PortNum));

    /* External Line initialization */
    LL_APB1_GRP2_EnableClock(SPI_NSS_LL_APB(PortNum));
 800aa4a:	f7ff fc8b 	bl	800a364 <LL_APB1_GRP2_EnableClock.constprop.7>
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800aa4e:	2c00      	cmp	r4, #0
 800aa50:	d117      	bne.n	800aa82 <HW_IF_NSS_RisingFalling_Interrupt+0x5a>
 800aa52:	0028      	movs	r0, r5
 800aa54:	2103      	movs	r1, #3

    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800aa56:	4263      	negs	r3, r4
 800aa58:	415c      	adcs	r4, r3
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800aa5a:	f7ff fc45 	bl	800a2e8 <LL_SYSCFG_SetEXTISource>
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800aa5e:	4b18      	ldr	r3, [pc, #96]	; (800aac0 <HW_IF_NSS_RisingFalling_Interrupt+0x98>)
 800aa60:	4264      	negs	r4, r4
 800aa62:	401c      	ands	r4, r3
 800aa64:	2380      	movs	r3, #128	; 0x80
 800aa66:	021b      	lsls	r3, r3, #8
 800aa68:	18e4      	adds	r4, r4, r3
    EXTI_InitStruct.LineCommand = ENABLE;
 800aa6a:	466a      	mov	r2, sp
 800aa6c:	2301      	movs	r3, #1
 800aa6e:	7113      	strb	r3, [r2, #4]
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 800aa70:	2300      	movs	r3, #0
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800aa72:	9400      	str	r4, [sp, #0]
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 800aa74:	7153      	strb	r3, [r2, #5]
    EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_RISING_FALLING;
 800aa76:	3303      	adds	r3, #3
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));

    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
    EXTI_InitStruct.LineCommand = DISABLE;
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
    EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_NONE;
 800aa78:	7193      	strb	r3, [r2, #6]
    LL_EXTI_Init(&EXTI_InitStruct);
 800aa7a:	4668      	mov	r0, sp
 800aa7c:	f7fe fa98 	bl	8008fb0 <LL_EXTI_Init>
  }  
}
 800aa80:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800aa82:	2000      	movs	r0, #0
 800aa84:	490f      	ldr	r1, [pc, #60]	; (800aac4 <HW_IF_NSS_RisingFalling_Interrupt+0x9c>)
 800aa86:	e7e6      	b.n	800aa56 <HW_IF_NSS_RisingFalling_Interrupt+0x2e>
  *         (*) value not defined in all devices.
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP2_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB2ENR, Periphs);
 800aa88:	2001      	movs	r0, #1
 800aa8a:	4a0f      	ldr	r2, [pc, #60]	; (800aac8 <HW_IF_NSS_RisingFalling_Interrupt+0xa0>)
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800aa8c:	2103      	movs	r1, #3
 800aa8e:	6993      	ldr	r3, [r2, #24]
 800aa90:	4383      	bics	r3, r0
 800aa92:	6193      	str	r3, [r2, #24]
 800aa94:	2c00      	cmp	r4, #0
 800aa96:	d001      	beq.n	800aa9c <HW_IF_NSS_RisingFalling_Interrupt+0x74>
 800aa98:	2000      	movs	r0, #0
 800aa9a:	490a      	ldr	r1, [pc, #40]	; (800aac4 <HW_IF_NSS_RisingFalling_Interrupt+0x9c>)
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800aa9c:	4263      	negs	r3, r4
 800aa9e:	415c      	adcs	r4, r3
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800aaa0:	f7ff fc22 	bl	800a2e8 <LL_SYSCFG_SetEXTISource>
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800aaa4:	4b06      	ldr	r3, [pc, #24]	; (800aac0 <HW_IF_NSS_RisingFalling_Interrupt+0x98>)
 800aaa6:	4264      	negs	r4, r4
 800aaa8:	401c      	ands	r4, r3
 800aaaa:	2380      	movs	r3, #128	; 0x80
 800aaac:	021b      	lsls	r3, r3, #8
 800aaae:	18e4      	adds	r4, r4, r3
    EXTI_InitStruct.LineCommand = DISABLE;
 800aab0:	466a      	mov	r2, sp
 800aab2:	2300      	movs	r3, #0
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800aab4:	9400      	str	r4, [sp, #0]
    EXTI_InitStruct.LineCommand = DISABLE;
 800aab6:	7113      	strb	r3, [r2, #4]
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 800aab8:	7153      	strb	r3, [r2, #5]
 800aaba:	e7dd      	b.n	800aa78 <HW_IF_NSS_RisingFalling_Interrupt+0x50>
 800aabc:	e000e100 	.word	0xe000e100
 800aac0:	ffff9000 	.word	0xffff9000
 800aac4:	000c0003 	.word	0x000c0003
 800aac8:	40021000 	.word	0x40021000

0800aacc <HW_IF_COUNTER_TIM_Init>:
  * @brief  Initialization of counter
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_COUNTER_TIM_Init(uint8_t PortNum)
{
 800aacc:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Get the peripheral handler variable */
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800aace:	25f0      	movs	r5, #240	; 0xf0
 800aad0:	006d      	lsls	r5, r5, #1
 800aad2:	4345      	muls	r5, r0
 800aad4:	4b25      	ldr	r3, [pc, #148]	; (800ab6c <HW_IF_COUNTER_TIM_Init+0xa0>)
  
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig;
  TIM_OC_InitTypeDef sConfigOC;
  
  htimcountrx->Instance =                       RX_COUNTTIM(PortNum);
 800aad6:	4242      	negs	r2, r0
 800aad8:	4150      	adcs	r0, r2
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800aada:	002e      	movs	r6, r5
  htimcountrx->Instance =                       RX_COUNTTIM(PortNum);
 800aadc:	195d      	adds	r5, r3, r5
 800aade:	002f      	movs	r7, r5
 800aae0:	4a23      	ldr	r2, [pc, #140]	; (800ab70 <HW_IF_COUNTER_TIM_Init+0xa4>)
 800aae2:	4240      	negs	r0, r0
 800aae4:	0280      	lsls	r0, r0, #10
 800aae6:	1880      	adds	r0, r0, r2
 800aae8:	37fc      	adds	r7, #252	; 0xfc
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800aaea:	3679      	adds	r6, #121	; 0x79
{
 800aaec:	b08f      	sub	sp, #60	; 0x3c
  htimcountrx->Instance =                       RX_COUNTTIM(PortNum);
 800aaee:	67f8      	str	r0, [r7, #124]	; 0x7c
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800aaf0:	36ff      	adds	r6, #255	; 0xff
 800aaf2:	18f6      	adds	r6, r6, r3
  htimcountrx->Init.Prescaler =                 ( HAL_RCC_GetHCLKFreq() / 1000000 ) - 1; // 1us Resolution
 800aaf4:	002c      	movs	r4, r5
 800aaf6:	f7fd faef 	bl	80080d8 <HAL_RCC_GetHCLKFreq>
 800aafa:	491e      	ldr	r1, [pc, #120]	; (800ab74 <HW_IF_COUNTER_TIM_Init+0xa8>)
 800aafc:	f7fa ff5a 	bl	80059b4 <__udivsi3>
 800ab00:	347d      	adds	r4, #125	; 0x7d
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800ab02:	002b      	movs	r3, r5
  htimcountrx->Init.Prescaler =                 ( HAL_RCC_GetHCLKFreq() / 1000000 ) - 1; // 1us Resolution
 800ab04:	34ff      	adds	r4, #255	; 0xff
 800ab06:	3801      	subs	r0, #1
  htimcountrx->Init.Period =                    DMA_TIME_ELAPSED;
 800ab08:	223c      	movs	r2, #60	; 0x3c
  htimcountrx->Init.Prescaler =                 ( HAL_RCC_GetHCLKFreq() / 1000000 ) - 1; // 1us Resolution
 800ab0a:	6020      	str	r0, [r4, #0]
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800ab0c:	2400      	movs	r4, #0
 800ab0e:	3381      	adds	r3, #129	; 0x81
  htimcountrx->Init.ClockDivision =             TIM_CLOCKDIVISION_DIV1;
  htimcountrx->Init.RepetitionCounter =         0;
 800ab10:	358d      	adds	r5, #141	; 0x8d
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800ab12:	33ff      	adds	r3, #255	; 0xff
  htimcountrx->Init.RepetitionCounter =         0;
 800ab14:	35ff      	adds	r5, #255	; 0xff
  htimcountrx->Init.Period =                    DMA_TIME_ELAPSED;
 800ab16:	605a      	str	r2, [r3, #4]
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800ab18:	601c      	str	r4, [r3, #0]
  htimcountrx->Init.ClockDivision =             TIM_CLOCKDIVISION_DIV1;
 800ab1a:	609c      	str	r4, [r3, #8]
  htimcountrx->Init.RepetitionCounter =         0;
 800ab1c:	602c      	str	r4, [r5, #0]
  HAL_TIM_Base_Init(htimcountrx);
 800ab1e:	0030      	movs	r0, r6
 800ab20:	f7fe f8c4 	bl	8008cac <HAL_TIM_Base_Init>
  
  HAL_TIM_OC_Init(htimcountrx);
 800ab24:	0030      	movs	r0, r6
 800ab26:	f7fe f8dc 	bl	8008ce2 <HAL_TIM_OC_Init>
  sBreakDeadTimeConfig.OffStateRunMode =        TIM_OSSR_DISABLE;
  sBreakDeadTimeConfig.OffStateIDLEMode =       TIM_OSSI_DISABLE;
  sBreakDeadTimeConfig.LockLevel =              TIM_LOCKLEVEL_OFF;
  sBreakDeadTimeConfig.DeadTime =               0;
  sBreakDeadTimeConfig.BreakState =             TIM_BREAK_DISABLE;
  sBreakDeadTimeConfig.BreakPolarity =          TIM_BREAKPOLARITY_HIGH;
 800ab2a:	2380      	movs	r3, #128	; 0x80
  sBreakDeadTimeConfig.AutomaticOutput =        TIM_AUTOMATICOUTPUT_DISABLE;
  HAL_TIMEx_ConfigBreakDeadTime(htimcountrx, &sBreakDeadTimeConfig);
 800ab2c:	4669      	mov	r1, sp
  sBreakDeadTimeConfig.BreakPolarity =          TIM_BREAKPOLARITY_HIGH;
 800ab2e:	019b      	lsls	r3, r3, #6
  HAL_TIMEx_ConfigBreakDeadTime(htimcountrx, &sBreakDeadTimeConfig);
 800ab30:	0030      	movs	r0, r6
  sBreakDeadTimeConfig.BreakPolarity =          TIM_BREAKPOLARITY_HIGH;
 800ab32:	9305      	str	r3, [sp, #20]
  sBreakDeadTimeConfig.OffStateRunMode =        TIM_OSSR_DISABLE;
 800ab34:	9400      	str	r4, [sp, #0]
  sBreakDeadTimeConfig.OffStateIDLEMode =       TIM_OSSI_DISABLE;
 800ab36:	9401      	str	r4, [sp, #4]
  sBreakDeadTimeConfig.LockLevel =              TIM_LOCKLEVEL_OFF;
 800ab38:	9402      	str	r4, [sp, #8]
  sBreakDeadTimeConfig.DeadTime =               0;
 800ab3a:	9403      	str	r4, [sp, #12]
  sBreakDeadTimeConfig.BreakState =             TIM_BREAK_DISABLE;
 800ab3c:	9404      	str	r4, [sp, #16]
  sBreakDeadTimeConfig.AutomaticOutput =        TIM_AUTOMATICOUTPUT_DISABLE;
 800ab3e:	9406      	str	r4, [sp, #24]
  HAL_TIMEx_ConfigBreakDeadTime(htimcountrx, &sBreakDeadTimeConfig);
 800ab40:	f7fe f9f8 	bl	8008f34 <HAL_TIMEx_ConfigBreakDeadTime>
  
  sConfigOC.OCMode =                            TIM_OCMODE_TIMING;
  sConfigOC.Pulse =                             DMA_TIME_COUNT_COMPARE;
 800ab44:	230a      	movs	r3, #10
  sConfigOC.OCPolarity =                        TIM_OCPOLARITY_HIGH;
  sConfigOC.OCNPolarity =                       TIM_OCNPOLARITY_HIGH;
  sConfigOC.OCFastMode =                        TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState =                       TIM_OCIDLESTATE_RESET;
  sConfigOC.OCNIdleState =                      TIM_OCNIDLESTATE_RESET;
  HAL_TIM_OC_ConfigChannel(htimcountrx, &sConfigOC, RX_COUNTTIMCH(PortNum));
 800ab46:	0022      	movs	r2, r4
 800ab48:	a907      	add	r1, sp, #28
 800ab4a:	0030      	movs	r0, r6
  sConfigOC.Pulse =                             DMA_TIME_COUNT_COMPARE;
 800ab4c:	9308      	str	r3, [sp, #32]
  sConfigOC.OCMode =                            TIM_OCMODE_TIMING;
 800ab4e:	9407      	str	r4, [sp, #28]
  sConfigOC.OCPolarity =                        TIM_OCPOLARITY_HIGH;
 800ab50:	9409      	str	r4, [sp, #36]	; 0x24
  sConfigOC.OCNPolarity =                       TIM_OCNPOLARITY_HIGH;
 800ab52:	940a      	str	r4, [sp, #40]	; 0x28
  sConfigOC.OCFastMode =                        TIM_OCFAST_DISABLE;
 800ab54:	940b      	str	r4, [sp, #44]	; 0x2c
  sConfigOC.OCIdleState =                       TIM_OCIDLESTATE_RESET;
 800ab56:	940c      	str	r4, [sp, #48]	; 0x30
  sConfigOC.OCNIdleState =                      TIM_OCNIDLESTATE_RESET;
 800ab58:	940d      	str	r4, [sp, #52]	; 0x34
  HAL_TIM_OC_ConfigChannel(htimcountrx, &sConfigOC, RX_COUNTTIMCH(PortNum));
 800ab5a:	f7fe f91d 	bl	8008d98 <HAL_TIM_OC_ConfigChannel>
  
  __HAL_TIM_CLEAR_IT(htimcountrx, TIM_IT_UPDATE);
 800ab5e:	2202      	movs	r2, #2
 800ab60:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800ab62:	4252      	negs	r2, r2
 800ab64:	611a      	str	r2, [r3, #16]
}
 800ab66:	b00f      	add	sp, #60	; 0x3c
 800ab68:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ab6a:	46c0      	nop			; (mov r8, r8)
 800ab6c:	20000058 	.word	0x20000058
 800ab70:	40014800 	.word	0x40014800
 800ab74:	000f4240 	.word	0x000f4240

0800ab78 <STUSB16xx_HW_IF_TX_DMA_Init>:
  * @brief  Initialization of DMA for transmission
  * @param  PortNum The port index
  * @retval None
  */ 
void STUSB16xx_HW_IF_TX_DMA_Init(uint8_t PortNum)
{
 800ab78:	23f0      	movs	r3, #240	; 0xf0
 800ab7a:	005b      	lsls	r3, r3, #1
 800ab7c:	4343      	muls	r3, r0
 800ab7e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800ab80:	001e      	movs	r6, r3
 800ab82:	9301      	str	r3, [sp, #4]
  
  /* Set the DMA handler of the peripheral handler */
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800ab84:	9a01      	ldr	r2, [sp, #4]
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800ab86:	4b18      	ldr	r3, [pc, #96]	; (800abe8 <STUSB16xx_HW_IF_TX_DMA_Init+0x70>)
 800ab88:	36a4      	adds	r6, #164	; 0xa4
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800ab8a:	189c      	adds	r4, r3, r2
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800ab8c:	18f6      	adds	r6, r6, r3
  
  /* Peripheral DMA init*/
  hdma_tx_spi->Instance =                   TX_DMACH(PortNum);
 800ab8e:	0003      	movs	r3, r0
 800ab90:	1e5a      	subs	r2, r3, #1
 800ab92:	4193      	sbcs	r3, r2
 800ab94:	2227      	movs	r2, #39	; 0x27
 800ab96:	425b      	negs	r3, r3
 800ab98:	4393      	bics	r3, r2
 800ab9a:	4a14      	ldr	r2, [pc, #80]	; (800abec <STUSB16xx_HW_IF_TX_DMA_Init+0x74>)
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800ab9c:	0027      	movs	r7, r4
  hdma_tx_spi->Instance =                   TX_DMACH(PortNum);
 800ab9e:	189b      	adds	r3, r3, r2
 800aba0:	0022      	movs	r2, r4
 800aba2:	32a4      	adds	r2, #164	; 0xa4
 800aba4:	6013      	str	r3, [r2, #0]
  hdma_tx_spi->Init.Direction =             DMA_MEMORY_TO_PERIPH;
 800aba6:	0023      	movs	r3, r4
 800aba8:	2210      	movs	r2, #16
 800abaa:	33a8      	adds	r3, #168	; 0xa8
 800abac:	601a      	str	r2, [r3, #0]
  hdma_tx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800abae:	0022      	movs	r2, r4
 800abb0:	2300      	movs	r3, #0
  hdma_tx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800abb2:	2180      	movs	r1, #128	; 0x80
{
 800abb4:	0005      	movs	r5, r0
  hdma_tx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800abb6:	32ac      	adds	r2, #172	; 0xac
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800abb8:	3794      	adds	r7, #148	; 0x94
 800abba:	603e      	str	r6, [r7, #0]
  hdma_tx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800abbc:	6051      	str	r1, [r2, #4]
  hdma_tx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800abbe:	6013      	str	r3, [r2, #0]
  hdma_tx_spi->Init.PeriphDataAlignment =   DMA_PDATAALIGN_BYTE;
 800abc0:	6093      	str	r3, [r2, #8]
  hdma_tx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800abc2:	60d3      	str	r3, [r2, #12]
  hdma_tx_spi->Init.Mode =                  DMA_NORMAL;
 800abc4:	6113      	str	r3, [r2, #16]
  hdma_tx_spi->Init.Priority =              DMACHIRQ_PRIO(PortNum);
 800abc6:	6153      	str	r3, [r2, #20]
  HAL_DMA_Init(hdma_tx_spi);
 800abc8:	0030      	movs	r0, r6
 800abca:	f7fc fdc5 	bl	8007758 <HAL_DMA_Init>
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
  
  /* Enable IRQ DMA */
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800abce:	4268      	negs	r0, r5
 800abd0:	4168      	adcs	r0, r5
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800abd2:	9b01      	ldr	r3, [sp, #4]
 800abd4:	4a04      	ldr	r2, [pc, #16]	; (800abe8 <STUSB16xx_HW_IF_TX_DMA_Init+0x70>)
 800abd6:	3340      	adds	r3, #64	; 0x40
 800abd8:	18d3      	adds	r3, r2, r3
 800abda:	34c8      	adds	r4, #200	; 0xc8
 800abdc:	603e      	str	r6, [r7, #0]
 800abde:	6023      	str	r3, [r4, #0]
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800abe0:	300a      	adds	r0, #10
 800abe2:	f7fc fcb7 	bl	8007554 <HAL_NVIC_EnableIRQ>
}
 800abe6:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800abe8:	20000058 	.word	0x20000058
 800abec:	40020058 	.word	0x40020058

0800abf0 <STUSB16xx_HW_IF_RX_DMA_Init>:
  * @brief  Initialization DMA for reception
  * @param  PortNum The port index
  * @retval None
  */ 
void STUSB16xx_HW_IF_RX_DMA_Init(uint8_t PortNum)
{
 800abf0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800abf2:	26f0      	movs	r6, #240	; 0xf0
 800abf4:	0076      	lsls	r6, r6, #1
 800abf6:	4346      	muls	r6, r0
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_rx_spi = &(Ports[PortNum].hdmarx);
 800abf8:	0033      	movs	r3, r6
 800abfa:	4a17      	ldr	r2, [pc, #92]	; (800ac58 <STUSB16xx_HW_IF_RX_DMA_Init+0x68>)
 800abfc:	33e8      	adds	r3, #232	; 0xe8
 800abfe:	189b      	adds	r3, r3, r2
 800ac00:	9301      	str	r3, [sp, #4]
 
  /* Peripheral DMA init*/
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800ac02:	0003      	movs	r3, r0
 800ac04:	1e5a      	subs	r2, r3, #1
 800ac06:	4193      	sbcs	r3, r2
 800ac08:	2227      	movs	r2, #39	; 0x27
 800ac0a:	425b      	negs	r3, r3
 800ac0c:	4393      	bics	r3, r2
 800ac0e:	4a13      	ldr	r2, [pc, #76]	; (800ac5c <STUSB16xx_HW_IF_RX_DMA_Init+0x6c>)
  hdma_rx_spi->Init.Direction =             DMA_PERIPH_TO_MEMORY;
  hdma_rx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
  hdma_rx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800ac10:	2180      	movs	r1, #128	; 0x80
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800ac12:	189b      	adds	r3, r3, r2
 800ac14:	4a10      	ldr	r2, [pc, #64]	; (800ac58 <STUSB16xx_HW_IF_RX_DMA_Init+0x68>)
{
 800ac16:	0005      	movs	r5, r0
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800ac18:	1994      	adds	r4, r2, r6
 800ac1a:	0022      	movs	r2, r4
  hdma_rx_spi->Init.PeriphDataAlignment =   DMA_PDATAALIGN_BYTE;
  hdma_rx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800ac1c:	0027      	movs	r7, r4
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800ac1e:	32e8      	adds	r2, #232	; 0xe8
 800ac20:	6013      	str	r3, [r2, #0]
  hdma_rx_spi->Init.Direction =             DMA_PERIPH_TO_MEMORY;
 800ac22:	2300      	movs	r3, #0
  hdma_rx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800ac24:	37fc      	adds	r7, #252	; 0xfc
  hdma_rx_spi->Init.Direction =             DMA_PERIPH_TO_MEMORY;
 800ac26:	6053      	str	r3, [r2, #4]
  hdma_rx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800ac28:	6093      	str	r3, [r2, #8]
  hdma_rx_spi->Init.PeriphDataAlignment =   DMA_PDATAALIGN_BYTE;
 800ac2a:	6113      	str	r3, [r2, #16]
  hdma_rx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800ac2c:	603b      	str	r3, [r7, #0]
  hdma_rx_spi->Init.Mode =                  DMA_NORMAL;
 800ac2e:	607b      	str	r3, [r7, #4]
  hdma_rx_spi->Init.Priority =              DMA_PRIORITY_VERY_HIGH;
 800ac30:	23c0      	movs	r3, #192	; 0xc0
 800ac32:	019b      	lsls	r3, r3, #6
 800ac34:	60bb      	str	r3, [r7, #8]
  hdma_rx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800ac36:	60d1      	str	r1, [r2, #12]
  HAL_DMA_Init(hdma_rx_spi);
 800ac38:	9801      	ldr	r0, [sp, #4]
 800ac3a:	f7fc fd8d 	bl	8007758 <HAL_DMA_Init>
  Ports[PortNum].hspi.hdmarx = hdma_rx_spi; 
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmarx,(*hdma_rx_spi));

  /* Enable IRQ DMA */
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800ac3e:	4268      	negs	r0, r5
 800ac40:	4168      	adcs	r0, r5
  Ports[PortNum].hspi.hdmarx = hdma_rx_spi; 
 800ac42:	9b01      	ldr	r3, [sp, #4]
 800ac44:	3498      	adds	r4, #152	; 0x98
 800ac46:	6023      	str	r3, [r4, #0]
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmarx,(*hdma_rx_spi));
 800ac48:	4b03      	ldr	r3, [pc, #12]	; (800ac58 <STUSB16xx_HW_IF_RX_DMA_Init+0x68>)
 800ac4a:	3640      	adds	r6, #64	; 0x40
 800ac4c:	199e      	adds	r6, r3, r6
 800ac4e:	613e      	str	r6, [r7, #16]
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800ac50:	300a      	adds	r0, #10
 800ac52:	f7fc fc7f 	bl	8007554 <HAL_NVIC_EnableIRQ>
  
}
 800ac56:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800ac58:	20000058 	.word	0x20000058
 800ac5c:	40020044 	.word	0x40020044

0800ac60 <STUSB16xx_HW_IF_Set_DMA_Normal_Mode>:
  * @brief  It switches SPI DMA in normal mode
  * @param  PortNum The port index
  * @retval None
  */
void STUSB16xx_HW_IF_Set_DMA_Normal_Mode(uint8_t PortNum)
{
 800ac60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ac62:	24f0      	movs	r4, #240	; 0xf0
 800ac64:	0064      	lsls	r4, r4, #1
 800ac66:	4344      	muls	r4, r0
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800ac68:	4e09      	ldr	r6, [pc, #36]	; (800ac90 <STUSB16xx_HW_IF_Set_DMA_Normal_Mode+0x30>)
 800ac6a:	0027      	movs	r7, r4
  
  hdma_tx_spi->Init.Mode =                  DMA_NORMAL;
 800ac6c:	1935      	adds	r5, r6, r4
 800ac6e:	002b      	movs	r3, r5
 800ac70:	2200      	movs	r2, #0
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800ac72:	37a4      	adds	r7, #164	; 0xa4
 800ac74:	19bf      	adds	r7, r7, r6
  hdma_tx_spi->Init.Mode =                  DMA_NORMAL;
 800ac76:	33bc      	adds	r3, #188	; 0xbc
 800ac78:	601a      	str	r2, [r3, #0]
  HAL_DMA_Init(hdma_tx_spi);
 800ac7a:	0038      	movs	r0, r7
 800ac7c:	f7fc fd6c 	bl	8007758 <HAL_DMA_Init>
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800ac80:	002b      	movs	r3, r5
 800ac82:	3440      	adds	r4, #64	; 0x40
 800ac84:	35c8      	adds	r5, #200	; 0xc8
 800ac86:	19a4      	adds	r4, r4, r6
 800ac88:	3394      	adds	r3, #148	; 0x94
 800ac8a:	601f      	str	r7, [r3, #0]
 800ac8c:	602c      	str	r4, [r5, #0]
}
 800ac8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ac90:	20000058 	.word	0x20000058

0800ac94 <STUSB16xx_HW_IF_Set_DMA_Circular_Mode>:
  * @brief  It switches SPI DMA in circular mode
  * @param  PortNum The port index
  * @retval None
  */
void STUSB16xx_HW_IF_Set_DMA_Circular_Mode(uint8_t PortNum)
{
 800ac94:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800ac96:	24f0      	movs	r4, #240	; 0xf0
 800ac98:	0064      	lsls	r4, r4, #1
 800ac9a:	4344      	muls	r4, r0
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800ac9c:	0023      	movs	r3, r4
 800ac9e:	4f0e      	ldr	r7, [pc, #56]	; (800acd8 <STUSB16xx_HW_IF_Set_DMA_Circular_Mode+0x44>)
 800aca0:	33a4      	adds	r3, #164	; 0xa4
  
  hdma_tx_spi->Init.Mode =                  DMA_CIRCULAR;
 800aca2:	193e      	adds	r6, r7, r4
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800aca4:	19db      	adds	r3, r3, r7
 800aca6:	9301      	str	r3, [sp, #4]
  hdma_tx_spi->Init.Mode =                  DMA_CIRCULAR;
 800aca8:	0033      	movs	r3, r6
 800acaa:	2220      	movs	r2, #32
 800acac:	33bc      	adds	r3, #188	; 0xbc
{
 800acae:	0005      	movs	r5, r0
  hdma_tx_spi->Init.Mode =                  DMA_CIRCULAR;
 800acb0:	601a      	str	r2, [r3, #0]
  HAL_DMA_Init(hdma_tx_spi);
 800acb2:	9801      	ldr	r0, [sp, #4]
 800acb4:	f7fc fd50 	bl	8007758 <HAL_DMA_Init>
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800acb8:	0033      	movs	r3, r6
 800acba:	9a01      	ldr	r2, [sp, #4]
 800acbc:	3394      	adds	r3, #148	; 0x94
 800acbe:	601a      	str	r2, [r3, #0]
  
  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800acc0:	4268      	negs	r0, r5
 800acc2:	4168      	adcs	r0, r5
 800acc4:	2200      	movs	r2, #0
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800acc6:	3440      	adds	r4, #64	; 0x40
 800acc8:	36c8      	adds	r6, #200	; 0xc8
 800acca:	19e7      	adds	r7, r4, r7
 800accc:	6037      	str	r7, [r6, #0]
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800acce:	300a      	adds	r0, #10
 800acd0:	0011      	movs	r1, r2
 800acd2:	f7fc fc15 	bl	8007500 <HAL_NVIC_SetPriority>
}
 800acd6:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800acd8:	20000058 	.word	0x20000058

0800acdc <STUSB16xx_HW_IF_Switch_Mode>:
  * @param  PortNum The port index
  * @param  mode Two allowed values:  STUSB16xx_SPI_Mode_TX or STUSB16xx_SPI_Mode_RX
  * @retval None
  */ 
void STUSB16xx_HW_IF_Switch_Mode(uint8_t PortNum, STUSB1602_SPI_Mode_TypeDef mode)
{
 800acdc:	b570      	push	{r4, r5, r6, lr}
 800acde:	000c      	movs	r4, r1

  /* Set the data sampling edge according to mode */
  HW_IF_SPI_Mode(PortNum, mode);  
  
  /* Enable/Disable RX NSS EXT Interrupt */
  HW_IF_NSS_RisingFalling_Interrupt (PortNum, mode == STUSB16xx_SPI_Mode_RX ? ENABLE : DISABLE);
 800ace0:	3c01      	subs	r4, #1
{
 800ace2:	0005      	movs	r5, r0
  HW_IF_SPI_Mode(PortNum, mode);  
 800ace4:	f7ff fc16 	bl	800a514 <HW_IF_SPI_Mode>
  HW_IF_NSS_RisingFalling_Interrupt (PortNum, mode == STUSB16xx_SPI_Mode_RX ? ENABLE : DISABLE);
 800ace8:	4261      	negs	r1, r4
 800acea:	4161      	adcs	r1, r4
 800acec:	0028      	movs	r0, r5
 800acee:	b2c9      	uxtb	r1, r1
 800acf0:	f7ff fe9a 	bl	800aa28 <HW_IF_NSS_RisingFalling_Interrupt>
}
 800acf4:	bd70      	pop	{r4, r5, r6, pc}
	...

0800acf8 <STUSB16xx_HW_IF_TX_EN_Status>:
  * @param  PortNum The port index
  * @param  status Two allowed values: GPIO_PIN_SET or GPIO_PIN_RESET
  * @retval None
  */ 
void STUSB16xx_HW_IF_TX_EN_Status(uint8_t PortNum, GPIO_PinState status)
{
 800acf8:	000a      	movs	r2, r1
 800acfa:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(TX_EN_GPIO_PORT(PortNum), TX_EN_GPIO_PIN(PortNum), status);
 800acfc:	2104      	movs	r1, #4
 800acfe:	2800      	cmp	r0, #0
 800ad00:	d000      	beq.n	800ad04 <STUSB16xx_HW_IF_TX_EN_Status+0xc>
 800ad02:	1849      	adds	r1, r1, r1
 800ad04:	4801      	ldr	r0, [pc, #4]	; (800ad0c <STUSB16xx_HW_IF_TX_EN_Status+0x14>)
 800ad06:	f7fc fe97 	bl	8007a38 <HAL_GPIO_WritePin>
}
 800ad0a:	bd10      	pop	{r4, pc}
 800ad0c:	48000800 	.word	0x48000800

0800ad10 <HW_IF_STUSB16xx_Reset>:
{
 800ad10:	b570      	push	{r4, r5, r6, lr}
 800ad12:	0005      	movs	r5, r0
  HW_IF_RESET_Assert(PortNum);
 800ad14:	2478      	movs	r4, #120	; 0x78
 800ad16:	f7ff fcf5 	bl	800a704 <HW_IF_RESET_Assert>
 800ad1a:	46c0      	nop			; (mov r8, r8)
 800ad1c:	3c01      	subs	r4, #1
 800ad1e:	b2a4      	uxth	r4, r4
  for(uint16_t i=0;i<120;i++) 
 800ad20:	2c00      	cmp	r4, #0
 800ad22:	d1fa      	bne.n	800ad1a <HW_IF_STUSB16xx_Reset+0xa>
  HW_IF_RESET_Deassert(PortNum);
 800ad24:	0028      	movs	r0, r5
 800ad26:	f7ff fcf9 	bl	800a71c <HW_IF_RESET_Deassert>
  STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_RESET);
 800ad2a:	0028      	movs	r0, r5
 800ad2c:	0021      	movs	r1, r4
 800ad2e:	f7ff ffe3 	bl	800acf8 <STUSB16xx_HW_IF_TX_EN_Status>
}
 800ad32:	bd70      	pop	{r4, r5, r6, pc}

0800ad34 <USBPD_HW_IF_PortHwInit>:
{
 800ad34:	b084      	sub	sp, #16
 800ad36:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ad38:	b093      	sub	sp, #76	; 0x4c
 800ad3a:	ac19      	add	r4, sp, #100	; 0x64
 800ad3c:	60a3      	str	r3, [r4, #8]
 800ad3e:	ab1f      	add	r3, sp, #124	; 0x7c
 800ad40:	781b      	ldrb	r3, [r3, #0]
 800ad42:	0005      	movs	r5, r0
 800ad44:	9311      	str	r3, [sp, #68]	; 0x44
  nvm_read = 0;
 800ad46:	2300      	movs	r3, #0
 800ad48:	4f2e      	ldr	r7, [pc, #184]	; (800ae04 <USBPD_HW_IF_PortHwInit+0xd0>)
{
 800ad4a:	9119      	str	r1, [sp, #100]	; 0x64
 800ad4c:	6062      	str	r2, [r4, #4]
  nvm_read = 0;
 800ad4e:	703b      	strb	r3, [r7, #0]
  HW_IF_STUSB1602_IO_Init(PortNum);
 800ad50:	f7ff fc62 	bl	800a618 <HW_IF_STUSB1602_IO_Init>
  HW_IF_STUSB16xx_Reset(PortNum);
 800ad54:	0028      	movs	r0, r5
 800ad56:	f7ff ffdb 	bl	800ad10 <HW_IF_STUSB16xx_Reset>
  HW_IF_STUSB16xx_I2C_Init(PortNum);
 800ad5a:	0028      	movs	r0, r5
 800ad5c:	f7ff fc36 	bl	800a5cc <HW_IF_STUSB16xx_I2C_Init>
  STUSB1602_Driver_Init(PortNum, Ports[PortNum].hi2c);
 800ad60:	21f0      	movs	r1, #240	; 0xf0
 800ad62:	0049      	lsls	r1, r1, #1
 800ad64:	4369      	muls	r1, r5
 800ad66:	4b28      	ldr	r3, [pc, #160]	; (800ae08 <USBPD_HW_IF_PortHwInit+0xd4>)
 800ad68:	2240      	movs	r2, #64	; 0x40
 800ad6a:	1859      	adds	r1, r3, r1
 800ad6c:	000e      	movs	r6, r1
 800ad6e:	3629      	adds	r6, #41	; 0x29
 800ad70:	36ff      	adds	r6, #255	; 0xff
 800ad72:	3139      	adds	r1, #57	; 0x39
 800ad74:	31ff      	adds	r1, #255	; 0xff
 800ad76:	4668      	mov	r0, sp
 800ad78:	3604      	adds	r6, #4
 800ad7a:	f001 fbff 	bl	800c57c <memcpy>
 800ad7e:	ce0e      	ldmia	r6!, {r1, r2, r3}
  nvm_read = STUSB1602_NVM_OK_Get(STUSB1602_I2C_Add(PortNum));
 800ad80:	002e      	movs	r6, r5
  STUSB1602_Driver_Init(PortNum, Ports[PortNum].hi2c);
 800ad82:	0028      	movs	r0, r5
 800ad84:	f7fb fd88 	bl	8006898 <STUSB1602_Driver_Init>
  nvm_read = STUSB1602_NVM_OK_Get(STUSB1602_I2C_Add(PortNum));
 800ad88:	1e73      	subs	r3, r6, #1
 800ad8a:	419e      	sbcs	r6, r3
 800ad8c:	3628      	adds	r6, #40	; 0x28
    nvm_read = STUSB1602_NVM_OK_Get(STUSB1602_I2C_Add(PortNum));
 800ad8e:	0030      	movs	r0, r6
 800ad90:	f7fc f81a 	bl	8006dc8 <STUSB1602_NVM_OK_Get>
 800ad94:	7038      	strb	r0, [r7, #0]
  while (nvm_read != 2)
 800ad96:	783b      	ldrb	r3, [r7, #0]
 800ad98:	2b02      	cmp	r3, #2
 800ad9a:	d1f8      	bne.n	800ad8e <USBPD_HW_IF_PortHwInit+0x5a>
  Ports[PortNum].Device_cut = STUSB1602_DEVICE_CUT_Get(STUSB1602_I2C_Add(PortNum));
 800ad9c:	27f0      	movs	r7, #240	; 0xf0
 800ad9e:	007f      	lsls	r7, r7, #1
 800ada0:	436f      	muls	r7, r5
 800ada2:	0030      	movs	r0, r6
 800ada4:	f7fc f81c 	bl	8006de0 <STUSB1602_DEVICE_CUT_Get>
 800ada8:	4b17      	ldr	r3, [pc, #92]	; (800ae08 <USBPD_HW_IF_PortHwInit+0xd4>)
 800adaa:	19df      	adds	r7, r3, r7
 800adac:	003b      	movs	r3, r7
 800adae:	33d9      	adds	r3, #217	; 0xd9
 800adb0:	33ff      	adds	r3, #255	; 0xff
 800adb2:	7018      	strb	r0, [r3, #0]
  HW_IF_DMA_Init(PortNum);
 800adb4:	0028      	movs	r0, r5
 800adb6:	f7ff fbf1 	bl	800a59c <HW_IF_DMA_Init>
  HW_IF_SPI_Init(PortNum);
 800adba:	0028      	movs	r0, r5
 800adbc:	f7ff fb7c 	bl	800a4b8 <HW_IF_SPI_Init>
  HW_IF_COUNTER_TIM_Init(PortNum);
 800adc0:	0028      	movs	r0, r5
 800adc2:	f7ff fe83 	bl	800aacc <HW_IF_COUNTER_TIM_Init>
  HW_IF_Port_SetInitialRole(PortNum,role);
 800adc6:	9911      	ldr	r1, [sp, #68]	; 0x44
 800adc8:	0028      	movs	r0, r5
 800adca:	f7ff fcd3 	bl	800a774 <HW_IF_Port_SetInitialRole>
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_RX);
 800adce:	0028      	movs	r0, r5
 800add0:	2101      	movs	r1, #1
 800add2:	f7ff ff83 	bl	800acdc <STUSB16xx_HW_IF_Switch_Mode>
    STUSB1602_CC_Detect_Alrt_Int_Mask_Set(STUSB1602_I2C_Add(PortNum), CC_Detect_Int_UNMASKED);
 800add6:	2100      	movs	r1, #0
 800add8:	0030      	movs	r0, r6
 800adda:	f7fb fda1 	bl	8006920 <STUSB1602_CC_Detect_Alrt_Int_Mask_Set>
  Ports[PortNum].cbs = cbs;
 800adde:	003a      	movs	r2, r7
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800ade0:	2301      	movs	r3, #1
  Ports[PortNum].cbs = cbs;
 800ade2:	32b9      	adds	r2, #185	; 0xb9
 800ade4:	32ff      	adds	r2, #255	; 0xff
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800ade6:	767b      	strb	r3, [r7, #25]
  Ports[PortNum].cbs = cbs;
 800ade8:	0013      	movs	r3, r2
 800adea:	cc07      	ldmia	r4!, {r0, r1, r2}
 800adec:	c307      	stmia	r3!, {r0, r1, r2}
 800adee:	cc07      	ldmia	r4!, {r0, r1, r2}
 800adf0:	c307      	stmia	r3!, {r0, r1, r2}
}
 800adf2:	2000      	movs	r0, #0
  Ports[PortNum].role = role;
 800adf4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800adf6:	3701      	adds	r7, #1
 800adf8:	77fb      	strb	r3, [r7, #31]
}
 800adfa:	b013      	add	sp, #76	; 0x4c
 800adfc:	bcf0      	pop	{r4, r5, r6, r7}
 800adfe:	bc08      	pop	{r3}
 800ae00:	b004      	add	sp, #16
 800ae02:	4718      	bx	r3
 800ae04:	200003e0 	.word	0x200003e0
 800ae08:	20000058 	.word	0x20000058

0800ae0c <STUSB16xx_HW_IF_Alert_Check>:
  * @param  PortNum The port index
  * @retval None
  */ 
void STUSB16xx_HW_IF_Alert_Check(uint8_t PortNum)
{
  Ports[PortNum].AlertEventCount++;
 800ae0c:	23f0      	movs	r3, #240	; 0xf0
 800ae0e:	005b      	lsls	r3, r3, #1
 800ae10:	4343      	muls	r3, r0
 800ae12:	4804      	ldr	r0, [pc, #16]	; (800ae24 <STUSB16xx_HW_IF_Alert_Check+0x18>)
 800ae14:	18c0      	adds	r0, r0, r3
 800ae16:	30d1      	adds	r0, #209	; 0xd1
 800ae18:	30ff      	adds	r0, #255	; 0xff
 800ae1a:	7803      	ldrb	r3, [r0, #0]
 800ae1c:	3301      	adds	r3, #1
 800ae1e:	7003      	strb	r3, [r0, #0]
}
 800ae20:	4770      	bx	lr
 800ae22:	46c0      	nop			; (mov r8, r8)
 800ae24:	20000058 	.word	0x20000058

0800ae28 <STUSB16xx_HW_IF_Alert_Manager>:
  * @brief  It manages registers related to STUSB1602 ALERT interrupts
  * @param  PortNum The port index
  * @retval USBPD_StatusTypeDef
  */ 
USBPD_StatusTypeDef STUSB16xx_HW_IF_Alert_Manager(uint8_t PortNum)
{
 800ae28:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ae2a:	0004      	movs	r4, r0
 800ae2c:	26c8      	movs	r6, #200	; 0xc8
 800ae2e:	b085      	sub	sp, #20
 800ae30:	46c0      	nop			; (mov r8, r8)
 800ae32:	3e01      	subs	r6, #1
  uint8_t AlertAttempts;
  uint8_t AlertAccomplished;
  uint32_t i;

  /* Delay of few us in order to be sure that registers are updated*/
  for(i=0; i<200; i++)
 800ae34:	2e00      	cmp	r6, #0
 800ae36:	d1fb      	bne.n	800ae30 <STUSB16xx_HW_IF_Alert_Manager+0x8>
  AlertAttempts = 10;
  
  while(1)
  {
    /* Registers from 0x0B to 0x12 are read */
    STUSB1602_AlertMonitoring_Value = STUSB1602_Alert_Monitoring_Get(STUSB1602_I2C_Add(PortNum));
 800ae38:	0025      	movs	r5, r4
 800ae3a:	1e6b      	subs	r3, r5, #1
 800ae3c:	419d      	sbcs	r5, r3
 800ae3e:	3528      	adds	r5, #40	; 0x28
 800ae40:	0029      	movs	r1, r5
 800ae42:	a802      	add	r0, sp, #8
 800ae44:	f7fb fd5e 	bl	8006904 <STUSB1602_Alert_Monitoring_Get>
    
    /* Check ALERT due to a change occurred on CC */
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.CC_DETECTION_STATUS_AL) && \
 800ae48:	2240      	movs	r2, #64	; 0x40
 800ae4a:	ab02      	add	r3, sp, #8
 800ae4c:	781b      	ldrb	r3, [r3, #0]
 800ae4e:	9301      	str	r3, [sp, #4]
 800ae50:	9901      	ldr	r1, [sp, #4]
  AlertAccomplished = 0;
 800ae52:	0033      	movs	r3, r6
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.CC_DETECTION_STATUS_AL) && \
 800ae54:	4211      	tst	r1, r2
 800ae56:	d03e      	beq.n	800aed6 <STUSB16xx_HW_IF_Alert_Manager+0xae>
        (!STUSB1602_AlertMonitoring_Value.reg_0C.b.CC_DETECTION_STATUS_AL_MASK) && \
 800ae58:	ab02      	add	r3, sp, #8
 800ae5a:	7859      	ldrb	r1, [r3, #1]
  AlertAccomplished = 0;
 800ae5c:	0033      	movs	r3, r6
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.CC_DETECTION_STATUS_AL) && \
 800ae5e:	4211      	tst	r1, r2
 800ae60:	d139      	bne.n	800aed6 <STUSB16xx_HW_IF_Alert_Manager+0xae>
        (!STUSB1602_AlertMonitoring_Value.reg_0C.b.CC_DETECTION_STATUS_AL_MASK) && \
 800ae62:	2701      	movs	r7, #1
 800ae64:	ab02      	add	r3, sp, #8
 800ae66:	789a      	ldrb	r2, [r3, #2]
  AlertAccomplished = 0;
 800ae68:	0033      	movs	r3, r6
        (!STUSB1602_AlertMonitoring_Value.reg_0C.b.CC_DETECTION_STATUS_AL_MASK) && \
 800ae6a:	423a      	tst	r2, r7
 800ae6c:	d033      	beq.n	800aed6 <STUSB16xx_HW_IF_Alert_Manager+0xae>
        (STUSB1602_AlertMonitoring_Value.reg_0D.b.ATTACH_STATE_TRANS))
    {
      if (STUSB1602_AlertMonitoring_Value.reg_0E.b.CC_ATTACH_STATE)     /* CC line is ATTACHED */
 800ae6e:	ab02      	add	r3, sp, #8
 800ae70:	78d8      	ldrb	r0, [r3, #3]
 800ae72:	496b      	ldr	r1, [pc, #428]	; (800b020 <STUSB16xx_HW_IF_Alert_Manager+0x1f8>)
 800ae74:	4238      	tst	r0, r7
 800ae76:	d100      	bne.n	800ae7a <STUSB16xx_HW_IF_Alert_Manager+0x52>
 800ae78:	e093      	b.n	800afa2 <STUSB16xx_HW_IF_Alert_Manager+0x17a>
      {
        /* Check the CC attach mode */
        switch (STUSB1602_AlertMonitoring_Value.reg_0E.b.CC_ATTACH_MODE)
 800ae7a:	0940      	lsrs	r0, r0, #5
 800ae7c:	3801      	subs	r0, #1
 800ae7e:	2318      	movs	r3, #24
 800ae80:	2804      	cmp	r0, #4
 800ae82:	d900      	bls.n	800ae86 <STUSB16xx_HW_IF_Alert_Manager+0x5e>
 800ae84:	e085      	b.n	800af92 <STUSB16xx_HW_IF_Alert_Manager+0x16a>
 800ae86:	f7fa fd8b 	bl	80059a0 <__gnu_thumb1_case_uqi>
 800ae8a:	6c03      	.short	0x6c03
 800ae8c:	747c      	.short	0x747c
 800ae8e:	0c          	.byte	0x0c
 800ae8f:	00          	.byte	0x00
        {
        case Sink_Attached:
          /* USBPD_CAD_STATE_ATTACHED */
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_SWITCH_TO_SRC;
 800ae90:	4363      	muls	r3, r4
 800ae92:	18cb      	adds	r3, r1, r3
 800ae94:	210f      	movs	r1, #15
 800ae96:	7c1a      	ldrb	r2, [r3, #16]
 800ae98:	438a      	bics	r2, r1
 800ae9a:	0011      	movs	r1, r2
 800ae9c:	2209      	movs	r2, #9
          /*  */
          break;

        default:
          /* USPPD_CAD_STATE_UNKNOWN */
          CAD_HW_Handles[PortNum].state = USPPD_CAD_STATE_UNKNOW;
 800ae9e:	430a      	orrs	r2, r1
 800aea0:	741a      	strb	r2, [r3, #16]
          break;
        }

        /* CAD handle is updated */
        CAD_HW_Handles[PortNum].cc = CCXHANDLE(STUSB1602_AlertMonitoring_Value.reg_11.b.CC_ATTACHED);
 800aea2:	2118      	movs	r1, #24
 800aea4:	2630      	movs	r6, #48	; 0x30
 800aea6:	4361      	muls	r1, r4
 800aea8:	4a5d      	ldr	r2, [pc, #372]	; (800b020 <STUSB16xx_HW_IF_Alert_Manager+0x1f8>)
 800aeaa:	ab02      	add	r3, sp, #8
 800aeac:	799b      	ldrb	r3, [r3, #6]
 800aeae:	1851      	adds	r1, r2, r1
 800aeb0:	7c0a      	ldrb	r2, [r1, #16]
 800aeb2:	09db      	lsrs	r3, r3, #7
 800aeb4:	3301      	adds	r3, #1
 800aeb6:	0118      	lsls	r0, r3, #4
 800aeb8:	43b2      	bics	r2, r6
 800aeba:	4302      	orrs	r2, r0
 800aebc:	740a      	strb	r2, [r1, #16]
  Ports[PortNum].CCx = cc;
 800aebe:	21f0      	movs	r1, #240	; 0xf0
 800aec0:	0049      	lsls	r1, r1, #1
 800aec2:	4361      	muls	r1, r4
 800aec4:	4a57      	ldr	r2, [pc, #348]	; (800b024 <STUSB16xx_HW_IF_Alert_Manager+0x1fc>)
  Ports[PortNum].CCxChange = SET;
 800aec6:	3e2f      	subs	r6, #47	; 0x2f
  Ports[PortNum].CCx = cc;
 800aec8:	1852      	adds	r2, r2, r1
 800aeca:	7593      	strb	r3, [r2, #22]
  Ports[PortNum].CCxChange = SET;
 800aecc:	75d6      	strb	r6, [r2, #23]

        /* Port handle is updated */
        HW_IF_Port_Set_CC(PortNum, CAD_HW_Handles[PortNum].cc);

        /* RX mode is enabled */
        HW_IF_RX_Enable(PortNum);
 800aece:	0020      	movs	r0, r4
 800aed0:	f7ff fc30 	bl	800a734 <HW_IF_RX_Enable>
        /* TX mode is enabled */
        HW_IF_RX_Disable(PortNum);
      }

      /* Exit from the alert check procedure */
      AlertAccomplished = 1;
 800aed4:	0033      	movs	r3, r6
    }

    /* Check if a MONITORING STATUS ALERT detected */
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.MONITORING_STATUS_AL) && \
 800aed6:	2220      	movs	r2, #32
 800aed8:	9901      	ldr	r1, [sp, #4]
 800aeda:	4211      	tst	r1, r2
 800aedc:	d00b      	beq.n	800aef6 <STUSB16xx_HW_IF_Alert_Manager+0xce>
      (!STUSB1602_AlertMonitoring_Value.reg_0C.b.MONITORING_STATUS_AL_MASK)) 
 800aede:	a902      	add	r1, sp, #8
 800aee0:	7849      	ldrb	r1, [r1, #1]
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.MONITORING_STATUS_AL) && \
 800aee2:	4211      	tst	r1, r2
 800aee4:	d107      	bne.n	800aef6 <STUSB16xx_HW_IF_Alert_Manager+0xce>
    {
      /* Check changes occurred in MONITORING STATUS register and restore the ALERT pin */
      STUSB1602_Monitoring_Status_Trans_Value = STUSB1602_Monitoring_Status_Trans_Reg_Get(STUSB1602_I2C_Add(PortNum));
 800aee6:	0028      	movs	r0, r5
 800aee8:	f7fb fd48 	bl	800697c <STUSB1602_Monitoring_Status_Trans_Reg_Get>

      /* Exit from the alert check procedure */
      AlertAccomplished = 1;

      /* If the alert due to a monitoring event is unmasked remove the if statement and put your code */
      if (STUSB1602_Monitoring_Status_Trans_Value.d8 >0)
 800aeec:	b2c0      	uxtb	r0, r0
      AlertAccomplished = 1;
 800aeee:	2301      	movs	r3, #1
      if (STUSB1602_Monitoring_Status_Trans_Value.d8 >0)
 800aef0:	2800      	cmp	r0, #0
 800aef2:	d000      	beq.n	800aef6 <STUSB16xx_HW_IF_Alert_Manager+0xce>
 800aef4:	46c0      	nop			; (mov r8, r8)
        __NOP();
      }
    }

    /* Check if a HW FAULT STATUS ALERT detected */
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.HW_FAULT_STATUS_AL) && \
 800aef6:	aa02      	add	r2, sp, #8
 800aef8:	7811      	ldrb	r1, [r2, #0]
 800aefa:	2210      	movs	r2, #16
 800aefc:	4211      	tst	r1, r2
 800aefe:	d066      	beq.n	800afce <STUSB16xx_HW_IF_Alert_Manager+0x1a6>
      (!STUSB1602_AlertMonitoring_Value.reg_0C.b.HW_FAULT_STATUS_AL_MASK)) 
 800af00:	a902      	add	r1, sp, #8
 800af02:	7849      	ldrb	r1, [r1, #1]
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.HW_FAULT_STATUS_AL) && \
 800af04:	4211      	tst	r1, r2
 800af06:	d162      	bne.n	800afce <STUSB16xx_HW_IF_Alert_Manager+0x1a6>
    {
      /* Check changes occurred in HW FAULT STATUS register and restore the ALERT pin */
      STUSB1602_HW_Fault_Status_Trans_Value = STUSB1602_Hard_Fault_Trans_Status_Get(STUSB1602_I2C_Add(PortNum));
 800af08:	0028      	movs	r0, r5
 800af0a:	f7fb fd7d 	bl	8006a08 <STUSB1602_Hard_Fault_Trans_Status_Get>

      /* Exit from the alert check procedure */
      AlertAccomplished = 1;

      /* If the alert due to a hardware fault event is unmasked remove then if statement and put your code*/
      if (STUSB1602_HW_Fault_Status_Trans_Value.d8 >0)
 800af0e:	b2c0      	uxtb	r0, r0
 800af10:	2800      	cmp	r0, #0
 800af12:	d000      	beq.n	800af16 <STUSB16xx_HW_IF_Alert_Manager+0xee>
 800af14:	46c0      	nop			; (mov r8, r8)
 800af16:	2604      	movs	r6, #4
 800af18:	2c00      	cmp	r4, #0
 800af1a:	d100      	bne.n	800af1e <STUSB16xx_HW_IF_Alert_Manager+0xf6>
 800af1c:	2602      	movs	r6, #2
 800af1e:	270a      	movs	r7, #10
 800af20:	b2b6      	uxth	r6, r6
  /* reset alert signal */
  uint8_t count = 10;
  uint8_t cleared_alert_flag = 0;
  while (1)
  {
    cleared_alert_flag = (HAL_GPIO_ReadPin(ALERT_GPIO_PORT(PortNum), ALERT_GPIO_PIN(PortNum)) != GPIO_PIN_RESET);
 800af22:	2090      	movs	r0, #144	; 0x90
 800af24:	0031      	movs	r1, r6
 800af26:	05c0      	lsls	r0, r0, #23
 800af28:	f7fc fd80 	bl	8007a2c <HAL_GPIO_ReadPin>
 800af2c:	1e04      	subs	r4, r0, #0
    /* check if the alert pin is reset */
    if (cleared_alert_flag || count == 0) 
 800af2e:	d158      	bne.n	800afe2 <STUSB16xx_HW_IF_Alert_Manager+0x1ba>
 800af30:	2f00      	cmp	r7, #0
 800af32:	d056      	beq.n	800afe2 <STUSB16xx_HW_IF_Alert_Manager+0x1ba>
    {
      break;
    }
    if (STUSB16xx_I2CxHandle.Lock != HAL_LOCKED)
 800af34:	4b3c      	ldr	r3, [pc, #240]	; (800b028 <STUSB16xx_HW_IF_Alert_Manager+0x200>)
 800af36:	3340      	adds	r3, #64	; 0x40
 800af38:	781b      	ldrb	r3, [r3, #0]
 800af3a:	2b01      	cmp	r3, #1
 800af3c:	d0f1      	beq.n	800af22 <STUSB16xx_HW_IF_Alert_Manager+0xfa>
    {
      /* Restore the CC_DETECTION_STATUS_TRANS register*/
      STUSB1602_Attach_State_Trans_Get(STUSB1602_I2C_Add(PortNum));
 800af3e:	0028      	movs	r0, r5
 800af40:	f7fb fd06 	bl	8006950 <STUSB1602_Attach_State_Trans_Get>

      /* Restore the MONITORING_STATUS_TRANS register */
      STUSB1602_Monitoring_Status_Trans_Reg_Get(STUSB1602_I2C_Add(PortNum));
 800af44:	0028      	movs	r0, r5
 800af46:	f7fb fd19 	bl	800697c <STUSB1602_Monitoring_Status_Trans_Reg_Get>

      /* Restore the HARD_FAULT_TRANS register */
      STUSB1602_Hard_Fault_Trans_Status_Get(STUSB1602_I2C_Add(PortNum));
 800af4a:	0028      	movs	r0, r5
 800af4c:	f7fb fd5c 	bl	8006a08 <STUSB1602_Hard_Fault_Trans_Status_Get>

      /* Decrement the counter to implement a TO */
      count--;
 800af50:	23fa      	movs	r3, #250	; 0xfa
 800af52:	3f01      	subs	r7, #1
 800af54:	b2ff      	uxtb	r7, r7
 800af56:	009b      	lsls	r3, r3, #2
 800af58:	46c0      	nop			; (mov r8, r8)
 800af5a:	3b01      	subs	r3, #1

      /* wait a bit time */
      for(i=0; i<1000; i++)
 800af5c:	2b00      	cmp	r3, #0
 800af5e:	d1fb      	bne.n	800af58 <STUSB16xx_HW_IF_Alert_Manager+0x130>
 800af60:	e7df      	b.n	800af22 <STUSB16xx_HW_IF_Alert_Manager+0xfa>
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_SWITCH_TO_SNK;
 800af62:	4363      	muls	r3, r4
 800af64:	18cb      	adds	r3, r1, r3
 800af66:	210f      	movs	r1, #15
 800af68:	7c1a      	ldrb	r2, [r3, #16]
 800af6a:	438a      	bics	r2, r1
 800af6c:	0011      	movs	r1, r2
 800af6e:	220a      	movs	r2, #10
 800af70:	e795      	b.n	800ae9e <STUSB16xx_HW_IF_Alert_Manager+0x76>
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_ACCESSORY;
 800af72:	4363      	muls	r3, r4
 800af74:	18cb      	adds	r3, r1, r3
 800af76:	210f      	movs	r1, #15
 800af78:	7c1a      	ldrb	r2, [r3, #16]
 800af7a:	438a      	bics	r2, r1
 800af7c:	0011      	movs	r1, r2
 800af7e:	2207      	movs	r2, #7
 800af80:	e78d      	b.n	800ae9e <STUSB16xx_HW_IF_Alert_Manager+0x76>
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_DEBUG;
 800af82:	4363      	muls	r3, r4
 800af84:	18cb      	adds	r3, r1, r3
 800af86:	210f      	movs	r1, #15
 800af88:	7c1a      	ldrb	r2, [r3, #16]
 800af8a:	438a      	bics	r2, r1
 800af8c:	0011      	movs	r1, r2
 800af8e:	2208      	movs	r2, #8
 800af90:	e785      	b.n	800ae9e <STUSB16xx_HW_IF_Alert_Manager+0x76>
          CAD_HW_Handles[PortNum].state = USPPD_CAD_STATE_UNKNOW;
 800af92:	4363      	muls	r3, r4
 800af94:	18cb      	adds	r3, r1, r3
 800af96:	210f      	movs	r1, #15
 800af98:	7c1a      	ldrb	r2, [r3, #16]
 800af9a:	438a      	bics	r2, r1
 800af9c:	0011      	movs	r1, r2
 800af9e:	220c      	movs	r2, #12
 800afa0:	e77d      	b.n	800ae9e <STUSB16xx_HW_IF_Alert_Manager+0x76>
        CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_DETACHED;
 800afa2:	2318      	movs	r3, #24
 800afa4:	4363      	muls	r3, r4
 800afa6:	18cb      	adds	r3, r1, r3
 800afa8:	210f      	movs	r1, #15
 800afaa:	7c1a      	ldrb	r2, [r3, #16]
        HW_IF_RX_Disable(PortNum);
 800afac:	0020      	movs	r0, r4
        CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_DETACHED;
 800afae:	438a      	bics	r2, r1
        CAD_HW_Handles[PortNum].cc = CCNONE;
 800afb0:	433a      	orrs	r2, r7
 800afb2:	3121      	adds	r1, #33	; 0x21
 800afb4:	438a      	bics	r2, r1
 800afb6:	741a      	strb	r2, [r3, #16]
  Ports[PortNum].CCx = cc;
 800afb8:	22f0      	movs	r2, #240	; 0xf0
 800afba:	0052      	lsls	r2, r2, #1
 800afbc:	4362      	muls	r2, r4
 800afbe:	4b19      	ldr	r3, [pc, #100]	; (800b024 <STUSB16xx_HW_IF_Alert_Manager+0x1fc>)
 800afc0:	189b      	adds	r3, r3, r2
 800afc2:	759e      	strb	r6, [r3, #22]
  Ports[PortNum].CCxChange = SET;
 800afc4:	75df      	strb	r7, [r3, #23]
        HW_IF_RX_Disable(PortNum);
 800afc6:	f7ff fbc5 	bl	800a754 <HW_IF_RX_Disable>
      AlertAccomplished = 1;
 800afca:	003b      	movs	r3, r7
 800afcc:	e783      	b.n	800aed6 <STUSB16xx_HW_IF_Alert_Manager+0xae>
    if (AlertAttempts == 0 || AlertAccomplished)
 800afce:	2b00      	cmp	r3, #0
 800afd0:	d1a1      	bne.n	800af16 <STUSB16xx_HW_IF_Alert_Manager+0xee>
 800afd2:	330a      	adds	r3, #10
 800afd4:	46c0      	nop			; (mov r8, r8)
 800afd6:	3b01      	subs	r3, #1
    for(i=0; i<10; i++)
 800afd8:	2b00      	cmp	r3, #0
 800afda:	d1fb      	bne.n	800afd4 <STUSB16xx_HW_IF_Alert_Manager+0x1ac>
      for(i=0; i<400000; i++) __NOP();
    }

  }
  return USBPD_OK;
} 
 800afdc:	2000      	movs	r0, #0
 800afde:	b005      	add	sp, #20
 800afe0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cleared_alert_flag |= (HAL_GPIO_ReadPin(ALERT_GPIO_PORT(PortNum), ALERT_GPIO_PIN(PortNum)) != GPIO_PIN_RESET);
 800afe2:	2090      	movs	r0, #144	; 0x90
 800afe4:	0031      	movs	r1, r6
 800afe6:	05c0      	lsls	r0, r0, #23
 800afe8:	f7fc fd20 	bl	8007a2c <HAL_GPIO_ReadPin>
  if (!cleared_alert_flag) {
 800afec:	4304      	orrs	r4, r0
 800afee:	b2e4      	uxtb	r4, r4
 800aff0:	2c00      	cmp	r4, #0
 800aff2:	d1f3      	bne.n	800afdc <STUSB16xx_HW_IF_Alert_Manager+0x1b4>
    USBPD_BSP_LED_Off(GREEN_USER_LED);
 800aff4:	2001      	movs	r0, #1
 800aff6:	f7fb ff81 	bl	8006efc <USBPD_BSP_LED_Off>
    USBPD_BSP_LED_Off(LED_PORT0_CC);
 800affa:	2003      	movs	r0, #3
 800affc:	f7fb ff7e 	bl	8006efc <USBPD_BSP_LED_Off>
    USBPD_BSP_LED_Off(LED_PORT0_VBUS);
 800b000:	2002      	movs	r0, #2
 800b002:	f7fb ff7b 	bl	8006efc <USBPD_BSP_LED_Off>
    USBPD_BSP_LED_Off(LED_PORT0_ROLE);
 800b006:	0020      	movs	r0, r4
 800b008:	f7fb ff78 	bl	8006efc <USBPD_BSP_LED_Off>
      USBPD_BSP_LED_Toggle(PortNum == 0 ? LED_PORT0_CC : LED_PORT0_CC);
 800b00c:	2003      	movs	r0, #3
 800b00e:	f7fb ff9f 	bl	8006f50 <USBPD_BSP_LED_Toggle>
 800b012:	4b06      	ldr	r3, [pc, #24]	; (800b02c <STUSB16xx_HW_IF_Alert_Manager+0x204>)
 800b014:	46c0      	nop			; (mov r8, r8)
 800b016:	3b01      	subs	r3, #1
      for(i=0; i<400000; i++) __NOP();
 800b018:	2b00      	cmp	r3, #0
 800b01a:	d1fb      	bne.n	800b014 <STUSB16xx_HW_IF_Alert_Manager+0x1ec>
 800b01c:	e7f6      	b.n	800b00c <STUSB16xx_HW_IF_Alert_Manager+0x1e4>
 800b01e:	46c0      	nop			; (mov r8, r8)
 800b020:	20001b8c 	.word	0x20001b8c
 800b024:	20000058 	.word	0x20000058
 800b028:	200019e4 	.word	0x200019e4
 800b02c:	00061a80 	.word	0x00061a80

0800b030 <CAD_StateMachine>:
{
 800b030:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (hhw_handle->AlertEventCount > 0)
 800b032:	27f0      	movs	r7, #240	; 0xf0
{
 800b034:	000d      	movs	r5, r1
  *Event = USBPD_CAD_EVENT_NONE;
 800b036:	2100      	movs	r1, #0
  if (hhw_handle->AlertEventCount > 0)
 800b038:	007f      	lsls	r7, r7, #1
 800b03a:	4347      	muls	r7, r0
 800b03c:	4e51      	ldr	r6, [pc, #324]	; (800b184 <CAD_StateMachine+0x154>)
{
 800b03e:	0004      	movs	r4, r0
  if (hhw_handle->AlertEventCount > 0)
 800b040:	19f7      	adds	r7, r6, r7
 800b042:	37d1      	adds	r7, #209	; 0xd1
 800b044:	37ff      	adds	r7, #255	; 0xff
 800b046:	783b      	ldrb	r3, [r7, #0]
{
 800b048:	9201      	str	r2, [sp, #4]
  *Event = USBPD_CAD_EVENT_NONE;
 800b04a:	7029      	strb	r1, [r5, #0]
  if (hhw_handle->AlertEventCount > 0)
 800b04c:	428b      	cmp	r3, r1
 800b04e:	d00c      	beq.n	800b06a <CAD_StateMachine+0x3a>
    ret = HW_IF_COMM_WAIT(PortNum, 0);
 800b050:	f7ff f95a 	bl	800a308 <HW_IF_COMM_WAIT>
    if (ret == USBPD_OK)
 800b054:	2800      	cmp	r0, #0
 800b056:	d108      	bne.n	800b06a <CAD_StateMachine+0x3a>
      if (STUSB16xx_HW_IF_Alert_Manager(PortNum) == USBPD_OK)
 800b058:	0020      	movs	r0, r4
 800b05a:	f7ff fee5 	bl	800ae28 <STUSB16xx_HW_IF_Alert_Manager>
 800b05e:	2800      	cmp	r0, #0
 800b060:	d100      	bne.n	800b064 <CAD_StateMachine+0x34>
        hhw_handle->AlertEventCount = 0;
 800b062:	7038      	strb	r0, [r7, #0]
      HW_IF_COMM_RELEASE(PortNum);
 800b064:	0020      	movs	r0, r4
 800b066:	f7ff f96d 	bl	800a344 <HW_IF_COMM_RELEASE>
  switch(_handle->state)
 800b06a:	2218      	movs	r2, #24
 800b06c:	0013      	movs	r3, r2
 800b06e:	4363      	muls	r3, r4
 800b070:	4945      	ldr	r1, [pc, #276]	; (800b188 <CAD_StateMachine+0x158>)
 800b072:	18cb      	adds	r3, r1, r3
 800b074:	7c18      	ldrb	r0, [r3, #16]
 800b076:	23f0      	movs	r3, #240	; 0xf0
 800b078:	0700      	lsls	r0, r0, #28
 800b07a:	0f00      	lsrs	r0, r0, #28
 800b07c:	005b      	lsls	r3, r3, #1
 800b07e:	280a      	cmp	r0, #10
 800b080:	d900      	bls.n	800b084 <CAD_StateMachine+0x54>
 800b082:	e06b      	b.n	800b15c <CAD_StateMachine+0x12c>
 800b084:	f7fa fc8c 	bl	80059a0 <__gnu_thumb1_case_uqi>
 800b088:	6a6a0619 	.word	0x6a6a0619
 800b08c:	6a6a6a6a 	.word	0x6a6a6a6a
 800b090:	566a      	.short	0x566a
 800b092:	71          	.byte	0x71
 800b093:	00          	.byte	0x00
    if (Ports[PortNum].NbDetach == 0)
 800b094:	4363      	muls	r3, r4
 800b096:	18f3      	adds	r3, r6, r3
 800b098:	33d3      	adds	r3, #211	; 0xd3
 800b09a:	33ff      	adds	r3, #255	; 0xff
 800b09c:	9300      	str	r3, [sp, #0]
 800b09e:	781b      	ldrb	r3, [r3, #0]
 800b0a0:	2b00      	cmp	r3, #0
 800b0a2:	d10a      	bne.n	800b0ba <CAD_StateMachine+0x8a>
      if ((STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum))) == VBUS_below_VSAFE0V_threshold)
 800b0a4:	0027      	movs	r7, r4
 800b0a6:	1e7b      	subs	r3, r7, #1
 800b0a8:	419f      	sbcs	r7, r3
 800b0aa:	3728      	adds	r7, #40	; 0x28
 800b0ac:	0038      	movs	r0, r7
 800b0ae:	f7fb fc7b 	bl	80069a8 <STUSB1602_VBUS_VSAFE0V_Get>
 800b0b2:	2801      	cmp	r0, #1
 800b0b4:	d126      	bne.n	800b104 <CAD_StateMachine+0xd4>
        Ports[PortNum].NbDetach = 1;
 800b0b6:	9b00      	ldr	r3, [sp, #0]
 800b0b8:	7018      	strb	r0, [r3, #0]
    *Event = USBPD_CAD_EVENT_DETACHED;
 800b0ba:	2301      	movs	r3, #1
 800b0bc:	702b      	strb	r3, [r5, #0]
  if ((hhw_handle->CCxChange == SET) && (_handle->state != USBPD_CAD_STATE_SWITCH_TO_SRC) && (_handle->state != USBPD_CAD_STATE_SWITCH_TO_SNK))
 800b0be:	23f0      	movs	r3, #240	; 0xf0
 800b0c0:	005b      	lsls	r3, r3, #1
 800b0c2:	4363      	muls	r3, r4
 800b0c4:	18f6      	adds	r6, r6, r3
 800b0c6:	7df3      	ldrb	r3, [r6, #23]
 800b0c8:	2b01      	cmp	r3, #1
 800b0ca:	d10f      	bne.n	800b0ec <CAD_StateMachine+0xbc>
 800b0cc:	3317      	adds	r3, #23
 800b0ce:	4363      	muls	r3, r4
 800b0d0:	4a2d      	ldr	r2, [pc, #180]	; (800b188 <CAD_StateMachine+0x158>)
 800b0d2:	18d3      	adds	r3, r2, r3
 800b0d4:	220f      	movs	r2, #15
 800b0d6:	7c1b      	ldrb	r3, [r3, #16]
 800b0d8:	401a      	ands	r2, r3
 800b0da:	3a09      	subs	r2, #9
 800b0dc:	2a01      	cmp	r2, #1
 800b0de:	d905      	bls.n	800b0ec <CAD_StateMachine+0xbc>
    *CCXX  = _handle->cc;
 800b0e0:	069b      	lsls	r3, r3, #26
 800b0e2:	9a01      	ldr	r2, [sp, #4]
 800b0e4:	0f9b      	lsrs	r3, r3, #30
 800b0e6:	7013      	strb	r3, [r2, #0]
    hhw_handle->CCxChange = RESET;
 800b0e8:	2300      	movs	r3, #0
 800b0ea:	75f3      	strb	r3, [r6, #23]
  if ((*Event != USBPD_CAD_EVENT_DETACHED) || (previous_event[PortNum] != USBPD_CAD_EVENT_DETACHED))
 800b0ec:	782a      	ldrb	r2, [r5, #0]
 800b0ee:	4b27      	ldr	r3, [pc, #156]	; (800b18c <CAD_StateMachine+0x15c>)
 800b0f0:	2a01      	cmp	r2, #1
 800b0f2:	d103      	bne.n	800b0fc <CAD_StateMachine+0xcc>
 800b0f4:	1919      	adds	r1, r3, r4
 800b0f6:	7849      	ldrb	r1, [r1, #1]
 800b0f8:	2901      	cmp	r1, #1
 800b0fa:	d03f      	beq.n	800b17c <CAD_StateMachine+0x14c>
    previous_event[PortNum] = *Event;
 800b0fc:	191c      	adds	r4, r3, r4
 800b0fe:	7062      	strb	r2, [r4, #1]
}
 800b100:	2002      	movs	r0, #2
 800b102:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        if  (STUSB1602_TypeC_FSM_State_Get(STUSB1602_I2C_Add(PortNum)) == Unattached_SNK)
 800b104:	0038      	movs	r0, r7
 800b106:	f7fb fc73 	bl	80069f0 <STUSB1602_TypeC_FSM_State_Get>
 800b10a:	2800      	cmp	r0, #0
 800b10c:	d1d5      	bne.n	800b0ba <CAD_StateMachine+0x8a>
          if ((STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum))) != VBUS_below_VSAFE0V_threshold)
 800b10e:	0038      	movs	r0, r7
 800b110:	f7fb fc4a 	bl	80069a8 <STUSB1602_VBUS_VSAFE0V_Get>
 800b114:	2801      	cmp	r0, #1
 800b116:	d0d0      	beq.n	800b0ba <CAD_StateMachine+0x8a>
            if ((STUSB1602_TypeC_FSM_State_Get(STUSB1602_I2C_Add(PortNum)) == AttachWait_SRC) && 
 800b118:	0038      	movs	r0, r7
 800b11a:	f7fb fc69 	bl	80069f0 <STUSB1602_TypeC_FSM_State_Get>
 800b11e:	2809      	cmp	r0, #9
 800b120:	d1cb      	bne.n	800b0ba <CAD_StateMachine+0x8a>
                (STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_below_VSAFE0V_threshold))
 800b122:	0038      	movs	r0, r7
 800b124:	f7fb fc40 	bl	80069a8 <STUSB1602_VBUS_VSAFE0V_Get>
            if ((STUSB1602_TypeC_FSM_State_Get(STUSB1602_I2C_Add(PortNum)) == AttachWait_SRC) && 
 800b128:	2801      	cmp	r0, #1
 800b12a:	d0c6      	beq.n	800b0ba <CAD_StateMachine+0x8a>
              HW_IF_RESET_CTRL(PortNum);
 800b12c:	0020      	movs	r0, r4
 800b12e:	f7ff fad7 	bl	800a6e0 <HW_IF_RESET_CTRL>
 800b132:	e7c2      	b.n	800b0ba <CAD_StateMachine+0x8a>
    _handle->params->PE_PowerRole = USBPD_PORTPOWERROLE_SRC;
 800b134:	0013      	movs	r3, r2
 800b136:	4363      	muls	r3, r4
 800b138:	4a13      	ldr	r2, [pc, #76]	; (800b188 <CAD_StateMachine+0x158>)
 800b13a:	18d3      	adds	r3, r2, r3
 800b13c:	2204      	movs	r2, #4
 800b13e:	6859      	ldr	r1, [r3, #4]
 800b140:	7808      	ldrb	r0, [r1, #0]
 800b142:	4302      	orrs	r2, r0
    _handle->params->PE_PowerRole = USBPD_PORTPOWERROLE_SNK;
 800b144:	700a      	strb	r2, [r1, #0]
    _handle->state = USBPD_CAD_STATE_ATTACHED;
 800b146:	210f      	movs	r1, #15
 800b148:	7c1a      	ldrb	r2, [r3, #16]
 800b14a:	438a      	bics	r2, r1
 800b14c:	0011      	movs	r1, r2
 800b14e:	2203      	movs	r2, #3
 800b150:	430a      	orrs	r2, r1
 800b152:	741a      	strb	r2, [r3, #16]
    *Event = USBPD_CAD_EVENT_ATTACHED;
 800b154:	2302      	movs	r3, #2
 800b156:	702b      	strb	r3, [r5, #0]
    Ports[PortNum].NbDetach =0;
 800b158:	33df      	adds	r3, #223	; 0xdf
 800b15a:	33ff      	adds	r3, #255	; 0xff
    Ports[PortNum].NbDetach =0;
 800b15c:	2200      	movs	r2, #0
 800b15e:	4363      	muls	r3, r4
 800b160:	18f3      	adds	r3, r6, r3
 800b162:	33d3      	adds	r3, #211	; 0xd3
 800b164:	33ff      	adds	r3, #255	; 0xff
 800b166:	701a      	strb	r2, [r3, #0]
    break;
 800b168:	e7a9      	b.n	800b0be <CAD_StateMachine+0x8e>
    _handle->params->PE_PowerRole = USBPD_PORTPOWERROLE_SNK;
 800b16a:	0013      	movs	r3, r2
 800b16c:	2004      	movs	r0, #4
 800b16e:	4363      	muls	r3, r4
 800b170:	4a05      	ldr	r2, [pc, #20]	; (800b188 <CAD_StateMachine+0x158>)
 800b172:	18d3      	adds	r3, r2, r3
 800b174:	6859      	ldr	r1, [r3, #4]
 800b176:	780a      	ldrb	r2, [r1, #0]
 800b178:	4382      	bics	r2, r0
 800b17a:	e7e3      	b.n	800b144 <CAD_StateMachine+0x114>
    *Event = USBPD_CAD_EVENT_NONE;
 800b17c:	2300      	movs	r3, #0
 800b17e:	702b      	strb	r3, [r5, #0]
 800b180:	e7be      	b.n	800b100 <CAD_StateMachine+0xd0>
 800b182:	46c0      	nop			; (mov r8, r8)
 800b184:	20000058 	.word	0x20000058
 800b188:	20001b8c 	.word	0x20001b8c
 800b18c:	200003e0 	.word	0x200003e0

0800b190 <STUSB16xx_HW_IF_Send_Packet>:
  * @param  pData The pointer to data buffer
  * @param  Size The amount of data to be sent
  * @retval USBPD status
  */
USBPD_StatusTypeDef STUSB16xx_HW_IF_Send_Packet(uint8_t PortNum, uint8_t *pData, uint16_t Size)
{
 800b190:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800b192:	0005      	movs	r5, r0
 800b194:	9100      	str	r1, [sp, #0]
 800b196:	9201      	str	r2, [sp, #4]
  USBPD_StatusTypeDef ret = USBPD_ERROR;
  
  /* Check if the bus is idle */
  ret = HW_IF_check_bus_idle(PortNum);
 800b198:	f7ff fc26 	bl	800a9e8 <HW_IF_check_bus_idle>
 800b19c:	1e06      	subs	r6, r0, #0
  if (ret == USBPD_OK && 1 /* tx ready */)
 800b19e:	d11d      	bne.n	800b1dc <STUSB16xx_HW_IF_Send_Packet+0x4c>
  {
    /* Set the state to busy*/
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_TX;
 800b1a0:	24f0      	movs	r4, #240	; 0xf0
 800b1a2:	2203      	movs	r2, #3
 800b1a4:	0064      	lsls	r4, r4, #1
 800b1a6:	436c      	muls	r4, r5
 800b1a8:	4f0d      	ldr	r7, [pc, #52]	; (800b1e0 <STUSB16xx_HW_IF_Send_Packet+0x50>)

    /* Set the SPI in TX mode */
    STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 800b1aa:	0001      	movs	r1, r0
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_TX;
 800b1ac:	193b      	adds	r3, r7, r4

    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800b1ae:	3440      	adds	r4, #64	; 0x40
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_TX;
 800b1b0:	765a      	strb	r2, [r3, #25]
    STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 800b1b2:	0028      	movs	r0, r5
    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800b1b4:	19e4      	adds	r4, r4, r7
    STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 800b1b6:	f7ff fd91 	bl	800acdc <STUSB16xx_HW_IF_Switch_Mode>
    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800b1ba:	0020      	movs	r0, r4
 800b1bc:	f7fd faec 	bl	8008798 <HAL_SPI_DMAStop>
    __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 800b1c0:	4b08      	ldr	r3, [pc, #32]	; (800b1e4 <STUSB16xx_HW_IF_Send_Packet+0x54>)
 800b1c2:	4a09      	ldr	r2, [pc, #36]	; (800b1e8 <STUSB16xx_HW_IF_Send_Packet+0x58>)

    /* Send TX Buffer by SPI DMA */
    HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, pData, Size);
 800b1c4:	9900      	ldr	r1, [sp, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 800b1c6:	605a      	str	r2, [r3, #4]
    HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, pData, Size);
 800b1c8:	0020      	movs	r0, r4
 800b1ca:	9a01      	ldr	r2, [sp, #4]
 800b1cc:	f7fd f8d2 	bl	8008374 <HAL_SPI_Transmit_DMA>

    /* Set TX_EN GPIO */
    STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_SET);
 800b1d0:	2101      	movs	r1, #1
 800b1d2:	0028      	movs	r0, r5
 800b1d4:	f7ff fd90 	bl	800acf8 <STUSB16xx_HW_IF_TX_EN_Status>
  else
  {
    __NOP();
  }
  return ret;
}
 800b1d8:	0030      	movs	r0, r6
 800b1da:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800b1dc:	46c0      	nop			; (mov r8, r8)
 800b1de:	e7fb      	b.n	800b1d8 <STUSB16xx_HW_IF_Send_Packet+0x48>
 800b1e0:	20000058 	.word	0x20000058
 800b1e4:	40020000 	.word	0x40020000
 800b1e8:	0fffffff 	.word	0x0fffffff

0800b1ec <STUSB16xx_HW_IF_DataRoleSwap>:
USBPD_StatusTypeDef STUSB16xx_HW_IF_DataRoleSwap(uint8_t PortNum)
{
  uint32_t STUSB16xx_ACK_timeout = 0xFFFF;
  USBPD_StatusTypeDef ret = USBPD_ERROR;

  if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_DFP)
 800b1ec:	21f0      	movs	r1, #240	; 0xf0
 800b1ee:	0049      	lsls	r1, r1, #1
 800b1f0:	4341      	muls	r1, r0
 800b1f2:	4a0c      	ldr	r2, [pc, #48]	; (800b224 <STUSB16xx_HW_IF_DataRoleSwap+0x38>)
{
 800b1f4:	b510      	push	{r4, lr}
  if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_DFP)
 800b1f6:	1852      	adds	r2, r2, r1
 800b1f8:	3229      	adds	r2, #41	; 0x29
 800b1fa:	7812      	ldrb	r2, [r2, #0]
{
 800b1fc:	0003      	movs	r3, r0
  if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_DFP)
 800b1fe:	2a01      	cmp	r2, #1
 800b200:	d107      	bne.n	800b212 <STUSB16xx_HW_IF_DataRoleSwap+0x26>
  {
    /* i2c_dr_swap_port_change_2_ufp_req command */
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Control_Set(STUSB1602_I2C_Add(PortNum), PD_DR_SWAP_PORT_CHANGE_2_UFP_REQ);    
 800b202:	1e58      	subs	r0, r3, #1
 800b204:	4183      	sbcs	r3, r0
 800b206:	3328      	adds	r3, #40	; 0x28
 800b208:	0018      	movs	r0, r3
 800b20a:	210a      	movs	r1, #10
//    }
  }
  else if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_UFP)
  {
    /* i2c_dr_swap_port_change_2_dfp_req command */
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Control_Set(STUSB1602_I2C_Add(PortNum), PD_DR_SWAP_PORT_CHANGE_2_DFP_REQ);    
 800b20c:	f7fb fcaa 	bl	8006b64 <STUSB1602_Type_C_Control_Set>

  if (STUSB16xx_ACK_timeout == 0)
    ret = USBPD_ERROR;

  return ret;
}
 800b210:	bd10      	pop	{r4, pc}
    ret = USBPD_ERROR;
 800b212:	2002      	movs	r0, #2
  else if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_UFP)
 800b214:	2a00      	cmp	r2, #0
 800b216:	d1fb      	bne.n	800b210 <STUSB16xx_HW_IF_DataRoleSwap+0x24>
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Control_Set(STUSB1602_I2C_Add(PortNum), PD_DR_SWAP_PORT_CHANGE_2_DFP_REQ);    
 800b218:	1e58      	subs	r0, r3, #1
 800b21a:	4183      	sbcs	r3, r0
 800b21c:	3328      	adds	r3, #40	; 0x28
 800b21e:	0018      	movs	r0, r3
 800b220:	2109      	movs	r1, #9
 800b222:	e7f3      	b.n	800b20c <STUSB16xx_HW_IF_DataRoleSwap+0x20>
 800b224:	20000058 	.word	0x20000058

0800b228 <USBPD_16xx_IsResistor_SinkTxOk>:
  * @brief  Get Sink Resistors State
  * @param  PortNum The port index
  * @retval USBPD_FALSE of USBPD_TRUE
  */
uint8_t USBPD_16xx_IsResistor_SinkTxOk(uint8_t PortNum)
{
 800b228:	b570      	push	{r4, r5, r6, lr}
  uint8_t TX_OK;

  USBPD_StatusTypeDef ret = USBPD_ERROR;
  /* try to acquire the communication resource to avoid the conflict */
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800b22a:	2164      	movs	r1, #100	; 0x64
{
 800b22c:	0005      	movs	r5, r0
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800b22e:	f7ff f86b 	bl	800a308 <HW_IF_COMM_WAIT>
  if (ret != USBPD_OK)
  {
    return USBPD_FALSE;
 800b232:	2300      	movs	r3, #0
  if (ret != USBPD_OK)
 800b234:	4298      	cmp	r0, r3
 800b236:	d10d      	bne.n	800b254 <USBPD_16xx_IsResistor_SinkTxOk+0x2c>
  }
  TX_OK = STUSB1602_Sink_Power_State_Get(STUSB1602_I2C_Add(PortNum));
 800b238:	0028      	movs	r0, r5
 800b23a:	1e43      	subs	r3, r0, #1
 800b23c:	4198      	sbcs	r0, r3
 800b23e:	3028      	adds	r0, #40	; 0x28
 800b240:	f7fb fbca 	bl	80069d8 <STUSB1602_Sink_Power_State_Get>
 800b244:	0004      	movs	r4, r0
  HW_IF_COMM_RELEASE(PortNum);
 800b246:	0028      	movs	r0, r5

  if ( TX_OK == Pwr_3_0_SNK)
 800b248:	3c02      	subs	r4, #2
  HW_IF_COMM_RELEASE(PortNum);
 800b24a:	f7ff f87b 	bl	800a344 <HW_IF_COMM_RELEASE>
  if ( TX_OK == Pwr_3_0_SNK)
 800b24e:	4263      	negs	r3, r4
 800b250:	4163      	adcs	r3, r4
    return USBPD_FALSE;
 800b252:	b2db      	uxtb	r3, r3
  }
  else
  {
    return USBPD_FALSE;
  }
}
 800b254:	0018      	movs	r0, r3
 800b256:	bd70      	pop	{r4, r5, r6, pc}

0800b258 <USBPD_TIM_Init>:
/**
  * @brief  Initialization of TIMERSERVER, used for CRC and RETRY operations
  * @retval None
  */
void USBPD_TIM_Init(void)
{
 800b258:	b537      	push	{r0, r1, r2, r4, r5, lr}
  TIMx_CLK_ENABLE;
 800b25a:	2001      	movs	r0, #1
 800b25c:	4a26      	ldr	r2, [pc, #152]	; (800b2f8 <USBPD_TIM_Init+0xa0>)
  *         @arg @ref LL_TIM_COUNTERMODE_CENTER_UP_DOWN
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetCounterMode(TIM_TypeDef *TIMx, uint32_t CounterMode)
{
  MODIFY_REG(TIMx->CR1, TIM_CR1_DIR | TIM_CR1_CMS, CounterMode);
 800b25e:	2480      	movs	r4, #128	; 0x80
 800b260:	69d1      	ldr	r1, [r2, #28]
 800b262:	05e4      	lsls	r4, r4, #23
 800b264:	4301      	orrs	r1, r0
 800b266:	61d1      	str	r1, [r2, #28]
 800b268:	69d3      	ldr	r3, [r2, #28]
 800b26a:	2270      	movs	r2, #112	; 0x70
 800b26c:	4003      	ands	r3, r0
 800b26e:	9301      	str	r3, [sp, #4]
 800b270:	9b01      	ldr	r3, [sp, #4]
 800b272:	6823      	ldr	r3, [r4, #0]

  /* Counter mode: select up-counting mode */
  LL_TIM_SetCounterMode(TIMx, LL_TIM_COUNTERMODE_UP);

  /* Set the pre-scaler value to have TIMx counter clock equal to 1 MHz */
  LL_TIM_SetPrescaler(TIMx, __LL_TIM_CALC_PSC(SystemCoreClock, 1000000));
 800b274:	2000      	movs	r0, #0
 800b276:	4393      	bics	r3, r2
 800b278:	6023      	str	r3, [r4, #0]
 800b27a:	4b20      	ldr	r3, [pc, #128]	; (800b2fc <USBPD_TIM_Init+0xa4>)
 800b27c:	681d      	ldr	r5, [r3, #0]
 800b27e:	4b20      	ldr	r3, [pc, #128]	; (800b300 <USBPD_TIM_Init+0xa8>)
 800b280:	429d      	cmp	r5, r3
 800b282:	d904      	bls.n	800b28e <USBPD_TIM_Init+0x36>
 800b284:	491f      	ldr	r1, [pc, #124]	; (800b304 <USBPD_TIM_Init+0xac>)
 800b286:	0028      	movs	r0, r5
 800b288:	f7fa fb94 	bl	80059b4 <__udivsi3>
 800b28c:	3801      	subs	r0, #1
  * @param  Prescaler between Min_Data=0 and Max_Data=65535
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
{
  WRITE_REG(TIMx->PSC, Prescaler);
 800b28e:	62a0      	str	r0, [r4, #40]	; 0x28
  * @param  TIMx Timer instance
  * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
  */
__STATIC_INLINE uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
{
  return (uint32_t)(READ_REG(TIMx->PSC));
 800b290:	6aa1      	ldr	r1, [r4, #40]	; 0x28

  /* Set the auto-reload value to have a counter frequency of 250Hz */
  LL_TIM_SetAutoReload(TIMx, __LL_TIM_CALC_ARR(SystemCoreClock, LL_TIM_GetPrescaler(TIMx), 250));
 800b292:	0028      	movs	r0, r5
 800b294:	3101      	adds	r1, #1
 800b296:	f7fa fb8d 	bl	80059b4 <__udivsi3>
 800b29a:	2200      	movs	r2, #0
 800b29c:	28f9      	cmp	r0, #249	; 0xf9
 800b29e:	d907      	bls.n	800b2b0 <USBPD_TIM_Init+0x58>
 800b2a0:	21fa      	movs	r1, #250	; 0xfa
 800b2a2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800b2a4:	0028      	movs	r0, r5
 800b2a6:	3301      	adds	r3, #1
 800b2a8:	4359      	muls	r1, r3
 800b2aa:	f7fa fb83 	bl	80059b4 <__udivsi3>
 800b2ae:	1e42      	subs	r2, r0, #1
  * @param  AutoReload between Min_Data=0 and Max_Data=65535
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
{
  WRITE_REG(TIMx->ARR, AutoReload);
 800b2b0:	2380      	movs	r3, #128	; 0x80
 800b2b2:	05db      	lsls	r3, r3, #23
 800b2b4:	62da      	str	r2, [r3, #44]	; 0x2c
  */
__STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
{
  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
 800b2b6:	4c14      	ldr	r4, [pc, #80]	; (800b308 <USBPD_TIM_Init+0xb0>)
 800b2b8:	699a      	ldr	r2, [r3, #24]
 800b2ba:	4914      	ldr	r1, [pc, #80]	; (800b30c <USBPD_TIM_Init+0xb4>)
 800b2bc:	4022      	ands	r2, r4
 800b2be:	430a      	orrs	r2, r1
  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
 800b2c0:	4813      	ldr	r0, [pc, #76]	; (800b310 <USBPD_TIM_Init+0xb8>)
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
 800b2c2:	619a      	str	r2, [r3, #24]
 800b2c4:	6842      	ldr	r2, [r0, #4]
 800b2c6:	4014      	ands	r4, r2
 800b2c8:	4321      	orrs	r1, r4
 800b2ca:	6041      	str	r1, [r0, #4]
  * @retval None
  */
__STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
{
  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
  MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
 800b2cc:	2102      	movs	r1, #2
 800b2ce:	6a1a      	ldr	r2, [r3, #32]
 800b2d0:	438a      	bics	r2, r1
 800b2d2:	621a      	str	r2, [r3, #32]
 800b2d4:	6a1a      	ldr	r2, [r3, #32]
 800b2d6:	311e      	adds	r1, #30
 800b2d8:	438a      	bics	r2, r1
 800b2da:	621a      	str	r2, [r3, #32]
 800b2dc:	6a1a      	ldr	r2, [r3, #32]
 800b2de:	490d      	ldr	r1, [pc, #52]	; (800b314 <USBPD_TIM_Init+0xbc>)
 800b2e0:	400a      	ands	r2, r1
 800b2e2:	621a      	str	r2, [r3, #32]
 800b2e4:	6a1a      	ldr	r2, [r3, #32]
 800b2e6:	490c      	ldr	r1, [pc, #48]	; (800b318 <USBPD_TIM_Init+0xc0>)
 800b2e8:	400a      	ands	r2, r1
 800b2ea:	621a      	str	r2, [r3, #32]
  SET_BIT(TIMx->CR1, TIM_CR1_CEN);
 800b2ec:	2201      	movs	r2, #1
 800b2ee:	6819      	ldr	r1, [r3, #0]
 800b2f0:	430a      	orrs	r2, r1
 800b2f2:	601a      	str	r2, [r3, #0]
  LL_TIM_OC_SetPolarity(TIMx, LL_TIM_CHANNEL_CH3, LL_TIM_OCPOLARITY_HIGH);
  LL_TIM_OC_SetPolarity(TIMx, LL_TIM_CHANNEL_CH4, LL_TIM_OCPOLARITY_HIGH);

  /* Enable counter */
  LL_TIM_EnableCounter(TIMx);
}
 800b2f4:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
 800b2f6:	46c0      	nop			; (mov r8, r8)
 800b2f8:	40021000 	.word	0x40021000
 800b2fc:	20000030 	.word	0x20000030
 800b300:	000f423f 	.word	0x000f423f
 800b304:	000f4240 	.word	0x000f4240
 800b308:	ffff8c8c 	.word	0xffff8c8c
 800b30c:	00003030 	.word	0x00003030
 800b310:	40000018 	.word	0x40000018
 800b314:	fffffdff 	.word	0xfffffdff
 800b318:	ffffdfff 	.word	0xffffdfff

0800b31c <USBPD_TIM_Start>:
  * @param  id Timer Operation Identifier
  * @param  us_time time in micro-seconds
  * @retval None
  */
void USBPD_TIM_Start(TIM_identifier id, uint16_t us_time)
{
 800b31c:	b510      	push	{r4, lr}
  switch (id)
 800b31e:	2803      	cmp	r0, #3
 800b320:	d80f      	bhi.n	800b342 <USBPD_TIM_Start+0x26>
 800b322:	2480      	movs	r4, #128	; 0x80
 800b324:	05e4      	lsls	r4, r4, #23
 800b326:	f7fa fb3b 	bl	80059a0 <__gnu_thumb1_case_uqi>
 800b32a:	0d02      	.short	0x0d02
 800b32c:	1f16      	.short	0x1f16
  {
    case TIM_PORT0_CRC:
      LL_TIM_OC_SetCompareCH1(TIMx, (us_time + TIMx->CNT) % 4000);
 800b32e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b330:	1808      	adds	r0, r1, r0
 800b332:	21fa      	movs	r1, #250	; 0xfa
 800b334:	0109      	lsls	r1, r1, #4
 800b336:	f7fa fbc3 	bl	8005ac0 <__aeabi_uidivmod>
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx)
{
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
 800b33a:	2303      	movs	r3, #3
  WRITE_REG(TIMx->CCR1, CompareValue);
 800b33c:	6361      	str	r1, [r4, #52]	; 0x34
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx)
{
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
 800b33e:	425b      	negs	r3, r3
 800b340:	6123      	str	r3, [r4, #16]
      LL_TIM_ClearFlag_CC4(TIMx);
      break;
    default:
      break;
  }
}
 800b342:	bd10      	pop	{r4, pc}
      LL_TIM_OC_SetCompareCH2(TIMx, (us_time + TIMx->CNT) % 4000);
 800b344:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b346:	1808      	adds	r0, r1, r0
 800b348:	21fa      	movs	r1, #250	; 0xfa
 800b34a:	0109      	lsls	r1, r1, #4
 800b34c:	f7fa fbb8 	bl	8005ac0 <__aeabi_uidivmod>
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC2IF));
 800b350:	2305      	movs	r3, #5
  WRITE_REG(TIMx->CCR2, CompareValue);
 800b352:	63a1      	str	r1, [r4, #56]	; 0x38
 800b354:	e7f3      	b.n	800b33e <USBPD_TIM_Start+0x22>
      LL_TIM_OC_SetCompareCH3(TIMx, (us_time + TIMx->CNT) % 4000);
 800b356:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b358:	1808      	adds	r0, r1, r0
 800b35a:	21fa      	movs	r1, #250	; 0xfa
 800b35c:	0109      	lsls	r1, r1, #4
 800b35e:	f7fa fbaf 	bl	8005ac0 <__aeabi_uidivmod>
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC3IF));
 800b362:	2309      	movs	r3, #9
  WRITE_REG(TIMx->CCR3, CompareValue);
 800b364:	63e1      	str	r1, [r4, #60]	; 0x3c
 800b366:	e7ea      	b.n	800b33e <USBPD_TIM_Start+0x22>
      LL_TIM_OC_SetCompareCH4(TIMx, (us_time + TIMx->CNT) % 4000);
 800b368:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b36a:	1808      	adds	r0, r1, r0
 800b36c:	21fa      	movs	r1, #250	; 0xfa
 800b36e:	0109      	lsls	r1, r1, #4
 800b370:	f7fa fba6 	bl	8005ac0 <__aeabi_uidivmod>
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
 800b374:	2311      	movs	r3, #17
  WRITE_REG(TIMx->CCR4, CompareValue);
 800b376:	6421      	str	r1, [r4, #64]	; 0x40
 800b378:	e7e1      	b.n	800b33e <USBPD_TIM_Start+0x22>

0800b37a <USBPD_TIM_IsExpired>:
  * @brief  Retrieve the TIMERSERVER status for a specified id
  * @param  id Timer Operation Identifier
  * @retval State of bit (1 or 0).
  */
uint8_t USBPD_TIM_IsExpired(TIM_identifier id)
{
 800b37a:	b500      	push	{lr}
    case TIM_PORT1_RETRY:
      return LL_TIM_IsActiveFlag_CC4(TIMx);
    default:
      break;
  }
  return 1;
 800b37c:	2301      	movs	r3, #1
  switch (id)
 800b37e:	2803      	cmp	r0, #3
 800b380:	d808      	bhi.n	800b394 <USBPD_TIM_IsExpired+0x1a>
 800b382:	2280      	movs	r2, #128	; 0x80
 800b384:	05d2      	lsls	r2, r2, #23
  * @param  TIMx Timer instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx)
{
  return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
 800b386:	6912      	ldr	r2, [r2, #16]
 800b388:	f7fa fb0a 	bl	80059a0 <__gnu_thumb1_case_uqi>
 800b38c:	0a080602 	.word	0x0a080602
  return (READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF));
 800b390:	0852      	lsrs	r2, r2, #1
      return LL_TIM_IsActiveFlag_CC4(TIMx);
 800b392:	4013      	ands	r3, r2
}
 800b394:	0018      	movs	r0, r3
 800b396:	bd00      	pop	{pc}
  return (READ_BIT(TIMx->SR, TIM_SR_CC2IF) == (TIM_SR_CC2IF));
 800b398:	0892      	lsrs	r2, r2, #2
 800b39a:	e7fa      	b.n	800b392 <USBPD_TIM_IsExpired+0x18>
  return (READ_BIT(TIMx->SR, TIM_SR_CC3IF) == (TIM_SR_CC3IF));
 800b39c:	08d2      	lsrs	r2, r2, #3
 800b39e:	e7f8      	b.n	800b392 <USBPD_TIM_IsExpired+0x18>
  return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
 800b3a0:	0912      	lsrs	r2, r2, #4
 800b3a2:	e7f6      	b.n	800b392 <USBPD_TIM_IsExpired+0x18>

0800b3a4 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 800b3a4:	b510      	push	{r4, lr}
  vTaskStartScheduler();
 800b3a6:	f000 fc67 	bl	800bc78 <vTaskStartScheduler>
  
  return osOK;
}
 800b3aa:	2000      	movs	r0, #0
 800b3ac:	bd10      	pop	{r4, pc}

0800b3ae <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 800b3ae:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b3b0:	6902      	ldr	r2, [r0, #16]
{
 800b3b2:	000b      	movs	r3, r1
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b3b4:	6846      	ldr	r6, [r0, #4]
 800b3b6:	6801      	ldr	r1, [r0, #0]
 800b3b8:	2508      	movs	r5, #8
 800b3ba:	5f45      	ldrsh	r5, [r0, r5]
 800b3bc:	b292      	uxth	r2, r2
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 800b3be:	2400      	movs	r4, #0
  if (priority != osPriorityError) {
 800b3c0:	2d84      	cmp	r5, #132	; 0x84
 800b3c2:	d000      	beq.n	800b3c6 <osThreadCreate+0x18>
    fpriority += (priority - osPriorityIdle);
 800b3c4:	1cec      	adds	r4, r5, #3
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b3c6:	a803      	add	r0, sp, #12
 800b3c8:	9001      	str	r0, [sp, #4]
 800b3ca:	9400      	str	r4, [sp, #0]
 800b3cc:	0030      	movs	r0, r6
 800b3ce:	f000 fb63 	bl	800ba98 <xTaskCreate>
                   thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
                   &handle) != pdPASS)  {
    return NULL;
 800b3d2:	2300      	movs	r3, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b3d4:	2801      	cmp	r0, #1
 800b3d6:	d100      	bne.n	800b3da <osThreadCreate+0x2c>
  }     
#endif
  
  return handle;
 800b3d8:	9b03      	ldr	r3, [sp, #12]
}
 800b3da:	0018      	movs	r0, r3
 800b3dc:	b004      	add	sp, #16
 800b3de:	bd70      	pop	{r4, r5, r6, pc}

0800b3e0 <osThreadTerminate>:
* @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osThreadTerminate shall be consistent in every CMSIS-RTOS.
*/
osStatus osThreadTerminate (osThreadId thread_id)
{
 800b3e0:	b510      	push	{r4, lr}
#if (INCLUDE_vTaskDelete == 1)
  vTaskDelete(thread_id);
 800b3e2:	f000 fc07 	bl	800bbf4 <vTaskDelete>
  return osOK;
#else
  return osErrorOS;
#endif
}
 800b3e6:	2000      	movs	r0, #0
 800b3e8:	bd10      	pop	{r4, pc}

0800b3ea <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 800b3ea:	b510      	push	{r4, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 800b3ec:	2800      	cmp	r0, #0
 800b3ee:	d100      	bne.n	800b3f2 <osDelay+0x8>
 800b3f0:	3001      	adds	r0, #1
 800b3f2:	f000 fd31 	bl	800be58 <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 800b3f6:	2000      	movs	r0, #0
 800b3f8:	bd10      	pop	{r4, pc}

0800b3fa <osMessageCreate>:
* @param  thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval  message queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS.
*/
osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
{
 800b3fa:	b510      	push	{r4, lr}
    return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
  }
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
#else  
  return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
 800b3fc:	6841      	ldr	r1, [r0, #4]
 800b3fe:	2200      	movs	r2, #0
 800b400:	6800      	ldr	r0, [r0, #0]
 800b402:	f000 f94f 	bl	800b6a4 <xQueueGenericCreate>
#endif
}
 800b406:	bd10      	pop	{r4, pc}

0800b408 <osMessagePut>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
*/
osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
 800b408:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  portBASE_TYPE taskWoken = pdFALSE;
 800b40a:	2300      	movs	r3, #0
{
 800b40c:	9101      	str	r1, [sp, #4]
  portBASE_TYPE taskWoken = pdFALSE;
 800b40e:	9303      	str	r3, [sp, #12]
  TickType_t ticks;
  
  ticks = millisec / portTICK_PERIOD_MS;
  if (ticks == 0) {
 800b410:	429a      	cmp	r2, r3
 800b412:	d100      	bne.n	800b416 <osMessagePut+0xe>
    ticks = 1;
 800b414:	2201      	movs	r2, #1
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800b416:	f3ef 8305 	mrs	r3, IPSR
  }
  
  if (inHandlerMode()) {
 800b41a:	2b00      	cmp	r3, #0
 800b41c:	d012      	beq.n	800b444 <osMessagePut+0x3c>
    if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
 800b41e:	2300      	movs	r3, #0
 800b420:	aa03      	add	r2, sp, #12
 800b422:	a901      	add	r1, sp, #4
 800b424:	f000 f9e3 	bl	800b7ee <xQueueGenericSendFromISR>
 800b428:	2801      	cmp	r0, #1
 800b42a:	d002      	beq.n	800b432 <osMessagePut+0x2a>
      return osErrorOS;
 800b42c:	20ff      	movs	r0, #255	; 0xff
      return osErrorOS;
    }
  }
  
  return osOK;
}
 800b42e:	b005      	add	sp, #20
 800b430:	bd00      	pop	{pc}
    portEND_SWITCHING_ISR(taskWoken);
 800b432:	9b03      	ldr	r3, [sp, #12]
 800b434:	2b00      	cmp	r3, #0
 800b436:	d003      	beq.n	800b440 <osMessagePut+0x38>
 800b438:	2280      	movs	r2, #128	; 0x80
 800b43a:	4b05      	ldr	r3, [pc, #20]	; (800b450 <osMessagePut+0x48>)
 800b43c:	0552      	lsls	r2, r2, #21
 800b43e:	601a      	str	r2, [r3, #0]
  return osOK;
 800b440:	2000      	movs	r0, #0
 800b442:	e7f4      	b.n	800b42e <osMessagePut+0x26>
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
 800b444:	a901      	add	r1, sp, #4
 800b446:	f000 f94a 	bl	800b6de <xQueueGenericSend>
 800b44a:	2801      	cmp	r0, #1
 800b44c:	d0f8      	beq.n	800b440 <osMessagePut+0x38>
 800b44e:	e7ed      	b.n	800b42c <osMessagePut+0x24>
 800b450:	e000ed04 	.word	0xe000ed04

0800b454 <osMessageGet>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval event information that includes status code.
* @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
*/
osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
{
 800b454:	b5f0      	push	{r4, r5, r6, r7, lr}
  portBASE_TYPE taskWoken;
  TickType_t ticks;
  osEvent event;
  
  event.def.message_id = queue_id;
  event.value.v = 0;
 800b456:	2700      	movs	r7, #0
{
 800b458:	b085      	sub	sp, #20
  event.def.message_id = queue_id;
 800b45a:	ac01      	add	r4, sp, #4
{
 800b45c:	0005      	movs	r5, r0
 800b45e:	0016      	movs	r6, r2
 800b460:	0008      	movs	r0, r1
  event.def.message_id = queue_id;
 800b462:	60a1      	str	r1, [r4, #8]
  event.value.v = 0;
 800b464:	6067      	str	r7, [r4, #4]
  
  if (queue_id == NULL) {
 800b466:	42b9      	cmp	r1, r7
 800b468:	d107      	bne.n	800b47a <osMessageGet+0x26>
    event.status = osErrorParameter;
 800b46a:	2380      	movs	r3, #128	; 0x80
 800b46c:	9301      	str	r3, [sp, #4]
    else {
      event.status = (ticks == 0) ? osOK : osEventTimeout;
    }
  }
  
  return event;
 800b46e:	002b      	movs	r3, r5
 800b470:	cc07      	ldmia	r4!, {r0, r1, r2}
 800b472:	c307      	stmia	r3!, {r0, r1, r2}
}
 800b474:	0028      	movs	r0, r5
 800b476:	b005      	add	sp, #20
 800b478:	bdf0      	pop	{r4, r5, r6, r7, pc}
  taskWoken = pdFALSE;
 800b47a:	9700      	str	r7, [sp, #0]
 800b47c:	f3ef 8305 	mrs	r3, IPSR
  if (inHandlerMode()) {
 800b480:	2b00      	cmp	r3, #0
 800b482:	d011      	beq.n	800b4a8 <osMessageGet+0x54>
    if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
 800b484:	466a      	mov	r2, sp
 800b486:	a902      	add	r1, sp, #8
 800b488:	f000 fa8a 	bl	800b9a0 <xQueueReceiveFromISR>
 800b48c:	2801      	cmp	r0, #1
 800b48e:	d109      	bne.n	800b4a4 <osMessageGet+0x50>
      event.status = osEventMessage;
 800b490:	2310      	movs	r3, #16
 800b492:	6023      	str	r3, [r4, #0]
    portEND_SWITCHING_ISR(taskWoken);
 800b494:	9b00      	ldr	r3, [sp, #0]
 800b496:	2b00      	cmp	r3, #0
 800b498:	d0e9      	beq.n	800b46e <osMessageGet+0x1a>
 800b49a:	2280      	movs	r2, #128	; 0x80
 800b49c:	4b09      	ldr	r3, [pc, #36]	; (800b4c4 <osMessageGet+0x70>)
 800b49e:	0552      	lsls	r2, r2, #21
 800b4a0:	601a      	str	r2, [r3, #0]
 800b4a2:	e7e4      	b.n	800b46e <osMessageGet+0x1a>
      event.status = osOK;
 800b4a4:	6027      	str	r7, [r4, #0]
 800b4a6:	e7f5      	b.n	800b494 <osMessageGet+0x40>
    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
 800b4a8:	a902      	add	r1, sp, #8
 800b4aa:	f000 f9e9 	bl	800b880 <xQueueGenericReceive>
 800b4ae:	2801      	cmp	r0, #1
 800b4b0:	d102      	bne.n	800b4b8 <osMessageGet+0x64>
      event.status = osEventMessage;
 800b4b2:	2310      	movs	r3, #16
 800b4b4:	6023      	str	r3, [r4, #0]
 800b4b6:	e7da      	b.n	800b46e <osMessageGet+0x1a>
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 800b4b8:	1e73      	subs	r3, r6, #1
 800b4ba:	419e      	sbcs	r6, r3
 800b4bc:	01b6      	lsls	r6, r6, #6
 800b4be:	9601      	str	r6, [sp, #4]
 800b4c0:	e7d5      	b.n	800b46e <osMessageGet+0x1a>
 800b4c2:	46c0      	nop			; (mov r8, r8)
 800b4c4:	e000ed04 	.word	0xe000ed04

0800b4c8 <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 800b4c8:	b510      	push	{r4, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
  {
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
 800b4ca:	f000 ff13 	bl	800c2f4 <xPortSysTickHandler>
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 800b4ce:	bd10      	pop	{r4, pc}

0800b4d0 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800b4d0:	0003      	movs	r3, r0

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800b4d2:	2201      	movs	r2, #1
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800b4d4:	3308      	adds	r3, #8
 800b4d6:	6043      	str	r3, [r0, #4]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800b4d8:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800b4da:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800b4dc:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800b4de:	4252      	negs	r2, r2
 800b4e0:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800b4e2:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800b4e4:	4770      	bx	lr

0800b4e6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 800b4e6:	2300      	movs	r3, #0
 800b4e8:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 800b4ea:	4770      	bx	lr

0800b4ec <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 800b4ec:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800b4ee:	689a      	ldr	r2, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 800b4f0:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800b4f2:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800b4f4:	689a      	ldr	r2, [r3, #8]
 800b4f6:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800b4f8:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800b4fa:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800b4fc:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800b4fe:	3301      	adds	r3, #1
 800b500:	6003      	str	r3, [r0, #0]
}
 800b502:	4770      	bx	lr

0800b504 <vListInsert>:
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800b504:	0003      	movs	r3, r0
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800b506:	680a      	ldr	r2, [r1, #0]
{
 800b508:	b530      	push	{r4, r5, lr}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800b50a:	3308      	adds	r3, #8
	if( xValueOfInsertion == portMAX_DELAY )
 800b50c:	1c54      	adds	r4, r2, #1
 800b50e:	d10b      	bne.n	800b528 <vListInsert+0x24>
		pxIterator = pxList->xListEnd.pxPrevious;
 800b510:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800b512:	685a      	ldr	r2, [r3, #4]
 800b514:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 800b516:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 800b518:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 800b51a:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800b51c:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800b51e:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800b520:	3301      	adds	r3, #1
 800b522:	6003      	str	r3, [r0, #0]
}
 800b524:	bd30      	pop	{r4, r5, pc}
 800b526:	0023      	movs	r3, r4
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800b528:	685c      	ldr	r4, [r3, #4]
 800b52a:	6825      	ldr	r5, [r4, #0]
 800b52c:	4295      	cmp	r5, r2
 800b52e:	d9fa      	bls.n	800b526 <vListInsert+0x22>
 800b530:	e7ef      	b.n	800b512 <vListInsert+0xe>

0800b532 <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800b532:	6841      	ldr	r1, [r0, #4]
 800b534:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 800b536:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800b538:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800b53a:	6882      	ldr	r2, [r0, #8]
 800b53c:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800b53e:	6859      	ldr	r1, [r3, #4]
 800b540:	4281      	cmp	r1, r0
 800b542:	d100      	bne.n	800b546 <uxListRemove+0x14>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800b544:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 800b546:	2200      	movs	r2, #0
 800b548:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 800b54a:	681a      	ldr	r2, [r3, #0]
 800b54c:	1e50      	subs	r0, r2, #1
 800b54e:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 800b550:	4770      	bx	lr

0800b552 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 800b552:	b570      	push	{r4, r5, r6, lr}
 800b554:	0016      	movs	r6, r2

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800b556:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
 800b558:	0004      	movs	r4, r0
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800b55a:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800b55c:	2a00      	cmp	r2, #0
 800b55e:	d00d      	beq.n	800b57c <prvCopyDataToQueue+0x2a>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 800b560:	2e00      	cmp	r6, #0
 800b562:	d10f      	bne.n	800b584 <prvCopyDataToQueue+0x32>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 800b564:	6880      	ldr	r0, [r0, #8]
 800b566:	f001 f809 	bl	800c57c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800b56a:	68a3      	ldr	r3, [r4, #8]
 800b56c:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800b56e:	189b      	adds	r3, r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800b570:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800b572:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800b574:	4293      	cmp	r3, r2
 800b576:	d301      	bcc.n	800b57c <prvCopyDataToQueue+0x2a>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800b578:	6823      	ldr	r3, [r4, #0]
 800b57a:	60a3      	str	r3, [r4, #8]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 800b57c:	3501      	adds	r5, #1
 800b57e:	63a5      	str	r5, [r4, #56]	; 0x38

	return xReturn;
}
 800b580:	2000      	movs	r0, #0
 800b582:	bd70      	pop	{r4, r5, r6, pc}
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800b584:	68c0      	ldr	r0, [r0, #12]
 800b586:	f000 fff9 	bl	800c57c <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800b58a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800b58c:	68e2      	ldr	r2, [r4, #12]
 800b58e:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800b590:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800b592:	18d2      	adds	r2, r2, r3
 800b594:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800b596:	428a      	cmp	r2, r1
 800b598:	d202      	bcs.n	800b5a0 <prvCopyDataToQueue+0x4e>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 800b59a:	6862      	ldr	r2, [r4, #4]
 800b59c:	18d3      	adds	r3, r2, r3
 800b59e:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 800b5a0:	2e02      	cmp	r6, #2
 800b5a2:	d1eb      	bne.n	800b57c <prvCopyDataToQueue+0x2a>
				--uxMessagesWaiting;
 800b5a4:	002b      	movs	r3, r5
 800b5a6:	1e5a      	subs	r2, r3, #1
 800b5a8:	4193      	sbcs	r3, r2
 800b5aa:	1aed      	subs	r5, r5, r3
 800b5ac:	e7e6      	b.n	800b57c <prvCopyDataToQueue+0x2a>

0800b5ae <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 800b5ae:	0003      	movs	r3, r0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800b5b0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
 800b5b2:	b510      	push	{r4, lr}
 800b5b4:	0008      	movs	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800b5b6:	2a00      	cmp	r2, #0
 800b5b8:	d00a      	beq.n	800b5d0 <prvCopyDataFromQueue+0x22>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800b5ba:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800b5bc:	685c      	ldr	r4, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800b5be:	1889      	adds	r1, r1, r2
 800b5c0:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800b5c2:	42a1      	cmp	r1, r4
 800b5c4:	d301      	bcc.n	800b5ca <prvCopyDataFromQueue+0x1c>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 800b5c6:	6819      	ldr	r1, [r3, #0]
 800b5c8:	60d9      	str	r1, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 800b5ca:	68d9      	ldr	r1, [r3, #12]
 800b5cc:	f000 ffd6 	bl	800c57c <memcpy>
	}
}
 800b5d0:	bd10      	pop	{r4, pc}

0800b5d2 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 800b5d2:	b570      	push	{r4, r5, r6, lr}
 800b5d4:	0005      	movs	r5, r0
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;
 800b5d6:	002e      	movs	r6, r5
 800b5d8:	3645      	adds	r6, #69	; 0x45
	taskENTER_CRITICAL();
 800b5da:	f000 fe41 	bl	800c260 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 800b5de:	7834      	ldrb	r4, [r6, #0]
 800b5e0:	b264      	sxtb	r4, r4

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800b5e2:	2c00      	cmp	r4, #0
 800b5e4:	dc10      	bgt.n	800b608 <prvUnlockQueue+0x36>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 800b5e6:	23ff      	movs	r3, #255	; 0xff
 800b5e8:	7033      	strb	r3, [r6, #0]
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;
 800b5ea:	002e      	movs	r6, r5
 800b5ec:	3644      	adds	r6, #68	; 0x44
	taskEXIT_CRITICAL();
 800b5ee:	f000 fe43 	bl	800c278 <vPortExitCritical>
	taskENTER_CRITICAL();
 800b5f2:	f000 fe35 	bl	800c260 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 800b5f6:	7834      	ldrb	r4, [r6, #0]
 800b5f8:	b264      	sxtb	r4, r4

		while( cRxLock > queueLOCKED_UNMODIFIED )
 800b5fa:	2c00      	cmp	r4, #0
 800b5fc:	dc11      	bgt.n	800b622 <prvUnlockQueue+0x50>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 800b5fe:	23ff      	movs	r3, #255	; 0xff
 800b600:	7033      	strb	r3, [r6, #0]
	}
	taskEXIT_CRITICAL();
 800b602:	f000 fe39 	bl	800c278 <vPortExitCritical>
}
 800b606:	bd70      	pop	{r4, r5, r6, pc}
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800b608:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800b60a:	2b00      	cmp	r3, #0
 800b60c:	d0eb      	beq.n	800b5e6 <prvUnlockQueue+0x14>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800b60e:	0028      	movs	r0, r5
 800b610:	3024      	adds	r0, #36	; 0x24
 800b612:	f000 fcad 	bl	800bf70 <xTaskRemoveFromEventList>
 800b616:	2800      	cmp	r0, #0
 800b618:	d001      	beq.n	800b61e <prvUnlockQueue+0x4c>
						vTaskMissedYield();
 800b61a:	f000 fd1d 	bl	800c058 <vTaskMissedYield>
 800b61e:	3c01      	subs	r4, #1
 800b620:	e7de      	b.n	800b5e0 <prvUnlockQueue+0xe>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800b622:	692b      	ldr	r3, [r5, #16]
 800b624:	2b00      	cmp	r3, #0
 800b626:	d0ea      	beq.n	800b5fe <prvUnlockQueue+0x2c>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800b628:	0028      	movs	r0, r5
 800b62a:	3010      	adds	r0, #16
 800b62c:	f000 fca0 	bl	800bf70 <xTaskRemoveFromEventList>
 800b630:	2800      	cmp	r0, #0
 800b632:	d001      	beq.n	800b638 <prvUnlockQueue+0x66>
					vTaskMissedYield();
 800b634:	f000 fd10 	bl	800c058 <vTaskMissedYield>
 800b638:	3c01      	subs	r4, #1
 800b63a:	e7dd      	b.n	800b5f8 <prvUnlockQueue+0x26>

0800b63c <xQueueGenericReset>:
{
 800b63c:	b570      	push	{r4, r5, r6, lr}
 800b63e:	0004      	movs	r4, r0
 800b640:	000d      	movs	r5, r1
	configASSERT( pxQueue );
 800b642:	2800      	cmp	r0, #0
 800b644:	d101      	bne.n	800b64a <xQueueGenericReset+0xe>
 800b646:	b672      	cpsid	i
 800b648:	e7fe      	b.n	800b648 <xQueueGenericReset+0xc>
	taskENTER_CRITICAL();
 800b64a:	f000 fe09 	bl	800c260 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800b64e:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800b650:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b652:	6822      	ldr	r2, [r4, #0]
 800b654:	434b      	muls	r3, r1
 800b656:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 800b658:	1a5b      	subs	r3, r3, r1
 800b65a:	18d3      	adds	r3, r2, r3
 800b65c:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 800b65e:	0023      	movs	r3, r4
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800b660:	6060      	str	r0, [r4, #4]
		pxQueue->pcWriteTo = pxQueue->pcHead;
 800b662:	60a2      	str	r2, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800b664:	2000      	movs	r0, #0
		pxQueue->cRxLock = queueUNLOCKED;
 800b666:	22ff      	movs	r2, #255	; 0xff
 800b668:	3344      	adds	r3, #68	; 0x44
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800b66a:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 800b66c:	701a      	strb	r2, [r3, #0]
		pxQueue->cTxLock = queueUNLOCKED;
 800b66e:	705a      	strb	r2, [r3, #1]
		if( xNewQueue == pdFALSE )
 800b670:	4285      	cmp	r5, r0
 800b672:	d10e      	bne.n	800b692 <xQueueGenericReset+0x56>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800b674:	6923      	ldr	r3, [r4, #16]
 800b676:	4283      	cmp	r3, r0
 800b678:	d007      	beq.n	800b68a <xQueueGenericReset+0x4e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800b67a:	0020      	movs	r0, r4
 800b67c:	3010      	adds	r0, #16
 800b67e:	f000 fc77 	bl	800bf70 <xTaskRemoveFromEventList>
 800b682:	2800      	cmp	r0, #0
 800b684:	d001      	beq.n	800b68a <xQueueGenericReset+0x4e>
					queueYIELD_IF_USING_PREEMPTION();
 800b686:	f000 fddf 	bl	800c248 <vPortYield>
	taskEXIT_CRITICAL();
 800b68a:	f000 fdf5 	bl	800c278 <vPortExitCritical>
}
 800b68e:	2001      	movs	r0, #1
 800b690:	bd70      	pop	{r4, r5, r6, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800b692:	0020      	movs	r0, r4
 800b694:	3010      	adds	r0, #16
 800b696:	f7ff ff1b 	bl	800b4d0 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 800b69a:	0020      	movs	r0, r4
 800b69c:	3024      	adds	r0, #36	; 0x24
 800b69e:	f7ff ff17 	bl	800b4d0 <vListInitialise>
 800b6a2:	e7f2      	b.n	800b68a <xQueueGenericReset+0x4e>

0800b6a4 <xQueueGenericCreate>:
	{
 800b6a4:	b570      	push	{r4, r5, r6, lr}
 800b6a6:	0006      	movs	r6, r0
 800b6a8:	000d      	movs	r5, r1
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 800b6aa:	2800      	cmp	r0, #0
 800b6ac:	d101      	bne.n	800b6b2 <xQueueGenericCreate+0xe>
 800b6ae:	b672      	cpsid	i
 800b6b0:	e7fe      	b.n	800b6b0 <xQueueGenericCreate+0xc>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800b6b2:	0008      	movs	r0, r1
 800b6b4:	4370      	muls	r0, r6
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 800b6b6:	3048      	adds	r0, #72	; 0x48
 800b6b8:	f000 fcf6 	bl	800c0a8 <pvPortMalloc>
 800b6bc:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
 800b6be:	d008      	beq.n	800b6d2 <xQueueGenericCreate+0x2e>
	if( uxItemSize == ( UBaseType_t ) 0 )
 800b6c0:	2d00      	cmp	r5, #0
 800b6c2:	d108      	bne.n	800b6d6 <xQueueGenericCreate+0x32>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800b6c4:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 800b6c6:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 800b6c8:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800b6ca:	2101      	movs	r1, #1
 800b6cc:	0020      	movs	r0, r4
 800b6ce:	f7ff ffb5 	bl	800b63c <xQueueGenericReset>
	}
 800b6d2:	0020      	movs	r0, r4
 800b6d4:	bd70      	pop	{r4, r5, r6, pc}
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 800b6d6:	0003      	movs	r3, r0
 800b6d8:	3348      	adds	r3, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 800b6da:	6003      	str	r3, [r0, #0]
 800b6dc:	e7f3      	b.n	800b6c6 <xQueueGenericCreate+0x22>

0800b6de <xQueueGenericSend>:
{
 800b6de:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b6e0:	b085      	sub	sp, #20
 800b6e2:	0004      	movs	r4, r0
 800b6e4:	000f      	movs	r7, r1
 800b6e6:	9201      	str	r2, [sp, #4]
 800b6e8:	001e      	movs	r6, r3
	configASSERT( pxQueue );
 800b6ea:	2800      	cmp	r0, #0
 800b6ec:	d101      	bne.n	800b6f2 <xQueueGenericSend+0x14>
 800b6ee:	b672      	cpsid	i
 800b6f0:	e7fe      	b.n	800b6f0 <xQueueGenericSend+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800b6f2:	2900      	cmp	r1, #0
 800b6f4:	d104      	bne.n	800b700 <xQueueGenericSend+0x22>
 800b6f6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800b6f8:	2b00      	cmp	r3, #0
 800b6fa:	d001      	beq.n	800b700 <xQueueGenericSend+0x22>
 800b6fc:	b672      	cpsid	i
 800b6fe:	e7fe      	b.n	800b6fe <xQueueGenericSend+0x20>
 800b700:	2300      	movs	r3, #0
 800b702:	9300      	str	r3, [sp, #0]
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800b704:	2e02      	cmp	r6, #2
 800b706:	d14f      	bne.n	800b7a8 <xQueueGenericSend+0xca>
 800b708:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b70a:	2b01      	cmp	r3, #1
 800b70c:	d04c      	beq.n	800b7a8 <xQueueGenericSend+0xca>
 800b70e:	b672      	cpsid	i
 800b710:	e7fe      	b.n	800b710 <xQueueGenericSend+0x32>
				if( xTicksToWait == ( TickType_t ) 0 )
 800b712:	9d01      	ldr	r5, [sp, #4]
 800b714:	2d00      	cmp	r5, #0
 800b716:	d103      	bne.n	800b720 <xQueueGenericSend+0x42>
					taskEXIT_CRITICAL();
 800b718:	f000 fdae 	bl	800c278 <vPortExitCritical>
			return errQUEUE_FULL;
 800b71c:	2000      	movs	r0, #0
 800b71e:	e05e      	b.n	800b7de <xQueueGenericSend+0x100>
				else if( xEntryTimeSet == pdFALSE )
 800b720:	9b00      	ldr	r3, [sp, #0]
 800b722:	2b00      	cmp	r3, #0
 800b724:	d102      	bne.n	800b72c <xQueueGenericSend+0x4e>
					vTaskSetTimeOutState( &xTimeOut );
 800b726:	a802      	add	r0, sp, #8
 800b728:	f000 fc56 	bl	800bfd8 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 800b72c:	f000 fda4 	bl	800c278 <vPortExitCritical>
		vTaskSuspendAll();
 800b730:	f000 fac6 	bl	800bcc0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800b734:	f000 fd94 	bl	800c260 <vPortEnterCritical>
 800b738:	0022      	movs	r2, r4
 800b73a:	3244      	adds	r2, #68	; 0x44
 800b73c:	7813      	ldrb	r3, [r2, #0]
 800b73e:	b25b      	sxtb	r3, r3
 800b740:	3301      	adds	r3, #1
 800b742:	d101      	bne.n	800b748 <xQueueGenericSend+0x6a>
 800b744:	2300      	movs	r3, #0
 800b746:	7013      	strb	r3, [r2, #0]
 800b748:	0022      	movs	r2, r4
 800b74a:	3245      	adds	r2, #69	; 0x45
 800b74c:	7813      	ldrb	r3, [r2, #0]
 800b74e:	b25b      	sxtb	r3, r3
 800b750:	3301      	adds	r3, #1
 800b752:	d101      	bne.n	800b758 <xQueueGenericSend+0x7a>
 800b754:	2300      	movs	r3, #0
 800b756:	7013      	strb	r3, [r2, #0]
 800b758:	f000 fd8e 	bl	800c278 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800b75c:	a901      	add	r1, sp, #4
 800b75e:	a802      	add	r0, sp, #8
 800b760:	f000 fc4a 	bl	800bff8 <xTaskCheckForTimeOut>
 800b764:	2800      	cmp	r0, #0
 800b766:	d13c      	bne.n	800b7e2 <xQueueGenericSend+0x104>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 800b768:	f000 fd7a 	bl	800c260 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800b76c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b76e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800b770:	4293      	cmp	r3, r2
 800b772:	d110      	bne.n	800b796 <xQueueGenericSend+0xb8>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800b774:	f000 fd80 	bl	800c278 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800b778:	0020      	movs	r0, r4
 800b77a:	9901      	ldr	r1, [sp, #4]
 800b77c:	3010      	adds	r0, #16
 800b77e:	f000 fbe5 	bl	800bf4c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800b782:	0020      	movs	r0, r4
 800b784:	f7ff ff25 	bl	800b5d2 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800b788:	f000 fb0e 	bl	800bda8 <xTaskResumeAll>
 800b78c:	2800      	cmp	r0, #0
 800b78e:	d109      	bne.n	800b7a4 <xQueueGenericSend+0xc6>
					portYIELD_WITHIN_API();
 800b790:	f000 fd5a 	bl	800c248 <vPortYield>
 800b794:	e006      	b.n	800b7a4 <xQueueGenericSend+0xc6>
	taskEXIT_CRITICAL();
 800b796:	f000 fd6f 	bl	800c278 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 800b79a:	0020      	movs	r0, r4
 800b79c:	f7ff ff19 	bl	800b5d2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800b7a0:	f000 fb02 	bl	800bda8 <xTaskResumeAll>
 800b7a4:	2301      	movs	r3, #1
 800b7a6:	9300      	str	r3, [sp, #0]
		taskENTER_CRITICAL();
 800b7a8:	f000 fd5a 	bl	800c260 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800b7ac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b7ae:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800b7b0:	4293      	cmp	r3, r2
 800b7b2:	d301      	bcc.n	800b7b8 <xQueueGenericSend+0xda>
 800b7b4:	2e02      	cmp	r6, #2
 800b7b6:	d1ac      	bne.n	800b712 <xQueueGenericSend+0x34>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800b7b8:	0032      	movs	r2, r6
 800b7ba:	0039      	movs	r1, r7
 800b7bc:	0020      	movs	r0, r4
 800b7be:	f7ff fec8 	bl	800b552 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800b7c2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800b7c4:	2b00      	cmp	r3, #0
 800b7c6:	d003      	beq.n	800b7d0 <xQueueGenericSend+0xf2>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800b7c8:	0020      	movs	r0, r4
 800b7ca:	3024      	adds	r0, #36	; 0x24
 800b7cc:	f000 fbd0 	bl	800bf70 <xTaskRemoveFromEventList>
 800b7d0:	2800      	cmp	r0, #0
 800b7d2:	d001      	beq.n	800b7d8 <xQueueGenericSend+0xfa>
							queueYIELD_IF_USING_PREEMPTION();
 800b7d4:	f000 fd38 	bl	800c248 <vPortYield>
				taskEXIT_CRITICAL();
 800b7d8:	f000 fd4e 	bl	800c278 <vPortExitCritical>
				return pdPASS;
 800b7dc:	2001      	movs	r0, #1
}
 800b7de:	b005      	add	sp, #20
 800b7e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
			prvUnlockQueue( pxQueue );
 800b7e2:	0020      	movs	r0, r4
 800b7e4:	f7ff fef5 	bl	800b5d2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800b7e8:	f000 fade 	bl	800bda8 <xTaskResumeAll>
 800b7ec:	e796      	b.n	800b71c <xQueueGenericSend+0x3e>

0800b7ee <xQueueGenericSendFromISR>:
{
 800b7ee:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b7f0:	b085      	sub	sp, #20
 800b7f2:	0004      	movs	r4, r0
 800b7f4:	9101      	str	r1, [sp, #4]
 800b7f6:	0017      	movs	r7, r2
 800b7f8:	001e      	movs	r6, r3
	configASSERT( pxQueue );
 800b7fa:	2800      	cmp	r0, #0
 800b7fc:	d101      	bne.n	800b802 <xQueueGenericSendFromISR+0x14>
 800b7fe:	b672      	cpsid	i
 800b800:	e7fe      	b.n	800b800 <xQueueGenericSendFromISR+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800b802:	9b01      	ldr	r3, [sp, #4]
 800b804:	2b00      	cmp	r3, #0
 800b806:	d104      	bne.n	800b812 <xQueueGenericSendFromISR+0x24>
 800b808:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800b80a:	2b00      	cmp	r3, #0
 800b80c:	d001      	beq.n	800b812 <xQueueGenericSendFromISR+0x24>
 800b80e:	b672      	cpsid	i
 800b810:	e7fe      	b.n	800b810 <xQueueGenericSendFromISR+0x22>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800b812:	2e02      	cmp	r6, #2
 800b814:	d104      	bne.n	800b820 <xQueueGenericSendFromISR+0x32>
 800b816:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b818:	2b01      	cmp	r3, #1
 800b81a:	d001      	beq.n	800b820 <xQueueGenericSendFromISR+0x32>
 800b81c:	b672      	cpsid	i
 800b81e:	e7fe      	b.n	800b81e <xQueueGenericSendFromISR+0x30>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800b820:	f000 fd38 	bl	800c294 <ulSetInterruptMaskFromISR>
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800b824:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b826:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800b828:	9003      	str	r0, [sp, #12]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800b82a:	4293      	cmp	r3, r2
 800b82c:	d302      	bcc.n	800b834 <xQueueGenericSendFromISR+0x46>
			xReturn = errQUEUE_FULL;
 800b82e:	2500      	movs	r5, #0
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800b830:	2e02      	cmp	r6, #2
 800b832:	d11a      	bne.n	800b86a <xQueueGenericSendFromISR+0x7c>
			const int8_t cTxLock = pxQueue->cTxLock;
 800b834:	0023      	movs	r3, r4
 800b836:	3345      	adds	r3, #69	; 0x45
 800b838:	9302      	str	r3, [sp, #8]
 800b83a:	781d      	ldrb	r5, [r3, #0]
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800b83c:	0032      	movs	r2, r6
			const int8_t cTxLock = pxQueue->cTxLock;
 800b83e:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800b840:	9901      	ldr	r1, [sp, #4]
 800b842:	0020      	movs	r0, r4
 800b844:	f7ff fe85 	bl	800b552 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 800b848:	1c6b      	adds	r3, r5, #1
 800b84a:	d114      	bne.n	800b876 <xQueueGenericSendFromISR+0x88>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800b84c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800b84e:	2b00      	cmp	r3, #0
 800b850:	d101      	bne.n	800b856 <xQueueGenericSendFromISR+0x68>
			xReturn = pdPASS;
 800b852:	2501      	movs	r5, #1
 800b854:	e009      	b.n	800b86a <xQueueGenericSendFromISR+0x7c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800b856:	0020      	movs	r0, r4
 800b858:	3024      	adds	r0, #36	; 0x24
 800b85a:	f000 fb89 	bl	800bf70 <xTaskRemoveFromEventList>
 800b85e:	2800      	cmp	r0, #0
 800b860:	d0f7      	beq.n	800b852 <xQueueGenericSendFromISR+0x64>
							if( pxHigherPriorityTaskWoken != NULL )
 800b862:	2f00      	cmp	r7, #0
 800b864:	d0f5      	beq.n	800b852 <xQueueGenericSendFromISR+0x64>
								*pxHigherPriorityTaskWoken = pdTRUE;
 800b866:	2501      	movs	r5, #1
 800b868:	603d      	str	r5, [r7, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800b86a:	9803      	ldr	r0, [sp, #12]
 800b86c:	f000 fd17 	bl	800c29e <vClearInterruptMaskFromISR>
}
 800b870:	0028      	movs	r0, r5
 800b872:	b005      	add	sp, #20
 800b874:	bdf0      	pop	{r4, r5, r6, r7, pc}
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800b876:	3501      	adds	r5, #1
 800b878:	9b02      	ldr	r3, [sp, #8]
 800b87a:	b26d      	sxtb	r5, r5
 800b87c:	701d      	strb	r5, [r3, #0]
 800b87e:	e7e8      	b.n	800b852 <xQueueGenericSendFromISR+0x64>

0800b880 <xQueueGenericReceive>:
{
 800b880:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b882:	b085      	sub	sp, #20
 800b884:	0004      	movs	r4, r0
 800b886:	000e      	movs	r6, r1
 800b888:	9201      	str	r2, [sp, #4]
 800b88a:	9300      	str	r3, [sp, #0]
	configASSERT( pxQueue );
 800b88c:	2800      	cmp	r0, #0
 800b88e:	d101      	bne.n	800b894 <xQueueGenericReceive+0x14>
 800b890:	b672      	cpsid	i
 800b892:	e7fe      	b.n	800b892 <xQueueGenericReceive+0x12>
 800b894:	2700      	movs	r7, #0
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800b896:	42b9      	cmp	r1, r7
 800b898:	d155      	bne.n	800b946 <xQueueGenericReceive+0xc6>
 800b89a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800b89c:	42bb      	cmp	r3, r7
 800b89e:	d001      	beq.n	800b8a4 <xQueueGenericReceive+0x24>
 800b8a0:	b672      	cpsid	i
 800b8a2:	e7fe      	b.n	800b8a2 <xQueueGenericReceive+0x22>
 800b8a4:	000f      	movs	r7, r1
 800b8a6:	e04e      	b.n	800b946 <xQueueGenericReceive+0xc6>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800b8a8:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 800b8aa:	60e7      	str	r7, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800b8ac:	2b00      	cmp	r3, #0
 800b8ae:	d064      	beq.n	800b97a <xQueueGenericReceive+0xfa>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800b8b0:	0020      	movs	r0, r4
 800b8b2:	3024      	adds	r0, #36	; 0x24
 800b8b4:	e05b      	b.n	800b96e <xQueueGenericReceive+0xee>
				if( xTicksToWait == ( TickType_t ) 0 )
 800b8b6:	9b01      	ldr	r3, [sp, #4]
 800b8b8:	2b00      	cmp	r3, #0
 800b8ba:	d103      	bne.n	800b8c4 <xQueueGenericReceive+0x44>
					taskEXIT_CRITICAL();
 800b8bc:	f000 fcdc 	bl	800c278 <vPortExitCritical>
					return errQUEUE_EMPTY;
 800b8c0:	2000      	movs	r0, #0
 800b8c2:	e05d      	b.n	800b980 <xQueueGenericReceive+0x100>
				else if( xEntryTimeSet == pdFALSE )
 800b8c4:	2f00      	cmp	r7, #0
 800b8c6:	d102      	bne.n	800b8ce <xQueueGenericReceive+0x4e>
					vTaskSetTimeOutState( &xTimeOut );
 800b8c8:	a802      	add	r0, sp, #8
 800b8ca:	f000 fb85 	bl	800bfd8 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 800b8ce:	f000 fcd3 	bl	800c278 <vPortExitCritical>
		vTaskSuspendAll();
 800b8d2:	f000 f9f5 	bl	800bcc0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800b8d6:	f000 fcc3 	bl	800c260 <vPortEnterCritical>
 800b8da:	0022      	movs	r2, r4
 800b8dc:	3244      	adds	r2, #68	; 0x44
 800b8de:	7813      	ldrb	r3, [r2, #0]
 800b8e0:	b25b      	sxtb	r3, r3
 800b8e2:	3301      	adds	r3, #1
 800b8e4:	d101      	bne.n	800b8ea <xQueueGenericReceive+0x6a>
 800b8e6:	2300      	movs	r3, #0
 800b8e8:	7013      	strb	r3, [r2, #0]
 800b8ea:	0022      	movs	r2, r4
 800b8ec:	3245      	adds	r2, #69	; 0x45
 800b8ee:	7813      	ldrb	r3, [r2, #0]
 800b8f0:	b25b      	sxtb	r3, r3
 800b8f2:	3301      	adds	r3, #1
 800b8f4:	d101      	bne.n	800b8fa <xQueueGenericReceive+0x7a>
 800b8f6:	2300      	movs	r3, #0
 800b8f8:	7013      	strb	r3, [r2, #0]
 800b8fa:	f000 fcbd 	bl	800c278 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800b8fe:	a901      	add	r1, sp, #4
 800b900:	a802      	add	r0, sp, #8
 800b902:	f000 fb79 	bl	800bff8 <xTaskCheckForTimeOut>
 800b906:	2800      	cmp	r0, #0
 800b908:	d13c      	bne.n	800b984 <xQueueGenericReceive+0x104>
	taskENTER_CRITICAL();
 800b90a:	f000 fca9 	bl	800c260 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800b90e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b910:	2b00      	cmp	r3, #0
 800b912:	d110      	bne.n	800b936 <xQueueGenericReceive+0xb6>
	taskEXIT_CRITICAL();
 800b914:	f000 fcb0 	bl	800c278 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800b918:	0020      	movs	r0, r4
 800b91a:	9901      	ldr	r1, [sp, #4]
 800b91c:	3024      	adds	r0, #36	; 0x24
 800b91e:	f000 fb15 	bl	800bf4c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800b922:	0020      	movs	r0, r4
 800b924:	f7ff fe55 	bl	800b5d2 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800b928:	f000 fa3e 	bl	800bda8 <xTaskResumeAll>
 800b92c:	2800      	cmp	r0, #0
 800b92e:	d109      	bne.n	800b944 <xQueueGenericReceive+0xc4>
					portYIELD_WITHIN_API();
 800b930:	f000 fc8a 	bl	800c248 <vPortYield>
 800b934:	e006      	b.n	800b944 <xQueueGenericReceive+0xc4>
	taskEXIT_CRITICAL();
 800b936:	f000 fc9f 	bl	800c278 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 800b93a:	0020      	movs	r0, r4
 800b93c:	f7ff fe49 	bl	800b5d2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800b940:	f000 fa32 	bl	800bda8 <xTaskResumeAll>
 800b944:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
 800b946:	f000 fc8b 	bl	800c260 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800b94a:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800b94c:	2d00      	cmp	r5, #0
 800b94e:	d0b2      	beq.n	800b8b6 <xQueueGenericReceive+0x36>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800b950:	0031      	movs	r1, r6
 800b952:	0020      	movs	r0, r4
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 800b954:	68e7      	ldr	r7, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800b956:	f7ff fe2a 	bl	800b5ae <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
 800b95a:	9b00      	ldr	r3, [sp, #0]
 800b95c:	2b00      	cmp	r3, #0
 800b95e:	d1a3      	bne.n	800b8a8 <xQueueGenericReceive+0x28>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800b960:	6923      	ldr	r3, [r4, #16]
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 800b962:	3d01      	subs	r5, #1
 800b964:	63a5      	str	r5, [r4, #56]	; 0x38
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800b966:	2b00      	cmp	r3, #0
 800b968:	d007      	beq.n	800b97a <xQueueGenericReceive+0xfa>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800b96a:	0020      	movs	r0, r4
 800b96c:	3010      	adds	r0, #16
 800b96e:	f000 faff 	bl	800bf70 <xTaskRemoveFromEventList>
 800b972:	2800      	cmp	r0, #0
 800b974:	d001      	beq.n	800b97a <xQueueGenericReceive+0xfa>
							queueYIELD_IF_USING_PREEMPTION();
 800b976:	f000 fc67 	bl	800c248 <vPortYield>
				taskEXIT_CRITICAL();
 800b97a:	f000 fc7d 	bl	800c278 <vPortExitCritical>
				return pdPASS;
 800b97e:	2001      	movs	r0, #1
}
 800b980:	b005      	add	sp, #20
 800b982:	bdf0      	pop	{r4, r5, r6, r7, pc}
			prvUnlockQueue( pxQueue );
 800b984:	0020      	movs	r0, r4
 800b986:	f7ff fe24 	bl	800b5d2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800b98a:	f000 fa0d 	bl	800bda8 <xTaskResumeAll>
	taskENTER_CRITICAL();
 800b98e:	f000 fc67 	bl	800c260 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800b992:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800b994:	2b00      	cmp	r3, #0
 800b996:	d100      	bne.n	800b99a <xQueueGenericReceive+0x11a>
 800b998:	e790      	b.n	800b8bc <xQueueGenericReceive+0x3c>
	taskEXIT_CRITICAL();
 800b99a:	f000 fc6d 	bl	800c278 <vPortExitCritical>
 800b99e:	e7d1      	b.n	800b944 <xQueueGenericReceive+0xc4>

0800b9a0 <xQueueReceiveFromISR>:
{
 800b9a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b9a2:	b085      	sub	sp, #20
 800b9a4:	0004      	movs	r4, r0
 800b9a6:	9102      	str	r1, [sp, #8]
 800b9a8:	0016      	movs	r6, r2
	configASSERT( pxQueue );
 800b9aa:	2800      	cmp	r0, #0
 800b9ac:	d101      	bne.n	800b9b2 <xQueueReceiveFromISR+0x12>
 800b9ae:	b672      	cpsid	i
 800b9b0:	e7fe      	b.n	800b9b0 <xQueueReceiveFromISR+0x10>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800b9b2:	9b02      	ldr	r3, [sp, #8]
 800b9b4:	2b00      	cmp	r3, #0
 800b9b6:	d104      	bne.n	800b9c2 <xQueueReceiveFromISR+0x22>
 800b9b8:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800b9ba:	2b00      	cmp	r3, #0
 800b9bc:	d001      	beq.n	800b9c2 <xQueueReceiveFromISR+0x22>
 800b9be:	b672      	cpsid	i
 800b9c0:	e7fe      	b.n	800b9c0 <xQueueReceiveFromISR+0x20>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800b9c2:	f000 fc67 	bl	800c294 <ulSetInterruptMaskFromISR>
			xReturn = pdFAIL;
 800b9c6:	2500      	movs	r5, #0
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800b9c8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800b9ca:	9003      	str	r0, [sp, #12]
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800b9cc:	9301      	str	r3, [sp, #4]
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800b9ce:	42ab      	cmp	r3, r5
 800b9d0:	d01b      	beq.n	800ba0a <xQueueReceiveFromISR+0x6a>
			const int8_t cRxLock = pxQueue->cRxLock;
 800b9d2:	0027      	movs	r7, r4
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800b9d4:	9902      	ldr	r1, [sp, #8]
			const int8_t cRxLock = pxQueue->cRxLock;
 800b9d6:	3744      	adds	r7, #68	; 0x44
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800b9d8:	0020      	movs	r0, r4
			const int8_t cRxLock = pxQueue->cRxLock;
 800b9da:	783d      	ldrb	r5, [r7, #0]
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800b9dc:	f7ff fde7 	bl	800b5ae <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 800b9e0:	9b01      	ldr	r3, [sp, #4]
			const int8_t cRxLock = pxQueue->cRxLock;
 800b9e2:	b26d      	sxtb	r5, r5
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 800b9e4:	3b01      	subs	r3, #1
 800b9e6:	63a3      	str	r3, [r4, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 800b9e8:	1c6b      	adds	r3, r5, #1
 800b9ea:	d114      	bne.n	800ba16 <xQueueReceiveFromISR+0x76>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800b9ec:	6923      	ldr	r3, [r4, #16]
 800b9ee:	2b00      	cmp	r3, #0
 800b9f0:	d101      	bne.n	800b9f6 <xQueueReceiveFromISR+0x56>
			xReturn = pdPASS;
 800b9f2:	2501      	movs	r5, #1
 800b9f4:	e009      	b.n	800ba0a <xQueueReceiveFromISR+0x6a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800b9f6:	0020      	movs	r0, r4
 800b9f8:	3010      	adds	r0, #16
 800b9fa:	f000 fab9 	bl	800bf70 <xTaskRemoveFromEventList>
 800b9fe:	2800      	cmp	r0, #0
 800ba00:	d0f7      	beq.n	800b9f2 <xQueueReceiveFromISR+0x52>
						if( pxHigherPriorityTaskWoken != NULL )
 800ba02:	2e00      	cmp	r6, #0
 800ba04:	d0f5      	beq.n	800b9f2 <xQueueReceiveFromISR+0x52>
							*pxHigherPriorityTaskWoken = pdTRUE;
 800ba06:	2501      	movs	r5, #1
 800ba08:	6035      	str	r5, [r6, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800ba0a:	9803      	ldr	r0, [sp, #12]
 800ba0c:	f000 fc47 	bl	800c29e <vClearInterruptMaskFromISR>
}
 800ba10:	0028      	movs	r0, r5
 800ba12:	b005      	add	sp, #20
 800ba14:	bdf0      	pop	{r4, r5, r6, r7, pc}
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 800ba16:	3501      	adds	r5, #1
 800ba18:	b26d      	sxtb	r5, r5
 800ba1a:	703d      	strb	r5, [r7, #0]
 800ba1c:	e7e9      	b.n	800b9f2 <xQueueReceiveFromISR+0x52>
	...

0800ba20 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800ba20:	4b06      	ldr	r3, [pc, #24]	; (800ba3c <prvResetNextTaskUnblockTime+0x1c>)
 800ba22:	681a      	ldr	r2, [r3, #0]
 800ba24:	6812      	ldr	r2, [r2, #0]
 800ba26:	2a00      	cmp	r2, #0
 800ba28:	d102      	bne.n	800ba30 <prvResetNextTaskUnblockTime+0x10>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 800ba2a:	3a01      	subs	r2, #1
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800ba2c:	605a      	str	r2, [r3, #4]
	}
}
 800ba2e:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800ba30:	681a      	ldr	r2, [r3, #0]
 800ba32:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800ba34:	68d2      	ldr	r2, [r2, #12]
 800ba36:	6852      	ldr	r2, [r2, #4]
 800ba38:	e7f8      	b.n	800ba2c <prvResetNextTaskUnblockTime+0xc>
 800ba3a:	46c0      	nop			; (mov r8, r8)
 800ba3c:	200003e8 	.word	0x200003e8

0800ba40 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 800ba40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ba42:	0005      	movs	r5, r0
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 800ba44:	4c13      	ldr	r4, [pc, #76]	; (800ba94 <prvAddCurrentTaskToDelayedList+0x54>)
{
 800ba46:	000f      	movs	r7, r1
const TickType_t xConstTickCount = xTickCount;
 800ba48:	68a6      	ldr	r6, [r4, #8]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800ba4a:	68e0      	ldr	r0, [r4, #12]
 800ba4c:	3004      	adds	r0, #4
 800ba4e:	f7ff fd70 	bl	800b532 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800ba52:	1c6b      	adds	r3, r5, #1
 800ba54:	d108      	bne.n	800ba68 <prvAddCurrentTaskToDelayedList+0x28>
 800ba56:	2f00      	cmp	r7, #0
 800ba58:	d006      	beq.n	800ba68 <prvAddCurrentTaskToDelayedList+0x28>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800ba5a:	0020      	movs	r0, r4
 800ba5c:	68e1      	ldr	r1, [r4, #12]
 800ba5e:	3010      	adds	r0, #16
 800ba60:	3104      	adds	r1, #4
 800ba62:	f7ff fd43 	bl	800b4ec <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 800ba66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800ba68:	68e3      	ldr	r3, [r4, #12]
			xTimeToWake = xConstTickCount + xTicksToWait;
 800ba6a:	1975      	adds	r5, r6, r5
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800ba6c:	605d      	str	r5, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 800ba6e:	42ae      	cmp	r6, r5
 800ba70:	d905      	bls.n	800ba7e <prvAddCurrentTaskToDelayedList+0x3e>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800ba72:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800ba74:	68e1      	ldr	r1, [r4, #12]
 800ba76:	3104      	adds	r1, #4
 800ba78:	f7ff fd44 	bl	800b504 <vListInsert>
 800ba7c:	e7f3      	b.n	800ba66 <prvAddCurrentTaskToDelayedList+0x26>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800ba7e:	6820      	ldr	r0, [r4, #0]
 800ba80:	68e1      	ldr	r1, [r4, #12]
 800ba82:	3104      	adds	r1, #4
 800ba84:	f7ff fd3e 	bl	800b504 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 800ba88:	6863      	ldr	r3, [r4, #4]
 800ba8a:	42ab      	cmp	r3, r5
 800ba8c:	d9eb      	bls.n	800ba66 <prvAddCurrentTaskToDelayedList+0x26>
					xNextTaskUnblockTime = xTimeToWake;
 800ba8e:	6065      	str	r5, [r4, #4]
}
 800ba90:	e7e9      	b.n	800ba66 <prvAddCurrentTaskToDelayedList+0x26>
 800ba92:	46c0      	nop			; (mov r8, r8)
 800ba94:	200003e8 	.word	0x200003e8

0800ba98 <xTaskCreate>:
	{
 800ba98:	b5f0      	push	{r4, r5, r6, r7, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800ba9a:	0095      	lsls	r5, r2, #2
	{
 800ba9c:	b085      	sub	sp, #20
 800ba9e:	9002      	str	r0, [sp, #8]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800baa0:	0028      	movs	r0, r5
	{
 800baa2:	000f      	movs	r7, r1
 800baa4:	9303      	str	r3, [sp, #12]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800baa6:	f000 faff 	bl	800c0a8 <pvPortMalloc>
 800baaa:	1e06      	subs	r6, r0, #0
			if( pxStack != NULL )
 800baac:	d100      	bne.n	800bab0 <xTaskCreate+0x18>
 800baae:	e08b      	b.n	800bbc8 <xTaskCreate+0x130>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 800bab0:	204c      	movs	r0, #76	; 0x4c
 800bab2:	f000 faf9 	bl	800c0a8 <pvPortMalloc>
 800bab6:	1e04      	subs	r4, r0, #0
				if( pxNewTCB != NULL )
 800bab8:	d100      	bne.n	800babc <xTaskCreate+0x24>
 800baba:	e082      	b.n	800bbc2 <xTaskCreate+0x12a>
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800babc:	2307      	movs	r3, #7
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800babe:	3d04      	subs	r5, #4
					pxNewTCB->pxStack = pxStack;
 800bac0:	6306      	str	r6, [r0, #48]	; 0x30
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800bac2:	1976      	adds	r6, r6, r5
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800bac4:	439e      	bics	r6, r3
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800bac6:	2300      	movs	r3, #0
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800bac8:	9601      	str	r6, [sp, #4]
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800baca:	001a      	movs	r2, r3
 800bacc:	5cf9      	ldrb	r1, [r7, r3]
 800bace:	3234      	adds	r2, #52	; 0x34
 800bad0:	54a1      	strb	r1, [r4, r2]
		if( pcName[ x ] == 0x00 )
 800bad2:	5cfa      	ldrb	r2, [r7, r3]
 800bad4:	2a00      	cmp	r2, #0
 800bad6:	d002      	beq.n	800bade <xTaskCreate+0x46>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800bad8:	3301      	adds	r3, #1
 800bada:	2b10      	cmp	r3, #16
 800badc:	d1f5      	bne.n	800baca <xTaskCreate+0x32>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800bade:	0023      	movs	r3, r4
 800bae0:	2200      	movs	r2, #0
 800bae2:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 800bae4:	3343      	adds	r3, #67	; 0x43
 800bae6:	701a      	strb	r2, [r3, #0]
 800bae8:	2d06      	cmp	r5, #6
 800baea:	d900      	bls.n	800baee <xTaskCreate+0x56>
 800baec:	2506      	movs	r5, #6
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800baee:	1d26      	adds	r6, r4, #4
	pxNewTCB->uxPriority = uxPriority;
 800baf0:	62e5      	str	r5, [r4, #44]	; 0x2c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800baf2:	0030      	movs	r0, r6
 800baf4:	f7ff fcf7 	bl	800b4e6 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 800baf8:	0020      	movs	r0, r4
 800bafa:	3018      	adds	r0, #24
 800bafc:	f7ff fcf3 	bl	800b4e6 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bb00:	2307      	movs	r3, #7
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800bb02:	0022      	movs	r2, r4
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bb04:	1b5d      	subs	r5, r3, r5
		pxNewTCB->ulNotifiedValue = 0;
 800bb06:	2300      	movs	r3, #0
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800bb08:	3248      	adds	r2, #72	; 0x48
		pxNewTCB->ulNotifiedValue = 0;
 800bb0a:	6463      	str	r3, [r4, #68]	; 0x44
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 800bb0c:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bb0e:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800bb10:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800bb12:	9902      	ldr	r1, [sp, #8]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800bb14:	7013      	strb	r3, [r2, #0]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800bb16:	9801      	ldr	r0, [sp, #4]
 800bb18:	9a03      	ldr	r2, [sp, #12]
 800bb1a:	f000 fb83 	bl	800c224 <pxPortInitialiseStack>
	if( ( void * ) pxCreatedTask != NULL )
 800bb1e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800bb20:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 800bb22:	2b00      	cmp	r3, #0
 800bb24:	d000      	beq.n	800bb28 <xTaskCreate+0x90>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 800bb26:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
 800bb28:	f000 fb9a 	bl	800c260 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 800bb2c:	4d2d      	ldr	r5, [pc, #180]	; (800bbe4 <xTaskCreate+0x14c>)
 800bb2e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800bb30:	3301      	adds	r3, #1
 800bb32:	62ab      	str	r3, [r5, #40]	; 0x28
		if( pxCurrentTCB == NULL )
 800bb34:	68ef      	ldr	r7, [r5, #12]
 800bb36:	2f00      	cmp	r7, #0
 800bb38:	d149      	bne.n	800bbce <xTaskCreate+0x136>
			pxCurrentTCB = pxNewTCB;
 800bb3a:	60ec      	str	r4, [r5, #12]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800bb3c:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800bb3e:	2b01      	cmp	r3, #1
 800bb40:	d11f      	bne.n	800bb82 <xTaskCreate+0xea>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800bb42:	2014      	movs	r0, #20
 800bb44:	4378      	muls	r0, r7
 800bb46:	4b28      	ldr	r3, [pc, #160]	; (800bbe8 <xTaskCreate+0x150>)
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800bb48:	3701      	adds	r7, #1
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800bb4a:	1818      	adds	r0, r3, r0
 800bb4c:	f7ff fcc0 	bl	800b4d0 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800bb50:	2f07      	cmp	r7, #7
 800bb52:	d1f6      	bne.n	800bb42 <xTaskCreate+0xaa>
	vListInitialise( &xDelayedTaskList1 );
 800bb54:	002f      	movs	r7, r5
 800bb56:	372c      	adds	r7, #44	; 0x2c
 800bb58:	0038      	movs	r0, r7
 800bb5a:	f7ff fcb9 	bl	800b4d0 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800bb5e:	4823      	ldr	r0, [pc, #140]	; (800bbec <xTaskCreate+0x154>)
 800bb60:	f7ff fcb6 	bl	800b4d0 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 800bb64:	0028      	movs	r0, r5
 800bb66:	3054      	adds	r0, #84	; 0x54
 800bb68:	f7ff fcb2 	bl	800b4d0 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 800bb6c:	0028      	movs	r0, r5
 800bb6e:	3068      	adds	r0, #104	; 0x68
 800bb70:	f7ff fcae 	bl	800b4d0 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 800bb74:	0028      	movs	r0, r5
 800bb76:	3010      	adds	r0, #16
 800bb78:	f7ff fcaa 	bl	800b4d0 <vListInitialise>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800bb7c:	4b1b      	ldr	r3, [pc, #108]	; (800bbec <xTaskCreate+0x154>)
	pxDelayedTaskList = &xDelayedTaskList1;
 800bb7e:	602f      	str	r7, [r5, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800bb80:	626b      	str	r3, [r5, #36]	; 0x24
		uxTaskNumber++;
 800bb82:	4b1b      	ldr	r3, [pc, #108]	; (800bbf0 <xTaskCreate+0x158>)
 800bb84:	681a      	ldr	r2, [r3, #0]
		prvAddTaskToReadyList( pxNewTCB );
 800bb86:	6859      	ldr	r1, [r3, #4]
		uxTaskNumber++;
 800bb88:	3201      	adds	r2, #1
 800bb8a:	601a      	str	r2, [r3, #0]
		prvAddTaskToReadyList( pxNewTCB );
 800bb8c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800bb8e:	428a      	cmp	r2, r1
 800bb90:	d900      	bls.n	800bb94 <xTaskCreate+0xfc>
 800bb92:	605a      	str	r2, [r3, #4]
 800bb94:	2014      	movs	r0, #20
 800bb96:	4350      	muls	r0, r2
 800bb98:	4b13      	ldr	r3, [pc, #76]	; (800bbe8 <xTaskCreate+0x150>)
 800bb9a:	0031      	movs	r1, r6
 800bb9c:	1818      	adds	r0, r3, r0
 800bb9e:	f7ff fca5 	bl	800b4ec <vListInsertEnd>
	taskEXIT_CRITICAL();
 800bba2:	f000 fb69 	bl	800c278 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 800bba6:	6feb      	ldr	r3, [r5, #124]	; 0x7c
			xReturn = pdPASS;
 800bba8:	2601      	movs	r6, #1
	if( xSchedulerRunning != pdFALSE )
 800bbaa:	2b00      	cmp	r3, #0
 800bbac:	d006      	beq.n	800bbbc <xTaskCreate+0x124>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800bbae:	68eb      	ldr	r3, [r5, #12]
 800bbb0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800bbb2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800bbb4:	429a      	cmp	r2, r3
 800bbb6:	d201      	bcs.n	800bbbc <xTaskCreate+0x124>
			taskYIELD_IF_USING_PREEMPTION();
 800bbb8:	f000 fb46 	bl	800c248 <vPortYield>
	}
 800bbbc:	0030      	movs	r0, r6
 800bbbe:	b005      	add	sp, #20
 800bbc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vPortFree( pxStack );
 800bbc2:	0030      	movs	r0, r6
 800bbc4:	f000 fae2 	bl	800c18c <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800bbc8:	2601      	movs	r6, #1
 800bbca:	4276      	negs	r6, r6
 800bbcc:	e7f6      	b.n	800bbbc <xTaskCreate+0x124>
			if( xSchedulerRunning == pdFALSE )
 800bbce:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 800bbd0:	2b00      	cmp	r3, #0
 800bbd2:	d1d6      	bne.n	800bb82 <xTaskCreate+0xea>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 800bbd4:	68eb      	ldr	r3, [r5, #12]
 800bbd6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800bbd8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bbda:	4293      	cmp	r3, r2
 800bbdc:	d8d1      	bhi.n	800bb82 <xTaskCreate+0xea>
					pxCurrentTCB = pxNewTCB;
 800bbde:	60ec      	str	r4, [r5, #12]
 800bbe0:	e7cf      	b.n	800bb82 <xTaskCreate+0xea>
 800bbe2:	46c0      	nop			; (mov r8, r8)
 800bbe4:	200003e8 	.word	0x200003e8
 800bbe8:	20000488 	.word	0x20000488
 800bbec:	20000428 	.word	0x20000428
 800bbf0:	20000468 	.word	0x20000468

0800bbf4 <vTaskDelete>:
	{
 800bbf4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800bbf6:	0004      	movs	r4, r0
		taskENTER_CRITICAL();
 800bbf8:	f000 fb32 	bl	800c260 <vPortEnterCritical>
 800bbfc:	4d1c      	ldr	r5, [pc, #112]	; (800bc70 <vTaskDelete+0x7c>)
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 800bbfe:	2c00      	cmp	r4, #0
 800bc00:	d100      	bne.n	800bc04 <vTaskDelete+0x10>
 800bc02:	68ec      	ldr	r4, [r5, #12]
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800bc04:	1d27      	adds	r7, r4, #4
 800bc06:	0038      	movs	r0, r7
 800bc08:	f7ff fc93 	bl	800b532 <uxListRemove>
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800bc0c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800bc0e:	2b00      	cmp	r3, #0
 800bc10:	d003      	beq.n	800bc1a <vTaskDelete+0x26>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800bc12:	0020      	movs	r0, r4
 800bc14:	3018      	adds	r0, #24
 800bc16:	f7ff fc8c 	bl	800b532 <uxListRemove>
			uxTaskNumber++;
 800bc1a:	4e16      	ldr	r6, [pc, #88]	; (800bc74 <vTaskDelete+0x80>)
 800bc1c:	6833      	ldr	r3, [r6, #0]
 800bc1e:	3301      	adds	r3, #1
 800bc20:	6033      	str	r3, [r6, #0]
			if( pxTCB == pxCurrentTCB )
 800bc22:	68eb      	ldr	r3, [r5, #12]
 800bc24:	42a3      	cmp	r3, r4
 800bc26:	d114      	bne.n	800bc52 <vTaskDelete+0x5e>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 800bc28:	0028      	movs	r0, r5
 800bc2a:	0039      	movs	r1, r7
 800bc2c:	3068      	adds	r0, #104	; 0x68
 800bc2e:	f7ff fc5d 	bl	800b4ec <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
 800bc32:	68b3      	ldr	r3, [r6, #8]
 800bc34:	3301      	adds	r3, #1
 800bc36:	60b3      	str	r3, [r6, #8]
		taskEXIT_CRITICAL();
 800bc38:	f000 fb1e 	bl	800c278 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 800bc3c:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 800bc3e:	2b00      	cmp	r3, #0
 800bc40:	d015      	beq.n	800bc6e <vTaskDelete+0x7a>
			if( pxTCB == pxCurrentTCB )
 800bc42:	68eb      	ldr	r3, [r5, #12]
 800bc44:	42a3      	cmp	r3, r4
 800bc46:	d112      	bne.n	800bc6e <vTaskDelete+0x7a>
				configASSERT( uxSchedulerSuspended == 0 );
 800bc48:	68f3      	ldr	r3, [r6, #12]
 800bc4a:	2b00      	cmp	r3, #0
 800bc4c:	d00d      	beq.n	800bc6a <vTaskDelete+0x76>
 800bc4e:	b672      	cpsid	i
 800bc50:	e7fe      	b.n	800bc50 <vTaskDelete+0x5c>
				--uxCurrentNumberOfTasks;
 800bc52:	6aab      	ldr	r3, [r5, #40]	; 0x28
			vPortFree( pxTCB->pxStack );
 800bc54:	6b20      	ldr	r0, [r4, #48]	; 0x30
				--uxCurrentNumberOfTasks;
 800bc56:	3b01      	subs	r3, #1
 800bc58:	62ab      	str	r3, [r5, #40]	; 0x28
			vPortFree( pxTCB->pxStack );
 800bc5a:	f000 fa97 	bl	800c18c <vPortFree>
			vPortFree( pxTCB );
 800bc5e:	0020      	movs	r0, r4
 800bc60:	f000 fa94 	bl	800c18c <vPortFree>
				prvResetNextTaskUnblockTime();
 800bc64:	f7ff fedc 	bl	800ba20 <prvResetNextTaskUnblockTime>
 800bc68:	e7e6      	b.n	800bc38 <vTaskDelete+0x44>
				portYIELD_WITHIN_API();
 800bc6a:	f000 faed 	bl	800c248 <vPortYield>
	}
 800bc6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800bc70:	200003e8 	.word	0x200003e8
 800bc74:	20000468 	.word	0x20000468

0800bc78 <vTaskStartScheduler>:
{
 800bc78:	b513      	push	{r0, r1, r4, lr}
		xReturn = xTaskCreate(	prvIdleTask,
 800bc7a:	2400      	movs	r4, #0
 800bc7c:	4b0c      	ldr	r3, [pc, #48]	; (800bcb0 <vTaskStartScheduler+0x38>)
 800bc7e:	9400      	str	r4, [sp, #0]
 800bc80:	3310      	adds	r3, #16
 800bc82:	9301      	str	r3, [sp, #4]
 800bc84:	2228      	movs	r2, #40	; 0x28
 800bc86:	0023      	movs	r3, r4
 800bc88:	490a      	ldr	r1, [pc, #40]	; (800bcb4 <vTaskStartScheduler+0x3c>)
 800bc8a:	480b      	ldr	r0, [pc, #44]	; (800bcb8 <vTaskStartScheduler+0x40>)
 800bc8c:	f7ff ff04 	bl	800ba98 <xTaskCreate>
	if( xReturn == pdPASS )
 800bc90:	2801      	cmp	r0, #1
 800bc92:	d109      	bne.n	800bca8 <vTaskStartScheduler+0x30>
		portDISABLE_INTERRUPTS();
 800bc94:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
 800bc96:	2201      	movs	r2, #1
 800bc98:	4b08      	ldr	r3, [pc, #32]	; (800bcbc <vTaskStartScheduler+0x44>)
 800bc9a:	4252      	negs	r2, r2
 800bc9c:	605a      	str	r2, [r3, #4]
		xSchedulerRunning = pdTRUE;
 800bc9e:	67d8      	str	r0, [r3, #124]	; 0x7c
		xTickCount = ( TickType_t ) 0U;
 800bca0:	609c      	str	r4, [r3, #8]
		if( xPortStartScheduler() != pdFALSE )
 800bca2:	f000 fb4d 	bl	800c340 <xPortStartScheduler>
}
 800bca6:	bd13      	pop	{r0, r1, r4, pc}
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 800bca8:	1c43      	adds	r3, r0, #1
 800bcaa:	d1fc      	bne.n	800bca6 <vTaskStartScheduler+0x2e>
 800bcac:	b672      	cpsid	i
 800bcae:	e7fe      	b.n	800bcae <vTaskStartScheduler+0x36>
 800bcb0:	20000468 	.word	0x20000468
 800bcb4:	0800c876 	.word	0x0800c876
 800bcb8:	0800be8d 	.word	0x0800be8d
 800bcbc:	200003e8 	.word	0x200003e8

0800bcc0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 800bcc0:	4a02      	ldr	r2, [pc, #8]	; (800bccc <vTaskSuspendAll+0xc>)
 800bcc2:	68d3      	ldr	r3, [r2, #12]
 800bcc4:	3301      	adds	r3, #1
 800bcc6:	60d3      	str	r3, [r2, #12]
}
 800bcc8:	4770      	bx	lr
 800bcca:	46c0      	nop			; (mov r8, r8)
 800bccc:	20000468 	.word	0x20000468

0800bcd0 <uxTaskGetNumberOfTasks>:
	return uxCurrentNumberOfTasks;
 800bcd0:	4b01      	ldr	r3, [pc, #4]	; (800bcd8 <uxTaskGetNumberOfTasks+0x8>)
 800bcd2:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
 800bcd4:	4770      	bx	lr
 800bcd6:	46c0      	nop			; (mov r8, r8)
 800bcd8:	200003e8 	.word	0x200003e8

0800bcdc <xTaskIncrementTick>:
{
 800bcdc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800bcde:	4d2f      	ldr	r5, [pc, #188]	; (800bd9c <xTaskIncrementTick+0xc0>)
 800bce0:	68eb      	ldr	r3, [r5, #12]
 800bce2:	2b00      	cmp	r3, #0
 800bce4:	d155      	bne.n	800bd92 <xTaskIncrementTick+0xb6>
		const TickType_t xConstTickCount = xTickCount + 1;
 800bce6:	4c2e      	ldr	r4, [pc, #184]	; (800bda0 <xTaskIncrementTick+0xc4>)
 800bce8:	68a3      	ldr	r3, [r4, #8]
 800bcea:	3301      	adds	r3, #1
 800bcec:	9300      	str	r3, [sp, #0]
		xTickCount = xConstTickCount;
 800bcee:	60a3      	str	r3, [r4, #8]
		if( xConstTickCount == ( TickType_t ) 0U )
 800bcf0:	2b00      	cmp	r3, #0
 800bcf2:	d10e      	bne.n	800bd12 <xTaskIncrementTick+0x36>
			taskSWITCH_DELAYED_LISTS();
 800bcf4:	6823      	ldr	r3, [r4, #0]
 800bcf6:	681b      	ldr	r3, [r3, #0]
 800bcf8:	2b00      	cmp	r3, #0
 800bcfa:	d001      	beq.n	800bd00 <xTaskIncrementTick+0x24>
 800bcfc:	b672      	cpsid	i
 800bcfe:	e7fe      	b.n	800bcfe <xTaskIncrementTick+0x22>
 800bd00:	6823      	ldr	r3, [r4, #0]
 800bd02:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800bd04:	6022      	str	r2, [r4, #0]
 800bd06:	6263      	str	r3, [r4, #36]	; 0x24
 800bd08:	696b      	ldr	r3, [r5, #20]
 800bd0a:	3301      	adds	r3, #1
 800bd0c:	616b      	str	r3, [r5, #20]
 800bd0e:	f7ff fe87 	bl	800ba20 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 800bd12:	6863      	ldr	r3, [r4, #4]
 800bd14:	9a00      	ldr	r2, [sp, #0]
BaseType_t xSwitchRequired = pdFALSE;
 800bd16:	2600      	movs	r6, #0
		if( xConstTickCount >= xNextTaskUnblockTime )
 800bd18:	4293      	cmp	r3, r2
 800bd1a:	d933      	bls.n	800bd84 <xTaskIncrementTick+0xa8>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800bd1c:	68e3      	ldr	r3, [r4, #12]
 800bd1e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800bd20:	2314      	movs	r3, #20
 800bd22:	4353      	muls	r3, r2
 800bd24:	4a1f      	ldr	r2, [pc, #124]	; (800bda4 <xTaskIncrementTick+0xc8>)
 800bd26:	58d3      	ldr	r3, [r2, r3]
 800bd28:	2b01      	cmp	r3, #1
 800bd2a:	d900      	bls.n	800bd2e <xTaskIncrementTick+0x52>
				xSwitchRequired = pdTRUE;
 800bd2c:	2601      	movs	r6, #1
		if( xYieldPending != pdFALSE )
 800bd2e:	69eb      	ldr	r3, [r5, #28]
 800bd30:	2b00      	cmp	r3, #0
 800bd32:	d000      	beq.n	800bd36 <xTaskIncrementTick+0x5a>
			xSwitchRequired = pdTRUE;
 800bd34:	2601      	movs	r6, #1
}
 800bd36:	0030      	movs	r0, r6
 800bd38:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800bd3a:	6823      	ldr	r3, [r4, #0]
					if( xConstTickCount < xItemValue )
 800bd3c:	9a00      	ldr	r2, [sp, #0]
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800bd3e:	68db      	ldr	r3, [r3, #12]
 800bd40:	68df      	ldr	r7, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800bd42:	687b      	ldr	r3, [r7, #4]
					if( xConstTickCount < xItemValue )
 800bd44:	429a      	cmp	r2, r3
 800bd46:	d322      	bcc.n	800bd8e <xTaskIncrementTick+0xb2>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800bd48:	1d3b      	adds	r3, r7, #4
 800bd4a:	0018      	movs	r0, r3
 800bd4c:	9301      	str	r3, [sp, #4]
 800bd4e:	f7ff fbf0 	bl	800b532 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800bd52:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800bd54:	2b00      	cmp	r3, #0
 800bd56:	d003      	beq.n	800bd60 <xTaskIncrementTick+0x84>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800bd58:	0038      	movs	r0, r7
 800bd5a:	3018      	adds	r0, #24
 800bd5c:	f7ff fbe9 	bl	800b532 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800bd60:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800bd62:	686b      	ldr	r3, [r5, #4]
 800bd64:	4298      	cmp	r0, r3
 800bd66:	d900      	bls.n	800bd6a <xTaskIncrementTick+0x8e>
 800bd68:	6068      	str	r0, [r5, #4]
 800bd6a:	2314      	movs	r3, #20
 800bd6c:	4358      	muls	r0, r3
 800bd6e:	4b0d      	ldr	r3, [pc, #52]	; (800bda4 <xTaskIncrementTick+0xc8>)
 800bd70:	1d39      	adds	r1, r7, #4
 800bd72:	1818      	adds	r0, r3, r0
 800bd74:	f7ff fbba 	bl	800b4ec <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800bd78:	68e3      	ldr	r3, [r4, #12]
 800bd7a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800bd7c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bd7e:	429a      	cmp	r2, r3
 800bd80:	d300      	bcc.n	800bd84 <xTaskIncrementTick+0xa8>
							xSwitchRequired = pdTRUE;
 800bd82:	2601      	movs	r6, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800bd84:	6823      	ldr	r3, [r4, #0]
 800bd86:	681b      	ldr	r3, [r3, #0]
 800bd88:	2b00      	cmp	r3, #0
 800bd8a:	d1d6      	bne.n	800bd3a <xTaskIncrementTick+0x5e>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bd8c:	3b01      	subs	r3, #1
						xNextTaskUnblockTime = xItemValue;
 800bd8e:	6063      	str	r3, [r4, #4]
						break;
 800bd90:	e7c4      	b.n	800bd1c <xTaskIncrementTick+0x40>
		++uxPendedTicks;
 800bd92:	69ab      	ldr	r3, [r5, #24]
BaseType_t xSwitchRequired = pdFALSE;
 800bd94:	2600      	movs	r6, #0
		++uxPendedTicks;
 800bd96:	3301      	adds	r3, #1
 800bd98:	61ab      	str	r3, [r5, #24]
 800bd9a:	e7c8      	b.n	800bd2e <xTaskIncrementTick+0x52>
 800bd9c:	20000468 	.word	0x20000468
 800bda0:	200003e8 	.word	0x200003e8
 800bda4:	20000488 	.word	0x20000488

0800bda8 <xTaskResumeAll>:
{
 800bda8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( uxSchedulerSuspended );
 800bdaa:	4c28      	ldr	r4, [pc, #160]	; (800be4c <xTaskResumeAll+0xa4>)
 800bdac:	68e3      	ldr	r3, [r4, #12]
 800bdae:	2b00      	cmp	r3, #0
 800bdb0:	d101      	bne.n	800bdb6 <xTaskResumeAll+0xe>
 800bdb2:	b672      	cpsid	i
 800bdb4:	e7fe      	b.n	800bdb4 <xTaskResumeAll+0xc>
	taskENTER_CRITICAL();
 800bdb6:	f000 fa53 	bl	800c260 <vPortEnterCritical>
		--uxSchedulerSuspended;
 800bdba:	68e3      	ldr	r3, [r4, #12]
 800bdbc:	3b01      	subs	r3, #1
 800bdbe:	60e3      	str	r3, [r4, #12]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800bdc0:	68e5      	ldr	r5, [r4, #12]
 800bdc2:	2d00      	cmp	r5, #0
 800bdc4:	d004      	beq.n	800bdd0 <xTaskResumeAll+0x28>
BaseType_t xAlreadyYielded = pdFALSE;
 800bdc6:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 800bdc8:	f000 fa56 	bl	800c278 <vPortExitCritical>
}
 800bdcc:	0020      	movs	r0, r4
 800bdce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800bdd0:	4e1f      	ldr	r6, [pc, #124]	; (800be50 <xTaskResumeAll+0xa8>)
 800bdd2:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800bdd4:	2b00      	cmp	r3, #0
 800bdd6:	d0f6      	beq.n	800bdc6 <xTaskResumeAll+0x1e>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800bdd8:	6d73      	ldr	r3, [r6, #84]	; 0x54
 800bdda:	2b00      	cmp	r3, #0
 800bddc:	d117      	bne.n	800be0e <xTaskResumeAll+0x66>
				if( pxTCB != NULL )
 800bdde:	2d00      	cmp	r5, #0
 800bde0:	d001      	beq.n	800bde6 <xTaskResumeAll+0x3e>
					prvResetNextTaskUnblockTime();
 800bde2:	f7ff fe1d 	bl	800ba20 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 800bde6:	69a5      	ldr	r5, [r4, #24]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 800bde8:	2d00      	cmp	r5, #0
 800bdea:	d009      	beq.n	800be00 <xTaskResumeAll+0x58>
								xYieldPending = pdTRUE;
 800bdec:	2601      	movs	r6, #1
							if( xTaskIncrementTick() != pdFALSE )
 800bdee:	f7ff ff75 	bl	800bcdc <xTaskIncrementTick>
 800bdf2:	2800      	cmp	r0, #0
 800bdf4:	d000      	beq.n	800bdf8 <xTaskResumeAll+0x50>
								xYieldPending = pdTRUE;
 800bdf6:	61e6      	str	r6, [r4, #28]
							--uxPendedCounts;
 800bdf8:	3d01      	subs	r5, #1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 800bdfa:	2d00      	cmp	r5, #0
 800bdfc:	d1f7      	bne.n	800bdee <xTaskResumeAll+0x46>
						uxPendedTicks = 0;
 800bdfe:	61a5      	str	r5, [r4, #24]
				if( xYieldPending != pdFALSE )
 800be00:	69e3      	ldr	r3, [r4, #28]
 800be02:	2b00      	cmp	r3, #0
 800be04:	d0df      	beq.n	800bdc6 <xTaskResumeAll+0x1e>
					taskYIELD_IF_USING_PREEMPTION();
 800be06:	f000 fa1f 	bl	800c248 <vPortYield>
						xAlreadyYielded = pdTRUE;
 800be0a:	2401      	movs	r4, #1
 800be0c:	e7dc      	b.n	800bdc8 <xTaskResumeAll+0x20>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 800be0e:	6e33      	ldr	r3, [r6, #96]	; 0x60
 800be10:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800be12:	0028      	movs	r0, r5
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800be14:	1d2f      	adds	r7, r5, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800be16:	3018      	adds	r0, #24
 800be18:	f7ff fb8b 	bl	800b532 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800be1c:	0038      	movs	r0, r7
 800be1e:	f7ff fb88 	bl	800b532 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800be22:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 800be24:	6863      	ldr	r3, [r4, #4]
 800be26:	4298      	cmp	r0, r3
 800be28:	d900      	bls.n	800be2c <xTaskResumeAll+0x84>
 800be2a:	6060      	str	r0, [r4, #4]
 800be2c:	2314      	movs	r3, #20
 800be2e:	4358      	muls	r0, r3
 800be30:	4b08      	ldr	r3, [pc, #32]	; (800be54 <xTaskResumeAll+0xac>)
 800be32:	0039      	movs	r1, r7
 800be34:	18c0      	adds	r0, r0, r3
 800be36:	f7ff fb59 	bl	800b4ec <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800be3a:	68f3      	ldr	r3, [r6, #12]
 800be3c:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800be3e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800be40:	429a      	cmp	r2, r3
 800be42:	d3c9      	bcc.n	800bdd8 <xTaskResumeAll+0x30>
						xYieldPending = pdTRUE;
 800be44:	2301      	movs	r3, #1
 800be46:	61e3      	str	r3, [r4, #28]
 800be48:	e7c6      	b.n	800bdd8 <xTaskResumeAll+0x30>
 800be4a:	46c0      	nop			; (mov r8, r8)
 800be4c:	20000468 	.word	0x20000468
 800be50:	200003e8 	.word	0x200003e8
 800be54:	20000488 	.word	0x20000488

0800be58 <vTaskDelay>:
	{
 800be58:	b570      	push	{r4, r5, r6, lr}
 800be5a:	1e04      	subs	r4, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
 800be5c:	d102      	bne.n	800be64 <vTaskDelay+0xc>
			portYIELD_WITHIN_API();
 800be5e:	f000 f9f3 	bl	800c248 <vPortYield>
	}
 800be62:	bd70      	pop	{r4, r5, r6, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 800be64:	4b08      	ldr	r3, [pc, #32]	; (800be88 <vTaskDelay+0x30>)
 800be66:	68dd      	ldr	r5, [r3, #12]
 800be68:	2d00      	cmp	r5, #0
 800be6a:	d001      	beq.n	800be70 <vTaskDelay+0x18>
 800be6c:	b672      	cpsid	i
 800be6e:	e7fe      	b.n	800be6e <vTaskDelay+0x16>
			vTaskSuspendAll();
 800be70:	f7ff ff26 	bl	800bcc0 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 800be74:	0029      	movs	r1, r5
 800be76:	0020      	movs	r0, r4
 800be78:	f7ff fde2 	bl	800ba40 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 800be7c:	f7ff ff94 	bl	800bda8 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 800be80:	2800      	cmp	r0, #0
 800be82:	d0ec      	beq.n	800be5e <vTaskDelay+0x6>
 800be84:	e7ed      	b.n	800be62 <vTaskDelay+0xa>
 800be86:	46c0      	nop			; (mov r8, r8)
 800be88:	20000468 	.word	0x20000468

0800be8c <prvIdleTask>:
{
 800be8c:	b570      	push	{r4, r5, r6, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800be8e:	4d14      	ldr	r5, [pc, #80]	; (800bee0 <prvIdleTask+0x54>)
 800be90:	68ab      	ldr	r3, [r5, #8]
 800be92:	2b00      	cmp	r3, #0
 800be94:	d106      	bne.n	800bea4 <prvIdleTask+0x18>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800be96:	4b13      	ldr	r3, [pc, #76]	; (800bee4 <prvIdleTask+0x58>)
 800be98:	681b      	ldr	r3, [r3, #0]
 800be9a:	2b01      	cmp	r3, #1
 800be9c:	d9f7      	bls.n	800be8e <prvIdleTask+0x2>
				taskYIELD();
 800be9e:	f000 f9d3 	bl	800c248 <vPortYield>
 800bea2:	e7f4      	b.n	800be8e <prvIdleTask+0x2>
			vTaskSuspendAll();
 800bea4:	f7ff ff0c 	bl	800bcc0 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 800bea8:	4c0f      	ldr	r4, [pc, #60]	; (800bee8 <prvIdleTask+0x5c>)
 800beaa:	6ea6      	ldr	r6, [r4, #104]	; 0x68
			( void ) xTaskResumeAll();
 800beac:	f7ff ff7c 	bl	800bda8 <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 800beb0:	2e00      	cmp	r6, #0
 800beb2:	d0ec      	beq.n	800be8e <prvIdleTask+0x2>
				taskENTER_CRITICAL();
 800beb4:	f000 f9d4 	bl	800c260 <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 800beb8:	6f63      	ldr	r3, [r4, #116]	; 0x74
 800beba:	68de      	ldr	r6, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800bebc:	1d30      	adds	r0, r6, #4
 800bebe:	f7ff fb38 	bl	800b532 <uxListRemove>
					--uxCurrentNumberOfTasks;
 800bec2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800bec4:	3b01      	subs	r3, #1
 800bec6:	62a3      	str	r3, [r4, #40]	; 0x28
					--uxDeletedTasksWaitingCleanUp;
 800bec8:	68ab      	ldr	r3, [r5, #8]
 800beca:	3b01      	subs	r3, #1
 800becc:	60ab      	str	r3, [r5, #8]
				taskEXIT_CRITICAL();
 800bece:	f000 f9d3 	bl	800c278 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 800bed2:	6b30      	ldr	r0, [r6, #48]	; 0x30
 800bed4:	f000 f95a 	bl	800c18c <vPortFree>
			vPortFree( pxTCB );
 800bed8:	0030      	movs	r0, r6
 800beda:	f000 f957 	bl	800c18c <vPortFree>
 800bede:	e7d6      	b.n	800be8e <prvIdleTask+0x2>
 800bee0:	20000468 	.word	0x20000468
 800bee4:	20000488 	.word	0x20000488
 800bee8:	200003e8 	.word	0x200003e8

0800beec <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800beec:	4914      	ldr	r1, [pc, #80]	; (800bf40 <vTaskSwitchContext+0x54>)
{
 800beee:	b570      	push	{r4, r5, r6, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800bef0:	68cb      	ldr	r3, [r1, #12]
 800bef2:	2b00      	cmp	r3, #0
 800bef4:	d002      	beq.n	800befc <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
 800bef6:	2301      	movs	r3, #1
 800bef8:	61cb      	str	r3, [r1, #28]
}
 800befa:	bd70      	pop	{r4, r5, r6, pc}
 800befc:	2514      	movs	r5, #20
		xYieldPending = pdFALSE;
 800befe:	61cb      	str	r3, [r1, #28]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800bf00:	684b      	ldr	r3, [r1, #4]
 800bf02:	4810      	ldr	r0, [pc, #64]	; (800bf44 <vTaskSwitchContext+0x58>)
 800bf04:	002a      	movs	r2, r5
 800bf06:	435a      	muls	r2, r3
 800bf08:	1814      	adds	r4, r2, r0
 800bf0a:	6826      	ldr	r6, [r4, #0]
 800bf0c:	2e00      	cmp	r6, #0
 800bf0e:	d011      	beq.n	800bf34 <vTaskSwitchContext+0x48>
 800bf10:	6865      	ldr	r5, [r4, #4]
 800bf12:	3208      	adds	r2, #8
 800bf14:	686d      	ldr	r5, [r5, #4]
 800bf16:	1812      	adds	r2, r2, r0
 800bf18:	6065      	str	r5, [r4, #4]
 800bf1a:	4295      	cmp	r5, r2
 800bf1c:	d101      	bne.n	800bf22 <vTaskSwitchContext+0x36>
 800bf1e:	686a      	ldr	r2, [r5, #4]
 800bf20:	6062      	str	r2, [r4, #4]
 800bf22:	2214      	movs	r2, #20
 800bf24:	435a      	muls	r2, r3
 800bf26:	1880      	adds	r0, r0, r2
 800bf28:	6842      	ldr	r2, [r0, #4]
 800bf2a:	68d0      	ldr	r0, [r2, #12]
 800bf2c:	4a06      	ldr	r2, [pc, #24]	; (800bf48 <vTaskSwitchContext+0x5c>)
 800bf2e:	60d0      	str	r0, [r2, #12]
 800bf30:	604b      	str	r3, [r1, #4]
}
 800bf32:	e7e2      	b.n	800befa <vTaskSwitchContext+0xe>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800bf34:	2b00      	cmp	r3, #0
 800bf36:	d101      	bne.n	800bf3c <vTaskSwitchContext+0x50>
 800bf38:	b672      	cpsid	i
 800bf3a:	e7fe      	b.n	800bf3a <vTaskSwitchContext+0x4e>
 800bf3c:	3b01      	subs	r3, #1
 800bf3e:	e7e1      	b.n	800bf04 <vTaskSwitchContext+0x18>
 800bf40:	20000468 	.word	0x20000468
 800bf44:	20000488 	.word	0x20000488
 800bf48:	200003e8 	.word	0x200003e8

0800bf4c <vTaskPlaceOnEventList>:
{
 800bf4c:	b510      	push	{r4, lr}
 800bf4e:	000c      	movs	r4, r1
	configASSERT( pxEventList );
 800bf50:	2800      	cmp	r0, #0
 800bf52:	d101      	bne.n	800bf58 <vTaskPlaceOnEventList+0xc>
 800bf54:	b672      	cpsid	i
 800bf56:	e7fe      	b.n	800bf56 <vTaskPlaceOnEventList+0xa>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800bf58:	4b04      	ldr	r3, [pc, #16]	; (800bf6c <vTaskPlaceOnEventList+0x20>)
 800bf5a:	68d9      	ldr	r1, [r3, #12]
 800bf5c:	3118      	adds	r1, #24
 800bf5e:	f7ff fad1 	bl	800b504 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800bf62:	2101      	movs	r1, #1
 800bf64:	0020      	movs	r0, r4
 800bf66:	f7ff fd6b 	bl	800ba40 <prvAddCurrentTaskToDelayedList>
}
 800bf6a:	bd10      	pop	{r4, pc}
 800bf6c:	200003e8 	.word	0x200003e8

0800bf70 <xTaskRemoveFromEventList>:
{
 800bf70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800bf72:	68c3      	ldr	r3, [r0, #12]
 800bf74:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 800bf76:	2c00      	cmp	r4, #0
 800bf78:	d101      	bne.n	800bf7e <xTaskRemoveFromEventList+0xe>
 800bf7a:	b672      	cpsid	i
 800bf7c:	e7fe      	b.n	800bf7c <xTaskRemoveFromEventList+0xc>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800bf7e:	0027      	movs	r7, r4
 800bf80:	3718      	adds	r7, #24
 800bf82:	0038      	movs	r0, r7
 800bf84:	f7ff fad5 	bl	800b532 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800bf88:	4d10      	ldr	r5, [pc, #64]	; (800bfcc <xTaskRemoveFromEventList+0x5c>)
 800bf8a:	4e11      	ldr	r6, [pc, #68]	; (800bfd0 <xTaskRemoveFromEventList+0x60>)
 800bf8c:	68eb      	ldr	r3, [r5, #12]
 800bf8e:	2b00      	cmp	r3, #0
 800bf90:	d118      	bne.n	800bfc4 <xTaskRemoveFromEventList+0x54>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800bf92:	1d27      	adds	r7, r4, #4
 800bf94:	0038      	movs	r0, r7
 800bf96:	f7ff facc 	bl	800b532 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800bf9a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800bf9c:	686a      	ldr	r2, [r5, #4]
 800bf9e:	4293      	cmp	r3, r2
 800bfa0:	d900      	bls.n	800bfa4 <xTaskRemoveFromEventList+0x34>
 800bfa2:	606b      	str	r3, [r5, #4]
 800bfa4:	2014      	movs	r0, #20
 800bfa6:	4358      	muls	r0, r3
 800bfa8:	4b0a      	ldr	r3, [pc, #40]	; (800bfd4 <xTaskRemoveFromEventList+0x64>)
 800bfaa:	18c0      	adds	r0, r0, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800bfac:	0039      	movs	r1, r7
 800bfae:	f7ff fa9d 	bl	800b4ec <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800bfb2:	68f3      	ldr	r3, [r6, #12]
 800bfb4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800bfb6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		xReturn = pdFALSE;
 800bfb8:	2000      	movs	r0, #0
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800bfba:	429a      	cmp	r2, r3
 800bfbc:	d901      	bls.n	800bfc2 <xTaskRemoveFromEventList+0x52>
		xYieldPending = pdTRUE;
 800bfbe:	3001      	adds	r0, #1
 800bfc0:	61e8      	str	r0, [r5, #28]
}
 800bfc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800bfc4:	0030      	movs	r0, r6
 800bfc6:	3054      	adds	r0, #84	; 0x54
 800bfc8:	e7f0      	b.n	800bfac <xTaskRemoveFromEventList+0x3c>
 800bfca:	46c0      	nop			; (mov r8, r8)
 800bfcc:	20000468 	.word	0x20000468
 800bfd0:	200003e8 	.word	0x200003e8
 800bfd4:	20000488 	.word	0x20000488

0800bfd8 <vTaskSetTimeOutState>:
	configASSERT( pxTimeOut );
 800bfd8:	2800      	cmp	r0, #0
 800bfda:	d101      	bne.n	800bfe0 <vTaskSetTimeOutState+0x8>
 800bfdc:	b672      	cpsid	i
 800bfde:	e7fe      	b.n	800bfde <vTaskSetTimeOutState+0x6>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800bfe0:	4b03      	ldr	r3, [pc, #12]	; (800bff0 <vTaskSetTimeOutState+0x18>)
 800bfe2:	695b      	ldr	r3, [r3, #20]
 800bfe4:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800bfe6:	4b03      	ldr	r3, [pc, #12]	; (800bff4 <vTaskSetTimeOutState+0x1c>)
 800bfe8:	689b      	ldr	r3, [r3, #8]
 800bfea:	6043      	str	r3, [r0, #4]
}
 800bfec:	4770      	bx	lr
 800bfee:	46c0      	nop			; (mov r8, r8)
 800bff0:	20000468 	.word	0x20000468
 800bff4:	200003e8 	.word	0x200003e8

0800bff8 <xTaskCheckForTimeOut>:
{
 800bff8:	b570      	push	{r4, r5, r6, lr}
 800bffa:	0004      	movs	r4, r0
 800bffc:	000d      	movs	r5, r1
	configASSERT( pxTimeOut );
 800bffe:	2800      	cmp	r0, #0
 800c000:	d101      	bne.n	800c006 <xTaskCheckForTimeOut+0xe>
 800c002:	b672      	cpsid	i
 800c004:	e7fe      	b.n	800c004 <xTaskCheckForTimeOut+0xc>
	configASSERT( pxTicksToWait );
 800c006:	2900      	cmp	r1, #0
 800c008:	d101      	bne.n	800c00e <xTaskCheckForTimeOut+0x16>
 800c00a:	b672      	cpsid	i
 800c00c:	e7fe      	b.n	800c00c <xTaskCheckForTimeOut+0x14>
	taskENTER_CRITICAL();
 800c00e:	f000 f927 	bl	800c260 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 800c012:	4b0f      	ldr	r3, [pc, #60]	; (800c050 <xTaskCheckForTimeOut+0x58>)
				xReturn = pdFALSE;
 800c014:	2600      	movs	r6, #0
		const TickType_t xConstTickCount = xTickCount;
 800c016:	6899      	ldr	r1, [r3, #8]
			if( *pxTicksToWait == portMAX_DELAY )
 800c018:	682b      	ldr	r3, [r5, #0]
 800c01a:	1c5a      	adds	r2, r3, #1
 800c01c:	d013      	beq.n	800c046 <xTaskCheckForTimeOut+0x4e>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800c01e:	4a0d      	ldr	r2, [pc, #52]	; (800c054 <xTaskCheckForTimeOut+0x5c>)
 800c020:	6826      	ldr	r6, [r4, #0]
 800c022:	6950      	ldr	r0, [r2, #20]
 800c024:	6862      	ldr	r2, [r4, #4]
 800c026:	4286      	cmp	r6, r0
 800c028:	d002      	beq.n	800c030 <xTaskCheckForTimeOut+0x38>
			xReturn = pdTRUE;
 800c02a:	2601      	movs	r6, #1
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800c02c:	4291      	cmp	r1, r2
 800c02e:	d20a      	bcs.n	800c046 <xTaskCheckForTimeOut+0x4e>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800c030:	1a88      	subs	r0, r1, r2
			xReturn = pdTRUE;
 800c032:	2601      	movs	r6, #1
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800c034:	4283      	cmp	r3, r0
 800c036:	d906      	bls.n	800c046 <xTaskCheckForTimeOut+0x4e>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 800c038:	1a5b      	subs	r3, r3, r1
 800c03a:	189b      	adds	r3, r3, r2
 800c03c:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 800c03e:	0020      	movs	r0, r4
 800c040:	f7ff ffca 	bl	800bfd8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 800c044:	2600      	movs	r6, #0
	taskEXIT_CRITICAL();
 800c046:	f000 f917 	bl	800c278 <vPortExitCritical>
}
 800c04a:	0030      	movs	r0, r6
 800c04c:	bd70      	pop	{r4, r5, r6, pc}
 800c04e:	46c0      	nop			; (mov r8, r8)
 800c050:	200003e8 	.word	0x200003e8
 800c054:	20000468 	.word	0x20000468

0800c058 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 800c058:	2201      	movs	r2, #1
 800c05a:	4b01      	ldr	r3, [pc, #4]	; (800c060 <vTaskMissedYield+0x8>)
 800c05c:	61da      	str	r2, [r3, #28]
}
 800c05e:	4770      	bx	lr
 800c060:	20000468 	.word	0x20000468

0800c064 <prvInsertBlockIntoFreeList>:
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800c064:	4b0f      	ldr	r3, [pc, #60]	; (800c0a4 <prvInsertBlockIntoFreeList+0x40>)
{
 800c066:	b530      	push	{r4, r5, lr}
 800c068:	001d      	movs	r5, r3
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800c06a:	681a      	ldr	r2, [r3, #0]
 800c06c:	4282      	cmp	r2, r0
 800c06e:	d317      	bcc.n	800c0a0 <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800c070:	685c      	ldr	r4, [r3, #4]
 800c072:	1919      	adds	r1, r3, r4
 800c074:	4288      	cmp	r0, r1
 800c076:	d103      	bne.n	800c080 <prvInsertBlockIntoFreeList+0x1c>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800c078:	6841      	ldr	r1, [r0, #4]
 800c07a:	0018      	movs	r0, r3
 800c07c:	1909      	adds	r1, r1, r4
 800c07e:	6059      	str	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800c080:	6841      	ldr	r1, [r0, #4]
 800c082:	1844      	adds	r4, r0, r1
 800c084:	42a2      	cmp	r2, r4
 800c086:	d106      	bne.n	800c096 <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800c088:	68ac      	ldr	r4, [r5, #8]
 800c08a:	42a2      	cmp	r2, r4
 800c08c:	d003      	beq.n	800c096 <prvInsertBlockIntoFreeList+0x32>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800c08e:	6854      	ldr	r4, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800c090:	6812      	ldr	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800c092:	1861      	adds	r1, r4, r1
 800c094:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 800c096:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 800c098:	4298      	cmp	r0, r3
 800c09a:	d000      	beq.n	800c09e <prvInsertBlockIntoFreeList+0x3a>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800c09c:	6018      	str	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800c09e:	bd30      	pop	{r4, r5, pc}
 800c0a0:	0013      	movs	r3, r2
 800c0a2:	e7e2      	b.n	800c06a <prvInsertBlockIntoFreeList+0x6>
 800c0a4:	20000514 	.word	0x20000514

0800c0a8 <pvPortMalloc>:
{
 800c0a8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800c0aa:	0005      	movs	r5, r0
	vTaskSuspendAll();
 800c0ac:	f7ff fe08 	bl	800bcc0 <vTaskSuspendAll>
		if( pxEnd == NULL )
 800c0b0:	4c33      	ldr	r4, [pc, #204]	; (800c180 <pvPortMalloc+0xd8>)
 800c0b2:	68a3      	ldr	r3, [r4, #8]
 800c0b4:	2b00      	cmp	r3, #0
 800c0b6:	d11a      	bne.n	800c0ee <pvPortMalloc+0x46>
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800c0b8:	2107      	movs	r1, #7
	uxAddress = ( size_t ) ucHeap;
 800c0ba:	4a32      	ldr	r2, [pc, #200]	; (800c184 <pvPortMalloc+0xdc>)
 800c0bc:	4b32      	ldr	r3, [pc, #200]	; (800c188 <pvPortMalloc+0xe0>)
 800c0be:	18d3      	adds	r3, r2, r3
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800c0c0:	420a      	tst	r2, r1
 800c0c2:	d03c      	beq.n	800c13e <pvPortMalloc+0x96>
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800c0c4:	1852      	adds	r2, r2, r1
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800c0c6:	438a      	bics	r2, r1
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 800c0c8:	1a9b      	subs	r3, r3, r2
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800c0ca:	2007      	movs	r0, #7
	xStart.xBlockSize = ( size_t ) 0;
 800c0cc:	2100      	movs	r1, #0
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 800c0ce:	18d3      	adds	r3, r2, r3
	uxAddress -= xHeapStructSize;
 800c0d0:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800c0d2:	4383      	bics	r3, r0
	xStart.xBlockSize = ( size_t ) 0;
 800c0d4:	6061      	str	r1, [r4, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800c0d6:	6022      	str	r2, [r4, #0]
	pxEnd->xBlockSize = 0;
 800c0d8:	6059      	str	r1, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 800c0da:	6019      	str	r1, [r3, #0]
	pxEnd = ( void * ) uxAddress;
 800c0dc:	60a3      	str	r3, [r4, #8]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800c0de:	1a99      	subs	r1, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 800c0e0:	6013      	str	r3, [r2, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800c0e2:	2380      	movs	r3, #128	; 0x80
 800c0e4:	061b      	lsls	r3, r3, #24
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800c0e6:	6051      	str	r1, [r2, #4]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800c0e8:	60e1      	str	r1, [r4, #12]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800c0ea:	6121      	str	r1, [r4, #16]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800c0ec:	6163      	str	r3, [r4, #20]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800c0ee:	6967      	ldr	r7, [r4, #20]
 800c0f0:	423d      	tst	r5, r7
 800c0f2:	d140      	bne.n	800c176 <pvPortMalloc+0xce>
			if( xWantedSize > 0 )
 800c0f4:	2d00      	cmp	r5, #0
 800c0f6:	d03e      	beq.n	800c176 <pvPortMalloc+0xce>
				xWantedSize += xHeapStructSize;
 800c0f8:	002b      	movs	r3, r5
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800c0fa:	2207      	movs	r2, #7
				xWantedSize += xHeapStructSize;
 800c0fc:	3308      	adds	r3, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800c0fe:	4213      	tst	r3, r2
 800c100:	d001      	beq.n	800c106 <pvPortMalloc+0x5e>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800c102:	4393      	bics	r3, r2
 800c104:	3308      	adds	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 800c106:	2b00      	cmp	r3, #0
 800c108:	d035      	beq.n	800c176 <pvPortMalloc+0xce>
 800c10a:	6926      	ldr	r6, [r4, #16]
 800c10c:	429e      	cmp	r6, r3
 800c10e:	d332      	bcc.n	800c176 <pvPortMalloc+0xce>
				pxPreviousBlock = &xStart;
 800c110:	0021      	movs	r1, r4
				pxBlock = xStart.pxNextFreeBlock;
 800c112:	6825      	ldr	r5, [r4, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800c114:	686a      	ldr	r2, [r5, #4]
 800c116:	429a      	cmp	r2, r3
 800c118:	d202      	bcs.n	800c120 <pvPortMalloc+0x78>
 800c11a:	6828      	ldr	r0, [r5, #0]
 800c11c:	2800      	cmp	r0, #0
 800c11e:	d110      	bne.n	800c142 <pvPortMalloc+0x9a>
				if( pxBlock != pxEnd )
 800c120:	68a0      	ldr	r0, [r4, #8]
 800c122:	42a8      	cmp	r0, r5
 800c124:	d027      	beq.n	800c176 <pvPortMalloc+0xce>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c126:	6808      	ldr	r0, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800c128:	1ad2      	subs	r2, r2, r3
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c12a:	9001      	str	r0, [sp, #4]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 800c12c:	6828      	ldr	r0, [r5, #0]
 800c12e:	6008      	str	r0, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800c130:	2a10      	cmp	r2, #16
 800c132:	d90d      	bls.n	800c150 <pvPortMalloc+0xa8>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800c134:	18e8      	adds	r0, r5, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 800c136:	0741      	lsls	r1, r0, #29
 800c138:	d006      	beq.n	800c148 <pvPortMalloc+0xa0>
 800c13a:	b672      	cpsid	i
 800c13c:	e7fe      	b.n	800c13c <pvPortMalloc+0x94>
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 800c13e:	4b12      	ldr	r3, [pc, #72]	; (800c188 <pvPortMalloc+0xe0>)
 800c140:	e7c3      	b.n	800c0ca <pvPortMalloc+0x22>
 800c142:	0029      	movs	r1, r5
 800c144:	0005      	movs	r5, r0
 800c146:	e7e5      	b.n	800c114 <pvPortMalloc+0x6c>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 800c148:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 800c14a:	606b      	str	r3, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 800c14c:	f7ff ff8a 	bl	800c064 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800c150:	686b      	ldr	r3, [r5, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800c152:	68e2      	ldr	r2, [r4, #12]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800c154:	1af6      	subs	r6, r6, r3
 800c156:	6126      	str	r6, [r4, #16]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800c158:	4296      	cmp	r6, r2
 800c15a:	d200      	bcs.n	800c15e <pvPortMalloc+0xb6>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 800c15c:	60e6      	str	r6, [r4, #12]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800c15e:	431f      	orrs	r7, r3
					pxBlock->pxNextFreeBlock = NULL;
 800c160:	2300      	movs	r3, #0
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c162:	9c01      	ldr	r4, [sp, #4]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800c164:	606f      	str	r7, [r5, #4]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c166:	3408      	adds	r4, #8
					pxBlock->pxNextFreeBlock = NULL;
 800c168:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 800c16a:	f7ff fe1d 	bl	800bda8 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 800c16e:	0763      	lsls	r3, r4, #29
 800c170:	d003      	beq.n	800c17a <pvPortMalloc+0xd2>
 800c172:	b672      	cpsid	i
 800c174:	e7fe      	b.n	800c174 <pvPortMalloc+0xcc>
void *pvReturn = NULL;
 800c176:	2400      	movs	r4, #0
 800c178:	e7f7      	b.n	800c16a <pvPortMalloc+0xc2>
}
 800c17a:	0020      	movs	r0, r4
 800c17c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800c17e:	46c0      	nop			; (mov r8, r8)
 800c180:	20000514 	.word	0x20000514
 800c184:	2000052c 	.word	0x2000052c
 800c188:	00001450 	.word	0x00001450

0800c18c <vPortFree>:
{
 800c18c:	b570      	push	{r4, r5, r6, lr}
	if( pv != NULL )
 800c18e:	2800      	cmp	r0, #0
 800c190:	d01a      	beq.n	800c1c8 <vPortFree+0x3c>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800c192:	4d0e      	ldr	r5, [pc, #56]	; (800c1cc <vPortFree+0x40>)
 800c194:	3808      	subs	r0, #8
 800c196:	6843      	ldr	r3, [r0, #4]
 800c198:	696a      	ldr	r2, [r5, #20]
 800c19a:	0004      	movs	r4, r0
 800c19c:	421a      	tst	r2, r3
 800c19e:	d101      	bne.n	800c1a4 <vPortFree+0x18>
 800c1a0:	b672      	cpsid	i
 800c1a2:	e7fe      	b.n	800c1a2 <vPortFree+0x16>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800c1a4:	6801      	ldr	r1, [r0, #0]
 800c1a6:	2900      	cmp	r1, #0
 800c1a8:	d001      	beq.n	800c1ae <vPortFree+0x22>
 800c1aa:	b672      	cpsid	i
 800c1ac:	e7fe      	b.n	800c1ac <vPortFree+0x20>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800c1ae:	4393      	bics	r3, r2
 800c1b0:	6043      	str	r3, [r0, #4]
				vTaskSuspendAll();
 800c1b2:	f7ff fd85 	bl	800bcc0 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 800c1b6:	692a      	ldr	r2, [r5, #16]
 800c1b8:	6863      	ldr	r3, [r4, #4]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800c1ba:	0020      	movs	r0, r4
					xFreeBytesRemaining += pxLink->xBlockSize;
 800c1bc:	189b      	adds	r3, r3, r2
 800c1be:	612b      	str	r3, [r5, #16]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800c1c0:	f7ff ff50 	bl	800c064 <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 800c1c4:	f7ff fdf0 	bl	800bda8 <xTaskResumeAll>
}
 800c1c8:	bd70      	pop	{r4, r5, r6, pc}
 800c1ca:	46c0      	nop			; (mov r8, r8)
 800c1cc:	20000514 	.word	0x20000514

0800c1d0 <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800c1d0:	4b03      	ldr	r3, [pc, #12]	; (800c1e0 <prvTaskExitError+0x10>)
 800c1d2:	681b      	ldr	r3, [r3, #0]
 800c1d4:	3301      	adds	r3, #1
 800c1d6:	d001      	beq.n	800c1dc <prvTaskExitError+0xc>
 800c1d8:	b672      	cpsid	i
 800c1da:	e7fe      	b.n	800c1da <prvTaskExitError+0xa>
	portDISABLE_INTERRUPTS();
 800c1dc:	b672      	cpsid	i
 800c1de:	e7fe      	b.n	800c1de <prvTaskExitError+0xe>
 800c1e0:	20000238 	.word	0x20000238
	...

0800c1f0 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
 800c1f0:	4a0b      	ldr	r2, [pc, #44]	; (800c220 <pxCurrentTCBConst2>)
 800c1f2:	6813      	ldr	r3, [r2, #0]
 800c1f4:	6818      	ldr	r0, [r3, #0]
 800c1f6:	3020      	adds	r0, #32
 800c1f8:	f380 8809 	msr	PSP, r0
 800c1fc:	2002      	movs	r0, #2
 800c1fe:	f380 8814 	msr	CONTROL, r0
 800c202:	f3bf 8f6f 	isb	sy
 800c206:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
 800c208:	46ae      	mov	lr, r5
 800c20a:	bc08      	pop	{r3}
 800c20c:	bc04      	pop	{r2}
 800c20e:	b662      	cpsie	i
 800c210:	4718      	bx	r3
 800c212:	46c0      	nop			; (mov r8, r8)
 800c214:	46c0      	nop			; (mov r8, r8)
 800c216:	46c0      	nop			; (mov r8, r8)
 800c218:	46c0      	nop			; (mov r8, r8)
 800c21a:	46c0      	nop			; (mov r8, r8)
 800c21c:	46c0      	nop			; (mov r8, r8)
 800c21e:	46c0      	nop			; (mov r8, r8)

0800c220 <pxCurrentTCBConst2>:
 800c220:	200003f4 	.word	0x200003f4

0800c224 <pxPortInitialiseStack>:
{
 800c224:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800c226:	2480      	movs	r4, #128	; 0x80
 800c228:	1f03      	subs	r3, r0, #4
 800c22a:	0464      	lsls	r4, r4, #17
 800c22c:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 800c22e:	3b04      	subs	r3, #4
 800c230:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 800c232:	4903      	ldr	r1, [pc, #12]	; (800c240 <pxPortInitialiseStack+0x1c>)
 800c234:	3b04      	subs	r3, #4
 800c236:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800c238:	3b14      	subs	r3, #20
	pxTopOfStack -= 8; /* R11..R4. */
 800c23a:	3840      	subs	r0, #64	; 0x40
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800c23c:	601a      	str	r2, [r3, #0]
}
 800c23e:	bd10      	pop	{r4, pc}
 800c240:	0800c1d1 	.word	0x0800c1d1

0800c244 <SVC_Handler>:
}
 800c244:	4770      	bx	lr
	...

0800c248 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
 800c248:	2280      	movs	r2, #128	; 0x80
 800c24a:	4b04      	ldr	r3, [pc, #16]	; (800c25c <vPortYield+0x14>)
 800c24c:	0552      	lsls	r2, r2, #21
 800c24e:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 800c250:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800c254:	f3bf 8f6f 	isb	sy
}
 800c258:	4770      	bx	lr
 800c25a:	46c0      	nop			; (mov r8, r8)
 800c25c:	e000ed04 	.word	0xe000ed04

0800c260 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
 800c260:	b672      	cpsid	i
    uxCriticalNesting++;
 800c262:	4a04      	ldr	r2, [pc, #16]	; (800c274 <vPortEnterCritical+0x14>)
 800c264:	6813      	ldr	r3, [r2, #0]
 800c266:	3301      	adds	r3, #1
 800c268:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
 800c26a:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800c26e:	f3bf 8f6f 	isb	sy
}
 800c272:	4770      	bx	lr
 800c274:	20000238 	.word	0x20000238

0800c278 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
 800c278:	4a05      	ldr	r2, [pc, #20]	; (800c290 <vPortExitCritical+0x18>)
 800c27a:	6813      	ldr	r3, [r2, #0]
 800c27c:	2b00      	cmp	r3, #0
 800c27e:	d101      	bne.n	800c284 <vPortExitCritical+0xc>
 800c280:	b672      	cpsid	i
 800c282:	e7fe      	b.n	800c282 <vPortExitCritical+0xa>
    uxCriticalNesting--;
 800c284:	3b01      	subs	r3, #1
 800c286:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
 800c288:	2b00      	cmp	r3, #0
 800c28a:	d100      	bne.n	800c28e <vPortExitCritical+0x16>
    {
        portENABLE_INTERRUPTS();
 800c28c:	b662      	cpsie	i
    }
}
 800c28e:	4770      	bx	lr
 800c290:	20000238 	.word	0x20000238

0800c294 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
	__asm volatile(
 800c294:	f3ef 8010 	mrs	r0, PRIMASK
 800c298:	b672      	cpsid	i
 800c29a:	4770      	bx	lr
					" bx lr				  "
				  );

	/* To avoid compiler warnings.  This line will never be reached. */
	return 0;
}
 800c29c:	2000      	movs	r0, #0

0800c29e <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( uint32_t ulMask )
{
	__asm volatile(
 800c29e:	f380 8810 	msr	PRIMASK, r0
 800c2a2:	4770      	bx	lr
	...

0800c2b0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 800c2b0:	f3ef 8009 	mrs	r0, PSP
 800c2b4:	4b0e      	ldr	r3, [pc, #56]	; (800c2f0 <pxCurrentTCBConst>)
 800c2b6:	681a      	ldr	r2, [r3, #0]
 800c2b8:	3820      	subs	r0, #32
 800c2ba:	6010      	str	r0, [r2, #0]
 800c2bc:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800c2be:	4644      	mov	r4, r8
 800c2c0:	464d      	mov	r5, r9
 800c2c2:	4656      	mov	r6, sl
 800c2c4:	465f      	mov	r7, fp
 800c2c6:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800c2c8:	b508      	push	{r3, lr}
 800c2ca:	b672      	cpsid	i
 800c2cc:	f7ff fe0e 	bl	800beec <vTaskSwitchContext>
 800c2d0:	b662      	cpsie	i
 800c2d2:	bc0c      	pop	{r2, r3}
 800c2d4:	6811      	ldr	r1, [r2, #0]
 800c2d6:	6808      	ldr	r0, [r1, #0]
 800c2d8:	3010      	adds	r0, #16
 800c2da:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800c2dc:	46a0      	mov	r8, r4
 800c2de:	46a9      	mov	r9, r5
 800c2e0:	46b2      	mov	sl, r6
 800c2e2:	46bb      	mov	fp, r7
 800c2e4:	f380 8809 	msr	PSP, r0
 800c2e8:	3820      	subs	r0, #32
 800c2ea:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800c2ec:	4718      	bx	r3
 800c2ee:	46c0      	nop			; (mov r8, r8)

0800c2f0 <pxCurrentTCBConst>:
 800c2f0:	200003f4 	.word	0x200003f4

0800c2f4 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 800c2f4:	b510      	push	{r4, lr}
uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 800c2f6:	f7ff ffcd 	bl	800c294 <ulSetInterruptMaskFromISR>
 800c2fa:	0004      	movs	r4, r0
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 800c2fc:	f7ff fcee 	bl	800bcdc <xTaskIncrementTick>
 800c300:	2800      	cmp	r0, #0
 800c302:	d003      	beq.n	800c30c <xPortSysTickHandler+0x18>
		{
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 800c304:	2280      	movs	r2, #128	; 0x80
 800c306:	4b03      	ldr	r3, [pc, #12]	; (800c314 <xPortSysTickHandler+0x20>)
 800c308:	0552      	lsls	r2, r2, #21
 800c30a:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 800c30c:	0020      	movs	r0, r4
 800c30e:	f7ff ffc6 	bl	800c29e <vClearInterruptMaskFromISR>
}
 800c312:	bd10      	pop	{r4, pc}
 800c314:	e000ed04 	.word	0xe000ed04

0800c318 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */
	/* Configure SysTick to interrupt at the requested rate. */

	portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800c318:	21fa      	movs	r1, #250	; 0xfa
 800c31a:	4b06      	ldr	r3, [pc, #24]	; (800c334 <vPortSetupTimerInterrupt+0x1c>)
{
 800c31c:	b510      	push	{r4, lr}
	portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800c31e:	6818      	ldr	r0, [r3, #0]
 800c320:	0089      	lsls	r1, r1, #2
 800c322:	f7f9 fb47 	bl	80059b4 <__udivsi3>
	portNVIC_SYSTICK_CTRL = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 800c326:	2207      	movs	r2, #7
	portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800c328:	4b03      	ldr	r3, [pc, #12]	; (800c338 <vPortSetupTimerInterrupt+0x20>)
 800c32a:	3801      	subs	r0, #1
 800c32c:	6018      	str	r0, [r3, #0]
	portNVIC_SYSTICK_CTRL = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 800c32e:	4b03      	ldr	r3, [pc, #12]	; (800c33c <vPortSetupTimerInterrupt+0x24>)
 800c330:	601a      	str	r2, [r3, #0]
}
 800c332:	bd10      	pop	{r4, pc}
 800c334:	20000030 	.word	0x20000030
 800c338:	e000e014 	.word	0xe000e014
 800c33c:	e000e010 	.word	0xe000e010

0800c340 <xPortStartScheduler>:
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 800c340:	22ff      	movs	r2, #255	; 0xff
 800c342:	4b0a      	ldr	r3, [pc, #40]	; (800c36c <xPortStartScheduler+0x2c>)
 800c344:	0412      	lsls	r2, r2, #16
 800c346:	6819      	ldr	r1, [r3, #0]
{
 800c348:	b510      	push	{r4, lr}
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 800c34a:	430a      	orrs	r2, r1
 800c34c:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 800c34e:	22ff      	movs	r2, #255	; 0xff
 800c350:	6819      	ldr	r1, [r3, #0]
 800c352:	0612      	lsls	r2, r2, #24
 800c354:	430a      	orrs	r2, r1
 800c356:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 800c358:	f7ff ffde 	bl	800c318 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 800c35c:	2200      	movs	r2, #0
 800c35e:	4b04      	ldr	r3, [pc, #16]	; (800c370 <xPortStartScheduler+0x30>)
 800c360:	601a      	str	r2, [r3, #0]
	vPortStartFirstTask();
 800c362:	f7ff ff45 	bl	800c1f0 <vPortStartFirstTask>
	prvTaskExitError();
 800c366:	f7ff ff33 	bl	800c1d0 <prvTaskExitError>
 800c36a:	46c0      	nop			; (mov r8, r8)
 800c36c:	e000ed20 	.word	0xe000ed20
 800c370:	20000238 	.word	0x20000238

0800c374 <Led_Init>:
/**
  * @brief This function performs an init of the LED manager.
  * @retval None
  */
void Led_Init()
{
 800c374:	2300      	movs	r3, #0
 800c376:	4a08      	ldr	r2, [pc, #32]	; (800c398 <Led_Init+0x24>)
 800c378:	b530      	push	{r4, r5, lr}
 800c37a:	0010      	movs	r0, r2
static inline void prvLedStatusInit(LED_BSP_TypeDef Index)
{
  configASSERT(LED_INDEX_IsValid(Index));

  Status[Index].Index = Index;
  Status[Index].Mode = LED_MODE_OFF;
 800c37c:	0019      	movs	r1, r3
  Status[Index].Period = LED_PERIOD_DEFAULT;
 800c37e:	2564      	movs	r5, #100	; 0x64
    LedOrder[i] = i;
 800c380:	4c06      	ldr	r4, [pc, #24]	; (800c39c <Led_Init+0x28>)
    prvLedStatusInit((LED_BSP_TypeDef)i);
 800c382:	7013      	strb	r3, [r2, #0]
    LedOrder[i] = i;
 800c384:	54e3      	strb	r3, [r4, r3]
 800c386:	3301      	adds	r3, #1
  Status[Index].Mode = LED_MODE_OFF;
 800c388:	7051      	strb	r1, [r2, #1]
  Status[Index].Period = LED_PERIOD_DEFAULT;
 800c38a:	8095      	strh	r5, [r2, #4]
  Status[Index].Count = 0;
 800c38c:	80d1      	strh	r1, [r2, #6]
 800c38e:	3208      	adds	r2, #8
  for(i=0; i<LED_INDEX_LEN; i++)
 800c390:	2b04      	cmp	r3, #4
 800c392:	d1f6      	bne.n	800c382 <Led_Init+0xe>
  GlobalCount = 0;
 800c394:	8401      	strh	r1, [r0, #32]
}
 800c396:	bd30      	pop	{r4, r5, pc}
 800c398:	2000197c 	.word	0x2000197c
 800c39c:	20001ce0 	.word	0x20001ce0

0800c3a0 <Led_Set>:
{
 800c3a0:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (!LED_INDEX_IsValid(Index) || 
 800c3a2:	b2c3      	uxtb	r3, r0
{
 800c3a4:	b089      	sub	sp, #36	; 0x24
 800c3a6:	0006      	movs	r6, r0
 800c3a8:	000d      	movs	r5, r1
  if (!LED_INDEX_IsValid(Index) || 
 800c3aa:	2b03      	cmp	r3, #3
 800c3ac:	d821      	bhi.n	800c3f2 <Led_Set+0x52>
 800c3ae:	2909      	cmp	r1, #9
 800c3b0:	d81f      	bhi.n	800c3f2 <Led_Set+0x52>
      !LED_MODE_IsValid(Mode) || 
 800c3b2:	2902      	cmp	r1, #2
 800c3b4:	d105      	bne.n	800c3c2 <Led_Set+0x22>
      !LED_PERIOD_IsValid(Mode, Period) )
 800c3b6:	0013      	movs	r3, r2
 800c3b8:	491e      	ldr	r1, [pc, #120]	; (800c434 <Led_Set+0x94>)
 800c3ba:	3b0a      	subs	r3, #10
 800c3bc:	b29b      	uxth	r3, r3
 800c3be:	428b      	cmp	r3, r1
 800c3c0:	d817      	bhi.n	800c3f2 <Led_Set+0x52>
  pStatus->Count = 0;
 800c3c2:	2100      	movs	r1, #0
  pStatus->Mode = Mode;
 800c3c4:	4c1c      	ldr	r4, [pc, #112]	; (800c438 <Led_Set+0x98>)
 800c3c6:	00f3      	lsls	r3, r6, #3
 800c3c8:	9301      	str	r3, [sp, #4]
  switch(Mode)
 800c3ca:	1e68      	subs	r0, r5, #1
  pStatus->Mode = Mode;
 800c3cc:	18e3      	adds	r3, r4, r3
 800c3ce:	705d      	strb	r5, [r3, #1]
  pStatus->Period = Period;
 800c3d0:	809a      	strh	r2, [r3, #4]
  pStatus->Count = 0;
 800c3d2:	80d9      	strh	r1, [r3, #6]
  switch(Mode)
 800c3d4:	2808      	cmp	r0, #8
 800c3d6:	d829      	bhi.n	800c42c <Led_Set+0x8c>
 800c3d8:	f7f9 fae2 	bl	80059a0 <__gnu_thumb1_case_uqi>
 800c3dc:	10100d05 	.word	0x10100d05
 800c3e0:	10101010 	.word	0x10101010
 800c3e4:	10          	.byte	0x10
 800c3e5:	00          	.byte	0x00
 * @brief  Turn on a LED.
 * @param  cIndex: State Index
 */
void prvLedOn(LED_BSP_TypeDef Index)
{
  USBPD_BSP_LED_On(Index);
 800c3e6:	0030      	movs	r0, r6
 800c3e8:	f7fa fd7a 	bl	8006ee0 <USBPD_BSP_LED_On>
  pStatus->ModePrevious = Mode;
 800c3ec:	9b01      	ldr	r3, [sp, #4]
 800c3ee:	18e4      	adds	r4, r4, r3
 800c3f0:	70a5      	strb	r5, [r4, #2]
}
 800c3f2:	b009      	add	sp, #36	; 0x24
 800c3f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    pStatus->Count = pStatus->Period;
 800c3f6:	00f3      	lsls	r3, r6, #3
 800c3f8:	18e3      	adds	r3, r4, r3
 800c3fa:	80da      	strh	r2, [r3, #6]
    if (xLedThreadId == NULL)
 800c3fc:	4b0f      	ldr	r3, [pc, #60]	; (800c43c <Led_Set+0x9c>)
 800c3fe:	681b      	ldr	r3, [r3, #0]
 800c400:	469c      	mov	ip, r3
 800c402:	2b00      	cmp	r3, #0
 800c404:	d10d      	bne.n	800c422 <Led_Set+0x82>
      osThreadDef(LEDThread, prvLedThread, LED_THREAD_PRIORITY, 0, configMINIMAL_STACK_SIZE);
 800c406:	ab03      	add	r3, sp, #12
 800c408:	9300      	str	r3, [sp, #0]
 800c40a:	9a00      	ldr	r2, [sp, #0]
 800c40c:	4b0c      	ldr	r3, [pc, #48]	; (800c440 <Led_Set+0xa0>)
 800c40e:	cb83      	ldmia	r3!, {r0, r1, r7}
 800c410:	c283      	stmia	r2!, {r0, r1, r7}
 800c412:	cb03      	ldmia	r3!, {r0, r1}
 800c414:	c203      	stmia	r2!, {r0, r1}
      xLedThreadId = osThreadCreate(osThread(LEDThread), NULL);
 800c416:	4661      	mov	r1, ip
 800c418:	9800      	ldr	r0, [sp, #0]
 800c41a:	f7fe ffc8 	bl	800b3ae <osThreadCreate>
 800c41e:	4b07      	ldr	r3, [pc, #28]	; (800c43c <Led_Set+0x9c>)
 800c420:	6018      	str	r0, [r3, #0]
    if (pStatus->ModePrevious != Mode)
 800c422:	00f3      	lsls	r3, r6, #3
 800c424:	18e3      	adds	r3, r4, r3
 800c426:	789b      	ldrb	r3, [r3, #2]
 800c428:	42ab      	cmp	r3, r5
 800c42a:	d0df      	beq.n	800c3ec <Led_Set+0x4c>
 * @brief  Turn off a LED.
 * @param  cIndex: State Index
 */
void prvLedOff(LED_BSP_TypeDef Index)
{
  USBPD_BSP_LED_Off(Index);
 800c42c:	0030      	movs	r0, r6
 800c42e:	f7fa fd65 	bl	8006efc <USBPD_BSP_LED_Off>
 800c432:	e7db      	b.n	800c3ec <Led_Set+0x4c>
 800c434:	00002706 	.word	0x00002706
 800c438:	2000197c 	.word	0x2000197c
 800c43c:	20001ce4 	.word	0x20001ce4
 800c440:	0800c84c 	.word	0x0800c84c

0800c444 <prvLedThread>:
{
 800c444:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    half_period = GlobalPeriod>>1;
 800c446:	2401      	movs	r4, #1
  osDelay(100);
 800c448:	2064      	movs	r0, #100	; 0x64
 800c44a:	f7fe ffce 	bl	800b3ea <osDelay>
    half_period = GlobalPeriod>>1;
 800c44e:	4f2c      	ldr	r7, [pc, #176]	; (800c500 <prvLedThread+0xbc>)
 800c450:	883d      	ldrh	r5, [r7, #0]
 800c452:	086d      	lsrs	r5, r5, #1
      if (LED_MODE_IsBlinking(pStatus->Mode))
 800c454:	4e2b      	ldr	r6, [pc, #172]	; (800c504 <prvLedThread+0xc0>)
 800c456:	00e3      	lsls	r3, r4, #3
 800c458:	3b07      	subs	r3, #7
 800c45a:	5cf0      	ldrb	r0, [r6, r3]
 800c45c:	1ec3      	subs	r3, r0, #3
 800c45e:	2b06      	cmp	r3, #6
 800c460:	d810      	bhi.n	800c484 <prvLedThread+0x40>
        switch(pStatus->Mode)
 800c462:	3804      	subs	r0, #4
 800c464:	8c33      	ldrh	r3, [r6, #32]
 800c466:	2805      	cmp	r0, #5
 800c468:	d804      	bhi.n	800c474 <prvLedThread+0x30>
 800c46a:	f7f9 fa99 	bl	80059a0 <__gnu_thumb1_case_uqi>
 800c46e:	1633      	.short	0x1633
 800c470:	3e383328 	.word	0x3e383328
          prvLed((LED_BSP_TypeDef)i, (GlobalMap >> GlobalCount) & 0x01);
 800c474:	6879      	ldr	r1, [r7, #4]
 * @brief  Turn on off a LED.
 * @param  cIndex: State Index
 */
void prvLed(LED_BSP_TypeDef Index, uint8_t Value)
{
  USBPD_BSP_LED_Set(Index, Value);
 800c476:	1e60      	subs	r0, r4, #1
          prvLed((LED_BSP_TypeDef)i, (GlobalMap >> GlobalCount) & 0x01);
 800c478:	40d9      	lsrs	r1, r3
  USBPD_BSP_LED_Set(Index, Value);
 800c47a:	2301      	movs	r3, #1
 800c47c:	b240      	sxtb	r0, r0
 800c47e:	4019      	ands	r1, r3
 800c480:	f7fa fd1e 	bl	8006ec0 <USBPD_BSP_LED_Set>
 800c484:	3401      	adds	r4, #1
    for(i=0; i<LED_INDEX_LEN; i++)
 800c486:	2c05      	cmp	r4, #5
 800c488:	d1e4      	bne.n	800c454 <prvLedThread+0x10>
    GlobalCount++;
 800c48a:	8c30      	ldrh	r0, [r6, #32]
    GlobalCount %= GlobalPeriod;
 800c48c:	8839      	ldrh	r1, [r7, #0]
    GlobalCount++;
 800c48e:	3001      	adds	r0, #1
    GlobalCount %= GlobalPeriod;
 800c490:	b280      	uxth	r0, r0
 800c492:	f7f9 fb15 	bl	8005ac0 <__aeabi_uidivmod>
 800c496:	8431      	strh	r1, [r6, #32]
 800c498:	e7d5      	b.n	800c446 <prvLedThread+0x2>
          if (GlobalCount == 0 || GlobalCount == 3) 
 800c49a:	2b00      	cmp	r3, #0
 800c49c:	d001      	beq.n	800c4a2 <prvLedThread+0x5e>
 800c49e:	2b03      	cmp	r3, #3
 800c4a0:	d104      	bne.n	800c4ac <prvLedThread+0x68>
  USBPD_BSP_LED_On(Index);
 800c4a2:	1e60      	subs	r0, r4, #1
 800c4a4:	b240      	sxtb	r0, r0
 800c4a6:	f7fa fd1b 	bl	8006ee0 <USBPD_BSP_LED_On>
 800c4aa:	e7eb      	b.n	800c484 <prvLedThread+0x40>
          else if (GlobalCount == 1 || GlobalCount == 4) 
 800c4ac:	2b01      	cmp	r3, #1
 800c4ae:	d001      	beq.n	800c4b4 <prvLedThread+0x70>
 800c4b0:	2b04      	cmp	r3, #4
 800c4b2:	d1e7      	bne.n	800c484 <prvLedThread+0x40>
  USBPD_BSP_LED_Off(Index);
 800c4b4:	1e60      	subs	r0, r4, #1
 800c4b6:	b240      	sxtb	r0, r0
 800c4b8:	f7fa fd20 	bl	8006efc <USBPD_BSP_LED_Off>
 800c4bc:	e7e2      	b.n	800c484 <prvLedThread+0x40>
          if (GlobalCount == 0 || GlobalCount == 4 || GlobalCount == 8) 
 800c4be:	001a      	movs	r2, r3
 800c4c0:	2104      	movs	r1, #4
 800c4c2:	438a      	bics	r2, r1
 800c4c4:	d0ed      	beq.n	800c4a2 <prvLedThread+0x5e>
 800c4c6:	2b08      	cmp	r3, #8
 800c4c8:	d0eb      	beq.n	800c4a2 <prvLedThread+0x5e>
          else if (GlobalCount == 2 || GlobalCount == 6 || GlobalCount == 10) 
 800c4ca:	2a02      	cmp	r2, #2
 800c4cc:	d0f2      	beq.n	800c4b4 <prvLedThread+0x70>
 800c4ce:	2b0a      	cmp	r3, #10
 800c4d0:	d1d8      	bne.n	800c484 <prvLedThread+0x40>
 800c4d2:	e7ef      	b.n	800c4b4 <prvLedThread+0x70>
          if (GlobalCount == 0) 
 800c4d4:	2b00      	cmp	r3, #0
 800c4d6:	d0e4      	beq.n	800c4a2 <prvLedThread+0x5e>
          else if (GlobalCount == 2) 
 800c4d8:	2b02      	cmp	r3, #2
 800c4da:	d1d3      	bne.n	800c484 <prvLedThread+0x40>
 800c4dc:	e7ea      	b.n	800c4b4 <prvLedThread+0x70>
          else if (GlobalCount == (half_period+2)) 
 800c4de:	1caa      	adds	r2, r5, #2
          if (GlobalCount == half_period) 
 800c4e0:	429d      	cmp	r5, r3
 800c4e2:	d0de      	beq.n	800c4a2 <prvLedThread+0x5e>
          else if (GlobalCount == (half_period+1) || GlobalCount == (half_period+4))
 800c4e4:	4293      	cmp	r3, r2
 800c4e6:	d1cd      	bne.n	800c484 <prvLedThread+0x40>
 800c4e8:	e7e4      	b.n	800c4b4 <prvLedThread+0x70>
          if (GlobalCount == half_period || GlobalCount == (half_period+3)) 
 800c4ea:	429d      	cmp	r5, r3
 800c4ec:	d0d9      	beq.n	800c4a2 <prvLedThread+0x5e>
 800c4ee:	1cea      	adds	r2, r5, #3
 800c4f0:	4293      	cmp	r3, r2
 800c4f2:	d0d6      	beq.n	800c4a2 <prvLedThread+0x5e>
          else if (GlobalCount == (half_period+1) || GlobalCount == (half_period+4))
 800c4f4:	1c6a      	adds	r2, r5, #1
 800c4f6:	4293      	cmp	r3, r2
 800c4f8:	d0dc      	beq.n	800c4b4 <prvLedThread+0x70>
 800c4fa:	1d2a      	adds	r2, r5, #4
 800c4fc:	e7f2      	b.n	800c4e4 <prvLedThread+0xa0>
 800c4fe:	46c0      	nop			; (mov r8, r8)
 800c500:	2000023c 	.word	0x2000023c
 800c504:	2000197c 	.word	0x2000197c

0800c508 <__aeabi_memclr>:
 800c508:	b510      	push	{r4, lr}
 800c50a:	2200      	movs	r2, #0
 800c50c:	f000 f801 	bl	800c512 <__aeabi_memset>
 800c510:	bd10      	pop	{r4, pc}

0800c512 <__aeabi_memset>:
 800c512:	0013      	movs	r3, r2
 800c514:	b510      	push	{r4, lr}
 800c516:	000a      	movs	r2, r1
 800c518:	0019      	movs	r1, r3
 800c51a:	f000 f838 	bl	800c58e <memset>
 800c51e:	bd10      	pop	{r4, pc}

0800c520 <__libc_init_array>:
 800c520:	b570      	push	{r4, r5, r6, lr}
 800c522:	2600      	movs	r6, #0
 800c524:	4d0c      	ldr	r5, [pc, #48]	; (800c558 <__libc_init_array+0x38>)
 800c526:	4c0d      	ldr	r4, [pc, #52]	; (800c55c <__libc_init_array+0x3c>)
 800c528:	1b64      	subs	r4, r4, r5
 800c52a:	10a4      	asrs	r4, r4, #2
 800c52c:	42a6      	cmp	r6, r4
 800c52e:	d109      	bne.n	800c544 <__libc_init_array+0x24>
 800c530:	2600      	movs	r6, #0
 800c532:	f000 f8b7 	bl	800c6a4 <_init>
 800c536:	4d0a      	ldr	r5, [pc, #40]	; (800c560 <__libc_init_array+0x40>)
 800c538:	4c0a      	ldr	r4, [pc, #40]	; (800c564 <__libc_init_array+0x44>)
 800c53a:	1b64      	subs	r4, r4, r5
 800c53c:	10a4      	asrs	r4, r4, #2
 800c53e:	42a6      	cmp	r6, r4
 800c540:	d105      	bne.n	800c54e <__libc_init_array+0x2e>
 800c542:	bd70      	pop	{r4, r5, r6, pc}
 800c544:	00b3      	lsls	r3, r6, #2
 800c546:	58eb      	ldr	r3, [r5, r3]
 800c548:	4798      	blx	r3
 800c54a:	3601      	adds	r6, #1
 800c54c:	e7ee      	b.n	800c52c <__libc_init_array+0xc>
 800c54e:	00b3      	lsls	r3, r6, #2
 800c550:	58eb      	ldr	r3, [r5, r3]
 800c552:	4798      	blx	r3
 800c554:	3601      	adds	r6, #1
 800c556:	e7f2      	b.n	800c53e <__libc_init_array+0x1e>
 800c558:	0800c888 	.word	0x0800c888
 800c55c:	0800c888 	.word	0x0800c888
 800c560:	0800c888 	.word	0x0800c888
 800c564:	0800c88c 	.word	0x0800c88c

0800c568 <malloc>:
 800c568:	b510      	push	{r4, lr}
 800c56a:	4b03      	ldr	r3, [pc, #12]	; (800c578 <malloc+0x10>)
 800c56c:	0001      	movs	r1, r0
 800c56e:	6818      	ldr	r0, [r3, #0]
 800c570:	f000 f816 	bl	800c5a0 <_malloc_r>
 800c574:	bd10      	pop	{r4, pc}
 800c576:	46c0      	nop			; (mov r8, r8)
 800c578:	20000244 	.word	0x20000244

0800c57c <memcpy>:
 800c57c:	2300      	movs	r3, #0
 800c57e:	b510      	push	{r4, lr}
 800c580:	429a      	cmp	r2, r3
 800c582:	d100      	bne.n	800c586 <memcpy+0xa>
 800c584:	bd10      	pop	{r4, pc}
 800c586:	5ccc      	ldrb	r4, [r1, r3]
 800c588:	54c4      	strb	r4, [r0, r3]
 800c58a:	3301      	adds	r3, #1
 800c58c:	e7f8      	b.n	800c580 <memcpy+0x4>

0800c58e <memset>:
 800c58e:	0003      	movs	r3, r0
 800c590:	1812      	adds	r2, r2, r0
 800c592:	4293      	cmp	r3, r2
 800c594:	d100      	bne.n	800c598 <memset+0xa>
 800c596:	4770      	bx	lr
 800c598:	7019      	strb	r1, [r3, #0]
 800c59a:	3301      	adds	r3, #1
 800c59c:	e7f9      	b.n	800c592 <memset+0x4>
	...

0800c5a0 <_malloc_r>:
 800c5a0:	2303      	movs	r3, #3
 800c5a2:	b570      	push	{r4, r5, r6, lr}
 800c5a4:	1ccd      	adds	r5, r1, #3
 800c5a6:	439d      	bics	r5, r3
 800c5a8:	3508      	adds	r5, #8
 800c5aa:	0006      	movs	r6, r0
 800c5ac:	2d0c      	cmp	r5, #12
 800c5ae:	d21e      	bcs.n	800c5ee <_malloc_r+0x4e>
 800c5b0:	250c      	movs	r5, #12
 800c5b2:	42a9      	cmp	r1, r5
 800c5b4:	d81d      	bhi.n	800c5f2 <_malloc_r+0x52>
 800c5b6:	0030      	movs	r0, r6
 800c5b8:	f000 f862 	bl	800c680 <__malloc_lock>
 800c5bc:	4a25      	ldr	r2, [pc, #148]	; (800c654 <_malloc_r+0xb4>)
 800c5be:	6814      	ldr	r4, [r2, #0]
 800c5c0:	0021      	movs	r1, r4
 800c5c2:	2900      	cmp	r1, #0
 800c5c4:	d119      	bne.n	800c5fa <_malloc_r+0x5a>
 800c5c6:	4c24      	ldr	r4, [pc, #144]	; (800c658 <_malloc_r+0xb8>)
 800c5c8:	6823      	ldr	r3, [r4, #0]
 800c5ca:	2b00      	cmp	r3, #0
 800c5cc:	d103      	bne.n	800c5d6 <_malloc_r+0x36>
 800c5ce:	0030      	movs	r0, r6
 800c5d0:	f000 f844 	bl	800c65c <_sbrk_r>
 800c5d4:	6020      	str	r0, [r4, #0]
 800c5d6:	0029      	movs	r1, r5
 800c5d8:	0030      	movs	r0, r6
 800c5da:	f000 f83f 	bl	800c65c <_sbrk_r>
 800c5de:	1c43      	adds	r3, r0, #1
 800c5e0:	d12b      	bne.n	800c63a <_malloc_r+0x9a>
 800c5e2:	230c      	movs	r3, #12
 800c5e4:	0030      	movs	r0, r6
 800c5e6:	6033      	str	r3, [r6, #0]
 800c5e8:	f000 f84b 	bl	800c682 <__malloc_unlock>
 800c5ec:	e003      	b.n	800c5f6 <_malloc_r+0x56>
 800c5ee:	2d00      	cmp	r5, #0
 800c5f0:	dadf      	bge.n	800c5b2 <_malloc_r+0x12>
 800c5f2:	230c      	movs	r3, #12
 800c5f4:	6033      	str	r3, [r6, #0]
 800c5f6:	2000      	movs	r0, #0
 800c5f8:	bd70      	pop	{r4, r5, r6, pc}
 800c5fa:	680b      	ldr	r3, [r1, #0]
 800c5fc:	1b5b      	subs	r3, r3, r5
 800c5fe:	d419      	bmi.n	800c634 <_malloc_r+0x94>
 800c600:	2b0b      	cmp	r3, #11
 800c602:	d903      	bls.n	800c60c <_malloc_r+0x6c>
 800c604:	600b      	str	r3, [r1, #0]
 800c606:	18cc      	adds	r4, r1, r3
 800c608:	6025      	str	r5, [r4, #0]
 800c60a:	e003      	b.n	800c614 <_malloc_r+0x74>
 800c60c:	684b      	ldr	r3, [r1, #4]
 800c60e:	428c      	cmp	r4, r1
 800c610:	d10d      	bne.n	800c62e <_malloc_r+0x8e>
 800c612:	6013      	str	r3, [r2, #0]
 800c614:	0030      	movs	r0, r6
 800c616:	f000 f834 	bl	800c682 <__malloc_unlock>
 800c61a:	0020      	movs	r0, r4
 800c61c:	2207      	movs	r2, #7
 800c61e:	300b      	adds	r0, #11
 800c620:	1d23      	adds	r3, r4, #4
 800c622:	4390      	bics	r0, r2
 800c624:	1ac3      	subs	r3, r0, r3
 800c626:	d0e7      	beq.n	800c5f8 <_malloc_r+0x58>
 800c628:	425a      	negs	r2, r3
 800c62a:	50e2      	str	r2, [r4, r3]
 800c62c:	e7e4      	b.n	800c5f8 <_malloc_r+0x58>
 800c62e:	6063      	str	r3, [r4, #4]
 800c630:	000c      	movs	r4, r1
 800c632:	e7ef      	b.n	800c614 <_malloc_r+0x74>
 800c634:	000c      	movs	r4, r1
 800c636:	6849      	ldr	r1, [r1, #4]
 800c638:	e7c3      	b.n	800c5c2 <_malloc_r+0x22>
 800c63a:	2303      	movs	r3, #3
 800c63c:	1cc4      	adds	r4, r0, #3
 800c63e:	439c      	bics	r4, r3
 800c640:	42a0      	cmp	r0, r4
 800c642:	d0e1      	beq.n	800c608 <_malloc_r+0x68>
 800c644:	1a21      	subs	r1, r4, r0
 800c646:	0030      	movs	r0, r6
 800c648:	f000 f808 	bl	800c65c <_sbrk_r>
 800c64c:	1c43      	adds	r3, r0, #1
 800c64e:	d1db      	bne.n	800c608 <_malloc_r+0x68>
 800c650:	e7c7      	b.n	800c5e2 <_malloc_r+0x42>
 800c652:	46c0      	nop			; (mov r8, r8)
 800c654:	200019cc 	.word	0x200019cc
 800c658:	200019d0 	.word	0x200019d0

0800c65c <_sbrk_r>:
 800c65c:	2300      	movs	r3, #0
 800c65e:	b570      	push	{r4, r5, r6, lr}
 800c660:	4c06      	ldr	r4, [pc, #24]	; (800c67c <_sbrk_r+0x20>)
 800c662:	0005      	movs	r5, r0
 800c664:	0008      	movs	r0, r1
 800c666:	6023      	str	r3, [r4, #0]
 800c668:	f000 f80c 	bl	800c684 <_sbrk>
 800c66c:	1c43      	adds	r3, r0, #1
 800c66e:	d103      	bne.n	800c678 <_sbrk_r+0x1c>
 800c670:	6823      	ldr	r3, [r4, #0]
 800c672:	2b00      	cmp	r3, #0
 800c674:	d000      	beq.n	800c678 <_sbrk_r+0x1c>
 800c676:	602b      	str	r3, [r5, #0]
 800c678:	bd70      	pop	{r4, r5, r6, pc}
 800c67a:	46c0      	nop			; (mov r8, r8)
 800c67c:	20001ce8 	.word	0x20001ce8

0800c680 <__malloc_lock>:
 800c680:	4770      	bx	lr

0800c682 <__malloc_unlock>:
 800c682:	4770      	bx	lr

0800c684 <_sbrk>:
 800c684:	4b05      	ldr	r3, [pc, #20]	; (800c69c <_sbrk+0x18>)
 800c686:	0002      	movs	r2, r0
 800c688:	6819      	ldr	r1, [r3, #0]
 800c68a:	2900      	cmp	r1, #0
 800c68c:	d101      	bne.n	800c692 <_sbrk+0xe>
 800c68e:	4904      	ldr	r1, [pc, #16]	; (800c6a0 <_sbrk+0x1c>)
 800c690:	6019      	str	r1, [r3, #0]
 800c692:	6818      	ldr	r0, [r3, #0]
 800c694:	1882      	adds	r2, r0, r2
 800c696:	601a      	str	r2, [r3, #0]
 800c698:	4770      	bx	lr
 800c69a:	46c0      	nop			; (mov r8, r8)
 800c69c:	200019d4 	.word	0x200019d4
 800c6a0:	20001cf0 	.word	0x20001cf0

0800c6a4 <_init>:
 800c6a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c6a6:	46c0      	nop			; (mov r8, r8)
 800c6a8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800c6aa:	bc08      	pop	{r3}
 800c6ac:	469e      	mov	lr, r3
 800c6ae:	4770      	bx	lr

0800c6b0 <_fini>:
 800c6b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c6b2:	46c0      	nop			; (mov r8, r8)
 800c6b4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800c6b6:	bc08      	pop	{r3}
 800c6b8:	469e      	mov	lr, r3
 800c6ba:	4770      	bx	lr
