
STM32F072RB-Nucleo_MB1303_Provider_PD30.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000cc1c  080000c0  080000c0  000100c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000020c  0800ccdc  0800ccdc  0001ccdc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  0800cee8  0800cee8  0001cee8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  0800ceec  0800ceec  0001ceec  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         000002a8  20000000  0800cef0  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00001b20  200002a8  0800d198  000202a8  2**2
                  ALLOC
  7 ._user_heap_stack 00000800  20001dc8  0800d198  00021dc8  2**0
                  ALLOC
  8 .ARM.attributes 0000002e  00000000  00000000  000202a8  2**0
                  CONTENTS, READONLY
  9 .debug_line   00022f1c  00000000  00000000  000202d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00046ac4  00000000  00000000  000431f2  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00007f96  00000000  00000000  00089cb6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00001ea8  00000000  00000000  00091c50  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000a32d2  00000000  00000000  00093af8  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00002bd0  00000000  00000000  00136dd0  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00017906  00000000  00000000  001399a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  000212d7  00000000  00000000  001512a6  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      00000f98  00000000  00000000  0017257d  2**0
                  CONTENTS, READONLY
 18 .iar.rtmodel  000000c9  00000000  00000000  00173515  2**0
                  CONTENTS, READONLY
 19 .iar_vfe_header 0000000c  00000000  00000000  001735e0  2**2
                  CONTENTS, READONLY
 20 .debug_frame  00007674  00000000  00000000  001735ec  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	200002a8 	.word	0x200002a8
 80000e0:	00000000 	.word	0x00000000
 80000e4:	0800ccc4 	.word	0x0800ccc4

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	200002ac 	.word	0x200002ac
 8000104:	0800ccc4 	.word	0x0800ccc4

08000108 <USBPD_CAD_Init>:
 8000108:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800010a:	0007      	movs	r7, r0
 800010c:	000c      	movs	r4, r1
 800010e:	0015      	movs	r5, r2
 8000110:	001e      	movs	r6, r3
 8000112:	2801      	cmp	r0, #1
 8000114:	d830      	bhi.n	8000178 <USBPD_CAD_Init+0x70>
 8000116:	200c      	movs	r0, #12
 8000118:	f00c fd36 	bl	800cb88 <malloc>
 800011c:	0002      	movs	r2, r0
 800011e:	4841      	ldr	r0, [pc, #260]	; (8000224 <.text_6>)
 8000120:	00b9      	lsls	r1, r7, #2
 8000122:	1841      	adds	r1, r0, r1
 8000124:	604a      	str	r2, [r1, #4]
 8000126:	2a00      	cmp	r2, #0
 8000128:	d101      	bne.n	800012e <USBPD_CAD_Init+0x26>
 800012a:	2003      	movs	r0, #3
 800012c:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 800012e:	9600      	str	r6, [sp, #0]
 8000130:	2300      	movs	r3, #0
 8000132:	2600      	movs	r6, #0
 8000134:	c248      	stmia	r2!, {r3, r6}
 8000136:	6013      	str	r3, [r2, #0]
 8000138:	7802      	ldrb	r2, [r0, #0]
 800013a:	1c52      	adds	r2, r2, #1
 800013c:	7002      	strb	r2, [r0, #0]
 800013e:	6848      	ldr	r0, [r1, #4]
 8000140:	9900      	ldr	r1, [sp, #0]
 8000142:	6001      	str	r1, [r0, #0]
 8000144:	7103      	strb	r3, [r0, #4]
 8000146:	6084      	str	r4, [r0, #8]
 8000148:	4837      	ldr	r0, [pc, #220]	; (8000228 <.text_7>)
 800014a:	6882      	ldr	r2, [r0, #8]
 800014c:	2301      	movs	r3, #1
 800014e:	6083      	str	r3, [r0, #8]
 8000150:	6881      	ldr	r1, [r0, #8]
 8000152:	2900      	cmp	r1, #0
 8000154:	d1fc      	bne.n	8000150 <USBPD_CAD_Init+0x48>
 8000156:	0029      	movs	r1, r5
 8000158:	4d34      	ldr	r5, [pc, #208]	; (800022c <.text_8>)
 800015a:	6005      	str	r5, [r0, #0]
 800015c:	6805      	ldr	r5, [r0, #0]
 800015e:	4e34      	ldr	r6, [pc, #208]	; (8000230 <.text_9>)
 8000160:	6035      	str	r5, [r6, #0]
 8000162:	6082      	str	r2, [r0, #8]
 8000164:	6882      	ldr	r2, [r0, #8]
 8000166:	4313      	orrs	r3, r2
 8000168:	6083      	str	r3, [r0, #8]
 800016a:	6863      	ldr	r3, [r4, #4]
 800016c:	9a00      	ldr	r2, [sp, #0]
 800016e:	0038      	movs	r0, r7
 8000170:	f009 fbac 	bl	80098cc <CAD_Init>
 8000174:	2000      	movs	r0, #0
 8000176:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 8000178:	2001      	movs	r0, #1
 800017a:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

0800017c <USBPD_CAD_PortEnable>:
 800017c:	2802      	cmp	r0, #2
 800017e:	d204      	bcs.n	800018a <USBPD_CAD_PortEnable+0xe>
 8000180:	4a28      	ldr	r2, [pc, #160]	; (8000224 <.text_6>)
 8000182:	0080      	lsls	r0, r0, #2
 8000184:	1810      	adds	r0, r2, r0
 8000186:	6840      	ldr	r0, [r0, #4]
 8000188:	7101      	strb	r1, [r0, #4]
 800018a:	4770      	bx	lr

0800018c <USBPD_CAD_Process>:
 800018c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800018e:	b084      	sub	sp, #16
 8000190:	a802      	add	r0, sp, #8
 8000192:	bf00      	nop
 8000194:	a132      	add	r1, pc, #200	; (adr r1, 8000260 <.text_14>)
 8000196:	c90c      	ldmia	r1!, {r2, r3}
 8000198:	c00c      	stmia	r0!, {r2, r3}
 800019a:	2400      	movs	r4, #0
 800019c:	4d22      	ldr	r5, [pc, #136]	; (8000228 <.text_7>)
 800019e:	4e21      	ldr	r6, [pc, #132]	; (8000224 <.text_6>)
 80001a0:	e031      	b.n	8000206 <USBPD_CAD_Process+0x7a>
 80001a2:	68a8      	ldr	r0, [r5, #8]
 80001a4:	2101      	movs	r1, #1
 80001a6:	60a9      	str	r1, [r5, #8]
 80001a8:	68aa      	ldr	r2, [r5, #8]
 80001aa:	2a00      	cmp	r2, #0
 80001ac:	d1fc      	bne.n	80001a8 <USBPD_CAD_Process+0x1c>
 80001ae:	4a1f      	ldr	r2, [pc, #124]	; (800022c <.text_8>)
 80001b0:	602a      	str	r2, [r5, #0]
 80001b2:	4a1f      	ldr	r2, [pc, #124]	; (8000230 <.text_9>)
 80001b4:	682b      	ldr	r3, [r5, #0]
 80001b6:	6013      	str	r3, [r2, #0]
 80001b8:	60a8      	str	r0, [r5, #8]
 80001ba:	68a8      	ldr	r0, [r5, #8]
 80001bc:	4301      	orrs	r1, r0
 80001be:	60a9      	str	r1, [r5, #8]
 80001c0:	e018      	b.n	80001f4 <USBPD_CAD_Process+0x68>
 80001c2:	0620      	lsls	r0, r4, #24
 80001c4:	0d80      	lsrs	r0, r0, #22
 80001c6:	9001      	str	r0, [sp, #4]
 80001c8:	1d30      	adds	r0, r6, #4
 80001ca:	9901      	ldr	r1, [sp, #4]
 80001cc:	1847      	adds	r7, r0, r1
 80001ce:	6838      	ldr	r0, [r7, #0]
 80001d0:	7900      	ldrb	r0, [r0, #4]
 80001d2:	2801      	cmp	r0, #1
 80001d4:	d116      	bne.n	8000204 <USBPD_CAD_Process+0x78>
 80001d6:	aa00      	add	r2, sp, #0
 80001d8:	1c52      	adds	r2, r2, #1
 80001da:	4669      	mov	r1, sp
 80001dc:	b2e0      	uxtb	r0, r4
 80001de:	f00b fa3b 	bl	800b658 <CAD_StateMachine>
 80001e2:	a902      	add	r1, sp, #8
 80001e4:	9a01      	ldr	r2, [sp, #4]
 80001e6:	5088      	str	r0, [r1, r2]
 80001e8:	4668      	mov	r0, sp
 80001ea:	7800      	ldrb	r0, [r0, #0]
 80001ec:	2800      	cmp	r0, #0
 80001ee:	d009      	beq.n	8000204 <USBPD_CAD_Process+0x78>
 80001f0:	2801      	cmp	r0, #1
 80001f2:	d0d6      	beq.n	80001a2 <USBPD_CAD_Process+0x16>
 80001f4:	4668      	mov	r0, sp
 80001f6:	7842      	ldrb	r2, [r0, #1]
 80001f8:	7801      	ldrb	r1, [r0, #0]
 80001fa:	b2e0      	uxtb	r0, r4
 80001fc:	683b      	ldr	r3, [r7, #0]
 80001fe:	689b      	ldr	r3, [r3, #8]
 8000200:	681b      	ldr	r3, [r3, #0]
 8000202:	4798      	blx	r3
 8000204:	1c64      	adds	r4, r4, #1
 8000206:	7830      	ldrb	r0, [r6, #0]
 8000208:	b2e1      	uxtb	r1, r4
 800020a:	4281      	cmp	r1, r0
 800020c:	d3d9      	bcc.n	80001c2 <USBPD_CAD_Process+0x36>
 800020e:	2801      	cmp	r0, #1
 8000210:	d101      	bne.n	8000216 <USBPD_CAD_Process+0x8a>
 8000212:	9802      	ldr	r0, [sp, #8]
 8000214:	e004      	b.n	8000220 <USBPD_CAD_Process+0x94>
 8000216:	9803      	ldr	r0, [sp, #12]
 8000218:	9902      	ldr	r1, [sp, #8]
 800021a:	4288      	cmp	r0, r1
 800021c:	d300      	bcc.n	8000220 <USBPD_CAD_Process+0x94>
 800021e:	4608      	mov	r0, r1
 8000220:	b005      	add	sp, #20
 8000222:	bdf0      	pop	{r4, r5, r6, r7, pc}

08000224 <.text_6>:
 8000224:	2000199c 	.word	0x2000199c

08000228 <.text_7>:
 8000228:	40023000 	.word	0x40023000

0800022c <.text_8>:
 800022c:	f407a5c2 	.word	0xf407a5c2

08000230 <.text_9>:
 8000230:	200019b8 	.word	0x200019b8

08000234 <USBPD_CAD_AssertRd>:
 8000234:	b510      	push	{r4, lr}
 8000236:	0004      	movs	r4, r0
 8000238:	f00a fbb9 	bl	800a9ae <USBPDM1_DeAssertRp>
 800023c:	0020      	movs	r0, r4
 800023e:	f00a fbb7 	bl	800a9b0 <USBPDM1_AssertRd>
 8000242:	bd10      	pop	{r4, pc}

08000244 <USBPD_CAD_AssertRp>:
 8000244:	b510      	push	{r4, lr}
 8000246:	0004      	movs	r4, r0
 8000248:	f00a fbb3 	bl	800a9b2 <USBPDM1_DeAssertRd>
 800024c:	0020      	movs	r0, r4
 800024e:	f00a fbad 	bl	800a9ac <USBPDM1_AssertRp>
 8000252:	bd10      	pop	{r4, pc}

08000254 <USBPD_CAD_EnterErrorRecovery>:
 8000254:	b580      	push	{r7, lr}
 8000256:	f009 fb5d 	bl	8009914 <CAD_Enter_ErrorRecovery>
 800025a:	bd01      	pop	{r0, pc}

0800025c <USBPD_CAD_GetMemoryConsumption>:
 800025c:	2018      	movs	r0, #24
 800025e:	4770      	bx	lr

08000260 <.text_14>:
 8000260:	00000002 	.word	0x00000002
 8000264:	00000002 	.word	0x00000002

08000268 <USBPD_PE_Init>:
 8000268:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
 800026a:	b083      	sub	sp, #12
 800026c:	0017      	movs	r7, r2
 800026e:	001d      	movs	r5, r3
 8000270:	4668      	mov	r0, sp
 8000272:	7b06      	ldrb	r6, [r0, #12]
 8000274:	2e01      	cmp	r6, #1
 8000276:	d838      	bhi.n	80002ea <USBPD_PE_Init+0x82>
 8000278:	20e6      	movs	r0, #230	; 0xe6
 800027a:	0080      	lsls	r0, r0, #2
 800027c:	f00c fc84 	bl	800cb88 <malloc>
 8000280:	499b      	ldr	r1, [pc, #620]	; (80004f0 <.text_10>)
 8000282:	466a      	mov	r2, sp
 8000284:	7b12      	ldrb	r2, [r2, #12]
 8000286:	0092      	lsls	r2, r2, #2
 8000288:	5088      	str	r0, [r1, r2]
 800028a:	0004      	movs	r4, r0
 800028c:	d101      	bne.n	8000292 <USBPD_PE_Init+0x2a>
 800028e:	2016      	movs	r0, #22
 8000290:	e073      	b.n	800037a <USBPD_PE_Init+0x112>
 8000292:	9500      	str	r5, [sp, #0]
 8000294:	9d04      	ldr	r5, [sp, #16]
 8000296:	21e6      	movs	r1, #230	; 0xe6
 8000298:	0089      	lsls	r1, r1, #2
 800029a:	f00c fc45 	bl	800cb28 <__aeabi_memclr>
 800029e:	6025      	str	r5, [r4, #0]
 80002a0:	6067      	str	r7, [r4, #4]
 80002a2:	2701      	movs	r7, #1
 80002a4:	68e0      	ldr	r0, [r4, #12]
 80002a6:	43b8      	bics	r0, r7
 80002a8:	403e      	ands	r6, r7
 80002aa:	4306      	orrs	r6, r0
 80002ac:	60e6      	str	r6, [r4, #12]
 80002ae:	9800      	ldr	r0, [sp, #0]
 80002b0:	60a0      	str	r0, [r4, #8]
 80002b2:	2600      	movs	r6, #0
 80002b4:	498f      	ldr	r1, [pc, #572]	; (80004f4 <.text_11>)
 80002b6:	1861      	adds	r1, r4, r1
 80002b8:	704e      	strb	r6, [r1, #1]
 80002ba:	6820      	ldr	r0, [r4, #0]
 80002bc:	6801      	ldr	r1, [r0, #0]
 80002be:	9102      	str	r1, [sp, #8]
 80002c0:	498d      	ldr	r1, [pc, #564]	; (80004f8 <.text_12>)
 80002c2:	1861      	adds	r1, r4, r1
 80002c4:	9101      	str	r1, [sp, #4]
 80002c6:	0021      	movs	r1, r4
 80002c8:	3136      	adds	r1, #54	; 0x36
 80002ca:	9100      	str	r1, [sp, #0]
 80002cc:	7900      	ldrb	r0, [r0, #4]
 80002ce:	0880      	lsrs	r0, r0, #2
 80002d0:	2301      	movs	r3, #1
 80002d2:	4003      	ands	r3, r0
 80002d4:	209d      	movs	r0, #157	; 0x9d
 80002d6:	0040      	lsls	r0, r0, #1
 80002d8:	1822      	adds	r2, r4, r0
 80002da:	bf00      	nop
 80002dc:	a128      	add	r1, pc, #160	; (adr r1, 8000380 <PE_PrlCallbacks>)
 80002de:	4668      	mov	r0, sp
 80002e0:	7b00      	ldrb	r0, [r0, #12]
 80002e2:	f004 fdad 	bl	8004e40 <USBPD_PRL_Init>
 80002e6:	2800      	cmp	r0, #0
 80002e8:	d001      	beq.n	80002ee <USBPD_PE_Init+0x86>
 80002ea:	2002      	movs	r0, #2
 80002ec:	e045      	b.n	800037a <USBPD_PE_Init+0x112>
 80002ee:	68e0      	ldr	r0, [r4, #12]
 80002f0:	4982      	ldr	r1, [pc, #520]	; (80004fc <.text_13>)
 80002f2:	4001      	ands	r1, r0
 80002f4:	60e1      	str	r1, [r4, #12]
 80002f6:	6860      	ldr	r0, [r4, #4]
 80002f8:	9000      	str	r0, [sp, #0]
 80002fa:	7800      	ldrb	r0, [r0, #0]
 80002fc:	2303      	movs	r3, #3
 80002fe:	6821      	ldr	r1, [r4, #0]
 8000300:	7909      	ldrb	r1, [r1, #4]
 8000302:	088a      	lsrs	r2, r1, #2
 8000304:	423a      	tst	r2, r7
 8000306:	d00c      	beq.n	8000322 <USBPD_PE_Init+0xba>
 8000308:	2108      	movs	r1, #8
 800030a:	4301      	orrs	r1, r0
 800030c:	9800      	ldr	r0, [sp, #0]
 800030e:	7001      	strb	r1, [r0, #0]
 8000310:	7928      	ldrb	r0, [r5, #4]
 8000312:	4003      	ands	r3, r0
 8000314:	2201      	movs	r2, #1
 8000316:	2101      	movs	r1, #1
 8000318:	4668      	mov	r0, sp
 800031a:	7b00      	ldrb	r0, [r0, #12]
 800031c:	f004 fde4 	bl	8004ee8 <USBPD_PRL_SetHeader>
 8000320:	e017      	b.n	8000352 <USBPD_PE_Init+0xea>
 8000322:	21f7      	movs	r1, #247	; 0xf7
 8000324:	4001      	ands	r1, r0
 8000326:	9800      	ldr	r0, [sp, #0]
 8000328:	7001      	strb	r1, [r0, #0]
 800032a:	4872      	ldr	r0, [pc, #456]	; (80004f4 <.text_11>)
 800032c:	5426      	strb	r6, [r4, r0]
 800032e:	7928      	ldrb	r0, [r5, #4]
 8000330:	4003      	ands	r3, r0
 8000332:	2200      	movs	r2, #0
 8000334:	2100      	movs	r1, #0
 8000336:	4668      	mov	r0, sp
 8000338:	7b00      	ldrb	r0, [r0, #12]
 800033a:	f004 fdd5 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800033e:	0638      	lsls	r0, r7, #24
 8000340:	9001      	str	r0, [sp, #4]
 8000342:	2304      	movs	r3, #4
 8000344:	aa01      	add	r2, sp, #4
 8000346:	2106      	movs	r1, #6
 8000348:	4668      	mov	r0, sp
 800034a:	7b00      	ldrb	r0, [r0, #12]
 800034c:	68a5      	ldr	r5, [r4, #8]
 800034e:	69ed      	ldr	r5, [r5, #28]
 8000350:	47a8      	blx	r5
 8000352:	6820      	ldr	r0, [r4, #0]
 8000354:	7900      	ldrb	r0, [r0, #4]
 8000356:	0880      	lsrs	r0, r0, #2
 8000358:	4007      	ands	r7, r0
 800035a:	0039      	movs	r1, r7
 800035c:	4668      	mov	r0, sp
 800035e:	7b00      	ldrb	r0, [r0, #12]
 8000360:	f004 fddf 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8000364:	6860      	ldr	r0, [r4, #4]
 8000366:	7841      	ldrb	r1, [r0, #1]
 8000368:	228f      	movs	r2, #143	; 0x8f
 800036a:	400a      	ands	r2, r1
 800036c:	7042      	strb	r2, [r0, #1]
 800036e:	6860      	ldr	r0, [r4, #4]
 8000370:	6801      	ldr	r1, [r0, #0]
 8000372:	2210      	movs	r2, #16
 8000374:	4391      	bics	r1, r2
 8000376:	6001      	str	r1, [r0, #0]
 8000378:	2000      	movs	r0, #0
 800037a:	b005      	add	sp, #20
 800037c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08000380 <PE_PrlCallbacks>:
 8000380:	4463 0800 4481 0800 4139 0800 418d 0800     cD...D..9A...A..

08000390 <USBPD_PE_SetTrace>:
 8000390:	4a5b      	ldr	r2, [pc, #364]	; (8000500 <.text_14>)
 8000392:	60d0      	str	r0, [r2, #12]
 8000394:	7011      	strb	r1, [r2, #0]
 8000396:	4770      	bx	lr

08000398 <USBPD_PE_CheckLIB>:
 8000398:	495a      	ldr	r1, [pc, #360]	; (8000504 <.text_15>)
 800039a:	4288      	cmp	r0, r1
 800039c:	d101      	bne.n	80003a2 <USBPD_PE_CheckLIB+0xa>
 800039e:	2001      	movs	r0, #1
 80003a0:	4770      	bx	lr
 80003a2:	2000      	movs	r0, #0
 80003a4:	4770      	bx	lr

080003a6 <USBPD_PE_GetMemoryConsumption>:
 80003a6:	b510      	push	{r4, lr}
 80003a8:	f004 fd9c 	bl	8004ee4 <USBPD_PRL_GetMemoryConsumption>
 80003ac:	0004      	movs	r4, r0
 80003ae:	f7ff ff55 	bl	800025c <USBPD_CAD_GetMemoryConsumption>
 80003b2:	1820      	adds	r0, r4, r0
 80003b4:	21e6      	movs	r1, #230	; 0xe6
 80003b6:	00c9      	lsls	r1, r1, #3
 80003b8:	1840      	adds	r0, r0, r1
 80003ba:	bd10      	pop	{r4, pc}

080003bc <USBPD_PE_TimerCounter>:
 80003bc:	b081      	sub	sp, #4
 80003be:	4950      	ldr	r1, [pc, #320]	; (8000500 <.text_14>)
 80003c0:	0080      	lsls	r0, r0, #2
 80003c2:	1808      	adds	r0, r1, r0
 80003c4:	6840      	ldr	r0, [r0, #4]
 80003c6:	21d9      	movs	r1, #217	; 0xd9
 80003c8:	0089      	lsls	r1, r1, #2
 80003ca:	1840      	adds	r0, r0, r1
 80003cc:	494e      	ldr	r1, [pc, #312]	; (8000508 <.text_16>)
 80003ce:	084a      	lsrs	r2, r1, #1
 80003d0:	8b43      	ldrh	r3, [r0, #26]
 80003d2:	4013      	ands	r3, r2
 80003d4:	2b01      	cmp	r3, #1
 80003d6:	db02      	blt.n	80003de <USBPD_PE_TimerCounter+0x22>
 80003d8:	8b43      	ldrh	r3, [r0, #26]
 80003da:	185b      	adds	r3, r3, r1
 80003dc:	8343      	strh	r3, [r0, #26]
 80003de:	8803      	ldrh	r3, [r0, #0]
 80003e0:	4013      	ands	r3, r2
 80003e2:	2b01      	cmp	r3, #1
 80003e4:	db02      	blt.n	80003ec <USBPD_PE_TimerCounter+0x30>
 80003e6:	8803      	ldrh	r3, [r0, #0]
 80003e8:	185b      	adds	r3, r3, r1
 80003ea:	8003      	strh	r3, [r0, #0]
 80003ec:	8843      	ldrh	r3, [r0, #2]
 80003ee:	4013      	ands	r3, r2
 80003f0:	2b01      	cmp	r3, #1
 80003f2:	db02      	blt.n	80003fa <USBPD_PE_TimerCounter+0x3e>
 80003f4:	8843      	ldrh	r3, [r0, #2]
 80003f6:	185b      	adds	r3, r3, r1
 80003f8:	8043      	strh	r3, [r0, #2]
 80003fa:	8883      	ldrh	r3, [r0, #4]
 80003fc:	4013      	ands	r3, r2
 80003fe:	2b01      	cmp	r3, #1
 8000400:	db02      	blt.n	8000408 <USBPD_PE_TimerCounter+0x4c>
 8000402:	8883      	ldrh	r3, [r0, #4]
 8000404:	185b      	adds	r3, r3, r1
 8000406:	8083      	strh	r3, [r0, #4]
 8000408:	88c3      	ldrh	r3, [r0, #6]
 800040a:	4013      	ands	r3, r2
 800040c:	2b01      	cmp	r3, #1
 800040e:	db02      	blt.n	8000416 <USBPD_PE_TimerCounter+0x5a>
 8000410:	88c3      	ldrh	r3, [r0, #6]
 8000412:	185b      	adds	r3, r3, r1
 8000414:	80c3      	strh	r3, [r0, #6]
 8000416:	8903      	ldrh	r3, [r0, #8]
 8000418:	4013      	ands	r3, r2
 800041a:	2b01      	cmp	r3, #1
 800041c:	db02      	blt.n	8000424 <USBPD_PE_TimerCounter+0x68>
 800041e:	8903      	ldrh	r3, [r0, #8]
 8000420:	185b      	adds	r3, r3, r1
 8000422:	8103      	strh	r3, [r0, #8]
 8000424:	8943      	ldrh	r3, [r0, #10]
 8000426:	4013      	ands	r3, r2
 8000428:	2b01      	cmp	r3, #1
 800042a:	db02      	blt.n	8000432 <USBPD_PE_TimerCounter+0x76>
 800042c:	8943      	ldrh	r3, [r0, #10]
 800042e:	185b      	adds	r3, r3, r1
 8000430:	8143      	strh	r3, [r0, #10]
 8000432:	8983      	ldrh	r3, [r0, #12]
 8000434:	4013      	ands	r3, r2
 8000436:	2b01      	cmp	r3, #1
 8000438:	db02      	blt.n	8000440 <USBPD_PE_TimerCounter+0x84>
 800043a:	8983      	ldrh	r3, [r0, #12]
 800043c:	185b      	adds	r3, r3, r1
 800043e:	8183      	strh	r3, [r0, #12]
 8000440:	89c3      	ldrh	r3, [r0, #14]
 8000442:	4013      	ands	r3, r2
 8000444:	2b01      	cmp	r3, #1
 8000446:	db02      	blt.n	800044e <USBPD_PE_TimerCounter+0x92>
 8000448:	89c3      	ldrh	r3, [r0, #14]
 800044a:	185b      	adds	r3, r3, r1
 800044c:	81c3      	strh	r3, [r0, #14]
 800044e:	8a43      	ldrh	r3, [r0, #18]
 8000450:	4013      	ands	r3, r2
 8000452:	2b01      	cmp	r3, #1
 8000454:	db02      	blt.n	800045c <USBPD_PE_TimerCounter+0xa0>
 8000456:	8a43      	ldrh	r3, [r0, #18]
 8000458:	185b      	adds	r3, r3, r1
 800045a:	8243      	strh	r3, [r0, #18]
 800045c:	8a83      	ldrh	r3, [r0, #20]
 800045e:	4013      	ands	r3, r2
 8000460:	2b01      	cmp	r3, #1
 8000462:	db02      	blt.n	800046a <USBPD_PE_TimerCounter+0xae>
 8000464:	8a83      	ldrh	r3, [r0, #20]
 8000466:	185b      	adds	r3, r3, r1
 8000468:	8283      	strh	r3, [r0, #20]
 800046a:	8ac3      	ldrh	r3, [r0, #22]
 800046c:	4013      	ands	r3, r2
 800046e:	2b01      	cmp	r3, #1
 8000470:	db02      	blt.n	8000478 <USBPD_PE_TimerCounter+0xbc>
 8000472:	8ac3      	ldrh	r3, [r0, #22]
 8000474:	185b      	adds	r3, r3, r1
 8000476:	82c3      	strh	r3, [r0, #22]
 8000478:	8a03      	ldrh	r3, [r0, #16]
 800047a:	4013      	ands	r3, r2
 800047c:	2b01      	cmp	r3, #1
 800047e:	db02      	blt.n	8000486 <USBPD_PE_TimerCounter+0xca>
 8000480:	8a03      	ldrh	r3, [r0, #16]
 8000482:	185b      	adds	r3, r3, r1
 8000484:	8203      	strh	r3, [r0, #16]
 8000486:	8b03      	ldrh	r3, [r0, #24]
 8000488:	4013      	ands	r3, r2
 800048a:	2b01      	cmp	r3, #1
 800048c:	db02      	blt.n	8000494 <USBPD_PE_TimerCounter+0xd8>
 800048e:	8b03      	ldrh	r3, [r0, #24]
 8000490:	185b      	adds	r3, r3, r1
 8000492:	8303      	strh	r3, [r0, #24]
 8000494:	8b83      	ldrh	r3, [r0, #28]
 8000496:	4013      	ands	r3, r2
 8000498:	2b01      	cmp	r3, #1
 800049a:	db02      	blt.n	80004a2 <USBPD_PE_TimerCounter+0xe6>
 800049c:	8b83      	ldrh	r3, [r0, #28]
 800049e:	185b      	adds	r3, r3, r1
 80004a0:	8383      	strh	r3, [r0, #28]
 80004a2:	8bc3      	ldrh	r3, [r0, #30]
 80004a4:	401a      	ands	r2, r3
 80004a6:	2a01      	cmp	r2, #1
 80004a8:	db02      	blt.n	80004b0 <USBPD_PE_TimerCounter+0xf4>
 80004aa:	8bc2      	ldrh	r2, [r0, #30]
 80004ac:	1851      	adds	r1, r2, r1
 80004ae:	83c1      	strh	r1, [r0, #30]
 80004b0:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80004b2:	1c49      	adds	r1, r1, #1
 80004b4:	6241      	str	r1, [r0, #36]	; 0x24
 80004b6:	b001      	add	sp, #4
 80004b8:	4770      	bx	lr

080004ba <USBPD_PE_IsCableConnected>:
 80004ba:	b538      	push	{r3, r4, r5, lr}
 80004bc:	000c      	movs	r4, r1
 80004be:	490c      	ldr	r1, [pc, #48]	; (80004f0 <.text_10>)
 80004c0:	0082      	lsls	r2, r0, #2
 80004c2:	588d      	ldr	r5, [r1, r2]
 80004c4:	2100      	movs	r1, #0
 80004c6:	f003 fe62 	bl	800418e <PE_Reset>
 80004ca:	6868      	ldr	r0, [r5, #4]
 80004cc:	6801      	ldr	r1, [r0, #0]
 80004ce:	2c01      	cmp	r4, #1
 80004d0:	d104      	bne.n	80004dc <USBPD_PE_IsCableConnected+0x22>
 80004d2:	2280      	movs	r2, #128	; 0x80
 80004d4:	0112      	lsls	r2, r2, #4
 80004d6:	430a      	orrs	r2, r1
 80004d8:	6002      	str	r2, [r0, #0]
 80004da:	e006      	b.n	80004ea <USBPD_PE_IsCableConnected+0x30>
 80004dc:	4a07      	ldr	r2, [pc, #28]	; (80004fc <.text_13>)
 80004de:	400a      	ands	r2, r1
 80004e0:	6002      	str	r2, [r0, #0]
 80004e2:	2000      	movs	r0, #0
 80004e4:	21d6      	movs	r1, #214	; 0xd6
 80004e6:	0089      	lsls	r1, r1, #2
 80004e8:	5468      	strb	r0, [r5, r1]
 80004ea:	2000      	movs	r0, #0
 80004ec:	bd32      	pop	{r1, r4, r5, pc}
	...

080004f0 <.text_10>:
 80004f0:	200019ac 	.word	0x200019ac

080004f4 <.text_11>:
 80004f4:	00000357 	.word	0x00000357

080004f8 <.text_12>:
 80004f8:	0000034a 	.word	0x0000034a

080004fc <.text_13>:
 80004fc:	fffff7ff 	.word	0xfffff7ff

08000500 <.text_14>:
 8000500:	200019a8 	.word	0x200019a8

08000504 <.text_15>:
 8000504:	30210001 	.word	0x30210001

08000508 <.text_16>:
 8000508:	0000ffff 	.word	0x0000ffff

0800050c <USBPD_PE_StateMachine_SRC>:
 800050c:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 800050e:	b08a      	sub	sp, #40	; 0x28
 8000510:	48b5      	ldr	r0, [pc, #724]	; (80007e8 <__iar_annotation$$branch+0xc>)
 8000512:	a90a      	add	r1, sp, #40	; 0x28
 8000514:	7809      	ldrb	r1, [r1, #0]
 8000516:	0089      	lsls	r1, r1, #2
 8000518:	1840      	adds	r0, r0, r1
 800051a:	6844      	ldr	r4, [r0, #4]
 800051c:	2000      	movs	r0, #0
 800051e:	9008      	str	r0, [sp, #32]
 8000520:	20d9      	movs	r0, #217	; 0xd9
 8000522:	0080      	lsls	r0, r0, #2
 8000524:	1820      	adds	r0, r4, r0
 8000526:	9004      	str	r0, [sp, #16]
 8000528:	6a46      	ldr	r6, [r0, #36]	; 0x24
 800052a:	8807      	ldrh	r7, [r0, #0]
 800052c:	4668      	mov	r0, sp
 800052e:	9904      	ldr	r1, [sp, #16]
 8000530:	8849      	ldrh	r1, [r1, #2]
 8000532:	8281      	strh	r1, [r0, #20]
 8000534:	9904      	ldr	r1, [sp, #16]
 8000536:	8889      	ldrh	r1, [r1, #4]
 8000538:	81c1      	strh	r1, [r0, #14]
 800053a:	9904      	ldr	r1, [sp, #16]
 800053c:	88c9      	ldrh	r1, [r1, #6]
 800053e:	8141      	strh	r1, [r0, #10]
 8000540:	9904      	ldr	r1, [sp, #16]
 8000542:	8909      	ldrh	r1, [r1, #8]
 8000544:	8101      	strh	r1, [r0, #8]
 8000546:	9904      	ldr	r1, [sp, #16]
 8000548:	8949      	ldrh	r1, [r1, #10]
 800054a:	80c1      	strh	r1, [r0, #6]
 800054c:	9904      	ldr	r1, [sp, #16]
 800054e:	8989      	ldrh	r1, [r1, #12]
 8000550:	8081      	strh	r1, [r0, #4]
 8000552:	9904      	ldr	r1, [sp, #16]
 8000554:	89c9      	ldrh	r1, [r1, #14]
 8000556:	8041      	strh	r1, [r0, #2]
 8000558:	9904      	ldr	r1, [sp, #16]
 800055a:	89c9      	ldrh	r1, [r1, #14]
 800055c:	8001      	strh	r1, [r0, #0]
 800055e:	9804      	ldr	r0, [sp, #16]
 8000560:	8a00      	ldrh	r0, [r0, #16]
 8000562:	9904      	ldr	r1, [sp, #16]
 8000564:	8a49      	ldrh	r1, [r1, #18]
 8000566:	9a04      	ldr	r2, [sp, #16]
 8000568:	8a92      	ldrh	r2, [r2, #20]
 800056a:	9b04      	ldr	r3, [sp, #16]
 800056c:	8adb      	ldrh	r3, [r3, #22]
 800056e:	9d04      	ldr	r5, [sp, #16]
 8000570:	8c2d      	ldrh	r5, [r5, #32]
 8000572:	0536      	lsls	r6, r6, #20
 8000574:	0d36      	lsrs	r6, r6, #20
 8000576:	19f6      	adds	r6, r6, r7
 8000578:	466f      	mov	r7, sp
 800057a:	8abf      	ldrh	r7, [r7, #20]
 800057c:	19f6      	adds	r6, r6, r7
 800057e:	466f      	mov	r7, sp
 8000580:	89ff      	ldrh	r7, [r7, #14]
 8000582:	19f6      	adds	r6, r6, r7
 8000584:	466f      	mov	r7, sp
 8000586:	897f      	ldrh	r7, [r7, #10]
 8000588:	19f6      	adds	r6, r6, r7
 800058a:	466f      	mov	r7, sp
 800058c:	893f      	ldrh	r7, [r7, #8]
 800058e:	19f6      	adds	r6, r6, r7
 8000590:	466f      	mov	r7, sp
 8000592:	88ff      	ldrh	r7, [r7, #6]
 8000594:	19f6      	adds	r6, r6, r7
 8000596:	466f      	mov	r7, sp
 8000598:	88bf      	ldrh	r7, [r7, #4]
 800059a:	19f6      	adds	r6, r6, r7
 800059c:	466f      	mov	r7, sp
 800059e:	887f      	ldrh	r7, [r7, #2]
 80005a0:	19f6      	adds	r6, r6, r7
 80005a2:	466f      	mov	r7, sp
 80005a4:	883f      	ldrh	r7, [r7, #0]
 80005a6:	19f6      	adds	r6, r6, r7
 80005a8:	1830      	adds	r0, r6, r0
 80005aa:	1840      	adds	r0, r0, r1
 80005ac:	1880      	adds	r0, r0, r2
 80005ae:	18c0      	adds	r0, r0, r3
 80005b0:	0529      	lsls	r1, r5, #20
 80005b2:	0f49      	lsrs	r1, r1, #29
 80005b4:	1840      	adds	r0, r0, r1
 80005b6:	9904      	ldr	r1, [sp, #16]
 80005b8:	8c09      	ldrh	r1, [r1, #32]
 80005ba:	06c9      	lsls	r1, r1, #27
 80005bc:	0ec9      	lsrs	r1, r1, #27
 80005be:	1840      	adds	r0, r0, r1
 80005c0:	b280      	uxth	r0, r0
 80005c2:	9007      	str	r0, [sp, #28]
 80005c4:	0020      	movs	r0, r4
 80005c6:	f003 f9f9 	bl	80039bc <PE_Check_RxEvent>
 80005ca:	4669      	mov	r1, sp
 80005cc:	7308      	strb	r0, [r1, #12]
 80005ce:	2803      	cmp	r0, #3
 80005d0:	d101      	bne.n	80005d6 <USBPD_PE_StateMachine_SRC+0xca>
 80005d2:	2001      	movs	r0, #1
 80005d4:	e254      	b.n	8000a80 <__iar_annotation$$branch+0x88>
 80005d6:	2502      	movs	r5, #2
 80005d8:	20d4      	movs	r0, #212	; 0xd4
 80005da:	0080      	lsls	r0, r0, #2
 80005dc:	1826      	adds	r6, r4, r0
 80005de:	7930      	ldrb	r0, [r6, #4]
 80005e0:	280f      	cmp	r0, #15
 80005e2:	d117      	bne.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 80005e4:	7230      	strb	r0, [r6, #8]
 80005e6:	2000      	movs	r0, #0
 80005e8:	7130      	strb	r0, [r6, #4]
 80005ea:	487f      	ldr	r0, [pc, #508]	; (80007e8 <__iar_annotation$$branch+0xc>)
 80005ec:	68c7      	ldr	r7, [r0, #12]
 80005ee:	2f00      	cmp	r7, #0
 80005f0:	d010      	beq.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 80005f2:	7800      	ldrb	r0, [r0, #0]
 80005f4:	07c0      	lsls	r0, r0, #31
 80005f6:	d50d      	bpl.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 80005f8:	7a30      	ldrb	r0, [r6, #8]
 80005fa:	7a71      	ldrb	r1, [r6, #9]
 80005fc:	4281      	cmp	r1, r0
 80005fe:	d009      	beq.n	8000614 <USBPD_PE_StateMachine_SRC+0x108>
 8000600:	7270      	strb	r0, [r6, #9]
 8000602:	2000      	movs	r0, #0
 8000604:	9000      	str	r0, [sp, #0]
 8000606:	2300      	movs	r3, #0
 8000608:	7a32      	ldrb	r2, [r6, #8]
 800060a:	7b20      	ldrb	r0, [r4, #12]
 800060c:	07c1      	lsls	r1, r0, #31
 800060e:	0fc9      	lsrs	r1, r1, #31
 8000610:	2004      	movs	r0, #4
 8000612:	47b8      	blx	r7
 8000614:	9807      	ldr	r0, [sp, #28]
 8000616:	2800      	cmp	r0, #0
 8000618:	d006      	beq.n	8000628 <USBPD_PE_StateMachine_SRC+0x11c>
 800061a:	2107      	movs	r1, #7
 800061c:	f005 fb44 	bl	8005ca8 <__aeabi_idivmod>
 8000620:	2900      	cmp	r1, #0
 8000622:	d101      	bne.n	8000628 <USBPD_PE_StateMachine_SRC+0x11c>
 8000624:	2001      	movs	r0, #1
 8000626:	9008      	str	r0, [sp, #32]
 8000628:	496f      	ldr	r1, [pc, #444]	; (80007e8 <__iar_annotation$$branch+0xc>)
 800062a:	7808      	ldrb	r0, [r1, #0]
 800062c:	4028      	ands	r0, r5
 800062e:	68c9      	ldr	r1, [r1, #12]
 8000630:	9101      	str	r1, [sp, #4]
 8000632:	4669      	mov	r1, sp
 8000634:	7b09      	ldrb	r1, [r1, #12]
 8000636:	7a32      	ldrb	r2, [r6, #8]
 8000638:	2a00      	cmp	r2, #0
 800063a:	d100      	bne.n	800063e <USBPD_PE_StateMachine_SRC+0x132>
 800063c:	e0eb      	b.n	8000816 <__iar_annotation$$branch+0x3a>
 800063e:	1e52      	subs	r2, r2, #1
 8000640:	d100      	bne.n	8000644 <USBPD_PE_StateMachine_SRC+0x138>
 8000642:	e0a8      	b.n	8000796 <__iar_annotation$$branch+0xe>
 8000644:	1e52      	subs	r2, r2, #1
 8000646:	d100      	bne.n	800064a <USBPD_PE_StateMachine_SRC+0x13e>
 8000648:	e0ed      	b.n	8000826 <__iar_annotation$$branch+0x4a>
 800064a:	1e52      	subs	r2, r2, #1
 800064c:	d101      	bne.n	8000652 <__iar_annotation$$branch+0x4>

0800064e <__iar_annotation$$branch>:
 800064e:	f001 f8e6 	bl	800181e <__iar_annotation$$branch+0x250>
 8000652:	1e52      	subs	r2, r2, #1
 8000654:	d101      	bne.n	800065a <__iar_annotation$$branch+0x4>

08000656 <__iar_annotation$$branch>:
 8000656:	f001 f8fc 	bl	8001852 <__iar_annotation$$branch+0x284>
 800065a:	1e52      	subs	r2, r2, #1
 800065c:	d100      	bne.n	8000660 <__iar_annotation$$branch+0xa>
 800065e:	e133      	b.n	80008c8 <__iar_annotation$$branch+0xec>
 8000660:	1e52      	subs	r2, r2, #1
 8000662:	d100      	bne.n	8000666 <__iar_annotation$$branch+0x10>
 8000664:	e214      	b.n	8000a90 <__iar_annotation$$branch+0x98>
 8000666:	1e52      	subs	r2, r2, #1
 8000668:	d100      	bne.n	800066c <__iar_annotation$$branch+0x16>
 800066a:	e219      	b.n	8000aa0 <__iar_annotation$$branch+0xa8>
 800066c:	1e52      	subs	r2, r2, #1
 800066e:	d100      	bne.n	8000672 <__iar_annotation$$branch+0x1c>
 8000670:	e282      	b.n	8000b78 <__iar_annotation$$branch+0x180>
 8000672:	1e52      	subs	r2, r2, #1
 8000674:	d100      	bne.n	8000678 <__iar_annotation$$branch+0x22>
 8000676:	e2ca      	b.n	8000c0e <__iar_annotation$$branch+0x216>
 8000678:	1e52      	subs	r2, r2, #1
 800067a:	2a01      	cmp	r2, #1
 800067c:	d800      	bhi.n	8000680 <__iar_annotation$$branch+0x2a>
 800067e:	e3c3      	b.n	8000e08 <__iar_annotation$$branch+0x410>
 8000680:	1e92      	subs	r2, r2, #2
 8000682:	d100      	bne.n	8000686 <__iar_annotation$$branch+0x30>
 8000684:	e357      	b.n	8000d36 <__iar_annotation$$branch+0x33e>
 8000686:	1e52      	subs	r2, r2, #1
 8000688:	d100      	bne.n	800068c <__iar_annotation$$branch+0x36>
 800068a:	e383      	b.n	8000d94 <__iar_annotation$$branch+0x39c>
 800068c:	1e52      	subs	r2, r2, #1
 800068e:	d100      	bne.n	8000692 <__iar_annotation$$branch+0x3c>
 8000690:	e3b7      	b.n	8000e02 <__iar_annotation$$branch+0x40a>
 8000692:	1e52      	subs	r2, r2, #1
 8000694:	d101      	bne.n	800069a <__iar_annotation$$branch+0x4>

08000696 <__iar_annotation$$branch>:
 8000696:	f000 fc91 	bl	8000fbc <__iar_annotation$$branch+0x5c4>
 800069a:	1e52      	subs	r2, r2, #1
 800069c:	d101      	bne.n	80006a2 <__iar_annotation$$branch+0x4>

0800069e <__iar_annotation$$branch>:
 800069e:	f000 fc21 	bl	8000ee4 <__iar_annotation$$branch+0x4ec>
 80006a2:	1e52      	subs	r2, r2, #1
 80006a4:	d101      	bne.n	80006aa <__iar_annotation$$branch+0x4>

080006a6 <__iar_annotation$$branch>:
 80006a6:	f000 fc3d 	bl	8000f24 <__iar_annotation$$branch+0x52c>
 80006aa:	1e52      	subs	r2, r2, #1
 80006ac:	d101      	bne.n	80006b2 <__iar_annotation$$branch+0x4>

080006ae <__iar_annotation$$branch>:
 80006ae:	f000 fc56 	bl	8000f5e <__iar_annotation$$branch+0x566>
 80006b2:	1e52      	subs	r2, r2, #1
 80006b4:	d101      	bne.n	80006ba <__iar_annotation$$branch+0x4>

080006b6 <__iar_annotation$$branch>:
 80006b6:	f000 fce5 	bl	8001084 <__iar_annotation$$branch+0x68c>
 80006ba:	1e52      	subs	r2, r2, #1
 80006bc:	d101      	bne.n	80006c2 <__iar_annotation$$branch+0x4>

080006be <__iar_annotation$$branch>:
 80006be:	f000 fc9d 	bl	8000ffc <__iar_annotation$$branch+0x604>
 80006c2:	1e52      	subs	r2, r2, #1
 80006c4:	d101      	bne.n	80006ca <__iar_annotation$$branch+0x4>

080006c6 <__iar_annotation$$branch>:
 80006c6:	f000 fcac 	bl	8001022 <__iar_annotation$$branch+0x62a>
 80006ca:	1e52      	subs	r2, r2, #1
 80006cc:	d100      	bne.n	80006d0 <__iar_annotation$$branch+0xa>
 80006ce:	e263      	b.n	8000b98 <__iar_annotation$$branch+0x1a0>
 80006d0:	1e92      	subs	r2, r2, #2
 80006d2:	d101      	bne.n	80006d8 <__iar_annotation$$branch+0x4>

080006d4 <__iar_annotation$$branch>:
 80006d4:	f000 fd2a 	bl	800112c <__iar_annotation$$branch+0x734>
 80006d8:	1e52      	subs	r2, r2, #1
 80006da:	d101      	bne.n	80006e0 <__iar_annotation$$branch+0x4>

080006dc <__iar_annotation$$branch>:
 80006dc:	f000 fd56 	bl	800118c <__iar_annotation$$branch+0x794>
 80006e0:	1e52      	subs	r2, r2, #1
 80006e2:	d101      	bne.n	80006e8 <__iar_annotation$$branch+0x4>

080006e4 <__iar_annotation$$branch>:
 80006e4:	f000 fdcd 	bl	8001282 <__iar_annotation$$branch+0x88a>
 80006e8:	1e52      	subs	r2, r2, #1
 80006ea:	d101      	bne.n	80006f0 <__iar_annotation$$branch+0x4>

080006ec <__iar_annotation$$branch>:
 80006ec:	f000 fde9 	bl	80012c2 <__iar_annotation$$branch+0x8ca>
 80006f0:	1e92      	subs	r2, r2, #2
 80006f2:	d101      	bne.n	80006f8 <__iar_annotation$$branch+0x4>

080006f4 <__iar_annotation$$branch>:
 80006f4:	f001 f869 	bl	80017ca <__iar_annotation$$branch+0x1fc>
 80006f8:	1e52      	subs	r2, r2, #1
 80006fa:	d101      	bne.n	8000700 <__iar_annotation$$branch+0x4>

080006fc <__iar_annotation$$branch>:
 80006fc:	f000 ff69 	bl	80015d2 <__iar_annotation$$branch+0x4>
 8000700:	1e52      	subs	r2, r2, #1
 8000702:	d101      	bne.n	8000708 <__iar_annotation$$branch+0x4>

08000704 <__iar_annotation$$branch>:
 8000704:	f000 ff8e 	bl	8001624 <__iar_annotation$$branch+0x56>
 8000708:	1e52      	subs	r2, r2, #1
 800070a:	d101      	bne.n	8000710 <__iar_annotation$$branch+0x4>

0800070c <__iar_annotation$$branch>:
 800070c:	f001 f814 	bl	8001738 <__iar_annotation$$branch+0x16a>
 8000710:	1e52      	subs	r2, r2, #1
 8000712:	d101      	bne.n	8000718 <__iar_annotation$$branch+0x4>

08000714 <__iar_annotation$$branch>:
 8000714:	f001 f849 	bl	80017aa <__iar_annotation$$branch+0x1dc>
 8000718:	1e52      	subs	r2, r2, #1
 800071a:	d101      	bne.n	8000720 <__iar_annotation$$branch+0x4>

0800071c <__iar_annotation$$branch>:
 800071c:	f000 fe39 	bl	8001392 <__iar_annotation$$branch+0x99a>
 8000720:	1e92      	subs	r2, r2, #2
 8000722:	d101      	bne.n	8000728 <__iar_annotation$$branch+0x4>

08000724 <__iar_annotation$$branch>:
 8000724:	f000 fea0 	bl	8001468 <__iar_annotation$$branch+0xa70>
 8000728:	1e52      	subs	r2, r2, #1
 800072a:	d101      	bne.n	8000730 <__iar_annotation$$branch+0x4>

0800072c <__iar_annotation$$branch>:
 800072c:	f000 fefa 	bl	8001524 <__iar_annotation$$branch+0xb2c>
 8000730:	1e52      	subs	r2, r2, #1
 8000732:	d101      	bne.n	8000738 <__iar_annotation$$branch+0x4>

08000734 <__iar_annotation$$branch>:
 8000734:	f000 ff1a 	bl	800156c <__iar_annotation$$branch+0xb74>
 8000738:	1e52      	subs	r2, r2, #1
 800073a:	d101      	bne.n	8000740 <__iar_annotation$$branch+0x4>

0800073c <__iar_annotation$$branch>:
 800073c:	f000 fcc7 	bl	80010ce <__iar_annotation$$branch+0x6d6>
 8000740:	1e52      	subs	r2, r2, #1
 8000742:	d101      	bne.n	8000748 <__iar_annotation$$branch+0x4>

08000744 <__iar_annotation$$branch>:
 8000744:	f000 fcd1 	bl	80010ea <__iar_annotation$$branch+0x6f2>
 8000748:	1e52      	subs	r2, r2, #1
 800074a:	d101      	bne.n	8000750 <__iar_annotation$$branch+0x4>

0800074c <__iar_annotation$$branch>:
 800074c:	f000 fcda 	bl	8001104 <__iar_annotation$$branch+0x70c>
 8000750:	1e52      	subs	r2, r2, #1
 8000752:	d101      	bne.n	8000758 <__iar_annotation$$branch+0x4>

08000754 <__iar_annotation$$branch>:
 8000754:	f000 fe21 	bl	800139a <__iar_annotation$$branch+0x9a2>
 8000758:	1e52      	subs	r2, r2, #1
 800075a:	d101      	bne.n	8000760 <__iar_annotation$$branch+0x4>

0800075c <__iar_annotation$$branch>:
 800075c:	f001 f9a5 	bl	8001aaa <__iar_annotation$$branch+0xca>
 8000760:	1e52      	subs	r2, r2, #1
 8000762:	d018      	beq.n	8000796 <__iar_annotation$$branch+0xe>
 8000764:	1e52      	subs	r2, r2, #1
 8000766:	d101      	bne.n	800076c <__iar_annotation$$branch+0x4>

08000768 <__iar_annotation$$branch>:
 8000768:	f001 f9ae 	bl	8001ac8 <__iar_annotation$$branch+0xe8>
 800076c:	1e52      	subs	r2, r2, #1
 800076e:	d101      	bne.n	8000774 <__iar_annotation$$branch+0x4>

08000770 <__iar_annotation$$branch>:
 8000770:	f001 f9e6 	bl	8001b40 <__iar_annotation$$branch+0x160>
 8000774:	1e52      	subs	r2, r2, #1
 8000776:	2a01      	cmp	r2, #1
 8000778:	d90d      	bls.n	8000796 <__iar_annotation$$branch+0xe>
 800077a:	1e92      	subs	r2, r2, #2
 800077c:	2a07      	cmp	r2, #7
 800077e:	d801      	bhi.n	8000784 <__iar_annotation$$branch+0x4>

08000780 <__iar_annotation$$branch>:
 8000780:	f001 fa10 	bl	8001ba4 <__iar_annotation$$branch+0x22>
 8000784:	3a08      	subs	r2, #8
 8000786:	d101      	bne.n	800078c <__iar_annotation$$branch+0x4>

08000788 <__iar_annotation$$branch>:
 8000788:	f001 f9fd 	bl	8001b86 <__iar_annotation$$branch+0x4>
 800078c:	1e52      	subs	r2, r2, #1
 800078e:	2a03      	cmp	r2, #3
 8000790:	d901      	bls.n	8000796 <__iar_annotation$$branch+0xe>
 8000792:	3a28      	subs	r2, #40	; 0x28
 8000794:	2a01      	cmp	r2, #1
 8000796:	d801      	bhi.n	800079c <__iar_annotation$$branch+0x4>

08000798 <__iar_annotation$$branch>:
 8000798:	f001 fa09 	bl	8001bae <__iar_annotation$$branch+0x2c>
 800079c:	3a12      	subs	r2, #18
 800079e:	d0fa      	beq.n	8000796 <__iar_annotation$$branch+0xe>
 80007a0:	3a1e      	subs	r2, #30
 80007a2:	d023      	beq.n	80007ec <__iar_annotation$$branch+0x10>
 80007a4:	1e52      	subs	r2, r2, #1
 80007a6:	d101      	bne.n	80007ac <__iar_annotation$$branch+0x4>

080007a8 <__iar_annotation$$branch>:
 80007a8:	f001 f898 	bl	80018dc <__iar_annotation$$branch+0x1e>
 80007ac:	1e52      	subs	r2, r2, #1
 80007ae:	d101      	bne.n	80007b4 <__iar_annotation$$branch+0x4>

080007b0 <__iar_annotation$$branch>:
 80007b0:	f001 f8e0 	bl	8001974 <__iar_annotation$$branch+0xb6>
 80007b4:	1e52      	subs	r2, r2, #1
 80007b6:	d101      	bne.n	80007bc <__iar_annotation$$branch+0x4>

080007b8 <__iar_annotation$$branch>:
 80007b8:	f001 f8fb 	bl	80019b2 <__iar_annotation$$branch+0xf4>
 80007bc:	1e52      	subs	r2, r2, #1
 80007be:	d100      	bne.n	80007c2 <__iar_annotation$$branch+0xa>
 80007c0:	e339      	b.n	8000e36 <__iar_annotation$$branch+0x43e>
 80007c2:	1e52      	subs	r2, r2, #1
 80007c4:	d100      	bne.n	80007c8 <__iar_annotation$$branch+0x10>
 80007c6:	e35c      	b.n	8000e82 <__iar_annotation$$branch+0x48a>
 80007c8:	1e92      	subs	r2, r2, #2
 80007ca:	d101      	bne.n	80007d0 <__iar_annotation$$branch+0x4>

080007cc <__iar_annotation$$branch>:
 80007cc:	f001 fa02 	bl	8001bd4 <__iar_annotation$$branch+0x52>
 80007d0:	1e52      	subs	r2, r2, #1
 80007d2:	d100      	bne.n	80007d6 <__iar_annotation$$branch+0xa>
 80007d4:	e0b9      	b.n	800094a <__iar_annotation$$branch+0x16e>
 80007d6:	1e92      	subs	r2, r2, #2
 80007d8:	2a08      	cmp	r2, #8
 80007da:	d801      	bhi.n	80007e0 <__iar_annotation$$branch+0x4>

080007dc <__iar_annotation$$branch>:
 80007dc:	f001 f9ec 	bl	8001bb8 <__iar_annotation$$branch+0x36>
 80007e0:	3a09      	subs	r2, #9
 80007e2:	d0cc      	beq.n	800077e <__iar_annotation$$branch+0xe>
 80007e4:	e0ee      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80007e6:	bf00      	nop
 80007e8:	200019a8 	.word	0x200019a8
 80007ec:	68a0      	ldr	r0, [r4, #8]
 80007ee:	6b81      	ldr	r1, [r0, #56]	; 0x38
 80007f0:	2900      	cmp	r1, #0
 80007f2:	d003      	beq.n	80007fc <__iar_annotation$$branch+0x20>
 80007f4:	7b22      	ldrb	r2, [r4, #12]
 80007f6:	07d0      	lsls	r0, r2, #31
 80007f8:	0fc0      	lsrs	r0, r0, #31
 80007fa:	4788      	blx	r1
 80007fc:	2014      	movs	r0, #20
 80007fe:	4669      	mov	r1, sp
 8000800:	7308      	strb	r0, [r1, #12]
 8000802:	2101      	movs	r1, #1
 8000804:	a80a      	add	r0, sp, #40	; 0x28
 8000806:	7800      	ldrb	r0, [r0, #0]
 8000808:	f003 fcc1 	bl	800418e <PE_Reset>
 800080c:	a80a      	add	r0, sp, #40	; 0x28
 800080e:	7800      	ldrb	r0, [r0, #0]
 8000810:	f004 fe20 	bl	8005454 <USBPD_PRL_Reset>
 8000814:	e0d6      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000816:	2500      	movs	r5, #0
 8000818:	43ed      	mvns	r5, r5
 800081a:	6860      	ldr	r0, [r4, #4]
 800081c:	6801      	ldr	r1, [r0, #0]
 800081e:	2210      	movs	r2, #16
 8000820:	4391      	bics	r1, r2
 8000822:	6001      	str	r1, [r0, #0]
 8000824:	e0ce      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000826:	6860      	ldr	r0, [r4, #4]
 8000828:	6800      	ldr	r0, [r0, #0]
 800082a:	0340      	lsls	r0, r0, #13
 800082c:	0fc1      	lsrs	r1, r0, #31
 800082e:	a80a      	add	r0, sp, #40	; 0x28
 8000830:	7800      	ldrb	r0, [r0, #0]
 8000832:	f004 fbb2 	bl	8004f9a <USBPD_PRL_CableCapable>
 8000836:	6860      	ldr	r0, [r4, #4]
 8000838:	2701      	movs	r7, #1
 800083a:	6801      	ldr	r1, [r0, #0]
 800083c:	0ac9      	lsrs	r1, r1, #11
 800083e:	4039      	ands	r1, r7
 8000840:	d100      	bne.n	8000844 <__iar_annotation$$branch+0x68>
 8000842:	e170      	b.n	8000b26 <__iar_annotation$$branch+0x12e>
 8000844:	2103      	movs	r1, #3
 8000846:	6822      	ldr	r2, [r4, #0]
 8000848:	7913      	ldrb	r3, [r2, #4]
 800084a:	2203      	movs	r2, #3
 800084c:	401a      	ands	r2, r3
 800084e:	7803      	ldrb	r3, [r0, #0]
 8000850:	25fc      	movs	r5, #252	; 0xfc
 8000852:	401d      	ands	r5, r3
 8000854:	432a      	orrs	r2, r5
 8000856:	7002      	strb	r2, [r0, #0]
 8000858:	6860      	ldr	r0, [r4, #4]
 800085a:	7802      	ldrb	r2, [r0, #0]
 800085c:	4011      	ands	r1, r2
 800085e:	2901      	cmp	r1, #1
 8000860:	d101      	bne.n	8000866 <__iar_annotation$$branch+0x8a>
 8000862:	2100      	movs	r1, #0
 8000864:	e000      	b.n	8000868 <__iar_annotation$$branch+0x8c>
 8000866:	2101      	movs	r1, #1
 8000868:	239f      	movs	r3, #159	; 0x9f
 800086a:	4013      	ands	r3, r2
 800086c:	0149      	lsls	r1, r1, #5
 800086e:	4319      	orrs	r1, r3
 8000870:	7001      	strb	r1, [r0, #0]
 8000872:	2000      	movs	r0, #0
 8000874:	7560      	strb	r0, [r4, #21]
 8000876:	6860      	ldr	r0, [r4, #4]
 8000878:	7841      	ldrb	r1, [r0, #1]
 800087a:	228f      	movs	r2, #143	; 0x8f
 800087c:	400a      	ands	r2, r1
 800087e:	2110      	movs	r1, #16
 8000880:	4311      	orrs	r1, r2
 8000882:	7041      	strb	r1, [r0, #1]
 8000884:	4db3      	ldr	r5, [pc, #716]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000886:	7828      	ldrb	r0, [r5, #0]
 8000888:	0780      	lsls	r0, r0, #30
 800088a:	d509      	bpl.n	80008a0 <__iar_annotation$$branch+0xc4>
 800088c:	2000      	movs	r0, #0
 800088e:	9000      	str	r0, [sp, #0]
 8000890:	2300      	movs	r3, #0
 8000892:	2256      	movs	r2, #86	; 0x56
 8000894:	68e0      	ldr	r0, [r4, #12]
 8000896:	2101      	movs	r1, #1
 8000898:	4001      	ands	r1, r0
 800089a:	2009      	movs	r0, #9
 800089c:	68ed      	ldr	r5, [r5, #12]
 800089e:	47a8      	blx	r5
 80008a0:	2156      	movs	r1, #86	; 0x56
 80008a2:	68e2      	ldr	r2, [r4, #12]
 80008a4:	2001      	movs	r0, #1
 80008a6:	4010      	ands	r0, r2
 80008a8:	68a2      	ldr	r2, [r4, #8]
 80008aa:	68d2      	ldr	r2, [r2, #12]
 80008ac:	4790      	blx	r2
 80008ae:	6860      	ldr	r0, [r4, #4]
 80008b0:	6800      	ldr	r0, [r0, #0]
 80008b2:	0900      	lsrs	r0, r0, #4
 80008b4:	4007      	ands	r7, r0
 80008b6:	d005      	beq.n	80008c4 <__iar_annotation$$branch+0xe8>
 80008b8:	48a7      	ldr	r0, [pc, #668]	; (8000b58 <__iar_annotation$$branch+0x160>)
 80008ba:	84b0      	strh	r0, [r6, #36]	; 0x24
 80008bc:	2514      	movs	r5, #20
 80008be:	2006      	movs	r0, #6
 80008c0:	7230      	strb	r0, [r6, #8]
 80008c2:	e07f      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80008c4:	2005      	movs	r0, #5
 80008c6:	e0e8      	b.n	8000a9a <__iar_annotation$$branch+0xa2>
 80008c8:	2001      	movs	r0, #1
 80008ca:	6861      	ldr	r1, [r4, #4]
 80008cc:	6809      	ldr	r1, [r1, #0]
 80008ce:	0c89      	lsrs	r1, r1, #18
 80008d0:	4001      	ands	r1, r0
 80008d2:	d100      	bne.n	80008d6 <__iar_annotation$$branch+0xfa>
 80008d4:	e0e0      	b.n	8000a98 <__iar_annotation$$branch+0xa0>
 80008d6:	6821      	ldr	r1, [r4, #0]
 80008d8:	7809      	ldrb	r1, [r1, #0]
 80008da:	0789      	lsls	r1, r1, #30
 80008dc:	d400      	bmi.n	80008e0 <__iar_annotation$$branch+0x104>
 80008de:	e0db      	b.n	8000a98 <__iar_annotation$$branch+0xa0>
 80008e0:	21ff      	movs	r1, #255	; 0xff
 80008e2:	1c89      	adds	r1, r1, #2
 80008e4:	82e1      	strh	r1, [r4, #22]
 80008e6:	7831      	ldrb	r1, [r6, #0]
 80008e8:	22e0      	movs	r2, #224	; 0xe0
 80008ea:	400a      	ands	r2, r1
 80008ec:	4310      	orrs	r0, r2
 80008ee:	7030      	strb	r0, [r6, #0]
 80008f0:	7870      	ldrb	r0, [r6, #1]
 80008f2:	2180      	movs	r1, #128	; 0x80
 80008f4:	4301      	orrs	r1, r0
 80008f6:	7071      	strb	r1, [r6, #1]
 80008f8:	6860      	ldr	r0, [r4, #4]
 80008fa:	7800      	ldrb	r0, [r0, #0]
 80008fc:	0640      	lsls	r0, r0, #25
 80008fe:	0f80      	lsrs	r0, r0, #30
 8000900:	6831      	ldr	r1, [r6, #0]
 8000902:	4a96      	ldr	r2, [pc, #600]	; (8000b5c <__iar_annotation$$branch+0x164>)
 8000904:	400a      	ands	r2, r1
 8000906:	0340      	lsls	r0, r0, #13
 8000908:	4310      	orrs	r0, r2
 800090a:	6030      	str	r0, [r6, #0]
 800090c:	4994      	ldr	r1, [pc, #592]	; (8000b60 <__iar_annotation$$branch+0x168>)
 800090e:	4001      	ands	r1, r0
 8000910:	6031      	str	r1, [r6, #0]
 8000912:	7830      	ldrb	r0, [r6, #0]
 8000914:	0680      	lsls	r0, r0, #26
 8000916:	0e80      	lsrs	r0, r0, #26
 8000918:	7030      	strb	r0, [r6, #0]
 800091a:	6830      	ldr	r0, [r6, #0]
 800091c:	b280      	uxth	r0, r0
 800091e:	21ff      	movs	r1, #255	; 0xff
 8000920:	0609      	lsls	r1, r1, #24
 8000922:	4301      	orrs	r1, r0
 8000924:	6031      	str	r1, [r6, #0]
 8000926:	2001      	movs	r0, #1
 8000928:	9002      	str	r0, [sp, #8]
 800092a:	209a      	movs	r0, #154	; 0x9a
 800092c:	9001      	str	r0, [sp, #4]
 800092e:	2001      	movs	r0, #1
 8000930:	9000      	str	r0, [sp, #0]
 8000932:	0033      	movs	r3, r6
 8000934:	220f      	movs	r2, #15
 8000936:	2101      	movs	r1, #1
 8000938:	0020      	movs	r0, r4
 800093a:	f002 ff61 	bl	8003800 <PE_Send_DataMessage>
 800093e:	2800      	cmp	r0, #0
 8000940:	d140      	bne.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000942:	4888      	ldr	r0, [pc, #544]	; (8000b64 <__iar_annotation$$branch+0x16c>)
 8000944:	83b0      	strh	r0, [r6, #28]
 8000946:	251e      	movs	r5, #30
 8000948:	e03c      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 800094a:	2912      	cmp	r1, #18
 800094c:	d136      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 800094e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000950:	0bc0      	lsrs	r0, r0, #15
 8000952:	d133      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 8000954:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000956:	0b00      	lsrs	r0, r0, #12
 8000958:	0740      	lsls	r0, r0, #29
 800095a:	d02f      	beq.n	80009bc <__iar_annotation$$branch+0x1e0>
 800095c:	201f      	movs	r0, #31
 800095e:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000960:	4001      	ands	r1, r0
 8000962:	290f      	cmp	r1, #15
 8000964:	d12a      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 8000966:	219e      	movs	r1, #158	; 0x9e
 8000968:	0049      	lsls	r1, r1, #1
 800096a:	1861      	adds	r1, r4, r1
 800096c:	780a      	ldrb	r2, [r1, #0]
 800096e:	784b      	ldrb	r3, [r1, #1]
 8000970:	021b      	lsls	r3, r3, #8
 8000972:	18d2      	adds	r2, r2, r3
 8000974:	788b      	ldrb	r3, [r1, #2]
 8000976:	041b      	lsls	r3, r3, #16
 8000978:	18d2      	adds	r2, r2, r3
 800097a:	78c9      	ldrb	r1, [r1, #3]
 800097c:	0609      	lsls	r1, r1, #24
 800097e:	1851      	adds	r1, r2, r1
 8000980:	9100      	str	r1, [sp, #0]
 8000982:	4669      	mov	r1, sp
 8000984:	7809      	ldrb	r1, [r1, #0]
 8000986:	4008      	ands	r0, r1
 8000988:	2801      	cmp	r0, #1
 800098a:	d117      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 800098c:	0988      	lsrs	r0, r1, #6
 800098e:	2801      	cmp	r0, #1
 8000990:	d114      	bne.n	80009bc <__iar_annotation$$branch+0x1e0>
 8000992:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000994:	0440      	lsls	r0, r0, #17
 8000996:	0f40      	lsrs	r0, r0, #29
 8000998:	1e43      	subs	r3, r0, #1
 800099a:	20a0      	movs	r0, #160	; 0xa0
 800099c:	0040      	lsls	r0, r0, #1
 800099e:	1822      	adds	r2, r4, r0
 80009a0:	2113      	movs	r1, #19
 80009a2:	7b27      	ldrb	r7, [r4, #12]
 80009a4:	07f8      	lsls	r0, r7, #31
 80009a6:	0fc0      	lsrs	r0, r0, #31
 80009a8:	68a7      	ldr	r7, [r4, #8]
 80009aa:	69ff      	ldr	r7, [r7, #28]
 80009ac:	47b8      	blx	r7
 80009ae:	2007      	movs	r0, #7
 80009b0:	7230      	strb	r0, [r6, #8]
 80009b2:	2000      	movs	r0, #0
 80009b4:	83b0      	strh	r0, [r6, #28]
 80009b6:	2014      	movs	r0, #20
 80009b8:	4669      	mov	r1, sp
 80009ba:	7308      	strb	r0, [r1, #12]
 80009bc:	8bb0      	ldrh	r0, [r6, #28]
 80009be:	03a9      	lsls	r1, r5, #14
 80009c0:	4288      	cmp	r0, r1
 80009c2:	d05f      	beq.n	8000a84 <__iar_annotation$$branch+0x8c>
 80009c4:	4863      	ldr	r0, [pc, #396]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 80009c6:	68c7      	ldr	r7, [r0, #12]
 80009c8:	2f00      	cmp	r7, #0
 80009ca:	d010      	beq.n	80009ee <__iar_annotation$$branch+0x212>
 80009cc:	7800      	ldrb	r0, [r0, #0]
 80009ce:	07c0      	lsls	r0, r0, #31
 80009d0:	d50d      	bpl.n	80009ee <__iar_annotation$$branch+0x212>
 80009d2:	7a30      	ldrb	r0, [r6, #8]
 80009d4:	7a71      	ldrb	r1, [r6, #9]
 80009d6:	4281      	cmp	r1, r0
 80009d8:	d009      	beq.n	80009ee <__iar_annotation$$branch+0x212>
 80009da:	7270      	strb	r0, [r6, #9]
 80009dc:	2000      	movs	r0, #0
 80009de:	9000      	str	r0, [sp, #0]
 80009e0:	2300      	movs	r3, #0
 80009e2:	7a32      	ldrb	r2, [r6, #8]
 80009e4:	7b20      	ldrb	r0, [r4, #12]
 80009e6:	07c1      	lsls	r1, r0, #31
 80009e8:	0fc9      	lsrs	r1, r1, #31
 80009ea:	2004      	movs	r0, #4
 80009ec:	47b8      	blx	r7
 80009ee:	2701      	movs	r7, #1
 80009f0:	4668      	mov	r0, sp
 80009f2:	7b00      	ldrb	r0, [r0, #12]
 80009f4:	2814      	cmp	r0, #20
 80009f6:	d101      	bne.n	80009fc <__iar_annotation$$branch+0x4>

080009f8 <__iar_annotation$$branch>:
 80009f8:	f001 f8fd 	bl	8001bf6 <__iar_annotation$$branch+0x4>
 80009fc:	0020      	movs	r0, r4
 80009fe:	f003 f809 	bl	8003a14 <PE_Check_AMSConflict>
 8000a02:	2815      	cmp	r0, #21
 8000a04:	d102      	bne.n	8000a0c <__iar_annotation$$branch+0x14>
 8000a06:	2014      	movs	r0, #20
 8000a08:	4669      	mov	r1, sp
 8000a0a:	7308      	strb	r0, [r1, #12]
 8000a0c:	4851      	ldr	r0, [pc, #324]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000a0e:	68c5      	ldr	r5, [r0, #12]
 8000a10:	2d00      	cmp	r5, #0
 8000a12:	d010      	beq.n	8000a36 <__iar_annotation$$branch+0x3e>
 8000a14:	7800      	ldrb	r0, [r0, #0]
 8000a16:	07c0      	lsls	r0, r0, #31
 8000a18:	d50d      	bpl.n	8000a36 <__iar_annotation$$branch+0x3e>
 8000a1a:	7a30      	ldrb	r0, [r6, #8]
 8000a1c:	7a71      	ldrb	r1, [r6, #9]
 8000a1e:	4281      	cmp	r1, r0
 8000a20:	d009      	beq.n	8000a36 <__iar_annotation$$branch+0x3e>
 8000a22:	7270      	strb	r0, [r6, #9]
 8000a24:	2000      	movs	r0, #0
 8000a26:	9000      	str	r0, [sp, #0]
 8000a28:	2300      	movs	r3, #0
 8000a2a:	7a32      	ldrb	r2, [r6, #8]
 8000a2c:	68e0      	ldr	r0, [r4, #12]
 8000a2e:	2101      	movs	r1, #1
 8000a30:	4001      	ands	r1, r0
 8000a32:	2004      	movs	r0, #4
 8000a34:	47a8      	blx	r5
 8000a36:	2500      	movs	r5, #0
 8000a38:	9808      	ldr	r0, [sp, #32]
 8000a3a:	2800      	cmp	r0, #0
 8000a3c:	d01c      	beq.n	8000a78 <__iar_annotation$$branch+0x80>
 8000a3e:	4845      	ldr	r0, [pc, #276]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000a40:	6901      	ldr	r1, [r0, #16]
 8000a42:	4a49      	ldr	r2, [pc, #292]	; (8000b68 <__iar_annotation$$branch+0x170>)
 8000a44:	4291      	cmp	r1, r2
 8000a46:	d017      	beq.n	8000a78 <__iar_annotation$$branch+0x80>
 8000a48:	1d01      	adds	r1, r0, #4
 8000a4a:	68e2      	ldr	r2, [r4, #12]
 8000a4c:	403a      	ands	r2, r7
 8000a4e:	0092      	lsls	r2, r2, #2
 8000a50:	5889      	ldr	r1, [r1, r2]
 8000a52:	68ce      	ldr	r6, [r1, #12]
 8000a54:	0b33      	lsrs	r3, r6, #12
 8000a56:	1c5b      	adds	r3, r3, #1
 8000a58:	4a44      	ldr	r2, [pc, #272]	; (8000b6c <__iar_annotation$$branch+0x174>)
 8000a5a:	4016      	ands	r6, r2
 8000a5c:	031b      	lsls	r3, r3, #12
 8000a5e:	4333      	orrs	r3, r6
 8000a60:	60cb      	str	r3, [r1, #12]
 8000a62:	1d00      	adds	r0, r0, #4
 8000a64:	68e1      	ldr	r1, [r4, #12]
 8000a66:	400f      	ands	r7, r1
 8000a68:	00b9      	lsls	r1, r7, #2
 8000a6a:	5840      	ldr	r0, [r0, r1]
 8000a6c:	68c1      	ldr	r1, [r0, #12]
 8000a6e:	0b0b      	lsrs	r3, r1, #12
 8000a70:	2b08      	cmp	r3, #8
 8000a72:	db01      	blt.n	8000a78 <__iar_annotation$$branch+0x80>
 8000a74:	400a      	ands	r2, r1
 8000a76:	60c2      	str	r2, [r0, #12]
 8000a78:	2d00      	cmp	r5, #0
 8000a7a:	d100      	bne.n	8000a7e <__iar_annotation$$branch+0x86>
 8000a7c:	e5ab      	b.n	80005d6 <USBPD_PE_StateMachine_SRC+0xca>
 8000a7e:	0028      	movs	r0, r5
 8000a80:	b00b      	add	sp, #44	; 0x2c
 8000a82:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000a84:	2000      	movs	r0, #0
 8000a86:	83b0      	strh	r0, [r6, #28]
 8000a88:	2007      	movs	r0, #7
 8000a8a:	7230      	strb	r0, [r6, #8]
 8000a8c:	2010      	movs	r0, #16
 8000a8e:	e7f7      	b.n	8000a80 <__iar_annotation$$branch+0x88>
 8000a90:	8cb0      	ldrh	r0, [r6, #36]	; 0x24
 8000a92:	03a9      	lsls	r1, r5, #14
 8000a94:	4288      	cmp	r0, r1
 8000a96:	d195      	bne.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000a98:	2007      	movs	r0, #7
 8000a9a:	7230      	strb	r0, [r6, #8]
 8000a9c:	2500      	movs	r5, #0
 8000a9e:	e791      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000aa0:	2101      	movs	r1, #1
 8000aa2:	0020      	movs	r0, r4
 8000aa4:	f002 fe0b 	bl	80036be <PE_Send_SRCCapabilities>
 8000aa8:	2805      	cmp	r0, #5
 8000aaa:	d002      	beq.n	8000ab2 <__iar_annotation$$branch+0xba>
 8000aac:	2809      	cmp	r0, #9
 8000aae:	d089      	beq.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000ab0:	e023      	b.n	8000afa <__iar_annotation$$branch+0x102>
 8000ab2:	2001      	movs	r0, #1
 8000ab4:	82e0      	strh	r0, [r4, #22]
 8000ab6:	2002      	movs	r0, #2
 8000ab8:	68e1      	ldr	r1, [r4, #12]
 8000aba:	4301      	orrs	r1, r0
 8000abc:	60e1      	str	r1, [r4, #12]
 8000abe:	2100      	movs	r1, #0
 8000ac0:	7561      	strb	r1, [r4, #21]
 8000ac2:	7521      	strb	r1, [r4, #20]
 8000ac4:	492a      	ldr	r1, [pc, #168]	; (8000b70 <__iar_annotation$$branch+0x178>)
 8000ac6:	83b1      	strh	r1, [r6, #28]
 8000ac8:	251a      	movs	r5, #26
 8000aca:	2116      	movs	r1, #22
 8000acc:	7231      	strb	r1, [r6, #8]
 8000ace:	4f21      	ldr	r7, [pc, #132]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000ad0:	7839      	ldrb	r1, [r7, #0]
 8000ad2:	4201      	tst	r1, r0
 8000ad4:	d009      	beq.n	8000aea <__iar_annotation$$branch+0xf2>
 8000ad6:	2000      	movs	r0, #0
 8000ad8:	9000      	str	r0, [sp, #0]
 8000ada:	2300      	movs	r3, #0
 8000adc:	220f      	movs	r2, #15
 8000ade:	7b20      	ldrb	r0, [r4, #12]
 8000ae0:	07c1      	lsls	r1, r0, #31
 8000ae2:	0fc9      	lsrs	r1, r1, #31
 8000ae4:	2009      	movs	r0, #9
 8000ae6:	68ff      	ldr	r7, [r7, #12]
 8000ae8:	47b8      	blx	r7
 8000aea:	210f      	movs	r1, #15
 8000aec:	7b22      	ldrb	r2, [r4, #12]
 8000aee:	07d0      	lsls	r0, r2, #31
 8000af0:	0fc0      	lsrs	r0, r0, #31
 8000af2:	68a2      	ldr	r2, [r4, #8]
 8000af4:	68d2      	ldr	r2, [r2, #12]
 8000af6:	4790      	blx	r2
 8000af8:	e764      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000afa:	2701      	movs	r7, #1
 8000afc:	68e1      	ldr	r1, [r4, #12]
 8000afe:	2001      	movs	r0, #1
 8000b00:	4008      	ands	r0, r1
 8000b02:	f004 fa37 	bl	8004f74 <USBPD_PRL_SRCReleaseSinkNG>
 8000b06:	68e0      	ldr	r0, [r4, #12]
 8000b08:	0840      	lsrs	r0, r0, #1
 8000b0a:	4007      	ands	r7, r0
 8000b0c:	d107      	bne.n	8000b1e <__iar_annotation$$branch+0x126>
 8000b0e:	7d60      	ldrb	r0, [r4, #21]
 8000b10:	2833      	cmp	r0, #51	; 0x33
 8000b12:	d204      	bcs.n	8000b1e <__iar_annotation$$branch+0x126>
 8000b14:	4817      	ldr	r0, [pc, #92]	; (8000b74 <__iar_annotation$$branch+0x17c>)
 8000b16:	8430      	strh	r0, [r6, #32]
 8000b18:	2596      	movs	r5, #150	; 0x96
 8000b1a:	2008      	movs	r0, #8
 8000b1c:	e6d0      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000b1e:	2f00      	cmp	r7, #0
 8000b20:	d001      	beq.n	8000b26 <__iar_annotation$$branch+0x12e>
 8000b22:	200f      	movs	r0, #15
 8000b24:	e7b9      	b.n	8000a9a <__iar_annotation$$branch+0xa2>
 8000b26:	4f0b      	ldr	r7, [pc, #44]	; (8000b54 <__iar_annotation$$branch+0x15c>)
 8000b28:	7838      	ldrb	r0, [r7, #0]
 8000b2a:	0780      	lsls	r0, r0, #30
 8000b2c:	d509      	bpl.n	8000b42 <__iar_annotation$$branch+0x14a>
 8000b2e:	2000      	movs	r0, #0
 8000b30:	9000      	str	r0, [sp, #0]
 8000b32:	2300      	movs	r3, #0
 8000b34:	2220      	movs	r2, #32
 8000b36:	7b20      	ldrb	r0, [r4, #12]
 8000b38:	07c1      	lsls	r1, r0, #31
 8000b3a:	0fc9      	lsrs	r1, r1, #31
 8000b3c:	2009      	movs	r0, #9
 8000b3e:	68ff      	ldr	r7, [r7, #12]
 8000b40:	47b8      	blx	r7
 8000b42:	2120      	movs	r1, #32
 8000b44:	7b22      	ldrb	r2, [r4, #12]
 8000b46:	07d0      	lsls	r0, r2, #31
 8000b48:	0fc0      	lsrs	r0, r0, #31
 8000b4a:	68a2      	ldr	r2, [r4, #8]
 8000b4c:	68d2      	ldr	r2, [r2, #12]
 8000b4e:	4790      	blx	r2
 8000b50:	2000      	movs	r0, #0
 8000b52:	e6b5      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000b54:	200019a8 	.word	0x200019a8
 8000b58:	00008014 	.word	0x00008014
 8000b5c:	ffff9fff 	.word	0xffff9fff
 8000b60:	fffff8ff 	.word	0xfffff8ff
 8000b64:	0000801e 	.word	0x0000801e
 8000b68:	b5e8b5cd 	.word	0xb5e8b5cd
 8000b6c:	00000fff 	.word	0x00000fff
 8000b70:	0000801a 	.word	0x0000801a
 8000b74:	00008096 	.word	0x00008096
 8000b78:	8c30      	ldrh	r0, [r6, #32]
 8000b7a:	03a9      	lsls	r1, r5, #14
 8000b7c:	4288      	cmp	r0, r1
 8000b7e:	d1bb      	bne.n	8000af8 <__iar_annotation$$branch+0x100>
 8000b80:	2000      	movs	r0, #0
 8000b82:	8430      	strh	r0, [r6, #32]
 8000b84:	6820      	ldr	r0, [r4, #0]
 8000b86:	6840      	ldr	r0, [r0, #4]
 8000b88:	0601      	lsls	r1, r0, #24
 8000b8a:	0fc9      	lsrs	r1, r1, #31
 8000b8c:	d002      	beq.n	8000b94 <__iar_annotation$$branch+0x19c>
 8000b8e:	7d60      	ldrb	r0, [r4, #21]
 8000b90:	1c40      	adds	r0, r0, #1
 8000b92:	7560      	strb	r0, [r4, #21]
 8000b94:	2007      	movs	r0, #7
 8000b96:	e693      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000b98:	2911      	cmp	r1, #17
 8000b9a:	d132      	bne.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000b9c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000b9e:	0bc0      	lsrs	r0, r0, #15
 8000ba0:	d12f      	bne.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000ba2:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000ba4:	0b00      	lsrs	r0, r0, #12
 8000ba6:	0740      	lsls	r0, r0, #29
 8000ba8:	d02b      	beq.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000baa:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000bac:	06c0      	lsls	r0, r0, #27
 8000bae:	0ec0      	lsrs	r0, r0, #27
 8000bb0:	2802      	cmp	r0, #2
 8000bb2:	d126      	bne.n	8000c02 <__iar_annotation$$branch+0x20a>
 8000bb4:	2501      	movs	r5, #1
 8000bb6:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8000bb8:	0600      	lsls	r0, r0, #24
 8000bba:	0f81      	lsrs	r1, r0, #30
 8000bbc:	68e2      	ldr	r2, [r4, #12]
 8000bbe:	2001      	movs	r0, #1
 8000bc0:	4010      	ands	r0, r2
 8000bc2:	f003 fc05 	bl	80043d0 <PE_ExtRevisionInteroperability>
 8000bc6:	209e      	movs	r0, #158	; 0x9e
 8000bc8:	0040      	lsls	r0, r0, #1
 8000bca:	1820      	adds	r0, r4, r0
 8000bcc:	7801      	ldrb	r1, [r0, #0]
 8000bce:	7842      	ldrb	r2, [r0, #1]
 8000bd0:	0212      	lsls	r2, r2, #8
 8000bd2:	1889      	adds	r1, r1, r2
 8000bd4:	7882      	ldrb	r2, [r0, #2]
 8000bd6:	0412      	lsls	r2, r2, #16
 8000bd8:	1889      	adds	r1, r1, r2
 8000bda:	78c0      	ldrb	r0, [r0, #3]
 8000bdc:	0600      	lsls	r0, r0, #24
 8000bde:	1808      	adds	r0, r1, r0
 8000be0:	9000      	str	r0, [sp, #0]
 8000be2:	2304      	movs	r3, #4
 8000be4:	466a      	mov	r2, sp
 8000be6:	2106      	movs	r1, #6
 8000be8:	68e0      	ldr	r0, [r4, #12]
 8000bea:	4005      	ands	r5, r0
 8000bec:	0028      	movs	r0, r5
 8000bee:	68a5      	ldr	r5, [r4, #8]
 8000bf0:	69ed      	ldr	r5, [r5, #28]
 8000bf2:	47a8      	blx	r5
 8000bf4:	2500      	movs	r5, #0
 8000bf6:	83b5      	strh	r5, [r6, #28]
 8000bf8:	2009      	movs	r0, #9
 8000bfa:	7230      	strb	r0, [r6, #8]
 8000bfc:	2014      	movs	r0, #20
 8000bfe:	4669      	mov	r1, sp
 8000c00:	7308      	strb	r0, [r1, #12]
 8000c02:	8bb0      	ldrh	r0, [r6, #28]
 8000c04:	2180      	movs	r1, #128	; 0x80
 8000c06:	0209      	lsls	r1, r1, #8
 8000c08:	4288      	cmp	r0, r1
 8000c0a:	d163      	bne.n	8000cd4 <__iar_annotation$$branch+0x2dc>
 8000c0c:	e1d3      	b.n	8000fb6 <__iar_annotation$$branch+0x5be>
 8000c0e:	a901      	add	r1, sp, #4
 8000c10:	7b22      	ldrb	r2, [r4, #12]
 8000c12:	07d0      	lsls	r0, r2, #31
 8000c14:	0fc0      	lsrs	r0, r0, #31
 8000c16:	68a2      	ldr	r2, [r4, #8]
 8000c18:	6a12      	ldr	r2, [r2, #32]
 8000c1a:	4790      	blx	r2
 8000c1c:	280a      	cmp	r0, #10
 8000c1e:	d01c      	beq.n	8000c5a <__iar_annotation$$branch+0x262>
 8000c20:	280b      	cmp	r0, #11
 8000c22:	d002      	beq.n	8000c2a <__iar_annotation$$branch+0x232>
 8000c24:	280d      	cmp	r0, #13
 8000c26:	d056      	beq.n	8000cd6 <__iar_annotation$$branch+0x2de>
 8000c28:	e06d      	b.n	8000d06 <__iar_annotation$$branch+0x30e>
 8000c2a:	2000      	movs	r0, #0
 8000c2c:	9000      	str	r0, [sp, #0]
 8000c2e:	230c      	movs	r3, #12
 8000c30:	2202      	movs	r2, #2
 8000c32:	2100      	movs	r1, #0
 8000c34:	0020      	movs	r0, r4
 8000c36:	f002 fd9c 	bl	8003772 <PE_Send_CtrlMessage>
 8000c3a:	4fb8      	ldr	r7, [pc, #736]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000c3c:	7838      	ldrb	r0, [r7, #0]
 8000c3e:	0780      	lsls	r0, r0, #30
 8000c40:	d509      	bpl.n	8000c56 <__iar_annotation$$branch+0x25e>
 8000c42:	2000      	movs	r0, #0
 8000c44:	9000      	str	r0, [sp, #0]
 8000c46:	2300      	movs	r3, #0
 8000c48:	2204      	movs	r2, #4
 8000c4a:	7b20      	ldrb	r0, [r4, #12]
 8000c4c:	07c1      	lsls	r1, r0, #31
 8000c4e:	0fc9      	lsrs	r1, r1, #31
 8000c50:	2009      	movs	r0, #9
 8000c52:	68ff      	ldr	r7, [r7, #12]
 8000c54:	47b8      	blx	r7
 8000c56:	2104      	movs	r1, #4
 8000c58:	e748      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000c5a:	6860      	ldr	r0, [r4, #4]
 8000c5c:	7840      	ldrb	r0, [r0, #1]
 8000c5e:	0640      	lsls	r0, r0, #25
 8000c60:	0f40      	lsrs	r0, r0, #29
 8000c62:	2801      	cmp	r0, #1
 8000c64:	d00c      	beq.n	8000c80 <__iar_annotation$$branch+0x288>
 8000c66:	4668      	mov	r0, sp
 8000c68:	7900      	ldrb	r0, [r0, #4]
 8000c6a:	2803      	cmp	r0, #3
 8000c6c:	d108      	bne.n	8000c80 <__iar_annotation$$branch+0x288>
 8000c6e:	7b20      	ldrb	r0, [r4, #12]
 8000c70:	0700      	lsls	r0, r0, #28
 8000c72:	0f80      	lsrs	r0, r0, #30
 8000c74:	2803      	cmp	r0, #3
 8000c76:	d103      	bne.n	8000c80 <__iar_annotation$$branch+0x288>
 8000c78:	03a8      	lsls	r0, r5, #14
 8000c7a:	8470      	strh	r0, [r6, #34]	; 0x22
 8000c7c:	2500      	movs	r5, #0
 8000c7e:	e002      	b.n	8000c86 <__iar_annotation$$branch+0x28e>
 8000c80:	48a7      	ldr	r0, [pc, #668]	; (8000f20 <__iar_annotation$$branch+0x528>)
 8000c82:	8470      	strh	r0, [r6, #34]	; 0x22
 8000c84:	251e      	movs	r5, #30
 8000c86:	2000      	movs	r0, #0
 8000c88:	9000      	str	r0, [sp, #0]
 8000c8a:	230c      	movs	r3, #12
 8000c8c:	2203      	movs	r2, #3
 8000c8e:	2100      	movs	r1, #0
 8000c90:	0020      	movs	r0, r4
 8000c92:	f002 fd6e 	bl	8003772 <PE_Send_CtrlMessage>
 8000c96:	4fa1      	ldr	r7, [pc, #644]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000c98:	7838      	ldrb	r0, [r7, #0]
 8000c9a:	0780      	lsls	r0, r0, #30
 8000c9c:	d509      	bpl.n	8000cb2 <__iar_annotation$$branch+0x2ba>
 8000c9e:	2000      	movs	r0, #0
 8000ca0:	9000      	str	r0, [sp, #0]
 8000ca2:	2300      	movs	r3, #0
 8000ca4:	2201      	movs	r2, #1
 8000ca6:	7b20      	ldrb	r0, [r4, #12]
 8000ca8:	07c1      	lsls	r1, r0, #31
 8000caa:	0fc9      	lsrs	r1, r1, #31
 8000cac:	2009      	movs	r0, #9
 8000cae:	68ff      	ldr	r7, [r7, #12]
 8000cb0:	47b8      	blx	r7
 8000cb2:	2101      	movs	r1, #1
 8000cb4:	7b22      	ldrb	r2, [r4, #12]
 8000cb6:	07d0      	lsls	r0, r2, #31
 8000cb8:	0fc0      	lsrs	r0, r0, #31
 8000cba:	68a2      	ldr	r2, [r4, #8]
 8000cbc:	68d2      	ldr	r2, [r2, #12]
 8000cbe:	4790      	blx	r2
 8000cc0:	7b21      	ldrb	r1, [r4, #12]
 8000cc2:	20f3      	movs	r0, #243	; 0xf3
 8000cc4:	4008      	ands	r0, r1
 8000cc6:	4669      	mov	r1, sp
 8000cc8:	7909      	ldrb	r1, [r1, #4]
 8000cca:	0089      	lsls	r1, r1, #2
 8000ccc:	220c      	movs	r2, #12
 8000cce:	400a      	ands	r2, r1
 8000cd0:	4302      	orrs	r2, r0
 8000cd2:	7322      	strb	r2, [r4, #12]
 8000cd4:	e676      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000cd6:	2000      	movs	r0, #0
 8000cd8:	9000      	str	r0, [sp, #0]
 8000cda:	2303      	movs	r3, #3
 8000cdc:	220c      	movs	r2, #12
 8000cde:	2100      	movs	r1, #0
 8000ce0:	0020      	movs	r0, r4
 8000ce2:	f002 fd46 	bl	8003772 <PE_Send_CtrlMessage>
 8000ce6:	4f8d      	ldr	r7, [pc, #564]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000ce8:	7838      	ldrb	r0, [r7, #0]
 8000cea:	0780      	lsls	r0, r0, #30
 8000cec:	d509      	bpl.n	8000d02 <__iar_annotation$$branch+0x30a>
 8000cee:	2000      	movs	r0, #0
 8000cf0:	9000      	str	r0, [sp, #0]
 8000cf2:	2300      	movs	r3, #0
 8000cf4:	2203      	movs	r2, #3
 8000cf6:	7b20      	ldrb	r0, [r4, #12]
 8000cf8:	07c1      	lsls	r1, r0, #31
 8000cfa:	0fc9      	lsrs	r1, r1, #31
 8000cfc:	2009      	movs	r0, #9
 8000cfe:	68ff      	ldr	r7, [r7, #12]
 8000d00:	47b8      	blx	r7
 8000d02:	2103      	movs	r1, #3
 8000d04:	e6f2      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000d06:	2000      	movs	r0, #0
 8000d08:	9000      	str	r0, [sp, #0]
 8000d0a:	230e      	movs	r3, #14
 8000d0c:	2204      	movs	r2, #4
 8000d0e:	2100      	movs	r1, #0
 8000d10:	0020      	movs	r0, r4
 8000d12:	f002 fd2e 	bl	8003772 <PE_Send_CtrlMessage>
 8000d16:	4f81      	ldr	r7, [pc, #516]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000d18:	7838      	ldrb	r0, [r7, #0]
 8000d1a:	0780      	lsls	r0, r0, #30
 8000d1c:	d509      	bpl.n	8000d32 <__iar_annotation$$branch+0x33a>
 8000d1e:	2000      	movs	r0, #0
 8000d20:	9000      	str	r0, [sp, #0]
 8000d22:	2300      	movs	r3, #0
 8000d24:	2202      	movs	r2, #2
 8000d26:	7b20      	ldrb	r0, [r4, #12]
 8000d28:	07c1      	lsls	r1, r0, #31
 8000d2a:	0fc9      	lsrs	r1, r1, #31
 8000d2c:	2009      	movs	r0, #9
 8000d2e:	68ff      	ldr	r7, [r7, #12]
 8000d30:	47b8      	blx	r7
 8000d32:	2102      	movs	r1, #2
 8000d34:	e6da      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000d36:	8c71      	ldrh	r1, [r6, #34]	; 0x22
 8000d38:	03aa      	lsls	r2, r5, #14
 8000d3a:	4291      	cmp	r1, r2
 8000d3c:	d1ca      	bne.n	8000cd4 <__iar_annotation$$branch+0x2dc>
 8000d3e:	2100      	movs	r1, #0
 8000d40:	8471      	strh	r1, [r6, #34]	; 0x22
 8000d42:	6861      	ldr	r1, [r4, #4]
 8000d44:	784a      	ldrb	r2, [r1, #1]
 8000d46:	238f      	movs	r3, #143	; 0x8f
 8000d48:	4013      	ands	r3, r2
 8000d4a:	2240      	movs	r2, #64	; 0x40
 8000d4c:	431a      	orrs	r2, r3
 8000d4e:	704a      	strb	r2, [r1, #1]
 8000d50:	2800      	cmp	r0, #0
 8000d52:	d009      	beq.n	8000d68 <__iar_annotation$$branch+0x370>
 8000d54:	2000      	movs	r0, #0
 8000d56:	9000      	str	r0, [sp, #0]
 8000d58:	2300      	movs	r3, #0
 8000d5a:	2256      	movs	r2, #86	; 0x56
 8000d5c:	7b20      	ldrb	r0, [r4, #12]
 8000d5e:	07c1      	lsls	r1, r0, #31
 8000d60:	0fc9      	lsrs	r1, r1, #31
 8000d62:	2009      	movs	r0, #9
 8000d64:	9f01      	ldr	r7, [sp, #4]
 8000d66:	47b8      	blx	r7
 8000d68:	2701      	movs	r7, #1
 8000d6a:	2156      	movs	r1, #86	; 0x56
 8000d6c:	68e2      	ldr	r2, [r4, #12]
 8000d6e:	2001      	movs	r0, #1
 8000d70:	4010      	ands	r0, r2
 8000d72:	68a2      	ldr	r2, [r4, #8]
 8000d74:	68d2      	ldr	r2, [r2, #12]
 8000d76:	4790      	blx	r2
 8000d78:	68a0      	ldr	r0, [r4, #8]
 8000d7a:	6801      	ldr	r1, [r0, #0]
 8000d7c:	2900      	cmp	r1, #0
 8000d7e:	d007      	beq.n	8000d90 <__iar_annotation$$branch+0x398>
 8000d80:	68e0      	ldr	r0, [r4, #12]
 8000d82:	4007      	ands	r7, r0
 8000d84:	0038      	movs	r0, r7
 8000d86:	4788      	blx	r1
 8000d88:	2800      	cmp	r0, #0
 8000d8a:	d001      	beq.n	8000d90 <__iar_annotation$$branch+0x398>
 8000d8c:	200f      	movs	r0, #15
 8000d8e:	7230      	strb	r0, [r6, #8]
 8000d90:	200d      	movs	r0, #13
 8000d92:	e595      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000d94:	2000      	movs	r0, #0
 8000d96:	9000      	str	r0, [sp, #0]
 8000d98:	2303      	movs	r3, #3
 8000d9a:	2206      	movs	r2, #6
 8000d9c:	2100      	movs	r1, #0
 8000d9e:	0020      	movs	r0, r4
 8000da0:	f002 fce7 	bl	8003772 <PE_Send_CtrlMessage>
 8000da4:	2800      	cmp	r0, #0
 8000da6:	d12e      	bne.n	8000e06 <__iar_annotation$$branch+0x40e>
 8000da8:	6860      	ldr	r0, [r4, #4]
 8000daa:	7841      	ldrb	r1, [r0, #1]
 8000dac:	228f      	movs	r2, #143	; 0x8f
 8000dae:	400a      	ands	r2, r1
 8000db0:	2130      	movs	r1, #48	; 0x30
 8000db2:	4311      	orrs	r1, r2
 8000db4:	7041      	strb	r1, [r0, #1]
 8000db6:	4859      	ldr	r0, [pc, #356]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000db8:	7800      	ldrb	r0, [r0, #0]
 8000dba:	0780      	lsls	r0, r0, #30
 8000dbc:	d50a      	bpl.n	8000dd4 <__iar_annotation$$branch+0x3dc>
 8000dbe:	2000      	movs	r0, #0
 8000dc0:	9000      	str	r0, [sp, #0]
 8000dc2:	2300      	movs	r3, #0
 8000dc4:	2256      	movs	r2, #86	; 0x56
 8000dc6:	7b20      	ldrb	r0, [r4, #12]
 8000dc8:	07c1      	lsls	r1, r0, #31
 8000dca:	0fc9      	lsrs	r1, r1, #31
 8000dcc:	2009      	movs	r0, #9
 8000dce:	4f53      	ldr	r7, [pc, #332]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000dd0:	68ff      	ldr	r7, [r7, #12]
 8000dd2:	47b8      	blx	r7
 8000dd4:	2156      	movs	r1, #86	; 0x56
 8000dd6:	7b22      	ldrb	r2, [r4, #12]
 8000dd8:	07d0      	lsls	r0, r2, #31
 8000dda:	0fc0      	lsrs	r0, r0, #31
 8000ddc:	68a2      	ldr	r2, [r4, #8]
 8000dde:	68d2      	ldr	r2, [r2, #12]
 8000de0:	4790      	blx	r2
 8000de2:	4f4e      	ldr	r7, [pc, #312]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000de4:	7838      	ldrb	r0, [r7, #0]
 8000de6:	0780      	lsls	r0, r0, #30
 8000de8:	d509      	bpl.n	8000dfe <__iar_annotation$$branch+0x406>
 8000dea:	2000      	movs	r0, #0
 8000dec:	9000      	str	r0, [sp, #0]
 8000dee:	2300      	movs	r3, #0
 8000df0:	2210      	movs	r2, #16
 8000df2:	7b20      	ldrb	r0, [r4, #12]
 8000df4:	07c1      	lsls	r1, r0, #31
 8000df6:	0fc9      	lsrs	r1, r1, #31
 8000df8:	2009      	movs	r0, #9
 8000dfa:	68ff      	ldr	r7, [r7, #12]
 8000dfc:	47b8      	blx	r7
 8000dfe:	2110      	movs	r1, #16
 8000e00:	e674      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000e02:	2500      	movs	r5, #0
 8000e04:	43ed      	mvns	r5, r5
 8000e06:	e5dd      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000e08:	6860      	ldr	r0, [r4, #4]
 8000e0a:	7840      	ldrb	r0, [r0, #1]
 8000e0c:	0640      	lsls	r0, r0, #25
 8000e0e:	0f40      	lsrs	r0, r0, #29
 8000e10:	2803      	cmp	r0, #3
 8000e12:	d001      	beq.n	8000e18 <__iar_annotation$$branch+0x420>
 8000e14:	200e      	movs	r0, #14
 8000e16:	e553      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000e18:	7a30      	ldrb	r0, [r6, #8]
 8000e1a:	280a      	cmp	r0, #10
 8000e1c:	d007      	beq.n	8000e2e <__iar_annotation$$branch+0x436>
 8000e1e:	7b21      	ldrb	r1, [r4, #12]
 8000e20:	07c8      	lsls	r0, r1, #31
 8000e22:	0fc0      	lsrs	r0, r0, #31
 8000e24:	68a1      	ldr	r1, [r4, #8]
 8000e26:	6909      	ldr	r1, [r1, #16]
 8000e28:	4788      	blx	r1
 8000e2a:	2800      	cmp	r0, #0
 8000e2c:	d101      	bne.n	8000e32 <__iar_annotation$$branch+0x43a>
 8000e2e:	2003      	movs	r0, #3
 8000e30:	e546      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000e32:	200f      	movs	r0, #15
 8000e34:	e544      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000e36:	2001      	movs	r0, #1
 8000e38:	9000      	str	r0, [sp, #0]
 8000e3a:	2397      	movs	r3, #151	; 0x97
 8000e3c:	2202      	movs	r2, #2
 8000e3e:	2100      	movs	r1, #0
 8000e40:	0020      	movs	r0, r4
 8000e42:	f002 fc96 	bl	8003772 <PE_Send_CtrlMessage>
 8000e46:	2800      	cmp	r0, #0
 8000e48:	d11a      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000e4a:	2002      	movs	r0, #2
 8000e4c:	82e0      	strh	r0, [r4, #22]
 8000e4e:	2501      	movs	r5, #1
 8000e50:	4f32      	ldr	r7, [pc, #200]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000e52:	7839      	ldrb	r1, [r7, #0]
 8000e54:	4201      	tst	r1, r0
 8000e56:	d009      	beq.n	8000e6c <__iar_annotation$$branch+0x474>
 8000e58:	2000      	movs	r0, #0
 8000e5a:	9000      	str	r0, [sp, #0]
 8000e5c:	2300      	movs	r3, #0
 8000e5e:	2227      	movs	r2, #39	; 0x27
 8000e60:	68e0      	ldr	r0, [r4, #12]
 8000e62:	2101      	movs	r1, #1
 8000e64:	4001      	ands	r1, r0
 8000e66:	2009      	movs	r0, #9
 8000e68:	68ff      	ldr	r7, [r7, #12]
 8000e6a:	47b8      	blx	r7
 8000e6c:	2127      	movs	r1, #39	; 0x27
 8000e6e:	68e0      	ldr	r0, [r4, #12]
 8000e70:	4005      	ands	r5, r0
 8000e72:	0028      	movs	r0, r5
 8000e74:	68a2      	ldr	r2, [r4, #8]
 8000e76:	68d2      	ldr	r2, [r2, #12]
 8000e78:	4790      	blx	r2
 8000e7a:	48bc      	ldr	r0, [pc, #752]	; (800116c <__iar_annotation$$branch+0x774>)
 8000e7c:	8470      	strh	r0, [r6, #34]	; 0x22
 8000e7e:	4dbc      	ldr	r5, [pc, #752]	; (8001170 <__iar_annotation$$branch+0x778>)
 8000e80:	e5a0      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000e82:	8c71      	ldrh	r1, [r6, #34]	; 0x22
 8000e84:	03aa      	lsls	r2, r5, #14
 8000e86:	4291      	cmp	r1, r2
 8000e88:	d1fa      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000e8a:	2800      	cmp	r0, #0
 8000e8c:	d009      	beq.n	8000ea2 <__iar_annotation$$branch+0x4aa>
 8000e8e:	2000      	movs	r0, #0
 8000e90:	9000      	str	r0, [sp, #0]
 8000e92:	2300      	movs	r3, #0
 8000e94:	2228      	movs	r2, #40	; 0x28
 8000e96:	7b20      	ldrb	r0, [r4, #12]
 8000e98:	07c1      	lsls	r1, r0, #31
 8000e9a:	0fc9      	lsrs	r1, r1, #31
 8000e9c:	2009      	movs	r0, #9
 8000e9e:	9f01      	ldr	r7, [sp, #4]
 8000ea0:	47b8      	blx	r7
 8000ea2:	2128      	movs	r1, #40	; 0x28
 8000ea4:	7b22      	ldrb	r2, [r4, #12]
 8000ea6:	07d0      	lsls	r0, r2, #31
 8000ea8:	0fc0      	lsrs	r0, r0, #31
 8000eaa:	68a2      	ldr	r2, [r4, #8]
 8000eac:	68d2      	ldr	r2, [r2, #12]
 8000eae:	4790      	blx	r2
 8000eb0:	2000      	movs	r0, #0
 8000eb2:	9000      	str	r0, [sp, #0]
 8000eb4:	2303      	movs	r3, #3
 8000eb6:	2206      	movs	r2, #6
 8000eb8:	2100      	movs	r1, #0
 8000eba:	0020      	movs	r0, r4
 8000ebc:	f002 fc59 	bl	8003772 <PE_Send_CtrlMessage>
 8000ec0:	2800      	cmp	r0, #0
 8000ec2:	d1dd      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000ec4:	4f15      	ldr	r7, [pc, #84]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000ec6:	7838      	ldrb	r0, [r7, #0]
 8000ec8:	0780      	lsls	r0, r0, #30
 8000eca:	d509      	bpl.n	8000ee0 <__iar_annotation$$branch+0x4e8>
 8000ecc:	2000      	movs	r0, #0
 8000ece:	9000      	str	r0, [sp, #0]
 8000ed0:	2300      	movs	r3, #0
 8000ed2:	222c      	movs	r2, #44	; 0x2c
 8000ed4:	7b20      	ldrb	r0, [r4, #12]
 8000ed6:	07c1      	lsls	r1, r0, #31
 8000ed8:	0fc9      	lsrs	r1, r1, #31
 8000eda:	2009      	movs	r0, #9
 8000edc:	68ff      	ldr	r7, [r7, #12]
 8000ede:	47b8      	blx	r7
 8000ee0:	212c      	movs	r1, #44	; 0x2c
 8000ee2:	e603      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000ee4:	0020      	movs	r0, r4
 8000ee6:	f002 fd2a 	bl	800393e <PE_PerformSoftReset>
 8000eea:	2000      	movs	r0, #0
 8000eec:	9000      	str	r0, [sp, #0]
 8000eee:	2307      	movs	r3, #7
 8000ef0:	2203      	movs	r2, #3
 8000ef2:	2100      	movs	r1, #0
 8000ef4:	0020      	movs	r0, r4
 8000ef6:	f002 fc3c 	bl	8003772 <PE_Send_CtrlMessage>
 8000efa:	4f08      	ldr	r7, [pc, #32]	; (8000f1c <__iar_annotation$$branch+0x524>)
 8000efc:	7838      	ldrb	r0, [r7, #0]
 8000efe:	0780      	lsls	r0, r0, #30
 8000f00:	d509      	bpl.n	8000f16 <__iar_annotation$$branch+0x51e>
 8000f02:	2000      	movs	r0, #0
 8000f04:	9000      	str	r0, [sp, #0]
 8000f06:	2300      	movs	r3, #0
 8000f08:	222f      	movs	r2, #47	; 0x2f
 8000f0a:	7b20      	ldrb	r0, [r4, #12]
 8000f0c:	07c1      	lsls	r1, r0, #31
 8000f0e:	0fc9      	lsrs	r1, r1, #31
 8000f10:	2009      	movs	r0, #9
 8000f12:	68ff      	ldr	r7, [r7, #12]
 8000f14:	47b8      	blx	r7
 8000f16:	212f      	movs	r1, #47	; 0x2f
 8000f18:	e5e8      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000f1a:	bf00      	nop
 8000f1c:	200019a8 	.word	0x200019a8
 8000f20:	0000801e 	.word	0x0000801e
 8000f24:	2000      	movs	r0, #0
 8000f26:	9000      	str	r0, [sp, #0]
 8000f28:	2312      	movs	r3, #18
 8000f2a:	220d      	movs	r2, #13
 8000f2c:	2100      	movs	r1, #0
 8000f2e:	0020      	movs	r0, r4
 8000f30:	f002 fc1f 	bl	8003772 <PE_Send_CtrlMessage>
 8000f34:	2800      	cmp	r0, #0
 8000f36:	d1a3      	bne.n	8000e80 <__iar_annotation$$branch+0x488>
 8000f38:	488e      	ldr	r0, [pc, #568]	; (8001174 <__iar_annotation$$branch+0x77c>)
 8000f3a:	83b0      	strh	r0, [r6, #28]
 8000f3c:	251a      	movs	r5, #26
 8000f3e:	4f8e      	ldr	r7, [pc, #568]	; (8001178 <__iar_annotation$$branch+0x780>)
 8000f40:	7838      	ldrb	r0, [r7, #0]
 8000f42:	0780      	lsls	r0, r0, #30
 8000f44:	d509      	bpl.n	8000f5a <__iar_annotation$$branch+0x562>
 8000f46:	2000      	movs	r0, #0
 8000f48:	9000      	str	r0, [sp, #0]
 8000f4a:	2300      	movs	r3, #0
 8000f4c:	222e      	movs	r2, #46	; 0x2e
 8000f4e:	7b20      	ldrb	r0, [r4, #12]
 8000f50:	07c1      	lsls	r1, r0, #31
 8000f52:	0fc9      	lsrs	r1, r1, #31
 8000f54:	2009      	movs	r0, #9
 8000f56:	68ff      	ldr	r7, [r7, #12]
 8000f58:	47b8      	blx	r7
 8000f5a:	212e      	movs	r1, #46	; 0x2e
 8000f5c:	e5c6      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8000f5e:	2911      	cmp	r1, #17
 8000f60:	d124      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f62:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000f64:	0bc9      	lsrs	r1, r1, #15
 8000f66:	d121      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f68:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000f6a:	0b09      	lsrs	r1, r1, #12
 8000f6c:	0749      	lsls	r1, r1, #29
 8000f6e:	d11d      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f70:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8000f72:	06c9      	lsls	r1, r1, #27
 8000f74:	0ec9      	lsrs	r1, r1, #27
 8000f76:	2903      	cmp	r1, #3
 8000f78:	d118      	bne.n	8000fac <__iar_annotation$$branch+0x5b4>
 8000f7a:	2100      	movs	r1, #0
 8000f7c:	83b1      	strh	r1, [r6, #28]
 8000f7e:	2800      	cmp	r0, #0
 8000f80:	d008      	beq.n	8000f94 <__iar_annotation$$branch+0x59c>
 8000f82:	9100      	str	r1, [sp, #0]
 8000f84:	2300      	movs	r3, #0
 8000f86:	222f      	movs	r2, #47	; 0x2f
 8000f88:	7b20      	ldrb	r0, [r4, #12]
 8000f8a:	07c1      	lsls	r1, r0, #31
 8000f8c:	0fc9      	lsrs	r1, r1, #31
 8000f8e:	2009      	movs	r0, #9
 8000f90:	9f01      	ldr	r7, [sp, #4]
 8000f92:	47b8      	blx	r7
 8000f94:	212f      	movs	r1, #47	; 0x2f
 8000f96:	7b22      	ldrb	r2, [r4, #12]
 8000f98:	07d0      	lsls	r0, r2, #31
 8000f9a:	0fc0      	lsrs	r0, r0, #31
 8000f9c:	68a2      	ldr	r2, [r4, #8]
 8000f9e:	68d2      	ldr	r2, [r2, #12]
 8000fa0:	4790      	blx	r2
 8000fa2:	2007      	movs	r0, #7
 8000fa4:	7230      	strb	r0, [r6, #8]
 8000fa6:	2014      	movs	r0, #20
 8000fa8:	4669      	mov	r1, sp
 8000faa:	7308      	strb	r0, [r1, #12]
 8000fac:	8bb0      	ldrh	r0, [r6, #28]
 8000fae:	03a9      	lsls	r1, r5, #14
 8000fb0:	4288      	cmp	r0, r1
 8000fb2:	d000      	beq.n	8000fb6 <__iar_annotation$$branch+0x5be>
 8000fb4:	e506      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 8000fb6:	2000      	movs	r0, #0
 8000fb8:	83b0      	strh	r0, [r6, #28]
 8000fba:	e73a      	b.n	8000e32 <__iar_annotation$$branch+0x43a>
 8000fbc:	7b60      	ldrb	r0, [r4, #13]
 8000fbe:	21fc      	movs	r1, #252	; 0xfc
 8000fc0:	4001      	ands	r1, r0
 8000fc2:	7361      	strb	r1, [r4, #13]
 8000fc4:	0020      	movs	r0, r4
 8000fc6:	f002 fc81 	bl	80038cc <PE_Send_HARDRESET>
 8000fca:	68a0      	ldr	r0, [r4, #8]
 8000fcc:	6843      	ldr	r3, [r0, #4]
 8000fce:	2b00      	cmp	r3, #0
 8000fd0:	d005      	beq.n	8000fde <__iar_annotation$$branch+0x5e6>
 8000fd2:	2202      	movs	r2, #2
 8000fd4:	2101      	movs	r1, #1
 8000fd6:	7b25      	ldrb	r5, [r4, #12]
 8000fd8:	07e8      	lsls	r0, r5, #31
 8000fda:	0fc0      	lsrs	r0, r0, #31
 8000fdc:	4798      	blx	r3
 8000fde:	4867      	ldr	r0, [pc, #412]	; (800117c <__iar_annotation$$branch+0x784>)
 8000fe0:	82f0      	strh	r0, [r6, #22]
 8000fe2:	251b      	movs	r5, #27
 8000fe4:	7d20      	ldrb	r0, [r4, #20]
 8000fe6:	1c40      	adds	r0, r0, #1
 8000fe8:	7520      	strb	r0, [r4, #20]
 8000fea:	6860      	ldr	r0, [r4, #4]
 8000fec:	6801      	ldr	r1, [r0, #0]
 8000fee:	2210      	movs	r2, #16
 8000ff0:	4391      	bics	r1, r2
 8000ff2:	6001      	str	r1, [r0, #0]
 8000ff4:	2000      	movs	r0, #0
 8000ff6:	7130      	strb	r0, [r6, #4]
 8000ff8:	2015      	movs	r0, #21
 8000ffa:	e461      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8000ffc:	495f      	ldr	r1, [pc, #380]	; (800117c <__iar_annotation$$branch+0x784>)
 8000ffe:	82f1      	strh	r1, [r6, #22]
 8001000:	251b      	movs	r5, #27
 8001002:	2115      	movs	r1, #21
 8001004:	7231      	strb	r1, [r6, #8]
 8001006:	2800      	cmp	r0, #0
 8001008:	d009      	beq.n	800101e <__iar_annotation$$branch+0x626>
 800100a:	2000      	movs	r0, #0
 800100c:	9000      	str	r0, [sp, #0]
 800100e:	2300      	movs	r3, #0
 8001010:	221d      	movs	r2, #29
 8001012:	7b20      	ldrb	r0, [r4, #12]
 8001014:	07c1      	lsls	r1, r0, #31
 8001016:	0fc9      	lsrs	r1, r1, #31
 8001018:	2009      	movs	r0, #9
 800101a:	9f01      	ldr	r7, [sp, #4]
 800101c:	47b8      	blx	r7
 800101e:	211d      	movs	r1, #29
 8001020:	e564      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8001022:	8af0      	ldrh	r0, [r6, #22]
 8001024:	03a9      	lsls	r1, r5, #14
 8001026:	4288      	cmp	r0, r1
 8001028:	d150      	bne.n	80010cc <__iar_annotation$$branch+0x6d4>
 800102a:	2000      	movs	r0, #0
 800102c:	82f0      	strh	r0, [r6, #22]
 800102e:	7d21      	ldrb	r1, [r4, #20]
 8001030:	2903      	cmp	r1, #3
 8001032:	d311      	bcc.n	8001058 <__iar_annotation$$branch+0x660>
 8001034:	7520      	strb	r0, [r4, #20]
 8001036:	7230      	strb	r0, [r6, #8]
 8001038:	4f4f      	ldr	r7, [pc, #316]	; (8001178 <__iar_annotation$$branch+0x780>)
 800103a:	7838      	ldrb	r0, [r7, #0]
 800103c:	0780      	lsls	r0, r0, #30
 800103e:	d509      	bpl.n	8001054 <__iar_annotation$$branch+0x65c>
 8001040:	2000      	movs	r0, #0
 8001042:	9000      	str	r0, [sp, #0]
 8001044:	2300      	movs	r3, #0
 8001046:	2220      	movs	r2, #32
 8001048:	7b20      	ldrb	r0, [r4, #12]
 800104a:	07c1      	lsls	r1, r0, #31
 800104c:	0fc9      	lsrs	r1, r1, #31
 800104e:	2009      	movs	r0, #9
 8001050:	68ff      	ldr	r7, [r7, #12]
 8001052:	47b8      	blx	r7
 8001054:	2120      	movs	r1, #32
 8001056:	e549      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 8001058:	68a0      	ldr	r0, [r4, #8]
 800105a:	6843      	ldr	r3, [r0, #4]
 800105c:	2b00      	cmp	r3, #0
 800105e:	d00a      	beq.n	8001076 <__iar_annotation$$branch+0x67e>
 8001060:	7b60      	ldrb	r0, [r4, #13]
 8001062:	0780      	lsls	r0, r0, #30
 8001064:	0f80      	lsrs	r0, r0, #30
 8001066:	1e42      	subs	r2, r0, #1
 8001068:	4192      	sbcs	r2, r2
 800106a:	0fd2      	lsrs	r2, r2, #31
 800106c:	2101      	movs	r1, #1
 800106e:	7b25      	ldrb	r5, [r4, #12]
 8001070:	07e8      	lsls	r0, r5, #31
 8001072:	0fc0      	lsrs	r0, r0, #31
 8001074:	4798      	blx	r3
 8001076:	4842      	ldr	r0, [pc, #264]	; (8001180 <__iar_annotation$$branch+0x788>)
 8001078:	9904      	ldr	r1, [sp, #16]
 800107a:	8008      	strh	r0, [r1, #0]
 800107c:	25c8      	movs	r5, #200	; 0xc8
 800107e:	00ad      	lsls	r5, r5, #2
 8001080:	2013      	movs	r0, #19
 8001082:	e41d      	b.n	80008c0 <__iar_annotation$$branch+0xe4>
 8001084:	68a0      	ldr	r0, [r4, #8]
 8001086:	6843      	ldr	r3, [r0, #4]
 8001088:	2701      	movs	r7, #1
 800108a:	2b00      	cmp	r3, #0
 800108c:	d005      	beq.n	800109a <__iar_annotation$$branch+0x6a2>
 800108e:	2204      	movs	r2, #4
 8001090:	68e1      	ldr	r1, [r4, #12]
 8001092:	2001      	movs	r0, #1
 8001094:	4008      	ands	r0, r1
 8001096:	2101      	movs	r1, #1
 8001098:	4798      	blx	r3
 800109a:	8ab0      	ldrh	r0, [r6, #20]
 800109c:	03a9      	lsls	r1, r5, #14
 800109e:	4288      	cmp	r0, r1
 80010a0:	d114      	bne.n	80010cc <__iar_annotation$$branch+0x6d4>
 80010a2:	2000      	movs	r0, #0
 80010a4:	9904      	ldr	r1, [sp, #16]
 80010a6:	8008      	strh	r0, [r1, #0]
 80010a8:	68a0      	ldr	r0, [r4, #8]
 80010aa:	6843      	ldr	r3, [r0, #4]
 80010ac:	2b00      	cmp	r3, #0
 80010ae:	d005      	beq.n	80010bc <__iar_annotation$$branch+0x6c4>
 80010b0:	2205      	movs	r2, #5
 80010b2:	2101      	movs	r1, #1
 80010b4:	68e0      	ldr	r0, [r4, #12]
 80010b6:	4007      	ands	r7, r0
 80010b8:	0038      	movs	r0, r7
 80010ba:	4798      	blx	r3
 80010bc:	4831      	ldr	r0, [pc, #196]	; (8001184 <__iar_annotation$$branch+0x78c>)
 80010be:	83f0      	strh	r0, [r6, #30]
 80010c0:	2101      	movs	r1, #1
 80010c2:	a80a      	add	r0, sp, #40	; 0x28
 80010c4:	7800      	ldrb	r0, [r0, #0]
 80010c6:	f003 f862 	bl	800418e <PE_Reset>
 80010ca:	7235      	strb	r5, [r6, #8]
 80010cc:	e47a      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80010ce:	2011      	movs	r0, #17
 80010d0:	82e0      	strh	r0, [r4, #22]
 80010d2:	2105      	movs	r1, #5
 80010d4:	7b22      	ldrb	r2, [r4, #12]
 80010d6:	07d0      	lsls	r0, r2, #31
 80010d8:	0fc0      	lsrs	r0, r0, #31
 80010da:	f004 f9aa 	bl	8005432 <USBDPD_PRL_BistCarrierEyeMode>
 80010de:	2028      	movs	r0, #40	; 0x28
 80010e0:	7230      	strb	r0, [r6, #8]
 80010e2:	4829      	ldr	r0, [pc, #164]	; (8001188 <__iar_annotation$$branch+0x790>)
 80010e4:	85b0      	strh	r0, [r6, #44]	; 0x2c
 80010e6:	253a      	movs	r5, #58	; 0x3a
 80010e8:	e46c      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 80010ea:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 80010ec:	03a9      	lsls	r1, r5, #14
 80010ee:	4288      	cmp	r0, r1
 80010f0:	d1fa      	bne.n	80010e8 <__iar_annotation$$branch+0x6f0>
 80010f2:	2105      	movs	r1, #5
 80010f4:	7b22      	ldrb	r2, [r4, #12]
 80010f6:	07d0      	lsls	r0, r2, #31
 80010f8:	0fc0      	lsrs	r0, r0, #31
 80010fa:	f004 f9a2 	bl	8005442 <USBDPD_PRL_BistCarrierEyeModeExit>
 80010fe:	2000      	movs	r0, #0
 8001100:	85b0      	strh	r0, [r6, #44]	; 0x2c
 8001102:	e694      	b.n	8000e2e <__iar_annotation$$branch+0x436>
 8001104:	2911      	cmp	r1, #17
 8001106:	d10e      	bne.n	8001126 <__iar_annotation$$branch+0x72e>
 8001108:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800110a:	0bc0      	lsrs	r0, r0, #15
 800110c:	d10b      	bne.n	8001126 <__iar_annotation$$branch+0x72e>
 800110e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001110:	0b00      	lsrs	r0, r0, #12
 8001112:	0740      	lsls	r0, r0, #29
 8001114:	d007      	beq.n	8001126 <__iar_annotation$$branch+0x72e>
 8001116:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001118:	06c0      	lsls	r0, r0, #27
 800111a:	0ec0      	lsrs	r0, r0, #27
 800111c:	2803      	cmp	r0, #3
 800111e:	d102      	bne.n	8001126 <__iar_annotation$$branch+0x72e>
 8001120:	2014      	movs	r0, #20
 8001122:	4669      	mov	r1, sp
 8001124:	7308      	strb	r0, [r1, #12]
 8001126:	2011      	movs	r0, #17
 8001128:	82e0      	strh	r0, [r4, #22]
 800112a:	e44b      	b.n	80009c4 <__iar_annotation$$branch+0x1e8>
 800112c:	2000      	movs	r0, #0
 800112e:	9000      	str	r0, [sp, #0]
 8001130:	2319      	movs	r3, #25
 8001132:	2208      	movs	r2, #8
 8001134:	2100      	movs	r1, #0
 8001136:	0020      	movs	r0, r4
 8001138:	f002 fb1b 	bl	8003772 <PE_Send_CtrlMessage>
 800113c:	2800      	cmp	r0, #0
 800113e:	d1f4      	bne.n	800112a <__iar_annotation$$branch+0x732>
 8001140:	2007      	movs	r0, #7
 8001142:	82e0      	strh	r0, [r4, #22]
 8001144:	480b      	ldr	r0, [pc, #44]	; (8001174 <__iar_annotation$$branch+0x77c>)
 8001146:	83b0      	strh	r0, [r6, #28]
 8001148:	251a      	movs	r5, #26
 800114a:	4f0b      	ldr	r7, [pc, #44]	; (8001178 <__iar_annotation$$branch+0x780>)
 800114c:	7838      	ldrb	r0, [r7, #0]
 800114e:	0780      	lsls	r0, r0, #30
 8001150:	d509      	bpl.n	8001166 <__iar_annotation$$branch+0x76e>
 8001152:	2000      	movs	r0, #0
 8001154:	9000      	str	r0, [sp, #0]
 8001156:	2300      	movs	r3, #0
 8001158:	2205      	movs	r2, #5
 800115a:	7b20      	ldrb	r0, [r4, #12]
 800115c:	07c1      	lsls	r1, r0, #31
 800115e:	0fc9      	lsrs	r1, r1, #31
 8001160:	2009      	movs	r0, #9
 8001162:	68ff      	ldr	r7, [r7, #12]
 8001164:	47b8      	blx	r7
 8001166:	2105      	movs	r1, #5
 8001168:	e4c0      	b.n	8000aec <__iar_annotation$$branch+0xf4>
 800116a:	bf00      	nop
 800116c:	00008226 	.word	0x00008226
 8001170:	00000226 	.word	0x00000226
 8001174:	0000801a 	.word	0x0000801a
 8001178:	200019a8 	.word	0x200019a8
 800117c:	0000801b 	.word	0x0000801b
 8001180:	00008320 	.word	0x00008320
 8001184:	0000957c 	.word	0x0000957c
 8001188:	0000803a 	.word	0x0000803a
 800118c:	2911      	cmp	r1, #17
 800118e:	d15e      	bne.n	800124e <__iar_annotation$$branch+0x856>
 8001190:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001192:	0bc0      	lsrs	r0, r0, #15
 8001194:	d133      	bne.n	80011fe <__iar_annotation$$branch+0x806>
 8001196:	2007      	movs	r0, #7
 8001198:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800119a:	0b09      	lsrs	r1, r1, #12
 800119c:	4201      	tst	r1, r0
 800119e:	d02e      	beq.n	80011fe <__iar_annotation$$branch+0x806>
 80011a0:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80011a2:	06c9      	lsls	r1, r1, #27
 80011a4:	0ec9      	lsrs	r1, r1, #27
 80011a6:	2904      	cmp	r1, #4
 80011a8:	d129      	bne.n	80011fe <__iar_annotation$$branch+0x806>
 80011aa:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80011ac:	0b09      	lsrs	r1, r1, #12
 80011ae:	4008      	ands	r0, r1
 80011b0:	0083      	lsls	r3, r0, #2
 80011b2:	209e      	movs	r0, #158	; 0x9e
 80011b4:	0040      	lsls	r0, r0, #1
 80011b6:	1822      	adds	r2, r4, r0
 80011b8:	2105      	movs	r1, #5
 80011ba:	7b27      	ldrb	r7, [r4, #12]
 80011bc:	07f8      	lsls	r0, r7, #31
 80011be:	0fc0      	lsrs	r0, r0, #31
 80011c0:	68a7      	ldr	r7, [r4, #8]
 80011c2:	69ff      	ldr	r7, [r7, #28]
 80011c4:	47b8      	blx	r7
 80011c6:	2000      	movs	r0, #0
 80011c8:	83b0      	strh	r0, [r6, #28]
 80011ca:	2003      	movs	r0, #3
 80011cc:	7230      	strb	r0, [r6, #8]
 80011ce:	2014      	movs	r0, #20
 80011d0:	4669      	mov	r1, sp
 80011d2:	7308      	strb	r0, [r1, #12]
 80011d4:	4fd0      	ldr	r7, [pc, #832]	; (8001518 <__iar_annotation$$branch+0xb20>)
 80011d6:	7838      	ldrb	r0, [r7, #0]
 80011d8:	0780      	lsls	r0, r0, #30
 80011da:	d509      	bpl.n	80011f0 <__iar_annotation$$branch+0x7f8>
 80011dc:	2000      	movs	r0, #0
 80011de:	9000      	str	r0, [sp, #0]
 80011e0:	2300      	movs	r3, #0
 80011e2:	2207      	movs	r2, #7
 80011e4:	7b20      	ldrb	r0, [r4, #12]
 80011e6:	07c1      	lsls	r1, r0, #31
 80011e8:	0fc9      	lsrs	r1, r1, #31
 80011ea:	2009      	movs	r0, #9
 80011ec:	68ff      	ldr	r7, [r7, #12]
 80011ee:	47b8      	blx	r7
 80011f0:	2107      	movs	r1, #7
 80011f2:	7b22      	ldrb	r2, [r4, #12]
 80011f4:	07d0      	lsls	r0, r2, #31
 80011f6:	0fc0      	lsrs	r0, r0, #31
 80011f8:	68a2      	ldr	r2, [r4, #8]
 80011fa:	68d2      	ldr	r2, [r2, #12]
 80011fc:	4790      	blx	r2
 80011fe:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001200:	0bc0      	lsrs	r0, r0, #15
 8001202:	d124      	bne.n	800124e <__iar_annotation$$branch+0x856>
 8001204:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001206:	0b00      	lsrs	r0, r0, #12
 8001208:	0740      	lsls	r0, r0, #29
 800120a:	d120      	bne.n	800124e <__iar_annotation$$branch+0x856>
 800120c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800120e:	06c0      	lsls	r0, r0, #27
 8001210:	0ec0      	lsrs	r0, r0, #27
 8001212:	2804      	cmp	r0, #4
 8001214:	d11b      	bne.n	800124e <__iar_annotation$$branch+0x856>
 8001216:	2000      	movs	r0, #0
 8001218:	83b0      	strh	r0, [r6, #28]
 800121a:	2003      	movs	r0, #3
 800121c:	7230      	strb	r0, [r6, #8]
 800121e:	2014      	movs	r0, #20
 8001220:	4669      	mov	r1, sp
 8001222:	7308      	strb	r0, [r1, #12]
 8001224:	4fbc      	ldr	r7, [pc, #752]	; (8001518 <__iar_annotation$$branch+0xb20>)
 8001226:	7838      	ldrb	r0, [r7, #0]
 8001228:	0780      	lsls	r0, r0, #30
 800122a:	d509      	bpl.n	8001240 <__iar_annotation$$branch+0x848>
 800122c:	2000      	movs	r0, #0
 800122e:	9000      	str	r0, [sp, #0]
 8001230:	2300      	movs	r3, #0
 8001232:	2208      	movs	r2, #8
 8001234:	7b20      	ldrb	r0, [r4, #12]
 8001236:	07c1      	lsls	r1, r0, #31
 8001238:	0fc9      	lsrs	r1, r1, #31
 800123a:	2009      	movs	r0, #9
 800123c:	68ff      	ldr	r7, [r7, #12]
 800123e:	47b8      	blx	r7
 8001240:	2108      	movs	r1, #8
 8001242:	7b22      	ldrb	r2, [r4, #12]
 8001244:	07d0      	lsls	r0, r2, #31
 8001246:	0fc0      	lsrs	r0, r0, #31
 8001248:	68a2      	ldr	r2, [r4, #8]
 800124a:	68d2      	ldr	r2, [r2, #12]
 800124c:	4790      	blx	r2
 800124e:	8bb0      	ldrh	r0, [r6, #28]
 8001250:	03a9      	lsls	r1, r5, #14
 8001252:	4288      	cmp	r0, r1
 8001254:	d11e      	bne.n	8001294 <__iar_annotation$$branch+0x89c>
 8001256:	4fb0      	ldr	r7, [pc, #704]	; (8001518 <__iar_annotation$$branch+0xb20>)
 8001258:	7838      	ldrb	r0, [r7, #0]
 800125a:	0780      	lsls	r0, r0, #30
 800125c:	d509      	bpl.n	8001272 <__iar_annotation$$branch+0x87a>
 800125e:	2000      	movs	r0, #0
 8001260:	9000      	str	r0, [sp, #0]
 8001262:	2300      	movs	r3, #0
 8001264:	2209      	movs	r2, #9
 8001266:	7b20      	ldrb	r0, [r4, #12]
 8001268:	07c1      	lsls	r1, r0, #31
 800126a:	0fc9      	lsrs	r1, r1, #31
 800126c:	2009      	movs	r0, #9
 800126e:	68ff      	ldr	r7, [r7, #12]
 8001270:	47b8      	blx	r7
 8001272:	2109      	movs	r1, #9
 8001274:	7b22      	ldrb	r2, [r4, #12]
 8001276:	07d0      	lsls	r0, r2, #31
 8001278:	0fc0      	lsrs	r0, r0, #31
 800127a:	68a2      	ldr	r2, [r4, #8]
 800127c:	68d2      	ldr	r2, [r2, #12]
 800127e:	4790      	blx	r2
 8001280:	e5d5      	b.n	8000e2e <__iar_annotation$$branch+0x436>
 8001282:	2001      	movs	r0, #1
 8001284:	9000      	str	r0, [sp, #0]
 8001286:	231b      	movs	r3, #27
 8001288:	2207      	movs	r2, #7
 800128a:	2100      	movs	r1, #0
 800128c:	0020      	movs	r0, r4
 800128e:	f002 fa70 	bl	8003772 <PE_Send_CtrlMessage>
 8001292:	2800      	cmp	r0, #0
 8001294:	d000      	beq.n	8001298 <__iar_annotation$$branch+0x8a0>
 8001296:	e748      	b.n	800112a <__iar_annotation$$branch+0x732>
 8001298:	2006      	movs	r0, #6
 800129a:	82e0      	strh	r0, [r4, #22]
 800129c:	489f      	ldr	r0, [pc, #636]	; (800151c <__iar_annotation$$branch+0xb24>)
 800129e:	83b0      	strh	r0, [r6, #28]
 80012a0:	251a      	movs	r5, #26
 80012a2:	4f9d      	ldr	r7, [pc, #628]	; (8001518 <__iar_annotation$$branch+0xb20>)
 80012a4:	7838      	ldrb	r0, [r7, #0]
 80012a6:	0780      	lsls	r0, r0, #30
 80012a8:	d509      	bpl.n	80012be <__iar_annotation$$branch+0x8c6>
 80012aa:	2000      	movs	r0, #0
 80012ac:	9000      	str	r0, [sp, #0]
 80012ae:	2300      	movs	r3, #0
 80012b0:	220b      	movs	r2, #11
 80012b2:	7b20      	ldrb	r0, [r4, #12]
 80012b4:	07c1      	lsls	r1, r0, #31
 80012b6:	0fc9      	lsrs	r1, r1, #31
 80012b8:	2009      	movs	r0, #9
 80012ba:	68ff      	ldr	r7, [r7, #12]
 80012bc:	47b8      	blx	r7
 80012be:	210b      	movs	r1, #11
 80012c0:	e752      	b.n	8001168 <__iar_annotation$$branch+0x770>
 80012c2:	2911      	cmp	r1, #17
 80012c4:	d162      	bne.n	800138c <__iar_annotation$$branch+0x994>
 80012c6:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 80012c8:	0bc0      	lsrs	r0, r0, #15
 80012ca:	d133      	bne.n	8001334 <__iar_annotation$$branch+0x93c>
 80012cc:	2007      	movs	r0, #7
 80012ce:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80012d0:	0b09      	lsrs	r1, r1, #12
 80012d2:	4201      	tst	r1, r0
 80012d4:	d02e      	beq.n	8001334 <__iar_annotation$$branch+0x93c>
 80012d6:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80012d8:	06c9      	lsls	r1, r1, #27
 80012da:	0ec9      	lsrs	r1, r1, #27
 80012dc:	2901      	cmp	r1, #1
 80012de:	d129      	bne.n	8001334 <__iar_annotation$$branch+0x93c>
 80012e0:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80012e2:	0b09      	lsrs	r1, r1, #12
 80012e4:	4008      	ands	r0, r1
 80012e6:	0083      	lsls	r3, r0, #2
 80012e8:	209e      	movs	r0, #158	; 0x9e
 80012ea:	0040      	lsls	r0, r0, #1
 80012ec:	1822      	adds	r2, r4, r0
 80012ee:	2104      	movs	r1, #4
 80012f0:	7b27      	ldrb	r7, [r4, #12]
 80012f2:	07f8      	lsls	r0, r7, #31
 80012f4:	0fc0      	lsrs	r0, r0, #31
 80012f6:	68a7      	ldr	r7, [r4, #8]
 80012f8:	69ff      	ldr	r7, [r7, #28]
 80012fa:	47b8      	blx	r7
 80012fc:	2000      	movs	r0, #0
 80012fe:	83b0      	strh	r0, [r6, #28]
 8001300:	2003      	movs	r0, #3
 8001302:	7230      	strb	r0, [r6, #8]
 8001304:	2014      	movs	r0, #20
 8001306:	4669      	mov	r1, sp
 8001308:	7308      	strb	r0, [r1, #12]
 800130a:	4f83      	ldr	r7, [pc, #524]	; (8001518 <__iar_annotation$$branch+0xb20>)
 800130c:	7838      	ldrb	r0, [r7, #0]
 800130e:	0780      	lsls	r0, r0, #30
 8001310:	d509      	bpl.n	8001326 <__iar_annotation$$branch+0x92e>
 8001312:	2000      	movs	r0, #0
 8001314:	9000      	str	r0, [sp, #0]
 8001316:	2300      	movs	r3, #0
 8001318:	220d      	movs	r2, #13
 800131a:	7b20      	ldrb	r0, [r4, #12]
 800131c:	07c1      	lsls	r1, r0, #31
 800131e:	0fc9      	lsrs	r1, r1, #31
 8001320:	2009      	movs	r0, #9
 8001322:	68ff      	ldr	r7, [r7, #12]
 8001324:	47b8      	blx	r7
 8001326:	210d      	movs	r1, #13
 8001328:	7b22      	ldrb	r2, [r4, #12]
 800132a:	07d0      	lsls	r0, r2, #31
 800132c:	0fc0      	lsrs	r0, r0, #31
 800132e:	68a2      	ldr	r2, [r4, #8]
 8001330:	68d2      	ldr	r2, [r2, #12]
 8001332:	4790      	blx	r2
 8001334:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001336:	0bc0      	lsrs	r0, r0, #15
 8001338:	d128      	bne.n	800138c <__iar_annotation$$branch+0x994>
 800133a:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800133c:	0b00      	lsrs	r0, r0, #12
 800133e:	0740      	lsls	r0, r0, #29
 8001340:	d124      	bne.n	800138c <__iar_annotation$$branch+0x994>
 8001342:	201f      	movs	r0, #31
 8001344:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8001346:	4001      	ands	r1, r0
 8001348:	2904      	cmp	r1, #4
 800134a:	d003      	beq.n	8001354 <__iar_annotation$$branch+0x95c>
 800134c:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800134e:	4008      	ands	r0, r1
 8001350:	2810      	cmp	r0, #16
 8001352:	d11b      	bne.n	800138c <__iar_annotation$$branch+0x994>
 8001354:	2000      	movs	r0, #0
 8001356:	83b0      	strh	r0, [r6, #28]
 8001358:	2003      	movs	r0, #3
 800135a:	7230      	strb	r0, [r6, #8]
 800135c:	2014      	movs	r0, #20
 800135e:	4669      	mov	r1, sp
 8001360:	7308      	strb	r0, [r1, #12]
 8001362:	4f6d      	ldr	r7, [pc, #436]	; (8001518 <__iar_annotation$$branch+0xb20>)
 8001364:	7838      	ldrb	r0, [r7, #0]
 8001366:	0780      	lsls	r0, r0, #30
 8001368:	d509      	bpl.n	800137e <__iar_annotation$$branch+0x986>
 800136a:	2000      	movs	r0, #0
 800136c:	9000      	str	r0, [sp, #0]
 800136e:	2300      	movs	r3, #0
 8001370:	220e      	movs	r2, #14
 8001372:	7b20      	ldrb	r0, [r4, #12]
 8001374:	07c1      	lsls	r1, r0, #31
 8001376:	0fc9      	lsrs	r1, r1, #31
 8001378:	2009      	movs	r0, #9
 800137a:	68ff      	ldr	r7, [r7, #12]
 800137c:	47b8      	blx	r7
 800137e:	210e      	movs	r1, #14
 8001380:	7b22      	ldrb	r2, [r4, #12]
 8001382:	07d0      	lsls	r0, r2, #31
 8001384:	0fc0      	lsrs	r0, r0, #31
 8001386:	68a2      	ldr	r2, [r4, #8]
 8001388:	68d2      	ldr	r2, [r2, #12]
 800138a:	4790      	blx	r2
 800138c:	8bb0      	ldrh	r0, [r6, #28]
 800138e:	03a9      	lsls	r1, r5, #14
 8001390:	e1cf      	b.n	8001732 <__iar_annotation$$branch+0x164>
 8001392:	68a0      	ldr	r0, [r4, #8]
 8001394:	6881      	ldr	r1, [r0, #8]
 8001396:	2900      	cmp	r1, #0
 8001398:	d108      	bne.n	80013ac <__iar_annotation$$branch+0x9b4>
 800139a:	2000      	movs	r0, #0
 800139c:	9000      	str	r0, [sp, #0]
 800139e:	2303      	movs	r3, #3
 80013a0:	2204      	movs	r2, #4
 80013a2:	2100      	movs	r1, #0
 80013a4:	0020      	movs	r0, r4
 80013a6:	f002 f9e4 	bl	8003772 <PE_Send_CtrlMessage>
 80013aa:	e6be      	b.n	800112a <__iar_annotation$$branch+0x732>
 80013ac:	7b22      	ldrb	r2, [r4, #12]
 80013ae:	07d0      	lsls	r0, r2, #31
 80013b0:	0fc0      	lsrs	r0, r0, #31
 80013b2:	4788      	blx	r1
 80013b4:	280a      	cmp	r0, #10
 80013b6:	d002      	beq.n	80013be <__iar_annotation$$branch+0x9c6>
 80013b8:	280d      	cmp	r0, #13
 80013ba:	d025      	beq.n	8001408 <__iar_annotation$$branch+0xa10>
 80013bc:	e03c      	b.n	8001438 <__iar_annotation$$branch+0xa40>
 80013be:	4858      	ldr	r0, [pc, #352]	; (8001520 <__iar_annotation$$branch+0xb28>)
 80013c0:	8470      	strh	r0, [r6, #34]	; 0x22
 80013c2:	251e      	movs	r5, #30
 80013c4:	2000      	movs	r0, #0
 80013c6:	9000      	str	r0, [sp, #0]
 80013c8:	2324      	movs	r3, #36	; 0x24
 80013ca:	2203      	movs	r2, #3
 80013cc:	2100      	movs	r1, #0
 80013ce:	0020      	movs	r0, r4
 80013d0:	f002 f9cf 	bl	8003772 <PE_Send_CtrlMessage>
 80013d4:	68a0      	ldr	r0, [r4, #8]
 80013d6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80013d8:	2b00      	cmp	r3, #0
 80013da:	d005      	beq.n	80013e8 <__iar_annotation$$branch+0x9f0>
 80013dc:	2201      	movs	r2, #1
 80013de:	2101      	movs	r1, #1
 80013e0:	7b27      	ldrb	r7, [r4, #12]
 80013e2:	07f8      	lsls	r0, r7, #31
 80013e4:	0fc0      	lsrs	r0, r0, #31
 80013e6:	4798      	blx	r3
 80013e8:	4f4b      	ldr	r7, [pc, #300]	; (8001518 <__iar_annotation$$branch+0xb20>)
 80013ea:	7838      	ldrb	r0, [r7, #0]
 80013ec:	0780      	lsls	r0, r0, #30
 80013ee:	d509      	bpl.n	8001404 <__iar_annotation$$branch+0xa0c>
 80013f0:	2000      	movs	r0, #0
 80013f2:	9000      	str	r0, [sp, #0]
 80013f4:	2300      	movs	r3, #0
 80013f6:	2238      	movs	r2, #56	; 0x38
 80013f8:	7b20      	ldrb	r0, [r4, #12]
 80013fa:	07c1      	lsls	r1, r0, #31
 80013fc:	0fc9      	lsrs	r1, r1, #31
 80013fe:	2009      	movs	r0, #9
 8001400:	68ff      	ldr	r7, [r7, #12]
 8001402:	47b8      	blx	r7
 8001404:	2138      	movs	r1, #56	; 0x38
 8001406:	e6af      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001408:	2000      	movs	r0, #0
 800140a:	9000      	str	r0, [sp, #0]
 800140c:	2303      	movs	r3, #3
 800140e:	220c      	movs	r2, #12
 8001410:	2100      	movs	r1, #0
 8001412:	0020      	movs	r0, r4
 8001414:	f002 f9ad 	bl	8003772 <PE_Send_CtrlMessage>
 8001418:	4f3f      	ldr	r7, [pc, #252]	; (8001518 <__iar_annotation$$branch+0xb20>)
 800141a:	7838      	ldrb	r0, [r7, #0]
 800141c:	0780      	lsls	r0, r0, #30
 800141e:	d509      	bpl.n	8001434 <__iar_annotation$$branch+0xa3c>
 8001420:	2000      	movs	r0, #0
 8001422:	9000      	str	r0, [sp, #0]
 8001424:	2300      	movs	r3, #0
 8001426:	2239      	movs	r2, #57	; 0x39
 8001428:	7b20      	ldrb	r0, [r4, #12]
 800142a:	07c1      	lsls	r1, r0, #31
 800142c:	0fc9      	lsrs	r1, r1, #31
 800142e:	2009      	movs	r0, #9
 8001430:	68ff      	ldr	r7, [r7, #12]
 8001432:	47b8      	blx	r7
 8001434:	2139      	movs	r1, #57	; 0x39
 8001436:	e697      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001438:	2000      	movs	r0, #0
 800143a:	9000      	str	r0, [sp, #0]
 800143c:	2303      	movs	r3, #3
 800143e:	2204      	movs	r2, #4
 8001440:	2100      	movs	r1, #0
 8001442:	0020      	movs	r0, r4
 8001444:	f002 f995 	bl	8003772 <PE_Send_CtrlMessage>
 8001448:	4f33      	ldr	r7, [pc, #204]	; (8001518 <__iar_annotation$$branch+0xb20>)
 800144a:	7838      	ldrb	r0, [r7, #0]
 800144c:	0780      	lsls	r0, r0, #30
 800144e:	d509      	bpl.n	8001464 <__iar_annotation$$branch+0xa6c>
 8001450:	2000      	movs	r0, #0
 8001452:	9000      	str	r0, [sp, #0]
 8001454:	2300      	movs	r3, #0
 8001456:	2216      	movs	r2, #22
 8001458:	7b20      	ldrb	r0, [r4, #12]
 800145a:	07c1      	lsls	r1, r0, #31
 800145c:	0fc9      	lsrs	r1, r1, #31
 800145e:	2009      	movs	r0, #9
 8001460:	68ff      	ldr	r7, [r7, #12]
 8001462:	47b8      	blx	r7
 8001464:	2116      	movs	r1, #22
 8001466:	e67f      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001468:	8c71      	ldrh	r1, [r6, #34]	; 0x22
 800146a:	03aa      	lsls	r2, r5, #14
 800146c:	4291      	cmp	r1, r2
 800146e:	d151      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 8001470:	2100      	movs	r1, #0
 8001472:	8471      	strh	r1, [r6, #34]	; 0x22
 8001474:	6861      	ldr	r1, [r4, #4]
 8001476:	784a      	ldrb	r2, [r1, #1]
 8001478:	238f      	movs	r3, #143	; 0x8f
 800147a:	4013      	ands	r3, r2
 800147c:	2240      	movs	r2, #64	; 0x40
 800147e:	431a      	orrs	r2, r3
 8001480:	704a      	strb	r2, [r1, #1]
 8001482:	2800      	cmp	r0, #0
 8001484:	d009      	beq.n	800149a <__iar_annotation$$branch+0xaa2>
 8001486:	2000      	movs	r0, #0
 8001488:	9000      	str	r0, [sp, #0]
 800148a:	2300      	movs	r3, #0
 800148c:	2256      	movs	r2, #86	; 0x56
 800148e:	7b20      	ldrb	r0, [r4, #12]
 8001490:	07c1      	lsls	r1, r0, #31
 8001492:	0fc9      	lsrs	r1, r1, #31
 8001494:	2009      	movs	r0, #9
 8001496:	9f01      	ldr	r7, [sp, #4]
 8001498:	47b8      	blx	r7
 800149a:	2701      	movs	r7, #1
 800149c:	2156      	movs	r1, #86	; 0x56
 800149e:	68e2      	ldr	r2, [r4, #12]
 80014a0:	2001      	movs	r0, #1
 80014a2:	4010      	ands	r0, r2
 80014a4:	68a2      	ldr	r2, [r4, #8]
 80014a6:	68d2      	ldr	r2, [r2, #12]
 80014a8:	4790      	blx	r2
 80014aa:	6860      	ldr	r0, [r4, #4]
 80014ac:	6801      	ldr	r1, [r0, #0]
 80014ae:	2210      	movs	r2, #16
 80014b0:	430a      	orrs	r2, r1
 80014b2:	6002      	str	r2, [r0, #0]
 80014b4:	68a0      	ldr	r0, [r4, #8]
 80014b6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80014b8:	2b00      	cmp	r3, #0
 80014ba:	d00f      	beq.n	80014dc <__iar_annotation$$branch+0xae4>
 80014bc:	2206      	movs	r2, #6
 80014be:	68e1      	ldr	r1, [r4, #12]
 80014c0:	2001      	movs	r0, #1
 80014c2:	4008      	ands	r0, r1
 80014c4:	2101      	movs	r1, #1
 80014c6:	4798      	blx	r3
 80014c8:	68a0      	ldr	r0, [r4, #8]
 80014ca:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80014cc:	2b00      	cmp	r3, #0
 80014ce:	d005      	beq.n	80014dc <__iar_annotation$$branch+0xae4>
 80014d0:	2207      	movs	r2, #7
 80014d2:	68e1      	ldr	r1, [r4, #12]
 80014d4:	2001      	movs	r0, #1
 80014d6:	4008      	ands	r0, r1
 80014d8:	2101      	movs	r1, #1
 80014da:	4798      	blx	r3
 80014dc:	2100      	movs	r1, #0
 80014de:	68e2      	ldr	r2, [r4, #12]
 80014e0:	2001      	movs	r0, #1
 80014e2:	4010      	ands	r0, r2
 80014e4:	f003 fd1d 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 80014e8:	2000      	movs	r0, #0
 80014ea:	9000      	str	r0, [sp, #0]
 80014ec:	2325      	movs	r3, #37	; 0x25
 80014ee:	2206      	movs	r2, #6
 80014f0:	2100      	movs	r1, #0
 80014f2:	0020      	movs	r0, r4
 80014f4:	f002 f93d 	bl	8003772 <PE_Send_CtrlMessage>
 80014f8:	2800      	cmp	r0, #0
 80014fa:	d10b      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 80014fc:	68a0      	ldr	r0, [r4, #8]
 80014fe:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001500:	2b00      	cmp	r3, #0
 8001502:	d005      	beq.n	8001510 <__iar_annotation$$branch+0xb18>
 8001504:	2208      	movs	r2, #8
 8001506:	2101      	movs	r1, #1
 8001508:	68e0      	ldr	r0, [r4, #12]
 800150a:	4007      	ands	r7, r0
 800150c:	0038      	movs	r0, r7
 800150e:	4798      	blx	r3
 8001510:	48bd      	ldr	r0, [pc, #756]	; (8001808 <__iar_annotation$$branch+0x23a>)
 8001512:	8370      	strh	r0, [r6, #26]
 8001514:	e609      	b.n	800112a <__iar_annotation$$branch+0x732>
 8001516:	bf00      	nop
 8001518:	200019a8 	.word	0x200019a8
 800151c:	0000801a 	.word	0x0000801a
 8001520:	0000801e 	.word	0x0000801e
 8001524:	2911      	cmp	r1, #17
 8001526:	d112      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 8001528:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800152a:	0bc0      	lsrs	r0, r0, #15
 800152c:	d10f      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 800152e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001530:	0b00      	lsrs	r0, r0, #12
 8001532:	0740      	lsls	r0, r0, #29
 8001534:	d10b      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 8001536:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001538:	06c0      	lsls	r0, r0, #27
 800153a:	0ec0      	lsrs	r0, r0, #27
 800153c:	2806      	cmp	r0, #6
 800153e:	d106      	bne.n	800154e <__iar_annotation$$branch+0xb56>
 8001540:	2000      	movs	r0, #0
 8001542:	8370      	strh	r0, [r6, #26]
 8001544:	2014      	movs	r0, #20
 8001546:	4669      	mov	r1, sp
 8001548:	7308      	strb	r0, [r1, #12]
 800154a:	2026      	movs	r0, #38	; 0x26
 800154c:	7230      	strb	r0, [r6, #8]
 800154e:	8b70      	ldrh	r0, [r6, #26]
 8001550:	03a9      	lsls	r1, r5, #14
 8001552:	4288      	cmp	r0, r1
 8001554:	d1de      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 8001556:	68a0      	ldr	r0, [r4, #8]
 8001558:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800155a:	2b00      	cmp	r3, #0
 800155c:	d005      	beq.n	800156a <__iar_annotation$$branch+0xb72>
 800155e:	220a      	movs	r2, #10
 8001560:	2101      	movs	r1, #1
 8001562:	7b27      	ldrb	r7, [r4, #12]
 8001564:	07f8      	lsls	r0, r7, #31
 8001566:	0fc0      	lsrs	r0, r0, #31
 8001568:	4798      	blx	r3
 800156a:	e12b      	b.n	80017c4 <__iar_annotation$$branch+0x1f6>
 800156c:	2100      	movs	r1, #0
 800156e:	0020      	movs	r0, r4
 8001570:	f002 fa14 	bl	800399c <PE_ChangePowerRole>
 8001574:	68a0      	ldr	r0, [r4, #8]
 8001576:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001578:	2501      	movs	r5, #1
 800157a:	2b00      	cmp	r3, #0
 800157c:	d005      	beq.n	800158a <__iar_annotation$$branch+0xb92>
 800157e:	220d      	movs	r2, #13
 8001580:	2100      	movs	r1, #0
 8001582:	68e7      	ldr	r7, [r4, #12]
 8001584:	2001      	movs	r0, #1
 8001586:	4038      	ands	r0, r7
 8001588:	4798      	blx	r3
 800158a:	0020      	movs	r0, r4
 800158c:	f002 feb0 	bl	80042f0 <PE_ResetDuringSwap>
 8001590:	4fae      	ldr	r7, [pc, #696]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001592:	7838      	ldrb	r0, [r7, #0]
 8001594:	0780      	lsls	r0, r0, #30
 8001596:	d509      	bpl.n	80015ac <__iar_annotation$$branch+0xbb4>
 8001598:	2000      	movs	r0, #0
 800159a:	9000      	str	r0, [sp, #0]
 800159c:	2300      	movs	r3, #0
 800159e:	2214      	movs	r2, #20
 80015a0:	68e0      	ldr	r0, [r4, #12]
 80015a2:	2101      	movs	r1, #1
 80015a4:	4001      	ands	r1, r0
 80015a6:	2009      	movs	r0, #9
 80015a8:	68ff      	ldr	r7, [r7, #12]
 80015aa:	47b8      	blx	r7
 80015ac:	2114      	movs	r1, #20
 80015ae:	68e2      	ldr	r2, [r4, #12]
 80015b0:	2001      	movs	r0, #1
 80015b2:	4010      	ands	r0, r2
 80015b4:	68a2      	ldr	r2, [r4, #8]
 80015b6:	68d2      	ldr	r2, [r2, #12]
 80015b8:	4790      	blx	r2
 80015ba:	68a0      	ldr	r0, [r4, #8]
 80015bc:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80015be:	2b00      	cmp	r3, #0
 80015c0:	d005      	beq.n	80015ce <__iar_annotation$$branch>
 80015c2:	220e      	movs	r2, #14
 80015c4:	2100      	movs	r1, #0
 80015c6:	68e0      	ldr	r0, [r4, #12]
 80015c8:	4005      	ands	r5, r0
 80015ca:	0028      	movs	r0, r5
 80015cc:	4798      	blx	r3

080015ce <__iar_annotation$$branch>:
 80015ce:	f7ff fa65 	bl	8000a9c <__iar_annotation$$branch+0xa4>
 80015d2:	2001      	movs	r0, #1
 80015d4:	9000      	str	r0, [sp, #0]
 80015d6:	231f      	movs	r3, #31
 80015d8:	220a      	movs	r2, #10
 80015da:	2100      	movs	r1, #0
 80015dc:	0020      	movs	r0, r4
 80015de:	f002 f8c8 	bl	8003772 <PE_Send_CtrlMessage>
 80015e2:	2800      	cmp	r0, #0
 80015e4:	d196      	bne.n	8001514 <__iar_annotation$$branch+0xb1c>
 80015e6:	2008      	movs	r0, #8
 80015e8:	82e0      	strh	r0, [r4, #22]
 80015ea:	48b7      	ldr	r0, [pc, #732]	; (80018c8 <__iar_annotation$$branch+0xa>)
 80015ec:	83b0      	strh	r0, [r6, #28]
 80015ee:	251a      	movs	r5, #26
 80015f0:	68a0      	ldr	r0, [r4, #8]
 80015f2:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80015f4:	2b00      	cmp	r3, #0
 80015f6:	d005      	beq.n	8001604 <__iar_annotation$$branch+0x36>
 80015f8:	2202      	movs	r2, #2
 80015fa:	2101      	movs	r1, #1
 80015fc:	7b27      	ldrb	r7, [r4, #12]
 80015fe:	07f8      	lsls	r0, r7, #31
 8001600:	0fc0      	lsrs	r0, r0, #31
 8001602:	4798      	blx	r3
 8001604:	4f91      	ldr	r7, [pc, #580]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001606:	7838      	ldrb	r0, [r7, #0]
 8001608:	0780      	lsls	r0, r0, #30
 800160a:	d509      	bpl.n	8001620 <__iar_annotation$$branch+0x52>
 800160c:	2000      	movs	r0, #0
 800160e:	9000      	str	r0, [sp, #0]
 8001610:	2300      	movs	r3, #0
 8001612:	2237      	movs	r2, #55	; 0x37
 8001614:	7b20      	ldrb	r0, [r4, #12]
 8001616:	07c1      	lsls	r1, r0, #31
 8001618:	0fc9      	lsrs	r1, r1, #31
 800161a:	2009      	movs	r0, #9
 800161c:	68ff      	ldr	r7, [r7, #12]
 800161e:	47b8      	blx	r7
 8001620:	2137      	movs	r1, #55	; 0x37
 8001622:	e5a1      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001624:	2911      	cmp	r1, #17
 8001626:	d000      	beq.n	800162a <__iar_annotation$$branch+0x5c>
 8001628:	e57f      	b.n	800112a <__iar_annotation$$branch+0x732>
 800162a:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800162c:	0bc9      	lsrs	r1, r1, #15
 800162e:	d17d      	bne.n	800172c <__iar_annotation$$branch+0x15e>
 8001630:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 8001632:	0b09      	lsrs	r1, r1, #12
 8001634:	0749      	lsls	r1, r1, #29
 8001636:	d179      	bne.n	800172c <__iar_annotation$$branch+0x15e>
 8001638:	2703      	movs	r7, #3
 800163a:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 800163c:	06c9      	lsls	r1, r1, #27
 800163e:	0ec9      	lsrs	r1, r1, #27
 8001640:	2903      	cmp	r1, #3
 8001642:	d006      	beq.n	8001652 <__iar_annotation$$branch+0x84>
 8001644:	2904      	cmp	r1, #4
 8001646:	d031      	beq.n	80016ac <__iar_annotation$$branch+0xde>
 8001648:	290c      	cmp	r1, #12
 800164a:	d013      	beq.n	8001674 <__iar_annotation$$branch+0xa6>
 800164c:	2910      	cmp	r1, #16
 800164e:	d049      	beq.n	80016e4 <__iar_annotation$$branch+0x116>
 8001650:	e06c      	b.n	800172c <__iar_annotation$$branch+0x15e>
 8001652:	2500      	movs	r5, #0
 8001654:	83b5      	strh	r5, [r6, #28]
 8001656:	2120      	movs	r1, #32
 8001658:	7231      	strb	r1, [r6, #8]
 800165a:	2800      	cmp	r0, #0
 800165c:	d008      	beq.n	8001670 <__iar_annotation$$branch+0xa2>
 800165e:	9500      	str	r5, [sp, #0]
 8001660:	2300      	movs	r3, #0
 8001662:	2238      	movs	r2, #56	; 0x38
 8001664:	7b20      	ldrb	r0, [r4, #12]
 8001666:	07c1      	lsls	r1, r0, #31
 8001668:	0fc9      	lsrs	r1, r1, #31
 800166a:	2009      	movs	r0, #9
 800166c:	9f01      	ldr	r7, [sp, #4]
 800166e:	47b8      	blx	r7
 8001670:	2138      	movs	r1, #56	; 0x38
 8001672:	e052      	b.n	800171a <__iar_annotation$$branch+0x14c>
 8001674:	68a0      	ldr	r0, [r4, #8]
 8001676:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001678:	2b00      	cmp	r3, #0
 800167a:	d005      	beq.n	8001688 <__iar_annotation$$branch+0xba>
 800167c:	2205      	movs	r2, #5
 800167e:	2101      	movs	r1, #1
 8001680:	7b25      	ldrb	r5, [r4, #12]
 8001682:	07e8      	lsls	r0, r5, #31
 8001684:	0fc0      	lsrs	r0, r0, #31
 8001686:	4798      	blx	r3
 8001688:	2500      	movs	r5, #0
 800168a:	83b5      	strh	r5, [r6, #28]
 800168c:	7237      	strb	r7, [r6, #8]
 800168e:	4f6f      	ldr	r7, [pc, #444]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001690:	7838      	ldrb	r0, [r7, #0]
 8001692:	0780      	lsls	r0, r0, #30
 8001694:	d508      	bpl.n	80016a8 <__iar_annotation$$branch+0xda>
 8001696:	9500      	str	r5, [sp, #0]
 8001698:	2300      	movs	r3, #0
 800169a:	2239      	movs	r2, #57	; 0x39
 800169c:	7b20      	ldrb	r0, [r4, #12]
 800169e:	07c1      	lsls	r1, r0, #31
 80016a0:	0fc9      	lsrs	r1, r1, #31
 80016a2:	2009      	movs	r0, #9
 80016a4:	68ff      	ldr	r7, [r7, #12]
 80016a6:	47b8      	blx	r7
 80016a8:	2139      	movs	r1, #57	; 0x39
 80016aa:	e036      	b.n	800171a <__iar_annotation$$branch+0x14c>
 80016ac:	68a0      	ldr	r0, [r4, #8]
 80016ae:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80016b0:	2b00      	cmp	r3, #0
 80016b2:	d005      	beq.n	80016c0 <__iar_annotation$$branch+0xf2>
 80016b4:	2204      	movs	r2, #4
 80016b6:	2101      	movs	r1, #1
 80016b8:	7b25      	ldrb	r5, [r4, #12]
 80016ba:	07e8      	lsls	r0, r5, #31
 80016bc:	0fc0      	lsrs	r0, r0, #31
 80016be:	4798      	blx	r3
 80016c0:	2500      	movs	r5, #0
 80016c2:	83b5      	strh	r5, [r6, #28]
 80016c4:	7237      	strb	r7, [r6, #8]
 80016c6:	4f61      	ldr	r7, [pc, #388]	; (800184c <__iar_annotation$$branch+0x27e>)
 80016c8:	7838      	ldrb	r0, [r7, #0]
 80016ca:	0780      	lsls	r0, r0, #30
 80016cc:	d508      	bpl.n	80016e0 <__iar_annotation$$branch+0x112>
 80016ce:	9500      	str	r5, [sp, #0]
 80016d0:	2300      	movs	r3, #0
 80016d2:	2216      	movs	r2, #22
 80016d4:	7b20      	ldrb	r0, [r4, #12]
 80016d6:	07c1      	lsls	r1, r0, #31
 80016d8:	0fc9      	lsrs	r1, r1, #31
 80016da:	2009      	movs	r0, #9
 80016dc:	68ff      	ldr	r7, [r7, #12]
 80016de:	47b8      	blx	r7
 80016e0:	2116      	movs	r1, #22
 80016e2:	e01a      	b.n	800171a <__iar_annotation$$branch+0x14c>
 80016e4:	68a0      	ldr	r0, [r4, #8]
 80016e6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80016e8:	2b00      	cmp	r3, #0
 80016ea:	d005      	beq.n	80016f8 <__iar_annotation$$branch+0x12a>
 80016ec:	2204      	movs	r2, #4
 80016ee:	2101      	movs	r1, #1
 80016f0:	7b25      	ldrb	r5, [r4, #12]
 80016f2:	07e8      	lsls	r0, r5, #31
 80016f4:	0fc0      	lsrs	r0, r0, #31
 80016f6:	4798      	blx	r3
 80016f8:	2500      	movs	r5, #0
 80016fa:	83b5      	strh	r5, [r6, #28]
 80016fc:	7237      	strb	r7, [r6, #8]
 80016fe:	4f53      	ldr	r7, [pc, #332]	; (800184c <__iar_annotation$$branch+0x27e>)
 8001700:	7838      	ldrb	r0, [r7, #0]
 8001702:	0780      	lsls	r0, r0, #30
 8001704:	d508      	bpl.n	8001718 <__iar_annotation$$branch+0x14a>
 8001706:	9500      	str	r5, [sp, #0]
 8001708:	2300      	movs	r3, #0
 800170a:	2255      	movs	r2, #85	; 0x55
 800170c:	7b20      	ldrb	r0, [r4, #12]
 800170e:	07c1      	lsls	r1, r0, #31
 8001710:	0fc9      	lsrs	r1, r1, #31
 8001712:	2009      	movs	r0, #9
 8001714:	68ff      	ldr	r7, [r7, #12]
 8001716:	47b8      	blx	r7
 8001718:	2155      	movs	r1, #85	; 0x55
 800171a:	7b22      	ldrb	r2, [r4, #12]
 800171c:	07d0      	lsls	r0, r2, #31
 800171e:	0fc0      	lsrs	r0, r0, #31
 8001720:	68a2      	ldr	r2, [r4, #8]
 8001722:	68d2      	ldr	r2, [r2, #12]
 8001724:	4790      	blx	r2
 8001726:	2014      	movs	r0, #20
 8001728:	4669      	mov	r1, sp
 800172a:	7308      	strb	r0, [r1, #12]
 800172c:	8bb0      	ldrh	r0, [r6, #28]
 800172e:	2180      	movs	r1, #128	; 0x80
 8001730:	0209      	lsls	r1, r1, #8
 8001732:	4288      	cmp	r0, r1
 8001734:	d138      	bne.n	80017a8 <__iar_annotation$$branch+0x1da>
 8001736:	e22a      	b.n	8001b8e <__iar_annotation$$branch+0xc>
 8001738:	6860      	ldr	r0, [r4, #4]
 800173a:	6801      	ldr	r1, [r0, #0]
 800173c:	2210      	movs	r2, #16
 800173e:	430a      	orrs	r2, r1
 8001740:	6002      	str	r2, [r0, #0]
 8001742:	68a0      	ldr	r0, [r4, #8]
 8001744:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001746:	2701      	movs	r7, #1
 8001748:	2b00      	cmp	r3, #0
 800174a:	d00f      	beq.n	800176c <__iar_annotation$$branch+0x19e>
 800174c:	2206      	movs	r2, #6
 800174e:	68e1      	ldr	r1, [r4, #12]
 8001750:	2001      	movs	r0, #1
 8001752:	4008      	ands	r0, r1
 8001754:	2101      	movs	r1, #1
 8001756:	4798      	blx	r3
 8001758:	68a0      	ldr	r0, [r4, #8]
 800175a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800175c:	2b00      	cmp	r3, #0
 800175e:	d005      	beq.n	800176c <__iar_annotation$$branch+0x19e>
 8001760:	2207      	movs	r2, #7
 8001762:	68e1      	ldr	r1, [r4, #12]
 8001764:	2001      	movs	r0, #1
 8001766:	4008      	ands	r0, r1
 8001768:	2101      	movs	r1, #1
 800176a:	4798      	blx	r3
 800176c:	2100      	movs	r1, #0
 800176e:	68e2      	ldr	r2, [r4, #12]
 8001770:	2001      	movs	r0, #1
 8001772:	4010      	ands	r0, r2
 8001774:	f003 fbd5 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8001778:	2000      	movs	r0, #0
 800177a:	9000      	str	r0, [sp, #0]
 800177c:	2321      	movs	r3, #33	; 0x21
 800177e:	2206      	movs	r2, #6
 8001780:	2100      	movs	r1, #0
 8001782:	0020      	movs	r0, r4
 8001784:	f001 fff5 	bl	8003772 <PE_Send_CtrlMessage>
 8001788:	2800      	cmp	r0, #0
 800178a:	d10d      	bne.n	80017a8 <__iar_annotation$$branch+0x1da>
 800178c:	68a0      	ldr	r0, [r4, #8]
 800178e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001790:	2b00      	cmp	r3, #0
 8001792:	d005      	beq.n	80017a0 <__iar_annotation$$branch+0x1d2>
 8001794:	2208      	movs	r2, #8
 8001796:	2101      	movs	r1, #1
 8001798:	68e0      	ldr	r0, [r4, #12]
 800179a:	4007      	ands	r7, r0
 800179c:	0038      	movs	r0, r7
 800179e:	4798      	blx	r3
 80017a0:	484a      	ldr	r0, [pc, #296]	; (80018cc <__iar_annotation$$branch+0xe>)
 80017a2:	8370      	strh	r0, [r6, #26]
 80017a4:	25f0      	movs	r5, #240	; 0xf0
 80017a6:	006d      	lsls	r5, r5, #1
 80017a8:	e4bf      	b.n	800112a <__iar_annotation$$branch+0x732>
 80017aa:	2911      	cmp	r1, #17
 80017ac:	d106      	bne.n	80017bc <__iar_annotation$$branch+0x1ee>
 80017ae:	2000      	movs	r0, #0
 80017b0:	8370      	strh	r0, [r6, #26]
 80017b2:	2026      	movs	r0, #38	; 0x26
 80017b4:	7230      	strb	r0, [r6, #8]
 80017b6:	2014      	movs	r0, #20
 80017b8:	4669      	mov	r1, sp
 80017ba:	7308      	strb	r0, [r1, #12]
 80017bc:	8b70      	ldrh	r0, [r6, #26]
 80017be:	03a9      	lsls	r1, r5, #14
 80017c0:	4288      	cmp	r0, r1
 80017c2:	d1f1      	bne.n	80017a8 <__iar_annotation$$branch+0x1da>
 80017c4:	2000      	movs	r0, #0
 80017c6:	8370      	strh	r0, [r6, #26]
 80017c8:	e069      	b.n	800189e <__iar_annotation$$branch>
 80017ca:	6860      	ldr	r0, [r4, #4]
 80017cc:	7841      	ldrb	r1, [r0, #1]
 80017ce:	0649      	lsls	r1, r1, #25
 80017d0:	0f49      	lsrs	r1, r1, #29
 80017d2:	2903      	cmp	r1, #3
 80017d4:	d11a      	bne.n	800180c <__iar_annotation$$branch+0x23e>
 80017d6:	6821      	ldr	r1, [r4, #0]
 80017d8:	6849      	ldr	r1, [r1, #4]
 80017da:	070a      	lsls	r2, r1, #28
 80017dc:	0fd2      	lsrs	r2, r2, #31
 80017de:	d015      	beq.n	800180c <__iar_annotation$$branch+0x23e>
 80017e0:	2103      	movs	r1, #3
 80017e2:	0020      	movs	r0, r4
 80017e4:	f001 ffaa 	bl	800373c <PE_Send_SNKCapabilities>
 80017e8:	4f18      	ldr	r7, [pc, #96]	; (800184c <__iar_annotation$$branch+0x27e>)
 80017ea:	7838      	ldrb	r0, [r7, #0]
 80017ec:	0780      	lsls	r0, r0, #30
 80017ee:	d509      	bpl.n	8001804 <__iar_annotation$$branch+0x236>
 80017f0:	2000      	movs	r0, #0
 80017f2:	9000      	str	r0, [sp, #0]
 80017f4:	2300      	movs	r3, #0
 80017f6:	220a      	movs	r2, #10
 80017f8:	7b20      	ldrb	r0, [r4, #12]
 80017fa:	07c1      	lsls	r1, r0, #31
 80017fc:	0fc9      	lsrs	r1, r1, #31
 80017fe:	2009      	movs	r0, #9
 8001800:	68ff      	ldr	r7, [r7, #12]
 8001802:	47b8      	blx	r7
 8001804:	210a      	movs	r1, #10
 8001806:	e4af      	b.n	8001168 <__iar_annotation$$branch+0x770>
 8001808:	000081ae 	.word	0x000081ae
 800180c:	7800      	ldrb	r0, [r0, #0]
 800180e:	0780      	lsls	r0, r0, #30
 8001810:	0f80      	lsrs	r0, r0, #30
 8001812:	2802      	cmp	r0, #2
 8001814:	d101      	bne.n	800181a <__iar_annotation$$branch+0x24c>
 8001816:	2001      	movs	r0, #1
 8001818:	e433      	b.n	8001082 <__iar_annotation$$branch+0x68a>
 800181a:	202a      	movs	r0, #42	; 0x2a
 800181c:	e431      	b.n	8001082 <__iar_annotation$$branch+0x68a>
 800181e:	2700      	movs	r7, #0
 8001820:	82e7      	strh	r7, [r4, #22]
 8001822:	7b21      	ldrb	r1, [r4, #12]
 8001824:	07c8      	lsls	r0, r1, #31
 8001826:	0fc0      	lsrs	r0, r0, #31
 8001828:	f003 fba4 	bl	8004f74 <USBPD_PRL_SRCReleaseSinkNG>
 800182c:	2004      	movs	r0, #4
 800182e:	7230      	strb	r0, [r6, #8]
 8001830:	7b20      	ldrb	r0, [r4, #12]
 8001832:	0700      	lsls	r0, r0, #28
 8001834:	0f80      	lsrs	r0, r0, #30
 8001836:	2803      	cmp	r0, #3
 8001838:	d10a      	bne.n	8001850 <__iar_annotation$$branch+0x282>
 800183a:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 800183c:	0440      	lsls	r0, r0, #17
 800183e:	0c40      	lsrs	r0, r0, #17
 8001840:	2800      	cmp	r0, #0
 8001842:	dc06      	bgt.n	8001852 <__iar_annotation$$branch+0x284>
 8001844:	4822      	ldr	r0, [pc, #136]	; (80018d0 <__iar_annotation$$branch+0x12>)
 8001846:	8670      	strh	r0, [r6, #50]	; 0x32
 8001848:	4d22      	ldr	r5, [pc, #136]	; (80018d4 <__iar_annotation$$branch+0x16>)
 800184a:	e002      	b.n	8001852 <__iar_annotation$$branch+0x284>
 800184c:	200019a8 	.word	0x200019a8
 8001850:	8677      	strh	r7, [r6, #50]	; 0x32
 8001852:	4668      	mov	r0, sp
 8001854:	7b00      	ldrb	r0, [r0, #12]
 8001856:	2814      	cmp	r0, #20
 8001858:	d01a      	beq.n	8001890 <__iar_annotation$$branch+0x2c2>
 800185a:	7ab0      	ldrb	r0, [r6, #10]
 800185c:	72f0      	strb	r0, [r6, #11]
 800185e:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001860:	0bc0      	lsrs	r0, r0, #15
 8001862:	d003      	beq.n	800186c <__iar_annotation$$branch+0x29e>
 8001864:	0020      	movs	r0, r4
 8001866:	f002 fb57 	bl	8003f18 <PE_Check_ExtendedMessage>
 800186a:	e00d      	b.n	8001888 <__iar_annotation$$branch+0x2ba>
 800186c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 800186e:	0bc0      	lsrs	r0, r0, #15
 8001870:	d107      	bne.n	8001882 <__iar_annotation$$branch+0x2b4>
 8001872:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001874:	0b00      	lsrs	r0, r0, #12
 8001876:	0740      	lsls	r0, r0, #29
 8001878:	d103      	bne.n	8001882 <__iar_annotation$$branch+0x2b4>
 800187a:	0020      	movs	r0, r4
 800187c:	f002 f902 	bl	8003a84 <PE_Check_ControlMessage>
 8001880:	e002      	b.n	8001888 <__iar_annotation$$branch+0x2ba>
 8001882:	0020      	movs	r0, r4
 8001884:	f002 fa9a 	bl	8003dbc <PE_Check_DataMessage>
 8001888:	2014      	movs	r0, #20
 800188a:	4669      	mov	r1, sp
 800188c:	7308      	strb	r0, [r1, #12]
 800188e:	e44c      	b.n	800112a <__iar_annotation$$branch+0x732>
 8001890:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 8001892:	2180      	movs	r1, #128	; 0x80
 8001894:	0209      	lsls	r1, r1, #8
 8001896:	4288      	cmp	r0, r1
 8001898:	d103      	bne.n	80018a2 <__iar_annotation$$branch+0x4>
 800189a:	2500      	movs	r5, #0
 800189c:	8675      	strh	r5, [r6, #50]	; 0x32

0800189e <__iar_annotation$$branch>:
 800189e:	f7ff fac8 	bl	8000e32 <__iar_annotation$$branch+0x43a>
 80018a2:	7930      	ldrb	r0, [r6, #4]
 80018a4:	2800      	cmp	r0, #0
 80018a6:	d006      	beq.n	80018b6 <__iar_annotation$$branch+0x18>
 80018a8:	7970      	ldrb	r0, [r6, #5]
 80018aa:	72f0      	strb	r0, [r6, #11]
 80018ac:	7930      	ldrb	r0, [r6, #4]
 80018ae:	7230      	strb	r0, [r6, #8]
 80018b0:	2500      	movs	r5, #0
 80018b2:	7135      	strb	r5, [r6, #4]
 80018b4:	e439      	b.n	800112a <__iar_annotation$$branch+0x732>
 80018b6:	4d08      	ldr	r5, [pc, #32]	; (80018d8 <__iar_annotation$$branch+0x1a>)
 80018b8:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 80018ba:	4028      	ands	r0, r5
 80018bc:	dc01      	bgt.n	80018c2 <__iar_annotation$$branch+0x4>

080018be <__iar_annotation$$branch>:
 80018be:	f7ff faa0 	bl	8000e02 <__iar_annotation$$branch+0x40a>
 80018c2:	8e70      	ldrh	r0, [r6, #50]	; 0x32
 80018c4:	4005      	ands	r5, r0
 80018c6:	e430      	b.n	800112a <__iar_annotation$$branch+0x732>
 80018c8:	0000801a 	.word	0x0000801a
 80018cc:	000081e0 	.word	0x000081e0
 80018d0:	0000b6b0 	.word	0x0000b6b0
 80018d4:	000036b0 	.word	0x000036b0
 80018d8:	00007fff 	.word	0x00007fff
 80018dc:	a80a      	add	r0, sp, #40	; 0x28
 80018de:	7800      	ldrb	r0, [r0, #0]
 80018e0:	68a1      	ldr	r1, [r4, #8]
 80018e2:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
 80018e4:	4788      	blx	r1
 80018e6:	280a      	cmp	r0, #10
 80018e8:	d142      	bne.n	8001970 <__iar_annotation$$branch+0xb2>
 80018ea:	2000      	movs	r0, #0
 80018ec:	9000      	str	r0, [sp, #0]
 80018ee:	2303      	movs	r3, #3
 80018f0:	2203      	movs	r2, #3
 80018f2:	2100      	movs	r1, #0
 80018f4:	0020      	movs	r0, r4
 80018f6:	f001 ff3c 	bl	8003772 <PE_Send_CtrlMessage>
 80018fa:	2800      	cmp	r0, #0
 80018fc:	d170      	bne.n	80019e0 <__iar_annotation$$branch>
 80018fe:	6861      	ldr	r1, [r4, #4]
 8001900:	780a      	ldrb	r2, [r1, #0]
 8001902:	48c8      	ldr	r0, [pc, #800]	; (8001c24 <.text_18>)
 8001904:	68c7      	ldr	r7, [r0, #12]
 8001906:	7800      	ldrb	r0, [r0, #0]
 8001908:	4028      	ands	r0, r5
 800190a:	08d3      	lsrs	r3, r2, #3
 800190c:	07db      	lsls	r3, r3, #31
 800190e:	d40f      	bmi.n	8001930 <__iar_annotation$$branch+0x72>
 8001910:	2308      	movs	r3, #8
 8001912:	4313      	orrs	r3, r2
 8001914:	700b      	strb	r3, [r1, #0]
 8001916:	2800      	cmp	r0, #0
 8001918:	d008      	beq.n	800192c <__iar_annotation$$branch+0x6e>
 800191a:	2000      	movs	r0, #0
 800191c:	9000      	str	r0, [sp, #0]
 800191e:	2300      	movs	r3, #0
 8001920:	2224      	movs	r2, #36	; 0x24
 8001922:	7b20      	ldrb	r0, [r4, #12]
 8001924:	07c1      	lsls	r1, r0, #31
 8001926:	0fc9      	lsrs	r1, r1, #31
 8001928:	2009      	movs	r0, #9
 800192a:	47b8      	blx	r7
 800192c:	2124      	movs	r1, #36	; 0x24
 800192e:	e00e      	b.n	800194e <__iar_annotation$$branch+0x90>
 8001930:	23f7      	movs	r3, #247	; 0xf7
 8001932:	4013      	ands	r3, r2
 8001934:	700b      	strb	r3, [r1, #0]
 8001936:	2800      	cmp	r0, #0
 8001938:	d008      	beq.n	800194c <__iar_annotation$$branch+0x8e>
 800193a:	2000      	movs	r0, #0
 800193c:	9000      	str	r0, [sp, #0]
 800193e:	2300      	movs	r3, #0
 8001940:	2223      	movs	r2, #35	; 0x23
 8001942:	7b20      	ldrb	r0, [r4, #12]
 8001944:	07c1      	lsls	r1, r0, #31
 8001946:	0fc9      	lsrs	r1, r1, #31
 8001948:	2009      	movs	r0, #9
 800194a:	47b8      	blx	r7
 800194c:	2123      	movs	r1, #35	; 0x23
 800194e:	7b22      	ldrb	r2, [r4, #12]
 8001950:	07d0      	lsls	r0, r2, #31
 8001952:	0fc0      	lsrs	r0, r0, #31
 8001954:	68a2      	ldr	r2, [r4, #8]
 8001956:	68d2      	ldr	r2, [r2, #12]
 8001958:	4790      	blx	r2
 800195a:	2001      	movs	r0, #1
 800195c:	6861      	ldr	r1, [r4, #4]
 800195e:	7809      	ldrb	r1, [r1, #0]
 8001960:	08ca      	lsrs	r2, r1, #3
 8001962:	2101      	movs	r1, #1
 8001964:	4011      	ands	r1, r2
 8001966:	68e2      	ldr	r2, [r4, #12]
 8001968:	4010      	ands	r0, r2
 800196a:	f003 fae5 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 800196e:	e037      	b.n	80019e0 <__iar_annotation$$branch>
 8001970:	6860      	ldr	r0, [r4, #4]
 8001972:	e74b      	b.n	800180c <__iar_annotation$$branch+0x23e>
 8001974:	2001      	movs	r0, #1
 8001976:	9000      	str	r0, [sp, #0]
 8001978:	2395      	movs	r3, #149	; 0x95
 800197a:	2209      	movs	r2, #9
 800197c:	2100      	movs	r1, #0
 800197e:	0020      	movs	r0, r4
 8001980:	f001 fef7 	bl	8003772 <PE_Send_CtrlMessage>
 8001984:	2800      	cmp	r0, #0
 8001986:	d12b      	bne.n	80019e0 <__iar_annotation$$branch>
 8001988:	200f      	movs	r0, #15
 800198a:	82e0      	strh	r0, [r4, #22]
 800198c:	48a6      	ldr	r0, [pc, #664]	; (8001c28 <.text_19>)
 800198e:	83b0      	strh	r0, [r6, #28]
 8001990:	251a      	movs	r5, #26
 8001992:	4fa4      	ldr	r7, [pc, #656]	; (8001c24 <.text_18>)
 8001994:	7838      	ldrb	r0, [r7, #0]
 8001996:	0780      	lsls	r0, r0, #30
 8001998:	d509      	bpl.n	80019ae <__iar_annotation$$branch+0xf0>
 800199a:	2000      	movs	r0, #0
 800199c:	9000      	str	r0, [sp, #0]
 800199e:	2300      	movs	r3, #0
 80019a0:	2221      	movs	r2, #33	; 0x21
 80019a2:	7b20      	ldrb	r0, [r4, #12]
 80019a4:	07c1      	lsls	r1, r0, #31
 80019a6:	0fc9      	lsrs	r1, r1, #31
 80019a8:	2009      	movs	r0, #9
 80019aa:	68ff      	ldr	r7, [r7, #12]
 80019ac:	47b8      	blx	r7
 80019ae:	2121      	movs	r1, #33	; 0x21
 80019b0:	e0e7      	b.n	8001b82 <__iar_annotation$$branch>
 80019b2:	8bb2      	ldrh	r2, [r6, #28]
 80019b4:	03ab      	lsls	r3, r5, #14
 80019b6:	429a      	cmp	r2, r3
 80019b8:	d100      	bne.n	80019bc <__iar_annotation$$branch+0xfe>
 80019ba:	e0e8      	b.n	8001b8e <__iar_annotation$$branch+0xc>
 80019bc:	2914      	cmp	r1, #20
 80019be:	d00f      	beq.n	80019e0 <__iar_annotation$$branch>
 80019c0:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80019c2:	0bc9      	lsrs	r1, r1, #15
 80019c4:	d10c      	bne.n	80019e0 <__iar_annotation$$branch>
 80019c6:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80019c8:	0b09      	lsrs	r1, r1, #12
 80019ca:	0749      	lsls	r1, r1, #29
 80019cc:	d108      	bne.n	80019e0 <__iar_annotation$$branch>
 80019ce:	8eb1      	ldrh	r1, [r6, #52]	; 0x34
 80019d0:	06c9      	lsls	r1, r1, #27
 80019d2:	0ec9      	lsrs	r1, r1, #27
 80019d4:	2903      	cmp	r1, #3
 80019d6:	d005      	beq.n	80019e4 <__iar_annotation$$branch+0x4>
 80019d8:	2904      	cmp	r1, #4
 80019da:	d052      	beq.n	8001a82 <__iar_annotation$$branch+0xa2>
 80019dc:	290c      	cmp	r1, #12
 80019de:	d03c      	beq.n	8001a5a <__iar_annotation$$branch+0x7a>

080019e0 <__iar_annotation$$branch>:
 80019e0:	f7fe fff0 	bl	80009c4 <__iar_annotation$$branch+0x1e8>
 80019e4:	6861      	ldr	r1, [r4, #4]
 80019e6:	780a      	ldrb	r2, [r1, #0]
 80019e8:	08d3      	lsrs	r3, r2, #3
 80019ea:	07db      	lsls	r3, r3, #31
 80019ec:	d410      	bmi.n	8001a10 <__iar_annotation$$branch+0x30>
 80019ee:	2308      	movs	r3, #8
 80019f0:	4313      	orrs	r3, r2
 80019f2:	700b      	strb	r3, [r1, #0]
 80019f4:	2800      	cmp	r0, #0
 80019f6:	d009      	beq.n	8001a0c <__iar_annotation$$branch+0x2c>
 80019f8:	2000      	movs	r0, #0
 80019fa:	9000      	str	r0, [sp, #0]
 80019fc:	2300      	movs	r3, #0
 80019fe:	2224      	movs	r2, #36	; 0x24
 8001a00:	7b20      	ldrb	r0, [r4, #12]
 8001a02:	07c1      	lsls	r1, r0, #31
 8001a04:	0fc9      	lsrs	r1, r1, #31
 8001a06:	2009      	movs	r0, #9
 8001a08:	9f01      	ldr	r7, [sp, #4]
 8001a0a:	47b8      	blx	r7
 8001a0c:	2124      	movs	r1, #36	; 0x24
 8001a0e:	e00f      	b.n	8001a30 <__iar_annotation$$branch+0x50>
 8001a10:	23f7      	movs	r3, #247	; 0xf7
 8001a12:	4013      	ands	r3, r2
 8001a14:	700b      	strb	r3, [r1, #0]
 8001a16:	2800      	cmp	r0, #0
 8001a18:	d009      	beq.n	8001a2e <__iar_annotation$$branch+0x4e>
 8001a1a:	2000      	movs	r0, #0
 8001a1c:	9000      	str	r0, [sp, #0]
 8001a1e:	2300      	movs	r3, #0
 8001a20:	2223      	movs	r2, #35	; 0x23
 8001a22:	7b20      	ldrb	r0, [r4, #12]
 8001a24:	07c1      	lsls	r1, r0, #31
 8001a26:	0fc9      	lsrs	r1, r1, #31
 8001a28:	2009      	movs	r0, #9
 8001a2a:	9f01      	ldr	r7, [sp, #4]
 8001a2c:	47b8      	blx	r7
 8001a2e:	2123      	movs	r1, #35	; 0x23
 8001a30:	7b22      	ldrb	r2, [r4, #12]
 8001a32:	07d0      	lsls	r0, r2, #31
 8001a34:	0fc0      	lsrs	r0, r0, #31
 8001a36:	68a2      	ldr	r2, [r4, #8]
 8001a38:	68d2      	ldr	r2, [r2, #12]
 8001a3a:	4790      	blx	r2
 8001a3c:	2001      	movs	r0, #1
 8001a3e:	6861      	ldr	r1, [r4, #4]
 8001a40:	7809      	ldrb	r1, [r1, #0]
 8001a42:	08ca      	lsrs	r2, r1, #3
 8001a44:	2101      	movs	r1, #1
 8001a46:	4011      	ands	r1, r2
 8001a48:	68e2      	ldr	r2, [r4, #12]
 8001a4a:	4010      	ands	r0, r2
 8001a4c:	f003 fa74 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 8001a50:	2000      	movs	r0, #0
 8001a52:	83b0      	strh	r0, [r6, #28]
 8001a54:	2003      	movs	r0, #3
 8001a56:	7230      	strb	r0, [r6, #8]
 8001a58:	e716      	b.n	8001888 <__iar_annotation$$branch+0x2ba>
 8001a5a:	2800      	cmp	r0, #0
 8001a5c:	d009      	beq.n	8001a72 <__iar_annotation$$branch+0x92>
 8001a5e:	2000      	movs	r0, #0
 8001a60:	9000      	str	r0, [sp, #0]
 8001a62:	2300      	movs	r3, #0
 8001a64:	2225      	movs	r2, #37	; 0x25
 8001a66:	7b20      	ldrb	r0, [r4, #12]
 8001a68:	07c1      	lsls	r1, r0, #31
 8001a6a:	0fc9      	lsrs	r1, r1, #31
 8001a6c:	2009      	movs	r0, #9
 8001a6e:	9f01      	ldr	r7, [sp, #4]
 8001a70:	47b8      	blx	r7
 8001a72:	2125      	movs	r1, #37	; 0x25
 8001a74:	7b22      	ldrb	r2, [r4, #12]
 8001a76:	07d0      	lsls	r0, r2, #31
 8001a78:	0fc0      	lsrs	r0, r0, #31
 8001a7a:	68a2      	ldr	r2, [r4, #8]
 8001a7c:	68d2      	ldr	r2, [r2, #12]
 8001a7e:	4790      	blx	r2
 8001a80:	e7e6      	b.n	8001a50 <__iar_annotation$$branch+0x70>
 8001a82:	2800      	cmp	r0, #0
 8001a84:	d009      	beq.n	8001a9a <__iar_annotation$$branch+0xba>
 8001a86:	2000      	movs	r0, #0
 8001a88:	9000      	str	r0, [sp, #0]
 8001a8a:	2300      	movs	r3, #0
 8001a8c:	2226      	movs	r2, #38	; 0x26
 8001a8e:	7b20      	ldrb	r0, [r4, #12]
 8001a90:	07c1      	lsls	r1, r0, #31
 8001a92:	0fc9      	lsrs	r1, r1, #31
 8001a94:	2009      	movs	r0, #9
 8001a96:	9f01      	ldr	r7, [sp, #4]
 8001a98:	47b8      	blx	r7
 8001a9a:	2126      	movs	r1, #38	; 0x26
 8001a9c:	7b22      	ldrb	r2, [r4, #12]
 8001a9e:	07d0      	lsls	r0, r2, #31
 8001aa0:	0fc0      	lsrs	r0, r0, #31
 8001aa2:	68a2      	ldr	r2, [r4, #8]
 8001aa4:	68d2      	ldr	r2, [r2, #12]
 8001aa6:	4790      	blx	r2
 8001aa8:	e7d2      	b.n	8001a50 <__iar_annotation$$branch+0x70>
 8001aaa:	2000      	movs	r0, #0
 8001aac:	9002      	str	r0, [sp, #8]
 8001aae:	2003      	movs	r0, #3
 8001ab0:	9001      	str	r0, [sp, #4]
 8001ab2:	2001      	movs	r0, #1
 8001ab4:	9000      	str	r0, [sp, #0]
 8001ab6:	20e3      	movs	r0, #227	; 0xe3
 8001ab8:	0080      	lsls	r0, r0, #2
 8001aba:	1823      	adds	r3, r4, r0
 8001abc:	2206      	movs	r2, #6
 8001abe:	2100      	movs	r1, #0
 8001ac0:	0020      	movs	r0, r4
 8001ac2:	f001 fe9d 	bl	8003800 <PE_Send_DataMessage>
 8001ac6:	e78b      	b.n	80019e0 <__iar_annotation$$branch>
 8001ac8:	ab06      	add	r3, sp, #24
 8001aca:	aa05      	add	r2, sp, #20
 8001acc:	210a      	movs	r1, #10
 8001ace:	a80a      	add	r0, sp, #40	; 0x28
 8001ad0:	7800      	ldrb	r0, [r0, #0]
 8001ad2:	68a7      	ldr	r7, [r4, #8]
 8001ad4:	69bf      	ldr	r7, [r7, #24]
 8001ad6:	47b8      	blx	r7
 8001ad8:	2700      	movs	r7, #0
 8001ada:	76e7      	strb	r7, [r4, #27]
 8001adc:	76a7      	strb	r7, [r4, #26]
 8001ade:	7b21      	ldrb	r1, [r4, #12]
 8001ae0:	07c8      	lsls	r0, r1, #31
 8001ae2:	0fc0      	lsrs	r0, r0, #31
 8001ae4:	f002 fcde 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8001ae8:	2800      	cmp	r0, #0
 8001aea:	d103      	bne.n	8001af4 <__iar_annotation$$branch+0x114>
 8001aec:	8b60      	ldrh	r0, [r4, #26]
 8001aee:	03a9      	lsls	r1, r5, #14
 8001af0:	4301      	orrs	r1, r0
 8001af2:	8361      	strh	r1, [r4, #26]
 8001af4:	9805      	ldr	r0, [sp, #20]
 8001af6:	00f9      	lsls	r1, r7, #3
 8001af8:	40c8      	lsrs	r0, r1
 8001afa:	0021      	movs	r1, r4
 8001afc:	311c      	adds	r1, #28
 8001afe:	55c8      	strb	r0, [r1, r7]
 8001b00:	1c7f      	adds	r7, r7, #1
 8001b02:	2f04      	cmp	r7, #4
 8001b04:	dbf6      	blt.n	8001af4 <__iar_annotation$$branch+0x114>
 8001b06:	2000      	movs	r0, #0
 8001b08:	9002      	str	r0, [sp, #8]
 8001b0a:	2003      	movs	r0, #3
 8001b0c:	9001      	str	r0, [sp, #4]
 8001b0e:	2008      	movs	r0, #8
 8001b10:	9000      	str	r0, [sp, #0]
 8001b12:	0023      	movs	r3, r4
 8001b14:	3318      	adds	r3, #24
 8001b16:	228c      	movs	r2, #140	; 0x8c
 8001b18:	2100      	movs	r1, #0
 8001b1a:	0020      	movs	r0, r4
 8001b1c:	f002 fcd2 	bl	80044c4 <PE_Send_ExtendedMessage>
 8001b20:	4f40      	ldr	r7, [pc, #256]	; (8001c24 <.text_18>)
 8001b22:	7838      	ldrb	r0, [r7, #0]
 8001b24:	0780      	lsls	r0, r0, #30
 8001b26:	d509      	bpl.n	8001b3c <__iar_annotation$$branch+0x15c>
 8001b28:	2000      	movs	r0, #0
 8001b2a:	9000      	str	r0, [sp, #0]
 8001b2c:	2300      	movs	r3, #0
 8001b2e:	2249      	movs	r2, #73	; 0x49
 8001b30:	7b20      	ldrb	r0, [r4, #12]
 8001b32:	07c1      	lsls	r1, r0, #31
 8001b34:	0fc9      	lsrs	r1, r1, #31
 8001b36:	2009      	movs	r0, #9
 8001b38:	68ff      	ldr	r7, [r7, #12]
 8001b3a:	47b8      	blx	r7
 8001b3c:	2149      	movs	r1, #73	; 0x49
 8001b3e:	e020      	b.n	8001b82 <__iar_annotation$$branch>
 8001b40:	20e5      	movs	r0, #229	; 0xe5
 8001b42:	0080      	lsls	r0, r0, #2
 8001b44:	1827      	adds	r7, r4, r0
 8001b46:	2001      	movs	r0, #1
 8001b48:	9000      	str	r0, [sp, #0]
 8001b4a:	2339      	movs	r3, #57	; 0x39
 8001b4c:	783a      	ldrb	r2, [r7, #0]
 8001b4e:	7971      	ldrb	r1, [r6, #5]
 8001b50:	0020      	movs	r0, r4
 8001b52:	f001 fe0e 	bl	8003772 <PE_Send_CtrlMessage>
 8001b56:	2800      	cmp	r0, #0
 8001b58:	d128      	bne.n	8001bac <__iar_annotation$$branch+0x2a>
 8001b5a:	8878      	ldrh	r0, [r7, #2]
 8001b5c:	82e0      	strh	r0, [r4, #22]
 8001b5e:	4832      	ldr	r0, [pc, #200]	; (8001c28 <.text_19>)
 8001b60:	83b0      	strh	r0, [r6, #28]
 8001b62:	251a      	movs	r5, #26
 8001b64:	4f2f      	ldr	r7, [pc, #188]	; (8001c24 <.text_18>)
 8001b66:	7838      	ldrb	r0, [r7, #0]
 8001b68:	0780      	lsls	r0, r0, #30
 8001b6a:	d509      	bpl.n	8001b80 <__iar_annotation$$branch+0x1a0>
 8001b6c:	2000      	movs	r0, #0
 8001b6e:	9000      	str	r0, [sp, #0]
 8001b70:	2300      	movs	r3, #0
 8001b72:	2241      	movs	r2, #65	; 0x41
 8001b74:	7b20      	ldrb	r0, [r4, #12]
 8001b76:	07c1      	lsls	r1, r0, #31
 8001b78:	0fc9      	lsrs	r1, r1, #31
 8001b7a:	2009      	movs	r0, #9
 8001b7c:	68ff      	ldr	r7, [r7, #12]
 8001b7e:	47b8      	blx	r7
 8001b80:	2141      	movs	r1, #65	; 0x41

08001b82 <__iar_annotation$$branch>:
 8001b82:	f7fe ffb3 	bl	8000aec <__iar_annotation$$branch+0xf4>
 8001b86:	8bb0      	ldrh	r0, [r6, #28]
 8001b88:	03aa      	lsls	r2, r5, #14
 8001b8a:	4290      	cmp	r0, r2
 8001b8c:	d102      	bne.n	8001b94 <__iar_annotation$$branch+0x12>
 8001b8e:	2000      	movs	r0, #0
 8001b90:	83b0      	strh	r0, [r6, #28]
 8001b92:	e02e      	b.n	8001bf2 <__iar_annotation$$branch>
 8001b94:	2914      	cmp	r1, #20
 8001b96:	d009      	beq.n	8001bac <__iar_annotation$$branch+0x2a>
 8001b98:	2000      	movs	r0, #0
 8001b9a:	83b0      	strh	r0, [r6, #28]
 8001b9c:	8eb0      	ldrh	r0, [r6, #52]	; 0x34
 8001b9e:	0bc0      	lsrs	r0, r0, #15
 8001ba0:	d027      	beq.n	8001bf2 <__iar_annotation$$branch>
 8001ba2:	e65f      	b.n	8001864 <__iar_annotation$$branch+0x296>
 8001ba4:	0020      	movs	r0, r4
 8001ba6:	f002 fce0 	bl	800456a <PE_SubStateMachine_ExtendedMessages>
 8001baa:	0005      	movs	r5, r0
 8001bac:	e718      	b.n	80019e0 <__iar_annotation$$branch>
 8001bae:	a903      	add	r1, sp, #12
 8001bb0:	0020      	movs	r0, r4
 8001bb2:	f002 fdf1 	bl	8004798 <PE_SubStateMachine_Generic>
 8001bb6:	e7f8      	b.n	8001baa <__iar_annotation$$branch+0x28>
 8001bb8:	a903      	add	r1, sp, #12
 8001bba:	0020      	movs	r0, r4
 8001bbc:	f002 ff5e 	bl	8004a7c <PE_SubStateMachine_VconnSwap>
 8001bc0:	0005      	movs	r5, r0
 8001bc2:	6860      	ldr	r0, [r4, #4]
 8001bc4:	6800      	ldr	r0, [r0, #0]
 8001bc6:	0340      	lsls	r0, r0, #13
 8001bc8:	0fc1      	lsrs	r1, r0, #31
 8001bca:	a80a      	add	r0, sp, #40	; 0x28
 8001bcc:	7800      	ldrb	r0, [r0, #0]
 8001bce:	f003 f9e4 	bl	8004f9a <USBPD_PRL_CableCapable>
 8001bd2:	e705      	b.n	80019e0 <__iar_annotation$$branch>
 8001bd4:	2106      	movs	r1, #6
 8001bd6:	a80a      	add	r0, sp, #40	; 0x28
 8001bd8:	7800      	ldrb	r0, [r0, #0]
 8001bda:	f008 f949 	bl	8009e70 <USBPD_PHY_ResetRequest>
 8001bde:	2007      	movs	r0, #7
 8001be0:	6861      	ldr	r1, [r4, #4]
 8001be2:	7849      	ldrb	r1, [r1, #1]
 8001be4:	0909      	lsrs	r1, r1, #4
 8001be6:	2207      	movs	r2, #7
 8001be8:	400a      	ands	r2, r1
 8001bea:	2a03      	cmp	r2, #3
 8001bec:	d001      	beq.n	8001bf2 <__iar_annotation$$branch>

08001bee <__iar_annotation$$branch>:
 8001bee:	f7fe fe67 	bl	80008c0 <__iar_annotation$$branch+0xe4>

08001bf2 <__iar_annotation$$branch>:
 8001bf2:	f7ff f91c 	bl	8000e2e <__iar_annotation$$branch+0x436>
 8001bf6:	7a30      	ldrb	r0, [r6, #8]
 8001bf8:	2803      	cmp	r0, #3
 8001bfa:	d110      	bne.n	8001c1e <__iar_annotation$$branch>
 8001bfc:	200e      	movs	r0, #14
 8001bfe:	5e30      	ldrsh	r0, [r6, r0]
 8001c00:	2800      	cmp	r0, #0
 8001c02:	d00c      	beq.n	8001c1e <__iar_annotation$$branch>
 8001c04:	2016      	movs	r0, #22
 8001c06:	5e20      	ldrsh	r0, [r4, r0]
 8001c08:	2800      	cmp	r0, #0
 8001c0a:	d108      	bne.n	8001c1e <__iar_annotation$$branch>
 8001c0c:	7b30      	ldrb	r0, [r6, #12]
 8001c0e:	7230      	strb	r0, [r6, #8]
 8001c10:	7b70      	ldrb	r0, [r6, #13]
 8001c12:	72f0      	strb	r0, [r6, #11]
 8001c14:	89f0      	ldrh	r0, [r6, #14]
 8001c16:	82e0      	strh	r0, [r4, #22]
 8001c18:	2000      	movs	r0, #0
 8001c1a:	81f0      	strh	r0, [r6, #14]
 8001c1c:	2501      	movs	r5, #1

08001c1e <__iar_annotation$$branch>:
 8001c1e:	f7fe ff0b 	bl	8000a38 <__iar_annotation$$branch+0x40>
	...

08001c24 <.text_18>:
 8001c24:	200019a8 	.word	0x200019a8

08001c28 <.text_19>:
 8001c28:	0000801a 	.word	0x0000801a

08001c2c <USBPD_PE_StateMachine_SNK>:
 8001c2c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001c2e:	b08f      	sub	sp, #60	; 0x3c
 8001c30:	0005      	movs	r5, r0
 8001c32:	48b3      	ldr	r0, [pc, #716]	; (8001f00 <__iar_annotation$$branch+0xce>)
 8001c34:	00a9      	lsls	r1, r5, #2
 8001c36:	1840      	adds	r0, r0, r1
 8001c38:	6840      	ldr	r0, [r0, #4]
 8001c3a:	9006      	str	r0, [sp, #24]
 8001c3c:	2400      	movs	r4, #0
 8001c3e:	21d9      	movs	r1, #217	; 0xd9
 8001c40:	0089      	lsls	r1, r1, #2
 8001c42:	1840      	adds	r0, r0, r1
 8001c44:	9004      	str	r0, [sp, #16]
 8001c46:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8001c48:	8807      	ldrh	r7, [r0, #0]
 8001c4a:	4668      	mov	r0, sp
 8001c4c:	9904      	ldr	r1, [sp, #16]
 8001c4e:	8849      	ldrh	r1, [r1, #2]
 8001c50:	82c1      	strh	r1, [r0, #22]
 8001c52:	9904      	ldr	r1, [sp, #16]
 8001c54:	8889      	ldrh	r1, [r1, #4]
 8001c56:	8281      	strh	r1, [r0, #20]
 8001c58:	9904      	ldr	r1, [sp, #16]
 8001c5a:	88c9      	ldrh	r1, [r1, #6]
 8001c5c:	81c1      	strh	r1, [r0, #14]
 8001c5e:	9904      	ldr	r1, [sp, #16]
 8001c60:	8909      	ldrh	r1, [r1, #8]
 8001c62:	8141      	strh	r1, [r0, #10]
 8001c64:	9904      	ldr	r1, [sp, #16]
 8001c66:	8949      	ldrh	r1, [r1, #10]
 8001c68:	8101      	strh	r1, [r0, #8]
 8001c6a:	9904      	ldr	r1, [sp, #16]
 8001c6c:	8989      	ldrh	r1, [r1, #12]
 8001c6e:	80c1      	strh	r1, [r0, #6]
 8001c70:	9904      	ldr	r1, [sp, #16]
 8001c72:	89c9      	ldrh	r1, [r1, #14]
 8001c74:	8081      	strh	r1, [r0, #4]
 8001c76:	9904      	ldr	r1, [sp, #16]
 8001c78:	89c9      	ldrh	r1, [r1, #14]
 8001c7a:	8041      	strh	r1, [r0, #2]
 8001c7c:	9904      	ldr	r1, [sp, #16]
 8001c7e:	8a09      	ldrh	r1, [r1, #16]
 8001c80:	8001      	strh	r1, [r0, #0]
 8001c82:	9804      	ldr	r0, [sp, #16]
 8001c84:	8a40      	ldrh	r0, [r0, #18]
 8001c86:	9904      	ldr	r1, [sp, #16]
 8001c88:	8a89      	ldrh	r1, [r1, #20]
 8001c8a:	9a04      	ldr	r2, [sp, #16]
 8001c8c:	8ad2      	ldrh	r2, [r2, #22]
 8001c8e:	9b04      	ldr	r3, [sp, #16]
 8001c90:	8c1b      	ldrh	r3, [r3, #32]
 8001c92:	0536      	lsls	r6, r6, #20
 8001c94:	0d36      	lsrs	r6, r6, #20
 8001c96:	19f6      	adds	r6, r6, r7
 8001c98:	466f      	mov	r7, sp
 8001c9a:	8aff      	ldrh	r7, [r7, #22]
 8001c9c:	19f6      	adds	r6, r6, r7
 8001c9e:	466f      	mov	r7, sp
 8001ca0:	8abf      	ldrh	r7, [r7, #20]
 8001ca2:	19f6      	adds	r6, r6, r7
 8001ca4:	466f      	mov	r7, sp
 8001ca6:	89ff      	ldrh	r7, [r7, #14]
 8001ca8:	19f6      	adds	r6, r6, r7
 8001caa:	466f      	mov	r7, sp
 8001cac:	897f      	ldrh	r7, [r7, #10]
 8001cae:	19f6      	adds	r6, r6, r7
 8001cb0:	466f      	mov	r7, sp
 8001cb2:	893f      	ldrh	r7, [r7, #8]
 8001cb4:	19f6      	adds	r6, r6, r7
 8001cb6:	466f      	mov	r7, sp
 8001cb8:	88ff      	ldrh	r7, [r7, #6]
 8001cba:	19f6      	adds	r6, r6, r7
 8001cbc:	466f      	mov	r7, sp
 8001cbe:	88bf      	ldrh	r7, [r7, #4]
 8001cc0:	19f6      	adds	r6, r6, r7
 8001cc2:	466f      	mov	r7, sp
 8001cc4:	887f      	ldrh	r7, [r7, #2]
 8001cc6:	19f6      	adds	r6, r6, r7
 8001cc8:	466f      	mov	r7, sp
 8001cca:	883f      	ldrh	r7, [r7, #0]
 8001ccc:	19f6      	adds	r6, r6, r7
 8001cce:	1830      	adds	r0, r6, r0
 8001cd0:	1840      	adds	r0, r0, r1
 8001cd2:	1880      	adds	r0, r0, r2
 8001cd4:	0519      	lsls	r1, r3, #20
 8001cd6:	0f49      	lsrs	r1, r1, #29
 8001cd8:	1840      	adds	r0, r0, r1
 8001cda:	9904      	ldr	r1, [sp, #16]
 8001cdc:	8c09      	ldrh	r1, [r1, #32]
 8001cde:	06c9      	lsls	r1, r1, #27
 8001ce0:	0ec9      	lsrs	r1, r1, #27
 8001ce2:	1846      	adds	r6, r0, r1
 8001ce4:	b2b6      	uxth	r6, r6
 8001ce6:	9806      	ldr	r0, [sp, #24]
 8001ce8:	f001 fe68 	bl	80039bc <PE_Check_RxEvent>
 8001cec:	4669      	mov	r1, sp
 8001cee:	7308      	strb	r0, [r1, #12]
 8001cf0:	2803      	cmp	r0, #3
 8001cf2:	d001      	beq.n	8001cf8 <__iar_annotation$$branch+0x4>

08001cf4 <__iar_annotation$$branch>:
 8001cf4:	f001 f97c 	bl	8002ff0 <__iar_annotation$$branch+0xaa0>
 8001cf8:	2001      	movs	r0, #1

08001cfa <__iar_annotation$$branch>:
 8001cfa:	f001 f974 	bl	8002fe6 <__iar_annotation$$branch+0xa96>
 8001cfe:	2400      	movs	r4, #0
 8001d00:	43e4      	mvns	r4, r4
 8001d02:	6868      	ldr	r0, [r5, #4]
 8001d04:	6801      	ldr	r1, [r0, #0]
 8001d06:	2210      	movs	r2, #16
 8001d08:	4391      	bics	r1, r2
 8001d0a:	6001      	str	r1, [r0, #0]

08001d0c <__iar_annotation$$branch>:
 8001d0c:	f001 f8fe 	bl	8002f0c <__iar_annotation$$branch+0x9bc>
 8001d10:	6868      	ldr	r0, [r5, #4]
 8001d12:	6800      	ldr	r0, [r0, #0]
 8001d14:	0340      	lsls	r0, r0, #13
 8001d16:	0fc1      	lsrs	r1, r0, #31
 8001d18:	4668      	mov	r0, sp
 8001d1a:	7b40      	ldrb	r0, [r0, #13]
 8001d1c:	f003 f93d 	bl	8004f9a <USBPD_PRL_CableCapable>
 8001d20:	2701      	movs	r7, #1
 8001d22:	68e9      	ldr	r1, [r5, #12]
 8001d24:	2001      	movs	r0, #1
 8001d26:	4008      	ands	r0, r1
 8001d28:	f003 fb94 	bl	8005454 <USBPD_PRL_Reset>
 8001d2c:	6868      	ldr	r0, [r5, #4]
 8001d2e:	6801      	ldr	r1, [r0, #0]
 8001d30:	0ac9      	lsrs	r1, r1, #11
 8001d32:	4039      	ands	r1, r7
 8001d34:	d0ea      	beq.n	8001d0c <__iar_annotation$$branch>
 8001d36:	2103      	movs	r1, #3
 8001d38:	682a      	ldr	r2, [r5, #0]
 8001d3a:	7913      	ldrb	r3, [r2, #4]
 8001d3c:	2203      	movs	r2, #3
 8001d3e:	401a      	ands	r2, r3
 8001d40:	7803      	ldrb	r3, [r0, #0]
 8001d42:	24fc      	movs	r4, #252	; 0xfc
 8001d44:	401c      	ands	r4, r3
 8001d46:	4322      	orrs	r2, r4
 8001d48:	7002      	strb	r2, [r0, #0]
 8001d4a:	6868      	ldr	r0, [r5, #4]
 8001d4c:	7802      	ldrb	r2, [r0, #0]
 8001d4e:	4011      	ands	r1, r2
 8001d50:	2901      	cmp	r1, #1
 8001d52:	d100      	bne.n	8001d56 <__iar_annotation$$branch+0x4a>
 8001d54:	2700      	movs	r7, #0
 8001d56:	219f      	movs	r1, #159	; 0x9f
 8001d58:	4011      	ands	r1, r2
 8001d5a:	017a      	lsls	r2, r7, #5
 8001d5c:	430a      	orrs	r2, r1
 8001d5e:	7002      	strb	r2, [r0, #0]
 8001d60:	48b3      	ldr	r0, [pc, #716]	; (8002030 <__iar_annotation$$branch+0x1fe>)
 8001d62:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001d64:	24fa      	movs	r4, #250	; 0xfa
 8001d66:	0064      	lsls	r4, r4, #1

08001d68 <__iar_annotation$$branch>:
 8001d68:	f001 f8ce 	bl	8002f08 <__iar_annotation$$branch+0x9b8>
 8001d6c:	2911      	cmp	r1, #17
 8001d6e:	d131      	bne.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d70:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d72:	0bc0      	lsrs	r0, r0, #15
 8001d74:	d12e      	bne.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d76:	2707      	movs	r7, #7
 8001d78:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d7a:	0b00      	lsrs	r0, r0, #12
 8001d7c:	4238      	tst	r0, r7
 8001d7e:	d029      	beq.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d80:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d82:	06c0      	lsls	r0, r0, #27
 8001d84:	0ec0      	lsrs	r0, r0, #27
 8001d86:	2801      	cmp	r0, #1
 8001d88:	d124      	bne.n	8001dd4 <__iar_annotation$$branch+0x6c>
 8001d8a:	2000      	movs	r0, #0
 8001d8c:	7528      	strb	r0, [r5, #20]
 8001d8e:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d90:	0600      	lsls	r0, r0, #24
 8001d92:	0f81      	lsrs	r1, r0, #30
 8001d94:	4668      	mov	r0, sp
 8001d96:	7b40      	ldrb	r0, [r0, #13]
 8001d98:	f002 fb1a 	bl	80043d0 <PE_ExtRevisionInteroperability>
 8001d9c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001d9e:	0b00      	lsrs	r0, r0, #12
 8001da0:	4007      	ands	r7, r0
 8001da2:	00bb      	lsls	r3, r7, #2
 8001da4:	209e      	movs	r0, #158	; 0x9e
 8001da6:	0040      	lsls	r0, r0, #1
 8001da8:	182a      	adds	r2, r5, r0
 8001daa:	2104      	movs	r1, #4
 8001dac:	7b2f      	ldrb	r7, [r5, #12]
 8001dae:	07f8      	lsls	r0, r7, #31
 8001db0:	0fc0      	lsrs	r0, r0, #31
 8001db2:	68af      	ldr	r7, [r5, #8]
 8001db4:	69ff      	ldr	r7, [r7, #28]
 8001db6:	47b8      	blx	r7
 8001db8:	2001      	movs	r0, #1
 8001dba:	82e8      	strh	r0, [r5, #22]
 8001dbc:	2044      	movs	r0, #68	; 0x44
 8001dbe:	7130      	strb	r0, [r6, #4]
 8001dc0:	6868      	ldr	r0, [r5, #4]
 8001dc2:	6801      	ldr	r1, [r0, #0]
 8001dc4:	2210      	movs	r2, #16
 8001dc6:	4391      	bics	r1, r2
 8001dc8:	6001      	str	r1, [r0, #0]
 8001dca:	2000      	movs	r0, #0
 8001dcc:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001dce:	2014      	movs	r0, #20
 8001dd0:	4669      	mov	r1, sp
 8001dd2:	7308      	strb	r0, [r1, #12]
 8001dd4:	8cf0      	ldrh	r0, [r6, #38]	; 0x26
 8001dd6:	03a1      	lsls	r1, r4, #14
 8001dd8:	4288      	cmp	r0, r1
 8001dda:	d197      	bne.n	8001d0c <__iar_annotation$$branch>
 8001ddc:	6868      	ldr	r0, [r5, #4]
 8001dde:	6801      	ldr	r1, [r0, #0]
 8001de0:	2210      	movs	r2, #16
 8001de2:	4391      	bics	r1, r2
 8001de4:	6001      	str	r1, [r0, #0]
 8001de6:	2000      	movs	r0, #0
 8001de8:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001dea:	e241      	b.n	8002270 <__iar_annotation$$branch>
 8001dec:	2001      	movs	r0, #1
 8001dee:	82e8      	strh	r0, [r5, #22]
 8001df0:	466a      	mov	r2, sp
 8001df2:	0029      	movs	r1, r5
 8001df4:	3110      	adds	r1, #16
 8001df6:	68eb      	ldr	r3, [r5, #12]
 8001df8:	4018      	ands	r0, r3
 8001dfa:	68ab      	ldr	r3, [r5, #8]
 8001dfc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001dfe:	4798      	blx	r3
 8001e00:	7b28      	ldrb	r0, [r5, #12]
 8001e02:	21f3      	movs	r1, #243	; 0xf3
 8001e04:	4001      	ands	r1, r0
 8001e06:	4668      	mov	r0, sp
 8001e08:	7800      	ldrb	r0, [r0, #0]
 8001e0a:	0080      	lsls	r0, r0, #2
 8001e0c:	220c      	movs	r2, #12
 8001e0e:	4002      	ands	r2, r0
 8001e10:	430a      	orrs	r2, r1
 8001e12:	732a      	strb	r2, [r5, #12]
 8001e14:	2045      	movs	r0, #69	; 0x45
 8001e16:	e181      	b.n	800211c <__iar_annotation$$branch+0x2ea>
 8001e18:	2000      	movs	r0, #0
 8001e1a:	9002      	str	r0, [sp, #8]
 8001e1c:	2046      	movs	r0, #70	; 0x46
 8001e1e:	9001      	str	r0, [sp, #4]
 8001e20:	2001      	movs	r0, #1
 8001e22:	9000      	str	r0, [sp, #0]
 8001e24:	002b      	movs	r3, r5
 8001e26:	3310      	adds	r3, #16
 8001e28:	2202      	movs	r2, #2
 8001e2a:	2100      	movs	r1, #0
 8001e2c:	0028      	movs	r0, r5
 8001e2e:	f001 fce7 	bl	8003800 <PE_Send_DataMessage>

08001e32 <__iar_annotation$$branch>:
 8001e32:	f000 fff6 	bl	8002e22 <__iar_annotation$$branch+0x8d2>
 8001e36:	2911      	cmp	r1, #17
 8001e38:	d111      	bne.n	8001e5e <__iar_annotation$$branch+0x2c>
 8001e3a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001e3c:	0bc9      	lsrs	r1, r1, #15
 8001e3e:	d10e      	bne.n	8001e5e <__iar_annotation$$branch+0x2c>
 8001e40:	2107      	movs	r1, #7
 8001e42:	8e32      	ldrh	r2, [r6, #48]	; 0x30
 8001e44:	0b12      	lsrs	r2, r2, #12
 8001e46:	420a      	tst	r2, r1
 8001e48:	d109      	bne.n	8001e5e <__iar_annotation$$branch+0x2c>
 8001e4a:	8e32      	ldrh	r2, [r6, #48]	; 0x30
 8001e4c:	06d2      	lsls	r2, r2, #27
 8001e4e:	0ed2      	lsrs	r2, r2, #27
 8001e50:	1e92      	subs	r2, r2, #2
 8001e52:	2a01      	cmp	r2, #1
 8001e54:	d904      	bls.n	8001e60 <__iar_annotation$$branch+0x2e>
 8001e56:	1e92      	subs	r2, r2, #2
 8001e58:	d026      	beq.n	8001ea8 <__iar_annotation$$branch+0x76>
 8001e5a:	3a08      	subs	r2, #8
 8001e5c:	d024      	beq.n	8001ea8 <__iar_annotation$$branch+0x76>
 8001e5e:	e08a      	b.n	8001f76 <__iar_annotation$$branch+0x144>
 8001e60:	2100      	movs	r1, #0
 8001e62:	8331      	strh	r1, [r6, #24]
 8001e64:	8471      	strh	r1, [r6, #34]	; 0x22
 8001e66:	2147      	movs	r1, #71	; 0x47
 8001e68:	7131      	strb	r1, [r6, #4]
 8001e6a:	4971      	ldr	r1, [pc, #452]	; (8002030 <__iar_annotation$$branch+0x1fe>)
 8001e6c:	8471      	strh	r1, [r6, #34]	; 0x22
 8001e6e:	24fa      	movs	r4, #250	; 0xfa
 8001e70:	0064      	lsls	r4, r4, #1
 8001e72:	6869      	ldr	r1, [r5, #4]
 8001e74:	784a      	ldrb	r2, [r1, #1]
 8001e76:	238f      	movs	r3, #143	; 0x8f
 8001e78:	4013      	ands	r3, r2
 8001e7a:	2240      	movs	r2, #64	; 0x40
 8001e7c:	431a      	orrs	r2, r3
 8001e7e:	704a      	strb	r2, [r1, #1]
 8001e80:	2800      	cmp	r0, #0
 8001e82:	d009      	beq.n	8001e98 <__iar_annotation$$branch+0x66>
 8001e84:	2000      	movs	r0, #0
 8001e86:	9000      	str	r0, [sp, #0]
 8001e88:	2300      	movs	r3, #0
 8001e8a:	2256      	movs	r2, #86	; 0x56
 8001e8c:	7b28      	ldrb	r0, [r5, #12]
 8001e8e:	07c1      	lsls	r1, r0, #31
 8001e90:	0fc9      	lsrs	r1, r1, #31
 8001e92:	2009      	movs	r0, #9
 8001e94:	9f01      	ldr	r7, [sp, #4]
 8001e96:	47b8      	blx	r7
 8001e98:	2156      	movs	r1, #86	; 0x56
 8001e9a:	7b2a      	ldrb	r2, [r5, #12]
 8001e9c:	07d0      	lsls	r0, r2, #31
 8001e9e:	0fc0      	lsrs	r0, r0, #31
 8001ea0:	68aa      	ldr	r2, [r5, #8]
 8001ea2:	68d2      	ldr	r2, [r2, #12]
 8001ea4:	4790      	blx	r2
 8001ea6:	e016      	b.n	8001ed6 <__iar_annotation$$branch+0xa4>
 8001ea8:	2400      	movs	r4, #0
 8001eaa:	8474      	strh	r4, [r6, #34]	; 0x22
 8001eac:	6868      	ldr	r0, [r5, #4]
 8001eae:	7840      	ldrb	r0, [r0, #1]
 8001eb0:	0900      	lsrs	r0, r0, #4
 8001eb2:	4001      	ands	r1, r0
 8001eb4:	2903      	cmp	r1, #3
 8001eb6:	d005      	beq.n	8001ec4 <__iar_annotation$$branch+0x92>
 8001eb8:	485d      	ldr	r0, [pc, #372]	; (8002030 <__iar_annotation$$branch+0x1fe>)
 8001eba:	84f0      	strh	r0, [r6, #38]	; 0x26
 8001ebc:	24fa      	movs	r4, #250	; 0xfa
 8001ebe:	0064      	lsls	r4, r4, #1
 8001ec0:	2043      	movs	r0, #67	; 0x43
 8001ec2:	e007      	b.n	8001ed4 <__iar_annotation$$branch+0xa2>
 8001ec4:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8001ec6:	06c0      	lsls	r0, r0, #27
 8001ec8:	0ec0      	lsrs	r0, r0, #27
 8001eca:	280c      	cmp	r0, #12
 8001ecc:	d101      	bne.n	8001ed2 <__iar_annotation$$branch+0xa0>
 8001ece:	2049      	movs	r0, #73	; 0x49
 8001ed0:	e000      	b.n	8001ed4 <__iar_annotation$$branch+0xa2>
 8001ed2:	2003      	movs	r0, #3
 8001ed4:	7130      	strb	r0, [r6, #4]
 8001ed6:	2014      	movs	r0, #20
 8001ed8:	4669      	mov	r1, sp
 8001eda:	7308      	strb	r0, [r1, #12]
 8001edc:	4808      	ldr	r0, [pc, #32]	; (8001f00 <__iar_annotation$$branch+0xce>)
 8001ede:	68c7      	ldr	r7, [r0, #12]
 8001ee0:	7800      	ldrb	r0, [r0, #0]
 8001ee2:	2102      	movs	r1, #2
 8001ee4:	4008      	ands	r0, r1
 8001ee6:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001ee8:	06c9      	lsls	r1, r1, #27
 8001eea:	0ec9      	lsrs	r1, r1, #27
 8001eec:	2902      	cmp	r1, #2
 8001eee:	d016      	beq.n	8001f1e <__iar_annotation$$branch+0xec>
 8001ef0:	2903      	cmp	r1, #3
 8001ef2:	d007      	beq.n	8001f04 <__iar_annotation$$branch+0xd2>
 8001ef4:	2904      	cmp	r1, #4
 8001ef6:	d01f      	beq.n	8001f38 <__iar_annotation$$branch+0x106>
 8001ef8:	290c      	cmp	r1, #12
 8001efa:	d02a      	beq.n	8001f52 <__iar_annotation$$branch+0x120>
 8001efc:	e03b      	b.n	8001f76 <__iar_annotation$$branch+0x144>
 8001efe:	bf00      	nop
 8001f00:	200019a8 	.word	0x200019a8
 8001f04:	2800      	cmp	r0, #0
 8001f06:	d008      	beq.n	8001f1a <__iar_annotation$$branch+0xe8>
 8001f08:	2000      	movs	r0, #0
 8001f0a:	9000      	str	r0, [sp, #0]
 8001f0c:	2300      	movs	r3, #0
 8001f0e:	2201      	movs	r2, #1
 8001f10:	7b28      	ldrb	r0, [r5, #12]
 8001f12:	07c1      	lsls	r1, r0, #31
 8001f14:	0fc9      	lsrs	r1, r1, #31
 8001f16:	2009      	movs	r0, #9
 8001f18:	47b8      	blx	r7
 8001f1a:	2101      	movs	r1, #1
 8001f1c:	e025      	b.n	8001f6a <__iar_annotation$$branch+0x138>
 8001f1e:	2800      	cmp	r0, #0
 8001f20:	d008      	beq.n	8001f34 <__iar_annotation$$branch+0x102>
 8001f22:	2000      	movs	r0, #0
 8001f24:	9000      	str	r0, [sp, #0]
 8001f26:	2300      	movs	r3, #0
 8001f28:	2204      	movs	r2, #4
 8001f2a:	7b28      	ldrb	r0, [r5, #12]
 8001f2c:	07c1      	lsls	r1, r0, #31
 8001f2e:	0fc9      	lsrs	r1, r1, #31
 8001f30:	2009      	movs	r0, #9
 8001f32:	47b8      	blx	r7
 8001f34:	2104      	movs	r1, #4
 8001f36:	e018      	b.n	8001f6a <__iar_annotation$$branch+0x138>
 8001f38:	2800      	cmp	r0, #0
 8001f3a:	d008      	beq.n	8001f4e <__iar_annotation$$branch+0x11c>
 8001f3c:	2000      	movs	r0, #0
 8001f3e:	9000      	str	r0, [sp, #0]
 8001f40:	2300      	movs	r3, #0
 8001f42:	2202      	movs	r2, #2
 8001f44:	7b28      	ldrb	r0, [r5, #12]
 8001f46:	07c1      	lsls	r1, r0, #31
 8001f48:	0fc9      	lsrs	r1, r1, #31
 8001f4a:	2009      	movs	r0, #9
 8001f4c:	47b8      	blx	r7
 8001f4e:	2102      	movs	r1, #2
 8001f50:	e00b      	b.n	8001f6a <__iar_annotation$$branch+0x138>
 8001f52:	2800      	cmp	r0, #0
 8001f54:	d008      	beq.n	8001f68 <__iar_annotation$$branch+0x136>
 8001f56:	2000      	movs	r0, #0
 8001f58:	9000      	str	r0, [sp, #0]
 8001f5a:	2300      	movs	r3, #0
 8001f5c:	2203      	movs	r2, #3
 8001f5e:	7b28      	ldrb	r0, [r5, #12]
 8001f60:	07c1      	lsls	r1, r0, #31
 8001f62:	0fc9      	lsrs	r1, r1, #31
 8001f64:	2009      	movs	r0, #9
 8001f66:	47b8      	blx	r7
 8001f68:	2103      	movs	r1, #3
 8001f6a:	7b2a      	ldrb	r2, [r5, #12]
 8001f6c:	07d0      	lsls	r0, r2, #31
 8001f6e:	0fc0      	lsrs	r0, r0, #31
 8001f70:	68aa      	ldr	r2, [r5, #8]
 8001f72:	68d2      	ldr	r2, [r2, #12]
 8001f74:	4790      	blx	r2
 8001f76:	8b30      	ldrh	r0, [r6, #24]
 8001f78:	2180      	movs	r1, #128	; 0x80
 8001f7a:	0209      	lsls	r1, r1, #8
 8001f7c:	4288      	cmp	r0, r1
 8001f7e:	d000      	beq.n	8001f82 <__iar_annotation$$branch+0x150>
 8001f80:	e6c4      	b.n	8001d0c <__iar_annotation$$branch>
 8001f82:	2400      	movs	r4, #0
 8001f84:	8334      	strh	r4, [r6, #24]
 8001f86:	e173      	b.n	8002270 <__iar_annotation$$branch>
 8001f88:	2911      	cmp	r1, #17
 8001f8a:	d148      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001f8c:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001f8e:	0bc9      	lsrs	r1, r1, #15
 8001f90:	d145      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001f92:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001f94:	0b09      	lsrs	r1, r1, #12
 8001f96:	0749      	lsls	r1, r1, #29
 8001f98:	d141      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001f9a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8001f9c:	06c9      	lsls	r1, r1, #27
 8001f9e:	0ec9      	lsrs	r1, r1, #27
 8001fa0:	2906      	cmp	r1, #6
 8001fa2:	d13c      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8001fa4:	2400      	movs	r4, #0
 8001fa6:	8474      	strh	r4, [r6, #34]	; 0x22
 8001fa8:	2114      	movs	r1, #20
 8001faa:	466a      	mov	r2, sp
 8001fac:	7311      	strb	r1, [r2, #12]
 8001fae:	6869      	ldr	r1, [r5, #4]
 8001fb0:	784a      	ldrb	r2, [r1, #1]
 8001fb2:	238f      	movs	r3, #143	; 0x8f
 8001fb4:	4013      	ands	r3, r2
 8001fb6:	2230      	movs	r2, #48	; 0x30
 8001fb8:	431a      	orrs	r2, r3
 8001fba:	704a      	strb	r2, [r1, #1]
 8001fbc:	2800      	cmp	r0, #0
 8001fbe:	d008      	beq.n	8001fd2 <__iar_annotation$$branch+0x1a0>
 8001fc0:	9400      	str	r4, [sp, #0]
 8001fc2:	2300      	movs	r3, #0
 8001fc4:	2256      	movs	r2, #86	; 0x56
 8001fc6:	7b28      	ldrb	r0, [r5, #12]
 8001fc8:	07c1      	lsls	r1, r0, #31
 8001fca:	0fc9      	lsrs	r1, r1, #31
 8001fcc:	2009      	movs	r0, #9
 8001fce:	9f01      	ldr	r7, [sp, #4]
 8001fd0:	47b8      	blx	r7
 8001fd2:	2156      	movs	r1, #86	; 0x56
 8001fd4:	7b2a      	ldrb	r2, [r5, #12]
 8001fd6:	07d0      	lsls	r0, r2, #31
 8001fd8:	0fc0      	lsrs	r0, r0, #31
 8001fda:	68aa      	ldr	r2, [r5, #8]
 8001fdc:	68d2      	ldr	r2, [r2, #12]
 8001fde:	4790      	blx	r2
 8001fe0:	82ec      	strh	r4, [r5, #22]
 8001fe2:	2003      	movs	r0, #3
 8001fe4:	7130      	strb	r0, [r6, #4]
 8001fe6:	4fb0      	ldr	r7, [pc, #704]	; (80022a8 <__iar_annotation$$branch+0x38>)
 8001fe8:	7838      	ldrb	r0, [r7, #0]
 8001fea:	0780      	lsls	r0, r0, #30
 8001fec:	d508      	bpl.n	8002000 <__iar_annotation$$branch+0x1ce>
 8001fee:	9400      	str	r4, [sp, #0]
 8001ff0:	2300      	movs	r3, #0
 8001ff2:	2210      	movs	r2, #16
 8001ff4:	7b28      	ldrb	r0, [r5, #12]
 8001ff6:	07c1      	lsls	r1, r0, #31
 8001ff8:	0fc9      	lsrs	r1, r1, #31
 8001ffa:	2009      	movs	r0, #9
 8001ffc:	68ff      	ldr	r7, [r7, #12]
 8001ffe:	47b8      	blx	r7
 8002000:	2110      	movs	r1, #16
 8002002:	7b2a      	ldrb	r2, [r5, #12]
 8002004:	07d0      	lsls	r0, r2, #31
 8002006:	0fc0      	lsrs	r0, r0, #31
 8002008:	68aa      	ldr	r2, [r5, #8]
 800200a:	68d2      	ldr	r2, [r2, #12]
 800200c:	4790      	blx	r2
 800200e:	7b28      	ldrb	r0, [r5, #12]
 8002010:	0700      	lsls	r0, r0, #28
 8002012:	0f80      	lsrs	r0, r0, #30
 8002014:	2803      	cmp	r0, #3
 8002016:	d102      	bne.n	800201e <__iar_annotation$$branch+0x1ec>
 8002018:	48a4      	ldr	r0, [pc, #656]	; (80022ac <__iar_annotation$$branch+0x3c>)
 800201a:	85b0      	strh	r0, [r6, #44]	; 0x2c
 800201c:	4ca4      	ldr	r4, [pc, #656]	; (80022b0 <__iar_annotation$$branch+0x40>)
 800201e:	8c70      	ldrh	r0, [r6, #34]	; 0x22
 8002020:	2180      	movs	r1, #128	; 0x80
 8002022:	0209      	lsls	r1, r1, #8
 8002024:	4288      	cmp	r0, r1
 8002026:	d000      	beq.n	800202a <__iar_annotation$$branch+0x1f8>
 8002028:	e670      	b.n	8001d0c <__iar_annotation$$branch>
 800202a:	2400      	movs	r4, #0
 800202c:	8474      	strh	r4, [r6, #34]	; 0x22
 800202e:	e11f      	b.n	8002270 <__iar_annotation$$branch>
 8002030:	000081f4 	.word	0x000081f4
 8002034:	7b69      	ldrb	r1, [r5, #13]
 8002036:	22fc      	movs	r2, #252	; 0xfc
 8002038:	400a      	ands	r2, r1
 800203a:	736a      	strb	r2, [r5, #13]
 800203c:	686a      	ldr	r2, [r5, #4]
 800203e:	2110      	movs	r1, #16
 8002040:	6813      	ldr	r3, [r2, #0]
 8002042:	430b      	orrs	r3, r1
 8002044:	6013      	str	r3, [r2, #0]
 8002046:	2200      	movs	r2, #0
 8002048:	82ea      	strh	r2, [r5, #22]
 800204a:	686a      	ldr	r2, [r5, #4]
 800204c:	7853      	ldrb	r3, [r2, #1]
 800204e:	278f      	movs	r7, #143	; 0x8f
 8002050:	401f      	ands	r7, r3
 8002052:	4339      	orrs	r1, r7
 8002054:	7051      	strb	r1, [r2, #1]
 8002056:	2800      	cmp	r0, #0
 8002058:	d009      	beq.n	800206e <__iar_annotation$$branch+0x23c>
 800205a:	2000      	movs	r0, #0
 800205c:	9000      	str	r0, [sp, #0]
 800205e:	2300      	movs	r3, #0
 8002060:	2256      	movs	r2, #86	; 0x56
 8002062:	7b28      	ldrb	r0, [r5, #12]
 8002064:	07c1      	lsls	r1, r0, #31
 8002066:	0fc9      	lsrs	r1, r1, #31
 8002068:	2009      	movs	r0, #9
 800206a:	9f01      	ldr	r7, [sp, #4]
 800206c:	47b8      	blx	r7
 800206e:	2156      	movs	r1, #86	; 0x56
 8002070:	7b2a      	ldrb	r2, [r5, #12]
 8002072:	07d0      	lsls	r0, r2, #31
 8002074:	0fc0      	lsrs	r0, r0, #31
 8002076:	68aa      	ldr	r2, [r5, #8]
 8002078:	68d2      	ldr	r2, [r2, #12]
 800207a:	4790      	blx	r2
 800207c:	2700      	movs	r7, #0
 800207e:	7037      	strb	r7, [r6, #0]
 8002080:	7d28      	ldrb	r0, [r5, #20]
 8002082:	2803      	cmp	r0, #3
 8002084:	d302      	bcc.n	800208c <__iar_annotation$$branch+0x25a>
 8002086:	752f      	strb	r7, [r5, #20]
 8002088:	7137      	strb	r7, [r6, #4]
 800208a:	e3ab      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800208c:	1c40      	adds	r0, r0, #1
 800208e:	7528      	strb	r0, [r5, #20]
 8002090:	0028      	movs	r0, r5
 8002092:	f001 fc1b 	bl	80038cc <PE_Send_HARDRESET>
 8002096:	2101      	movs	r1, #1
 8002098:	4668      	mov	r0, sp
 800209a:	7b40      	ldrb	r0, [r0, #13]
 800209c:	f002 f877 	bl	800418e <PE_Reset>
 80020a0:	6868      	ldr	r0, [r5, #4]
 80020a2:	6801      	ldr	r1, [r0, #0]
 80020a4:	2210      	movs	r2, #16
 80020a6:	430a      	orrs	r2, r1
 80020a8:	6002      	str	r2, [r0, #0]
 80020aa:	4882      	ldr	r0, [pc, #520]	; (80022b4 <__iar_annotation$$branch+0x44>)
 80020ac:	8270      	strh	r0, [r6, #18]
 80020ae:	209b      	movs	r0, #155	; 0x9b
 80020b0:	7130      	strb	r0, [r6, #4]
 80020b2:	e38d      	b.n	80027d0 <__iar_annotation$$branch+0x280>
 80020b4:	68e8      	ldr	r0, [r5, #12]
 80020b6:	4a80      	ldr	r2, [pc, #512]	; (80022b8 <__iar_annotation$$branch+0x48>)
 80020b8:	4002      	ands	r2, r0
 80020ba:	60ea      	str	r2, [r5, #12]
 80020bc:	2401      	movs	r4, #1
 80020be:	6868      	ldr	r0, [r5, #4]
 80020c0:	6800      	ldr	r0, [r0, #0]
 80020c2:	0c80      	lsrs	r0, r0, #18
 80020c4:	4020      	ands	r0, r4
 80020c6:	d007      	beq.n	80020d8 <__iar_annotation$$branch+0x2a6>
 80020c8:	68a8      	ldr	r0, [r5, #8]
 80020ca:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80020cc:	2b00      	cmp	r3, #0
 80020ce:	d003      	beq.n	80020d8 <__iar_annotation$$branch+0x2a6>
 80020d0:	2100      	movs	r1, #0
 80020d2:	2001      	movs	r0, #1
 80020d4:	4010      	ands	r0, r2
 80020d6:	4798      	blx	r3
 80020d8:	4f73      	ldr	r7, [pc, #460]	; (80022a8 <__iar_annotation$$branch+0x38>)
 80020da:	7838      	ldrb	r0, [r7, #0]
 80020dc:	0780      	lsls	r0, r0, #30
 80020de:	d509      	bpl.n	80020f4 <__iar_annotation$$branch+0x2c2>
 80020e0:	2000      	movs	r0, #0
 80020e2:	9000      	str	r0, [sp, #0]
 80020e4:	2300      	movs	r3, #0
 80020e6:	221d      	movs	r2, #29
 80020e8:	68e8      	ldr	r0, [r5, #12]
 80020ea:	2101      	movs	r1, #1
 80020ec:	4001      	ands	r1, r0
 80020ee:	2009      	movs	r0, #9
 80020f0:	68ff      	ldr	r7, [r7, #12]
 80020f2:	47b8      	blx	r7
 80020f4:	211d      	movs	r1, #29
 80020f6:	68e8      	ldr	r0, [r5, #12]
 80020f8:	4004      	ands	r4, r0
 80020fa:	0020      	movs	r0, r4
 80020fc:	68aa      	ldr	r2, [r5, #8]
 80020fe:	68d2      	ldr	r2, [r2, #12]
 8002100:	4790      	blx	r2
 8002102:	2101      	movs	r1, #1
 8002104:	4668      	mov	r0, sp
 8002106:	7b40      	ldrb	r0, [r0, #13]
 8002108:	f002 f841 	bl	800418e <PE_Reset>
 800210c:	6868      	ldr	r0, [r5, #4]
 800210e:	6801      	ldr	r1, [r0, #0]
 8002110:	2210      	movs	r2, #16
 8002112:	430a      	orrs	r2, r1
 8002114:	6002      	str	r2, [r0, #0]
 8002116:	4867      	ldr	r0, [pc, #412]	; (80022b4 <__iar_annotation$$branch+0x44>)
 8002118:	8270      	strh	r0, [r6, #18]
 800211a:	209b      	movs	r0, #155	; 0x9b
 800211c:	e357      	b.n	80027ce <__iar_annotation$$branch+0x27e>
 800211e:	68a8      	ldr	r0, [r5, #8]
 8002120:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8002122:	2a00      	cmp	r2, #0
 8002124:	d005      	beq.n	8002132 <__iar_annotation$$branch+0x300>
 8002126:	2100      	movs	r1, #0
 8002128:	4668      	mov	r0, sp
 800212a:	7b40      	ldrb	r0, [r0, #13]
 800212c:	4790      	blx	r2
 800212e:	2801      	cmp	r0, #1
 8002130:	d004      	beq.n	800213c <__iar_annotation$$branch+0x30a>
 8002132:	8a70      	ldrh	r0, [r6, #18]
 8002134:	03a1      	lsls	r1, r4, #14
 8002136:	4288      	cmp	r0, r1
 8002138:	d000      	beq.n	800213c <__iar_annotation$$branch+0x30a>
 800213a:	e353      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800213c:	485f      	ldr	r0, [pc, #380]	; (80022bc <__iar_annotation$$branch+0x4c>)
 800213e:	8270      	strh	r0, [r6, #18]
 8002140:	2040      	movs	r0, #64	; 0x40
 8002142:	7130      	strb	r0, [r6, #4]
 8002144:	2400      	movs	r4, #0
 8002146:	4f58      	ldr	r7, [pc, #352]	; (80022a8 <__iar_annotation$$branch+0x38>)
 8002148:	7838      	ldrb	r0, [r7, #0]
 800214a:	0780      	lsls	r0, r0, #30
 800214c:	d508      	bpl.n	8002160 <__iar_annotation$$branch+0x32e>
 800214e:	9400      	str	r4, [sp, #0]
 8002150:	2300      	movs	r3, #0
 8002152:	2213      	movs	r2, #19
 8002154:	7b28      	ldrb	r0, [r5, #12]
 8002156:	07c1      	lsls	r1, r0, #31
 8002158:	0fc9      	lsrs	r1, r1, #31
 800215a:	2009      	movs	r0, #9
 800215c:	68ff      	ldr	r7, [r7, #12]
 800215e:	47b8      	blx	r7
 8002160:	2113      	movs	r1, #19
 8002162:	e377      	b.n	8002854 <__iar_annotation$$branch+0x304>
 8002164:	68a8      	ldr	r0, [r5, #8]
 8002166:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8002168:	2a00      	cmp	r2, #0
 800216a:	d012      	beq.n	8002192 <__iar_annotation$$branch+0x360>
 800216c:	2101      	movs	r1, #1
 800216e:	4668      	mov	r0, sp
 8002170:	7b40      	ldrb	r0, [r0, #13]
 8002172:	4790      	blx	r2
 8002174:	2801      	cmp	r0, #1
 8002176:	d10c      	bne.n	8002192 <__iar_annotation$$branch+0x360>
 8002178:	6868      	ldr	r0, [r5, #4]
 800217a:	6801      	ldr	r1, [r0, #0]
 800217c:	2210      	movs	r2, #16
 800217e:	4391      	bics	r1, r2
 8002180:	6001      	str	r1, [r0, #0]
 8002182:	2000      	movs	r0, #0
 8002184:	8270      	strh	r0, [r6, #18]
 8002186:	484e      	ldr	r0, [pc, #312]	; (80022c0 <__iar_annotation$$branch+0x50>)
 8002188:	84f0      	strh	r0, [r6, #38]	; 0x26
 800218a:	24fa      	movs	r4, #250	; 0xfa
 800218c:	0064      	lsls	r4, r4, #1
 800218e:	2043      	movs	r0, #67	; 0x43
 8002190:	7130      	strb	r0, [r6, #4]
 8002192:	8a70      	ldrh	r0, [r6, #18]
 8002194:	2180      	movs	r1, #128	; 0x80
 8002196:	0209      	lsls	r1, r1, #8
 8002198:	4288      	cmp	r0, r1
 800219a:	d000      	beq.n	800219e <__iar_annotation$$branch+0x36c>
 800219c:	e322      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800219e:	2000      	movs	r0, #0
 80021a0:	8270      	strh	r0, [r6, #18]
 80021a2:	6868      	ldr	r0, [r5, #4]
 80021a4:	6801      	ldr	r1, [r0, #0]
 80021a6:	2210      	movs	r2, #16
 80021a8:	4391      	bics	r1, r2
 80021aa:	6001      	str	r1, [r0, #0]
 80021ac:	e060      	b.n	8002270 <__iar_annotation$$branch>
 80021ae:	0028      	movs	r0, r5
 80021b0:	f001 fbc5 	bl	800393e <PE_PerformSoftReset>
 80021b4:	2000      	movs	r0, #0
 80021b6:	9000      	str	r0, [sp, #0]
 80021b8:	2303      	movs	r3, #3
 80021ba:	2203      	movs	r2, #3
 80021bc:	2100      	movs	r1, #0
 80021be:	0028      	movs	r0, r5
 80021c0:	f001 fad7 	bl	8003772 <PE_Send_CtrlMessage>
 80021c4:	4f38      	ldr	r7, [pc, #224]	; (80022a8 <__iar_annotation$$branch+0x38>)
 80021c6:	7838      	ldrb	r0, [r7, #0]
 80021c8:	0780      	lsls	r0, r0, #30
 80021ca:	d509      	bpl.n	80021e0 <__iar_annotation$$branch+0x3ae>
 80021cc:	2000      	movs	r0, #0
 80021ce:	9000      	str	r0, [sp, #0]
 80021d0:	2300      	movs	r3, #0
 80021d2:	222f      	movs	r2, #47	; 0x2f
 80021d4:	7b28      	ldrb	r0, [r5, #12]
 80021d6:	07c1      	lsls	r1, r0, #31
 80021d8:	0fc9      	lsrs	r1, r1, #31
 80021da:	2009      	movs	r0, #9
 80021dc:	68ff      	ldr	r7, [r7, #12]
 80021de:	47b8      	blx	r7
 80021e0:	212f      	movs	r1, #47	; 0x2f
 80021e2:	e337      	b.n	8002854 <__iar_annotation$$branch+0x304>
 80021e4:	6868      	ldr	r0, [r5, #4]
 80021e6:	7840      	ldrb	r0, [r0, #1]
 80021e8:	0640      	lsls	r0, r0, #25
 80021ea:	0f40      	lsrs	r0, r0, #29
 80021ec:	2804      	cmp	r0, #4
 80021ee:	d101      	bne.n	80021f4 <__iar_annotation$$branch+0x3c2>
 80021f0:	200f      	movs	r0, #15
 80021f2:	e2ec      	b.n	80027ce <__iar_annotation$$branch+0x27e>
 80021f4:	2000      	movs	r0, #0
 80021f6:	9000      	str	r0, [sp, #0]
 80021f8:	2350      	movs	r3, #80	; 0x50
 80021fa:	220d      	movs	r2, #13
 80021fc:	2100      	movs	r1, #0
 80021fe:	0028      	movs	r0, r5
 8002200:	f001 fab7 	bl	8003772 <PE_Send_CtrlMessage>
 8002204:	2800      	cmp	r0, #0
 8002206:	d000      	beq.n	800220a <__iar_annotation$$branch+0x3d8>
 8002208:	e2ec      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800220a:	2003      	movs	r0, #3
 800220c:	82e8      	strh	r0, [r5, #22]
 800220e:	8337      	strh	r7, [r6, #24]
 8002210:	241a      	movs	r4, #26
 8002212:	4f25      	ldr	r7, [pc, #148]	; (80022a8 <__iar_annotation$$branch+0x38>)
 8002214:	7838      	ldrb	r0, [r7, #0]
 8002216:	0780      	lsls	r0, r0, #30
 8002218:	d509      	bpl.n	800222e <__iar_annotation$$branch+0x3fc>
 800221a:	2000      	movs	r0, #0
 800221c:	9000      	str	r0, [sp, #0]
 800221e:	2300      	movs	r3, #0
 8002220:	222e      	movs	r2, #46	; 0x2e
 8002222:	7b28      	ldrb	r0, [r5, #12]
 8002224:	07c1      	lsls	r1, r0, #31
 8002226:	0fc9      	lsrs	r1, r1, #31
 8002228:	2009      	movs	r0, #9
 800222a:	68ff      	ldr	r7, [r7, #12]
 800222c:	47b8      	blx	r7
 800222e:	212e      	movs	r1, #46	; 0x2e
 8002230:	e310      	b.n	8002854 <__iar_annotation$$branch+0x304>
 8002232:	2911      	cmp	r1, #17
 8002234:	d115      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 8002236:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002238:	0bc0      	lsrs	r0, r0, #15
 800223a:	d112      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 800223c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800223e:	0b00      	lsrs	r0, r0, #12
 8002240:	0740      	lsls	r0, r0, #29
 8002242:	d10e      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 8002244:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002246:	06c0      	lsls	r0, r0, #27
 8002248:	0ec0      	lsrs	r0, r0, #27
 800224a:	2803      	cmp	r0, #3
 800224c:	d109      	bne.n	8002262 <__iar_annotation$$branch+0x430>
 800224e:	2000      	movs	r0, #0
 8002250:	8330      	strh	r0, [r6, #24]
 8002252:	0028      	movs	r0, r5
 8002254:	f001 fb73 	bl	800393e <PE_PerformSoftReset>
 8002258:	2003      	movs	r0, #3
 800225a:	7130      	strb	r0, [r6, #4]
 800225c:	2014      	movs	r0, #20
 800225e:	4669      	mov	r1, sp
 8002260:	7308      	strb	r0, [r1, #12]
 8002262:	8b30      	ldrh	r0, [r6, #24]
 8002264:	03a1      	lsls	r1, r4, #14
 8002266:	4288      	cmp	r0, r1
 8002268:	d000      	beq.n	800226c <__iar_annotation$$branch+0x43a>
 800226a:	e2bb      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800226c:	2000      	movs	r0, #0
 800226e:	8330      	strh	r0, [r6, #24]

08002270 <__iar_annotation$$branch>:
 8002270:	f000 fcd3 	bl	8002c1a <__iar_annotation$$branch+0x6ca>
 8002274:	6868      	ldr	r0, [r5, #4]
 8002276:	7840      	ldrb	r0, [r0, #1]
 8002278:	0640      	lsls	r0, r0, #25
 800227a:	0f40      	lsrs	r0, r0, #29
 800227c:	2803      	cmp	r0, #3
 800227e:	d121      	bne.n	80022c4 <__iar_annotation$$branch+0x54>
 8002280:	2103      	movs	r1, #3
 8002282:	0028      	movs	r0, r5
 8002284:	f001 fa5a 	bl	800373c <PE_Send_SNKCapabilities>
 8002288:	4f07      	ldr	r7, [pc, #28]	; (80022a8 <__iar_annotation$$branch+0x38>)
 800228a:	7838      	ldrb	r0, [r7, #0]
 800228c:	0780      	lsls	r0, r0, #30
 800228e:	d509      	bpl.n	80022a4 <__iar_annotation$$branch+0x34>
 8002290:	2000      	movs	r0, #0
 8002292:	9000      	str	r0, [sp, #0]
 8002294:	2300      	movs	r3, #0
 8002296:	220a      	movs	r2, #10
 8002298:	7b28      	ldrb	r0, [r5, #12]
 800229a:	07c1      	lsls	r1, r0, #31
 800229c:	0fc9      	lsrs	r1, r1, #31
 800229e:	2009      	movs	r0, #9
 80022a0:	68ff      	ldr	r7, [r7, #12]
 80022a2:	47b8      	blx	r7
 80022a4:	210a      	movs	r1, #10
 80022a6:	e2d5      	b.n	8002854 <__iar_annotation$$branch+0x304>
 80022a8:	200019a8 	.word	0x200019a8
 80022ac:	0000a328 	.word	0x0000a328
 80022b0:	00002328 	.word	0x00002328
 80022b4:	0000828a 	.word	0x0000828a
 80022b8:	fffff7ff 	.word	0xfffff7ff
 80022bc:	000084fb 	.word	0x000084fb
 80022c0:	000081f4 	.word	0x000081f4
 80022c4:	2000      	movs	r0, #0
 80022c6:	9000      	str	r0, [sp, #0]
 80022c8:	2303      	movs	r3, #3
 80022ca:	2204      	movs	r2, #4
 80022cc:	2100      	movs	r1, #0
 80022ce:	0028      	movs	r0, r5
 80022d0:	f001 fa4f 	bl	8003772 <PE_Send_CtrlMessage>
 80022d4:	e286      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80022d6:	9400      	str	r4, [sp, #0]
 80022d8:	2343      	movs	r3, #67	; 0x43
 80022da:	2207      	movs	r2, #7
 80022dc:	2100      	movs	r1, #0
 80022de:	0028      	movs	r0, r5
 80022e0:	f001 fa47 	bl	8003772 <PE_Send_CtrlMessage>
 80022e4:	2800      	cmp	r0, #0
 80022e6:	d000      	beq.n	80022ea <__iar_annotation$$branch+0x7a>
 80022e8:	e27c      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80022ea:	2006      	movs	r0, #6
 80022ec:	82e8      	strh	r0, [r5, #22]
 80022ee:	8337      	strh	r7, [r6, #24]
 80022f0:	241a      	movs	r4, #26
 80022f2:	4fbf      	ldr	r7, [pc, #764]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 80022f4:	7838      	ldrb	r0, [r7, #0]
 80022f6:	0780      	lsls	r0, r0, #30
 80022f8:	d509      	bpl.n	800230e <__iar_annotation$$branch+0x9e>
 80022fa:	2000      	movs	r0, #0
 80022fc:	9000      	str	r0, [sp, #0]
 80022fe:	2300      	movs	r3, #0
 8002300:	220b      	movs	r2, #11
 8002302:	7b28      	ldrb	r0, [r5, #12]
 8002304:	07c1      	lsls	r1, r0, #31
 8002306:	0fc9      	lsrs	r1, r1, #31
 8002308:	2009      	movs	r0, #9
 800230a:	68ff      	ldr	r7, [r7, #12]
 800230c:	47b8      	blx	r7
 800230e:	210b      	movs	r1, #11
 8002310:	e2a0      	b.n	8002854 <__iar_annotation$$branch+0x304>
 8002312:	2914      	cmp	r1, #20
 8002314:	d00e      	beq.n	8002334 <__iar_annotation$$branch+0xc4>
 8002316:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002318:	0bc0      	lsrs	r0, r0, #15
 800231a:	d10b      	bne.n	8002334 <__iar_annotation$$branch+0xc4>
 800231c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800231e:	0b00      	lsrs	r0, r0, #12
 8002320:	0740      	lsls	r0, r0, #29
 8002322:	d007      	beq.n	8002334 <__iar_annotation$$branch+0xc4>
 8002324:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002326:	06c0      	lsls	r0, r0, #27
 8002328:	0ec0      	lsrs	r0, r0, #27
 800232a:	2803      	cmp	r0, #3
 800232c:	d102      	bne.n	8002334 <__iar_annotation$$branch+0xc4>
 800232e:	2014      	movs	r0, #20
 8002330:	4669      	mov	r1, sp
 8002332:	7308      	strb	r0, [r1, #12]
 8002334:	2011      	movs	r0, #17

08002336 <__iar_annotation$$branch>:
 8002336:	f000 fd1d 	bl	8002d74 <__iar_annotation$$branch+0x824>
 800233a:	2011      	movs	r0, #17
 800233c:	82e8      	strh	r0, [r5, #22]
 800233e:	2105      	movs	r1, #5
 8002340:	7b2a      	ldrb	r2, [r5, #12]
 8002342:	07d0      	lsls	r0, r2, #31
 8002344:	0fc0      	lsrs	r0, r0, #31
 8002346:	f003 f874 	bl	8005432 <USBDPD_PRL_BistCarrierEyeMode>
 800234a:	205d      	movs	r0, #93	; 0x5d
 800234c:	7130      	strb	r0, [r6, #4]
 800234e:	48a9      	ldr	r0, [pc, #676]	; (80025f4 <__iar_annotation$$branch+0xa4>)
 8002350:	8530      	strh	r0, [r6, #40]	; 0x28
 8002352:	243a      	movs	r4, #58	; 0x3a
 8002354:	e246      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002356:	8d30      	ldrh	r0, [r6, #40]	; 0x28
 8002358:	03a1      	lsls	r1, r4, #14
 800235a:	4288      	cmp	r0, r1
 800235c:	d000      	beq.n	8002360 <__iar_annotation$$branch+0x2a>
 800235e:	e241      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002360:	2105      	movs	r1, #5
 8002362:	7b2a      	ldrb	r2, [r5, #12]
 8002364:	07d0      	lsls	r0, r2, #31
 8002366:	0fc0      	lsrs	r0, r0, #31
 8002368:	f003 f86b 	bl	8005442 <USBDPD_PRL_BistCarrierEyeModeExit>
 800236c:	2000      	movs	r0, #0
 800236e:	8530      	strh	r0, [r6, #40]	; 0x28

08002370 <__iar_annotation$$branch>:
 8002370:	f000 fda5 	bl	8002ebe <__iar_annotation$$branch+0x96e>
 8002374:	2911      	cmp	r1, #17
 8002376:	d000      	beq.n	800237a <__iar_annotation$$branch+0xa>
 8002378:	e234      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800237a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800237c:	0bc9      	lsrs	r1, r1, #15
 800237e:	d000      	beq.n	8002382 <__iar_annotation$$branch+0x12>
 8002380:	e230      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002382:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002384:	0b09      	lsrs	r1, r1, #12
 8002386:	0749      	lsls	r1, r1, #29
 8002388:	d000      	beq.n	800238c <__iar_annotation$$branch+0x1c>
 800238a:	e22b      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800238c:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800238e:	06c9      	lsls	r1, r1, #27
 8002390:	0ec9      	lsrs	r1, r1, #27
 8002392:	2906      	cmp	r1, #6
 8002394:	d000      	beq.n	8002398 <__iar_annotation$$branch+0x28>
 8002396:	e225      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002398:	2800      	cmp	r0, #0
 800239a:	d009      	beq.n	80023b0 <__iar_annotation$$branch+0x40>
 800239c:	2000      	movs	r0, #0
 800239e:	9000      	str	r0, [sp, #0]
 80023a0:	2300      	movs	r3, #0
 80023a2:	222a      	movs	r2, #42	; 0x2a
 80023a4:	7b28      	ldrb	r0, [r5, #12]
 80023a6:	07c1      	lsls	r1, r0, #31
 80023a8:	0fc9      	lsrs	r1, r1, #31
 80023aa:	2009      	movs	r0, #9
 80023ac:	9f01      	ldr	r7, [sp, #4]
 80023ae:	47b8      	blx	r7
 80023b0:	212a      	movs	r1, #42	; 0x2a
 80023b2:	7b2a      	ldrb	r2, [r5, #12]
 80023b4:	07d0      	lsls	r0, r2, #31
 80023b6:	0fc0      	lsrs	r0, r0, #31
 80023b8:	68aa      	ldr	r2, [r5, #8]
 80023ba:	68d2      	ldr	r2, [r2, #12]
 80023bc:	4790      	blx	r2

080023be <__iar_annotation$$branch>:
 80023be:	f000 fceb 	bl	8002d98 <__iar_annotation$$branch+0x848>
 80023c2:	9400      	str	r4, [sp, #0]
 80023c4:	2360      	movs	r3, #96	; 0x60
 80023c6:	2208      	movs	r2, #8
 80023c8:	2100      	movs	r1, #0
 80023ca:	0028      	movs	r0, r5
 80023cc:	f001 f9d1 	bl	8003772 <PE_Send_CtrlMessage>
 80023d0:	2800      	cmp	r0, #0
 80023d2:	d000      	beq.n	80023d6 <__iar_annotation$$branch+0x18>
 80023d4:	e206      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80023d6:	2007      	movs	r0, #7
 80023d8:	82e8      	strh	r0, [r5, #22]
 80023da:	8337      	strh	r7, [r6, #24]
 80023dc:	241a      	movs	r4, #26
 80023de:	4f84      	ldr	r7, [pc, #528]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 80023e0:	7838      	ldrb	r0, [r7, #0]
 80023e2:	0780      	lsls	r0, r0, #30
 80023e4:	d509      	bpl.n	80023fa <__iar_annotation$$branch+0x3c>
 80023e6:	2000      	movs	r0, #0
 80023e8:	9000      	str	r0, [sp, #0]
 80023ea:	2300      	movs	r3, #0
 80023ec:	2205      	movs	r2, #5
 80023ee:	7b28      	ldrb	r0, [r5, #12]
 80023f0:	07c1      	lsls	r1, r0, #31
 80023f2:	0fc9      	lsrs	r1, r1, #31
 80023f4:	2009      	movs	r0, #9
 80023f6:	68ff      	ldr	r7, [r7, #12]
 80023f8:	47b8      	blx	r7
 80023fa:	2105      	movs	r1, #5
 80023fc:	e22a      	b.n	8002854 <__iar_annotation$$branch+0x304>
 80023fe:	2911      	cmp	r1, #17
 8002400:	d15e      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 8002402:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002404:	0bc0      	lsrs	r0, r0, #15
 8002406:	d133      	bne.n	8002470 <__iar_annotation$$branch+0xb2>
 8002408:	2007      	movs	r0, #7
 800240a:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800240c:	0b09      	lsrs	r1, r1, #12
 800240e:	4201      	tst	r1, r0
 8002410:	d02e      	beq.n	8002470 <__iar_annotation$$branch+0xb2>
 8002412:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002414:	06c9      	lsls	r1, r1, #27
 8002416:	0ec9      	lsrs	r1, r1, #27
 8002418:	2904      	cmp	r1, #4
 800241a:	d129      	bne.n	8002470 <__iar_annotation$$branch+0xb2>
 800241c:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 800241e:	0b09      	lsrs	r1, r1, #12
 8002420:	4008      	ands	r0, r1
 8002422:	0083      	lsls	r3, r0, #2
 8002424:	209e      	movs	r0, #158	; 0x9e
 8002426:	0040      	lsls	r0, r0, #1
 8002428:	182a      	adds	r2, r5, r0
 800242a:	2105      	movs	r1, #5
 800242c:	7b2f      	ldrb	r7, [r5, #12]
 800242e:	07f8      	lsls	r0, r7, #31
 8002430:	0fc0      	lsrs	r0, r0, #31
 8002432:	68af      	ldr	r7, [r5, #8]
 8002434:	69ff      	ldr	r7, [r7, #28]
 8002436:	47b8      	blx	r7
 8002438:	2000      	movs	r0, #0
 800243a:	8330      	strh	r0, [r6, #24]
 800243c:	2014      	movs	r0, #20
 800243e:	4669      	mov	r1, sp
 8002440:	7308      	strb	r0, [r1, #12]
 8002442:	2003      	movs	r0, #3
 8002444:	7130      	strb	r0, [r6, #4]
 8002446:	4f6a      	ldr	r7, [pc, #424]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 8002448:	7838      	ldrb	r0, [r7, #0]
 800244a:	0780      	lsls	r0, r0, #30
 800244c:	d509      	bpl.n	8002462 <__iar_annotation$$branch+0xa4>
 800244e:	2000      	movs	r0, #0
 8002450:	9000      	str	r0, [sp, #0]
 8002452:	2300      	movs	r3, #0
 8002454:	2207      	movs	r2, #7
 8002456:	7b28      	ldrb	r0, [r5, #12]
 8002458:	07c1      	lsls	r1, r0, #31
 800245a:	0fc9      	lsrs	r1, r1, #31
 800245c:	2009      	movs	r0, #9
 800245e:	68ff      	ldr	r7, [r7, #12]
 8002460:	47b8      	blx	r7
 8002462:	2107      	movs	r1, #7
 8002464:	7b2a      	ldrb	r2, [r5, #12]
 8002466:	07d0      	lsls	r0, r2, #31
 8002468:	0fc0      	lsrs	r0, r0, #31
 800246a:	68aa      	ldr	r2, [r5, #8]
 800246c:	68d2      	ldr	r2, [r2, #12]
 800246e:	4790      	blx	r2
 8002470:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002472:	0bc0      	lsrs	r0, r0, #15
 8002474:	d124      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 8002476:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002478:	0b00      	lsrs	r0, r0, #12
 800247a:	0740      	lsls	r0, r0, #29
 800247c:	d120      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 800247e:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002480:	06c0      	lsls	r0, r0, #27
 8002482:	0ec0      	lsrs	r0, r0, #27
 8002484:	2804      	cmp	r0, #4
 8002486:	d11b      	bne.n	80024c0 <__iar_annotation$$branch+0x102>
 8002488:	2000      	movs	r0, #0
 800248a:	8330      	strh	r0, [r6, #24]
 800248c:	2014      	movs	r0, #20
 800248e:	4669      	mov	r1, sp
 8002490:	7308      	strb	r0, [r1, #12]
 8002492:	2003      	movs	r0, #3
 8002494:	7130      	strb	r0, [r6, #4]
 8002496:	4f56      	ldr	r7, [pc, #344]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 8002498:	7838      	ldrb	r0, [r7, #0]
 800249a:	0780      	lsls	r0, r0, #30
 800249c:	d509      	bpl.n	80024b2 <__iar_annotation$$branch+0xf4>
 800249e:	2000      	movs	r0, #0
 80024a0:	9000      	str	r0, [sp, #0]
 80024a2:	2300      	movs	r3, #0
 80024a4:	2208      	movs	r2, #8
 80024a6:	7b28      	ldrb	r0, [r5, #12]
 80024a8:	07c1      	lsls	r1, r0, #31
 80024aa:	0fc9      	lsrs	r1, r1, #31
 80024ac:	2009      	movs	r0, #9
 80024ae:	68ff      	ldr	r7, [r7, #12]
 80024b0:	47b8      	blx	r7
 80024b2:	2108      	movs	r1, #8
 80024b4:	7b2a      	ldrb	r2, [r5, #12]
 80024b6:	07d0      	lsls	r0, r2, #31
 80024b8:	0fc0      	lsrs	r0, r0, #31
 80024ba:	68aa      	ldr	r2, [r5, #8]
 80024bc:	68d2      	ldr	r2, [r2, #12]
 80024be:	4790      	blx	r2
 80024c0:	8b30      	ldrh	r0, [r6, #24]
 80024c2:	03a1      	lsls	r1, r4, #14
 80024c4:	4288      	cmp	r0, r1
 80024c6:	d000      	beq.n	80024ca <__iar_annotation$$branch>
 80024c8:	e18c      	b.n	80027e4 <__iar_annotation$$branch+0x294>

080024ca <__iar_annotation$$branch>:
 80024ca:	f000 fcf6 	bl	8002eba <__iar_annotation$$branch+0x96a>
 80024ce:	2000      	movs	r0, #0
 80024d0:	9000      	str	r0, [sp, #0]
 80024d2:	2303      	movs	r3, #3
 80024d4:	2204      	movs	r2, #4
 80024d6:	2100      	movs	r1, #0
 80024d8:	0028      	movs	r0, r5
 80024da:	f001 f94a 	bl	8003772 <PE_Send_CtrlMessage>
 80024de:	4844      	ldr	r0, [pc, #272]	; (80025f0 <__iar_annotation$$branch+0xa0>)
 80024e0:	7800      	ldrb	r0, [r0, #0]
 80024e2:	0780      	lsls	r0, r0, #30
 80024e4:	d500      	bpl.n	80024e8 <__iar_annotation$$branch+0x1e>
 80024e6:	e1d5      	b.n	8002894 <__iar_annotation$$branch+0x344>
 80024e8:	e1df      	b.n	80028aa <__iar_annotation$$branch+0x35a>
 80024ea:	4943      	ldr	r1, [pc, #268]	; (80025f8 <__iar_annotation$$branch+0xa8>)
 80024ec:	84b1      	strh	r1, [r6, #36]	; 0x24
 80024ee:	2464      	movs	r4, #100	; 0x64
 80024f0:	2100      	movs	r1, #0
 80024f2:	82e9      	strh	r1, [r5, #22]
 80024f4:	2104      	movs	r1, #4
 80024f6:	7131      	strb	r1, [r6, #4]
 80024f8:	2800      	cmp	r0, #0
 80024fa:	d009      	beq.n	8002510 <__iar_annotation$$branch+0x46>
 80024fc:	2000      	movs	r0, #0
 80024fe:	9000      	str	r0, [sp, #0]
 8002500:	2300      	movs	r3, #0
 8002502:	221f      	movs	r2, #31
 8002504:	7b28      	ldrb	r0, [r5, #12]
 8002506:	07c1      	lsls	r1, r0, #31
 8002508:	0fc9      	lsrs	r1, r1, #31
 800250a:	2009      	movs	r0, #9
 800250c:	9f01      	ldr	r7, [sp, #4]
 800250e:	47b8      	blx	r7
 8002510:	211f      	movs	r1, #31
 8002512:	7b2a      	ldrb	r2, [r5, #12]
 8002514:	07d0      	lsls	r0, r2, #31
 8002516:	0fc0      	lsrs	r0, r0, #31
 8002518:	68aa      	ldr	r2, [r5, #8]
 800251a:	68d2      	ldr	r2, [r2, #12]
 800251c:	4790      	blx	r2
 800251e:	4668      	mov	r0, sp
 8002520:	7b00      	ldrb	r0, [r0, #12]
 8002522:	2814      	cmp	r0, #20
 8002524:	d016      	beq.n	8002554 <__iar_annotation$$branch+0x4>
 8002526:	79b0      	ldrb	r0, [r6, #6]
 8002528:	71f0      	strb	r0, [r6, #7]
 800252a:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800252c:	0bc0      	lsrs	r0, r0, #15
 800252e:	d001      	beq.n	8002534 <__iar_annotation$$branch+0x4>

08002530 <__iar_annotation$$branch>:
 8002530:	f000 fcad 	bl	8002e8e <__iar_annotation$$branch+0x93e>
 8002534:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002536:	0bc0      	lsrs	r0, r0, #15
 8002538:	d107      	bne.n	800254a <__iar_annotation$$branch+0x1a>
 800253a:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 800253c:	0b00      	lsrs	r0, r0, #12
 800253e:	0740      	lsls	r0, r0, #29
 8002540:	d103      	bne.n	800254a <__iar_annotation$$branch+0x1a>
 8002542:	0028      	movs	r0, r5
 8002544:	f001 fa9e 	bl	8003a84 <PE_Check_ControlMessage>
 8002548:	e002      	b.n	8002550 <__iar_annotation$$branch>
 800254a:	0028      	movs	r0, r5
 800254c:	f001 fc36 	bl	8003dbc <PE_Check_DataMessage>

08002550 <__iar_annotation$$branch>:
 8002550:	f000 fca0 	bl	8002e94 <__iar_annotation$$branch+0x944>
 8002554:	68e8      	ldr	r0, [r5, #12]
 8002556:	0b00      	lsrs	r0, r0, #12
 8002558:	2180      	movs	r1, #128	; 0x80
 800255a:	0209      	lsls	r1, r1, #8
 800255c:	240f      	movs	r4, #15
 800255e:	2800      	cmp	r0, #0
 8002560:	d01e      	beq.n	80025a0 <__iar_annotation$$branch+0x50>
 8002562:	8a32      	ldrh	r2, [r6, #16]
 8002564:	428a      	cmp	r2, r1
 8002566:	d104      	bne.n	8002572 <__iar_annotation$$branch+0x22>
 8002568:	7134      	strb	r4, [r6, #4]
 800256a:	7d28      	ldrb	r0, [r5, #20]
 800256c:	1c40      	adds	r0, r0, #1
 800256e:	7528      	strb	r0, [r5, #20]
 8002570:	e12e      	b.n	80027d0 <__iar_annotation$$branch+0x280>
 8002572:	6b72      	ldr	r2, [r6, #52]	; 0x34
 8002574:	0512      	lsls	r2, r2, #20
 8002576:	0d12      	lsrs	r2, r2, #20
 8002578:	2307      	movs	r3, #7
 800257a:	8e34      	ldrh	r4, [r6, #48]	; 0x30
 800257c:	0a67      	lsrs	r7, r4, #9
 800257e:	2407      	movs	r4, #7
 8002580:	403c      	ands	r4, r7
 8002582:	1824      	adds	r4, r4, r0
 8002584:	2733      	movs	r7, #51	; 0x33
 8002586:	437c      	muls	r4, r7
 8002588:	18a4      	adds	r4, r4, r2
 800258a:	4321      	orrs	r1, r4
 800258c:	9c04      	ldr	r4, [sp, #16]
 800258e:	8021      	strh	r1, [r4, #0]
 8002590:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002592:	0a49      	lsrs	r1, r1, #9
 8002594:	400b      	ands	r3, r1
 8002596:	1818      	adds	r0, r3, r0
 8002598:	2133      	movs	r1, #51	; 0x33
 800259a:	4348      	muls	r0, r1
 800259c:	1884      	adds	r4, r0, r2
 800259e:	e121      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80025a0:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 80025a2:	4288      	cmp	r0, r1
 80025a4:	d103      	bne.n	80025ae <__iar_annotation$$branch+0x5e>
 80025a6:	2400      	movs	r4, #0
 80025a8:	85b4      	strh	r4, [r6, #44]	; 0x2c
 80025aa:	2044      	movs	r0, #68	; 0x44
 80025ac:	e1b0      	b.n	8002910 <__iar_annotation$$branch+0x3c0>
 80025ae:	7830      	ldrb	r0, [r6, #0]
 80025b0:	2800      	cmp	r0, #0
 80025b2:	d014      	beq.n	80025de <__iar_annotation$$branch+0x8e>
 80025b4:	6868      	ldr	r0, [r5, #4]
 80025b6:	7800      	ldrb	r0, [r0, #0]
 80025b8:	0781      	lsls	r1, r0, #30
 80025ba:	0f89      	lsrs	r1, r1, #30
 80025bc:	2901      	cmp	r1, #1
 80025be:	d007      	beq.n	80025d0 <__iar_annotation$$branch+0x80>
 80025c0:	2902      	cmp	r1, #2
 80025c2:	d10c      	bne.n	80025de <__iar_annotation$$branch+0x8e>
 80025c4:	4668      	mov	r0, sp
 80025c6:	7b40      	ldrb	r0, [r0, #13]
 80025c8:	f002 fcdf 	bl	8004f8a <USBPD_PRL_IsResistor_SinkTxOK>
 80025cc:	2801      	cmp	r0, #1
 80025ce:	d106      	bne.n	80025de <__iar_annotation$$branch+0x8e>
 80025d0:	7870      	ldrb	r0, [r6, #1]
 80025d2:	71f0      	strb	r0, [r6, #7]
 80025d4:	7830      	ldrb	r0, [r6, #0]
 80025d6:	7130      	strb	r0, [r6, #4]
 80025d8:	2400      	movs	r4, #0
 80025da:	7034      	strb	r4, [r6, #0]
 80025dc:	e102      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80025de:	48b4      	ldr	r0, [pc, #720]	; (80028b0 <__iar_annotation$$branch+0x360>)
 80025e0:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 80025e2:	4001      	ands	r1, r0
 80025e4:	2900      	cmp	r1, #0
 80025e6:	dd09      	ble.n	80025fc <__iar_annotation$$branch+0xac>
 80025e8:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 80025ea:	0004      	movs	r4, r0
 80025ec:	400c      	ands	r4, r1
 80025ee:	e0f9      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80025f0:	200019a8 	.word	0x200019a8
 80025f4:	0000803a 	.word	0x0000803a
 80025f8:	00008064 	.word	0x00008064
 80025fc:	7830      	ldrb	r0, [r6, #0]
 80025fe:	2800      	cmp	r0, #0
 8002600:	d000      	beq.n	8002604 <__iar_annotation$$branch+0xb4>
 8002602:	e0ef      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002604:	2400      	movs	r4, #0
 8002606:	43e4      	mvns	r4, r4
 8002608:	e0ec      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800260a:	4668      	mov	r0, sp
 800260c:	7b40      	ldrb	r0, [r0, #13]
 800260e:	68a9      	ldr	r1, [r5, #8]
 8002610:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
 8002612:	4788      	blx	r1
 8002614:	280a      	cmp	r0, #10
 8002616:	d145      	bne.n	80026a4 <__iar_annotation$$branch+0x154>
 8002618:	2000      	movs	r0, #0
 800261a:	9000      	str	r0, [sp, #0]
 800261c:	2303      	movs	r3, #3
 800261e:	2203      	movs	r2, #3
 8002620:	2100      	movs	r1, #0
 8002622:	0028      	movs	r0, r5
 8002624:	f001 f8a5 	bl	8003772 <PE_Send_CtrlMessage>
 8002628:	2800      	cmp	r0, #0
 800262a:	d000      	beq.n	800262e <__iar_annotation$$branch+0xde>
 800262c:	e0da      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 800262e:	6868      	ldr	r0, [r5, #4]
 8002630:	7801      	ldrb	r1, [r0, #0]
 8002632:	08ca      	lsrs	r2, r1, #3
 8002634:	07d2      	lsls	r2, r2, #31
 8002636:	d412      	bmi.n	800265e <__iar_annotation$$branch+0x10e>
 8002638:	2208      	movs	r2, #8
 800263a:	430a      	orrs	r2, r1
 800263c:	7002      	strb	r2, [r0, #0]
 800263e:	4f9d      	ldr	r7, [pc, #628]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002640:	7838      	ldrb	r0, [r7, #0]
 8002642:	0780      	lsls	r0, r0, #30
 8002644:	d509      	bpl.n	800265a <__iar_annotation$$branch+0x10a>
 8002646:	2000      	movs	r0, #0
 8002648:	9000      	str	r0, [sp, #0]
 800264a:	2300      	movs	r3, #0
 800264c:	2224      	movs	r2, #36	; 0x24
 800264e:	7b28      	ldrb	r0, [r5, #12]
 8002650:	07c1      	lsls	r1, r0, #31
 8002652:	0fc9      	lsrs	r1, r1, #31
 8002654:	2009      	movs	r0, #9
 8002656:	68ff      	ldr	r7, [r7, #12]
 8002658:	47b8      	blx	r7
 800265a:	2124      	movs	r1, #36	; 0x24
 800265c:	e011      	b.n	8002682 <__iar_annotation$$branch+0x132>
 800265e:	22f7      	movs	r2, #247	; 0xf7
 8002660:	400a      	ands	r2, r1
 8002662:	7002      	strb	r2, [r0, #0]
 8002664:	4f93      	ldr	r7, [pc, #588]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002666:	7838      	ldrb	r0, [r7, #0]
 8002668:	0780      	lsls	r0, r0, #30
 800266a:	d509      	bpl.n	8002680 <__iar_annotation$$branch+0x130>
 800266c:	2000      	movs	r0, #0
 800266e:	9000      	str	r0, [sp, #0]
 8002670:	2300      	movs	r3, #0
 8002672:	2223      	movs	r2, #35	; 0x23
 8002674:	7b28      	ldrb	r0, [r5, #12]
 8002676:	07c1      	lsls	r1, r0, #31
 8002678:	0fc9      	lsrs	r1, r1, #31
 800267a:	2009      	movs	r0, #9
 800267c:	68ff      	ldr	r7, [r7, #12]
 800267e:	47b8      	blx	r7
 8002680:	2123      	movs	r1, #35	; 0x23
 8002682:	7b2a      	ldrb	r2, [r5, #12]
 8002684:	07d0      	lsls	r0, r2, #31
 8002686:	0fc0      	lsrs	r0, r0, #31
 8002688:	68aa      	ldr	r2, [r5, #8]
 800268a:	68d2      	ldr	r2, [r2, #12]
 800268c:	4790      	blx	r2
 800268e:	2001      	movs	r0, #1
 8002690:	6869      	ldr	r1, [r5, #4]
 8002692:	7809      	ldrb	r1, [r1, #0]
 8002694:	08ca      	lsrs	r2, r1, #3
 8002696:	2101      	movs	r1, #1
 8002698:	4011      	ands	r1, r2
 800269a:	68ea      	ldr	r2, [r5, #12]
 800269c:	4010      	ands	r0, r2
 800269e:	f002 fc4b 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 80026a2:	e09f      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026a4:	6868      	ldr	r0, [r5, #4]
 80026a6:	7800      	ldrb	r0, [r0, #0]
 80026a8:	0780      	lsls	r0, r0, #30
 80026aa:	0f80      	lsrs	r0, r0, #30
 80026ac:	2802      	cmp	r0, #2
 80026ae:	d101      	bne.n	80026b4 <__iar_annotation$$branch+0x164>
 80026b0:	2001      	movs	r0, #1
 80026b2:	e12d      	b.n	8002910 <__iar_annotation$$branch+0x3c0>
 80026b4:	202a      	movs	r0, #42	; 0x2a
 80026b6:	e12b      	b.n	8002910 <__iar_annotation$$branch+0x3c0>
 80026b8:	9400      	str	r4, [sp, #0]
 80026ba:	2395      	movs	r3, #149	; 0x95
 80026bc:	2209      	movs	r2, #9
 80026be:	2100      	movs	r1, #0
 80026c0:	0028      	movs	r0, r5
 80026c2:	f001 f856 	bl	8003772 <PE_Send_CtrlMessage>
 80026c6:	2800      	cmp	r0, #0
 80026c8:	d000      	beq.n	80026cc <__iar_annotation$$branch+0x17c>
 80026ca:	e08b      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026cc:	200f      	movs	r0, #15
 80026ce:	82e8      	strh	r0, [r5, #22]
 80026d0:	e3a7      	b.n	8002e22 <__iar_annotation$$branch+0x8d2>
 80026d2:	8b32      	ldrh	r2, [r6, #24]
 80026d4:	03a3      	lsls	r3, r4, #14
 80026d6:	429a      	cmp	r2, r3
 80026d8:	d100      	bne.n	80026dc <__iar_annotation$$branch+0x18c>
 80026da:	e6f6      	b.n	80024ca <__iar_annotation$$branch>
 80026dc:	2914      	cmp	r1, #20
 80026de:	d100      	bne.n	80026e2 <__iar_annotation$$branch+0x192>
 80026e0:	e080      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026e2:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 80026e4:	0bc9      	lsrs	r1, r1, #15
 80026e6:	d000      	beq.n	80026ea <__iar_annotation$$branch+0x19a>
 80026e8:	e07c      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 80026ea:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 80026ec:	0b09      	lsrs	r1, r1, #12
 80026ee:	0749      	lsls	r1, r1, #29
 80026f0:	d178      	bne.n	80027e4 <__iar_annotation$$branch+0x294>
 80026f2:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 80026f4:	06c9      	lsls	r1, r1, #27
 80026f6:	0ec9      	lsrs	r1, r1, #27
 80026f8:	2903      	cmp	r1, #3
 80026fa:	d004      	beq.n	8002706 <__iar_annotation$$branch+0x1b6>
 80026fc:	2904      	cmp	r1, #4
 80026fe:	d04d      	beq.n	800279c <__iar_annotation$$branch+0x24c>
 8002700:	290c      	cmp	r1, #12
 8002702:	d037      	beq.n	8002774 <__iar_annotation$$branch+0x224>
 8002704:	e06e      	b.n	80027e4 <__iar_annotation$$branch+0x294>
 8002706:	6869      	ldr	r1, [r5, #4]
 8002708:	780a      	ldrb	r2, [r1, #0]
 800270a:	08d3      	lsrs	r3, r2, #3
 800270c:	07db      	lsls	r3, r3, #31
 800270e:	d410      	bmi.n	8002732 <__iar_annotation$$branch+0x1e2>
 8002710:	2308      	movs	r3, #8
 8002712:	4313      	orrs	r3, r2
 8002714:	700b      	strb	r3, [r1, #0]
 8002716:	2800      	cmp	r0, #0
 8002718:	d009      	beq.n	800272e <__iar_annotation$$branch+0x1de>
 800271a:	2000      	movs	r0, #0
 800271c:	9000      	str	r0, [sp, #0]
 800271e:	2300      	movs	r3, #0
 8002720:	2224      	movs	r2, #36	; 0x24
 8002722:	7b28      	ldrb	r0, [r5, #12]
 8002724:	07c1      	lsls	r1, r0, #31
 8002726:	0fc9      	lsrs	r1, r1, #31
 8002728:	2009      	movs	r0, #9
 800272a:	9f01      	ldr	r7, [sp, #4]
 800272c:	47b8      	blx	r7
 800272e:	2124      	movs	r1, #36	; 0x24
 8002730:	e00f      	b.n	8002752 <__iar_annotation$$branch+0x202>
 8002732:	23f7      	movs	r3, #247	; 0xf7
 8002734:	4013      	ands	r3, r2
 8002736:	700b      	strb	r3, [r1, #0]
 8002738:	2800      	cmp	r0, #0
 800273a:	d009      	beq.n	8002750 <__iar_annotation$$branch+0x200>
 800273c:	2000      	movs	r0, #0
 800273e:	9000      	str	r0, [sp, #0]
 8002740:	2300      	movs	r3, #0
 8002742:	2223      	movs	r2, #35	; 0x23
 8002744:	7b28      	ldrb	r0, [r5, #12]
 8002746:	07c1      	lsls	r1, r0, #31
 8002748:	0fc9      	lsrs	r1, r1, #31
 800274a:	2009      	movs	r0, #9
 800274c:	9f01      	ldr	r7, [sp, #4]
 800274e:	47b8      	blx	r7
 8002750:	2123      	movs	r1, #35	; 0x23
 8002752:	7b2a      	ldrb	r2, [r5, #12]
 8002754:	07d0      	lsls	r0, r2, #31
 8002756:	0fc0      	lsrs	r0, r0, #31
 8002758:	68aa      	ldr	r2, [r5, #8]
 800275a:	68d2      	ldr	r2, [r2, #12]
 800275c:	4790      	blx	r2
 800275e:	2001      	movs	r0, #1
 8002760:	6869      	ldr	r1, [r5, #4]
 8002762:	7809      	ldrb	r1, [r1, #0]
 8002764:	08ca      	lsrs	r2, r1, #3
 8002766:	2101      	movs	r1, #1
 8002768:	4011      	ands	r1, r2
 800276a:	68ea      	ldr	r2, [r5, #12]
 800276c:	4010      	ands	r0, r2
 800276e:	f002 fbe3 	bl	8004f38 <USBPD_PRL_SetHeaderDataRole>
 8002772:	e30f      	b.n	8002d94 <__iar_annotation$$branch+0x844>
 8002774:	2800      	cmp	r0, #0
 8002776:	d009      	beq.n	800278c <__iar_annotation$$branch+0x23c>
 8002778:	2000      	movs	r0, #0
 800277a:	9000      	str	r0, [sp, #0]
 800277c:	2300      	movs	r3, #0
 800277e:	2225      	movs	r2, #37	; 0x25
 8002780:	7b28      	ldrb	r0, [r5, #12]
 8002782:	07c1      	lsls	r1, r0, #31
 8002784:	0fc9      	lsrs	r1, r1, #31
 8002786:	2009      	movs	r0, #9
 8002788:	9f01      	ldr	r7, [sp, #4]
 800278a:	47b8      	blx	r7
 800278c:	2125      	movs	r1, #37	; 0x25
 800278e:	7b2a      	ldrb	r2, [r5, #12]
 8002790:	07d0      	lsls	r0, r2, #31
 8002792:	0fc0      	lsrs	r0, r0, #31
 8002794:	68aa      	ldr	r2, [r5, #8]
 8002796:	68d2      	ldr	r2, [r2, #12]
 8002798:	4790      	blx	r2
 800279a:	e2fb      	b.n	8002d94 <__iar_annotation$$branch+0x844>
 800279c:	2800      	cmp	r0, #0
 800279e:	d009      	beq.n	80027b4 <__iar_annotation$$branch+0x264>
 80027a0:	2000      	movs	r0, #0
 80027a2:	9000      	str	r0, [sp, #0]
 80027a4:	2300      	movs	r3, #0
 80027a6:	2226      	movs	r2, #38	; 0x26
 80027a8:	7b28      	ldrb	r0, [r5, #12]
 80027aa:	07c1      	lsls	r1, r0, #31
 80027ac:	0fc9      	lsrs	r1, r1, #31
 80027ae:	2009      	movs	r0, #9
 80027b0:	9f01      	ldr	r7, [sp, #4]
 80027b2:	47b8      	blx	r7
 80027b4:	2126      	movs	r1, #38	; 0x26
 80027b6:	7b2a      	ldrb	r2, [r5, #12]
 80027b8:	07d0      	lsls	r0, r2, #31
 80027ba:	0fc0      	lsrs	r0, r0, #31
 80027bc:	68aa      	ldr	r2, [r5, #8]
 80027be:	68d2      	ldr	r2, [r2, #12]
 80027c0:	4790      	blx	r2
 80027c2:	e2e7      	b.n	8002d94 <__iar_annotation$$branch+0x844>
 80027c4:	68a8      	ldr	r0, [r5, #8]
 80027c6:	6881      	ldr	r1, [r0, #8]
 80027c8:	2900      	cmp	r1, #0
 80027ca:	d102      	bne.n	80027d2 <__iar_annotation$$branch+0x282>
 80027cc:	202a      	movs	r0, #42	; 0x2a
 80027ce:	7130      	strb	r0, [r6, #4]
 80027d0:	e354      	b.n	8002e7c <__iar_annotation$$branch+0x92c>
 80027d2:	4668      	mov	r0, sp
 80027d4:	7b40      	ldrb	r0, [r0, #13]
 80027d6:	4788      	blx	r1
 80027d8:	280a      	cmp	r0, #10
 80027da:	d004      	beq.n	80027e6 <__iar_annotation$$branch+0x296>
 80027dc:	280c      	cmp	r0, #12
 80027de:	d052      	beq.n	8002886 <__iar_annotation$$branch+0x336>
 80027e0:	280d      	cmp	r0, #13
 80027e2:	d038      	beq.n	8002856 <__iar_annotation$$branch+0x306>
 80027e4:	e392      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 80027e6:	68a8      	ldr	r0, [r5, #8]
 80027e8:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80027ea:	2b00      	cmp	r3, #0
 80027ec:	d005      	beq.n	80027fa <__iar_annotation$$branch+0x2aa>
 80027ee:	2201      	movs	r2, #1
 80027f0:	2100      	movs	r1, #0
 80027f2:	7b2f      	ldrb	r7, [r5, #12]
 80027f4:	07f8      	lsls	r0, r7, #31
 80027f6:	0fc0      	lsrs	r0, r0, #31
 80027f8:	4798      	blx	r3
 80027fa:	2000      	movs	r0, #0
 80027fc:	9000      	str	r0, [sp, #0]
 80027fe:	2352      	movs	r3, #82	; 0x52
 8002800:	2203      	movs	r2, #3
 8002802:	2100      	movs	r1, #0
 8002804:	0028      	movs	r0, r5
 8002806:	f000 ffb4 	bl	8003772 <PE_Send_CtrlMessage>
 800280a:	2800      	cmp	r0, #0
 800280c:	d1ea      	bne.n	80027e4 <__iar_annotation$$branch+0x294>
 800280e:	2008      	movs	r0, #8
 8002810:	82e8      	strh	r0, [r5, #22]
 8002812:	6868      	ldr	r0, [r5, #4]
 8002814:	6801      	ldr	r1, [r0, #0]
 8002816:	2210      	movs	r2, #16
 8002818:	430a      	orrs	r2, r1
 800281a:	6002      	str	r2, [r0, #0]
 800281c:	68a8      	ldr	r0, [r5, #8]
 800281e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002820:	2b00      	cmp	r3, #0
 8002822:	d005      	beq.n	8002830 <__iar_annotation$$branch+0x2e0>
 8002824:	2206      	movs	r2, #6
 8002826:	2100      	movs	r1, #0
 8002828:	7b2c      	ldrb	r4, [r5, #12]
 800282a:	07e0      	lsls	r0, r4, #31
 800282c:	0fc0      	lsrs	r0, r0, #31
 800282e:	4798      	blx	r3
 8002830:	489d      	ldr	r0, [pc, #628]	; (8002aa8 <__iar_annotation$$branch+0x558>)
 8002832:	82b0      	strh	r0, [r6, #20]
 8002834:	4c9d      	ldr	r4, [pc, #628]	; (8002aac <__iar_annotation$$branch+0x55c>)
 8002836:	4f1f      	ldr	r7, [pc, #124]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002838:	7838      	ldrb	r0, [r7, #0]
 800283a:	0780      	lsls	r0, r0, #30
 800283c:	d509      	bpl.n	8002852 <__iar_annotation$$branch+0x302>
 800283e:	2000      	movs	r0, #0
 8002840:	9000      	str	r0, [sp, #0]
 8002842:	2300      	movs	r3, #0
 8002844:	2238      	movs	r2, #56	; 0x38
 8002846:	7b28      	ldrb	r0, [r5, #12]
 8002848:	07c1      	lsls	r1, r0, #31
 800284a:	0fc9      	lsrs	r1, r1, #31
 800284c:	2009      	movs	r0, #9
 800284e:	68ff      	ldr	r7, [r7, #12]
 8002850:	47b8      	blx	r7
 8002852:	2138      	movs	r1, #56	; 0x38
 8002854:	e2fe      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 8002856:	2000      	movs	r0, #0
 8002858:	9000      	str	r0, [sp, #0]
 800285a:	2303      	movs	r3, #3
 800285c:	220c      	movs	r2, #12
 800285e:	2100      	movs	r1, #0
 8002860:	0028      	movs	r0, r5
 8002862:	f000 ff86 	bl	8003772 <PE_Send_CtrlMessage>
 8002866:	4f13      	ldr	r7, [pc, #76]	; (80028b4 <__iar_annotation$$branch+0x364>)
 8002868:	7838      	ldrb	r0, [r7, #0]
 800286a:	0780      	lsls	r0, r0, #30
 800286c:	d509      	bpl.n	8002882 <__iar_annotation$$branch+0x332>
 800286e:	2000      	movs	r0, #0
 8002870:	9000      	str	r0, [sp, #0]
 8002872:	2300      	movs	r3, #0
 8002874:	2239      	movs	r2, #57	; 0x39
 8002876:	7b28      	ldrb	r0, [r5, #12]
 8002878:	07c1      	lsls	r1, r0, #31
 800287a:	0fc9      	lsrs	r1, r1, #31
 800287c:	2009      	movs	r0, #9
 800287e:	68ff      	ldr	r7, [r7, #12]
 8002880:	47b8      	blx	r7
 8002882:	2139      	movs	r1, #57	; 0x39
 8002884:	e2e6      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 8002886:	202a      	movs	r0, #42	; 0x2a
 8002888:	7130      	strb	r0, [r6, #4]
 800288a:	2400      	movs	r4, #0
 800288c:	4809      	ldr	r0, [pc, #36]	; (80028b4 <__iar_annotation$$branch+0x364>)
 800288e:	7800      	ldrb	r0, [r0, #0]
 8002890:	0780      	lsls	r0, r0, #30
 8002892:	d50a      	bpl.n	80028aa <__iar_annotation$$branch+0x35a>
 8002894:	2000      	movs	r0, #0
 8002896:	9000      	str	r0, [sp, #0]
 8002898:	2300      	movs	r3, #0
 800289a:	2216      	movs	r2, #22
 800289c:	7b28      	ldrb	r0, [r5, #12]
 800289e:	07c1      	lsls	r1, r0, #31
 80028a0:	0fc9      	lsrs	r1, r1, #31
 80028a2:	2009      	movs	r0, #9
 80028a4:	4f03      	ldr	r7, [pc, #12]	; (80028b4 <__iar_annotation$$branch+0x364>)
 80028a6:	68ff      	ldr	r7, [r7, #12]
 80028a8:	47b8      	blx	r7
 80028aa:	2116      	movs	r1, #22
 80028ac:	e2d2      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 80028ae:	bf00      	nop
 80028b0:	00007fff 	.word	0x00007fff
 80028b4:	200019a8 	.word	0x200019a8
 80028b8:	2911      	cmp	r1, #17
 80028ba:	d11c      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028bc:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 80028be:	0bc0      	lsrs	r0, r0, #15
 80028c0:	d119      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028c2:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 80028c4:	0b00      	lsrs	r0, r0, #12
 80028c6:	0740      	lsls	r0, r0, #29
 80028c8:	d115      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028ca:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 80028cc:	06c0      	lsls	r0, r0, #27
 80028ce:	0ec0      	lsrs	r0, r0, #27
 80028d0:	2806      	cmp	r0, #6
 80028d2:	d110      	bne.n	80028f6 <__iar_annotation$$branch+0x3a6>
 80028d4:	2000      	movs	r0, #0
 80028d6:	82f0      	strh	r0, [r6, #22]
 80028d8:	68a8      	ldr	r0, [r5, #8]
 80028da:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80028dc:	2b00      	cmp	r3, #0
 80028de:	d005      	beq.n	80028ec <__iar_annotation$$branch+0x39c>
 80028e0:	2209      	movs	r2, #9
 80028e2:	2100      	movs	r1, #0
 80028e4:	7b2f      	ldrb	r7, [r5, #12]
 80028e6:	07f8      	lsls	r0, r7, #31
 80028e8:	0fc0      	lsrs	r0, r0, #31
 80028ea:	4798      	blx	r3
 80028ec:	2053      	movs	r0, #83	; 0x53
 80028ee:	7130      	strb	r0, [r6, #4]
 80028f0:	2014      	movs	r0, #20
 80028f2:	4669      	mov	r1, sp
 80028f4:	7308      	strb	r0, [r1, #12]
 80028f6:	8ab0      	ldrh	r0, [r6, #20]
 80028f8:	03a1      	lsls	r1, r4, #14
 80028fa:	4288      	cmp	r0, r1
 80028fc:	d000      	beq.n	8002900 <__iar_annotation$$branch+0x3b0>
 80028fe:	e305      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002900:	2000      	movs	r0, #0
 8002902:	82b0      	strh	r0, [r6, #20]
 8002904:	68a8      	ldr	r0, [r5, #8]
 8002906:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8002908:	2800      	cmp	r0, #0
 800290a:	d100      	bne.n	800290e <__iar_annotation$$branch+0x3be>
 800290c:	e185      	b.n	8002c1a <__iar_annotation$$branch+0x6ca>
 800290e:	2092      	movs	r0, #146	; 0x92
 8002910:	e2fb      	b.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002912:	6869      	ldr	r1, [r5, #4]
 8002914:	784a      	ldrb	r2, [r1, #1]
 8002916:	238f      	movs	r3, #143	; 0x8f
 8002918:	4013      	ands	r3, r2
 800291a:	2240      	movs	r2, #64	; 0x40
 800291c:	431a      	orrs	r2, r3
 800291e:	704a      	strb	r2, [r1, #1]
 8002920:	2800      	cmp	r0, #0
 8002922:	d009      	beq.n	8002938 <__iar_annotation$$branch+0x3e8>
 8002924:	2000      	movs	r0, #0
 8002926:	9000      	str	r0, [sp, #0]
 8002928:	2300      	movs	r3, #0
 800292a:	2256      	movs	r2, #86	; 0x56
 800292c:	7b28      	ldrb	r0, [r5, #12]
 800292e:	07c1      	lsls	r1, r0, #31
 8002930:	0fc9      	lsrs	r1, r1, #31
 8002932:	2009      	movs	r0, #9
 8002934:	9f01      	ldr	r7, [sp, #4]
 8002936:	47b8      	blx	r7
 8002938:	2701      	movs	r7, #1
 800293a:	2156      	movs	r1, #86	; 0x56
 800293c:	68ea      	ldr	r2, [r5, #12]
 800293e:	2001      	movs	r0, #1
 8002940:	4010      	ands	r0, r2
 8002942:	68aa      	ldr	r2, [r5, #8]
 8002944:	68d2      	ldr	r2, [r2, #12]
 8002946:	4790      	blx	r2
 8002948:	68a8      	ldr	r0, [r5, #8]
 800294a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800294c:	2b00      	cmp	r3, #0
 800294e:	d005      	beq.n	800295c <__iar_annotation$$branch+0x40c>
 8002950:	220a      	movs	r2, #10
 8002952:	68e9      	ldr	r1, [r5, #12]
 8002954:	2001      	movs	r0, #1
 8002956:	4008      	ands	r0, r1
 8002958:	2100      	movs	r1, #0
 800295a:	4798      	blx	r3
 800295c:	68e9      	ldr	r1, [r5, #12]
 800295e:	2001      	movs	r0, #1
 8002960:	4008      	ands	r0, r1
 8002962:	f002 fb03 	bl	8004f6c <USBPD_PRL_SRCSetSinkNG>
 8002966:	68a8      	ldr	r0, [r5, #8]
 8002968:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800296a:	2b00      	cmp	r3, #0
 800296c:	d005      	beq.n	800297a <__iar_annotation$$branch+0x42a>
 800296e:	220b      	movs	r2, #11
 8002970:	68e9      	ldr	r1, [r5, #12]
 8002972:	2001      	movs	r0, #1
 8002974:	4008      	ands	r0, r1
 8002976:	2101      	movs	r1, #1
 8002978:	4798      	blx	r3
 800297a:	2101      	movs	r1, #1
 800297c:	4668      	mov	r0, sp
 800297e:	7b40      	ldrb	r0, [r0, #13]
 8002980:	f002 facf 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8002984:	2000      	movs	r0, #0
 8002986:	9000      	str	r0, [sp, #0]
 8002988:	2354      	movs	r3, #84	; 0x54
 800298a:	2206      	movs	r2, #6
 800298c:	2100      	movs	r1, #0
 800298e:	0028      	movs	r0, r5
 8002990:	f000 feef 	bl	8003772 <PE_Send_CtrlMessage>
 8002994:	2800      	cmp	r0, #0
 8002996:	d10c      	bne.n	80029b2 <__iar_annotation$$branch+0x462>
 8002998:	68a8      	ldr	r0, [r5, #8]
 800299a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800299c:	2b00      	cmp	r3, #0
 800299e:	d005      	beq.n	80029ac <__iar_annotation$$branch+0x45c>
 80029a0:	220c      	movs	r2, #12
 80029a2:	2100      	movs	r1, #0
 80029a4:	68ec      	ldr	r4, [r5, #12]
 80029a6:	2001      	movs	r0, #1
 80029a8:	4020      	ands	r0, r4
 80029aa:	4798      	blx	r3
 80029ac:	48b2      	ldr	r0, [pc, #712]	; (8002c78 <__iar_annotation$$branch+0x728>)
 80029ae:	8430      	strh	r0, [r6, #32]
 80029b0:	2414      	movs	r4, #20
 80029b2:	7930      	ldrb	r0, [r6, #4]
 80029b4:	2854      	cmp	r0, #84	; 0x54
 80029b6:	d05c      	beq.n	8002a72 <__iar_annotation$$branch+0x522>
 80029b8:	2100      	movs	r1, #0
 80029ba:	4668      	mov	r0, sp
 80029bc:	7b40      	ldrb	r0, [r0, #13]
 80029be:	f002 fab0 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 80029c2:	68a8      	ldr	r0, [r5, #8]
 80029c4:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80029c6:	2b00      	cmp	r3, #0
 80029c8:	d053      	beq.n	8002a72 <__iar_annotation$$branch+0x522>
 80029ca:	2206      	movs	r2, #6
 80029cc:	68e9      	ldr	r1, [r5, #12]
 80029ce:	2001      	movs	r0, #1
 80029d0:	4008      	ands	r0, r1
 80029d2:	2101      	movs	r1, #1
 80029d4:	4798      	blx	r3
 80029d6:	68a8      	ldr	r0, [r5, #8]
 80029d8:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80029da:	2b00      	cmp	r3, #0
 80029dc:	d049      	beq.n	8002a72 <__iar_annotation$$branch+0x522>
 80029de:	2207      	movs	r2, #7
 80029e0:	2100      	movs	r1, #0
 80029e2:	68e8      	ldr	r0, [r5, #12]
 80029e4:	4007      	ands	r7, r0
 80029e6:	0038      	movs	r0, r7
 80029e8:	e151      	b.n	8002c8e <__iar_annotation$$branch+0x73e>
 80029ea:	8c30      	ldrh	r0, [r6, #32]
 80029ec:	03a1      	lsls	r1, r4, #14
 80029ee:	4288      	cmp	r0, r1
 80029f0:	d13f      	bne.n	8002a72 <__iar_annotation$$branch+0x522>
 80029f2:	2000      	movs	r0, #0
 80029f4:	8430      	strh	r0, [r6, #32]
 80029f6:	2101      	movs	r1, #1
 80029f8:	0028      	movs	r0, r5
 80029fa:	f000 ffcf 	bl	800399c <PE_ChangePowerRole>
 80029fe:	68a8      	ldr	r0, [r5, #8]
 8002a00:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002a02:	2b00      	cmp	r3, #0
 8002a04:	d005      	beq.n	8002a12 <__iar_annotation$$branch+0x4c2>
 8002a06:	220e      	movs	r2, #14
 8002a08:	2101      	movs	r1, #1
 8002a0a:	7b2f      	ldrb	r7, [r5, #12]
 8002a0c:	07f8      	lsls	r0, r7, #31
 8002a0e:	0fc0      	lsrs	r0, r0, #31
 8002a10:	4798      	blx	r3
 8002a12:	7b29      	ldrb	r1, [r5, #12]
 8002a14:	07c8      	lsls	r0, r1, #31
 8002a16:	0fc0      	lsrs	r0, r0, #31
 8002a18:	f002 faac 	bl	8004f74 <USBPD_PRL_SRCReleaseSinkNG>
 8002a1c:	0028      	movs	r0, r5
 8002a1e:	f001 fc67 	bl	80042f0 <PE_ResetDuringSwap>
 8002a22:	48b0      	ldr	r0, [pc, #704]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002a24:	7800      	ldrb	r0, [r0, #0]
 8002a26:	0780      	lsls	r0, r0, #30
 8002a28:	d500      	bpl.n	8002a2c <__iar_annotation$$branch+0x4dc>
 8002a2a:	e14d      	b.n	8002cc8 <__iar_annotation$$branch+0x778>
 8002a2c:	e157      	b.n	8002cde <__iar_annotation$$branch+0x78e>
 8002a2e:	68a8      	ldr	r0, [r5, #8]
 8002a30:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002a32:	2b00      	cmp	r3, #0
 8002a34:	d005      	beq.n	8002a42 <__iar_annotation$$branch+0x4f2>
 8002a36:	2202      	movs	r2, #2
 8002a38:	7b29      	ldrb	r1, [r5, #12]
 8002a3a:	07c8      	lsls	r0, r1, #31
 8002a3c:	0fc0      	lsrs	r0, r0, #31
 8002a3e:	2100      	movs	r1, #0
 8002a40:	4798      	blx	r3
 8002a42:	9400      	str	r4, [sp, #0]
 8002a44:	2358      	movs	r3, #88	; 0x58
 8002a46:	20e5      	movs	r0, #229	; 0xe5
 8002a48:	0080      	lsls	r0, r0, #2
 8002a4a:	5c2a      	ldrb	r2, [r5, r0]
 8002a4c:	2100      	movs	r1, #0
 8002a4e:	0028      	movs	r0, r5
 8002a50:	f000 fe8f 	bl	8003772 <PE_Send_CtrlMessage>
 8002a54:	2800      	cmp	r0, #0
 8002a56:	d000      	beq.n	8002a5a <__iar_annotation$$branch+0x50a>
 8002a58:	e110      	b.n	8002c7c <__iar_annotation$$branch+0x72c>
 8002a5a:	20e5      	movs	r0, #229	; 0xe5
 8002a5c:	0080      	lsls	r0, r0, #2
 8002a5e:	1828      	adds	r0, r5, r0
 8002a60:	8840      	ldrh	r0, [r0, #2]
 8002a62:	82e8      	strh	r0, [r5, #22]
 8002a64:	8337      	strh	r7, [r6, #24]
 8002a66:	241a      	movs	r4, #26
 8002a68:	6868      	ldr	r0, [r5, #4]
 8002a6a:	6801      	ldr	r1, [r0, #0]
 8002a6c:	2210      	movs	r2, #16
 8002a6e:	430a      	orrs	r2, r1
 8002a70:	6002      	str	r2, [r0, #0]
 8002a72:	e24b      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002a74:	2911      	cmp	r1, #17
 8002a76:	d111      	bne.n	8002a9c <__iar_annotation$$branch+0x54c>
 8002a78:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002a7a:	0bc9      	lsrs	r1, r1, #15
 8002a7c:	d10e      	bne.n	8002a9c <__iar_annotation$$branch+0x54c>
 8002a7e:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002a80:	0b09      	lsrs	r1, r1, #12
 8002a82:	0749      	lsls	r1, r1, #29
 8002a84:	d10a      	bne.n	8002a9c <__iar_annotation$$branch+0x54c>
 8002a86:	8e31      	ldrh	r1, [r6, #48]	; 0x30
 8002a88:	06c9      	lsls	r1, r1, #27
 8002a8a:	0ec9      	lsrs	r1, r1, #27
 8002a8c:	2903      	cmp	r1, #3
 8002a8e:	d006      	beq.n	8002a9e <__iar_annotation$$branch+0x54e>
 8002a90:	2904      	cmp	r1, #4
 8002a92:	d066      	beq.n	8002b62 <__iar_annotation$$branch+0x612>
 8002a94:	290c      	cmp	r1, #12
 8002a96:	d049      	beq.n	8002b2c <__iar_annotation$$branch+0x5dc>
 8002a98:	2910      	cmp	r1, #16
 8002a9a:	d077      	beq.n	8002b8c <__iar_annotation$$branch+0x63c>
 8002a9c:	e090      	b.n	8002bc0 <__iar_annotation$$branch+0x670>
 8002a9e:	4802      	ldr	r0, [pc, #8]	; (8002aa8 <__iar_annotation$$branch+0x558>)
 8002aa0:	82b0      	strh	r0, [r6, #20]
 8002aa2:	4c02      	ldr	r4, [pc, #8]	; (8002aac <__iar_annotation$$branch+0x55c>)
 8002aa4:	e004      	b.n	8002ab0 <__iar_annotation$$branch+0x560>
 8002aa6:	bf00      	nop
 8002aa8:	00008343 	.word	0x00008343
 8002aac:	00000343 	.word	0x00000343
 8002ab0:	2000      	movs	r0, #0
 8002ab2:	8330      	strh	r0, [r6, #24]
 8002ab4:	2014      	movs	r0, #20
 8002ab6:	4669      	mov	r1, sp
 8002ab8:	7308      	strb	r0, [r1, #12]
 8002aba:	2059      	movs	r0, #89	; 0x59
 8002abc:	7130      	strb	r0, [r6, #4]
 8002abe:	68a8      	ldr	r0, [r5, #8]
 8002ac0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002ac2:	2b00      	cmp	r3, #0
 8002ac4:	d005      	beq.n	8002ad2 <__iar_annotation$$branch+0x582>
 8002ac6:	2206      	movs	r2, #6
 8002ac8:	2100      	movs	r1, #0
 8002aca:	7b2f      	ldrb	r7, [r5, #12]
 8002acc:	07f8      	lsls	r0, r7, #31
 8002ace:	0fc0      	lsrs	r0, r0, #31
 8002ad0:	4798      	blx	r3
 8002ad2:	6868      	ldr	r0, [r5, #4]
 8002ad4:	7841      	ldrb	r1, [r0, #1]
 8002ad6:	228f      	movs	r2, #143	; 0x8f
 8002ad8:	400a      	ands	r2, r1
 8002ada:	2140      	movs	r1, #64	; 0x40
 8002adc:	4311      	orrs	r1, r2
 8002ade:	7041      	strb	r1, [r0, #1]
 8002ae0:	4880      	ldr	r0, [pc, #512]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002ae2:	7800      	ldrb	r0, [r0, #0]
 8002ae4:	0780      	lsls	r0, r0, #30
 8002ae6:	d50a      	bpl.n	8002afe <__iar_annotation$$branch+0x5ae>
 8002ae8:	2000      	movs	r0, #0
 8002aea:	9000      	str	r0, [sp, #0]
 8002aec:	2300      	movs	r3, #0
 8002aee:	2256      	movs	r2, #86	; 0x56
 8002af0:	7b28      	ldrb	r0, [r5, #12]
 8002af2:	07c1      	lsls	r1, r0, #31
 8002af4:	0fc9      	lsrs	r1, r1, #31
 8002af6:	2009      	movs	r0, #9
 8002af8:	4f7a      	ldr	r7, [pc, #488]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002afa:	68ff      	ldr	r7, [r7, #12]
 8002afc:	47b8      	blx	r7
 8002afe:	2156      	movs	r1, #86	; 0x56
 8002b00:	7b2a      	ldrb	r2, [r5, #12]
 8002b02:	07d0      	lsls	r0, r2, #31
 8002b04:	0fc0      	lsrs	r0, r0, #31
 8002b06:	68aa      	ldr	r2, [r5, #8]
 8002b08:	68d2      	ldr	r2, [r2, #12]
 8002b0a:	4790      	blx	r2
 8002b0c:	4f75      	ldr	r7, [pc, #468]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002b0e:	7838      	ldrb	r0, [r7, #0]
 8002b10:	0780      	lsls	r0, r0, #30
 8002b12:	d509      	bpl.n	8002b28 <__iar_annotation$$branch+0x5d8>
 8002b14:	2000      	movs	r0, #0
 8002b16:	9000      	str	r0, [sp, #0]
 8002b18:	2300      	movs	r3, #0
 8002b1a:	2238      	movs	r2, #56	; 0x38
 8002b1c:	7b28      	ldrb	r0, [r5, #12]
 8002b1e:	07c1      	lsls	r1, r0, #31
 8002b20:	0fc9      	lsrs	r1, r1, #31
 8002b22:	2009      	movs	r0, #9
 8002b24:	68ff      	ldr	r7, [r7, #12]
 8002b26:	47b8      	blx	r7
 8002b28:	2138      	movs	r1, #56	; 0x38
 8002b2a:	e043      	b.n	8002bb4 <__iar_annotation$$branch+0x664>
 8002b2c:	2800      	cmp	r0, #0
 8002b2e:	d009      	beq.n	8002b44 <__iar_annotation$$branch+0x5f4>
 8002b30:	2000      	movs	r0, #0
 8002b32:	9000      	str	r0, [sp, #0]
 8002b34:	2300      	movs	r3, #0
 8002b36:	2239      	movs	r2, #57	; 0x39
 8002b38:	7b28      	ldrb	r0, [r5, #12]
 8002b3a:	07c1      	lsls	r1, r0, #31
 8002b3c:	0fc9      	lsrs	r1, r1, #31
 8002b3e:	2009      	movs	r0, #9
 8002b40:	9f01      	ldr	r7, [sp, #4]
 8002b42:	47b8      	blx	r7
 8002b44:	2139      	movs	r1, #57	; 0x39
 8002b46:	7b2a      	ldrb	r2, [r5, #12]
 8002b48:	07d0      	lsls	r0, r2, #31
 8002b4a:	0fc0      	lsrs	r0, r0, #31
 8002b4c:	68aa      	ldr	r2, [r5, #8]
 8002b4e:	68d2      	ldr	r2, [r2, #12]
 8002b50:	4790      	blx	r2
 8002b52:	2000      	movs	r0, #0
 8002b54:	8330      	strh	r0, [r6, #24]
 8002b56:	2014      	movs	r0, #20
 8002b58:	4669      	mov	r1, sp
 8002b5a:	7308      	strb	r0, [r1, #12]
 8002b5c:	2003      	movs	r0, #3
 8002b5e:	7130      	strb	r0, [r6, #4]
 8002b60:	e02e      	b.n	8002bc0 <__iar_annotation$$branch+0x670>
 8002b62:	2100      	movs	r1, #0
 8002b64:	8331      	strh	r1, [r6, #24]
 8002b66:	2114      	movs	r1, #20
 8002b68:	466a      	mov	r2, sp
 8002b6a:	7311      	strb	r1, [r2, #12]
 8002b6c:	2103      	movs	r1, #3
 8002b6e:	7131      	strb	r1, [r6, #4]
 8002b70:	2800      	cmp	r0, #0
 8002b72:	d009      	beq.n	8002b88 <__iar_annotation$$branch+0x638>
 8002b74:	2000      	movs	r0, #0
 8002b76:	9000      	str	r0, [sp, #0]
 8002b78:	2300      	movs	r3, #0
 8002b7a:	2216      	movs	r2, #22
 8002b7c:	7b28      	ldrb	r0, [r5, #12]
 8002b7e:	07c1      	lsls	r1, r0, #31
 8002b80:	0fc9      	lsrs	r1, r1, #31
 8002b82:	2009      	movs	r0, #9
 8002b84:	9f01      	ldr	r7, [sp, #4]
 8002b86:	47b8      	blx	r7
 8002b88:	2116      	movs	r1, #22
 8002b8a:	e013      	b.n	8002bb4 <__iar_annotation$$branch+0x664>
 8002b8c:	2100      	movs	r1, #0
 8002b8e:	8331      	strh	r1, [r6, #24]
 8002b90:	2114      	movs	r1, #20
 8002b92:	466a      	mov	r2, sp
 8002b94:	7311      	strb	r1, [r2, #12]
 8002b96:	2103      	movs	r1, #3
 8002b98:	7131      	strb	r1, [r6, #4]
 8002b9a:	2800      	cmp	r0, #0
 8002b9c:	d009      	beq.n	8002bb2 <__iar_annotation$$branch+0x662>
 8002b9e:	2000      	movs	r0, #0
 8002ba0:	9000      	str	r0, [sp, #0]
 8002ba2:	2300      	movs	r3, #0
 8002ba4:	2255      	movs	r2, #85	; 0x55
 8002ba6:	7b28      	ldrb	r0, [r5, #12]
 8002ba8:	07c1      	lsls	r1, r0, #31
 8002baa:	0fc9      	lsrs	r1, r1, #31
 8002bac:	2009      	movs	r0, #9
 8002bae:	9f01      	ldr	r7, [sp, #4]
 8002bb0:	47b8      	blx	r7
 8002bb2:	2155      	movs	r1, #85	; 0x55
 8002bb4:	7b2a      	ldrb	r2, [r5, #12]
 8002bb6:	07d0      	lsls	r0, r2, #31
 8002bb8:	0fc0      	lsrs	r0, r0, #31
 8002bba:	68aa      	ldr	r2, [r5, #8]
 8002bbc:	68d2      	ldr	r2, [r2, #12]
 8002bbe:	4790      	blx	r2
 8002bc0:	8b30      	ldrh	r0, [r6, #24]
 8002bc2:	2180      	movs	r1, #128	; 0x80
 8002bc4:	0209      	lsls	r1, r1, #8
 8002bc6:	4288      	cmp	r0, r1
 8002bc8:	d155      	bne.n	8002c76 <__iar_annotation$$branch+0x726>
 8002bca:	2400      	movs	r4, #0
 8002bcc:	8334      	strh	r4, [r6, #24]
 8002bce:	e176      	b.n	8002ebe <__iar_annotation$$branch+0x96e>
 8002bd0:	2911      	cmp	r1, #17
 8002bd2:	d112      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002bd4:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002bd6:	0bc0      	lsrs	r0, r0, #15
 8002bd8:	d10f      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002bda:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002bdc:	0b00      	lsrs	r0, r0, #12
 8002bde:	0740      	lsls	r0, r0, #29
 8002be0:	d10b      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002be2:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002be4:	06c0      	lsls	r0, r0, #27
 8002be6:	0ec0      	lsrs	r0, r0, #27
 8002be8:	2806      	cmp	r0, #6
 8002bea:	d106      	bne.n	8002bfa <__iar_annotation$$branch+0x6aa>
 8002bec:	2000      	movs	r0, #0
 8002bee:	82b0      	strh	r0, [r6, #20]
 8002bf0:	205a      	movs	r0, #90	; 0x5a
 8002bf2:	7130      	strb	r0, [r6, #4]
 8002bf4:	2014      	movs	r0, #20
 8002bf6:	4669      	mov	r1, sp
 8002bf8:	7308      	strb	r0, [r1, #12]
 8002bfa:	8ab0      	ldrh	r0, [r6, #20]
 8002bfc:	03a1      	lsls	r1, r4, #14
 8002bfe:	4288      	cmp	r0, r1
 8002c00:	d139      	bne.n	8002c76 <__iar_annotation$$branch+0x726>
 8002c02:	68a8      	ldr	r0, [r5, #8]
 8002c04:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c06:	2b00      	cmp	r3, #0
 8002c08:	d005      	beq.n	8002c16 <__iar_annotation$$branch+0x6c6>
 8002c0a:	220f      	movs	r2, #15
 8002c0c:	2100      	movs	r1, #0
 8002c0e:	7b2f      	ldrb	r7, [r5, #12]
 8002c10:	07f8      	lsls	r0, r7, #31
 8002c12:	0fc0      	lsrs	r0, r0, #31
 8002c14:	4798      	blx	r3
 8002c16:	2000      	movs	r0, #0
 8002c18:	82b0      	strh	r0, [r6, #20]
 8002c1a:	200f      	movs	r0, #15
 8002c1c:	e175      	b.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002c1e:	68a8      	ldr	r0, [r5, #8]
 8002c20:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c22:	2701      	movs	r7, #1
 8002c24:	2b00      	cmp	r3, #0
 8002c26:	d00f      	beq.n	8002c48 <__iar_annotation$$branch+0x6f8>
 8002c28:	220a      	movs	r2, #10
 8002c2a:	68e9      	ldr	r1, [r5, #12]
 8002c2c:	2001      	movs	r0, #1
 8002c2e:	4008      	ands	r0, r1
 8002c30:	2100      	movs	r1, #0
 8002c32:	4798      	blx	r3
 8002c34:	68a8      	ldr	r0, [r5, #8]
 8002c36:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c38:	2b00      	cmp	r3, #0
 8002c3a:	d005      	beq.n	8002c48 <__iar_annotation$$branch+0x6f8>
 8002c3c:	220b      	movs	r2, #11
 8002c3e:	68e9      	ldr	r1, [r5, #12]
 8002c40:	2001      	movs	r0, #1
 8002c42:	4008      	ands	r0, r1
 8002c44:	2101      	movs	r1, #1
 8002c46:	4798      	blx	r3
 8002c48:	2000      	movs	r0, #0
 8002c4a:	9000      	str	r0, [sp, #0]
 8002c4c:	235b      	movs	r3, #91	; 0x5b
 8002c4e:	2206      	movs	r2, #6
 8002c50:	2100      	movs	r1, #0
 8002c52:	0028      	movs	r0, r5
 8002c54:	f000 fd8d 	bl	8003772 <PE_Send_CtrlMessage>
 8002c58:	2800      	cmp	r0, #0
 8002c5a:	d10f      	bne.n	8002c7c <__iar_annotation$$branch+0x72c>
 8002c5c:	68a8      	ldr	r0, [r5, #8]
 8002c5e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c60:	2b00      	cmp	r3, #0
 8002c62:	d005      	beq.n	8002c70 <__iar_annotation$$branch+0x720>
 8002c64:	220c      	movs	r2, #12
 8002c66:	2100      	movs	r1, #0
 8002c68:	68e8      	ldr	r0, [r5, #12]
 8002c6a:	4007      	ands	r7, r0
 8002c6c:	0038      	movs	r0, r7
 8002c6e:	4798      	blx	r3
 8002c70:	4801      	ldr	r0, [pc, #4]	; (8002c78 <__iar_annotation$$branch+0x728>)
 8002c72:	8430      	strh	r0, [r6, #32]
 8002c74:	2414      	movs	r4, #20
 8002c76:	e149      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002c78:	00008014 	.word	0x00008014
 8002c7c:	68a8      	ldr	r0, [r5, #8]
 8002c7e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002c80:	2b00      	cmp	r3, #0
 8002c82:	d0f8      	beq.n	8002c76 <__iar_annotation$$branch+0x726>
 8002c84:	220f      	movs	r2, #15
 8002c86:	2100      	movs	r1, #0
 8002c88:	7b2f      	ldrb	r7, [r5, #12]
 8002c8a:	07f8      	lsls	r0, r7, #31
 8002c8c:	0fc0      	lsrs	r0, r0, #31
 8002c8e:	4798      	blx	r3
 8002c90:	e13c      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002c92:	8c30      	ldrh	r0, [r6, #32]
 8002c94:	03a1      	lsls	r1, r4, #14
 8002c96:	4288      	cmp	r0, r1
 8002c98:	d1fa      	bne.n	8002c90 <__iar_annotation$$branch+0x740>
 8002c9a:	2000      	movs	r0, #0
 8002c9c:	8430      	strh	r0, [r6, #32]
 8002c9e:	2101      	movs	r1, #1
 8002ca0:	0028      	movs	r0, r5
 8002ca2:	f000 fe7b 	bl	800399c <PE_ChangePowerRole>
 8002ca6:	0028      	movs	r0, r5
 8002ca8:	f001 fb22 	bl	80042f0 <PE_ResetDuringSwap>
 8002cac:	68a8      	ldr	r0, [r5, #8]
 8002cae:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002cb0:	2b00      	cmp	r3, #0
 8002cb2:	d005      	beq.n	8002cc0 <__iar_annotation$$branch+0x770>
 8002cb4:	220e      	movs	r2, #14
 8002cb6:	2101      	movs	r1, #1
 8002cb8:	7b2f      	ldrb	r7, [r5, #12]
 8002cba:	07f8      	lsls	r0, r7, #31
 8002cbc:	0fc0      	lsrs	r0, r0, #31
 8002cbe:	4798      	blx	r3
 8002cc0:	4808      	ldr	r0, [pc, #32]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002cc2:	7800      	ldrb	r0, [r0, #0]
 8002cc4:	0780      	lsls	r0, r0, #30
 8002cc6:	d50a      	bpl.n	8002cde <__iar_annotation$$branch+0x78e>
 8002cc8:	2000      	movs	r0, #0
 8002cca:	9000      	str	r0, [sp, #0]
 8002ccc:	2300      	movs	r3, #0
 8002cce:	2215      	movs	r2, #21
 8002cd0:	7b28      	ldrb	r0, [r5, #12]
 8002cd2:	07c1      	lsls	r1, r0, #31
 8002cd4:	0fc9      	lsrs	r1, r1, #31
 8002cd6:	2009      	movs	r0, #9
 8002cd8:	4f02      	ldr	r7, [pc, #8]	; (8002ce4 <__iar_annotation$$branch+0x794>)
 8002cda:	68ff      	ldr	r7, [r7, #12]
 8002cdc:	47b8      	blx	r7
 8002cde:	2115      	movs	r1, #21
 8002ce0:	e0b8      	b.n	8002e54 <__iar_annotation$$branch+0x904>
 8002ce2:	bf00      	nop
 8002ce4:	200019a8 	.word	0x200019a8
 8002ce8:	ab05      	add	r3, sp, #20
 8002cea:	aa08      	add	r2, sp, #32
 8002cec:	2100      	movs	r1, #0
 8002cee:	7b2f      	ldrb	r7, [r5, #12]
 8002cf0:	07f8      	lsls	r0, r7, #31
 8002cf2:	0fc0      	lsrs	r0, r0, #31
 8002cf4:	68af      	ldr	r7, [r5, #8]
 8002cf6:	69bf      	ldr	r7, [r7, #24]
 8002cf8:	47b8      	blx	r7
 8002cfa:	2000      	movs	r0, #0
 8002cfc:	9002      	str	r0, [sp, #8]
 8002cfe:	2003      	movs	r0, #3
 8002d00:	9001      	str	r0, [sp, #4]
 8002d02:	9805      	ldr	r0, [sp, #20]
 8002d04:	0880      	lsrs	r0, r0, #2
 8002d06:	9000      	str	r0, [sp, #0]
 8002d08:	ab08      	add	r3, sp, #32
 8002d0a:	2201      	movs	r2, #1
 8002d0c:	2100      	movs	r1, #0
 8002d0e:	0028      	movs	r0, r5
 8002d10:	f000 fd76 	bl	8003800 <PE_Send_DataMessage>
 8002d14:	e0fa      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002d16:	9402      	str	r4, [sp, #8]
 8002d18:	2003      	movs	r0, #3
 8002d1a:	9001      	str	r0, [sp, #4]
 8002d1c:	2001      	movs	r0, #1
 8002d1e:	9000      	str	r0, [sp, #0]
 8002d20:	20e3      	movs	r0, #227	; 0xe3
 8002d22:	0080      	lsls	r0, r0, #2
 8002d24:	182b      	adds	r3, r5, r0
 8002d26:	2206      	movs	r2, #6
 8002d28:	2100      	movs	r1, #0
 8002d2a:	0028      	movs	r0, r5
 8002d2c:	f000 fd68 	bl	8003800 <PE_Send_DataMessage>
 8002d30:	e0ec      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002d32:	9400      	str	r4, [sp, #0]
 8002d34:	2366      	movs	r3, #102	; 0x66
 8002d36:	2214      	movs	r2, #20
 8002d38:	2100      	movs	r1, #0
 8002d3a:	0028      	movs	r0, r5
 8002d3c:	f000 fd19 	bl	8003772 <PE_Send_CtrlMessage>
 8002d40:	2800      	cmp	r0, #0
 8002d42:	d1f5      	bne.n	8002d30 <__iar_annotation$$branch+0x7e0>
 8002d44:	8337      	strh	r7, [r6, #24]
 8002d46:	241a      	movs	r4, #26
 8002d48:	4fa8      	ldr	r7, [pc, #672]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002d4a:	7838      	ldrb	r0, [r7, #0]
 8002d4c:	0780      	lsls	r0, r0, #30
 8002d4e:	d509      	bpl.n	8002d64 <__iar_annotation$$branch+0x814>
 8002d50:	2000      	movs	r0, #0
 8002d52:	9000      	str	r0, [sp, #0]
 8002d54:	2300      	movs	r3, #0
 8002d56:	2247      	movs	r2, #71	; 0x47
 8002d58:	7b28      	ldrb	r0, [r5, #12]
 8002d5a:	07c1      	lsls	r1, r0, #31
 8002d5c:	0fc9      	lsrs	r1, r1, #31
 8002d5e:	2009      	movs	r0, #9
 8002d60:	68ff      	ldr	r7, [r7, #12]
 8002d62:	47b8      	blx	r7
 8002d64:	2147      	movs	r1, #71	; 0x47
 8002d66:	7b2a      	ldrb	r2, [r5, #12]
 8002d68:	07d0      	lsls	r0, r2, #31
 8002d6a:	0fc0      	lsrs	r0, r0, #31
 8002d6c:	68aa      	ldr	r2, [r5, #8]
 8002d6e:	68d2      	ldr	r2, [r2, #12]
 8002d70:	4790      	blx	r2
 8002d72:	200b      	movs	r0, #11
 8002d74:	82e8      	strh	r0, [r5, #22]
 8002d76:	e0c9      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002d78:	2911      	cmp	r1, #17
 8002d7a:	d107      	bne.n	8002d8c <__iar_annotation$$branch+0x83c>
 8002d7c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002d7e:	0bc0      	lsrs	r0, r0, #15
 8002d80:	d004      	beq.n	8002d8c <__iar_annotation$$branch+0x83c>
 8002d82:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002d84:	0b00      	lsrs	r0, r0, #12
 8002d86:	0740      	lsls	r0, r0, #29
 8002d88:	d000      	beq.n	8002d8c <__iar_annotation$$branch+0x83c>
 8002d8a:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002d8c:	8b30      	ldrh	r0, [r6, #24]
 8002d8e:	03a1      	lsls	r1, r4, #14
 8002d90:	4288      	cmp	r0, r1
 8002d92:	d1f0      	bne.n	8002d76 <__iar_annotation$$branch+0x826>
 8002d94:	2000      	movs	r0, #0
 8002d96:	8330      	strh	r0, [r6, #24]
 8002d98:	2003      	movs	r0, #3
 8002d9a:	7130      	strb	r0, [r6, #4]
 8002d9c:	e07a      	b.n	8002e94 <__iar_annotation$$branch+0x944>
 8002d9e:	9400      	str	r4, [sp, #0]
 8002da0:	2339      	movs	r3, #57	; 0x39
 8002da2:	20e5      	movs	r0, #229	; 0xe5
 8002da4:	0080      	lsls	r0, r0, #2
 8002da6:	5c2a      	ldrb	r2, [r5, r0]
 8002da8:	2100      	movs	r1, #0
 8002daa:	0028      	movs	r0, r5
 8002dac:	f000 fce1 	bl	8003772 <PE_Send_CtrlMessage>
 8002db0:	2800      	cmp	r0, #0
 8002db2:	d139      	bne.n	8002e28 <__iar_annotation$$branch+0x8d8>
 8002db4:	20e5      	movs	r0, #229	; 0xe5
 8002db6:	0080      	lsls	r0, r0, #2
 8002db8:	1828      	adds	r0, r5, r0
 8002dba:	8840      	ldrh	r0, [r0, #2]
 8002dbc:	82e8      	strh	r0, [r5, #22]
 8002dbe:	6868      	ldr	r0, [r5, #4]
 8002dc0:	7841      	ldrb	r1, [r0, #1]
 8002dc2:	228f      	movs	r2, #143	; 0x8f
 8002dc4:	400a      	ands	r2, r1
 8002dc6:	2130      	movs	r1, #48	; 0x30
 8002dc8:	4311      	orrs	r1, r2
 8002dca:	7041      	strb	r1, [r0, #1]
 8002dcc:	4887      	ldr	r0, [pc, #540]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002dce:	7800      	ldrb	r0, [r0, #0]
 8002dd0:	0780      	lsls	r0, r0, #30
 8002dd2:	d50a      	bpl.n	8002dea <__iar_annotation$$branch+0x89a>
 8002dd4:	2000      	movs	r0, #0
 8002dd6:	9000      	str	r0, [sp, #0]
 8002dd8:	2300      	movs	r3, #0
 8002dda:	2256      	movs	r2, #86	; 0x56
 8002ddc:	7b28      	ldrb	r0, [r5, #12]
 8002dde:	07c1      	lsls	r1, r0, #31
 8002de0:	0fc9      	lsrs	r1, r1, #31
 8002de2:	2009      	movs	r0, #9
 8002de4:	4c81      	ldr	r4, [pc, #516]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002de6:	68e4      	ldr	r4, [r4, #12]
 8002de8:	47a0      	blx	r4
 8002dea:	2156      	movs	r1, #86	; 0x56
 8002dec:	7b2a      	ldrb	r2, [r5, #12]
 8002dee:	07d0      	lsls	r0, r2, #31
 8002df0:	0fc0      	lsrs	r0, r0, #31
 8002df2:	68aa      	ldr	r2, [r5, #8]
 8002df4:	68d2      	ldr	r2, [r2, #12]
 8002df6:	4790      	blx	r2
 8002df8:	4c7c      	ldr	r4, [pc, #496]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002dfa:	7820      	ldrb	r0, [r4, #0]
 8002dfc:	0780      	lsls	r0, r0, #30
 8002dfe:	d509      	bpl.n	8002e14 <__iar_annotation$$branch+0x8c4>
 8002e00:	2000      	movs	r0, #0
 8002e02:	9000      	str	r0, [sp, #0]
 8002e04:	2300      	movs	r3, #0
 8002e06:	2241      	movs	r2, #65	; 0x41
 8002e08:	7b28      	ldrb	r0, [r5, #12]
 8002e0a:	07c1      	lsls	r1, r0, #31
 8002e0c:	0fc9      	lsrs	r1, r1, #31
 8002e0e:	2009      	movs	r0, #9
 8002e10:	68e4      	ldr	r4, [r4, #12]
 8002e12:	47a0      	blx	r4
 8002e14:	2141      	movs	r1, #65	; 0x41
 8002e16:	7b2a      	ldrb	r2, [r5, #12]
 8002e18:	07d0      	lsls	r0, r2, #31
 8002e1a:	0fc0      	lsrs	r0, r0, #31
 8002e1c:	68aa      	ldr	r2, [r5, #8]
 8002e1e:	68d2      	ldr	r2, [r2, #12]
 8002e20:	4790      	blx	r2
 8002e22:	8337      	strh	r7, [r6, #24]
 8002e24:	241a      	movs	r4, #26
 8002e26:	e071      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e28:	6868      	ldr	r0, [r5, #4]
 8002e2a:	7841      	ldrb	r1, [r0, #1]
 8002e2c:	228f      	movs	r2, #143	; 0x8f
 8002e2e:	400a      	ands	r2, r1
 8002e30:	2130      	movs	r1, #48	; 0x30
 8002e32:	4311      	orrs	r1, r2
 8002e34:	7041      	strb	r1, [r0, #1]
 8002e36:	4f6d      	ldr	r7, [pc, #436]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002e38:	7838      	ldrb	r0, [r7, #0]
 8002e3a:	0780      	lsls	r0, r0, #30
 8002e3c:	d509      	bpl.n	8002e52 <__iar_annotation$$branch+0x902>
 8002e3e:	2000      	movs	r0, #0
 8002e40:	9000      	str	r0, [sp, #0]
 8002e42:	2300      	movs	r3, #0
 8002e44:	2256      	movs	r2, #86	; 0x56
 8002e46:	7b28      	ldrb	r0, [r5, #12]
 8002e48:	07c1      	lsls	r1, r0, #31
 8002e4a:	0fc9      	lsrs	r1, r1, #31
 8002e4c:	2009      	movs	r0, #9
 8002e4e:	68ff      	ldr	r7, [r7, #12]
 8002e50:	47b8      	blx	r7
 8002e52:	2156      	movs	r1, #86	; 0x56
 8002e54:	7b2a      	ldrb	r2, [r5, #12]
 8002e56:	07d0      	lsls	r0, r2, #31
 8002e58:	0fc0      	lsrs	r0, r0, #31
 8002e5a:	68aa      	ldr	r2, [r5, #8]
 8002e5c:	68d2      	ldr	r2, [r2, #12]
 8002e5e:	4790      	blx	r2
 8002e60:	e054      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e62:	8b30      	ldrh	r0, [r6, #24]
 8002e64:	03a2      	lsls	r2, r4, #14
 8002e66:	4290      	cmp	r0, r2
 8002e68:	d10a      	bne.n	8002e80 <__iar_annotation$$branch+0x930>
 8002e6a:	2000      	movs	r0, #0
 8002e6c:	8330      	strh	r0, [r6, #24]
 8002e6e:	2103      	movs	r1, #3
 8002e70:	22e5      	movs	r2, #229	; 0xe5
 8002e72:	0092      	lsls	r2, r2, #2
 8002e74:	5caa      	ldrb	r2, [r5, r2]
 8002e76:	2a11      	cmp	r2, #17
 8002e78:	7131      	strb	r1, [r6, #4]
 8002e7a:	d147      	bne.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e7c:	2400      	movs	r4, #0
 8002e7e:	e045      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e80:	2914      	cmp	r1, #20
 8002e82:	d043      	beq.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e84:	2000      	movs	r0, #0
 8002e86:	8330      	strh	r0, [r6, #24]
 8002e88:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002e8a:	0bc0      	lsrs	r0, r0, #15
 8002e8c:	d006      	beq.n	8002e9c <__iar_annotation$$branch+0x94c>
 8002e8e:	0028      	movs	r0, r5
 8002e90:	f001 f842 	bl	8003f18 <PE_Check_ExtendedMessage>
 8002e94:	2014      	movs	r0, #20
 8002e96:	4669      	mov	r1, sp
 8002e98:	7308      	strb	r0, [r1, #12]
 8002e9a:	e037      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002e9c:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002e9e:	0bc0      	lsrs	r0, r0, #15
 8002ea0:	d10b      	bne.n	8002eba <__iar_annotation$$branch+0x96a>
 8002ea2:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002ea4:	0b00      	lsrs	r0, r0, #12
 8002ea6:	0740      	lsls	r0, r0, #29
 8002ea8:	d107      	bne.n	8002eba <__iar_annotation$$branch+0x96a>
 8002eaa:	8e30      	ldrh	r0, [r6, #48]	; 0x30
 8002eac:	06c0      	lsls	r0, r0, #27
 8002eae:	0ec0      	lsrs	r0, r0, #27
 8002eb0:	2810      	cmp	r0, #16
 8002eb2:	d102      	bne.n	8002eba <__iar_annotation$$branch+0x96a>
 8002eb4:	2014      	movs	r0, #20
 8002eb6:	4669      	mov	r1, sp
 8002eb8:	7308      	strb	r0, [r1, #12]
 8002eba:	2000      	movs	r0, #0
 8002ebc:	8330      	strh	r0, [r6, #24]
 8002ebe:	2003      	movs	r0, #3
 8002ec0:	e023      	b.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002ec2:	0028      	movs	r0, r5
 8002ec4:	f001 fb51 	bl	800456a <PE_SubStateMachine_ExtendedMessages>
 8002ec8:	e003      	b.n	8002ed2 <__iar_annotation$$branch+0x982>
 8002eca:	a903      	add	r1, sp, #12
 8002ecc:	0028      	movs	r0, r5
 8002ece:	f001 fc63 	bl	8004798 <PE_SubStateMachine_Generic>
 8002ed2:	0004      	movs	r4, r0
 8002ed4:	e01a      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002ed6:	a903      	add	r1, sp, #12
 8002ed8:	0028      	movs	r0, r5
 8002eda:	f001 fdcf 	bl	8004a7c <PE_SubStateMachine_VconnSwap>
 8002ede:	0004      	movs	r4, r0
 8002ee0:	6868      	ldr	r0, [r5, #4]
 8002ee2:	6800      	ldr	r0, [r0, #0]
 8002ee4:	0340      	lsls	r0, r0, #13
 8002ee6:	0fc1      	lsrs	r1, r0, #31
 8002ee8:	4668      	mov	r0, sp
 8002eea:	7b40      	ldrb	r0, [r0, #13]
 8002eec:	f002 f855 	bl	8004f9a <USBPD_PRL_CableCapable>
 8002ef0:	e00c      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 8002ef2:	2106      	movs	r1, #6
 8002ef4:	4668      	mov	r0, sp
 8002ef6:	7b40      	ldrb	r0, [r0, #13]
 8002ef8:	f006 ffba 	bl	8009e70 <USBPD_PHY_ResetRequest>
 8002efc:	6868      	ldr	r0, [r5, #4]
 8002efe:	7840      	ldrb	r0, [r0, #1]
 8002f00:	0640      	lsls	r0, r0, #25
 8002f02:	0f40      	lsrs	r0, r0, #29
 8002f04:	2803      	cmp	r0, #3
 8002f06:	d000      	beq.n	8002f0a <__iar_annotation$$branch+0x9ba>
 8002f08:	2043      	movs	r0, #67	; 0x43
 8002f0a:	7130      	strb	r0, [r6, #4]
 8002f0c:	4837      	ldr	r0, [pc, #220]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002f0e:	68c7      	ldr	r7, [r0, #12]
 8002f10:	2f00      	cmp	r7, #0
 8002f12:	d00f      	beq.n	8002f34 <__iar_annotation$$branch+0x9e4>
 8002f14:	7800      	ldrb	r0, [r0, #0]
 8002f16:	07c0      	lsls	r0, r0, #31
 8002f18:	d50c      	bpl.n	8002f34 <__iar_annotation$$branch+0x9e4>
 8002f1a:	7932      	ldrb	r2, [r6, #4]
 8002f1c:	7970      	ldrb	r0, [r6, #5]
 8002f1e:	4290      	cmp	r0, r2
 8002f20:	d008      	beq.n	8002f34 <__iar_annotation$$branch+0x9e4>
 8002f22:	7172      	strb	r2, [r6, #5]
 8002f24:	2000      	movs	r0, #0
 8002f26:	9000      	str	r0, [sp, #0]
 8002f28:	2300      	movs	r3, #0
 8002f2a:	7b28      	ldrb	r0, [r5, #12]
 8002f2c:	07c1      	lsls	r1, r0, #31
 8002f2e:	0fc9      	lsrs	r1, r1, #31
 8002f30:	2004      	movs	r0, #4
 8002f32:	47b8      	blx	r7
 8002f34:	4668      	mov	r0, sp
 8002f36:	7b00      	ldrb	r0, [r0, #12]
 8002f38:	2814      	cmp	r0, #20
 8002f3a:	d01d      	beq.n	8002f78 <__iar_annotation$$branch+0xa28>
 8002f3c:	0028      	movs	r0, r5
 8002f3e:	f000 fd69 	bl	8003a14 <PE_Check_AMSConflict>
 8002f42:	2815      	cmp	r0, #21
 8002f44:	d102      	bne.n	8002f4c <__iar_annotation$$branch+0x9fc>
 8002f46:	2014      	movs	r0, #20
 8002f48:	4669      	mov	r1, sp
 8002f4a:	7308      	strb	r0, [r1, #12]
 8002f4c:	4827      	ldr	r0, [pc, #156]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002f4e:	68c4      	ldr	r4, [r0, #12]
 8002f50:	2c00      	cmp	r4, #0
 8002f52:	d00f      	beq.n	8002f74 <__iar_annotation$$branch+0xa24>
 8002f54:	7800      	ldrb	r0, [r0, #0]
 8002f56:	07c0      	lsls	r0, r0, #31
 8002f58:	d50c      	bpl.n	8002f74 <__iar_annotation$$branch+0xa24>
 8002f5a:	7932      	ldrb	r2, [r6, #4]
 8002f5c:	7970      	ldrb	r0, [r6, #5]
 8002f5e:	4290      	cmp	r0, r2
 8002f60:	d008      	beq.n	8002f74 <__iar_annotation$$branch+0xa24>
 8002f62:	7172      	strb	r2, [r6, #5]
 8002f64:	2000      	movs	r0, #0
 8002f66:	9000      	str	r0, [sp, #0]
 8002f68:	2300      	movs	r3, #0
 8002f6a:	7b28      	ldrb	r0, [r5, #12]
 8002f6c:	07c1      	lsls	r1, r0, #31
 8002f6e:	0fc9      	lsrs	r1, r1, #31
 8002f70:	2004      	movs	r0, #4
 8002f72:	47a0      	blx	r4
 8002f74:	2400      	movs	r4, #0
 8002f76:	e012      	b.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f78:	7930      	ldrb	r0, [r6, #4]
 8002f7a:	2803      	cmp	r0, #3
 8002f7c:	d10f      	bne.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f7e:	200a      	movs	r0, #10
 8002f80:	5e30      	ldrsh	r0, [r6, r0]
 8002f82:	2800      	cmp	r0, #0
 8002f84:	d00b      	beq.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f86:	2116      	movs	r1, #22
 8002f88:	5e69      	ldrsh	r1, [r5, r1]
 8002f8a:	2900      	cmp	r1, #0
 8002f8c:	d107      	bne.n	8002f9e <__iar_annotation$$branch+0xa4e>
 8002f8e:	7a31      	ldrb	r1, [r6, #8]
 8002f90:	7131      	strb	r1, [r6, #4]
 8002f92:	7a71      	ldrb	r1, [r6, #9]
 8002f94:	71f1      	strb	r1, [r6, #7]
 8002f96:	82e8      	strh	r0, [r5, #22]
 8002f98:	2000      	movs	r0, #0
 8002f9a:	8170      	strh	r0, [r6, #10]
 8002f9c:	2401      	movs	r4, #1
 8002f9e:	9807      	ldr	r0, [sp, #28]
 8002fa0:	2800      	cmp	r0, #0
 8002fa2:	d01d      	beq.n	8002fe0 <__iar_annotation$$branch+0xa90>
 8002fa4:	4811      	ldr	r0, [pc, #68]	; (8002fec <__iar_annotation$$branch+0xa9c>)
 8002fa6:	6901      	ldr	r1, [r0, #16]
 8002fa8:	4aa9      	ldr	r2, [pc, #676]	; (8003250 <.text_23>)
 8002faa:	4291      	cmp	r1, r2
 8002fac:	d018      	beq.n	8002fe0 <__iar_annotation$$branch+0xa90>
 8002fae:	2101      	movs	r1, #1
 8002fb0:	1d02      	adds	r2, r0, #4
 8002fb2:	68eb      	ldr	r3, [r5, #12]
 8002fb4:	400b      	ands	r3, r1
 8002fb6:	009b      	lsls	r3, r3, #2
 8002fb8:	58d2      	ldr	r2, [r2, r3]
 8002fba:	68d7      	ldr	r7, [r2, #12]
 8002fbc:	0b3e      	lsrs	r6, r7, #12
 8002fbe:	1c76      	adds	r6, r6, #1
 8002fc0:	4ba4      	ldr	r3, [pc, #656]	; (8003254 <.text_24>)
 8002fc2:	401f      	ands	r7, r3
 8002fc4:	0336      	lsls	r6, r6, #12
 8002fc6:	433e      	orrs	r6, r7
 8002fc8:	60d6      	str	r6, [r2, #12]
 8002fca:	1d00      	adds	r0, r0, #4
 8002fcc:	68ea      	ldr	r2, [r5, #12]
 8002fce:	4011      	ands	r1, r2
 8002fd0:	0089      	lsls	r1, r1, #2
 8002fd2:	5840      	ldr	r0, [r0, r1]
 8002fd4:	68c1      	ldr	r1, [r0, #12]
 8002fd6:	0b0a      	lsrs	r2, r1, #12
 8002fd8:	2a08      	cmp	r2, #8
 8002fda:	db01      	blt.n	8002fe0 <__iar_annotation$$branch+0xa90>
 8002fdc:	400b      	ands	r3, r1
 8002fde:	60c3      	str	r3, [r0, #12]
 8002fe0:	2c00      	cmp	r4, #0
 8002fe2:	d00a      	beq.n	8002ffa <__iar_annotation$$branch+0xaaa>
 8002fe4:	0020      	movs	r0, r4
 8002fe6:	b00f      	add	sp, #60	; 0x3c
 8002fe8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002fea:	bf00      	nop
 8002fec:	200019a8 	.word	0x200019a8
 8002ff0:	4668      	mov	r0, sp
 8002ff2:	7345      	strb	r5, [r0, #13]
 8002ff4:	9d06      	ldr	r5, [sp, #24]
 8002ff6:	9407      	str	r4, [sp, #28]
 8002ff8:	9606      	str	r6, [sp, #24]
 8002ffa:	2402      	movs	r4, #2
 8002ffc:	20d5      	movs	r0, #213	; 0xd5
 8002ffe:	0080      	lsls	r0, r0, #2
 8003000:	182e      	adds	r6, r5, r0
 8003002:	7832      	ldrb	r2, [r6, #0]
 8003004:	2a0f      	cmp	r2, #15
 8003006:	d115      	bne.n	8003034 <__iar_annotation$$branch+0xae4>
 8003008:	7132      	strb	r2, [r6, #4]
 800300a:	2000      	movs	r0, #0
 800300c:	7030      	strb	r0, [r6, #0]
 800300e:	4892      	ldr	r0, [pc, #584]	; (8003258 <.text_25>)
 8003010:	68c7      	ldr	r7, [r0, #12]
 8003012:	2f00      	cmp	r7, #0
 8003014:	d00e      	beq.n	8003034 <__iar_annotation$$branch+0xae4>
 8003016:	7800      	ldrb	r0, [r0, #0]
 8003018:	07c0      	lsls	r0, r0, #31
 800301a:	d50b      	bpl.n	8003034 <__iar_annotation$$branch+0xae4>
 800301c:	7970      	ldrb	r0, [r6, #5]
 800301e:	4290      	cmp	r0, r2
 8003020:	d008      	beq.n	8003034 <__iar_annotation$$branch+0xae4>
 8003022:	7172      	strb	r2, [r6, #5]
 8003024:	2000      	movs	r0, #0
 8003026:	9000      	str	r0, [sp, #0]
 8003028:	2300      	movs	r3, #0
 800302a:	7b28      	ldrb	r0, [r5, #12]
 800302c:	07c1      	lsls	r1, r0, #31
 800302e:	0fc9      	lsrs	r1, r1, #31
 8003030:	2004      	movs	r0, #4
 8003032:	47b8      	blx	r7
 8003034:	9806      	ldr	r0, [sp, #24]
 8003036:	2800      	cmp	r0, #0
 8003038:	d006      	beq.n	8003048 <__iar_annotation$$branch+0xaf8>
 800303a:	2107      	movs	r1, #7
 800303c:	f002 fe34 	bl	8005ca8 <__aeabi_idivmod>
 8003040:	2900      	cmp	r1, #0
 8003042:	d101      	bne.n	8003048 <__iar_annotation$$branch+0xaf8>
 8003044:	2001      	movs	r0, #1
 8003046:	9007      	str	r0, [sp, #28]
 8003048:	4983      	ldr	r1, [pc, #524]	; (8003258 <.text_25>)
 800304a:	7808      	ldrb	r0, [r1, #0]
 800304c:	4020      	ands	r0, r4
 800304e:	68c9      	ldr	r1, [r1, #12]
 8003050:	9101      	str	r1, [sp, #4]
 8003052:	4669      	mov	r1, sp
 8003054:	7b09      	ldrb	r1, [r1, #12]
 8003056:	4f81      	ldr	r7, [pc, #516]	; (800325c <.text_26>)
 8003058:	7932      	ldrb	r2, [r6, #4]
 800305a:	2a00      	cmp	r2, #0
 800305c:	d101      	bne.n	8003062 <__iar_annotation$$branch+0x4>

0800305e <__iar_annotation$$branch>:
 800305e:	f7fe fe4e 	bl	8001cfe <__iar_annotation$$branch+0x4>
 8003062:	1e52      	subs	r2, r2, #1
 8003064:	d046      	beq.n	80030f4 <__iar_annotation$$branch+0x2c>
 8003066:	1e92      	subs	r2, r2, #2
 8003068:	d101      	bne.n	800306e <__iar_annotation$$branch+0x4>

0800306a <__iar_annotation$$branch>:
 800306a:	f7ff fa41 	bl	80024f0 <__iar_annotation$$branch+0x26>
 800306e:	1e52      	subs	r2, r2, #1
 8003070:	d101      	bne.n	8003076 <__iar_annotation$$branch+0x4>

08003072 <__iar_annotation$$branch>:
 8003072:	f7ff fa54 	bl	800251e <__iar_annotation$$branch+0x54>
 8003076:	3a0b      	subs	r2, #11
 8003078:	d101      	bne.n	800307e <__iar_annotation$$branch+0x4>

0800307a <__iar_annotation$$branch>:
 800307a:	f7fe ffdb 	bl	8002034 <__iar_annotation$$branch+0x202>
 800307e:	1e52      	subs	r2, r2, #1
 8003080:	d101      	bne.n	8003086 <__iar_annotation$$branch+0x4>

08003082 <__iar_annotation$$branch>:
 8003082:	f7ff f894 	bl	80021ae <__iar_annotation$$branch+0x37c>
 8003086:	1e52      	subs	r2, r2, #1
 8003088:	d101      	bne.n	800308e <__iar_annotation$$branch+0x4>

0800308a <__iar_annotation$$branch>:
 800308a:	f7ff f8ab 	bl	80021e4 <__iar_annotation$$branch+0x3b2>
 800308e:	1fd2      	subs	r2, r2, #7
 8003090:	d101      	bne.n	8003096 <__iar_annotation$$branch+0x4>

08003092 <__iar_annotation$$branch>:
 8003092:	f7ff f996 	bl	80023c2 <__iar_annotation$$branch+0x4>
 8003096:	1e92      	subs	r2, r2, #2
 8003098:	d101      	bne.n	800309e <__iar_annotation$$branch+0x4>

0800309a <__iar_annotation$$branch>:
 800309a:	f7ff f91c 	bl	80022d6 <__iar_annotation$$branch+0x66>
 800309e:	1ed2      	subs	r2, r2, #3
 80030a0:	d101      	bne.n	80030a6 <__iar_annotation$$branch+0x4>

080030a2 <__iar_annotation$$branch>:
 80030a2:	f7ff f8e7 	bl	8002274 <__iar_annotation$$branch+0x4>
 80030a6:	1e52      	subs	r2, r2, #1
 80030a8:	d100      	bne.n	80030ac <__iar_annotation$$branch+0xa>
 80030aa:	e4c0      	b.n	8002a2e <__iar_annotation$$branch+0x4de>
 80030ac:	1f12      	subs	r2, r2, #4
 80030ae:	d101      	bne.n	80030b4 <__iar_annotation$$branch+0x4>

080030b0 <__iar_annotation$$branch>:
 80030b0:	f7ff fb88 	bl	80027c4 <__iar_annotation$$branch+0x274>
 80030b4:	1f52      	subs	r2, r2, #5
 80030b6:	d101      	bne.n	80030bc <__iar_annotation$$branch+0x4>

080030b8 <__iar_annotation$$branch>:
 80030b8:	f7ff f93f 	bl	800233a <__iar_annotation$$branch+0x4>
 80030bc:	1e92      	subs	r2, r2, #2
 80030be:	d101      	bne.n	80030c4 <__iar_annotation$$branch+0x4>

080030c0 <__iar_annotation$$branch>:
 80030c0:	f7ff f927 	bl	8002312 <__iar_annotation$$branch+0xa2>
 80030c4:	1e52      	subs	r2, r2, #1
 80030c6:	d101      	bne.n	80030cc <__iar_annotation$$branch+0x4>

080030c8 <__iar_annotation$$branch>:
 80030c8:	f7ff fa01 	bl	80024ce <__iar_annotation$$branch+0x4>
 80030cc:	1e52      	subs	r2, r2, #1
 80030ce:	d100      	bne.n	80030d2 <__iar_annotation$$branch+0xa>
 80030d0:	e621      	b.n	8002d16 <__iar_annotation$$branch+0x7c6>
 80030d2:	1e52      	subs	r2, r2, #1
 80030d4:	d00e      	beq.n	80030f4 <__iar_annotation$$branch+0x2c>
 80030d6:	1e92      	subs	r2, r2, #2
 80030d8:	d100      	bne.n	80030dc <__iar_annotation$$branch+0x14>
 80030da:	e660      	b.n	8002d9e <__iar_annotation$$branch+0x84e>
 80030dc:	1e52      	subs	r2, r2, #1
 80030de:	2a01      	cmp	r2, #1
 80030e0:	d908      	bls.n	80030f4 <__iar_annotation$$branch+0x2c>
 80030e2:	1e92      	subs	r2, r2, #2
 80030e4:	2a07      	cmp	r2, #7
 80030e6:	d800      	bhi.n	80030ea <__iar_annotation$$branch+0x22>
 80030e8:	e6eb      	b.n	8002ec2 <__iar_annotation$$branch+0x972>
 80030ea:	3a08      	subs	r2, #8
 80030ec:	d100      	bne.n	80030f0 <__iar_annotation$$branch+0x28>
 80030ee:	e6b8      	b.n	8002e62 <__iar_annotation$$branch+0x912>
 80030f0:	1e52      	subs	r2, r2, #1
 80030f2:	2a03      	cmp	r2, #3
 80030f4:	d800      	bhi.n	80030f8 <__iar_annotation$$branch+0x30>
 80030f6:	e6e8      	b.n	8002eca <__iar_annotation$$branch+0x97a>
 80030f8:	1f12      	subs	r2, r2, #4
 80030fa:	d101      	bne.n	8003100 <__iar_annotation$$branch+0x4>

080030fc <__iar_annotation$$branch>:
 80030fc:	f7fe fe08 	bl	8001d10 <__iar_annotation$$branch+0x4>
 8003100:	1e52      	subs	r2, r2, #1
 8003102:	d101      	bne.n	8003108 <__iar_annotation$$branch+0x4>

08003104 <__iar_annotation$$branch>:
 8003104:	f7fe ffd6 	bl	80020b4 <__iar_annotation$$branch+0x282>
 8003108:	1e52      	subs	r2, r2, #1
 800310a:	d101      	bne.n	8003110 <__iar_annotation$$branch+0x4>

0800310c <__iar_annotation$$branch>:
 800310c:	f7ff f82a 	bl	8002164 <__iar_annotation$$branch+0x332>
 8003110:	1ed2      	subs	r2, r2, #3
 8003112:	d101      	bne.n	8003118 <__iar_annotation$$branch+0x4>

08003114 <__iar_annotation$$branch>:
 8003114:	f7fe fe2a 	bl	8001d6c <__iar_annotation$$branch+0x4>
 8003118:	1e52      	subs	r2, r2, #1
 800311a:	d101      	bne.n	8003120 <__iar_annotation$$branch+0x4>

0800311c <__iar_annotation$$branch>:
 800311c:	f7fe fe66 	bl	8001dec <__iar_annotation$$branch+0x84>
 8003120:	1e52      	subs	r2, r2, #1
 8003122:	d101      	bne.n	8003128 <__iar_annotation$$branch+0x4>

08003124 <__iar_annotation$$branch>:
 8003124:	f7fe fe78 	bl	8001e18 <__iar_annotation$$branch+0xb0>
 8003128:	1e52      	subs	r2, r2, #1
 800312a:	d101      	bne.n	8003130 <__iar_annotation$$branch+0x4>

0800312c <__iar_annotation$$branch>:
 800312c:	f7fe fe83 	bl	8001e36 <__iar_annotation$$branch+0x4>
 8003130:	1e52      	subs	r2, r2, #1
 8003132:	d101      	bne.n	8003138 <__iar_annotation$$branch+0x4>

08003134 <__iar_annotation$$branch>:
 8003134:	f7fe ff28 	bl	8001f88 <__iar_annotation$$branch+0x156>
 8003138:	1e92      	subs	r2, r2, #2
 800313a:	d101      	bne.n	8003140 <__iar_annotation$$branch+0x4>

0800313c <__iar_annotation$$branch>:
 800313c:	f7ff f9d5 	bl	80024ea <__iar_annotation$$branch+0x20>
 8003140:	1ed2      	subs	r2, r2, #3
 8003142:	d100      	bne.n	8003146 <__iar_annotation$$branch+0xa>
 8003144:	e5d0      	b.n	8002ce8 <__iar_annotation$$branch+0x798>
 8003146:	1f12      	subs	r2, r2, #4
 8003148:	d101      	bne.n	800314e <__iar_annotation$$branch+0x4>

0800314a <__iar_annotation$$branch>:
 800314a:	f7ff f872 	bl	8002232 <__iar_annotation$$branch+0x400>
 800314e:	1e92      	subs	r2, r2, #2
 8003150:	d101      	bne.n	8003156 <__iar_annotation$$branch+0x4>

08003152 <__iar_annotation$$branch>:
 8003152:	f7ff fbb1 	bl	80028b8 <__iar_annotation$$branch+0x368>
 8003156:	1e52      	subs	r2, r2, #1
 8003158:	d101      	bne.n	800315e <__iar_annotation$$branch+0x4>

0800315a <__iar_annotation$$branch>:
 800315a:	f7ff fbda 	bl	8002912 <__iar_annotation$$branch+0x3c2>
 800315e:	1e52      	subs	r2, r2, #1
 8003160:	d100      	bne.n	8003164 <__iar_annotation$$branch+0xa>
 8003162:	e442      	b.n	80029ea <__iar_annotation$$branch+0x49a>
 8003164:	1f12      	subs	r2, r2, #4
 8003166:	d100      	bne.n	800316a <__iar_annotation$$branch+0x10>
 8003168:	e484      	b.n	8002a74 <__iar_annotation$$branch+0x524>
 800316a:	1e52      	subs	r2, r2, #1
 800316c:	d100      	bne.n	8003170 <__iar_annotation$$branch+0x16>
 800316e:	e52f      	b.n	8002bd0 <__iar_annotation$$branch+0x680>
 8003170:	1e52      	subs	r2, r2, #1
 8003172:	d100      	bne.n	8003176 <__iar_annotation$$branch+0x1c>
 8003174:	e553      	b.n	8002c1e <__iar_annotation$$branch+0x6ce>
 8003176:	1e52      	subs	r2, r2, #1
 8003178:	d100      	bne.n	800317c <__iar_annotation$$branch+0x22>
 800317a:	e58a      	b.n	8002c92 <__iar_annotation$$branch+0x742>
 800317c:	1e92      	subs	r2, r2, #2
 800317e:	d101      	bne.n	8003184 <__iar_annotation$$branch+0x4>

08003180 <__iar_annotation$$branch>:
 8003180:	f7ff f8e9 	bl	8002356 <__iar_annotation$$branch+0x20>
 8003184:	1ed2      	subs	r2, r2, #3
 8003186:	d101      	bne.n	800318c <__iar_annotation$$branch+0x4>

08003188 <__iar_annotation$$branch>:
 8003188:	f7ff f939 	bl	80023fe <__iar_annotation$$branch+0x40>
 800318c:	1e92      	subs	r2, r2, #2
 800318e:	2a01      	cmp	r2, #1
 8003190:	d9b0      	bls.n	80030f4 <__iar_annotation$$branch+0x2c>
 8003192:	1ed2      	subs	r2, r2, #3
 8003194:	d100      	bne.n	8003198 <__iar_annotation$$branch+0x10>
 8003196:	e5cc      	b.n	8002d32 <__iar_annotation$$branch+0x7e2>
 8003198:	1e52      	subs	r2, r2, #1
 800319a:	d100      	bne.n	800319e <__iar_annotation$$branch+0x16>
 800319c:	e5ec      	b.n	8002d78 <__iar_annotation$$branch+0x828>
 800319e:	3a0e      	subs	r2, #14
 80031a0:	d0a8      	beq.n	80030f4 <__iar_annotation$$branch+0x2c>
 80031a2:	3a1e      	subs	r2, #30
 80031a4:	d01e      	beq.n	80031e4 <__iar_annotation$$branch+0x14>
 80031a6:	1e52      	subs	r2, r2, #1
 80031a8:	d101      	bne.n	80031ae <__iar_annotation$$branch+0x4>

080031aa <__iar_annotation$$branch>:
 80031aa:	f7ff fa2e 	bl	800260a <__iar_annotation$$branch+0xba>
 80031ae:	1e52      	subs	r2, r2, #1
 80031b0:	d101      	bne.n	80031b6 <__iar_annotation$$branch+0x4>

080031b2 <__iar_annotation$$branch>:
 80031b2:	f7ff fa81 	bl	80026b8 <__iar_annotation$$branch+0x168>
 80031b6:	1e52      	subs	r2, r2, #1
 80031b8:	d101      	bne.n	80031be <__iar_annotation$$branch+0x4>

080031ba <__iar_annotation$$branch>:
 80031ba:	f7ff fa8a 	bl	80026d2 <__iar_annotation$$branch+0x182>
 80031be:	1ed2      	subs	r2, r2, #3
 80031c0:	d101      	bne.n	80031c6 <__iar_annotation$$branch+0x4>

080031c2 <__iar_annotation$$branch>:
 80031c2:	f7ff f8d7 	bl	8002374 <__iar_annotation$$branch+0x4>
 80031c6:	1e52      	subs	r2, r2, #1
 80031c8:	d100      	bne.n	80031cc <__iar_annotation$$branch+0xa>
 80031ca:	e692      	b.n	8002ef2 <__iar_annotation$$branch+0x9a2>
 80031cc:	1e92      	subs	r2, r2, #2
 80031ce:	d101      	bne.n	80031d4 <__iar_annotation$$branch+0x4>

080031d0 <__iar_annotation$$branch>:
 80031d0:	f7fe ffa5 	bl	800211e <__iar_annotation$$branch+0x2ec>
 80031d4:	1e52      	subs	r2, r2, #1
 80031d6:	2a08      	cmp	r2, #8
 80031d8:	d800      	bhi.n	80031dc <__iar_annotation$$branch+0xc>
 80031da:	e67c      	b.n	8002ed6 <__iar_annotation$$branch+0x986>
 80031dc:	3a09      	subs	r2, #9
 80031de:	d100      	bne.n	80031e2 <__iar_annotation$$branch+0x12>
 80031e0:	e66f      	b.n	8002ec2 <__iar_annotation$$branch+0x972>
 80031e2:	e693      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>
 80031e4:	68a8      	ldr	r0, [r5, #8]
 80031e6:	6b81      	ldr	r1, [r0, #56]	; 0x38
 80031e8:	2900      	cmp	r1, #0
 80031ea:	d003      	beq.n	80031f4 <__iar_annotation$$branch+0x24>
 80031ec:	7b2a      	ldrb	r2, [r5, #12]
 80031ee:	07d0      	lsls	r0, r2, #31
 80031f0:	0fc0      	lsrs	r0, r0, #31
 80031f2:	4788      	blx	r1
 80031f4:	2014      	movs	r0, #20
 80031f6:	4669      	mov	r1, sp
 80031f8:	7308      	strb	r0, [r1, #12]
 80031fa:	2101      	movs	r1, #1
 80031fc:	4668      	mov	r0, sp
 80031fe:	7b40      	ldrb	r0, [r0, #13]
 8003200:	f000 ffc5 	bl	800418e <PE_Reset>
 8003204:	4668      	mov	r0, sp
 8003206:	7b40      	ldrb	r0, [r0, #13]
 8003208:	f002 f924 	bl	8005454 <USBPD_PRL_Reset>
 800320c:	e67e      	b.n	8002f0c <__iar_annotation$$branch+0x9bc>

0800320e <USBPD_PE_StateMachine_DRP>:
 800320e:	b580      	push	{r7, lr}
 8003210:	4911      	ldr	r1, [pc, #68]	; (8003258 <.text_25>)
 8003212:	0082      	lsls	r2, r0, #2
 8003214:	1889      	adds	r1, r1, r2
 8003216:	6849      	ldr	r1, [r1, #4]
 8003218:	6849      	ldr	r1, [r1, #4]
 800321a:	7809      	ldrb	r1, [r1, #0]
 800321c:	0889      	lsrs	r1, r1, #2
 800321e:	07c9      	lsls	r1, r1, #31
 8003220:	d502      	bpl.n	8003228 <USBPD_PE_StateMachine_DRP+0x1a>
 8003222:	f7fd f973 	bl	800050c <USBPD_PE_StateMachine_SRC>
 8003226:	bd02      	pop	{r1, pc}
 8003228:	f7fe fd00 	bl	8001c2c <USBPD_PE_StateMachine_SNK>
 800322c:	bd02      	pop	{r1, pc}

0800322e <USBPD_PE_Request_HardReset>:
 800322e:	b580      	push	{r7, lr}
 8003230:	4909      	ldr	r1, [pc, #36]	; (8003258 <.text_25>)
 8003232:	0082      	lsls	r2, r0, #2
 8003234:	1889      	adds	r1, r1, r2
 8003236:	6849      	ldr	r1, [r1, #4]
 8003238:	22d5      	movs	r2, #213	; 0xd5
 800323a:	0092      	lsls	r2, r2, #2
 800323c:	188a      	adds	r2, r1, r2
 800323e:	2300      	movs	r3, #0
 8003240:	7053      	strb	r3, [r2, #1]
 8003242:	230f      	movs	r3, #15
 8003244:	7013      	strb	r3, [r2, #0]
 8003246:	6889      	ldr	r1, [r1, #8]
 8003248:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800324a:	4788      	blx	r1
 800324c:	2000      	movs	r0, #0
 800324e:	bd02      	pop	{r1, pc}

08003250 <.text_23>:
 8003250:	b5e8b5cd 	.word	0xb5e8b5cd

08003254 <.text_24>:
 8003254:	00000fff 	.word	0x00000fff

08003258 <.text_25>:
 8003258:	200019a8 	.word	0x200019a8

0800325c <.text_26>:
 800325c:	0000801a 	.word	0x0000801a

08003260 <USBPD_PE_Request_CtrlMessage>:
 8003260:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 8003262:	b082      	sub	sp, #8
 8003264:	48b9      	ldr	r0, [pc, #740]	; (800354c <.text_29>)
 8003266:	466b      	mov	r3, sp
 8003268:	7a1b      	ldrb	r3, [r3, #8]
 800326a:	009b      	lsls	r3, r3, #2
 800326c:	58c0      	ldr	r0, [r0, r3]
 800326e:	9000      	str	r0, [sp, #0]
 8003270:	2402      	movs	r4, #2
 8003272:	23d5      	movs	r3, #213	; 0xd5
 8003274:	009b      	lsls	r3, r3, #2
 8003276:	18c0      	adds	r0, r0, r3
 8003278:	7803      	ldrb	r3, [r0, #0]
 800327a:	2b00      	cmp	r3, #0
 800327c:	d106      	bne.n	800328c <USBPD_PE_Request_CtrlMessage+0x2c>
 800327e:	9b00      	ldr	r3, [sp, #0]
 8003280:	685b      	ldr	r3, [r3, #4]
 8003282:	2501      	movs	r5, #1
 8003284:	681e      	ldr	r6, [r3, #0]
 8003286:	0af6      	lsrs	r6, r6, #11
 8003288:	402e      	ands	r6, r5
 800328a:	d101      	bne.n	8003290 <USBPD_PE_Request_CtrlMessage+0x30>
 800328c:	2003      	movs	r0, #3
 800328e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8003290:	466e      	mov	r6, sp
 8003292:	7132      	strb	r2, [r6, #4]
 8003294:	466a      	mov	r2, sp
 8003296:	7151      	strb	r1, [r2, #5]
 8003298:	9900      	ldr	r1, [sp, #0]
 800329a:	22e5      	movs	r2, #229	; 0xe5
 800329c:	0092      	lsls	r2, r2, #2
 800329e:	1889      	adds	r1, r1, r2
 80032a0:	222e      	movs	r2, #46	; 0x2e
 80032a2:	2603      	movs	r6, #3
 80032a4:	466f      	mov	r7, sp
 80032a6:	797f      	ldrb	r7, [r7, #5]
 80032a8:	2f02      	cmp	r7, #2
 80032aa:	d01a      	beq.n	80032e2 <USBPD_PE_Request_CtrlMessage+0x82>
 80032ac:	2f07      	cmp	r7, #7
 80032ae:	d029      	beq.n	8003304 <USBPD_PE_Request_CtrlMessage+0xa4>
 80032b0:	2f08      	cmp	r7, #8
 80032b2:	d03a      	beq.n	800332a <USBPD_PE_Request_CtrlMessage+0xca>
 80032b4:	2f09      	cmp	r7, #9
 80032b6:	d04b      	beq.n	8003350 <USBPD_PE_Request_CtrlMessage+0xf0>
 80032b8:	2f0a      	cmp	r7, #10
 80032ba:	d052      	beq.n	8003362 <USBPD_PE_Request_CtrlMessage+0x102>
 80032bc:	2f0b      	cmp	r7, #11
 80032be:	d063      	beq.n	8003388 <USBPD_PE_Request_CtrlMessage+0x128>
 80032c0:	2f0d      	cmp	r7, #13
 80032c2:	d06c      	beq.n	800339e <USBPD_PE_Request_CtrlMessage+0x13e>
 80032c4:	2f11      	cmp	r7, #17
 80032c6:	d071      	beq.n	80033ac <USBPD_PE_Request_CtrlMessage+0x14c>
 80032c8:	2f12      	cmp	r7, #18
 80032ca:	d100      	bne.n	80032ce <USBPD_PE_Request_CtrlMessage+0x6e>
 80032cc:	e082      	b.n	80033d4 <USBPD_PE_Request_CtrlMessage+0x174>
 80032ce:	2f13      	cmp	r7, #19
 80032d0:	d100      	bne.n	80032d4 <USBPD_PE_Request_CtrlMessage+0x74>
 80032d2:	e090      	b.n	80033f6 <USBPD_PE_Request_CtrlMessage+0x196>
 80032d4:	2f14      	cmp	r7, #20
 80032d6:	d100      	bne.n	80032da <USBPD_PE_Request_CtrlMessage+0x7a>
 80032d8:	e0a3      	b.n	8003422 <USBPD_PE_Request_CtrlMessage+0x1c2>
 80032da:	2f15      	cmp	r7, #21
 80032dc:	d100      	bne.n	80032e0 <USBPD_PE_Request_CtrlMessage+0x80>
 80032de:	e0b8      	b.n	8003452 <USBPD_PE_Request_CtrlMessage+0x1f2>
 80032e0:	e0d0      	b.n	8003484 <USBPD_PE_Request_CtrlMessage+0x224>
 80032e2:	781a      	ldrb	r2, [r3, #0]
 80032e4:	0892      	lsrs	r2, r2, #2
 80032e6:	422a      	tst	r2, r5
 80032e8:	d00a      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80032ea:	804c      	strh	r4, [r1, #2]
 80032ec:	2400      	movs	r4, #0
 80032ee:	7044      	strb	r4, [r0, #1]
 80032f0:	2196      	movs	r1, #150	; 0x96
 80032f2:	7001      	strb	r1, [r0, #0]
 80032f4:	4668      	mov	r0, sp
 80032f6:	7a00      	ldrb	r0, [r0, #8]
 80032f8:	9900      	ldr	r1, [sp, #0]
 80032fa:	6889      	ldr	r1, [r1, #8]
 80032fc:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80032fe:	4788      	blx	r1
 8003300:	0020      	movs	r0, r4
 8003302:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 8003304:	7859      	ldrb	r1, [r3, #1]
 8003306:	0649      	lsls	r1, r1, #25
 8003308:	0f49      	lsrs	r1, r1, #29
 800330a:	2903      	cmp	r1, #3
 800330c:	d1f8      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 800330e:	9900      	ldr	r1, [sp, #0]
 8003310:	6809      	ldr	r1, [r1, #0]
 8003312:	6849      	ldr	r1, [r1, #4]
 8003314:	08c9      	lsrs	r1, r1, #3
 8003316:	4029      	ands	r1, r5
 8003318:	d103      	bne.n	8003322 <USBPD_PE_Request_CtrlMessage+0xc2>
 800331a:	7819      	ldrb	r1, [r3, #0]
 800331c:	0889      	lsrs	r1, r1, #2
 800331e:	4229      	tst	r1, r5
 8003320:	d1ee      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003322:	2400      	movs	r4, #0
 8003324:	7044      	strb	r4, [r0, #1]
 8003326:	211a      	movs	r1, #26
 8003328:	e7e3      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 800332a:	7859      	ldrb	r1, [r3, #1]
 800332c:	0649      	lsls	r1, r1, #25
 800332e:	0f49      	lsrs	r1, r1, #29
 8003330:	2903      	cmp	r1, #3
 8003332:	d1e5      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003334:	9900      	ldr	r1, [sp, #0]
 8003336:	6809      	ldr	r1, [r1, #0]
 8003338:	6849      	ldr	r1, [r1, #4]
 800333a:	08c9      	lsrs	r1, r1, #3
 800333c:	4029      	ands	r1, r5
 800333e:	d103      	bne.n	8003348 <USBPD_PE_Request_CtrlMessage+0xe8>
 8003340:	7819      	ldrb	r1, [r3, #0]
 8003342:	0889      	lsrs	r1, r1, #2
 8003344:	4229      	tst	r1, r5
 8003346:	d0db      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003348:	2400      	movs	r4, #0
 800334a:	7044      	strb	r4, [r0, #1]
 800334c:	2118      	movs	r1, #24
 800334e:	e7d0      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003350:	7859      	ldrb	r1, [r3, #1]
 8003352:	0649      	lsls	r1, r1, #25
 8003354:	0f49      	lsrs	r1, r1, #29
 8003356:	2903      	cmp	r1, #3
 8003358:	d1d2      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 800335a:	2400      	movs	r4, #0
 800335c:	7044      	strb	r4, [r0, #1]
 800335e:	2194      	movs	r1, #148	; 0x94
 8003360:	e7c7      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003362:	785a      	ldrb	r2, [r3, #1]
 8003364:	0652      	lsls	r2, r2, #25
 8003366:	0f52      	lsrs	r2, r2, #29
 8003368:	2a03      	cmp	r2, #3
 800336a:	d1c9      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 800336c:	9a00      	ldr	r2, [sp, #0]
 800336e:	6812      	ldr	r2, [r2, #0]
 8003370:	6852      	ldr	r2, [r2, #4]
 8003372:	08d2      	lsrs	r2, r2, #3
 8003374:	4015      	ands	r5, r2
 8003376:	d0c3      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003378:	220a      	movs	r2, #10
 800337a:	700a      	strb	r2, [r1, #0]
 800337c:	2208      	movs	r2, #8
 800337e:	804a      	strh	r2, [r1, #2]
 8003380:	2400      	movs	r4, #0
 8003382:	7044      	strb	r4, [r0, #1]
 8003384:	211e      	movs	r1, #30
 8003386:	e7b4      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003388:	9a00      	ldr	r2, [sp, #0]
 800338a:	6892      	ldr	r2, [r2, #8]
 800338c:	6b12      	ldr	r2, [r2, #48]	; 0x30
 800338e:	2a00      	cmp	r2, #0
 8003390:	d0b6      	beq.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 8003392:	2210      	movs	r2, #16
 8003394:	804a      	strh	r2, [r1, #2]
 8003396:	2400      	movs	r4, #0
 8003398:	7044      	strb	r4, [r0, #1]
 800339a:	21a2      	movs	r1, #162	; 0xa2
 800339c:	e7a9      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 800339e:	4669      	mov	r1, sp
 80033a0:	7909      	ldrb	r1, [r1, #4]
 80033a2:	7041      	strb	r1, [r0, #1]
 80033a4:	2111      	movs	r1, #17
 80033a6:	7001      	strb	r1, [r0, #0]
 80033a8:	2400      	movs	r4, #0
 80033aa:	e7a3      	b.n	80032f4 <USBPD_PE_Request_CtrlMessage+0x94>
 80033ac:	785f      	ldrb	r7, [r3, #1]
 80033ae:	067f      	lsls	r7, r7, #25
 80033b0:	0f7f      	lsrs	r7, r7, #29
 80033b2:	2f03      	cmp	r7, #3
 80033b4:	d1a4      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033b6:	781b      	ldrb	r3, [r3, #0]
 80033b8:	401e      	ands	r6, r3
 80033ba:	2e01      	cmp	r6, #1
 80033bc:	dda0      	ble.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033be:	089b      	lsrs	r3, r3, #2
 80033c0:	422b      	tst	r3, r5
 80033c2:	d19d      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033c4:	2311      	movs	r3, #17
 80033c6:	700b      	strb	r3, [r1, #0]
 80033c8:	230a      	movs	r3, #10
 80033ca:	804b      	strh	r3, [r1, #2]
 80033cc:	2400      	movs	r4, #0
 80033ce:	7044      	strb	r4, [r0, #1]
 80033d0:	7002      	strb	r2, [r0, #0]
 80033d2:	e78f      	b.n	80032f4 <USBPD_PE_Request_CtrlMessage+0x94>
 80033d4:	785d      	ldrb	r5, [r3, #1]
 80033d6:	066d      	lsls	r5, r5, #25
 80033d8:	0f6d      	lsrs	r5, r5, #29
 80033da:	2d03      	cmp	r5, #3
 80033dc:	d190      	bne.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033de:	781b      	ldrb	r3, [r3, #0]
 80033e0:	401e      	ands	r6, r3
 80033e2:	2e01      	cmp	r6, #1
 80033e4:	dd8c      	ble.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>
 80033e6:	7002      	strb	r2, [r0, #0]
 80033e8:	2212      	movs	r2, #18
 80033ea:	700a      	strb	r2, [r1, #0]
 80033ec:	220b      	movs	r2, #11
 80033ee:	804a      	strh	r2, [r1, #2]
 80033f0:	2400      	movs	r4, #0
 80033f2:	7044      	strb	r4, [r0, #1]
 80033f4:	e77e      	b.n	80032f4 <USBPD_PE_Request_CtrlMessage+0x94>
 80033f6:	785a      	ldrb	r2, [r3, #1]
 80033f8:	0652      	lsls	r2, r2, #25
 80033fa:	0f52      	lsrs	r2, r2, #29
 80033fc:	2a03      	cmp	r2, #3
 80033fe:	d1ed      	bne.n	80033dc <USBPD_PE_Request_CtrlMessage+0x17c>
 8003400:	781a      	ldrb	r2, [r3, #0]
 8003402:	4016      	ands	r6, r2
 8003404:	2e01      	cmp	r6, #1
 8003406:	dded      	ble.n	80033e4 <USBPD_PE_Request_CtrlMessage+0x184>
 8003408:	0892      	lsrs	r2, r2, #2
 800340a:	422a      	tst	r2, r5
 800340c:	d1e6      	bne.n	80033dc <USBPD_PE_Request_CtrlMessage+0x17c>
 800340e:	9a00      	ldr	r2, [sp, #0]
 8003410:	6812      	ldr	r2, [r2, #0]
 8003412:	88d2      	ldrh	r2, [r2, #6]
 8003414:	0852      	lsrs	r2, r2, #1
 8003416:	422a      	tst	r2, r5
 8003418:	d0e4      	beq.n	80033e4 <USBPD_PE_Request_CtrlMessage+0x184>
 800341a:	2213      	movs	r2, #19
 800341c:	700a      	strb	r2, [r1, #0]
 800341e:	2209      	movs	r2, #9
 8003420:	e7ad      	b.n	800337e <USBPD_PE_Request_CtrlMessage+0x11e>
 8003422:	785a      	ldrb	r2, [r3, #1]
 8003424:	0652      	lsls	r2, r2, #25
 8003426:	0f52      	lsrs	r2, r2, #29
 8003428:	2a03      	cmp	r2, #3
 800342a:	d1d7      	bne.n	80033dc <USBPD_PE_Request_CtrlMessage+0x17c>
 800342c:	781a      	ldrb	r2, [r3, #0]
 800342e:	4016      	ands	r6, r2
 8003430:	2e01      	cmp	r6, #1
 8003432:	ddd7      	ble.n	80033e4 <USBPD_PE_Request_CtrlMessage+0x184>
 8003434:	0892      	lsrs	r2, r2, #2
 8003436:	422a      	tst	r2, r5
 8003438:	d125      	bne.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 800343a:	9a00      	ldr	r2, [sp, #0]
 800343c:	6812      	ldr	r2, [r2, #0]
 800343e:	88d2      	ldrh	r2, [r2, #6]
 8003440:	0892      	lsrs	r2, r2, #2
 8003442:	422a      	tst	r2, r5
 8003444:	d01f      	beq.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 8003446:	220b      	movs	r2, #11
 8003448:	804a      	strh	r2, [r1, #2]
 800344a:	2400      	movs	r4, #0
 800344c:	7044      	strb	r4, [r0, #1]
 800344e:	2165      	movs	r1, #101	; 0x65
 8003450:	e74f      	b.n	80032f2 <USBPD_PE_Request_CtrlMessage+0x92>
 8003452:	785f      	ldrb	r7, [r3, #1]
 8003454:	067f      	lsls	r7, r7, #25
 8003456:	0f7f      	lsrs	r7, r7, #29
 8003458:	2f03      	cmp	r7, #3
 800345a:	d114      	bne.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 800345c:	781b      	ldrb	r3, [r3, #0]
 800345e:	401e      	ands	r6, r3
 8003460:	2e01      	cmp	r6, #1
 8003462:	dd10      	ble.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 8003464:	9b00      	ldr	r3, [sp, #0]
 8003466:	681b      	ldr	r3, [r3, #0]
 8003468:	88db      	ldrh	r3, [r3, #6]
 800346a:	0a1b      	lsrs	r3, r3, #8
 800346c:	422b      	tst	r3, r5
 800346e:	d00a      	beq.n	8003486 <USBPD_PE_Request_CtrlMessage+0x226>
 8003470:	466b      	mov	r3, sp
 8003472:	791b      	ldrb	r3, [r3, #4]
 8003474:	7043      	strb	r3, [r0, #1]
 8003476:	23ff      	movs	r3, #255	; 0xff
 8003478:	330e      	adds	r3, #14
 800347a:	804b      	strh	r3, [r1, #2]
 800347c:	2315      	movs	r3, #21
 800347e:	700b      	strb	r3, [r1, #0]
 8003480:	7002      	strb	r2, [r0, #0]
 8003482:	e791      	b.n	80033a8 <USBPD_PE_Request_CtrlMessage+0x148>
 8003484:	2410      	movs	r4, #16
 8003486:	e73b      	b.n	8003300 <USBPD_PE_Request_CtrlMessage+0xa0>

08003488 <USBPD_PE_Request_DataMessage>:
 8003488:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 800348a:	b084      	sub	sp, #16
 800348c:	482f      	ldr	r0, [pc, #188]	; (800354c <.text_29>)
 800348e:	466b      	mov	r3, sp
 8003490:	7c1b      	ldrb	r3, [r3, #16]
 8003492:	009b      	lsls	r3, r3, #2
 8003494:	58c0      	ldr	r0, [r0, r3]
 8003496:	9001      	str	r0, [sp, #4]
 8003498:	2402      	movs	r4, #2
 800349a:	23d5      	movs	r3, #213	; 0xd5
 800349c:	009b      	lsls	r3, r3, #2
 800349e:	18c0      	adds	r0, r0, r3
 80034a0:	7803      	ldrb	r3, [r0, #0]
 80034a2:	2b00      	cmp	r3, #0
 80034a4:	d106      	bne.n	80034b4 <USBPD_PE_Request_DataMessage+0x2c>
 80034a6:	9b01      	ldr	r3, [sp, #4]
 80034a8:	685b      	ldr	r3, [r3, #4]
 80034aa:	2501      	movs	r5, #1
 80034ac:	681e      	ldr	r6, [r3, #0]
 80034ae:	0af6      	lsrs	r6, r6, #11
 80034b0:	402e      	ands	r6, r5
 80034b2:	d101      	bne.n	80034b8 <USBPD_PE_Request_DataMessage+0x30>
 80034b4:	2003      	movs	r0, #3
 80034b6:	e022      	b.n	80034fe <USBPD_PE_Request_DataMessage+0x76>
 80034b8:	9203      	str	r2, [sp, #12]
 80034ba:	466a      	mov	r2, sp
 80034bc:	7011      	strb	r1, [r2, #0]
 80034be:	9901      	ldr	r1, [sp, #4]
 80034c0:	4a9c      	ldr	r2, [pc, #624]	; (8003734 <.text_33>)
 80034c2:	1889      	adds	r1, r1, r2
 80034c4:	9102      	str	r1, [sp, #8]
 80034c6:	2103      	movs	r1, #3
 80034c8:	2207      	movs	r2, #7
 80034ca:	2600      	movs	r6, #0
 80034cc:	466f      	mov	r7, sp
 80034ce:	783f      	ldrb	r7, [r7, #0]
 80034d0:	2f01      	cmp	r7, #1
 80034d2:	d004      	beq.n	80034de <USBPD_PE_Request_DataMessage+0x56>
 80034d4:	2f06      	cmp	r7, #6
 80034d6:	d014      	beq.n	8003502 <USBPD_PE_Request_DataMessage+0x7a>
 80034d8:	2f07      	cmp	r7, #7
 80034da:	d022      	beq.n	8003522 <USBPD_PE_Request_DataMessage+0x9a>
 80034dc:	e034      	b.n	8003548 <USBPD_PE_Request_DataMessage+0xc0>
 80034de:	7819      	ldrb	r1, [r3, #0]
 80034e0:	0889      	lsrs	r1, r1, #2
 80034e2:	4229      	tst	r1, r5
 80034e4:	d00a      	beq.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 80034e6:	9902      	ldr	r1, [sp, #8]
 80034e8:	800d      	strh	r5, [r1, #0]
 80034ea:	7046      	strb	r6, [r0, #1]
 80034ec:	7002      	strb	r2, [r0, #0]
 80034ee:	2400      	movs	r4, #0
 80034f0:	4668      	mov	r0, sp
 80034f2:	7c00      	ldrb	r0, [r0, #16]
 80034f4:	9901      	ldr	r1, [sp, #4]
 80034f6:	6889      	ldr	r1, [r1, #8]
 80034f8:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80034fa:	4788      	blx	r1
 80034fc:	0020      	movs	r0, r4
 80034fe:	b005      	add	sp, #20
 8003500:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003502:	785d      	ldrb	r5, [r3, #1]
 8003504:	092d      	lsrs	r5, r5, #4
 8003506:	402a      	ands	r2, r5
 8003508:	2a03      	cmp	r2, #3
 800350a:	d1f7      	bne.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 800350c:	781a      	ldrb	r2, [r3, #0]
 800350e:	4011      	ands	r1, r2
 8003510:	2901      	cmp	r1, #1
 8003512:	ddf3      	ble.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 8003514:	7046      	strb	r6, [r0, #1]
 8003516:	9903      	ldr	r1, [sp, #12]
 8003518:	6809      	ldr	r1, [r1, #0]
 800351a:	6381      	str	r1, [r0, #56]	; 0x38
 800351c:	212b      	movs	r1, #43	; 0x2b
 800351e:	7001      	strb	r1, [r0, #0]
 8003520:	e7e5      	b.n	80034ee <USBPD_PE_Request_DataMessage+0x66>
 8003522:	785d      	ldrb	r5, [r3, #1]
 8003524:	092d      	lsrs	r5, r5, #4
 8003526:	402a      	ands	r2, r5
 8003528:	2a03      	cmp	r2, #3
 800352a:	d1e7      	bne.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 800352c:	781a      	ldrb	r2, [r3, #0]
 800352e:	4011      	ands	r1, r2
 8003530:	2901      	cmp	r1, #1
 8003532:	dde3      	ble.n	80034fc <USBPD_PE_Request_DataMessage+0x74>
 8003534:	9903      	ldr	r1, [sp, #12]
 8003536:	6809      	ldr	r1, [r1, #0]
 8003538:	6381      	str	r1, [r0, #56]	; 0x38
 800353a:	21ff      	movs	r1, #255	; 0xff
 800353c:	310e      	adds	r1, #14
 800353e:	9a02      	ldr	r2, [sp, #8]
 8003540:	8011      	strh	r1, [r2, #0]
 8003542:	7046      	strb	r6, [r0, #1]
 8003544:	2162      	movs	r1, #98	; 0x62
 8003546:	e7ea      	b.n	800351e <USBPD_PE_Request_DataMessage+0x96>
 8003548:	2410      	movs	r4, #16
 800354a:	e7d7      	b.n	80034fc <USBPD_PE_Request_DataMessage+0x74>

0800354c <.text_29>:
 800354c:	200019ac 	.word	0x200019ac

08003550 <USBPD_PE_Send_Request>:
 8003550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003552:	4b79      	ldr	r3, [pc, #484]	; (8003738 <.text_34>)
 8003554:	0084      	lsls	r4, r0, #2
 8003556:	591b      	ldr	r3, [r3, r4]
 8003558:	24d5      	movs	r4, #213	; 0xd5
 800355a:	00a4      	lsls	r4, r4, #2
 800355c:	191c      	adds	r4, r3, r4
 800355e:	7825      	ldrb	r5, [r4, #0]
 8003560:	2d00      	cmp	r5, #0
 8003562:	d105      	bne.n	8003570 <USBPD_PE_Send_Request+0x20>
 8003564:	685d      	ldr	r5, [r3, #4]
 8003566:	2601      	movs	r6, #1
 8003568:	682f      	ldr	r7, [r5, #0]
 800356a:	0aff      	lsrs	r7, r7, #11
 800356c:	4037      	ands	r7, r6
 800356e:	d101      	bne.n	8003574 <USBPD_PE_Send_Request+0x24>
 8003570:	2003      	movs	r0, #3
 8003572:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 8003574:	786f      	ldrb	r7, [r5, #1]
 8003576:	067f      	lsls	r7, r7, #25
 8003578:	0f7f      	lsrs	r7, r7, #29
 800357a:	2f03      	cmp	r7, #3
 800357c:	d115      	bne.n	80035aa <USBPD_PE_Send_Request+0x5a>
 800357e:	782d      	ldrb	r5, [r5, #0]
 8003580:	08ad      	lsrs	r5, r5, #2
 8003582:	4235      	tst	r5, r6
 8003584:	d111      	bne.n	80035aa <USBPD_PE_Send_Request+0x5a>
 8003586:	2545      	movs	r5, #69	; 0x45
 8003588:	7025      	strb	r5, [r4, #0]
 800358a:	6119      	str	r1, [r3, #16]
 800358c:	7b19      	ldrb	r1, [r3, #12]
 800358e:	25f3      	movs	r5, #243	; 0xf3
 8003590:	400d      	ands	r5, r1
 8003592:	0091      	lsls	r1, r2, #2
 8003594:	220c      	movs	r2, #12
 8003596:	400a      	ands	r2, r1
 8003598:	432a      	orrs	r2, r5
 800359a:	731a      	strb	r2, [r3, #12]
 800359c:	2100      	movs	r1, #0
 800359e:	7061      	strb	r1, [r4, #1]
 80035a0:	6899      	ldr	r1, [r3, #8]
 80035a2:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80035a4:	4788      	blx	r1
 80035a6:	2000      	movs	r0, #0
 80035a8:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}
 80035aa:	2002      	movs	r0, #2
 80035ac:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

080035ae <USBPD_PE_SendExtendedMessage>:
 80035ae:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
 80035b0:	b083      	sub	sp, #12
 80035b2:	2600      	movs	r6, #0
 80035b4:	9601      	str	r6, [sp, #4]
 80035b6:	4860      	ldr	r0, [pc, #384]	; (8003738 <.text_34>)
 80035b8:	4669      	mov	r1, sp
 80035ba:	7b09      	ldrb	r1, [r1, #12]
 80035bc:	0089      	lsls	r1, r1, #2
 80035be:	5844      	ldr	r4, [r0, r1]
 80035c0:	20d3      	movs	r0, #211	; 0xd3
 80035c2:	0080      	lsls	r0, r0, #2
 80035c4:	1825      	adds	r5, r4, r0
 80035c6:	7a28      	ldrb	r0, [r5, #8]
 80035c8:	2800      	cmp	r0, #0
 80035ca:	d104      	bne.n	80035d6 <USBPD_PE_SendExtendedMessage+0x28>
 80035cc:	6860      	ldr	r0, [r4, #4]
 80035ce:	6801      	ldr	r1, [r0, #0]
 80035d0:	050f      	lsls	r7, r1, #20
 80035d2:	0fff      	lsrs	r7, r7, #31
 80035d4:	d101      	bne.n	80035da <USBPD_PE_SendExtendedMessage+0x2c>
 80035d6:	2003      	movs	r0, #3
 80035d8:	e06f      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 80035da:	7841      	ldrb	r1, [r0, #1]
 80035dc:	0649      	lsls	r1, r1, #25
 80035de:	0f49      	lsrs	r1, r1, #29
 80035e0:	2903      	cmp	r1, #3
 80035e2:	d10c      	bne.n	80035fe <USBPD_PE_SendExtendedMessage+0x50>
 80035e4:	7800      	ldrb	r0, [r0, #0]
 80035e6:	0780      	lsls	r0, r0, #30
 80035e8:	0f80      	lsrs	r0, r0, #30
 80035ea:	2801      	cmp	r0, #1
 80035ec:	dc01      	bgt.n	80035f2 <USBPD_PE_SendExtendedMessage+0x44>
 80035ee:	2001      	movs	r0, #1
 80035f0:	e063      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 80035f2:	4668      	mov	r0, sp
 80035f4:	8d00      	ldrh	r0, [r0, #40]	; 0x28
 80035f6:	21ff      	movs	r1, #255	; 0xff
 80035f8:	1d89      	adds	r1, r1, #6
 80035fa:	4288      	cmp	r0, r1
 80035fc:	d301      	bcc.n	8003602 <USBPD_PE_SendExtendedMessage+0x54>
 80035fe:	2002      	movs	r0, #2
 8003600:	e05b      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 8003602:	4668      	mov	r0, sp
 8003604:	7002      	strb	r2, [r0, #0]
 8003606:	68e0      	ldr	r0, [r4, #12]
 8003608:	2110      	movs	r1, #16
 800360a:	4388      	bics	r0, r1
 800360c:	60e0      	str	r0, [r4, #12]
 800360e:	4949      	ldr	r1, [pc, #292]	; (8003734 <.text_33>)
 8003610:	1861      	adds	r1, r4, r1
 8003612:	2210      	movs	r2, #16
 8003614:	466f      	mov	r7, sp
 8003616:	783f      	ldrb	r7, [r7, #0]
 8003618:	2f83      	cmp	r7, #131	; 0x83
 800361a:	d00c      	beq.n	8003636 <USBPD_PE_SendExtendedMessage+0x88>
 800361c:	2f84      	cmp	r7, #132	; 0x84
 800361e:	d021      	beq.n	8003664 <USBPD_PE_SendExtendedMessage+0xb6>
 8003620:	2f86      	cmp	r7, #134	; 0x86
 8003622:	d021      	beq.n	8003668 <USBPD_PE_SendExtendedMessage+0xba>
 8003624:	2f88      	cmp	r7, #136	; 0x88
 8003626:	d021      	beq.n	800366c <USBPD_PE_SendExtendedMessage+0xbe>
 8003628:	2f89      	cmp	r7, #137	; 0x89
 800362a:	d009      	beq.n	8003640 <USBPD_PE_SendExtendedMessage+0x92>
 800362c:	2f8a      	cmp	r7, #138	; 0x8a
 800362e:	d023      	beq.n	8003678 <USBPD_PE_SendExtendedMessage+0xca>
 8003630:	2f8b      	cmp	r7, #139	; 0x8b
 8003632:	d005      	beq.n	8003640 <USBPD_PE_SendExtendedMessage+0x92>
 8003634:	e025      	b.n	8003682 <USBPD_PE_SendExtendedMessage+0xd4>
 8003636:	200c      	movs	r0, #12
 8003638:	8008      	strh	r0, [r1, #0]
 800363a:	68e0      	ldr	r0, [r4, #12]
 800363c:	4302      	orrs	r2, r0
 800363e:	60e2      	str	r2, [r4, #12]
 8003640:	4668      	mov	r0, sp
 8003642:	8d00      	ldrh	r0, [r0, #40]	; 0x28
 8003644:	2800      	cmp	r0, #0
 8003646:	d028      	beq.n	800369a <USBPD_PE_SendExtendedMessage+0xec>
 8003648:	001f      	movs	r7, r3
 800364a:	4668      	mov	r0, sp
 800364c:	7b00      	ldrb	r0, [r0, #12]
 800364e:	f000 ff29 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8003652:	2801      	cmp	r0, #1
 8003654:	d100      	bne.n	8003658 <USBPD_PE_SendExtendedMessage+0xaa>
 8003656:	2604      	movs	r6, #4
 8003658:	9702      	str	r7, [sp, #8]
 800365a:	9801      	ldr	r0, [sp, #4]
 800365c:	4669      	mov	r1, sp
 800365e:	8d09      	ldrh	r1, [r1, #40]	; 0x28
 8003660:	4fc3      	ldr	r7, [pc, #780]	; (8003970 <.text_40>)
 8003662:	e016      	b.n	8003692 <USBPD_PE_SendExtendedMessage+0xe4>
 8003664:	200d      	movs	r0, #13
 8003666:	e7e7      	b.n	8003638 <USBPD_PE_SendExtendedMessage+0x8a>
 8003668:	200e      	movs	r0, #14
 800366a:	e7e5      	b.n	8003638 <USBPD_PE_SendExtendedMessage+0x8a>
 800366c:	4302      	orrs	r2, r0
 800366e:	60e2      	str	r2, [r4, #12]
 8003670:	20ff      	movs	r0, #255	; 0xff
 8003672:	300c      	adds	r0, #12
 8003674:	8008      	strh	r0, [r1, #0]
 8003676:	e7e3      	b.n	8003640 <USBPD_PE_SendExtendedMessage+0x92>
 8003678:	4302      	orrs	r2, r0
 800367a:	60e2      	str	r2, [r4, #12]
 800367c:	2086      	movs	r0, #134	; 0x86
 800367e:	0040      	lsls	r0, r0, #1
 8003680:	e7f8      	b.n	8003674 <USBPD_PE_SendExtendedMessage+0xc6>
 8003682:	2010      	movs	r0, #16
 8003684:	e019      	b.n	80036ba <USBPD_PE_SendExtendedMessage+0x10c>
 8003686:	9a02      	ldr	r2, [sp, #8]
 8003688:	5c12      	ldrb	r2, [r2, r0]
 800368a:	1983      	adds	r3, r0, r6
 800368c:	18e3      	adds	r3, r4, r3
 800368e:	55da      	strb	r2, [r3, r7]
 8003690:	1c40      	adds	r0, r0, #1
 8003692:	4288      	cmp	r0, r1
 8003694:	d3f7      	bcc.n	8003686 <USBPD_PE_SendExtendedMessage+0xd8>
 8003696:	8029      	strh	r1, [r5, #0]
 8003698:	e000      	b.n	800369c <USBPD_PE_SendExtendedMessage+0xee>
 800369a:	802e      	strh	r6, [r5, #0]
 800369c:	4668      	mov	r0, sp
 800369e:	7c00      	ldrb	r0, [r0, #16]
 80036a0:	7268      	strb	r0, [r5, #9]
 80036a2:	4668      	mov	r0, sp
 80036a4:	7800      	ldrb	r0, [r0, #0]
 80036a6:	49bc      	ldr	r1, [pc, #752]	; (8003998 <.text_43>)
 80036a8:	5460      	strb	r0, [r4, r1]
 80036aa:	2031      	movs	r0, #49	; 0x31
 80036ac:	7228      	strb	r0, [r5, #8]
 80036ae:	4668      	mov	r0, sp
 80036b0:	7b00      	ldrb	r0, [r0, #12]
 80036b2:	68a1      	ldr	r1, [r4, #8]
 80036b4:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 80036b6:	4788      	blx	r1
 80036b8:	2000      	movs	r0, #0
 80036ba:	b005      	add	sp, #20
 80036bc:	bdf0      	pop	{r4, r5, r6, r7, pc}

080036be <PE_Send_SRCCapabilities>:
 80036be:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80036c0:	b084      	sub	sp, #16
 80036c2:	0005      	movs	r5, r0
 80036c4:	000f      	movs	r7, r1
 80036c6:	20e2      	movs	r0, #226	; 0xe2
 80036c8:	0080      	lsls	r0, r0, #2
 80036ca:	582e      	ldr	r6, [r5, r0]
 80036cc:	211e      	movs	r1, #30
 80036ce:	0028      	movs	r0, r5
 80036d0:	3018      	adds	r0, #24
 80036d2:	f009 fa29 	bl	800cb28 <__aeabi_memclr>
 80036d6:	ab02      	add	r3, sp, #8
 80036d8:	002a      	movs	r2, r5
 80036da:	321a      	adds	r2, #26
 80036dc:	2100      	movs	r1, #0
 80036de:	7b2c      	ldrb	r4, [r5, #12]
 80036e0:	07e0      	lsls	r0, r4, #31
 80036e2:	0fc0      	lsrs	r0, r0, #31
 80036e4:	68ac      	ldr	r4, [r5, #8]
 80036e6:	69a4      	ldr	r4, [r4, #24]
 80036e8:	47a0      	blx	r4
 80036ea:	9802      	ldr	r0, [sp, #8]
 80036ec:	1c80      	adds	r0, r0, #2
 80036ee:	b2c0      	uxtb	r0, r0
 80036f0:	4669      	mov	r1, sp
 80036f2:	8188      	strh	r0, [r1, #12]
 80036f4:	2401      	movs	r4, #1
 80036f6:	9701      	str	r7, [sp, #4]
 80036f8:	4668      	mov	r0, sp
 80036fa:	8980      	ldrh	r0, [r0, #12]
 80036fc:	9000      	str	r0, [sp, #0]
 80036fe:	002b      	movs	r3, r5
 8003700:	3318      	adds	r3, #24
 8003702:	2201      	movs	r2, #1
 8003704:	68e9      	ldr	r1, [r5, #12]
 8003706:	2001      	movs	r0, #1
 8003708:	4008      	ands	r0, r1
 800370a:	2100      	movs	r1, #0
 800370c:	f001 fc5a 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8003710:	2803      	cmp	r0, #3
 8003712:	d10c      	bne.n	800372e <PE_Send_SRCCapabilities+0x70>
 8003714:	20e2      	movs	r0, #226	; 0xe2
 8003716:	0080      	lsls	r0, r0, #2
 8003718:	5828      	ldr	r0, [r5, r0]
 800371a:	1b80      	subs	r0, r0, r6
 800371c:	49b9      	ldr	r1, [pc, #740]	; (8003a04 <.text_46>)
 800371e:	4288      	cmp	r0, r1
 8003720:	d204      	bcs.n	800372c <PE_Send_SRCCapabilities+0x6e>
 8003722:	6868      	ldr	r0, [r5, #4]
 8003724:	6800      	ldr	r0, [r0, #0]
 8003726:	0ac0      	lsrs	r0, r0, #11
 8003728:	4004      	ands	r4, r0
 800372a:	d1e3      	bne.n	80036f4 <PE_Send_SRCCapabilities+0x36>
 800372c:	2010      	movs	r0, #16
 800372e:	b005      	add	sp, #20
 8003730:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08003734 <.text_33>:
 8003734:	00000396 	.word	0x00000396

08003738 <.text_34>:
 8003738:	200019ac 	.word	0x200019ac

0800373c <PE_Send_SNKCapabilities>:
 800373c:	b578      	push	{r3, r4, r5, r6, lr}
 800373e:	b08b      	sub	sp, #44	; 0x2c
 8003740:	0004      	movs	r4, r0
 8003742:	000d      	movs	r5, r1
 8003744:	ab03      	add	r3, sp, #12
 8003746:	aa04      	add	r2, sp, #16
 8003748:	2101      	movs	r1, #1
 800374a:	7b26      	ldrb	r6, [r4, #12]
 800374c:	07f0      	lsls	r0, r6, #31
 800374e:	0fc0      	lsrs	r0, r0, #31
 8003750:	68a6      	ldr	r6, [r4, #8]
 8003752:	69b6      	ldr	r6, [r6, #24]
 8003754:	47b0      	blx	r6
 8003756:	2000      	movs	r0, #0
 8003758:	9002      	str	r0, [sp, #8]
 800375a:	9501      	str	r5, [sp, #4]
 800375c:	9803      	ldr	r0, [sp, #12]
 800375e:	0880      	lsrs	r0, r0, #2
 8003760:	9000      	str	r0, [sp, #0]
 8003762:	ab04      	add	r3, sp, #16
 8003764:	2204      	movs	r2, #4
 8003766:	2100      	movs	r1, #0
 8003768:	0020      	movs	r0, r4
 800376a:	f000 f849 	bl	8003800 <PE_Send_DataMessage>
 800376e:	b00c      	add	sp, #48	; 0x30
 8003770:	bd70      	pop	{r4, r5, r6, pc}

08003772 <PE_Send_CtrlMessage>:
 8003772:	b5fc      	push	{r2, r3, r4, r5, r6, r7, lr}
 8003774:	b083      	sub	sp, #12
 8003776:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8003778:	0005      	movs	r5, r0
 800377a:	4668      	mov	r0, sp
 800377c:	7201      	strb	r1, [r0, #8]
 800377e:	0016      	movs	r6, r2
 8003780:	2401      	movs	r4, #1
 8003782:	9701      	str	r7, [sp, #4]
 8003784:	2002      	movs	r0, #2
 8003786:	9000      	str	r0, [sp, #0]
 8003788:	002b      	movs	r3, r5
 800378a:	3318      	adds	r3, #24
 800378c:	0032      	movs	r2, r6
 800378e:	4668      	mov	r0, sp
 8003790:	7a01      	ldrb	r1, [r0, #8]
 8003792:	468c      	mov	ip, r1
 8003794:	68e9      	ldr	r1, [r5, #12]
 8003796:	2001      	movs	r0, #1
 8003798:	4008      	ands	r0, r1
 800379a:	4661      	mov	r1, ip
 800379c:	f001 fc12 	bl	8004fc4 <USBPD_PRL_SendMessage>
 80037a0:	2803      	cmp	r0, #3
 80037a2:	d11a      	bne.n	80037da <PE_Send_CtrlMessage+0x68>
 80037a4:	6868      	ldr	r0, [r5, #4]
 80037a6:	6800      	ldr	r0, [r0, #0]
 80037a8:	0ac0      	lsrs	r0, r0, #11
 80037aa:	4004      	ands	r4, r0
 80037ac:	d1e8      	bne.n	8003780 <PE_Send_CtrlMessage+0xe>
 80037ae:	2000      	movs	r0, #0
 80037b0:	21d5      	movs	r1, #213	; 0xd5
 80037b2:	0089      	lsls	r1, r1, #2
 80037b4:	1869      	adds	r1, r5, r1
 80037b6:	e00c      	b.n	80037d2 <PE_Send_CtrlMessage+0x60>
 80037b8:	700a      	strb	r2, [r1, #0]
 80037ba:	e00b      	b.n	80037d4 <PE_Send_CtrlMessage+0x62>
 80037bc:	6868      	ldr	r0, [r5, #4]
 80037be:	7840      	ldrb	r0, [r0, #1]
 80037c0:	0640      	lsls	r0, r0, #25
 80037c2:	0f40      	lsrs	r0, r0, #29
 80037c4:	2804      	cmp	r0, #4
 80037c6:	d001      	beq.n	80037cc <PE_Send_CtrlMessage+0x5a>
 80037c8:	2e0d      	cmp	r6, #13
 80037ca:	d101      	bne.n	80037d0 <PE_Send_CtrlMessage+0x5e>
 80037cc:	200f      	movs	r0, #15
 80037ce:	e000      	b.n	80037d2 <PE_Send_CtrlMessage+0x60>
 80037d0:	2011      	movs	r0, #17
 80037d2:	7108      	strb	r0, [r1, #4]
 80037d4:	2010      	movs	r0, #16
 80037d6:	b005      	add	sp, #20
 80037d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80037da:	21d5      	movs	r1, #213	; 0xd5
 80037dc:	0089      	lsls	r1, r1, #2
 80037de:	1869      	adds	r1, r5, r1
 80037e0:	2200      	movs	r2, #0
 80037e2:	2805      	cmp	r0, #5
 80037e4:	d006      	beq.n	80037f4 <PE_Send_CtrlMessage+0x82>
 80037e6:	2806      	cmp	r0, #6
 80037e8:	d0e6      	beq.n	80037b8 <PE_Send_CtrlMessage+0x46>
 80037ea:	2807      	cmp	r0, #7
 80037ec:	d0e6      	beq.n	80037bc <PE_Send_CtrlMessage+0x4a>
 80037ee:	2809      	cmp	r0, #9
 80037f0:	d0f1      	beq.n	80037d6 <PE_Send_CtrlMessage+0x64>
 80037f2:	e7ef      	b.n	80037d4 <PE_Send_CtrlMessage+0x62>
 80037f4:	4668      	mov	r0, sp
 80037f6:	7c00      	ldrb	r0, [r0, #16]
 80037f8:	7108      	strb	r0, [r1, #4]
 80037fa:	700a      	strb	r2, [r1, #0]
 80037fc:	2000      	movs	r0, #0
 80037fe:	e7ea      	b.n	80037d6 <PE_Send_CtrlMessage+0x64>

08003800 <PE_Send_DataMessage>:
 8003800:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8003802:	b082      	sub	sp, #8
 8003804:	0005      	movs	r5, r0
 8003806:	2000      	movs	r0, #0
 8003808:	e00c      	b.n	8003824 <PE_Send_DataMessage+0x24>
 800380a:	2600      	movs	r6, #0
 800380c:	0081      	lsls	r1, r0, #2
 800380e:	1869      	adds	r1, r5, r1
 8003810:	198a      	adds	r2, r1, r6
 8003812:	6819      	ldr	r1, [r3, #0]
 8003814:	00f7      	lsls	r7, r6, #3
 8003816:	40f9      	lsrs	r1, r7
 8003818:	7691      	strb	r1, [r2, #26]
 800381a:	1c76      	adds	r6, r6, #1
 800381c:	2e04      	cmp	r6, #4
 800381e:	dbf5      	blt.n	800380c <PE_Send_DataMessage+0xc>
 8003820:	1d1b      	adds	r3, r3, #4
 8003822:	1c40      	adds	r0, r0, #1
 8003824:	990a      	ldr	r1, [sp, #40]	; 0x28
 8003826:	4288      	cmp	r0, r1
 8003828:	d3ef      	bcc.n	800380a <PE_Send_DataMessage+0xa>
 800382a:	2401      	movs	r4, #1
 800382c:	a80c      	add	r0, sp, #48	; 0x30
 800382e:	7800      	ldrb	r0, [r0, #0]
 8003830:	9001      	str	r0, [sp, #4]
 8003832:	980a      	ldr	r0, [sp, #40]	; 0x28
 8003834:	0080      	lsls	r0, r0, #2
 8003836:	1c80      	adds	r0, r0, #2
 8003838:	b280      	uxth	r0, r0
 800383a:	9000      	str	r0, [sp, #0]
 800383c:	002b      	movs	r3, r5
 800383e:	3318      	adds	r3, #24
 8003840:	4668      	mov	r0, sp
 8003842:	7c02      	ldrb	r2, [r0, #16]
 8003844:	7b01      	ldrb	r1, [r0, #12]
 8003846:	68ee      	ldr	r6, [r5, #12]
 8003848:	2001      	movs	r0, #1
 800384a:	4030      	ands	r0, r6
 800384c:	f001 fbba 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8003850:	2803      	cmp	r0, #3
 8003852:	d117      	bne.n	8003884 <PE_Send_DataMessage+0x84>
 8003854:	6868      	ldr	r0, [r5, #4]
 8003856:	6800      	ldr	r0, [r0, #0]
 8003858:	0ac0      	lsrs	r0, r0, #11
 800385a:	4004      	ands	r4, r0
 800385c:	d1e5      	bne.n	800382a <PE_Send_DataMessage+0x2a>
 800385e:	2010      	movs	r0, #16
 8003860:	e00e      	b.n	8003880 <PE_Send_DataMessage+0x80>
 8003862:	2a00      	cmp	r2, #0
 8003864:	d001      	beq.n	800386a <PE_Send_DataMessage+0x6a>
 8003866:	2099      	movs	r0, #153	; 0x99
 8003868:	e008      	b.n	800387c <PE_Send_DataMessage+0x7c>
 800386a:	6868      	ldr	r0, [r5, #4]
 800386c:	7840      	ldrb	r0, [r0, #1]
 800386e:	0640      	lsls	r0, r0, #25
 8003870:	0f40      	lsrs	r0, r0, #29
 8003872:	2804      	cmp	r0, #4
 8003874:	d101      	bne.n	800387a <PE_Send_DataMessage+0x7a>
 8003876:	200f      	movs	r0, #15
 8003878:	e000      	b.n	800387c <PE_Send_DataMessage+0x7c>
 800387a:	2011      	movs	r0, #17
 800387c:	7008      	strb	r0, [r1, #0]
 800387e:	2000      	movs	r0, #0
 8003880:	b005      	add	sp, #20
 8003882:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003884:	4669      	mov	r1, sp
 8003886:	7b0a      	ldrb	r2, [r1, #12]
 8003888:	21d6      	movs	r1, #214	; 0xd6
 800388a:	0089      	lsls	r1, r1, #2
 800388c:	1869      	adds	r1, r5, r1
 800388e:	2805      	cmp	r0, #5
 8003890:	d004      	beq.n	800389c <PE_Send_DataMessage+0x9c>
 8003892:	2807      	cmp	r0, #7
 8003894:	d0e5      	beq.n	8003862 <PE_Send_DataMessage+0x62>
 8003896:	2809      	cmp	r0, #9
 8003898:	d0f2      	beq.n	8003880 <PE_Send_DataMessage+0x80>
 800389a:	e7f0      	b.n	800387e <PE_Send_DataMessage+0x7e>
 800389c:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800389e:	7008      	strb	r0, [r1, #0]
 80038a0:	4e59      	ldr	r6, [pc, #356]	; (8003a08 <.text_47>)
 80038a2:	7830      	ldrb	r0, [r6, #0]
 80038a4:	0780      	lsls	r0, r0, #30
 80038a6:	d509      	bpl.n	80038bc <PE_Send_DataMessage+0xbc>
 80038a8:	2000      	movs	r0, #0
 80038aa:	9000      	str	r0, [sp, #0]
 80038ac:	2300      	movs	r3, #0
 80038ae:	2242      	movs	r2, #66	; 0x42
 80038b0:	68e8      	ldr	r0, [r5, #12]
 80038b2:	2101      	movs	r1, #1
 80038b4:	4001      	ands	r1, r0
 80038b6:	2009      	movs	r0, #9
 80038b8:	68f6      	ldr	r6, [r6, #12]
 80038ba:	47b0      	blx	r6
 80038bc:	2142      	movs	r1, #66	; 0x42
 80038be:	68e8      	ldr	r0, [r5, #12]
 80038c0:	4004      	ands	r4, r0
 80038c2:	0020      	movs	r0, r4
 80038c4:	68aa      	ldr	r2, [r5, #8]
 80038c6:	68d2      	ldr	r2, [r2, #12]
 80038c8:	4790      	blx	r2
 80038ca:	e7d8      	b.n	800387e <PE_Send_DataMessage+0x7e>

080038cc <PE_Send_HARDRESET>:
 80038cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80038ce:	0004      	movs	r4, r0
 80038d0:	20e2      	movs	r0, #226	; 0xe2
 80038d2:	0080      	lsls	r0, r0, #2
 80038d4:	5825      	ldr	r5, [r4, r0]
 80038d6:	2601      	movs	r6, #1
 80038d8:	4f4b      	ldr	r7, [pc, #300]	; (8003a08 <.text_47>)
 80038da:	7838      	ldrb	r0, [r7, #0]
 80038dc:	0780      	lsls	r0, r0, #30
 80038de:	d509      	bpl.n	80038f4 <PE_Send_HARDRESET+0x28>
 80038e0:	2000      	movs	r0, #0
 80038e2:	9000      	str	r0, [sp, #0]
 80038e4:	2300      	movs	r3, #0
 80038e6:	221e      	movs	r2, #30
 80038e8:	68e0      	ldr	r0, [r4, #12]
 80038ea:	2101      	movs	r1, #1
 80038ec:	4001      	ands	r1, r0
 80038ee:	2009      	movs	r0, #9
 80038f0:	68ff      	ldr	r7, [r7, #12]
 80038f2:	47b8      	blx	r7
 80038f4:	211e      	movs	r1, #30
 80038f6:	68e2      	ldr	r2, [r4, #12]
 80038f8:	2001      	movs	r0, #1
 80038fa:	4010      	ands	r0, r2
 80038fc:	68a2      	ldr	r2, [r4, #8]
 80038fe:	68d2      	ldr	r2, [r2, #12]
 8003900:	4790      	blx	r2
 8003902:	68e1      	ldr	r1, [r4, #12]
 8003904:	2001      	movs	r0, #1
 8003906:	4008      	ands	r0, r1
 8003908:	f001 fd3f 	bl	800538a <USBPD_PRL_ResetRequestReset>
 800390c:	20e2      	movs	r0, #226	; 0xe2
 800390e:	0080      	lsls	r0, r0, #2
 8003910:	1820      	adds	r0, r4, r0
 8003912:	9000      	str	r0, [sp, #0]
 8003914:	4f3b      	ldr	r7, [pc, #236]	; (8003a04 <.text_46>)
 8003916:	2105      	movs	r1, #5
 8003918:	68e2      	ldr	r2, [r4, #12]
 800391a:	2001      	movs	r0, #1
 800391c:	4010      	ands	r0, r2
 800391e:	f001 fd3f 	bl	80053a0 <USBPD_PRL_ResetRequestProcess>
 8003922:	2803      	cmp	r0, #3
 8003924:	d10a      	bne.n	800393c <PE_Send_HARDRESET+0x70>
 8003926:	9800      	ldr	r0, [sp, #0]
 8003928:	6800      	ldr	r0, [r0, #0]
 800392a:	1b40      	subs	r0, r0, r5
 800392c:	42b8      	cmp	r0, r7
 800392e:	d204      	bcs.n	800393a <PE_Send_HARDRESET+0x6e>
 8003930:	6860      	ldr	r0, [r4, #4]
 8003932:	6800      	ldr	r0, [r0, #0]
 8003934:	0ac0      	lsrs	r0, r0, #11
 8003936:	4030      	ands	r0, r6
 8003938:	d1ed      	bne.n	8003916 <PE_Send_HARDRESET+0x4a>
 800393a:	2004      	movs	r0, #4
 800393c:	bdf2      	pop	{r1, r4, r5, r6, r7, pc}

0800393e <PE_PerformSoftReset>:
 800393e:	b538      	push	{r3, r4, r5, lr}
 8003940:	0004      	movs	r4, r0
 8003942:	2500      	movs	r5, #0
 8003944:	2001      	movs	r0, #1
 8003946:	6861      	ldr	r1, [r4, #4]
 8003948:	7809      	ldrb	r1, [r1, #0]
 800394a:	0889      	lsrs	r1, r1, #2
 800394c:	4201      	tst	r1, r0
 800394e:	d006      	beq.n	800395e <PE_PerformSoftReset+0x20>
 8003950:	7565      	strb	r5, [r4, #21]
 8003952:	2101      	movs	r1, #1
 8003954:	68e2      	ldr	r2, [r4, #12]
 8003956:	4010      	ands	r0, r2
 8003958:	f001 fae3 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 800395c:	bd31      	pop	{r0, r4, r5, pc}
 800395e:	2100      	movs	r1, #0
 8003960:	68e2      	ldr	r2, [r4, #12]
 8003962:	4010      	ands	r0, r2
 8003964:	f001 fadd 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 8003968:	4828      	ldr	r0, [pc, #160]	; (8003a0c <.text_48>)
 800396a:	5225      	strh	r5, [r4, r0]
 800396c:	7525      	strb	r5, [r4, #20]
 800396e:	bd31      	pop	{r0, r4, r5, pc}

08003970 <.text_40>:
 8003970:	00000242 	.word	0x00000242

08003974 <PE_Get_DataRole>:
 8003974:	4924      	ldr	r1, [pc, #144]	; (8003a08 <.text_47>)
 8003976:	0080      	lsls	r0, r0, #2
 8003978:	1808      	adds	r0, r1, r0
 800397a:	6840      	ldr	r0, [r0, #4]
 800397c:	6840      	ldr	r0, [r0, #4]
 800397e:	7800      	ldrb	r0, [r0, #0]
 8003980:	0701      	lsls	r1, r0, #28
 8003982:	0fc8      	lsrs	r0, r1, #31
 8003984:	4770      	bx	lr

08003986 <PE_Get_SpecRevision>:
 8003986:	4920      	ldr	r1, [pc, #128]	; (8003a08 <.text_47>)
 8003988:	0080      	lsls	r0, r0, #2
 800398a:	1808      	adds	r0, r1, r0
 800398c:	6840      	ldr	r0, [r0, #4]
 800398e:	6840      	ldr	r0, [r0, #4]
 8003990:	7800      	ldrb	r0, [r0, #0]
 8003992:	0780      	lsls	r0, r0, #30
 8003994:	0f80      	lsrs	r0, r0, #30
 8003996:	4770      	bx	lr

08003998 <.text_43>:
 8003998:	00000393 	.word	0x00000393

0800399c <PE_ChangePowerRole>:
 800399c:	b538      	push	{r3, r4, r5, lr}
 800399e:	6842      	ldr	r2, [r0, #4]
 80039a0:	7813      	ldrb	r3, [r2, #0]
 80039a2:	24fb      	movs	r4, #251	; 0xfb
 80039a4:	401c      	ands	r4, r3
 80039a6:	008b      	lsls	r3, r1, #2
 80039a8:	2504      	movs	r5, #4
 80039aa:	402b      	ands	r3, r5
 80039ac:	4323      	orrs	r3, r4
 80039ae:	7013      	strb	r3, [r2, #0]
 80039b0:	7b02      	ldrb	r2, [r0, #12]
 80039b2:	07d0      	lsls	r0, r2, #31
 80039b4:	0fc0      	lsrs	r0, r0, #31
 80039b6:	f001 fab4 	bl	8004f22 <USBPD_PRL_SetHeaderPowerRole>
 80039ba:	bd31      	pop	{r0, r4, r5, pc}

080039bc <PE_Check_RxEvent>:
 80039bc:	b081      	sub	sp, #4
 80039be:	0001      	movs	r1, r0
 80039c0:	2014      	movs	r0, #20
 80039c2:	4a13      	ldr	r2, [pc, #76]	; (8003a10 <.text_49>)
 80039c4:	1889      	adds	r1, r1, r2
 80039c6:	780a      	ldrb	r2, [r1, #0]
 80039c8:	2a00      	cmp	r2, #0
 80039ca:	d019      	beq.n	8003a00 <PE_Check_RxEvent+0x44>
 80039cc:	780a      	ldrb	r2, [r1, #0]
 80039ce:	0692      	lsls	r2, r2, #26
 80039d0:	d401      	bmi.n	80039d6 <PE_Check_RxEvent+0x1a>
 80039d2:	2003      	movs	r0, #3
 80039d4:	e014      	b.n	8003a00 <PE_Check_RxEvent+0x44>
 80039d6:	2200      	movs	r2, #0
 80039d8:	780b      	ldrb	r3, [r1, #0]
 80039da:	06db      	lsls	r3, r3, #27
 80039dc:	0edb      	lsrs	r3, r3, #27
 80039de:	2b01      	cmp	r3, #1
 80039e0:	d004      	beq.n	80039ec <PE_Check_RxEvent+0x30>
 80039e2:	2b02      	cmp	r3, #2
 80039e4:	d005      	beq.n	80039f2 <PE_Check_RxEvent+0x36>
 80039e6:	2b04      	cmp	r3, #4
 80039e8:	d006      	beq.n	80039f8 <PE_Check_RxEvent+0x3c>
 80039ea:	e008      	b.n	80039fe <PE_Check_RxEvent+0x42>
 80039ec:	2011      	movs	r0, #17
 80039ee:	710a      	strb	r2, [r1, #4]
 80039f0:	e005      	b.n	80039fe <PE_Check_RxEvent+0x42>
 80039f2:	2012      	movs	r0, #18
 80039f4:	2301      	movs	r3, #1
 80039f6:	e001      	b.n	80039fc <PE_Check_RxEvent+0x40>
 80039f8:	2013      	movs	r0, #19
 80039fa:	2302      	movs	r3, #2
 80039fc:	710b      	strb	r3, [r1, #4]
 80039fe:	700a      	strb	r2, [r1, #0]
 8003a00:	b001      	add	sp, #4
 8003a02:	4770      	bx	lr

08003a04 <.text_46>:
 8003a04:	00001771 	.word	0x00001771

08003a08 <.text_47>:
 8003a08:	200019a8 	.word	0x200019a8

08003a0c <.text_48>:
 8003a0c:	0000036e 	.word	0x0000036e

08003a10 <.text_49>:
 8003a10:	00000356 	.word	0x00000356

08003a14 <PE_Check_AMSConflict>:
 8003a14:	b081      	sub	sp, #4
 8003a16:	21d6      	movs	r1, #214	; 0xd6
 8003a18:	0089      	lsls	r1, r1, #2
 8003a1a:	1841      	adds	r1, r0, r1
 8003a1c:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
 8003a1e:	0bd2      	lsrs	r2, r2, #15
 8003a20:	d10a      	bne.n	8003a38 <PE_Check_AMSConflict+0x24>
 8003a22:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
 8003a24:	0452      	lsls	r2, r2, #17
 8003a26:	0f52      	lsrs	r2, r2, #29
 8003a28:	d106      	bne.n	8003a38 <PE_Check_AMSConflict+0x24>
 8003a2a:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
 8003a2c:	06d2      	lsls	r2, r2, #27
 8003a2e:	0ed2      	lsrs	r2, r2, #27
 8003a30:	2a0d      	cmp	r2, #13
 8003a32:	d101      	bne.n	8003a38 <PE_Check_AMSConflict+0x24>
 8003a34:	2010      	movs	r0, #16
 8003a36:	e01a      	b.n	8003a6e <PE_Check_AMSConflict+0x5a>
 8003a38:	2216      	movs	r2, #22
 8003a3a:	5e80      	ldrsh	r0, [r0, r2]
 8003a3c:	2203      	movs	r2, #3
 8003a3e:	0003      	movs	r3, r0
 8003a40:	d00f      	beq.n	8003a62 <PE_Check_AMSConflict+0x4e>
 8003a42:	1e43      	subs	r3, r0, #1
 8003a44:	2b01      	cmp	r3, #1
 8003a46:	d90f      	bls.n	8003a68 <PE_Check_AMSConflict+0x54>
 8003a48:	1e9b      	subs	r3, r3, #2
 8003a4a:	d00f      	beq.n	8003a6c <PE_Check_AMSConflict+0x58>
 8003a4c:	1e5b      	subs	r3, r3, #1
 8003a4e:	d00f      	beq.n	8003a70 <PE_Check_AMSConflict+0x5c>
 8003a50:	1e5b      	subs	r3, r3, #1
 8003a52:	2b0b      	cmp	r3, #11
 8003a54:	d908      	bls.n	8003a68 <PE_Check_AMSConflict+0x54>
 8003a56:	3b0c      	subs	r3, #12
 8003a58:	d00f      	beq.n	8003a7a <PE_Check_AMSConflict+0x66>
 8003a5a:	3bef      	subs	r3, #239	; 0xef
 8003a5c:	2b0e      	cmp	r3, #14
 8003a5e:	d909      	bls.n	8003a74 <PE_Check_AMSConflict+0x60>
 8003a60:	e00c      	b.n	8003a7c <PE_Check_AMSConflict+0x68>
 8003a62:	2004      	movs	r0, #4
 8003a64:	7008      	strb	r0, [r1, #0]
 8003a66:	e009      	b.n	8003a7c <PE_Check_AMSConflict+0x68>
 8003a68:	2011      	movs	r0, #17
 8003a6a:	e000      	b.n	8003a6e <PE_Check_AMSConflict+0x5a>
 8003a6c:	200f      	movs	r0, #15
 8003a6e:	7008      	strb	r0, [r1, #0]
 8003a70:	2015      	movs	r0, #21
 8003a72:	e004      	b.n	8003a7e <PE_Check_AMSConflict+0x6a>
 8003a74:	80c8      	strh	r0, [r1, #6]
 8003a76:	7808      	ldrb	r0, [r1, #0]
 8003a78:	7108      	strb	r0, [r1, #4]
 8003a7a:	700a      	strb	r2, [r1, #0]
 8003a7c:	2000      	movs	r0, #0
 8003a7e:	b001      	add	sp, #4
 8003a80:	4770      	bx	lr
	...

08003a84 <PE_Check_ControlMessage>:
 8003a84:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 8003a86:	0004      	movs	r4, r0
 8003a88:	48ca      	ldr	r0, [pc, #808]	; (8003db4 <.text_52>)
 8003a8a:	68c1      	ldr	r1, [r0, #12]
 8003a8c:	9101      	str	r1, [sp, #4]
 8003a8e:	7800      	ldrb	r0, [r0, #0]
 8003a90:	2102      	movs	r1, #2
 8003a92:	4008      	ands	r0, r1
 8003a94:	21d6      	movs	r1, #214	; 0xd6
 8003a96:	0089      	lsls	r1, r1, #2
 8003a98:	1866      	adds	r6, r4, r1
 8003a9a:	2103      	movs	r1, #3
 8003a9c:	2501      	movs	r5, #1
 8003a9e:	222a      	movs	r2, #42	; 0x2a
 8003aa0:	8db3      	ldrh	r3, [r6, #44]	; 0x2c
 8003aa2:	06db      	lsls	r3, r3, #27
 8003aa4:	0edb      	lsrs	r3, r3, #27
 8003aa6:	1e5b      	subs	r3, r3, #1
 8003aa8:	2b14      	cmp	r3, #20
 8003aaa:	d900      	bls.n	8003aae <PE_Check_ControlMessage+0x2a>
 8003aac:	e17b      	b.n	8003da6 <PE_Check_ControlMessage+0x322>
 8003aae:	a702      	add	r7, pc, #8	; (adr r7, 8003ab8 <PE_Check_ControlMessage+0x34>)
 8003ab0:	005b      	lsls	r3, r3, #1
 8003ab2:	5aff      	ldrh	r7, [r7, r3]
 8003ab4:	44bf      	add	pc, r7
 8003ab6:	bf00      	nop
 8003ab8:	002a02fa 	.word	0x002a02fa
 8003abc:	02e802e8 	.word	0x02e802e8
 8003ac0:	02e80090 	.word	0x02e80090
 8003ac4:	01d400ac 	.word	0x01d400ac
 8003ac8:	016e01b8 	.word	0x016e01b8
 8003acc:	02e801a8 	.word	0x02e801a8
 8003ad0:	02ee0064 	.word	0x02ee0064
 8003ad4:	02fa02ee 	.word	0x02fa02ee
 8003ad8:	025e021e 	.word	0x025e021e
 8003adc:	028c02e2 	.word	0x028c02e2
 8003ae0:	02d4      	.short	0x02d4
 8003ae2:	6861      	ldr	r1, [r4, #4]
 8003ae4:	7809      	ldrb	r1, [r1, #0]
 8003ae6:	0889      	lsrs	r1, r1, #2
 8003ae8:	4229      	tst	r1, r5
 8003aea:	d000      	beq.n	8003aee <PE_Check_ControlMessage+0x6a>
 8003aec:	e161      	b.n	8003db2 <PE_Check_ControlMessage+0x32e>
 8003aee:	2102      	movs	r1, #2
 8003af0:	82e1      	strh	r1, [r4, #22]
 8003af2:	2800      	cmp	r0, #0
 8003af4:	d009      	beq.n	8003b0a <PE_Check_ControlMessage+0x86>
 8003af6:	2000      	movs	r0, #0
 8003af8:	9000      	str	r0, [sp, #0]
 8003afa:	2300      	movs	r3, #0
 8003afc:	2229      	movs	r2, #41	; 0x29
 8003afe:	68e0      	ldr	r0, [r4, #12]
 8003b00:	2101      	movs	r1, #1
 8003b02:	4001      	ands	r1, r0
 8003b04:	2009      	movs	r0, #9
 8003b06:	9f01      	ldr	r7, [sp, #4]
 8003b08:	47b8      	blx	r7
 8003b0a:	2129      	movs	r1, #41	; 0x29
 8003b0c:	68e0      	ldr	r0, [r4, #12]
 8003b0e:	4005      	ands	r5, r0
 8003b10:	0028      	movs	r0, r5
 8003b12:	68a2      	ldr	r2, [r4, #8]
 8003b14:	68d2      	ldr	r2, [r2, #12]
 8003b16:	4790      	blx	r2
 8003b18:	2098      	movs	r0, #152	; 0x98
 8003b1a:	e142      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003b1c:	82e1      	strh	r1, [r4, #22]
 8003b1e:	2800      	cmp	r0, #0
 8003b20:	d009      	beq.n	8003b36 <PE_Check_ControlMessage+0xb2>
 8003b22:	2000      	movs	r0, #0
 8003b24:	9000      	str	r0, [sp, #0]
 8003b26:	2300      	movs	r3, #0
 8003b28:	2230      	movs	r2, #48	; 0x30
 8003b2a:	68e0      	ldr	r0, [r4, #12]
 8003b2c:	2101      	movs	r1, #1
 8003b2e:	4001      	ands	r1, r0
 8003b30:	2009      	movs	r0, #9
 8003b32:	9f01      	ldr	r7, [sp, #4]
 8003b34:	47b8      	blx	r7
 8003b36:	2130      	movs	r1, #48	; 0x30
 8003b38:	68e0      	ldr	r0, [r4, #12]
 8003b3a:	4005      	ands	r5, r0
 8003b3c:	0028      	movs	r0, r5
 8003b3e:	68a2      	ldr	r2, [r4, #8]
 8003b40:	68d2      	ldr	r2, [r2, #12]
 8003b42:	4790      	blx	r2
 8003b44:	2010      	movs	r0, #16
 8003b46:	e12c      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003b48:	2800      	cmp	r0, #0
 8003b4a:	d009      	beq.n	8003b60 <PE_Check_ControlMessage+0xdc>
 8003b4c:	2000      	movs	r0, #0
 8003b4e:	9000      	str	r0, [sp, #0]
 8003b50:	2300      	movs	r3, #0
 8003b52:	2231      	movs	r2, #49	; 0x31
 8003b54:	68e0      	ldr	r0, [r4, #12]
 8003b56:	2101      	movs	r1, #1
 8003b58:	4001      	ands	r1, r0
 8003b5a:	2009      	movs	r0, #9
 8003b5c:	9e01      	ldr	r6, [sp, #4]
 8003b5e:	47b0      	blx	r6
 8003b60:	2131      	movs	r1, #49	; 0x31
 8003b62:	e10c      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003b64:	2306      	movs	r3, #6
 8003b66:	82e3      	strh	r3, [r4, #22]
 8003b68:	466b      	mov	r3, sp
 8003b6a:	6867      	ldr	r7, [r4, #4]
 8003b6c:	783f      	ldrb	r7, [r7, #0]
 8003b6e:	701f      	strb	r7, [r3, #0]
 8003b70:	463b      	mov	r3, r7
 8003b72:	089f      	lsrs	r7, r3, #2
 8003b74:	422f      	tst	r7, r5
 8003b76:	d04d      	beq.n	8003c14 <PE_Check_ControlMessage+0x190>
 8003b78:	2800      	cmp	r0, #0
 8003b7a:	d009      	beq.n	8003b90 <PE_Check_ControlMessage+0x10c>
 8003b7c:	2000      	movs	r0, #0
 8003b7e:	9000      	str	r0, [sp, #0]
 8003b80:	2300      	movs	r3, #0
 8003b82:	220c      	movs	r2, #12
 8003b84:	68e0      	ldr	r0, [r4, #12]
 8003b86:	2101      	movs	r1, #1
 8003b88:	4001      	ands	r1, r0
 8003b8a:	2009      	movs	r0, #9
 8003b8c:	9f01      	ldr	r7, [sp, #4]
 8003b8e:	47b8      	blx	r7
 8003b90:	210c      	movs	r1, #12
 8003b92:	68e2      	ldr	r2, [r4, #12]
 8003b94:	2001      	movs	r0, #1
 8003b96:	4010      	ands	r0, r2
 8003b98:	68a2      	ldr	r2, [r4, #8]
 8003b9a:	68d2      	ldr	r2, [r2, #12]
 8003b9c:	4790      	blx	r2
 8003b9e:	2100      	movs	r1, #0
 8003ba0:	0020      	movs	r0, r4
 8003ba2:	f7ff fd8c 	bl	80036be <PE_Send_SRCCapabilities>
 8003ba6:	2805      	cmp	r0, #5
 8003ba8:	d002      	beq.n	8003bb0 <PE_Check_ControlMessage+0x12c>
 8003baa:	2000      	movs	r0, #0
 8003bac:	82e0      	strh	r0, [r4, #22]
 8003bae:	e0f7      	b.n	8003da0 <PE_Check_ControlMessage+0x31c>
 8003bb0:	6860      	ldr	r0, [r4, #4]
 8003bb2:	7841      	ldrb	r1, [r0, #1]
 8003bb4:	228f      	movs	r2, #143	; 0x8f
 8003bb6:	400a      	ands	r2, r1
 8003bb8:	2140      	movs	r1, #64	; 0x40
 8003bba:	4311      	orrs	r1, r2
 8003bbc:	7041      	strb	r1, [r0, #1]
 8003bbe:	487d      	ldr	r0, [pc, #500]	; (8003db4 <.text_52>)
 8003bc0:	7800      	ldrb	r0, [r0, #0]
 8003bc2:	0780      	lsls	r0, r0, #30
 8003bc4:	d50a      	bpl.n	8003bdc <PE_Check_ControlMessage+0x158>
 8003bc6:	2000      	movs	r0, #0
 8003bc8:	9000      	str	r0, [sp, #0]
 8003bca:	2300      	movs	r3, #0
 8003bcc:	2256      	movs	r2, #86	; 0x56
 8003bce:	68e0      	ldr	r0, [r4, #12]
 8003bd0:	2101      	movs	r1, #1
 8003bd2:	4001      	ands	r1, r0
 8003bd4:	2009      	movs	r0, #9
 8003bd6:	4f77      	ldr	r7, [pc, #476]	; (8003db4 <.text_52>)
 8003bd8:	68ff      	ldr	r7, [r7, #12]
 8003bda:	47b8      	blx	r7
 8003bdc:	2156      	movs	r1, #86	; 0x56
 8003bde:	68e2      	ldr	r2, [r4, #12]
 8003be0:	2001      	movs	r0, #1
 8003be2:	4010      	ands	r0, r2
 8003be4:	68a2      	ldr	r2, [r4, #8]
 8003be6:	68d2      	ldr	r2, [r2, #12]
 8003be8:	4790      	blx	r2
 8003bea:	82e5      	strh	r5, [r4, #22]
 8003bec:	4872      	ldr	r0, [pc, #456]	; (8003db8 <.text_53>)
 8003bee:	82b0      	strh	r0, [r6, #20]
 8003bf0:	2016      	movs	r0, #22
 8003bf2:	7030      	strb	r0, [r6, #0]
 8003bf4:	4e6f      	ldr	r6, [pc, #444]	; (8003db4 <.text_52>)
 8003bf6:	7830      	ldrb	r0, [r6, #0]
 8003bf8:	0780      	lsls	r0, r0, #30
 8003bfa:	d509      	bpl.n	8003c10 <PE_Check_ControlMessage+0x18c>
 8003bfc:	2000      	movs	r0, #0
 8003bfe:	9000      	str	r0, [sp, #0]
 8003c00:	2300      	movs	r3, #0
 8003c02:	220f      	movs	r2, #15
 8003c04:	68e0      	ldr	r0, [r4, #12]
 8003c06:	2101      	movs	r1, #1
 8003c08:	4001      	ands	r1, r0
 8003c0a:	2009      	movs	r0, #9
 8003c0c:	68f6      	ldr	r6, [r6, #12]
 8003c0e:	47b0      	blx	r6
 8003c10:	210f      	movs	r1, #15
 8003c12:	e0b4      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003c14:	6820      	ldr	r0, [r4, #0]
 8003c16:	6840      	ldr	r0, [r0, #4]
 8003c18:	08c0      	lsrs	r0, r0, #3
 8003c1a:	4028      	ands	r0, r5
 8003c1c:	d001      	beq.n	8003c22 <PE_Check_ControlMessage+0x19e>
 8003c1e:	204c      	movs	r0, #76	; 0x4c
 8003c20:	e0bf      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003c22:	4019      	ands	r1, r3
 8003c24:	e02b      	b.n	8003c7e <PE_Check_ControlMessage+0x1fa>
 8003c26:	6823      	ldr	r3, [r4, #0]
 8003c28:	685b      	ldr	r3, [r3, #4]
 8003c2a:	08db      	lsrs	r3, r3, #3
 8003c2c:	402b      	ands	r3, r5
 8003c2e:	d023      	beq.n	8003c78 <PE_Check_ControlMessage+0x1f4>
 8003c30:	2122      	movs	r1, #34	; 0x22
 8003c32:	7031      	strb	r1, [r6, #0]
 8003c34:	2800      	cmp	r0, #0
 8003c36:	d009      	beq.n	8003c4c <PE_Check_ControlMessage+0x1c8>
 8003c38:	2000      	movs	r0, #0
 8003c3a:	9000      	str	r0, [sp, #0]
 8003c3c:	2300      	movs	r3, #0
 8003c3e:	223a      	movs	r2, #58	; 0x3a
 8003c40:	68e0      	ldr	r0, [r4, #12]
 8003c42:	2101      	movs	r1, #1
 8003c44:	4001      	ands	r1, r0
 8003c46:	2009      	movs	r0, #9
 8003c48:	9e01      	ldr	r6, [sp, #4]
 8003c4a:	47b0      	blx	r6
 8003c4c:	213a      	movs	r1, #58	; 0x3a
 8003c4e:	68e0      	ldr	r0, [r4, #12]
 8003c50:	4005      	ands	r5, r0
 8003c52:	0028      	movs	r0, r5
 8003c54:	68a2      	ldr	r2, [r4, #8]
 8003c56:	68d2      	ldr	r2, [r2, #12]
 8003c58:	4790      	blx	r2
 8003c5a:	2008      	movs	r0, #8
 8003c5c:	82e0      	strh	r0, [r4, #22]
 8003c5e:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003c60:	68a0      	ldr	r0, [r4, #8]
 8003c62:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8003c64:	2800      	cmp	r0, #0
 8003c66:	d007      	beq.n	8003c78 <PE_Check_ControlMessage+0x1f4>
 8003c68:	2010      	movs	r0, #16
 8003c6a:	82e0      	strh	r0, [r4, #22]
 8003c6c:	209d      	movs	r0, #157	; 0x9d
 8003c6e:	e098      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003c70:	68a0      	ldr	r0, [r4, #8]
 8003c72:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 8003c74:	2800      	cmp	r0, #0
 8003c76:	d105      	bne.n	8003c84 <PE_Check_ControlMessage+0x200>
 8003c78:	6860      	ldr	r0, [r4, #4]
 8003c7a:	7800      	ldrb	r0, [r0, #0]
 8003c7c:	4001      	ands	r1, r0
 8003c7e:	2902      	cmp	r1, #2
 8003c80:	d127      	bne.n	8003cd2 <PE_Check_ControlMessage+0x24e>
 8003c82:	e095      	b.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003c84:	200f      	movs	r0, #15
 8003c86:	82e0      	strh	r0, [r4, #22]
 8003c88:	2093      	movs	r0, #147	; 0x93
 8003c8a:	e08a      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003c8c:	2307      	movs	r3, #7
 8003c8e:	82e3      	strh	r3, [r4, #22]
 8003c90:	466b      	mov	r3, sp
 8003c92:	6867      	ldr	r7, [r4, #4]
 8003c94:	783f      	ldrb	r7, [r7, #0]
 8003c96:	701f      	strb	r7, [r3, #0]
 8003c98:	08bf      	lsrs	r7, r7, #2
 8003c9a:	422f      	tst	r7, r5
 8003c9c:	d004      	beq.n	8003ca8 <PE_Check_ControlMessage+0x224>
 8003c9e:	6823      	ldr	r3, [r4, #0]
 8003ca0:	685b      	ldr	r3, [r3, #4]
 8003ca2:	08db      	lsrs	r3, r3, #3
 8003ca4:	402b      	ands	r3, r5
 8003ca6:	d00f      	beq.n	8003cc8 <PE_Check_ControlMessage+0x244>
 8003ca8:	211d      	movs	r1, #29
 8003caa:	7031      	strb	r1, [r6, #0]
 8003cac:	2800      	cmp	r0, #0
 8003cae:	d009      	beq.n	8003cc4 <PE_Check_ControlMessage+0x240>
 8003cb0:	2000      	movs	r0, #0
 8003cb2:	9000      	str	r0, [sp, #0]
 8003cb4:	2300      	movs	r3, #0
 8003cb6:	2206      	movs	r2, #6
 8003cb8:	68e0      	ldr	r0, [r4, #12]
 8003cba:	2101      	movs	r1, #1
 8003cbc:	4001      	ands	r1, r0
 8003cbe:	2009      	movs	r0, #9
 8003cc0:	9e01      	ldr	r6, [sp, #4]
 8003cc2:	47b0      	blx	r6
 8003cc4:	2106      	movs	r1, #6
 8003cc6:	e05a      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003cc8:	4668      	mov	r0, sp
 8003cca:	7800      	ldrb	r0, [r0, #0]
 8003ccc:	4001      	ands	r1, r0
 8003cce:	2902      	cmp	r1, #2
 8003cd0:	d06e      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003cd2:	7032      	strb	r2, [r6, #0]
 8003cd4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003cd6:	6821      	ldr	r1, [r4, #0]
 8003cd8:	88ca      	ldrh	r2, [r1, #6]
 8003cda:	08d2      	lsrs	r2, r2, #3
 8003cdc:	422a      	tst	r2, r5
 8003cde:	d067      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003ce0:	6862      	ldr	r2, [r4, #4]
 8003ce2:	7812      	ldrb	r2, [r2, #0]
 8003ce4:	0892      	lsrs	r2, r2, #2
 8003ce6:	422a      	tst	r2, r5
 8003ce8:	d103      	bne.n	8003cf2 <PE_Check_ControlMessage+0x26e>
 8003cea:	6849      	ldr	r1, [r1, #4]
 8003cec:	08c9      	lsrs	r1, r1, #3
 8003cee:	4029      	ands	r1, r5
 8003cf0:	d05e      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003cf2:	210a      	movs	r1, #10
 8003cf4:	82e1      	strh	r1, [r4, #22]
 8003cf6:	2163      	movs	r1, #99	; 0x63
 8003cf8:	7031      	strb	r1, [r6, #0]
 8003cfa:	2800      	cmp	r0, #0
 8003cfc:	d009      	beq.n	8003d12 <PE_Check_ControlMessage+0x28e>
 8003cfe:	2000      	movs	r0, #0
 8003d00:	9000      	str	r0, [sp, #0]
 8003d02:	2300      	movs	r3, #0
 8003d04:	2243      	movs	r2, #67	; 0x43
 8003d06:	68e0      	ldr	r0, [r4, #12]
 8003d08:	2101      	movs	r1, #1
 8003d0a:	4001      	ands	r1, r0
 8003d0c:	2009      	movs	r0, #9
 8003d0e:	9e01      	ldr	r6, [sp, #4]
 8003d10:	47b0      	blx	r6
 8003d12:	2143      	movs	r1, #67	; 0x43
 8003d14:	e033      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003d16:	6821      	ldr	r1, [r4, #0]
 8003d18:	88c9      	ldrh	r1, [r1, #6]
 8003d1a:	0949      	lsrs	r1, r1, #5
 8003d1c:	4229      	tst	r1, r5
 8003d1e:	d047      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003d20:	210b      	movs	r1, #11
 8003d22:	82e1      	strh	r1, [r4, #22]
 8003d24:	2130      	movs	r1, #48	; 0x30
 8003d26:	7031      	strb	r1, [r6, #0]
 8003d28:	2800      	cmp	r0, #0
 8003d2a:	d009      	beq.n	8003d40 <PE_Check_ControlMessage+0x2bc>
 8003d2c:	2000      	movs	r0, #0
 8003d2e:	9000      	str	r0, [sp, #0]
 8003d30:	2300      	movs	r3, #0
 8003d32:	224a      	movs	r2, #74	; 0x4a
 8003d34:	68e0      	ldr	r0, [r4, #12]
 8003d36:	2101      	movs	r1, #1
 8003d38:	4001      	ands	r1, r0
 8003d3a:	2009      	movs	r0, #9
 8003d3c:	9e01      	ldr	r6, [sp, #4]
 8003d3e:	47b0      	blx	r6
 8003d40:	214a      	movs	r1, #74	; 0x4a
 8003d42:	e01c      	b.n	8003d7e <PE_Check_ControlMessage+0x2fa>
 8003d44:	6821      	ldr	r1, [r4, #0]
 8003d46:	88c9      	ldrh	r1, [r1, #6]
 8003d48:	0889      	lsrs	r1, r1, #2
 8003d4a:	4229      	tst	r1, r5
 8003d4c:	d030      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003d4e:	210b      	movs	r1, #11
 8003d50:	82e1      	strh	r1, [r4, #22]
 8003d52:	6861      	ldr	r1, [r4, #4]
 8003d54:	7809      	ldrb	r1, [r1, #0]
 8003d56:	0889      	lsrs	r1, r1, #2
 8003d58:	4229      	tst	r1, r5
 8003d5a:	d001      	beq.n	8003d60 <PE_Check_ControlMessage+0x2dc>
 8003d5c:	212d      	movs	r1, #45	; 0x2d
 8003d5e:	e000      	b.n	8003d62 <PE_Check_ControlMessage+0x2de>
 8003d60:	2111      	movs	r1, #17
 8003d62:	7031      	strb	r1, [r6, #0]
 8003d64:	2800      	cmp	r0, #0
 8003d66:	d009      	beq.n	8003d7c <PE_Check_ControlMessage+0x2f8>
 8003d68:	2000      	movs	r0, #0
 8003d6a:	9000      	str	r0, [sp, #0]
 8003d6c:	2300      	movs	r3, #0
 8003d6e:	2246      	movs	r2, #70	; 0x46
 8003d70:	68e0      	ldr	r0, [r4, #12]
 8003d72:	2101      	movs	r1, #1
 8003d74:	4001      	ands	r1, r0
 8003d76:	2009      	movs	r0, #9
 8003d78:	9e01      	ldr	r6, [sp, #4]
 8003d7a:	47b0      	blx	r6
 8003d7c:	2146      	movs	r1, #70	; 0x46
 8003d7e:	68e0      	ldr	r0, [r4, #12]
 8003d80:	4005      	ands	r5, r0
 8003d82:	0028      	movs	r0, r5
 8003d84:	68a2      	ldr	r2, [r4, #8]
 8003d86:	68d2      	ldr	r2, [r2, #12]
 8003d88:	4790      	blx	r2
 8003d8a:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003d8c:	6820      	ldr	r0, [r4, #0]
 8003d8e:	88c0      	ldrh	r0, [r0, #6]
 8003d90:	0a00      	lsrs	r0, r0, #8
 8003d92:	4228      	tst	r0, r5
 8003d94:	d00c      	beq.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003d96:	202f      	movs	r0, #47	; 0x2f
 8003d98:	e003      	b.n	8003da2 <PE_Check_ControlMessage+0x31e>
 8003d9a:	2009      	movs	r0, #9
 8003d9c:	82e0      	strh	r0, [r4, #22]
 8003d9e:	e007      	b.n	8003db0 <PE_Check_ControlMessage+0x32c>
 8003da0:	2011      	movs	r0, #17
 8003da2:	7030      	strb	r0, [r6, #0]
 8003da4:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003da6:	6860      	ldr	r0, [r4, #4]
 8003da8:	7800      	ldrb	r0, [r0, #0]
 8003daa:	4001      	ands	r1, r0
 8003dac:	2902      	cmp	r1, #2
 8003dae:	d100      	bne.n	8003db2 <PE_Check_ControlMessage+0x32e>
 8003db0:	7035      	strb	r5, [r6, #0]
 8003db2:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

08003db4 <.text_52>:
 8003db4:	200019a8 	.word	0x200019a8

08003db8 <.text_53>:
 8003db8:	0000801a 	.word	0x0000801a

08003dbc <PE_Check_DataMessage>:
 8003dbc:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 8003dbe:	0004      	movs	r4, r0
 8003dc0:	209e      	movs	r0, #158	; 0x9e
 8003dc2:	0040      	lsls	r0, r0, #1
 8003dc4:	1827      	adds	r7, r4, r0
 8003dc6:	20d6      	movs	r0, #214	; 0xd6
 8003dc8:	0080      	lsls	r0, r0, #2
 8003dca:	1826      	adds	r6, r4, r0
 8003dcc:	2501      	movs	r5, #1
 8003dce:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 8003dd0:	06c0      	lsls	r0, r0, #27
 8003dd2:	0ec0      	lsrs	r0, r0, #27
 8003dd4:	2801      	cmp	r0, #1
 8003dd6:	d02f      	beq.n	8003e38 <PE_Check_DataMessage+0x7c>
 8003dd8:	2802      	cmp	r0, #2
 8003dda:	d009      	beq.n	8003df0 <PE_Check_DataMessage+0x34>
 8003ddc:	2803      	cmp	r0, #3
 8003dde:	d047      	beq.n	8003e70 <PE_Check_DataMessage+0xb4>
 8003de0:	2806      	cmp	r0, #6
 8003de2:	d07d      	beq.n	8003ee0 <PE_Check_DataMessage+0x124>
 8003de4:	2807      	cmp	r0, #7
 8003de6:	d100      	bne.n	8003dea <PE_Check_DataMessage+0x2e>
 8003de8:	e08a      	b.n	8003f00 <PE_Check_DataMessage+0x144>
 8003dea:	280f      	cmp	r0, #15
 8003dec:	d071      	beq.n	8003ed2 <PE_Check_DataMessage+0x116>
 8003dee:	e090      	b.n	8003f12 <PE_Check_DataMessage+0x156>
 8003df0:	6860      	ldr	r0, [r4, #4]
 8003df2:	7800      	ldrb	r0, [r0, #0]
 8003df4:	0880      	lsrs	r0, r0, #2
 8003df6:	4228      	tst	r0, r5
 8003df8:	d100      	bne.n	8003dfc <PE_Check_DataMessage+0x40>
 8003dfa:	e08c      	b.n	8003f16 <PE_Check_DataMessage+0x15a>
 8003dfc:	7838      	ldrb	r0, [r7, #0]
 8003dfe:	7879      	ldrb	r1, [r7, #1]
 8003e00:	0209      	lsls	r1, r1, #8
 8003e02:	1840      	adds	r0, r0, r1
 8003e04:	78b9      	ldrb	r1, [r7, #2]
 8003e06:	0409      	lsls	r1, r1, #16
 8003e08:	1840      	adds	r0, r0, r1
 8003e0a:	78f9      	ldrb	r1, [r7, #3]
 8003e0c:	0609      	lsls	r1, r1, #24
 8003e0e:	1840      	adds	r0, r0, r1
 8003e10:	9000      	str	r0, [sp, #0]
 8003e12:	2304      	movs	r3, #4
 8003e14:	466a      	mov	r2, sp
 8003e16:	2106      	movs	r1, #6
 8003e18:	68e7      	ldr	r7, [r4, #12]
 8003e1a:	2001      	movs	r0, #1
 8003e1c:	4038      	ands	r0, r7
 8003e1e:	68a7      	ldr	r7, [r4, #8]
 8003e20:	69ff      	ldr	r7, [r7, #28]
 8003e22:	47b8      	blx	r7
 8003e24:	82e5      	strh	r5, [r4, #22]
 8003e26:	8d70      	ldrh	r0, [r6, #42]	; 0x2a
 8003e28:	0440      	lsls	r0, r0, #17
 8003e2a:	0c40      	lsrs	r0, r0, #17
 8003e2c:	2801      	cmp	r0, #1
 8003e2e:	db01      	blt.n	8003e34 <PE_Check_DataMessage+0x78>
 8003e30:	2000      	movs	r0, #0
 8003e32:	8570      	strh	r0, [r6, #42]	; 0x2a
 8003e34:	2009      	movs	r0, #9
 8003e36:	e06d      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003e38:	6860      	ldr	r0, [r4, #4]
 8003e3a:	7800      	ldrb	r0, [r0, #0]
 8003e3c:	0880      	lsrs	r0, r0, #2
 8003e3e:	4228      	tst	r0, r5
 8003e40:	d169      	bne.n	8003f16 <PE_Check_DataMessage+0x15a>
 8003e42:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 8003e44:	0600      	lsls	r0, r0, #24
 8003e46:	0f81      	lsrs	r1, r0, #30
 8003e48:	68e2      	ldr	r2, [r4, #12]
 8003e4a:	2001      	movs	r0, #1
 8003e4c:	4010      	ands	r0, r2
 8003e4e:	f000 fabf 	bl	80043d0 <PE_ExtRevisionInteroperability>
 8003e52:	8db0      	ldrh	r0, [r6, #44]	; 0x2c
 8003e54:	0440      	lsls	r0, r0, #17
 8003e56:	0f40      	lsrs	r0, r0, #29
 8003e58:	0083      	lsls	r3, r0, #2
 8003e5a:	003a      	movs	r2, r7
 8003e5c:	2104      	movs	r1, #4
 8003e5e:	68e7      	ldr	r7, [r4, #12]
 8003e60:	2001      	movs	r0, #1
 8003e62:	4038      	ands	r0, r7
 8003e64:	68a7      	ldr	r7, [r4, #8]
 8003e66:	69ff      	ldr	r7, [r7, #28]
 8003e68:	47b8      	blx	r7
 8003e6a:	82e5      	strh	r5, [r4, #22]
 8003e6c:	2044      	movs	r0, #68	; 0x44
 8003e6e:	e051      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003e70:	2000      	movs	r0, #0
 8003e72:	9001      	str	r0, [sp, #4]
 8003e74:	9000      	str	r0, [sp, #0]
 8003e76:	7838      	ldrb	r0, [r7, #0]
 8003e78:	7879      	ldrb	r1, [r7, #1]
 8003e7a:	0209      	lsls	r1, r1, #8
 8003e7c:	1840      	adds	r0, r0, r1
 8003e7e:	78b9      	ldrb	r1, [r7, #2]
 8003e80:	0409      	lsls	r1, r1, #16
 8003e82:	1840      	adds	r0, r0, r1
 8003e84:	78f9      	ldrb	r1, [r7, #3]
 8003e86:	0609      	lsls	r1, r1, #24
 8003e88:	1847      	adds	r7, r0, r1
 8003e8a:	466b      	mov	r3, sp
 8003e8c:	aa01      	add	r2, sp, #4
 8003e8e:	2103      	movs	r1, #3
 8003e90:	68e0      	ldr	r0, [r4, #12]
 8003e92:	4005      	ands	r5, r0
 8003e94:	0028      	movs	r0, r5
 8003e96:	68a5      	ldr	r5, [r4, #8]
 8003e98:	69ad      	ldr	r5, [r5, #24]
 8003e9a:	47a8      	blx	r5
 8003e9c:	9800      	ldr	r0, [sp, #0]
 8003e9e:	2804      	cmp	r0, #4
 8003ea0:	d115      	bne.n	8003ece <PE_Check_DataMessage+0x112>
 8003ea2:	6860      	ldr	r0, [r4, #4]
 8003ea4:	7840      	ldrb	r0, [r0, #1]
 8003ea6:	0640      	lsls	r0, r0, #25
 8003ea8:	0f40      	lsrs	r0, r0, #29
 8003eaa:	2803      	cmp	r0, #3
 8003eac:	d10f      	bne.n	8003ece <PE_Check_DataMessage+0x112>
 8003eae:	9801      	ldr	r0, [sp, #4]
 8003eb0:	49b4      	ldr	r1, [pc, #720]	; (8004184 <.text_57>)
 8003eb2:	4288      	cmp	r0, r1
 8003eb4:	d10b      	bne.n	8003ece <PE_Check_DataMessage+0x112>
 8003eb6:	0f38      	lsrs	r0, r7, #28
 8003eb8:	d003      	beq.n	8003ec2 <PE_Check_DataMessage+0x106>
 8003eba:	2805      	cmp	r0, #5
 8003ebc:	d003      	beq.n	8003ec6 <PE_Check_DataMessage+0x10a>
 8003ebe:	2808      	cmp	r0, #8
 8003ec0:	d103      	bne.n	8003eca <PE_Check_DataMessage+0x10e>
 8003ec2:	2029      	movs	r0, #41	; 0x29
 8003ec4:	e026      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003ec6:	2027      	movs	r0, #39	; 0x27
 8003ec8:	e024      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003eca:	202a      	movs	r0, #42	; 0x2a
 8003ecc:	e022      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003ece:	2003      	movs	r0, #3
 8003ed0:	e020      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003ed2:	6860      	ldr	r0, [r4, #4]
 8003ed4:	7800      	ldrb	r0, [r0, #0]
 8003ed6:	0780      	lsls	r0, r0, #30
 8003ed8:	0f80      	lsrs	r0, r0, #30
 8003eda:	2802      	cmp	r0, #2
 8003edc:	d11b      	bne.n	8003f16 <PE_Check_DataMessage+0x15a>
 8003ede:	e016      	b.n	8003f0e <PE_Check_DataMessage+0x152>
 8003ee0:	6820      	ldr	r0, [r4, #0]
 8003ee2:	88c0      	ldrh	r0, [r0, #6]
 8003ee4:	0900      	lsrs	r0, r0, #4
 8003ee6:	4228      	tst	r0, r5
 8003ee8:	d011      	beq.n	8003f0e <PE_Check_DataMessage+0x152>
 8003eea:	2304      	movs	r3, #4
 8003eec:	003a      	movs	r2, r7
 8003eee:	210b      	movs	r1, #11
 8003ef0:	68e0      	ldr	r0, [r4, #12]
 8003ef2:	4005      	ands	r5, r0
 8003ef4:	0028      	movs	r0, r5
 8003ef6:	68a4      	ldr	r4, [r4, #8]
 8003ef8:	69e4      	ldr	r4, [r4, #28]
 8003efa:	47a0      	blx	r4
 8003efc:	202c      	movs	r0, #44	; 0x2c
 8003efe:	e009      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003f00:	6820      	ldr	r0, [r4, #0]
 8003f02:	88c0      	ldrh	r0, [r0, #6]
 8003f04:	0a40      	lsrs	r0, r0, #9
 8003f06:	4228      	tst	r0, r5
 8003f08:	d001      	beq.n	8003f0e <PE_Check_DataMessage+0x152>
 8003f0a:	203d      	movs	r0, #61	; 0x3d
 8003f0c:	e002      	b.n	8003f14 <PE_Check_DataMessage+0x158>
 8003f0e:	7035      	strb	r5, [r6, #0]
 8003f10:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8003f12:	2011      	movs	r0, #17
 8003f14:	7030      	strb	r0, [r6, #0]
 8003f16:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

08003f18 <PE_Check_ExtendedMessage>:
 8003f18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003f1a:	0005      	movs	r5, r0
 8003f1c:	209e      	movs	r0, #158	; 0x9e
 8003f1e:	0040      	lsls	r0, r0, #1
 8003f20:	1828      	adds	r0, r5, r0
 8003f22:	7801      	ldrb	r1, [r0, #0]
 8003f24:	7840      	ldrb	r0, [r0, #1]
 8003f26:	0200      	lsls	r0, r0, #8
 8003f28:	1808      	adds	r0, r1, r0
 8003f2a:	21e4      	movs	r1, #228	; 0xe4
 8003f2c:	0089      	lsls	r1, r1, #2
 8003f2e:	1869      	adds	r1, r5, r1
 8003f30:	8008      	strh	r0, [r1, #0]
 8003f32:	4a95      	ldr	r2, [pc, #596]	; (8004188 <.text_58>)
 8003f34:	18ac      	adds	r4, r5, r2
 8003f36:	8f62      	ldrh	r2, [r4, #58]	; 0x3a
 8003f38:	06d2      	lsls	r2, r2, #27
 8003f3a:	0ed2      	lsrs	r2, r2, #27
 8003f3c:	2380      	movs	r3, #128	; 0x80
 8003f3e:	4313      	orrs	r3, r2
 8003f40:	708b      	strb	r3, [r1, #2]
 8003f42:	2601      	movs	r6, #1
 8003f44:	0402      	lsls	r2, r0, #16
 8003f46:	0e92      	lsrs	r2, r2, #26
 8003f48:	2101      	movs	r1, #1
 8003f4a:	4011      	ands	r1, r2
 8003f4c:	0402      	lsls	r2, r0, #16
 8003f4e:	0ed2      	lsrs	r2, r2, #27
 8003f50:	0712      	lsls	r2, r2, #28
 8003f52:	d003      	beq.n	8003f5c <PE_Check_ExtendedMessage+0x44>
 8003f54:	000a      	movs	r2, r1
 8003f56:	d001      	beq.n	8003f5c <PE_Check_ExtendedMessage+0x44>
 8003f58:	2034      	movs	r0, #52	; 0x34
 8003f5a:	e0a7      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8003f5c:	05c2      	lsls	r2, r0, #23
 8003f5e:	0dd2      	lsrs	r2, r2, #23
 8003f60:	0403      	lsls	r3, r0, #16
 8003f62:	0fdb      	lsrs	r3, r3, #31
 8003f64:	d10c      	bne.n	8003f80 <PE_Check_ExtendedMessage+0x68>
 8003f66:	8022      	strh	r2, [r4, #0]
 8003f68:	2000      	movs	r0, #0
 8003f6a:	2336      	movs	r3, #54	; 0x36
 8003f6c:	8821      	ldrh	r1, [r4, #0]
 8003f6e:	4288      	cmp	r0, r1
 8003f70:	d218      	bcs.n	8003fa4 <PE_Check_ExtendedMessage+0x8c>
 8003f72:	1829      	adds	r1, r5, r0
 8003f74:	229f      	movs	r2, #159	; 0x9f
 8003f76:	0052      	lsls	r2, r2, #1
 8003f78:	5c8a      	ldrb	r2, [r1, r2]
 8003f7a:	54ca      	strb	r2, [r1, r3]
 8003f7c:	1c40      	adds	r0, r0, #1
 8003f7e:	e7f5      	b.n	8003f6c <PE_Check_ExtendedMessage+0x54>
 8003f80:	23f8      	movs	r3, #248	; 0xf8
 8003f82:	01db      	lsls	r3, r3, #7
 8003f84:	4003      	ands	r3, r0
 8003f86:	d108      	bne.n	8003f9a <PE_Check_ExtendedMessage+0x82>
 8003f88:	8f60      	ldrh	r0, [r4, #58]	; 0x3a
 8003f8a:	0440      	lsls	r0, r0, #17
 8003f8c:	0f40      	lsrs	r0, r0, #29
 8003f8e:	2806      	cmp	r0, #6
 8003f90:	dc00      	bgt.n	8003f94 <PE_Check_ExtendedMessage+0x7c>
 8003f92:	e08f      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003f94:	2a1b      	cmp	r2, #27
 8003f96:	d200      	bcs.n	8003f9a <PE_Check_ExtendedMessage+0x82>
 8003f98:	e08c      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003f9a:	2900      	cmp	r1, #0
 8003f9c:	d000      	beq.n	8003fa0 <PE_Check_ExtendedMessage+0x88>
 8003f9e:	e089      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003fa0:	8820      	ldrh	r0, [r4, #0]
 8003fa2:	4290      	cmp	r0, r2
 8003fa4:	d300      	bcc.n	8003fa8 <PE_Check_ExtendedMessage+0x90>
 8003fa6:	e085      	b.n	80040b4 <PE_Check_ExtendedMessage+0x19c>
 8003fa8:	2037      	movs	r0, #55	; 0x37
 8003faa:	e07f      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8003fac:	2305      	movs	r3, #5
 8003fae:	2109      	movs	r1, #9
 8003fb0:	68ef      	ldr	r7, [r5, #12]
 8003fb2:	2001      	movs	r0, #1
 8003fb4:	4038      	ands	r0, r7
 8003fb6:	68af      	ldr	r7, [r5, #8]
 8003fb8:	69ff      	ldr	r7, [r7, #28]
 8003fba:	47b8      	blx	r7
 8003fbc:	2003      	movs	r0, #3
 8003fbe:	73a0      	strb	r0, [r4, #14]
 8003fc0:	4cca      	ldr	r4, [pc, #808]	; (80042ec <.text_61>)
 8003fc2:	7820      	ldrb	r0, [r4, #0]
 8003fc4:	0780      	lsls	r0, r0, #30
 8003fc6:	d509      	bpl.n	8003fdc <PE_Check_ExtendedMessage+0xc4>
 8003fc8:	2000      	movs	r0, #0
 8003fca:	9000      	str	r0, [sp, #0]
 8003fcc:	2300      	movs	r3, #0
 8003fce:	224b      	movs	r2, #75	; 0x4b
 8003fd0:	68e8      	ldr	r0, [r5, #12]
 8003fd2:	2101      	movs	r1, #1
 8003fd4:	4001      	ands	r1, r0
 8003fd6:	2009      	movs	r0, #9
 8003fd8:	68e4      	ldr	r4, [r4, #12]
 8003fda:	47a0      	blx	r4
 8003fdc:	214b      	movs	r1, #75	; 0x4b
 8003fde:	e0a4      	b.n	800412a <PE_Check_ExtendedMessage+0x212>
 8003fe0:	6828      	ldr	r0, [r5, #0]
 8003fe2:	88c0      	ldrh	r0, [r0, #6]
 8003fe4:	0980      	lsrs	r0, r0, #6
 8003fe6:	4230      	tst	r0, r6
 8003fe8:	d062      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8003fea:	2301      	movs	r3, #1
 8003fec:	2110      	movs	r1, #16
 8003fee:	68e8      	ldr	r0, [r5, #12]
 8003ff0:	4006      	ands	r6, r0
 8003ff2:	0030      	movs	r0, r6
 8003ff4:	68ad      	ldr	r5, [r5, #8]
 8003ff6:	69ed      	ldr	r5, [r5, #28]
 8003ff8:	47a8      	blx	r5
 8003ffa:	203a      	movs	r0, #58	; 0x3a
 8003ffc:	e056      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8003ffe:	6828      	ldr	r0, [r5, #0]
 8004000:	88c0      	ldrh	r0, [r0, #6]
 8004002:	0980      	lsrs	r0, r0, #6
 8004004:	4230      	tst	r0, r6
 8004006:	d053      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004008:	2301      	movs	r3, #1
 800400a:	210e      	movs	r1, #14
 800400c:	68e8      	ldr	r0, [r5, #12]
 800400e:	4006      	ands	r6, r0
 8004010:	0030      	movs	r0, r6
 8004012:	68ad      	ldr	r5, [r5, #8]
 8004014:	69ed      	ldr	r5, [r5, #28]
 8004016:	47a8      	blx	r5
 8004018:	203b      	movs	r0, #59	; 0x3b
 800401a:	e047      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 800401c:	6828      	ldr	r0, [r5, #0]
 800401e:	88c0      	ldrh	r0, [r0, #6]
 8004020:	09c0      	lsrs	r0, r0, #7
 8004022:	4230      	tst	r0, r6
 8004024:	d044      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004026:	2302      	movs	r3, #2
 8004028:	210c      	movs	r1, #12
 800402a:	68e8      	ldr	r0, [r5, #12]
 800402c:	4006      	ands	r6, r0
 800402e:	0030      	movs	r0, r6
 8004030:	68ad      	ldr	r5, [r5, #8]
 8004032:	69ed      	ldr	r5, [r5, #28]
 8004034:	47a8      	blx	r5
 8004036:	203c      	movs	r0, #60	; 0x3c
 8004038:	e038      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 800403a:	68a9      	ldr	r1, [r5, #8]
 800403c:	694f      	ldr	r7, [r1, #20]
 800403e:	2f00      	cmp	r7, #0
 8004040:	d036      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004042:	8823      	ldrh	r3, [r4, #0]
 8004044:	002a      	movs	r2, r5
 8004046:	3236      	adds	r2, #54	; 0x36
 8004048:	7881      	ldrb	r1, [r0, #2]
 800404a:	68e8      	ldr	r0, [r5, #12]
 800404c:	4006      	ands	r6, r0
 800404e:	0030      	movs	r0, r6
 8004050:	47b8      	blx	r7
 8004052:	2038      	movs	r0, #56	; 0x38
 8004054:	e02a      	b.n	80040ac <PE_Check_ExtendedMessage+0x194>
 8004056:	6829      	ldr	r1, [r5, #0]
 8004058:	88c9      	ldrh	r1, [r1, #6]
 800405a:	0ac9      	lsrs	r1, r1, #11
 800405c:	4231      	tst	r1, r6
 800405e:	d027      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004060:	68a9      	ldr	r1, [r5, #8]
 8004062:	6949      	ldr	r1, [r1, #20]
 8004064:	2900      	cmp	r1, #0
 8004066:	d116      	bne.n	8004096 <PE_Check_ExtendedMessage+0x17e>
 8004068:	e022      	b.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 800406a:	68a9      	ldr	r1, [r5, #8]
 800406c:	694f      	ldr	r7, [r1, #20]
 800406e:	2f00      	cmp	r7, #0
 8004070:	d01f      	beq.n	80040b2 <PE_Check_ExtendedMessage+0x19a>
 8004072:	8823      	ldrh	r3, [r4, #0]
 8004074:	002a      	movs	r2, r5
 8004076:	3236      	adds	r2, #54	; 0x36
 8004078:	7881      	ldrb	r1, [r0, #2]
 800407a:	68e8      	ldr	r0, [r5, #12]
 800407c:	4006      	ands	r6, r0
 800407e:	0030      	movs	r0, r6
 8004080:	47b8      	blx	r7
 8004082:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
 8004084:	6829      	ldr	r1, [r5, #0]
 8004086:	88c9      	ldrh	r1, [r1, #6]
 8004088:	0a89      	lsrs	r1, r1, #10
 800408a:	4231      	tst	r1, r6
 800408c:	d010      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 800408e:	68a9      	ldr	r1, [r5, #8]
 8004090:	6949      	ldr	r1, [r1, #20]
 8004092:	2900      	cmp	r1, #0
 8004094:	d00c      	beq.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 8004096:	8823      	ldrh	r3, [r4, #0]
 8004098:	002a      	movs	r2, r5
 800409a:	3236      	adds	r2, #54	; 0x36
 800409c:	7881      	ldrb	r1, [r0, #2]
 800409e:	68e8      	ldr	r0, [r5, #12]
 80040a0:	4006      	ands	r6, r0
 80040a2:	0030      	movs	r0, r6
 80040a4:	68ad      	ldr	r5, [r5, #8]
 80040a6:	696d      	ldr	r5, [r5, #20]
 80040a8:	47a8      	blx	r5
 80040aa:	20a5      	movs	r0, #165	; 0xa5
 80040ac:	73a0      	strb	r0, [r4, #14]
 80040ae:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
 80040b0:	73a6      	strb	r6, [r4, #14]
 80040b2:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
 80040b4:	20e4      	movs	r0, #228	; 0xe4
 80040b6:	0080      	lsls	r0, r0, #2
 80040b8:	1828      	adds	r0, r5, r0
 80040ba:	219f      	movs	r1, #159	; 0x9f
 80040bc:	0049      	lsls	r1, r1, #1
 80040be:	186a      	adds	r2, r5, r1
 80040c0:	7881      	ldrb	r1, [r0, #2]
 80040c2:	3981      	subs	r1, #129	; 0x81
 80040c4:	d018      	beq.n	80040f8 <PE_Check_ExtendedMessage+0x1e0>
 80040c6:	1e49      	subs	r1, r1, #1
 80040c8:	d100      	bne.n	80040cc <PE_Check_ExtendedMessage+0x1b4>
 80040ca:	e76f      	b.n	8003fac <PE_Check_ExtendedMessage+0x94>
 80040cc:	1e49      	subs	r1, r1, #1
 80040ce:	d087      	beq.n	8003fe0 <PE_Check_ExtendedMessage+0xc8>
 80040d0:	1e49      	subs	r1, r1, #1
 80040d2:	d094      	beq.n	8003ffe <PE_Check_ExtendedMessage+0xe6>
 80040d4:	1e49      	subs	r1, r1, #1
 80040d6:	d0b0      	beq.n	800403a <PE_Check_ExtendedMessage+0x122>
 80040d8:	1e49      	subs	r1, r1, #1
 80040da:	d09f      	beq.n	800401c <PE_Check_ExtendedMessage+0x104>
 80040dc:	1e49      	subs	r1, r1, #1
 80040de:	d0ac      	beq.n	800403a <PE_Check_ExtendedMessage+0x122>
 80040e0:	1e49      	subs	r1, r1, #1
 80040e2:	d0cf      	beq.n	8004084 <PE_Check_ExtendedMessage+0x16c>
 80040e4:	1e49      	subs	r1, r1, #1
 80040e6:	d0e4      	beq.n	80040b2 <PE_Check_ExtendedMessage+0x19a>
 80040e8:	1e49      	subs	r1, r1, #1
 80040ea:	d0b4      	beq.n	8004056 <PE_Check_ExtendedMessage+0x13e>
 80040ec:	1e49      	subs	r1, r1, #1
 80040ee:	d0bc      	beq.n	800406a <PE_Check_ExtendedMessage+0x152>
 80040f0:	1e89      	subs	r1, r1, #2
 80040f2:	2901      	cmp	r1, #1
 80040f4:	d9a1      	bls.n	800403a <PE_Check_ExtendedMessage+0x122>
 80040f6:	e7db      	b.n	80040b0 <PE_Check_ExtendedMessage+0x198>
 80040f8:	2318      	movs	r3, #24
 80040fa:	2108      	movs	r1, #8
 80040fc:	68ef      	ldr	r7, [r5, #12]
 80040fe:	2001      	movs	r0, #1
 8004100:	4038      	ands	r0, r7
 8004102:	68af      	ldr	r7, [r5, #8]
 8004104:	69ff      	ldr	r7, [r7, #28]
 8004106:	47b8      	blx	r7
 8004108:	2003      	movs	r0, #3
 800410a:	73a0      	strb	r0, [r4, #14]
 800410c:	4c77      	ldr	r4, [pc, #476]	; (80042ec <.text_61>)
 800410e:	7820      	ldrb	r0, [r4, #0]
 8004110:	0780      	lsls	r0, r0, #30
 8004112:	d509      	bpl.n	8004128 <PE_Check_ExtendedMessage+0x210>
 8004114:	2000      	movs	r0, #0
 8004116:	9000      	str	r0, [sp, #0]
 8004118:	2300      	movs	r3, #0
 800411a:	2244      	movs	r2, #68	; 0x44
 800411c:	68e8      	ldr	r0, [r5, #12]
 800411e:	2101      	movs	r1, #1
 8004120:	4001      	ands	r1, r0
 8004122:	2009      	movs	r0, #9
 8004124:	68e4      	ldr	r4, [r4, #12]
 8004126:	47a0      	blx	r4
 8004128:	2144      	movs	r1, #68	; 0x44
 800412a:	68e8      	ldr	r0, [r5, #12]
 800412c:	4006      	ands	r6, r0
 800412e:	0030      	movs	r0, r6
 8004130:	68aa      	ldr	r2, [r5, #8]
 8004132:	68d2      	ldr	r2, [r2, #12]
 8004134:	4790      	blx	r2
 8004136:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}

08004138 <PE_PRL_HardResetReceived>:
 8004138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800413a:	0007      	movs	r7, r0
 800413c:	48cf      	ldr	r0, [pc, #828]	; (800447c <.text_65>)
 800413e:	00b9      	lsls	r1, r7, #2
 8004140:	5844      	ldr	r4, [r0, r1]
 8004142:	48d7      	ldr	r0, [pc, #860]	; (80044a0 <.text_67>)
 8004144:	1825      	adds	r5, r4, r0
 8004146:	2600      	movs	r6, #0
 8004148:	702e      	strb	r6, [r5, #0]
 800414a:	0038      	movs	r0, r7
 800414c:	f001 f982 	bl	8005454 <USBPD_PRL_Reset>
 8004150:	6860      	ldr	r0, [r4, #4]
 8004152:	2101      	movs	r1, #1
 8004154:	7802      	ldrb	r2, [r0, #0]
 8004156:	0892      	lsrs	r2, r2, #2
 8004158:	420a      	tst	r2, r1
 800415a:	d001      	beq.n	8004160 <PE_PRL_HardResetReceived+0x28>
 800415c:	2014      	movs	r0, #20
 800415e:	e005      	b.n	800416c <PE_PRL_HardResetReceived+0x34>
 8004160:	6802      	ldr	r2, [r0, #0]
 8004162:	2310      	movs	r3, #16
 8004164:	4313      	orrs	r3, r2
 8004166:	6003      	str	r3, [r0, #0]
 8004168:	842e      	strh	r6, [r5, #32]
 800416a:	203f      	movs	r0, #63	; 0x3f
 800416c:	70a8      	strb	r0, [r5, #2]
 800416e:	7b60      	ldrb	r0, [r4, #13]
 8004170:	22fc      	movs	r2, #252	; 0xfc
 8004172:	4002      	ands	r2, r0
 8004174:	4311      	orrs	r1, r2
 8004176:	7361      	strb	r1, [r4, #13]
 8004178:	0038      	movs	r0, r7
 800417a:	68a1      	ldr	r1, [r4, #8]
 800417c:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800417e:	4788      	blx	r1
 8004180:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}
	...

08004184 <.text_57>:
 8004184:	00001388 	.word	0x00001388

08004188 <.text_58>:
 8004188:	0000034a 	.word	0x0000034a

0800418c <PE_PRL_BistCompleted>:
 800418c:	4770      	bx	lr

0800418e <PE_Reset>:
 800418e:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 8004190:	b084      	sub	sp, #16
 8004192:	000e      	movs	r6, r1
 8004194:	48c8      	ldr	r0, [pc, #800]	; (80044b8 <.text_69>)
 8004196:	1d01      	adds	r1, r0, #4
 8004198:	466a      	mov	r2, sp
 800419a:	7c12      	ldrb	r2, [r2, #16]
 800419c:	0092      	lsls	r2, r2, #2
 800419e:	588c      	ldr	r4, [r1, r2]
 80041a0:	2500      	movs	r5, #0
 80041a2:	9502      	str	r5, [sp, #8]
 80041a4:	68e1      	ldr	r1, [r4, #12]
 80041a6:	2203      	movs	r2, #3
 80041a8:	4391      	bics	r1, r2
 80041aa:	466a      	mov	r2, sp
 80041ac:	7c12      	ldrb	r2, [r2, #16]
 80041ae:	07d3      	lsls	r3, r2, #31
 80041b0:	0fdb      	lsrs	r3, r3, #31
 80041b2:	430b      	orrs	r3, r1
 80041b4:	60e3      	str	r3, [r4, #12]
 80041b6:	6861      	ldr	r1, [r4, #4]
 80041b8:	680a      	ldr	r2, [r1, #0]
 80041ba:	2310      	movs	r3, #16
 80041bc:	439a      	bics	r2, r3
 80041be:	600a      	str	r2, [r1, #0]
 80041c0:	6861      	ldr	r1, [r4, #4]
 80041c2:	784a      	ldrb	r2, [r1, #1]
 80041c4:	238f      	movs	r3, #143	; 0x8f
 80041c6:	4013      	ands	r3, r2
 80041c8:	704b      	strb	r3, [r1, #1]
 80041ca:	7800      	ldrb	r0, [r0, #0]
 80041cc:	0780      	lsls	r0, r0, #30
 80041ce:	d509      	bpl.n	80041e4 <PE_Reset+0x56>
 80041d0:	9500      	str	r5, [sp, #0]
 80041d2:	2300      	movs	r3, #0
 80041d4:	2256      	movs	r2, #86	; 0x56
 80041d6:	7b20      	ldrb	r0, [r4, #12]
 80041d8:	07c1      	lsls	r1, r0, #31
 80041da:	0fc9      	lsrs	r1, r1, #31
 80041dc:	2009      	movs	r0, #9
 80041de:	4fb6      	ldr	r7, [pc, #728]	; (80044b8 <.text_69>)
 80041e0:	68ff      	ldr	r7, [r7, #12]
 80041e2:	47b8      	blx	r7
 80041e4:	4668      	mov	r0, sp
 80041e6:	7006      	strb	r6, [r0, #0]
 80041e8:	2156      	movs	r1, #86	; 0x56
 80041ea:	7b22      	ldrb	r2, [r4, #12]
 80041ec:	07d0      	lsls	r0, r2, #31
 80041ee:	0fc0      	lsrs	r0, r0, #31
 80041f0:	68a2      	ldr	r2, [r4, #8]
 80041f2:	68d2      	ldr	r2, [r2, #12]
 80041f4:	4790      	blx	r2
 80041f6:	48b1      	ldr	r0, [pc, #708]	; (80044bc <.text_70>)
 80041f8:	1826      	adds	r6, r4, r0
 80041fa:	82b5      	strh	r5, [r6, #20]
 80041fc:	82e5      	strh	r5, [r4, #22]
 80041fe:	72b5      	strb	r5, [r6, #10]
 8004200:	4668      	mov	r0, sp
 8004202:	7800      	ldrb	r0, [r0, #0]
 8004204:	2800      	cmp	r0, #0
 8004206:	d100      	bne.n	800420a <PE_Reset+0x7c>
 8004208:	7525      	strb	r5, [r4, #20]
 800420a:	7335      	strb	r5, [r6, #12]
 800420c:	7475      	strb	r5, [r6, #17]
 800420e:	72f5      	strb	r5, [r6, #11]
 8004210:	6860      	ldr	r0, [r4, #4]
 8004212:	7800      	ldrb	r0, [r0, #0]
 8004214:	0880      	lsrs	r0, r0, #2
 8004216:	07c0      	lsls	r0, r0, #31
 8004218:	d51d      	bpl.n	8004256 <PE_Reset+0xc8>
 800421a:	6820      	ldr	r0, [r4, #0]
 800421c:	7900      	ldrb	r0, [r0, #4]
 800421e:	0783      	lsls	r3, r0, #30
 8004220:	0f9b      	lsrs	r3, r3, #30
 8004222:	2201      	movs	r2, #1
 8004224:	2101      	movs	r1, #1
 8004226:	4668      	mov	r0, sp
 8004228:	7c00      	ldrb	r0, [r0, #16]
 800422a:	f000 fe5d 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800422e:	6860      	ldr	r0, [r4, #4]
 8004230:	7801      	ldrb	r1, [r0, #0]
 8004232:	2208      	movs	r2, #8
 8004234:	430a      	orrs	r2, r1
 8004236:	7002      	strb	r2, [r0, #0]
 8004238:	2002      	movs	r0, #2
 800423a:	73b0      	strb	r0, [r6, #14]
 800423c:	2304      	movs	r3, #4
 800423e:	aa02      	add	r2, sp, #8
 8004240:	2102      	movs	r1, #2
 8004242:	4668      	mov	r0, sp
 8004244:	7c00      	ldrb	r0, [r0, #16]
 8004246:	68a7      	ldr	r7, [r4, #8]
 8004248:	69ff      	ldr	r7, [r7, #28]
 800424a:	47b8      	blx	r7
 800424c:	6860      	ldr	r0, [r4, #4]
 800424e:	7800      	ldrb	r0, [r0, #0]
 8004250:	0880      	lsrs	r0, r0, #2
 8004252:	07c0      	lsls	r0, r0, #31
 8004254:	d428      	bmi.n	80042a8 <PE_Reset+0x11a>
 8004256:	6820      	ldr	r0, [r4, #0]
 8004258:	7900      	ldrb	r0, [r0, #4]
 800425a:	0783      	lsls	r3, r0, #30
 800425c:	0f9b      	lsrs	r3, r3, #30
 800425e:	2200      	movs	r2, #0
 8004260:	2100      	movs	r1, #0
 8004262:	4668      	mov	r0, sp
 8004264:	7c00      	ldrb	r0, [r0, #16]
 8004266:	f000 fe3f 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800426a:	6860      	ldr	r0, [r4, #4]
 800426c:	7801      	ldrb	r1, [r0, #0]
 800426e:	22f7      	movs	r2, #247	; 0xf7
 8004270:	400a      	ands	r2, r1
 8004272:	7002      	strb	r2, [r0, #0]
 8004274:	4668      	mov	r0, sp
 8004276:	7800      	ldrb	r0, [r0, #0]
 8004278:	2800      	cmp	r0, #0
 800427a:	d101      	bne.n	8004280 <PE_Reset+0xf2>
 800427c:	203e      	movs	r0, #62	; 0x3e
 800427e:	73b0      	strb	r0, [r6, #14]
 8004280:	7375      	strb	r5, [r6, #13]
 8004282:	2080      	movs	r0, #128	; 0x80
 8004284:	0440      	lsls	r0, r0, #17
 8004286:	9001      	str	r0, [sp, #4]
 8004288:	2304      	movs	r3, #4
 800428a:	aa01      	add	r2, sp, #4
 800428c:	2107      	movs	r1, #7
 800428e:	4668      	mov	r0, sp
 8004290:	7c00      	ldrb	r0, [r0, #16]
 8004292:	68a7      	ldr	r7, [r4, #8]
 8004294:	69ff      	ldr	r7, [r7, #28]
 8004296:	47b8      	blx	r7
 8004298:	2304      	movs	r3, #4
 800429a:	aa02      	add	r2, sp, #8
 800429c:	2102      	movs	r1, #2
 800429e:	4668      	mov	r0, sp
 80042a0:	7c00      	ldrb	r0, [r0, #16]
 80042a2:	68a7      	ldr	r7, [r4, #8]
 80042a4:	69ff      	ldr	r7, [r7, #28]
 80042a6:	47b8      	blx	r7
 80042a8:	8035      	strh	r5, [r6, #0]
 80042aa:	8075      	strh	r5, [r6, #2]
 80042ac:	2124      	movs	r1, #36	; 0x24
 80042ae:	20d8      	movs	r0, #216	; 0xd8
 80042b0:	0080      	lsls	r0, r0, #2
 80042b2:	1820      	adds	r0, r4, r0
 80042b4:	f008 fc38 	bl	800cb28 <__aeabi_memclr>
 80042b8:	487f      	ldr	r0, [pc, #508]	; (80044b8 <.text_69>)
 80042ba:	68c5      	ldr	r5, [r0, #12]
 80042bc:	2d00      	cmp	r5, #0
 80042be:	d00f      	beq.n	80042e0 <PE_Reset+0x152>
 80042c0:	7800      	ldrb	r0, [r0, #0]
 80042c2:	07c0      	lsls	r0, r0, #31
 80042c4:	d50c      	bpl.n	80042e0 <PE_Reset+0x152>
 80042c6:	7bb2      	ldrb	r2, [r6, #14]
 80042c8:	7bf0      	ldrb	r0, [r6, #15]
 80042ca:	4290      	cmp	r0, r2
 80042cc:	d008      	beq.n	80042e0 <PE_Reset+0x152>
 80042ce:	73f2      	strb	r2, [r6, #15]
 80042d0:	2000      	movs	r0, #0
 80042d2:	9000      	str	r0, [sp, #0]
 80042d4:	2300      	movs	r3, #0
 80042d6:	7b20      	ldrb	r0, [r4, #12]
 80042d8:	07c1      	lsls	r1, r0, #31
 80042da:	0fc9      	lsrs	r1, r1, #31
 80042dc:	2004      	movs	r0, #4
 80042de:	47a8      	blx	r5
 80042e0:	4668      	mov	r0, sp
 80042e2:	7c00      	ldrb	r0, [r0, #16]
 80042e4:	f001 f8b6 	bl	8005454 <USBPD_PRL_Reset>
 80042e8:	b005      	add	sp, #20
 80042ea:	bdf0      	pop	{r4, r5, r6, r7, pc}

080042ec <.text_61>:
 80042ec:	200019a8 	.word	0x200019a8

080042f0 <PE_ResetDuringSwap>:
 80042f0:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 80042f2:	0004      	movs	r4, r0
 80042f4:	2700      	movs	r7, #0
 80042f6:	9701      	str	r7, [sp, #4]
 80042f8:	6860      	ldr	r0, [r4, #4]
 80042fa:	7841      	ldrb	r1, [r0, #1]
 80042fc:	228f      	movs	r2, #143	; 0x8f
 80042fe:	400a      	ands	r2, r1
 8004300:	2110      	movs	r1, #16
 8004302:	4311      	orrs	r1, r2
 8004304:	7041      	strb	r1, [r0, #1]
 8004306:	4d6c      	ldr	r5, [pc, #432]	; (80044b8 <.text_69>)
 8004308:	2601      	movs	r6, #1
 800430a:	7828      	ldrb	r0, [r5, #0]
 800430c:	0780      	lsls	r0, r0, #30
 800430e:	d508      	bpl.n	8004322 <PE_ResetDuringSwap+0x32>
 8004310:	9700      	str	r7, [sp, #0]
 8004312:	2300      	movs	r3, #0
 8004314:	2256      	movs	r2, #86	; 0x56
 8004316:	68e0      	ldr	r0, [r4, #12]
 8004318:	2101      	movs	r1, #1
 800431a:	4001      	ands	r1, r0
 800431c:	2009      	movs	r0, #9
 800431e:	68ed      	ldr	r5, [r5, #12]
 8004320:	47a8      	blx	r5
 8004322:	2156      	movs	r1, #86	; 0x56
 8004324:	68e2      	ldr	r2, [r4, #12]
 8004326:	2001      	movs	r0, #1
 8004328:	4010      	ands	r0, r2
 800432a:	68a2      	ldr	r2, [r4, #8]
 800432c:	68d2      	ldr	r2, [r2, #12]
 800432e:	4790      	blx	r2
 8004330:	4863      	ldr	r0, [pc, #396]	; (80044c0 <.text_71>)
 8004332:	1825      	adds	r5, r4, r0
 8004334:	702f      	strb	r7, [r5, #0]
 8004336:	712f      	strb	r7, [r5, #4]
 8004338:	68e1      	ldr	r1, [r4, #12]
 800433a:	2001      	movs	r0, #1
 800433c:	4008      	ands	r0, r1
 800433e:	6861      	ldr	r1, [r4, #4]
 8004340:	7809      	ldrb	r1, [r1, #0]
 8004342:	0889      	lsrs	r1, r1, #2
 8004344:	4231      	tst	r1, r6
 8004346:	d014      	beq.n	8004372 <PE_ResetDuringSwap+0x82>
 8004348:	f7ff fb14 	bl	8003974 <PE_Get_DataRole>
 800434c:	6861      	ldr	r1, [r4, #4]
 800434e:	7809      	ldrb	r1, [r1, #0]
 8004350:	2303      	movs	r3, #3
 8004352:	400b      	ands	r3, r1
 8004354:	0002      	movs	r2, r0
 8004356:	2101      	movs	r1, #1
 8004358:	68e7      	ldr	r7, [r4, #12]
 800435a:	2001      	movs	r0, #1
 800435c:	4038      	ands	r0, r7
 800435e:	f000 fdc3 	bl	8004ee8 <USBPD_PRL_SetHeader>
 8004362:	2002      	movs	r0, #2
 8004364:	7068      	strb	r0, [r5, #1]
 8004366:	6860      	ldr	r0, [r4, #4]
 8004368:	6801      	ldr	r1, [r0, #0]
 800436a:	2210      	movs	r2, #16
 800436c:	4391      	bics	r1, r2
 800436e:	6001      	str	r1, [r0, #0]
 8004370:	e019      	b.n	80043a6 <PE_ResetDuringSwap+0xb6>
 8004372:	f7ff faff 	bl	8003974 <PE_Get_DataRole>
 8004376:	6861      	ldr	r1, [r4, #4]
 8004378:	7809      	ldrb	r1, [r1, #0]
 800437a:	2303      	movs	r3, #3
 800437c:	400b      	ands	r3, r1
 800437e:	0002      	movs	r2, r0
 8004380:	2100      	movs	r1, #0
 8004382:	68e7      	ldr	r7, [r4, #12]
 8004384:	2001      	movs	r0, #1
 8004386:	4038      	ands	r0, r7
 8004388:	f000 fdae 	bl	8004ee8 <USBPD_PRL_SetHeader>
 800438c:	203e      	movs	r0, #62	; 0x3e
 800438e:	7068      	strb	r0, [r5, #1]
 8004390:	0630      	lsls	r0, r6, #24
 8004392:	9000      	str	r0, [sp, #0]
 8004394:	2304      	movs	r3, #4
 8004396:	466a      	mov	r2, sp
 8004398:	2107      	movs	r1, #7
 800439a:	68e5      	ldr	r5, [r4, #12]
 800439c:	2001      	movs	r0, #1
 800439e:	4028      	ands	r0, r5
 80043a0:	68a5      	ldr	r5, [r4, #8]
 80043a2:	69ed      	ldr	r5, [r5, #28]
 80043a4:	47a8      	blx	r5
 80043a6:	2304      	movs	r3, #4
 80043a8:	aa01      	add	r2, sp, #4
 80043aa:	2102      	movs	r1, #2
 80043ac:	68e5      	ldr	r5, [r4, #12]
 80043ae:	2001      	movs	r0, #1
 80043b0:	4028      	ands	r0, r5
 80043b2:	68a5      	ldr	r5, [r4, #8]
 80043b4:	69ed      	ldr	r5, [r5, #28]
 80043b6:	47a8      	blx	r5
 80043b8:	2124      	movs	r1, #36	; 0x24
 80043ba:	20d8      	movs	r0, #216	; 0xd8
 80043bc:	0080      	lsls	r0, r0, #2
 80043be:	1820      	adds	r0, r4, r0
 80043c0:	f008 fbb2 	bl	800cb28 <__aeabi_memclr>
 80043c4:	68e0      	ldr	r0, [r4, #12]
 80043c6:	4006      	ands	r6, r0
 80043c8:	0030      	movs	r0, r6
 80043ca:	f001 f843 	bl	8005454 <USBPD_PRL_Reset>
 80043ce:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

080043d0 <PE_ExtRevisionInteroperability>:
 80043d0:	b5fe      	push	{r1, r2, r3, r4, r5, r6, r7, lr}
 80043d2:	000a      	movs	r2, r1
 80043d4:	4c38      	ldr	r4, [pc, #224]	; (80044b8 <.text_69>)
 80043d6:	0081      	lsls	r1, r0, #2
 80043d8:	1861      	adds	r1, r4, r1
 80043da:	9101      	str	r1, [sp, #4]
 80043dc:	684e      	ldr	r6, [r1, #4]
 80043de:	2103      	movs	r1, #3
 80043e0:	6873      	ldr	r3, [r6, #4]
 80043e2:	781b      	ldrb	r3, [r3, #0]
 80043e4:	400b      	ands	r3, r1
 80043e6:	4293      	cmp	r3, r2
 80043e8:	d03a      	beq.n	8004460 <PE_ExtRevisionInteroperability+0x90>
 80043ea:	6873      	ldr	r3, [r6, #4]
 80043ec:	781b      	ldrb	r3, [r3, #0]
 80043ee:	079b      	lsls	r3, r3, #30
 80043f0:	0f9b      	lsrs	r3, r3, #30
 80043f2:	429a      	cmp	r2, r3
 80043f4:	d300      	bcc.n	80043f8 <PE_ExtRevisionInteroperability+0x28>
 80043f6:	001a      	movs	r2, r3
 80043f8:	6873      	ldr	r3, [r6, #4]
 80043fa:	781d      	ldrb	r5, [r3, #0]
 80043fc:	27fc      	movs	r7, #252	; 0xfc
 80043fe:	402f      	ands	r7, r5
 8004400:	400a      	ands	r2, r1
 8004402:	433a      	orrs	r2, r7
 8004404:	701a      	strb	r2, [r3, #0]
 8004406:	6872      	ldr	r2, [r6, #4]
 8004408:	7812      	ldrb	r2, [r2, #0]
 800440a:	2501      	movs	r5, #1
 800440c:	2303      	movs	r3, #3
 800440e:	4013      	ands	r3, r2
 8004410:	2b01      	cmp	r3, #1
 8004412:	d101      	bne.n	8004418 <PE_ExtRevisionInteroperability+0x48>
 8004414:	2700      	movs	r7, #0
 8004416:	e000      	b.n	800441a <PE_ExtRevisionInteroperability+0x4a>
 8004418:	2701      	movs	r7, #1
 800441a:	239f      	movs	r3, #159	; 0x9f
 800441c:	4013      	ands	r3, r2
 800441e:	017a      	lsls	r2, r7, #5
 8004420:	431a      	orrs	r2, r3
 8004422:	6873      	ldr	r3, [r6, #4]
 8004424:	701a      	strb	r2, [r3, #0]
 8004426:	6872      	ldr	r2, [r6, #4]
 8004428:	7812      	ldrb	r2, [r2, #0]
 800442a:	4011      	ands	r1, r2
 800442c:	f000 fd91 	bl	8004f52 <USBPD_PRL_SetHeaderSpecification>
 8004430:	7820      	ldrb	r0, [r4, #0]
 8004432:	0780      	lsls	r0, r0, #30
 8004434:	d50b      	bpl.n	800444e <PE_ExtRevisionInteroperability+0x7e>
 8004436:	2000      	movs	r0, #0
 8004438:	9000      	str	r0, [sp, #0]
 800443a:	2300      	movs	r3, #0
 800443c:	2236      	movs	r2, #54	; 0x36
 800443e:	9801      	ldr	r0, [sp, #4]
 8004440:	6840      	ldr	r0, [r0, #4]
 8004442:	68c0      	ldr	r0, [r0, #12]
 8004444:	2101      	movs	r1, #1
 8004446:	4001      	ands	r1, r0
 8004448:	2009      	movs	r0, #9
 800444a:	68e4      	ldr	r4, [r4, #12]
 800444c:	47a0      	blx	r4
 800444e:	9801      	ldr	r0, [sp, #4]
 8004450:	6842      	ldr	r2, [r0, #4]
 8004452:	2136      	movs	r1, #54	; 0x36
 8004454:	68d0      	ldr	r0, [r2, #12]
 8004456:	4005      	ands	r5, r0
 8004458:	0028      	movs	r0, r5
 800445a:	6892      	ldr	r2, [r2, #8]
 800445c:	68d2      	ldr	r2, [r2, #12]
 800445e:	4790      	blx	r2
 8004460:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}

08004462 <PE_PRL_PostReceiveEvent>:
 8004462:	4b15      	ldr	r3, [pc, #84]	; (80044b8 <.text_69>)
 8004464:	0080      	lsls	r0, r0, #2
 8004466:	1818      	adds	r0, r3, r0
 8004468:	6840      	ldr	r0, [r0, #4]
 800446a:	4b0d      	ldr	r3, [pc, #52]	; (80044a0 <.text_67>)
 800446c:	18c0      	adds	r0, r0, r3
 800446e:	2301      	movs	r3, #1
 8004470:	408b      	lsls	r3, r1
 8004472:	7003      	strb	r3, [r0, #0]
 8004474:	8811      	ldrh	r1, [r2, #0]
 8004476:	85c1      	strh	r1, [r0, #46]	; 0x2e
 8004478:	4770      	bx	lr
	...

0800447c <.text_65>:
 800447c:	200019ac 	.word	0x200019ac

08004480 <PE_PRL_PostReceiveEventComplete>:
 8004480:	b510      	push	{r4, lr}
 8004482:	490d      	ldr	r1, [pc, #52]	; (80044b8 <.text_69>)
 8004484:	0082      	lsls	r2, r0, #2
 8004486:	1889      	adds	r1, r1, r2
 8004488:	6849      	ldr	r1, [r1, #4]
 800448a:	4a05      	ldr	r2, [pc, #20]	; (80044a0 <.text_67>)
 800448c:	188a      	adds	r2, r1, r2
 800448e:	7813      	ldrb	r3, [r2, #0]
 8004490:	2420      	movs	r4, #32
 8004492:	431c      	orrs	r4, r3
 8004494:	7014      	strb	r4, [r2, #0]
 8004496:	6889      	ldr	r1, [r1, #8]
 8004498:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800449a:	4788      	blx	r1
 800449c:	bd10      	pop	{r4, pc}
	...

080044a0 <.text_67>:
 80044a0:	00000356 	.word	0x00000356

080044a4 <PE_Get_UnchunkedSupport>:
 80044a4:	4904      	ldr	r1, [pc, #16]	; (80044b8 <.text_69>)
 80044a6:	0080      	lsls	r0, r0, #2
 80044a8:	1808      	adds	r0, r1, r0
 80044aa:	6840      	ldr	r0, [r0, #4]
 80044ac:	6840      	ldr	r0, [r0, #4]
 80044ae:	6800      	ldr	r0, [r0, #0]
 80044b0:	0301      	lsls	r1, r0, #12
 80044b2:	0fc8      	lsrs	r0, r1, #31
 80044b4:	4770      	bx	lr
	...

080044b8 <.text_69>:
 80044b8:	200019a8 	.word	0x200019a8

080044bc <.text_70>:
 80044bc:	0000034a 	.word	0x0000034a

080044c0 <.text_71>:
 80044c0:	00000357 	.word	0x00000357

080044c4 <PE_Send_ExtendedMessage>:
 80044c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80044c6:	b085      	sub	sp, #20
 80044c8:	6844      	ldr	r4, [r0, #4]
 80044ca:	25d6      	movs	r5, #214	; 0xd6
 80044cc:	00ad      	lsls	r5, r5, #2
 80044ce:	1945      	adds	r5, r0, r5
 80044d0:	9503      	str	r5, [sp, #12]
 80044d2:	2511      	movs	r5, #17
 80044d4:	7866      	ldrb	r6, [r4, #1]
 80044d6:	0676      	lsls	r6, r6, #25
 80044d8:	0f76      	lsrs	r6, r6, #29
 80044da:	2e03      	cmp	r6, #3
 80044dc:	d129      	bne.n	8004532 <PE_Send_ExtendedMessage+0x6e>
 80044de:	7824      	ldrb	r4, [r4, #0]
 80044e0:	07a4      	lsls	r4, r4, #30
 80044e2:	0fa4      	lsrs	r4, r4, #30
 80044e4:	2c01      	cmp	r4, #1
 80044e6:	dd24      	ble.n	8004532 <PE_Send_ExtendedMessage+0x6e>
 80044e8:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 80044ea:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80044ec:	9304      	str	r3, [sp, #16]
 80044ee:	23ff      	movs	r3, #255	; 0xff
 80044f0:	330a      	adds	r3, #10
 80044f2:	429f      	cmp	r7, r3
 80044f4:	d21d      	bcs.n	8004532 <PE_Send_ExtendedMessage+0x6e>
 80044f6:	0006      	movs	r6, r0
 80044f8:	4668      	mov	r0, sp
 80044fa:	7241      	strb	r1, [r0, #9]
 80044fc:	7202      	strb	r2, [r0, #8]
 80044fe:	970a      	str	r7, [sp, #40]	; 0x28
 8004500:	a80c      	add	r0, sp, #48	; 0x30
 8004502:	7004      	strb	r4, [r0, #0]
 8004504:	2401      	movs	r4, #1
 8004506:	a80c      	add	r0, sp, #48	; 0x30
 8004508:	7800      	ldrb	r0, [r0, #0]
 800450a:	9001      	str	r0, [sp, #4]
 800450c:	980a      	ldr	r0, [sp, #40]	; 0x28
 800450e:	b280      	uxth	r0, r0
 8004510:	9000      	str	r0, [sp, #0]
 8004512:	9b04      	ldr	r3, [sp, #16]
 8004514:	4668      	mov	r0, sp
 8004516:	7a02      	ldrb	r2, [r0, #8]
 8004518:	7a41      	ldrb	r1, [r0, #9]
 800451a:	68f7      	ldr	r7, [r6, #12]
 800451c:	2001      	movs	r0, #1
 800451e:	4038      	ands	r0, r7
 8004520:	f000 fd50 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8004524:	2803      	cmp	r0, #3
 8004526:	d117      	bne.n	8004558 <PE_Send_ExtendedMessage+0x94>
 8004528:	6870      	ldr	r0, [r6, #4]
 800452a:	6800      	ldr	r0, [r0, #0]
 800452c:	0ac0      	lsrs	r0, r0, #11
 800452e:	4004      	ands	r4, r0
 8004530:	d1e8      	bne.n	8004504 <PE_Send_ExtendedMessage+0x40>
 8004532:	9803      	ldr	r0, [sp, #12]
 8004534:	7005      	strb	r5, [r0, #0]
 8004536:	2010      	movs	r0, #16
 8004538:	e00c      	b.n	8004554 <PE_Send_ExtendedMessage+0x90>
 800453a:	6870      	ldr	r0, [r6, #4]
 800453c:	7840      	ldrb	r0, [r0, #1]
 800453e:	0640      	lsls	r0, r0, #25
 8004540:	0f40      	lsrs	r0, r0, #29
 8004542:	2804      	cmp	r0, #4
 8004544:	d103      	bne.n	800454e <PE_Send_ExtendedMessage+0x8a>
 8004546:	200f      	movs	r0, #15
 8004548:	9903      	ldr	r1, [sp, #12]
 800454a:	7008      	strb	r0, [r1, #0]
 800454c:	e001      	b.n	8004552 <PE_Send_ExtendedMessage+0x8e>
 800454e:	9803      	ldr	r0, [sp, #12]
 8004550:	7005      	strb	r5, [r0, #0]
 8004552:	2000      	movs	r0, #0
 8004554:	b005      	add	sp, #20
 8004556:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004558:	2805      	cmp	r0, #5
 800455a:	d004      	beq.n	8004566 <PE_Send_ExtendedMessage+0xa2>
 800455c:	2807      	cmp	r0, #7
 800455e:	d0ec      	beq.n	800453a <PE_Send_ExtendedMessage+0x76>
 8004560:	2809      	cmp	r0, #9
 8004562:	d0f7      	beq.n	8004554 <PE_Send_ExtendedMessage+0x90>
 8004564:	e7f5      	b.n	8004552 <PE_Send_ExtendedMessage+0x8e>
 8004566:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8004568:	e7ee      	b.n	8004548 <PE_Send_ExtendedMessage+0x84>

0800456a <PE_SubStateMachine_ExtendedMessages>:
 800456a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800456c:	b084      	sub	sp, #16
 800456e:	0005      	movs	r5, r0
 8004570:	2702      	movs	r7, #2
 8004572:	4886      	ldr	r0, [pc, #536]	; (800478c <.text_74>)
 8004574:	1828      	adds	r0, r5, r0
 8004576:	9002      	str	r0, [sp, #8]
 8004578:	4885      	ldr	r0, [pc, #532]	; (8004790 <.text_75>)
 800457a:	182c      	adds	r4, r5, r0
 800457c:	4985      	ldr	r1, [pc, #532]	; (8004794 <.text_76>)
 800457e:	2600      	movs	r6, #0
 8004580:	2003      	movs	r0, #3
 8004582:	7ba2      	ldrb	r2, [r4, #14]
 8004584:	2a31      	cmp	r2, #49	; 0x31
 8004586:	d016      	beq.n	80045b6 <PE_SubStateMachine_ExtendedMessages+0x4c>
 8004588:	2a32      	cmp	r2, #50	; 0x32
 800458a:	d049      	beq.n	8004620 <PE_SubStateMachine_ExtendedMessages+0xb6>
 800458c:	2a33      	cmp	r2, #51	; 0x33
 800458e:	d074      	beq.n	800467a <PE_SubStateMachine_ExtendedMessages+0x110>
 8004590:	2a34      	cmp	r2, #52	; 0x34
 8004592:	d100      	bne.n	8004596 <PE_SubStateMachine_ExtendedMessages+0x2c>
 8004594:	e083      	b.n	800469e <PE_SubStateMachine_ExtendedMessages+0x134>
 8004596:	2a35      	cmp	r2, #53	; 0x35
 8004598:	d100      	bne.n	800459c <PE_SubStateMachine_ExtendedMessages+0x32>
 800459a:	e0b6      	b.n	800470a <PE_SubStateMachine_ExtendedMessages+0x1a0>
 800459c:	2a36      	cmp	r2, #54	; 0x36
 800459e:	d100      	bne.n	80045a2 <PE_SubStateMachine_ExtendedMessages+0x38>
 80045a0:	e0c3      	b.n	800472a <PE_SubStateMachine_ExtendedMessages+0x1c0>
 80045a2:	2a37      	cmp	r2, #55	; 0x37
 80045a4:	d100      	bne.n	80045a8 <PE_SubStateMachine_ExtendedMessages+0x3e>
 80045a6:	e0c9      	b.n	800473c <PE_SubStateMachine_ExtendedMessages+0x1d2>
 80045a8:	2a38      	cmp	r2, #56	; 0x38
 80045aa:	d100      	bne.n	80045ae <PE_SubStateMachine_ExtendedMessages+0x44>
 80045ac:	e0e8      	b.n	8004780 <PE_SubStateMachine_ExtendedMessages+0x216>
 80045ae:	2aa5      	cmp	r2, #165	; 0xa5
 80045b0:	d100      	bne.n	80045b4 <PE_SubStateMachine_ExtendedMessages+0x4a>
 80045b2:	e0d9      	b.n	8004768 <PE_SubStateMachine_ExtendedMessages+0x1fe>
 80045b4:	e0e7      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 80045b6:	8026      	strh	r6, [r4, #0]
 80045b8:	2701      	movs	r7, #1
 80045ba:	68e9      	ldr	r1, [r5, #12]
 80045bc:	2001      	movs	r0, #1
 80045be:	4008      	ands	r0, r1
 80045c0:	f7ff ff70 	bl	80044a4 <PE_Get_UnchunkedSupport>
 80045c4:	2801      	cmp	r0, #1
 80045c6:	d105      	bne.n	80045d4 <PE_SubStateMachine_ExtendedMessages+0x6a>
 80045c8:	2091      	movs	r0, #145	; 0x91
 80045ca:	0080      	lsls	r0, r0, #2
 80045cc:	1828      	adds	r0, r5, r0
 80045ce:	7046      	strb	r6, [r0, #1]
 80045d0:	7006      	strb	r6, [r0, #0]
 80045d2:	e023      	b.n	800461c <PE_SubStateMachine_ExtendedMessages+0xb2>
 80045d4:	76ee      	strb	r6, [r5, #27]
 80045d6:	76ae      	strb	r6, [r5, #26]
 80045d8:	68e8      	ldr	r0, [r5, #12]
 80045da:	4007      	ands	r7, r0
 80045dc:	0038      	movs	r0, r7
 80045de:	f7ff ff61 	bl	80044a4 <PE_Get_UnchunkedSupport>
 80045e2:	2800      	cmp	r0, #0
 80045e4:	d104      	bne.n	80045f0 <PE_SubStateMachine_ExtendedMessages+0x86>
 80045e6:	8b68      	ldrh	r0, [r5, #26]
 80045e8:	2180      	movs	r1, #128	; 0x80
 80045ea:	0209      	lsls	r1, r1, #8
 80045ec:	4301      	orrs	r1, r0
 80045ee:	8369      	strh	r1, [r5, #26]
 80045f0:	4866      	ldr	r0, [pc, #408]	; (800478c <.text_74>)
 80045f2:	1828      	adds	r0, r5, r0
 80045f4:	8861      	ldrh	r1, [r4, #2]
 80045f6:	291a      	cmp	r1, #26
 80045f8:	4631      	mov	r1, r6
 80045fa:	d90c      	bls.n	8004616 <PE_SubStateMachine_ExtendedMessages+0xac>
 80045fc:	5c42      	ldrb	r2, [r0, r1]
 80045fe:	002b      	movs	r3, r5
 8004600:	331c      	adds	r3, #28
 8004602:	545a      	strb	r2, [r3, r1]
 8004604:	1c49      	adds	r1, r1, #1
 8004606:	291a      	cmp	r1, #26
 8004608:	d208      	bcs.n	800461c <PE_SubStateMachine_ExtendedMessages+0xb2>
 800460a:	e7f7      	b.n	80045fc <PE_SubStateMachine_ExtendedMessages+0x92>
 800460c:	5c42      	ldrb	r2, [r0, r1]
 800460e:	002b      	movs	r3, r5
 8004610:	331c      	adds	r3, #28
 8004612:	545a      	strb	r2, [r3, r1]
 8004614:	1c49      	adds	r1, r1, #1
 8004616:	8862      	ldrh	r2, [r4, #2]
 8004618:	4291      	cmp	r1, r2
 800461a:	d3f7      	bcc.n	800460c <PE_SubStateMachine_ExtendedMessages+0xa2>
 800461c:	2032      	movs	r0, #50	; 0x32
 800461e:	e08b      	b.n	8004738 <PE_SubStateMachine_ExtendedMessages+0x1ce>
 8004620:	0028      	movs	r0, r5
 8004622:	3018      	adds	r0, #24
 8004624:	9003      	str	r0, [sp, #12]
 8004626:	7b29      	ldrb	r1, [r5, #12]
 8004628:	07c8      	lsls	r0, r1, #31
 800462a:	0fc0      	lsrs	r0, r0, #31
 800462c:	f7ff ff3a 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004630:	2801      	cmp	r0, #1
 8004632:	d101      	bne.n	8004638 <PE_SubStateMachine_ExtendedMessages+0xce>
 8004634:	9802      	ldr	r0, [sp, #8]
 8004636:	9003      	str	r0, [sp, #12]
 8004638:	2001      	movs	r0, #1
 800463a:	68e9      	ldr	r1, [r5, #12]
 800463c:	0909      	lsrs	r1, r1, #4
 800463e:	4001      	ands	r1, r0
 8004640:	d006      	beq.n	8004650 <PE_SubStateMachine_ExtendedMessages+0xe6>
 8004642:	6869      	ldr	r1, [r5, #4]
 8004644:	7809      	ldrb	r1, [r1, #0]
 8004646:	0889      	lsrs	r1, r1, #2
 8004648:	4201      	tst	r1, r0
 800464a:	d102      	bne.n	8004652 <PE_SubStateMachine_ExtendedMessages+0xe8>
 800464c:	2002      	movs	r0, #2
 800464e:	e000      	b.n	8004652 <PE_SubStateMachine_ExtendedMessages+0xe8>
 8004650:	2000      	movs	r0, #0
 8004652:	21e4      	movs	r1, #228	; 0xe4
 8004654:	0089      	lsls	r1, r1, #2
 8004656:	186e      	adds	r6, r5, r1
 8004658:	9002      	str	r0, [sp, #8]
 800465a:	2033      	movs	r0, #51	; 0x33
 800465c:	9001      	str	r0, [sp, #4]
 800465e:	8860      	ldrh	r0, [r4, #2]
 8004660:	1d00      	adds	r0, r0, #4
 8004662:	9000      	str	r0, [sp, #0]
 8004664:	9b03      	ldr	r3, [sp, #12]
 8004666:	78f2      	ldrb	r2, [r6, #3]
 8004668:	7ae1      	ldrb	r1, [r4, #11]
 800466a:	0028      	movs	r0, r5
 800466c:	f7ff ff2a 	bl	80044c4 <PE_Send_ExtendedMessage>
 8004670:	2800      	cmp	r0, #0
 8004672:	d101      	bne.n	8004678 <PE_SubStateMachine_ExtendedMessages+0x10e>
 8004674:	88f0      	ldrh	r0, [r6, #6]
 8004676:	82e8      	strh	r0, [r5, #22]
 8004678:	e085      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800467a:	68ea      	ldr	r2, [r5, #12]
 800467c:	06d3      	lsls	r3, r2, #27
 800467e:	0fdb      	lsrs	r3, r3, #31
 8004680:	d009      	beq.n	8004696 <PE_SubStateMachine_ExtendedMessages+0x12c>
 8004682:	8461      	strh	r1, [r4, #34]	; 0x22
 8004684:	271a      	movs	r7, #26
 8004686:	20e4      	movs	r0, #228	; 0xe4
 8004688:	0080      	lsls	r0, r0, #2
 800468a:	1828      	adds	r0, r5, r0
 800468c:	78c0      	ldrb	r0, [r0, #3]
 800468e:	2884      	cmp	r0, #132	; 0x84
 8004690:	d166      	bne.n	8004760 <PE_SubStateMachine_ExtendedMessages+0x1f6>
 8004692:	2074      	movs	r0, #116	; 0x74
 8004694:	e072      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 8004696:	73a0      	strb	r0, [r4, #14]
 8004698:	2700      	movs	r7, #0
 800469a:	8466      	strh	r6, [r4, #34]	; 0x22
 800469c:	e073      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800469e:	4669      	mov	r1, sp
 80046a0:	22e4      	movs	r2, #228	; 0xe4
 80046a2:	0092      	lsls	r2, r2, #2
 80046a4:	5aaa      	ldrh	r2, [r5, r2]
 80046a6:	0452      	lsls	r2, r2, #17
 80046a8:	0f12      	lsrs	r2, r2, #28
 80046aa:	800a      	strh	r2, [r1, #0]
 80046ac:	4611      	mov	r1, r2
 80046ae:	221a      	movs	r2, #26
 80046b0:	434a      	muls	r2, r1
 80046b2:	9201      	str	r2, [sp, #4]
 80046b4:	8861      	ldrh	r1, [r4, #2]
 80046b6:	428a      	cmp	r2, r1
 80046b8:	da03      	bge.n	80046c2 <PE_SubStateMachine_ExtendedMessages+0x158>
 80046ba:	466a      	mov	r2, sp
 80046bc:	8812      	ldrh	r2, [r2, #0]
 80046be:	2a0a      	cmp	r2, #10
 80046c0:	db01      	blt.n	80046c6 <PE_SubStateMachine_ExtendedMessages+0x15c>
 80046c2:	8466      	strh	r6, [r4, #34]	; 0x22
 80046c4:	e05a      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 80046c6:	9a01      	ldr	r2, [sp, #4]
 80046c8:	1a88      	subs	r0, r1, r2
 80046ca:	281a      	cmp	r0, #26
 80046cc:	d202      	bcs.n	80046d4 <PE_SubStateMachine_ExtendedMessages+0x16a>
 80046ce:	1a89      	subs	r1, r1, r2
 80046d0:	b2c9      	uxtb	r1, r1
 80046d2:	e000      	b.n	80046d6 <PE_SubStateMachine_ExtendedMessages+0x16c>
 80046d4:	211a      	movs	r1, #26
 80046d6:	2000      	movs	r0, #0
 80046d8:	e006      	b.n	80046e8 <PE_SubStateMachine_ExtendedMessages+0x17e>
 80046da:	9b02      	ldr	r3, [sp, #8]
 80046dc:	1817      	adds	r7, r2, r0
 80046de:	5ddb      	ldrb	r3, [r3, r7]
 80046e0:	002f      	movs	r7, r5
 80046e2:	371c      	adds	r7, #28
 80046e4:	543b      	strb	r3, [r7, r0]
 80046e6:	1c40      	adds	r0, r0, #1
 80046e8:	4288      	cmp	r0, r1
 80046ea:	d3f6      	bcc.n	80046da <PE_SubStateMachine_ExtendedMessages+0x170>
 80046ec:	002b      	movs	r3, r5
 80046ee:	3318      	adds	r3, #24
 80046f0:	8862      	ldrh	r2, [r4, #2]
 80046f2:	20e4      	movs	r0, #228	; 0xe4
 80046f4:	0080      	lsls	r0, r0, #2
 80046f6:	5a28      	ldrh	r0, [r5, r0]
 80046f8:	0440      	lsls	r0, r0, #17
 80046fa:	0f01      	lsrs	r1, r0, #28
 80046fc:	7b2d      	ldrb	r5, [r5, #12]
 80046fe:	07e8      	lsls	r0, r5, #31
 8004700:	0fc0      	lsrs	r0, r0, #31
 8004702:	f001 f8cb 	bl	800589c <USBPD_PRL_PrepareExtendedTxChunkSending>
 8004706:	2035      	movs	r0, #53	; 0x35
 8004708:	e016      	b.n	8004738 <PE_SubStateMachine_ExtendedMessages+0x1ce>
 800470a:	9602      	str	r6, [sp, #8]
 800470c:	2036      	movs	r0, #54	; 0x36
 800470e:	9001      	str	r0, [sp, #4]
 8004710:	8860      	ldrh	r0, [r4, #2]
 8004712:	9000      	str	r0, [sp, #0]
 8004714:	002b      	movs	r3, r5
 8004716:	3318      	adds	r3, #24
 8004718:	20e4      	movs	r0, #228	; 0xe4
 800471a:	0080      	lsls	r0, r0, #2
 800471c:	1828      	adds	r0, r5, r0
 800471e:	78c2      	ldrb	r2, [r0, #3]
 8004720:	7ae1      	ldrb	r1, [r4, #11]
 8004722:	0028      	movs	r0, r5
 8004724:	f7ff fece 	bl	80044c4 <PE_Send_ExtendedMessage>
 8004728:	e02d      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800472a:	8026      	strh	r6, [r4, #0]
 800472c:	68ea      	ldr	r2, [r5, #12]
 800472e:	06d3      	lsls	r3, r2, #27
 8004730:	0fdb      	lsrs	r3, r3, #31
 8004732:	d001      	beq.n	8004738 <PE_SubStateMachine_ExtendedMessages+0x1ce>
 8004734:	8461      	strh	r1, [r4, #34]	; 0x22
 8004736:	2039      	movs	r0, #57	; 0x39
 8004738:	73a0      	strb	r0, [r4, #14]
 800473a:	e01d      	b.n	8004778 <PE_SubStateMachine_ExtendedMessages+0x20e>
 800473c:	8c60      	ldrh	r0, [r4, #34]	; 0x22
 800473e:	03ba      	lsls	r2, r7, #14
 8004740:	4290      	cmp	r0, r2
 8004742:	d101      	bne.n	8004748 <PE_SubStateMachine_ExtendedMessages+0x1de>
 8004744:	8466      	strh	r6, [r4, #34]	; 0x22
 8004746:	e00d      	b.n	8004764 <PE_SubStateMachine_ExtendedMessages+0x1fa>
 8004748:	8461      	strh	r1, [r4, #34]	; 0x22
 800474a:	271a      	movs	r7, #26
 800474c:	48c9      	ldr	r0, [pc, #804]	; (8004a74 <.text_78>)
 800474e:	182a      	adds	r2, r5, r0
 8004750:	7ae1      	ldrb	r1, [r4, #11]
 8004752:	7b2b      	ldrb	r3, [r5, #12]
 8004754:	07d8      	lsls	r0, r3, #31
 8004756:	0fc0      	lsrs	r0, r0, #31
 8004758:	f001 f8c8 	bl	80058ec <USBPD_PRL_ManageExtendedRx>
 800475c:	2800      	cmp	r0, #0
 800475e:	d101      	bne.n	8004764 <PE_SubStateMachine_ExtendedMessages+0x1fa>
 8004760:	2039      	movs	r0, #57	; 0x39
 8004762:	e00b      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 8004764:	200f      	movs	r0, #15
 8004766:	e009      	b.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 8004768:	7aa1      	ldrb	r1, [r4, #10]
 800476a:	2900      	cmp	r1, #0
 800476c:	d006      	beq.n	800477c <PE_SubStateMachine_ExtendedMessages+0x212>
 800476e:	7ae0      	ldrb	r0, [r4, #11]
 8004770:	7460      	strb	r0, [r4, #17]
 8004772:	7aa0      	ldrb	r0, [r4, #10]
 8004774:	73a0      	strb	r0, [r4, #14]
 8004776:	72a6      	strb	r6, [r4, #10]
 8004778:	2700      	movs	r7, #0
 800477a:	e004      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 800477c:	73a0      	strb	r0, [r4, #14]
 800477e:	e002      	b.n	8004786 <PE_SubStateMachine_ExtendedMessages+0x21c>
 8004780:	8466      	strh	r6, [r4, #34]	; 0x22
 8004782:	73a0      	strb	r0, [r4, #14]
 8004784:	8026      	strh	r6, [r4, #0]
 8004786:	0038      	movs	r0, r7
 8004788:	b005      	add	sp, #20
 800478a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800478c <.text_74>:
 800478c:	00000242 	.word	0x00000242

08004790 <.text_75>:
 8004790:	0000034a 	.word	0x0000034a

08004794 <.text_76>:
 8004794:	0000801a 	.word	0x0000801a

08004798 <PE_SubStateMachine_Generic>:
 8004798:	b5f0      	push	{r4, r5, r6, r7, lr}
 800479a:	b085      	sub	sp, #20
 800479c:	0004      	movs	r4, r0
 800479e:	2601      	movs	r6, #1
 80047a0:	2703      	movs	r7, #3
 80047a2:	2500      	movs	r5, #0
 80047a4:	20d6      	movs	r0, #214	; 0xd6
 80047a6:	0080      	lsls	r0, r0, #2
 80047a8:	5c20      	ldrb	r0, [r4, r0]
 80047aa:	2801      	cmp	r0, #1
 80047ac:	d013      	beq.n	80047d6 <PE_SubStateMachine_Generic+0x3e>
 80047ae:	282c      	cmp	r0, #44	; 0x2c
 80047b0:	d100      	bne.n	80047b4 <PE_SubStateMachine_Generic+0x1c>
 80047b2:	e136      	b.n	8004a22 <PE_SubStateMachine_Generic+0x28a>
 80047b4:	2830      	cmp	r0, #48	; 0x30
 80047b6:	d05a      	beq.n	800486e <PE_SubStateMachine_Generic+0xd6>
 80047b8:	283a      	cmp	r0, #58	; 0x3a
 80047ba:	d100      	bne.n	80047be <PE_SubStateMachine_Generic+0x26>
 80047bc:	e10b      	b.n	80049d6 <PE_SubStateMachine_Generic+0x23e>
 80047be:	283b      	cmp	r0, #59	; 0x3b
 80047c0:	d100      	bne.n	80047c4 <PE_SubStateMachine_Generic+0x2c>
 80047c2:	e0e6      	b.n	8004992 <PE_SubStateMachine_Generic+0x1fa>
 80047c4:	283c      	cmp	r0, #60	; 0x3c
 80047c6:	d100      	bne.n	80047ca <PE_SubStateMachine_Generic+0x32>
 80047c8:	e0c1      	b.n	800494e <PE_SubStateMachine_Generic+0x1b6>
 80047ca:	2863      	cmp	r0, #99	; 0x63
 80047cc:	d01a      	beq.n	8004804 <PE_SubStateMachine_Generic+0x6c>
 80047ce:	2874      	cmp	r0, #116	; 0x74
 80047d0:	d100      	bne.n	80047d4 <PE_SubStateMachine_Generic+0x3c>
 80047d2:	e087      	b.n	80048e4 <PE_SubStateMachine_Generic+0x14c>
 80047d4:	e147      	b.n	8004a66 <PE_SubStateMachine_Generic+0x2ce>
 80047d6:	9500      	str	r5, [sp, #0]
 80047d8:	2303      	movs	r3, #3
 80047da:	2210      	movs	r2, #16
 80047dc:	2100      	movs	r1, #0
 80047de:	0020      	movs	r0, r4
 80047e0:	f7fe ffc7 	bl	8003772 <PE_Send_CtrlMessage>
 80047e4:	4da4      	ldr	r5, [pc, #656]	; (8004a78 <.text_79>)
 80047e6:	7828      	ldrb	r0, [r5, #0]
 80047e8:	0780      	lsls	r0, r0, #30
 80047ea:	d509      	bpl.n	8004800 <PE_SubStateMachine_Generic+0x68>
 80047ec:	2000      	movs	r0, #0
 80047ee:	9000      	str	r0, [sp, #0]
 80047f0:	2300      	movs	r3, #0
 80047f2:	2255      	movs	r2, #85	; 0x55
 80047f4:	68e0      	ldr	r0, [r4, #12]
 80047f6:	2101      	movs	r1, #1
 80047f8:	4001      	ands	r1, r0
 80047fa:	2009      	movs	r0, #9
 80047fc:	68ed      	ldr	r5, [r5, #12]
 80047fe:	47a8      	blx	r5
 8004800:	2155      	movs	r1, #85	; 0x55
 8004802:	e068      	b.n	80048d6 <PE_SubStateMachine_Generic+0x13e>
 8004804:	9503      	str	r5, [sp, #12]
 8004806:	ab03      	add	r3, sp, #12
 8004808:	0022      	movs	r2, r4
 800480a:	321c      	adds	r2, #28
 800480c:	2108      	movs	r1, #8
 800480e:	68e7      	ldr	r7, [r4, #12]
 8004810:	2001      	movs	r0, #1
 8004812:	4038      	ands	r0, r7
 8004814:	68a7      	ldr	r7, [r4, #8]
 8004816:	69bf      	ldr	r7, [r7, #24]
 8004818:	47b8      	blx	r7
 800481a:	76e5      	strb	r5, [r4, #27]
 800481c:	76a5      	strb	r5, [r4, #26]
 800481e:	68e1      	ldr	r1, [r4, #12]
 8004820:	2001      	movs	r0, #1
 8004822:	4008      	ands	r0, r1
 8004824:	f7ff fe3e 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004828:	2800      	cmp	r0, #0
 800482a:	d103      	bne.n	8004834 <PE_SubStateMachine_Generic+0x9c>
 800482c:	8b60      	ldrh	r0, [r4, #26]
 800482e:	03f1      	lsls	r1, r6, #15
 8004830:	4301      	orrs	r1, r0
 8004832:	8361      	strh	r1, [r4, #26]
 8004834:	9502      	str	r5, [sp, #8]
 8004836:	2003      	movs	r0, #3
 8004838:	9001      	str	r0, [sp, #4]
 800483a:	9803      	ldr	r0, [sp, #12]
 800483c:	1d00      	adds	r0, r0, #4
 800483e:	9000      	str	r0, [sp, #0]
 8004840:	0023      	movs	r3, r4
 8004842:	3318      	adds	r3, #24
 8004844:	2281      	movs	r2, #129	; 0x81
 8004846:	2100      	movs	r1, #0
 8004848:	0020      	movs	r0, r4
 800484a:	f7ff fe3b 	bl	80044c4 <PE_Send_ExtendedMessage>
 800484e:	4d8a      	ldr	r5, [pc, #552]	; (8004a78 <.text_79>)
 8004850:	7828      	ldrb	r0, [r5, #0]
 8004852:	0780      	lsls	r0, r0, #30
 8004854:	d509      	bpl.n	800486a <PE_SubStateMachine_Generic+0xd2>
 8004856:	2000      	movs	r0, #0
 8004858:	9000      	str	r0, [sp, #0]
 800485a:	2300      	movs	r3, #0
 800485c:	2245      	movs	r2, #69	; 0x45
 800485e:	68e0      	ldr	r0, [r4, #12]
 8004860:	2101      	movs	r1, #1
 8004862:	4001      	ands	r1, r0
 8004864:	2009      	movs	r0, #9
 8004866:	68ed      	ldr	r5, [r5, #12]
 8004868:	47a8      	blx	r5
 800486a:	2145      	movs	r1, #69	; 0x45
 800486c:	e033      	b.n	80048d6 <PE_SubStateMachine_Generic+0x13e>
 800486e:	9503      	str	r5, [sp, #12]
 8004870:	ab03      	add	r3, sp, #12
 8004872:	0022      	movs	r2, r4
 8004874:	321c      	adds	r2, #28
 8004876:	2109      	movs	r1, #9
 8004878:	68e7      	ldr	r7, [r4, #12]
 800487a:	2001      	movs	r0, #1
 800487c:	4038      	ands	r0, r7
 800487e:	68a7      	ldr	r7, [r4, #8]
 8004880:	69bf      	ldr	r7, [r7, #24]
 8004882:	47b8      	blx	r7
 8004884:	76e5      	strb	r5, [r4, #27]
 8004886:	76a5      	strb	r5, [r4, #26]
 8004888:	68e1      	ldr	r1, [r4, #12]
 800488a:	2001      	movs	r0, #1
 800488c:	4008      	ands	r0, r1
 800488e:	f7ff fe09 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004892:	2800      	cmp	r0, #0
 8004894:	d103      	bne.n	800489e <PE_SubStateMachine_Generic+0x106>
 8004896:	8b60      	ldrh	r0, [r4, #26]
 8004898:	03f1      	lsls	r1, r6, #15
 800489a:	4301      	orrs	r1, r0
 800489c:	8361      	strh	r1, [r4, #26]
 800489e:	9502      	str	r5, [sp, #8]
 80048a0:	2003      	movs	r0, #3
 80048a2:	9001      	str	r0, [sp, #4]
 80048a4:	9803      	ldr	r0, [sp, #12]
 80048a6:	1d00      	adds	r0, r0, #4
 80048a8:	9000      	str	r0, [sp, #0]
 80048aa:	0023      	movs	r3, r4
 80048ac:	3318      	adds	r3, #24
 80048ae:	2282      	movs	r2, #130	; 0x82
 80048b0:	2100      	movs	r1, #0
 80048b2:	0020      	movs	r0, r4
 80048b4:	f7ff fe06 	bl	80044c4 <PE_Send_ExtendedMessage>
 80048b8:	4d6f      	ldr	r5, [pc, #444]	; (8004a78 <.text_79>)
 80048ba:	7828      	ldrb	r0, [r5, #0]
 80048bc:	0780      	lsls	r0, r0, #30
 80048be:	d509      	bpl.n	80048d4 <PE_SubStateMachine_Generic+0x13c>
 80048c0:	2000      	movs	r0, #0
 80048c2:	9000      	str	r0, [sp, #0]
 80048c4:	2300      	movs	r3, #0
 80048c6:	224c      	movs	r2, #76	; 0x4c
 80048c8:	68e0      	ldr	r0, [r4, #12]
 80048ca:	2101      	movs	r1, #1
 80048cc:	4001      	ands	r1, r0
 80048ce:	2009      	movs	r0, #9
 80048d0:	68ed      	ldr	r5, [r5, #12]
 80048d2:	47a8      	blx	r5
 80048d4:	214c      	movs	r1, #76	; 0x4c
 80048d6:	68e0      	ldr	r0, [r4, #12]
 80048d8:	4006      	ands	r6, r0
 80048da:	0030      	movs	r0, r6
 80048dc:	68a2      	ldr	r2, [r4, #8]
 80048de:	68d2      	ldr	r2, [r2, #12]
 80048e0:	4790      	blx	r2
 80048e2:	e0c3      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 80048e4:	9100      	str	r1, [sp, #0]
 80048e6:	7808      	ldrb	r0, [r1, #0]
 80048e8:	2814      	cmp	r0, #20
 80048ea:	d025      	beq.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 80048ec:	20d6      	movs	r0, #214	; 0xd6
 80048ee:	0080      	lsls	r0, r0, #2
 80048f0:	1820      	adds	r0, r4, r0
 80048f2:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
 80048f4:	0bc0      	lsrs	r0, r0, #15
 80048f6:	d11f      	bne.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 80048f8:	20d6      	movs	r0, #214	; 0xd6
 80048fa:	0080      	lsls	r0, r0, #2
 80048fc:	1820      	adds	r0, r4, r0
 80048fe:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
 8004900:	0440      	lsls	r0, r0, #17
 8004902:	0f40      	lsrs	r0, r0, #29
 8004904:	d018      	beq.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 8004906:	20d6      	movs	r0, #214	; 0xd6
 8004908:	0080      	lsls	r0, r0, #2
 800490a:	1820      	adds	r0, r4, r0
 800490c:	8d80      	ldrh	r0, [r0, #44]	; 0x2c
 800490e:	06c0      	lsls	r0, r0, #27
 8004910:	0ec0      	lsrs	r0, r0, #27
 8004912:	2805      	cmp	r0, #5
 8004914:	d110      	bne.n	8004938 <PE_SubStateMachine_Generic+0x1a0>
 8004916:	2318      	movs	r3, #24
 8004918:	209f      	movs	r0, #159	; 0x9f
 800491a:	0040      	lsls	r0, r0, #1
 800491c:	1822      	adds	r2, r4, r0
 800491e:	210f      	movs	r1, #15
 8004920:	68e0      	ldr	r0, [r4, #12]
 8004922:	4006      	ands	r6, r0
 8004924:	0030      	movs	r0, r6
 8004926:	68a6      	ldr	r6, [r4, #8]
 8004928:	69f6      	ldr	r6, [r6, #28]
 800492a:	47b0      	blx	r6
 800492c:	20d6      	movs	r0, #214	; 0xd6
 800492e:	0080      	lsls	r0, r0, #2
 8004930:	5427      	strb	r7, [r4, r0]
 8004932:	2014      	movs	r0, #20
 8004934:	9900      	ldr	r1, [sp, #0]
 8004936:	7008      	strb	r0, [r1, #0]
 8004938:	20d6      	movs	r0, #214	; 0xd6
 800493a:	0080      	lsls	r0, r0, #2
 800493c:	1820      	adds	r0, r4, r0
 800493e:	8a81      	ldrh	r1, [r0, #20]
 8004940:	2280      	movs	r2, #128	; 0x80
 8004942:	0212      	lsls	r2, r2, #8
 8004944:	4291      	cmp	r1, r2
 8004946:	d101      	bne.n	800494c <PE_SubStateMachine_Generic+0x1b4>
 8004948:	8285      	strh	r5, [r0, #20]
 800494a:	7007      	strb	r7, [r0, #0]
 800494c:	e08e      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 800494e:	ab03      	add	r3, sp, #12
 8004950:	0022      	movs	r2, r4
 8004952:	321c      	adds	r2, #28
 8004954:	210d      	movs	r1, #13
 8004956:	68e7      	ldr	r7, [r4, #12]
 8004958:	2001      	movs	r0, #1
 800495a:	4038      	ands	r0, r7
 800495c:	68a7      	ldr	r7, [r4, #8]
 800495e:	69bf      	ldr	r7, [r7, #24]
 8004960:	47b8      	blx	r7
 8004962:	76e5      	strb	r5, [r4, #27]
 8004964:	76a5      	strb	r5, [r4, #26]
 8004966:	68e0      	ldr	r0, [r4, #12]
 8004968:	4006      	ands	r6, r0
 800496a:	0030      	movs	r0, r6
 800496c:	f7ff fd9a 	bl	80044a4 <PE_Get_UnchunkedSupport>
 8004970:	2800      	cmp	r0, #0
 8004972:	d104      	bne.n	800497e <PE_SubStateMachine_Generic+0x1e6>
 8004974:	8b60      	ldrh	r0, [r4, #26]
 8004976:	2180      	movs	r1, #128	; 0x80
 8004978:	0209      	lsls	r1, r1, #8
 800497a:	4301      	orrs	r1, r0
 800497c:	8361      	strh	r1, [r4, #26]
 800497e:	9502      	str	r5, [sp, #8]
 8004980:	2003      	movs	r0, #3
 8004982:	9001      	str	r0, [sp, #4]
 8004984:	9803      	ldr	r0, [sp, #12]
 8004986:	1d00      	adds	r0, r0, #4
 8004988:	9000      	str	r0, [sp, #0]
 800498a:	0023      	movs	r3, r4
 800498c:	3318      	adds	r3, #24
 800498e:	2287      	movs	r2, #135	; 0x87
 8004990:	e042      	b.n	8004a18 <PE_SubStateMachine_Generic+0x280>
 8004992:	9503      	str	r5, [sp, #12]
 8004994:	ab04      	add	r3, sp, #16
 8004996:	0022      	movs	r2, r4
 8004998:	321c      	adds	r2, #28
 800499a:	210f      	movs	r1, #15
 800499c:	68e0      	ldr	r0, [r4, #12]
 800499e:	4006      	ands	r6, r0
 80049a0:	0030      	movs	r0, r6
 80049a2:	68a5      	ldr	r5, [r4, #8]
 80049a4:	69ad      	ldr	r5, [r5, #24]
 80049a6:	47a8      	blx	r5
 80049a8:	7fe0      	ldrb	r0, [r4, #31]
 80049aa:	0600      	lsls	r0, r0, #24
 80049ac:	7fa1      	ldrb	r1, [r4, #30]
 80049ae:	0409      	lsls	r1, r1, #16
 80049b0:	4301      	orrs	r1, r0
 80049b2:	7f60      	ldrb	r0, [r4, #29]
 80049b4:	0200      	lsls	r0, r0, #8
 80049b6:	4308      	orrs	r0, r1
 80049b8:	7f21      	ldrb	r1, [r4, #28]
 80049ba:	4301      	orrs	r1, r0
 80049bc:	9103      	str	r1, [sp, #12]
 80049be:	2000      	movs	r0, #0
 80049c0:	9002      	str	r0, [sp, #8]
 80049c2:	9701      	str	r7, [sp, #4]
 80049c4:	2001      	movs	r0, #1
 80049c6:	9000      	str	r0, [sp, #0]
 80049c8:	ab03      	add	r3, sp, #12
 80049ca:	2205      	movs	r2, #5
 80049cc:	2100      	movs	r1, #0
 80049ce:	0020      	movs	r0, r4
 80049d0:	f7fe ff16 	bl	8003800 <PE_Send_DataMessage>
 80049d4:	e04a      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 80049d6:	ab03      	add	r3, sp, #12
 80049d8:	0022      	movs	r2, r4
 80049da:	321c      	adds	r2, #28
 80049dc:	2111      	movs	r1, #17
 80049de:	68e7      	ldr	r7, [r4, #12]
 80049e0:	2001      	movs	r0, #1
 80049e2:	4038      	ands	r0, r7
 80049e4:	68a7      	ldr	r7, [r4, #8]
 80049e6:	69bf      	ldr	r7, [r7, #24]
 80049e8:	47b8      	blx	r7
 80049ea:	76e5      	strb	r5, [r4, #27]
 80049ec:	76a5      	strb	r5, [r4, #26]
 80049ee:	68e0      	ldr	r0, [r4, #12]
 80049f0:	4006      	ands	r6, r0
 80049f2:	0030      	movs	r0, r6
 80049f4:	f7ff fd56 	bl	80044a4 <PE_Get_UnchunkedSupport>
 80049f8:	2800      	cmp	r0, #0
 80049fa:	d104      	bne.n	8004a06 <PE_SubStateMachine_Generic+0x26e>
 80049fc:	8b60      	ldrh	r0, [r4, #26]
 80049fe:	2180      	movs	r1, #128	; 0x80
 8004a00:	0209      	lsls	r1, r1, #8
 8004a02:	4301      	orrs	r1, r0
 8004a04:	8361      	strh	r1, [r4, #26]
 8004a06:	9502      	str	r5, [sp, #8]
 8004a08:	2003      	movs	r0, #3
 8004a0a:	9001      	str	r0, [sp, #4]
 8004a0c:	9803      	ldr	r0, [sp, #12]
 8004a0e:	1d00      	adds	r0, r0, #4
 8004a10:	9000      	str	r0, [sp, #0]
 8004a12:	0023      	movs	r3, r4
 8004a14:	3318      	adds	r3, #24
 8004a16:	2285      	movs	r2, #133	; 0x85
 8004a18:	2100      	movs	r1, #0
 8004a1a:	0020      	movs	r0, r4
 8004a1c:	f7ff fd52 	bl	80044c4 <PE_Send_ExtendedMessage>
 8004a20:	e024      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 8004a22:	4d15      	ldr	r5, [pc, #84]	; (8004a78 <.text_79>)
 8004a24:	7828      	ldrb	r0, [r5, #0]
 8004a26:	0780      	lsls	r0, r0, #30
 8004a28:	d509      	bpl.n	8004a3e <PE_SubStateMachine_Generic+0x2a6>
 8004a2a:	2000      	movs	r0, #0
 8004a2c:	9000      	str	r0, [sp, #0]
 8004a2e:	2300      	movs	r3, #0
 8004a30:	224d      	movs	r2, #77	; 0x4d
 8004a32:	68e0      	ldr	r0, [r4, #12]
 8004a34:	2101      	movs	r1, #1
 8004a36:	4001      	ands	r1, r0
 8004a38:	2009      	movs	r0, #9
 8004a3a:	68ed      	ldr	r5, [r5, #12]
 8004a3c:	47a8      	blx	r5
 8004a3e:	214d      	movs	r1, #77	; 0x4d
 8004a40:	68e2      	ldr	r2, [r4, #12]
 8004a42:	2001      	movs	r0, #1
 8004a44:	4010      	ands	r0, r2
 8004a46:	68a2      	ldr	r2, [r4, #8]
 8004a48:	68d2      	ldr	r2, [r2, #12]
 8004a4a:	4790      	blx	r2
 8004a4c:	2300      	movs	r3, #0
 8004a4e:	2200      	movs	r2, #0
 8004a50:	210b      	movs	r1, #11
 8004a52:	68e0      	ldr	r0, [r4, #12]
 8004a54:	4006      	ands	r6, r0
 8004a56:	0030      	movs	r0, r6
 8004a58:	68a5      	ldr	r5, [r4, #8]
 8004a5a:	69ad      	ldr	r5, [r5, #24]
 8004a5c:	47a8      	blx	r5
 8004a5e:	20d6      	movs	r0, #214	; 0xd6
 8004a60:	0080      	lsls	r0, r0, #2
 8004a62:	5427      	strb	r7, [r4, r0]
 8004a64:	e002      	b.n	8004a6c <PE_SubStateMachine_Generic+0x2d4>
 8004a66:	20d6      	movs	r0, #214	; 0xd6
 8004a68:	0080      	lsls	r0, r0, #2
 8004a6a:	5426      	strb	r6, [r4, r0]
 8004a6c:	2002      	movs	r0, #2
 8004a6e:	b005      	add	sp, #20
 8004a70:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08004a74 <.text_78>:
 8004a74:	00000392 	.word	0x00000392

08004a78 <.text_79>:
 8004a78:	200019a8 	.word	0x200019a8

08004a7c <PE_SubStateMachine_VconnSwap>:
 8004a7c:	b5f2      	push	{r1, r4, r5, r6, r7, lr}
 8004a7e:	b082      	sub	sp, #8
 8004a80:	0004      	movs	r4, r0
 8004a82:	2002      	movs	r0, #2
 8004a84:	9001      	str	r0, [sp, #4]
 8004a86:	20d6      	movs	r0, #214	; 0xd6
 8004a88:	0080      	lsls	r0, r0, #2
 8004a8a:	1826      	adds	r6, r4, r0
 8004a8c:	201f      	movs	r0, #31
 8004a8e:	4d82      	ldr	r5, [pc, #520]	; (8004c98 <PE_SubStateMachine_VconnSwap+0x21c>)
 8004a90:	2107      	movs	r1, #7
 8004a92:	7832      	ldrb	r2, [r6, #0]
 8004a94:	2a9d      	cmp	r2, #157	; 0x9d
 8004a96:	d011      	beq.n	8004abc <PE_SubStateMachine_VconnSwap+0x40>
 8004a98:	d30f      	bcc.n	8004aba <PE_SubStateMachine_VconnSwap+0x3e>
 8004a9a:	2a9f      	cmp	r2, #159	; 0x9f
 8004a9c:	d077      	beq.n	8004b8e <PE_SubStateMachine_VconnSwap+0x112>
 8004a9e:	d34b      	bcc.n	8004b38 <PE_SubStateMachine_VconnSwap+0xbc>
 8004aa0:	2aa1      	cmp	r2, #161	; 0xa1
 8004aa2:	d100      	bne.n	8004aa6 <PE_SubStateMachine_VconnSwap+0x2a>
 8004aa4:	e0b0      	b.n	8004c08 <PE_SubStateMachine_VconnSwap+0x18c>
 8004aa6:	d200      	bcs.n	8004aaa <PE_SubStateMachine_VconnSwap+0x2e>
 8004aa8:	e0a3      	b.n	8004bf2 <PE_SubStateMachine_VconnSwap+0x176>
 8004aaa:	2aa3      	cmp	r2, #163	; 0xa3
 8004aac:	d100      	bne.n	8004ab0 <PE_SubStateMachine_VconnSwap+0x34>
 8004aae:	e0f5      	b.n	8004c9c <PE_SubStateMachine_VconnSwap+0x220>
 8004ab0:	d200      	bcs.n	8004ab4 <PE_SubStateMachine_VconnSwap+0x38>
 8004ab2:	e0c9      	b.n	8004c48 <PE_SubStateMachine_VconnSwap+0x1cc>
 8004ab4:	2aa4      	cmp	r2, #164	; 0xa4
 8004ab6:	d100      	bne.n	8004aba <PE_SubStateMachine_VconnSwap+0x3e>
 8004ab8:	e18f      	b.n	8004dda <PE_SubStateMachine_VconnSwap+0x35e>
 8004aba:	e1a3      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004abc:	6860      	ldr	r0, [r4, #4]
 8004abe:	2703      	movs	r7, #3
 8004ac0:	7842      	ldrb	r2, [r0, #1]
 8004ac2:	0912      	lsrs	r2, r2, #4
 8004ac4:	4011      	ands	r1, r2
 8004ac6:	2903      	cmp	r1, #3
 8004ac8:	d169      	bne.n	8004b9e <PE_SubStateMachine_VconnSwap+0x122>
 8004aca:	6800      	ldr	r0, [r0, #0]
 8004acc:	0501      	lsls	r1, r0, #20
 8004ace:	0fc9      	lsrs	r1, r1, #31
 8004ad0:	d065      	beq.n	8004b9e <PE_SubStateMachine_VconnSwap+0x122>
 8004ad2:	7b21      	ldrb	r1, [r4, #12]
 8004ad4:	07c8      	lsls	r0, r1, #31
 8004ad6:	0fc0      	lsrs	r0, r0, #31
 8004ad8:	68a1      	ldr	r1, [r4, #8]
 8004ada:	6b09      	ldr	r1, [r1, #48]	; 0x30
 8004adc:	4788      	blx	r1
 8004ade:	280a      	cmp	r0, #10
 8004ae0:	d002      	beq.n	8004ae8 <PE_SubStateMachine_VconnSwap+0x6c>
 8004ae2:	280d      	cmp	r0, #13
 8004ae4:	d008      	beq.n	8004af8 <PE_SubStateMachine_VconnSwap+0x7c>
 8004ae6:	e01e      	b.n	8004b26 <PE_SubStateMachine_VconnSwap+0xaa>
 8004ae8:	209e      	movs	r0, #158	; 0x9e
 8004aea:	7030      	strb	r0, [r6, #0]
 8004aec:	68e0      	ldr	r0, [r4, #12]
 8004aee:	2180      	movs	r1, #128	; 0x80
 8004af0:	0109      	lsls	r1, r1, #4
 8004af2:	4301      	orrs	r1, r0
 8004af4:	60e1      	str	r1, [r4, #12]
 8004af6:	e185      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004af8:	2000      	movs	r0, #0
 8004afa:	9000      	str	r0, [sp, #0]
 8004afc:	2303      	movs	r3, #3
 8004afe:	220c      	movs	r2, #12
 8004b00:	2100      	movs	r1, #0
 8004b02:	0020      	movs	r0, r4
 8004b04:	f7fe fe35 	bl	8003772 <PE_Send_CtrlMessage>
 8004b08:	7828      	ldrb	r0, [r5, #0]
 8004b0a:	0780      	lsls	r0, r0, #30
 8004b0c:	d509      	bpl.n	8004b22 <PE_SubStateMachine_VconnSwap+0xa6>
 8004b0e:	2000      	movs	r0, #0
 8004b10:	9000      	str	r0, [sp, #0]
 8004b12:	2300      	movs	r3, #0
 8004b14:	223e      	movs	r2, #62	; 0x3e
 8004b16:	7b20      	ldrb	r0, [r4, #12]
 8004b18:	07c1      	lsls	r1, r0, #31
 8004b1a:	0fc9      	lsrs	r1, r1, #31
 8004b1c:	2009      	movs	r0, #9
 8004b1e:	68ed      	ldr	r5, [r5, #12]
 8004b20:	47a8      	blx	r5
 8004b22:	213e      	movs	r1, #62	; 0x3e
 8004b24:	e08c      	b.n	8004c40 <PE_SubStateMachine_VconnSwap+0x1c4>
 8004b26:	2000      	movs	r0, #0
 8004b28:	9000      	str	r0, [sp, #0]
 8004b2a:	2303      	movs	r3, #3
 8004b2c:	2204      	movs	r2, #4
 8004b2e:	2100      	movs	r1, #0
 8004b30:	0020      	movs	r0, r4
 8004b32:	f7fe fe1e 	bl	8003772 <PE_Send_CtrlMessage>
 8004b36:	e036      	b.n	8004ba6 <PE_SubStateMachine_VconnSwap+0x12a>
 8004b38:	2000      	movs	r0, #0
 8004b3a:	9000      	str	r0, [sp, #0]
 8004b3c:	239e      	movs	r3, #158	; 0x9e
 8004b3e:	2203      	movs	r2, #3
 8004b40:	2100      	movs	r1, #0
 8004b42:	0020      	movs	r0, r4
 8004b44:	f7fe fe15 	bl	8003772 <PE_Send_CtrlMessage>
 8004b48:	2800      	cmp	r0, #0
 8004b4a:	d1d4      	bne.n	8004af6 <PE_SubStateMachine_VconnSwap+0x7a>
 8004b4c:	2701      	movs	r7, #1
 8004b4e:	6860      	ldr	r0, [r4, #4]
 8004b50:	6800      	ldr	r0, [r0, #0]
 8004b52:	0c80      	lsrs	r0, r0, #18
 8004b54:	4038      	ands	r0, r7
 8004b56:	d006      	beq.n	8004b66 <PE_SubStateMachine_VconnSwap+0xea>
 8004b58:	209f      	movs	r0, #159	; 0x9f
 8004b5a:	7030      	strb	r0, [r6, #0]
 8004b5c:	48aa      	ldr	r0, [pc, #680]	; (8004e08 <.text_81>)
 8004b5e:	84f0      	strh	r0, [r6, #38]	; 0x26
 8004b60:	2064      	movs	r0, #100	; 0x64
 8004b62:	9001      	str	r0, [sp, #4]
 8004b64:	e001      	b.n	8004b6a <PE_SubStateMachine_VconnSwap+0xee>
 8004b66:	20a0      	movs	r0, #160	; 0xa0
 8004b68:	7030      	strb	r0, [r6, #0]
 8004b6a:	7828      	ldrb	r0, [r5, #0]
 8004b6c:	0780      	lsls	r0, r0, #30
 8004b6e:	d509      	bpl.n	8004b84 <PE_SubStateMachine_VconnSwap+0x108>
 8004b70:	2000      	movs	r0, #0
 8004b72:	9000      	str	r0, [sp, #0]
 8004b74:	2300      	movs	r3, #0
 8004b76:	223d      	movs	r2, #61	; 0x3d
 8004b78:	68e0      	ldr	r0, [r4, #12]
 8004b7a:	2101      	movs	r1, #1
 8004b7c:	4001      	ands	r1, r0
 8004b7e:	2009      	movs	r0, #9
 8004b80:	68ed      	ldr	r5, [r5, #12]
 8004b82:	47a8      	blx	r5
 8004b84:	213d      	movs	r1, #61	; 0x3d
 8004b86:	68e0      	ldr	r0, [r4, #12]
 8004b88:	4007      	ands	r7, r0
 8004b8a:	0038      	movs	r0, r7
 8004b8c:	e080      	b.n	8004c90 <PE_SubStateMachine_VconnSwap+0x214>
 8004b8e:	2703      	movs	r7, #3
 8004b90:	8cf2      	ldrh	r2, [r6, #38]	; 0x26
 8004b92:	2380      	movs	r3, #128	; 0x80
 8004b94:	021b      	lsls	r3, r3, #8
 8004b96:	429a      	cmp	r2, r3
 8004b98:	d107      	bne.n	8004baa <PE_SubStateMachine_VconnSwap+0x12e>
 8004b9a:	2000      	movs	r0, #0
 8004b9c:	84f0      	strh	r0, [r6, #38]	; 0x26
 8004b9e:	68e0      	ldr	r0, [r4, #12]
 8004ba0:	499a      	ldr	r1, [pc, #616]	; (8004e0c <.text_82>)
 8004ba2:	4001      	ands	r1, r0
 8004ba4:	60e1      	str	r1, [r4, #12]
 8004ba6:	7037      	strb	r7, [r6, #0]
 8004ba8:	e12c      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004baa:	9a02      	ldr	r2, [sp, #8]
 8004bac:	7812      	ldrb	r2, [r2, #0]
 8004bae:	2a11      	cmp	r2, #17
 8004bb0:	d1fa      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bb2:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004bb4:	0bd2      	lsrs	r2, r2, #15
 8004bb6:	d1f7      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bb8:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004bba:	0b12      	lsrs	r2, r2, #12
 8004bbc:	420a      	tst	r2, r1
 8004bbe:	d1f3      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bc0:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 8004bc2:	4008      	ands	r0, r1
 8004bc4:	2806      	cmp	r0, #6
 8004bc6:	d1ef      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004bc8:	2014      	movs	r0, #20
 8004bca:	9902      	ldr	r1, [sp, #8]
 8004bcc:	7008      	strb	r0, [r1, #0]
 8004bce:	68a0      	ldr	r0, [r4, #8]
 8004bd0:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004bd2:	2a00      	cmp	r2, #0
 8004bd4:	d004      	beq.n	8004be0 <PE_SubStateMachine_VconnSwap+0x164>
 8004bd6:	2100      	movs	r1, #0
 8004bd8:	7b23      	ldrb	r3, [r4, #12]
 8004bda:	07d8      	lsls	r0, r3, #31
 8004bdc:	0fc0      	lsrs	r0, r0, #31
 8004bde:	4790      	blx	r2
 8004be0:	68e0      	ldr	r0, [r4, #12]
 8004be2:	498a      	ldr	r1, [pc, #552]	; (8004e0c <.text_82>)
 8004be4:	4001      	ands	r1, r0
 8004be6:	60e1      	str	r1, [r4, #12]
 8004be8:	7037      	strb	r7, [r6, #0]
 8004bea:	7828      	ldrb	r0, [r5, #0]
 8004bec:	0780      	lsls	r0, r0, #30
 8004bee:	d41c      	bmi.n	8004c2a <PE_SubStateMachine_VconnSwap+0x1ae>
 8004bf0:	e025      	b.n	8004c3e <PE_SubStateMachine_VconnSwap+0x1c2>
 8004bf2:	68a0      	ldr	r0, [r4, #8]
 8004bf4:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004bf6:	2a00      	cmp	r2, #0
 8004bf8:	d004      	beq.n	8004c04 <PE_SubStateMachine_VconnSwap+0x188>
 8004bfa:	2101      	movs	r1, #1
 8004bfc:	7b23      	ldrb	r3, [r4, #12]
 8004bfe:	07d8      	lsls	r0, r3, #31
 8004c00:	0fc0      	lsrs	r0, r0, #31
 8004c02:	4790      	blx	r2
 8004c04:	20a1      	movs	r0, #161	; 0xa1
 8004c06:	e0fc      	b.n	8004e02 <PE_SubStateMachine_VconnSwap+0x386>
 8004c08:	2000      	movs	r0, #0
 8004c0a:	9000      	str	r0, [sp, #0]
 8004c0c:	2303      	movs	r3, #3
 8004c0e:	2206      	movs	r2, #6
 8004c10:	2100      	movs	r1, #0
 8004c12:	0020      	movs	r0, r4
 8004c14:	f7fe fdad 	bl	8003772 <PE_Send_CtrlMessage>
 8004c18:	2800      	cmp	r0, #0
 8004c1a:	d1c5      	bne.n	8004ba8 <PE_SubStateMachine_VconnSwap+0x12c>
 8004c1c:	68e0      	ldr	r0, [r4, #12]
 8004c1e:	497b      	ldr	r1, [pc, #492]	; (8004e0c <.text_82>)
 8004c20:	4001      	ands	r1, r0
 8004c22:	60e1      	str	r1, [r4, #12]
 8004c24:	7828      	ldrb	r0, [r5, #0]
 8004c26:	0780      	lsls	r0, r0, #30
 8004c28:	d509      	bpl.n	8004c3e <PE_SubStateMachine_VconnSwap+0x1c2>
 8004c2a:	2000      	movs	r0, #0
 8004c2c:	9000      	str	r0, [sp, #0]
 8004c2e:	2300      	movs	r3, #0
 8004c30:	2240      	movs	r2, #64	; 0x40
 8004c32:	7b20      	ldrb	r0, [r4, #12]
 8004c34:	07c1      	lsls	r1, r0, #31
 8004c36:	0fc9      	lsrs	r1, r1, #31
 8004c38:	2009      	movs	r0, #9
 8004c3a:	68ed      	ldr	r5, [r5, #12]
 8004c3c:	47a8      	blx	r5
 8004c3e:	2140      	movs	r1, #64	; 0x40
 8004c40:	7b22      	ldrb	r2, [r4, #12]
 8004c42:	07d0      	lsls	r0, r2, #31
 8004c44:	0fc0      	lsrs	r0, r0, #31
 8004c46:	e023      	b.n	8004c90 <PE_SubStateMachine_VconnSwap+0x214>
 8004c48:	2000      	movs	r0, #0
 8004c4a:	9000      	str	r0, [sp, #0]
 8004c4c:	23a3      	movs	r3, #163	; 0xa3
 8004c4e:	220b      	movs	r2, #11
 8004c50:	2100      	movs	r1, #0
 8004c52:	0020      	movs	r0, r4
 8004c54:	f7fe fd8d 	bl	8003772 <PE_Send_CtrlMessage>
 8004c58:	2800      	cmp	r0, #0
 8004c5a:	d11c      	bne.n	8004c96 <PE_SubStateMachine_VconnSwap+0x21a>
 8004c5c:	68e1      	ldr	r1, [r4, #12]
 8004c5e:	2080      	movs	r0, #128	; 0x80
 8004c60:	0100      	lsls	r0, r0, #4
 8004c62:	4308      	orrs	r0, r1
 8004c64:	60e0      	str	r0, [r4, #12]
 8004c66:	496a      	ldr	r1, [pc, #424]	; (8004e10 <.text_83>)
 8004c68:	82b1      	strh	r1, [r6, #20]
 8004c6a:	211a      	movs	r1, #26
 8004c6c:	9101      	str	r1, [sp, #4]
 8004c6e:	2601      	movs	r6, #1
 8004c70:	7829      	ldrb	r1, [r5, #0]
 8004c72:	0789      	lsls	r1, r1, #30
 8004c74:	d508      	bpl.n	8004c88 <PE_SubStateMachine_VconnSwap+0x20c>
 8004c76:	2100      	movs	r1, #0
 8004c78:	9100      	str	r1, [sp, #0]
 8004c7a:	2300      	movs	r3, #0
 8004c7c:	223c      	movs	r2, #60	; 0x3c
 8004c7e:	2101      	movs	r1, #1
 8004c80:	4001      	ands	r1, r0
 8004c82:	2009      	movs	r0, #9
 8004c84:	68ed      	ldr	r5, [r5, #12]
 8004c86:	47a8      	blx	r5
 8004c88:	213c      	movs	r1, #60	; 0x3c
 8004c8a:	68e0      	ldr	r0, [r4, #12]
 8004c8c:	4006      	ands	r6, r0
 8004c8e:	0030      	movs	r0, r6
 8004c90:	68a2      	ldr	r2, [r4, #8]
 8004c92:	68d2      	ldr	r2, [r2, #12]
 8004c94:	4790      	blx	r2
 8004c96:	e0b5      	b.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004c98:	200019a8 	.word	0x200019a8
 8004c9c:	9a02      	ldr	r2, [sp, #8]
 8004c9e:	7812      	ldrb	r2, [r2, #0]
 8004ca0:	2a11      	cmp	r2, #17
 8004ca2:	d110      	bne.n	8004cc6 <PE_SubStateMachine_VconnSwap+0x24a>
 8004ca4:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004ca6:	0bd2      	lsrs	r2, r2, #15
 8004ca8:	d10d      	bne.n	8004cc6 <PE_SubStateMachine_VconnSwap+0x24a>
 8004caa:	8db2      	ldrh	r2, [r6, #44]	; 0x2c
 8004cac:	0b12      	lsrs	r2, r2, #12
 8004cae:	420a      	tst	r2, r1
 8004cb0:	d109      	bne.n	8004cc6 <PE_SubStateMachine_VconnSwap+0x24a>
 8004cb2:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 8004cb4:	4008      	ands	r0, r1
 8004cb6:	2803      	cmp	r0, #3
 8004cb8:	d006      	beq.n	8004cc8 <PE_SubStateMachine_VconnSwap+0x24c>
 8004cba:	2804      	cmp	r0, #4
 8004cbc:	d03f      	beq.n	8004d3e <PE_SubStateMachine_VconnSwap+0x2c2>
 8004cbe:	280c      	cmp	r0, #12
 8004cc0:	d020      	beq.n	8004d04 <PE_SubStateMachine_VconnSwap+0x288>
 8004cc2:	2810      	cmp	r0, #16
 8004cc4:	d05a      	beq.n	8004d7c <PE_SubStateMachine_VconnSwap+0x300>
 8004cc6:	e080      	b.n	8004dca <PE_SubStateMachine_VconnSwap+0x34e>
 8004cc8:	2000      	movs	r0, #0
 8004cca:	82b0      	strh	r0, [r6, #20]
 8004ccc:	2701      	movs	r7, #1
 8004cce:	6860      	ldr	r0, [r4, #4]
 8004cd0:	6800      	ldr	r0, [r0, #0]
 8004cd2:	0c80      	lsrs	r0, r0, #18
 8004cd4:	4038      	ands	r0, r7
 8004cd6:	d001      	beq.n	8004cdc <PE_SubStateMachine_VconnSwap+0x260>
 8004cd8:	209f      	movs	r0, #159	; 0x9f
 8004cda:	e000      	b.n	8004cde <PE_SubStateMachine_VconnSwap+0x262>
 8004cdc:	20a0      	movs	r0, #160	; 0xa0
 8004cde:	7030      	strb	r0, [r6, #0]
 8004ce0:	2014      	movs	r0, #20
 8004ce2:	9902      	ldr	r1, [sp, #8]
 8004ce4:	7008      	strb	r0, [r1, #0]
 8004ce6:	7828      	ldrb	r0, [r5, #0]
 8004ce8:	0780      	lsls	r0, r0, #30
 8004cea:	d509      	bpl.n	8004d00 <PE_SubStateMachine_VconnSwap+0x284>
 8004cec:	2000      	movs	r0, #0
 8004cee:	9000      	str	r0, [sp, #0]
 8004cf0:	2300      	movs	r3, #0
 8004cf2:	223d      	movs	r2, #61	; 0x3d
 8004cf4:	68e0      	ldr	r0, [r4, #12]
 8004cf6:	2101      	movs	r1, #1
 8004cf8:	4001      	ands	r1, r0
 8004cfa:	2009      	movs	r0, #9
 8004cfc:	68ed      	ldr	r5, [r5, #12]
 8004cfe:	47a8      	blx	r5
 8004d00:	213d      	movs	r1, #61	; 0x3d
 8004d02:	e05c      	b.n	8004dbe <PE_SubStateMachine_VconnSwap+0x342>
 8004d04:	2000      	movs	r0, #0
 8004d06:	82b0      	strh	r0, [r6, #20]
 8004d08:	68e0      	ldr	r0, [r4, #12]
 8004d0a:	4940      	ldr	r1, [pc, #256]	; (8004e0c <.text_82>)
 8004d0c:	4001      	ands	r1, r0
 8004d0e:	60e1      	str	r1, [r4, #12]
 8004d10:	2003      	movs	r0, #3
 8004d12:	7030      	strb	r0, [r6, #0]
 8004d14:	2014      	movs	r0, #20
 8004d16:	9902      	ldr	r1, [sp, #8]
 8004d18:	7008      	strb	r0, [r1, #0]
 8004d1a:	7828      	ldrb	r0, [r5, #0]
 8004d1c:	0780      	lsls	r0, r0, #30
 8004d1e:	d509      	bpl.n	8004d34 <PE_SubStateMachine_VconnSwap+0x2b8>
 8004d20:	2000      	movs	r0, #0
 8004d22:	9000      	str	r0, [sp, #0]
 8004d24:	2300      	movs	r3, #0
 8004d26:	223e      	movs	r2, #62	; 0x3e
 8004d28:	7b20      	ldrb	r0, [r4, #12]
 8004d2a:	07c1      	lsls	r1, r0, #31
 8004d2c:	0fc9      	lsrs	r1, r1, #31
 8004d2e:	2009      	movs	r0, #9
 8004d30:	68ed      	ldr	r5, [r5, #12]
 8004d32:	47a8      	blx	r5
 8004d34:	213e      	movs	r1, #62	; 0x3e
 8004d36:	7b22      	ldrb	r2, [r4, #12]
 8004d38:	07d0      	lsls	r0, r2, #31
 8004d3a:	0fc0      	lsrs	r0, r0, #31
 8004d3c:	e042      	b.n	8004dc4 <PE_SubStateMachine_VconnSwap+0x348>
 8004d3e:	2000      	movs	r0, #0
 8004d40:	82b0      	strh	r0, [r6, #20]
 8004d42:	68e0      	ldr	r0, [r4, #12]
 8004d44:	4931      	ldr	r1, [pc, #196]	; (8004e0c <.text_82>)
 8004d46:	4001      	ands	r1, r0
 8004d48:	60e1      	str	r1, [r4, #12]
 8004d4a:	2003      	movs	r0, #3
 8004d4c:	7030      	strb	r0, [r6, #0]
 8004d4e:	2014      	movs	r0, #20
 8004d50:	9902      	ldr	r1, [sp, #8]
 8004d52:	7008      	strb	r0, [r1, #0]
 8004d54:	7828      	ldrb	r0, [r5, #0]
 8004d56:	0780      	lsls	r0, r0, #30
 8004d58:	d509      	bpl.n	8004d6e <PE_SubStateMachine_VconnSwap+0x2f2>
 8004d5a:	2000      	movs	r0, #0
 8004d5c:	9000      	str	r0, [sp, #0]
 8004d5e:	2300      	movs	r3, #0
 8004d60:	223f      	movs	r2, #63	; 0x3f
 8004d62:	7b20      	ldrb	r0, [r4, #12]
 8004d64:	07c1      	lsls	r1, r0, #31
 8004d66:	0fc9      	lsrs	r1, r1, #31
 8004d68:	2009      	movs	r0, #9
 8004d6a:	68ef      	ldr	r7, [r5, #12]
 8004d6c:	47b8      	blx	r7
 8004d6e:	213f      	movs	r1, #63	; 0x3f
 8004d70:	7b22      	ldrb	r2, [r4, #12]
 8004d72:	07d0      	lsls	r0, r2, #31
 8004d74:	0fc0      	lsrs	r0, r0, #31
 8004d76:	68a2      	ldr	r2, [r4, #8]
 8004d78:	68d2      	ldr	r2, [r2, #12]
 8004d7a:	4790      	blx	r2
 8004d7c:	2000      	movs	r0, #0
 8004d7e:	82b0      	strh	r0, [r6, #20]
 8004d80:	2701      	movs	r7, #1
 8004d82:	6860      	ldr	r0, [r4, #4]
 8004d84:	6800      	ldr	r0, [r0, #0]
 8004d86:	0c80      	lsrs	r0, r0, #18
 8004d88:	4038      	ands	r0, r7
 8004d8a:	d101      	bne.n	8004d90 <PE_SubStateMachine_VconnSwap+0x314>
 8004d8c:	20a4      	movs	r0, #164	; 0xa4
 8004d8e:	e004      	b.n	8004d9a <PE_SubStateMachine_VconnSwap+0x31e>
 8004d90:	68e0      	ldr	r0, [r4, #12]
 8004d92:	491e      	ldr	r1, [pc, #120]	; (8004e0c <.text_82>)
 8004d94:	4001      	ands	r1, r0
 8004d96:	60e1      	str	r1, [r4, #12]
 8004d98:	2003      	movs	r0, #3
 8004d9a:	7030      	strb	r0, [r6, #0]
 8004d9c:	2014      	movs	r0, #20
 8004d9e:	9902      	ldr	r1, [sp, #8]
 8004da0:	7008      	strb	r0, [r1, #0]
 8004da2:	7828      	ldrb	r0, [r5, #0]
 8004da4:	0780      	lsls	r0, r0, #30
 8004da6:	d509      	bpl.n	8004dbc <PE_SubStateMachine_VconnSwap+0x340>
 8004da8:	2000      	movs	r0, #0
 8004daa:	9000      	str	r0, [sp, #0]
 8004dac:	2300      	movs	r3, #0
 8004dae:	2255      	movs	r2, #85	; 0x55
 8004db0:	68e0      	ldr	r0, [r4, #12]
 8004db2:	2101      	movs	r1, #1
 8004db4:	4001      	ands	r1, r0
 8004db6:	2009      	movs	r0, #9
 8004db8:	68ed      	ldr	r5, [r5, #12]
 8004dba:	47a8      	blx	r5
 8004dbc:	2155      	movs	r1, #85	; 0x55
 8004dbe:	68e0      	ldr	r0, [r4, #12]
 8004dc0:	4007      	ands	r7, r0
 8004dc2:	0038      	movs	r0, r7
 8004dc4:	68a2      	ldr	r2, [r4, #8]
 8004dc6:	68d2      	ldr	r2, [r2, #12]
 8004dc8:	4790      	blx	r2
 8004dca:	8ab0      	ldrh	r0, [r6, #20]
 8004dcc:	2180      	movs	r1, #128	; 0x80
 8004dce:	0209      	lsls	r1, r1, #8
 8004dd0:	4288      	cmp	r0, r1
 8004dd2:	d117      	bne.n	8004e04 <PE_SubStateMachine_VconnSwap+0x388>
 8004dd4:	2000      	movs	r0, #0
 8004dd6:	82b0      	strh	r0, [r6, #20]
 8004dd8:	e00e      	b.n	8004df8 <PE_SubStateMachine_VconnSwap+0x37c>
 8004dda:	68a0      	ldr	r0, [r4, #8]
 8004ddc:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004dde:	2a00      	cmp	r2, #0
 8004de0:	d004      	beq.n	8004dec <PE_SubStateMachine_VconnSwap+0x370>
 8004de2:	2101      	movs	r1, #1
 8004de4:	7b23      	ldrb	r3, [r4, #12]
 8004de6:	07d8      	lsls	r0, r3, #31
 8004de8:	0fc0      	lsrs	r0, r0, #31
 8004dea:	4790      	blx	r2
 8004dec:	6860      	ldr	r0, [r4, #4]
 8004dee:	6801      	ldr	r1, [r0, #0]
 8004df0:	2280      	movs	r2, #128	; 0x80
 8004df2:	02d2      	lsls	r2, r2, #11
 8004df4:	430a      	orrs	r2, r1
 8004df6:	6002      	str	r2, [r0, #0]
 8004df8:	68e0      	ldr	r0, [r4, #12]
 8004dfa:	4904      	ldr	r1, [pc, #16]	; (8004e0c <.text_82>)
 8004dfc:	4001      	ands	r1, r0
 8004dfe:	60e1      	str	r1, [r4, #12]
 8004e00:	2003      	movs	r0, #3
 8004e02:	7030      	strb	r0, [r6, #0]
 8004e04:	9801      	ldr	r0, [sp, #4]
 8004e06:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08004e08 <.text_81>:
 8004e08:	00008064 	.word	0x00008064

08004e0c <.text_82>:
 8004e0c:	fffff7ff 	.word	0xfffff7ff

08004e10 <.text_83>:
 8004e10:	0000801a 	.word	0x0000801a

08004e14 <USBPD_PE_ExecFastRoleSwapSignalling>:
 8004e14:	b580      	push	{r7, lr}
 8004e16:	f000 f8bc 	bl	8004f92 <USBPD_PRL_FastRoleSwapSignalling>
 8004e1a:	bd01      	pop	{r0, pc}

08004e1c <USBPD_PRL_TimerCounter>:
 8004e1c:	b081      	sub	sp, #4
 8004e1e:	4965      	ldr	r1, [pc, #404]	; (8004fb4 <.text_17>)
 8004e20:	0080      	lsls	r0, r0, #2
 8004e22:	1808      	adds	r0, r1, r0
 8004e24:	6841      	ldr	r1, [r0, #4]
 8004e26:	7a8a      	ldrb	r2, [r1, #10]
 8004e28:	2a00      	cmp	r2, #0
 8004e2a:	d001      	beq.n	8004e30 <USBPD_PRL_TimerCounter+0x14>
 8004e2c:	1e52      	subs	r2, r2, #1
 8004e2e:	728a      	strb	r2, [r1, #10]
 8004e30:	6840      	ldr	r0, [r0, #4]
 8004e32:	8e81      	ldrh	r1, [r0, #52]	; 0x34
 8004e34:	2900      	cmp	r1, #0
 8004e36:	d001      	beq.n	8004e3c <USBPD_PRL_TimerCounter+0x20>
 8004e38:	1e49      	subs	r1, r1, #1
 8004e3a:	8681      	strh	r1, [r0, #52]	; 0x34
 8004e3c:	b001      	add	sp, #4
 8004e3e:	4770      	bx	lr

08004e40 <USBPD_PRL_Init>:
 8004e40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8004e42:	b082      	sub	sp, #8
 8004e44:	001c      	movs	r4, r3
 8004e46:	4668      	mov	r0, sp
 8004e48:	7a00      	ldrb	r0, [r0, #8]
 8004e4a:	2801      	cmp	r0, #1
 8004e4c:	d83a      	bhi.n	8004ec4 <USBPD_PRL_Init+0x84>
 8004e4e:	2038      	movs	r0, #56	; 0x38
 8004e50:	f007 fe9a 	bl	800cb88 <malloc>
 8004e54:	4957      	ldr	r1, [pc, #348]	; (8004fb4 <.text_17>)
 8004e56:	466a      	mov	r2, sp
 8004e58:	7a12      	ldrb	r2, [r2, #8]
 8004e5a:	0092      	lsls	r2, r2, #2
 8004e5c:	188d      	adds	r5, r1, r2
 8004e5e:	6068      	str	r0, [r5, #4]
 8004e60:	2800      	cmp	r0, #0
 8004e62:	d101      	bne.n	8004e68 <USBPD_PRL_Init+0x28>
 8004e64:	2016      	movs	r0, #22
 8004e66:	e02e      	b.n	8004ec6 <USBPD_PRL_Init+0x86>
 8004e68:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8004e6a:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 8004e6c:	4669      	mov	r1, sp
 8004e6e:	710c      	strb	r4, [r1, #4]
 8004e70:	2138      	movs	r1, #56	; 0x38
 8004e72:	f007 fe59 	bl	800cb28 <__aeabi_memclr>
 8004e76:	6868      	ldr	r0, [r5, #4]
 8004e78:	2400      	movs	r4, #0
 8004e7a:	7104      	strb	r4, [r0, #4]
 8004e7c:	7144      	strb	r4, [r0, #5]
 8004e7e:	6006      	str	r6, [r0, #0]
 8004e80:	7284      	strb	r4, [r0, #10]
 8004e82:	6869      	ldr	r1, [r5, #4]
 8004e84:	72cc      	strb	r4, [r1, #11]
 8004e86:	220f      	movs	r2, #15
 8004e88:	2103      	movs	r1, #3
 8004e8a:	6868      	ldr	r0, [r5, #4]
 8004e8c:	1d80      	adds	r0, r0, #6
 8004e8e:	f007 fe50 	bl	800cb32 <__aeabi_memset>
 8004e92:	6869      	ldr	r1, [r5, #4]
 8004e94:	730c      	strb	r4, [r1, #12]
 8004e96:	6868      	ldr	r0, [r5, #4]
 8004e98:	9904      	ldr	r1, [sp, #16]
 8004e9a:	62c1      	str	r1, [r0, #44]	; 0x2c
 8004e9c:	990a      	ldr	r1, [sp, #40]	; 0x28
 8004e9e:	6281      	str	r1, [r0, #40]	; 0x28
 8004ea0:	6247      	str	r7, [r0, #36]	; 0x24
 8004ea2:	9903      	ldr	r1, [sp, #12]
 8004ea4:	6301      	str	r1, [r0, #48]	; 0x30
 8004ea6:	7344      	strb	r4, [r0, #13]
 8004ea8:	6868      	ldr	r0, [r5, #4]
 8004eaa:	7384      	strb	r4, [r0, #14]
 8004eac:	2001      	movs	r0, #1
 8004eae:	9000      	str	r0, [sp, #0]
 8004eb0:	4668      	mov	r0, sp
 8004eb2:	7903      	ldrb	r3, [r0, #4]
 8004eb4:	6868      	ldr	r0, [r5, #4]
 8004eb6:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8004eb8:	a104      	add	r1, pc, #16	; (adr r1, 8004ecc <PRL_PhyCallbacks>)
 8004eba:	4668      	mov	r0, sp
 8004ebc:	7a00      	ldrb	r0, [r0, #8]
 8004ebe:	f004 fedf 	bl	8009c80 <USBPD_PHY_Init>
 8004ec2:	e000      	b.n	8004ec6 <USBPD_PRL_Init+0x86>
 8004ec4:	2002      	movs	r0, #2
 8004ec6:	b005      	add	sp, #20
 8004ec8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08004ecc <PRL_PhyCallbacks>:
 8004ecc:	54af 0800 57d1 0800 5819 0800 5827 0800     .T...W...X..'X..
 8004edc:	5839 0800 5855 0800                         9X..UX..

08004ee4 <USBPD_PRL_GetMemoryConsumption>:
 8004ee4:	2070      	movs	r0, #112	; 0x70
 8004ee6:	4770      	bx	lr

08004ee8 <USBPD_PRL_SetHeader>:
 8004ee8:	b530      	push	{r4, r5, lr}
 8004eea:	4c32      	ldr	r4, [pc, #200]	; (8004fb4 <.text_17>)
 8004eec:	0080      	lsls	r0, r0, #2
 8004eee:	1820      	adds	r0, r4, r0
 8004ef0:	6840      	ldr	r0, [r0, #4]
 8004ef2:	8a84      	ldrh	r4, [r0, #20]
 8004ef4:	4d30      	ldr	r5, [pc, #192]	; (8004fb8 <.text_18>)
 8004ef6:	4025      	ands	r5, r4
 8004ef8:	0209      	lsls	r1, r1, #8
 8004efa:	2480      	movs	r4, #128	; 0x80
 8004efc:	0064      	lsls	r4, r4, #1
 8004efe:	4021      	ands	r1, r4
 8004f00:	4329      	orrs	r1, r5
 8004f02:	8281      	strh	r1, [r0, #20]
 8004f04:	4c2d      	ldr	r4, [pc, #180]	; (8004fbc <.text_19>)
 8004f06:	400c      	ands	r4, r1
 8004f08:	0151      	lsls	r1, r2, #5
 8004f0a:	2220      	movs	r2, #32
 8004f0c:	4011      	ands	r1, r2
 8004f0e:	4321      	orrs	r1, r4
 8004f10:	8281      	strh	r1, [r0, #20]
 8004f12:	4a2b      	ldr	r2, [pc, #172]	; (8004fc0 <.text_20>)
 8004f14:	400a      	ands	r2, r1
 8004f16:	0199      	lsls	r1, r3, #6
 8004f18:	23c0      	movs	r3, #192	; 0xc0
 8004f1a:	400b      	ands	r3, r1
 8004f1c:	4313      	orrs	r3, r2
 8004f1e:	8283      	strh	r3, [r0, #20]
 8004f20:	bd30      	pop	{r4, r5, pc}

08004f22 <USBPD_PRL_SetHeaderPowerRole>:
 8004f22:	4a24      	ldr	r2, [pc, #144]	; (8004fb4 <.text_17>)
 8004f24:	0080      	lsls	r0, r0, #2
 8004f26:	1810      	adds	r0, r2, r0
 8004f28:	6840      	ldr	r0, [r0, #4]
 8004f2a:	8a82      	ldrh	r2, [r0, #20]
 8004f2c:	4b22      	ldr	r3, [pc, #136]	; (8004fb8 <.text_18>)
 8004f2e:	4013      	ands	r3, r2
 8004f30:	0209      	lsls	r1, r1, #8
 8004f32:	2280      	movs	r2, #128	; 0x80
 8004f34:	0052      	lsls	r2, r2, #1
 8004f36:	e008      	b.n	8004f4a <.text_10>

08004f38 <USBPD_PRL_SetHeaderDataRole>:
 8004f38:	4a1e      	ldr	r2, [pc, #120]	; (8004fb4 <.text_17>)
 8004f3a:	0080      	lsls	r0, r0, #2
 8004f3c:	1810      	adds	r0, r2, r0
 8004f3e:	6840      	ldr	r0, [r0, #4]
 8004f40:	8a82      	ldrh	r2, [r0, #20]
 8004f42:	4b1e      	ldr	r3, [pc, #120]	; (8004fbc <.text_19>)
 8004f44:	4013      	ands	r3, r2
 8004f46:	0149      	lsls	r1, r1, #5
 8004f48:	2220      	movs	r2, #32

08004f4a <.text_10>:
 8004f4a:	4011      	ands	r1, r2
 8004f4c:	4319      	orrs	r1, r3
 8004f4e:	8281      	strh	r1, [r0, #20]
 8004f50:	4770      	bx	lr

08004f52 <USBPD_PRL_SetHeaderSpecification>:
 8004f52:	4a18      	ldr	r2, [pc, #96]	; (8004fb4 <.text_17>)
 8004f54:	0080      	lsls	r0, r0, #2
 8004f56:	1810      	adds	r0, r2, r0
 8004f58:	6840      	ldr	r0, [r0, #4]
 8004f5a:	8a82      	ldrh	r2, [r0, #20]
 8004f5c:	4b18      	ldr	r3, [pc, #96]	; (8004fc0 <.text_20>)
 8004f5e:	4013      	ands	r3, r2
 8004f60:	0189      	lsls	r1, r1, #6
 8004f62:	22c0      	movs	r2, #192	; 0xc0
 8004f64:	400a      	ands	r2, r1
 8004f66:	431a      	orrs	r2, r3
 8004f68:	8282      	strh	r2, [r0, #20]
 8004f6a:	4770      	bx	lr

08004f6c <USBPD_PRL_SRCSetSinkNG>:
 8004f6c:	b580      	push	{r7, lr}
 8004f6e:	f004 fe5b 	bl	8009c28 <USBPD_PHY_SetResistor_SinkTxNG>
 8004f72:	bd01      	pop	{r0, pc}

08004f74 <USBPD_PRL_SRCReleaseSinkNG>:
 8004f74:	b510      	push	{r4, lr}
 8004f76:	0004      	movs	r4, r0
 8004f78:	f004 fe5e 	bl	8009c38 <USBPD_PHY_SetResistor_SinkTxOK>
 8004f7c:	480d      	ldr	r0, [pc, #52]	; (8004fb4 <.text_17>)
 8004f7e:	00a1      	lsls	r1, r4, #2
 8004f80:	1840      	adds	r0, r0, r1
 8004f82:	6840      	ldr	r0, [r0, #4]
 8004f84:	2106      	movs	r1, #6
 8004f86:	7101      	strb	r1, [r0, #4]
 8004f88:	bd10      	pop	{r4, pc}

08004f8a <USBPD_PRL_IsResistor_SinkTxOK>:
 8004f8a:	b580      	push	{r7, lr}
 8004f8c:	f004 fe5d 	bl	8009c4a <USBPD_PHY_IsResistor_SinkTxOk>
 8004f90:	bd02      	pop	{r1, pc}

08004f92 <USBPD_PRL_FastRoleSwapSignalling>:
 8004f92:	b580      	push	{r7, lr}
 8004f94:	f004 fe5d 	bl	8009c52 <USBPD_PHY_FastRoleSwapSignalling>
 8004f98:	bd01      	pop	{r0, pc}

08004f9a <USBPD_PRL_CableCapable>:
 8004f9a:	b580      	push	{r7, lr}
 8004f9c:	2901      	cmp	r1, #1
 8004f9e:	d105      	bne.n	8004fac <USBPD_PRL_CableCapable+0x12>
 8004fa0:	4904      	ldr	r1, [pc, #16]	; (8004fb4 <.text_17>)
 8004fa2:	0082      	lsls	r2, r0, #2
 8004fa4:	1889      	adds	r1, r1, r2
 8004fa6:	6849      	ldr	r1, [r1, #4]
 8004fa8:	6809      	ldr	r1, [r1, #0]
 8004faa:	e000      	b.n	8004fae <USBPD_PRL_CableCapable+0x14>
 8004fac:	2101      	movs	r1, #1
 8004fae:	f004 fe4b 	bl	8009c48 <USBPD_PHY_SOPSupported>
 8004fb2:	bd01      	pop	{r0, pc}

08004fb4 <.text_17>:
 8004fb4:	200019bc 	.word	0x200019bc

08004fb8 <.text_18>:
 8004fb8:	0000feff 	.word	0x0000feff

08004fbc <.text_19>:
 8004fbc:	0000ffdf 	.word	0x0000ffdf

08004fc0 <.text_20>:
 8004fc0:	0000ff3f 	.word	0x0000ff3f

08004fc4 <USBPD_PRL_SendMessage>:
 8004fc4:	b5f5      	push	{r0, r2, r4, r5, r6, r7, lr}
 8004fc6:	b083      	sub	sp, #12
 8004fc8:	2703      	movs	r7, #3
 8004fca:	48b2      	ldr	r0, [pc, #712]	; (8005294 <USBPD_PRL_SendMessage+0x2d0>)
 8004fcc:	466a      	mov	r2, sp
 8004fce:	7b12      	ldrb	r2, [r2, #12]
 8004fd0:	0092      	lsls	r2, r2, #2
 8004fd2:	1884      	adds	r4, r0, r2
 8004fd4:	6860      	ldr	r0, [r4, #4]
 8004fd6:	7a42      	ldrb	r2, [r0, #9]
 8004fd8:	2a00      	cmp	r2, #0
 8004fda:	d104      	bne.n	8004fe6 <USBPD_PRL_SendMessage+0x22>
 8004fdc:	7902      	ldrb	r2, [r0, #4]
 8004fde:	2a06      	cmp	r2, #6
 8004fe0:	dd01      	ble.n	8004fe6 <USBPD_PRL_SendMessage+0x22>
 8004fe2:	220e      	movs	r2, #14
 8004fe4:	7102      	strb	r2, [r0, #4]
 8004fe6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8004fe8:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8004fea:	9302      	str	r3, [sp, #8]
 8004fec:	466b      	mov	r3, sp
 8004fee:	7119      	strb	r1, [r3, #4]
 8004ff0:	9200      	str	r2, [sp, #0]
 8004ff2:	2606      	movs	r6, #6
 8004ff4:	2200      	movs	r2, #0
 8004ff6:	7901      	ldrb	r1, [r0, #4]
 8004ff8:	290f      	cmp	r1, #15
 8004ffa:	d900      	bls.n	8004ffe <USBPD_PRL_SendMessage+0x3a>
 8004ffc:	e1c0      	b.n	8005380 <USBPD_PRL_SendMessage+0x3bc>
 8004ffe:	a302      	add	r3, pc, #8	; (adr r3, 8005008 <USBPD_PRL_SendMessage+0x44>)
 8005000:	0049      	lsls	r1, r1, #1
 8005002:	5a5b      	ldrh	r3, [r3, r1]
 8005004:	449f      	add	pc, r3
 8005006:	bf00      	nop
 8005008:	002e0020 	.word	0x002e0020
 800500c:	03780042 	.word	0x03780042
 8005010:	00900052 	.word	0x00900052
 8005014:	011e0078 	.word	0x011e0078
 8005018:	02900130 	.word	0x02900130
 800501c:	02dc02b6 	.word	0x02dc02b6
 8005020:	037802fc 	.word	0x037802fc
 8005024:	032e0372 	.word	0x032e0372
 8005028:	4668      	mov	r0, sp
 800502a:	7b00      	ldrb	r0, [r0, #12]
 800502c:	f004 fe24 	bl	8009c78 <USBPD_PHY_Reset>
 8005030:	6860      	ldr	r0, [r4, #4]
 8005032:	7106      	strb	r6, [r0, #4]
 8005034:	e1a6      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005036:	4668      	mov	r0, sp
 8005038:	7b00      	ldrb	r0, [r0, #12]
 800503a:	f004 fdf5 	bl	8009c28 <USBPD_PHY_SetResistor_SinkTxNG>
 800503e:	6860      	ldr	r0, [r4, #4]
 8005040:	2102      	movs	r1, #2
 8005042:	7101      	strb	r1, [r0, #4]
 8005044:	2111      	movs	r1, #17
 8005046:	8681      	strh	r1, [r0, #52]	; 0x34
 8005048:	e19c      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 800504a:	9900      	ldr	r1, [sp, #0]
 800504c:	2901      	cmp	r1, #1
 800504e:	d1ef      	bne.n	8005030 <USBPD_PRL_SendMessage+0x6c>
 8005050:	8e81      	ldrh	r1, [r0, #52]	; 0x34
 8005052:	2900      	cmp	r1, #0
 8005054:	d112      	bne.n	800507c <USBPD_PRL_SendMessage+0xb8>
 8005056:	2105      	movs	r1, #5
 8005058:	e168      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 800505a:	9800      	ldr	r0, [sp, #0]
 800505c:	2802      	cmp	r0, #2
 800505e:	d1e7      	bne.n	8005030 <USBPD_PRL_SendMessage+0x6c>
 8005060:	4668      	mov	r0, sp
 8005062:	7b00      	ldrb	r0, [r0, #12]
 8005064:	f004 fdf1 	bl	8009c4a <USBPD_PHY_IsResistor_SinkTxOk>
 8005068:	2801      	cmp	r0, #1
 800506a:	d107      	bne.n	800507c <USBPD_PRL_SendMessage+0xb8>
 800506c:	2005      	movs	r0, #5
 800506e:	6861      	ldr	r1, [r4, #4]
 8005070:	7108      	strb	r0, [r1, #4]
 8005072:	4668      	mov	r0, sp
 8005074:	7b00      	ldrb	r0, [r0, #12]
 8005076:	f004 fde8 	bl	8009c4a <USBPD_PHY_IsResistor_SinkTxOk>
 800507a:	e183      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 800507c:	2009      	movs	r0, #9
 800507e:	e182      	b.n	8005386 <USBPD_PRL_SendMessage+0x3c2>
 8005080:	8a81      	ldrh	r1, [r0, #20]
 8005082:	0609      	lsls	r1, r1, #24
 8005084:	0f89      	lsrs	r1, r1, #30
 8005086:	2902      	cmp	r1, #2
 8005088:	d106      	bne.n	8005098 <USBPD_PRL_SendMessage+0xd4>
 800508a:	9900      	ldr	r1, [sp, #0]
 800508c:	2901      	cmp	r1, #1
 800508e:	d002      	beq.n	8005096 <USBPD_PRL_SendMessage+0xd2>
 8005090:	2902      	cmp	r1, #2
 8005092:	d101      	bne.n	8005098 <USBPD_PRL_SendMessage+0xd4>
 8005094:	2104      	movs	r1, #4
 8005096:	e149      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 8005098:	4669      	mov	r1, sp
 800509a:	7c09      	ldrb	r1, [r1, #16]
 800509c:	23ff      	movs	r3, #255	; 0xff
 800509e:	7243      	strb	r3, [r0, #9]
 80050a0:	8a86      	ldrh	r6, [r0, #20]
 80050a2:	4bbd      	ldr	r3, [pc, #756]	; (8005398 <.text_23>)
 80050a4:	4033      	ands	r3, r6
 80050a6:	06ce      	lsls	r6, r1, #27
 80050a8:	0ef6      	lsrs	r6, r6, #27
 80050aa:	431e      	orrs	r6, r3
 80050ac:	8286      	strh	r6, [r0, #20]
 80050ae:	0473      	lsls	r3, r6, #17
 80050b0:	0c5b      	lsrs	r3, r3, #17
 80050b2:	09ce      	lsrs	r6, r1, #7
 80050b4:	03f6      	lsls	r6, r6, #15
 80050b6:	431e      	orrs	r6, r3
 80050b8:	8286      	strh	r6, [r0, #20]
 80050ba:	7302      	strb	r2, [r0, #12]
 80050bc:	6860      	ldr	r0, [r4, #4]
 80050be:	8a83      	ldrh	r3, [r0, #20]
 80050c0:	0bdc      	lsrs	r4, r3, #15
 80050c2:	d018      	beq.n	80050f6 <USBPD_PRL_SendMessage+0x132>
 80050c4:	9b02      	ldr	r3, [sp, #8]
 80050c6:	789b      	ldrb	r3, [r3, #2]
 80050c8:	9c02      	ldr	r4, [sp, #8]
 80050ca:	78e4      	ldrb	r4, [r4, #3]
 80050cc:	0224      	lsls	r4, r4, #8
 80050ce:	191b      	adds	r3, r3, r4
 80050d0:	8343      	strh	r3, [r0, #26]
 80050d2:	8b43      	ldrh	r3, [r0, #26]
 80050d4:	0a9c      	lsrs	r4, r3, #10
 80050d6:	07e4      	lsls	r4, r4, #31
 80050d8:	d41a      	bmi.n	8005110 <USBPD_PRL_SendMessage+0x14c>
 80050da:	0ada      	lsrs	r2, r3, #11
 80050dc:	0712      	lsls	r2, r2, #28
 80050de:	d118      	bne.n	8005112 <USBPD_PRL_SendMessage+0x14e>
 80050e0:	1f2a      	subs	r2, r5, #4
 80050e2:	8402      	strh	r2, [r0, #32]
 80050e4:	05d2      	lsls	r2, r2, #23
 80050e6:	0dd2      	lsrs	r2, r2, #23
 80050e8:	8b43      	ldrh	r3, [r0, #26]
 80050ea:	24fe      	movs	r4, #254	; 0xfe
 80050ec:	0224      	lsls	r4, r4, #8
 80050ee:	401c      	ands	r4, r3
 80050f0:	4322      	orrs	r2, r4
 80050f2:	8342      	strh	r2, [r0, #26]
 80050f4:	e00d      	b.n	8005112 <USBPD_PRL_SendMessage+0x14e>
 80050f6:	1eac      	subs	r4, r5, #2
 80050f8:	4da8      	ldr	r5, [pc, #672]	; (800539c <.text_24>)
 80050fa:	401d      	ands	r5, r3
 80050fc:	1063      	asrs	r3, r4, #1
 80050fe:	0f9b      	lsrs	r3, r3, #30
 8005100:	191b      	adds	r3, r3, r4
 8005102:	109b      	asrs	r3, r3, #2
 8005104:	031b      	lsls	r3, r3, #12
 8005106:	24e0      	movs	r4, #224	; 0xe0
 8005108:	01e4      	lsls	r4, r4, #7
 800510a:	401c      	ands	r4, r3
 800510c:	432c      	orrs	r4, r5
 800510e:	8284      	strh	r4, [r0, #20]
 8005110:	8402      	strh	r2, [r0, #32]
 8005112:	290d      	cmp	r1, #13
 8005114:	d103      	bne.n	800511e <USBPD_PRL_SendMessage+0x15a>
 8005116:	8a81      	ldrh	r1, [r0, #20]
 8005118:	22f0      	movs	r2, #240	; 0xf0
 800511a:	0212      	lsls	r2, r2, #8
 800511c:	400a      	ands	r2, r1
 800511e:	d000      	beq.n	8005122 <USBPD_PRL_SendMessage+0x15e>
 8005120:	e103      	b.n	800532a <USBPD_PRL_SendMessage+0x366>
 8005122:	2107      	movs	r1, #7
 8005124:	e102      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 8005126:	72c2      	strb	r2, [r0, #11]
 8005128:	220f      	movs	r2, #15
 800512a:	2103      	movs	r1, #3
 800512c:	6860      	ldr	r0, [r4, #4]
 800512e:	1d80      	adds	r0, r0, #6
 8005130:	f007 fcff 	bl	800cb32 <__aeabi_memset>
 8005134:	2008      	movs	r0, #8
 8005136:	e0bf      	b.n	80052b8 <USBPD_PRL_SendMessage+0x2f4>
 8005138:	8a81      	ldrh	r1, [r0, #20]
 800513a:	0bc9      	lsrs	r1, r1, #15
 800513c:	d06f      	beq.n	800521e <USBPD_PRL_SendMessage+0x25a>
 800513e:	8b41      	ldrh	r1, [r0, #26]
 8005140:	0a89      	lsrs	r1, r1, #10
 8005142:	07c9      	lsls	r1, r1, #31
 8005144:	d462      	bmi.n	800520c <USBPD_PRL_SendMessage+0x248>
 8005146:	8c03      	ldrh	r3, [r0, #32]
 8005148:	2b1b      	cmp	r3, #27
 800514a:	d302      	bcc.n	8005152 <USBPD_PRL_SendMessage+0x18e>
 800514c:	8b41      	ldrh	r1, [r0, #26]
 800514e:	0bc9      	lsrs	r1, r1, #15
 8005150:	d153      	bne.n	80051fa <USBPD_PRL_SendMessage+0x236>
 8005152:	4950      	ldr	r1, [pc, #320]	; (8005294 <USBPD_PRL_SendMessage+0x2d0>)
 8005154:	466e      	mov	r6, sp
 8005156:	7b36      	ldrb	r6, [r6, #12]
 8005158:	00b6      	lsls	r6, r6, #2
 800515a:	1989      	adds	r1, r1, r6
 800515c:	6849      	ldr	r1, [r1, #4]
 800515e:	8b49      	ldrh	r1, [r1, #26]
 8005160:	0ace      	lsrs	r6, r1, #11
 8005162:	0736      	lsls	r6, r6, #28
 8005164:	d106      	bne.n	8005174 <USBPD_PRL_SendMessage+0x1b0>
 8005166:	26fe      	movs	r6, #254	; 0xfe
 8005168:	0236      	lsls	r6, r6, #8
 800516a:	400e      	ands	r6, r1
 800516c:	05d9      	lsls	r1, r3, #23
 800516e:	0dc9      	lsrs	r1, r1, #23
 8005170:	4331      	orrs	r1, r6
 8005172:	8341      	strh	r1, [r0, #26]
 8005174:	8a83      	ldrh	r3, [r0, #20]
 8005176:	4989      	ldr	r1, [pc, #548]	; (800539c <.text_24>)
 8005178:	4019      	ands	r1, r3
 800517a:	8281      	strh	r1, [r0, #20]
 800517c:	8b43      	ldrh	r3, [r0, #26]
 800517e:	0bdb      	lsrs	r3, r3, #15
 8005180:	d038      	beq.n	80051f4 <USBPD_PRL_SendMessage+0x230>
 8005182:	8c03      	ldrh	r3, [r0, #32]
 8005184:	1c9b      	adds	r3, r3, #2
 8005186:	105d      	asrs	r5, r3, #1
 8005188:	0fad      	lsrs	r5, r5, #30
 800518a:	18eb      	adds	r3, r5, r3
 800518c:	109b      	asrs	r3, r3, #2
 800518e:	031b      	lsls	r3, r3, #12
 8005190:	25e0      	movs	r5, #224	; 0xe0
 8005192:	01ed      	lsls	r5, r5, #7
 8005194:	401d      	ands	r5, r3
 8005196:	430d      	orrs	r5, r1
 8005198:	8285      	strh	r5, [r0, #20]
 800519a:	8c00      	ldrh	r0, [r0, #32]
 800519c:	1c81      	adds	r1, r0, #2
 800519e:	1c80      	adds	r0, r0, #2
 80051a0:	104b      	asrs	r3, r1, #1
 80051a2:	0f9b      	lsrs	r3, r3, #30
 80051a4:	1859      	adds	r1, r3, r1
 80051a6:	1089      	asrs	r1, r1, #2
 80051a8:	0089      	lsls	r1, r1, #2
 80051aa:	1a40      	subs	r0, r0, r1
 80051ac:	b2c0      	uxtb	r0, r0
 80051ae:	2800      	cmp	r0, #0
 80051b0:	d01a      	beq.n	80051e8 <USBPD_PRL_SendMessage+0x224>
 80051b2:	2500      	movs	r5, #0
 80051b4:	9000      	str	r0, [sp, #0]
 80051b6:	e005      	b.n	80051c4 <USBPD_PRL_SendMessage+0x200>
 80051b8:	9902      	ldr	r1, [sp, #8]
 80051ba:	1d09      	adds	r1, r1, #4
 80051bc:	8c1b      	ldrh	r3, [r3, #32]
 80051be:	1818      	adds	r0, r3, r0
 80051c0:	540a      	strb	r2, [r1, r0]
 80051c2:	1c6d      	adds	r5, r5, #1
 80051c4:	6863      	ldr	r3, [r4, #4]
 80051c6:	b2e8      	uxtb	r0, r5
 80051c8:	2104      	movs	r1, #4
 80051ca:	9e00      	ldr	r6, [sp, #0]
 80051cc:	1b89      	subs	r1, r1, r6
 80051ce:	4288      	cmp	r0, r1
 80051d0:	dbf2      	blt.n	80051b8 <USBPD_PRL_SendMessage+0x1f4>
 80051d2:	8a99      	ldrh	r1, [r3, #20]
 80051d4:	4871      	ldr	r0, [pc, #452]	; (800539c <.text_24>)
 80051d6:	4008      	ands	r0, r1
 80051d8:	0b09      	lsrs	r1, r1, #12
 80051da:	1c49      	adds	r1, r1, #1
 80051dc:	0309      	lsls	r1, r1, #12
 80051de:	25e0      	movs	r5, #224	; 0xe0
 80051e0:	01ed      	lsls	r5, r5, #7
 80051e2:	400d      	ands	r5, r1
 80051e4:	4305      	orrs	r5, r0
 80051e6:	829d      	strh	r5, [r3, #20]
 80051e8:	6860      	ldr	r0, [r4, #4]
 80051ea:	8a80      	ldrh	r0, [r0, #20]
 80051ec:	0440      	lsls	r0, r0, #17
 80051ee:	0f40      	lsrs	r0, r0, #29
 80051f0:	0085      	lsls	r5, r0, #2
 80051f2:	1cad      	adds	r5, r5, #2
 80051f4:	6860      	ldr	r0, [r4, #4]
 80051f6:	8402      	strh	r2, [r0, #32]
 80051f8:	e008      	b.n	800520c <USBPD_PRL_SendMessage+0x248>
 80051fa:	8a81      	ldrh	r1, [r0, #20]
 80051fc:	22e0      	movs	r2, #224	; 0xe0
 80051fe:	01d2      	lsls	r2, r2, #7
 8005200:	430a      	orrs	r2, r1
 8005202:	8282      	strh	r2, [r0, #20]
 8005204:	8c01      	ldrh	r1, [r0, #32]
 8005206:	391a      	subs	r1, #26
 8005208:	8401      	strh	r1, [r0, #32]
 800520a:	251e      	movs	r5, #30
 800520c:	6860      	ldr	r0, [r4, #4]
 800520e:	8b40      	ldrh	r0, [r0, #26]
 8005210:	9902      	ldr	r1, [sp, #8]
 8005212:	7088      	strb	r0, [r1, #2]
 8005214:	6860      	ldr	r0, [r4, #4]
 8005216:	8b40      	ldrh	r0, [r0, #26]
 8005218:	0a00      	lsrs	r0, r0, #8
 800521a:	9902      	ldr	r1, [sp, #8]
 800521c:	70c8      	strb	r0, [r1, #3]
 800521e:	6860      	ldr	r0, [r4, #4]
 8005220:	7ac2      	ldrb	r2, [r0, #11]
 8005222:	8a83      	ldrh	r3, [r0, #20]
 8005224:	4999      	ldr	r1, [pc, #612]	; (800548c <.text_29>)
 8005226:	4019      	ands	r1, r3
 8005228:	0253      	lsls	r3, r2, #9
 800522a:	22e0      	movs	r2, #224	; 0xe0
 800522c:	0112      	lsls	r2, r2, #4
 800522e:	401a      	ands	r2, r3
 8005230:	430a      	orrs	r2, r1
 8005232:	8282      	strh	r2, [r0, #20]
 8005234:	4668      	mov	r0, sp
 8005236:	7900      	ldrb	r0, [r0, #4]
 8005238:	2800      	cmp	r0, #0
 800523a:	d004      	beq.n	8005246 <USBPD_PRL_SendMessage+0x282>
 800523c:	4894      	ldr	r0, [pc, #592]	; (8005490 <.text_30>)
 800523e:	4010      	ands	r0, r2
 8005240:	9a02      	ldr	r2, [sp, #8]
 8005242:	7010      	strb	r0, [r2, #0]
 8005244:	e003      	b.n	800524e <USBPD_PRL_SendMessage+0x28a>
 8005246:	9802      	ldr	r0, [sp, #8]
 8005248:	7002      	strb	r2, [r0, #0]
 800524a:	6860      	ldr	r0, [r4, #4]
 800524c:	8a80      	ldrh	r0, [r0, #20]
 800524e:	0a00      	lsrs	r0, r0, #8
 8005250:	9902      	ldr	r1, [sp, #8]
 8005252:	7048      	strb	r0, [r1, #1]
 8005254:	480f      	ldr	r0, [pc, #60]	; (8005294 <USBPD_PRL_SendMessage+0x2d0>)
 8005256:	8005      	strh	r5, [r0, #0]
 8005258:	6860      	ldr	r0, [r4, #4]
 800525a:	2109      	movs	r1, #9
 800525c:	7101      	strb	r1, [r0, #4]
 800525e:	2102      	movs	r1, #2
 8005260:	7481      	strb	r1, [r0, #18]
 8005262:	488c      	ldr	r0, [pc, #560]	; (8005494 <.text_31>)
 8005264:	6804      	ldr	r4, [r0, #0]
 8005266:	2c00      	cmp	r4, #0
 8005268:	d007      	beq.n	800527a <USBPD_PRL_SendMessage+0x2b6>
 800526a:	b2a8      	uxth	r0, r5
 800526c:	9000      	str	r0, [sp, #0]
 800526e:	9b02      	ldr	r3, [sp, #8]
 8005270:	4668      	mov	r0, sp
 8005272:	7902      	ldrb	r2, [r0, #4]
 8005274:	7b01      	ldrb	r1, [r0, #12]
 8005276:	2002      	movs	r0, #2
 8005278:	47a0      	blx	r4
 800527a:	4668      	mov	r0, sp
 800527c:	7b00      	ldrb	r0, [r0, #12]
 800527e:	2800      	cmp	r0, #0
 8005280:	d101      	bne.n	8005286 <USBPD_PRL_SendMessage+0x2c2>
 8005282:	2001      	movs	r0, #1
 8005284:	e000      	b.n	8005288 <USBPD_PRL_SendMessage+0x2c4>
 8005286:	2003      	movs	r0, #3
 8005288:	4983      	ldr	r1, [pc, #524]	; (8005498 <.text_32>)
 800528a:	f006 fb5b 	bl	800b944 <USBPD_TIM_Start>
 800528e:	b2ab      	uxth	r3, r5
 8005290:	e06c      	b.n	800536c <USBPD_PRL_SendMessage+0x3a8>
 8005292:	bf00      	nop
 8005294:	200019bc 	.word	0x200019bc
 8005298:	4668      	mov	r0, sp
 800529a:	7b00      	ldrb	r0, [r0, #12]
 800529c:	2800      	cmp	r0, #0
 800529e:	d101      	bne.n	80052a4 <USBPD_PRL_SendMessage+0x2e0>
 80052a0:	2001      	movs	r0, #1
 80052a2:	e000      	b.n	80052a6 <USBPD_PRL_SendMessage+0x2e2>
 80052a4:	2003      	movs	r0, #3
 80052a6:	f006 fb7c 	bl	800b9a2 <USBPD_TIM_IsExpired>
 80052aa:	2801      	cmp	r0, #1
 80052ac:	d003      	beq.n	80052b6 <USBPD_PRL_SendMessage+0x2f2>
 80052ae:	6860      	ldr	r0, [r4, #4]
 80052b0:	7b80      	ldrb	r0, [r0, #14]
 80052b2:	2801      	cmp	r0, #1
 80052b4:	d166      	bne.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 80052b6:	200c      	movs	r0, #12
 80052b8:	6861      	ldr	r1, [r4, #4]
 80052ba:	7108      	strb	r0, [r1, #4]
 80052bc:	e062      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 80052be:	7ac1      	ldrb	r1, [r0, #11]
 80052c0:	2207      	movs	r2, #7
 80052c2:	8b03      	ldrh	r3, [r0, #24]
 80052c4:	0a5d      	lsrs	r5, r3, #9
 80052c6:	2307      	movs	r3, #7
 80052c8:	402b      	ands	r3, r5
 80052ca:	4299      	cmp	r1, r3
 80052cc:	d1f3      	bne.n	80052b6 <USBPD_PRL_SendMessage+0x2f2>
 80052ce:	7e03      	ldrb	r3, [r0, #24]
 80052d0:	06db      	lsls	r3, r3, #27
 80052d2:	0edb      	lsrs	r3, r3, #27
 80052d4:	2b01      	cmp	r3, #1
 80052d6:	d1ee      	bne.n	80052b6 <USBPD_PRL_SendMessage+0x2f2>
 80052d8:	1c49      	adds	r1, r1, #1
 80052da:	400a      	ands	r2, r1
 80052dc:	72c2      	strb	r2, [r0, #11]
 80052de:	6860      	ldr	r0, [r4, #4]
 80052e0:	7106      	strb	r6, [r0, #4]
 80052e2:	e00d      	b.n	8005300 <USBPD_PRL_SendMessage+0x33c>
 80052e4:	7ac1      	ldrb	r1, [r0, #11]
 80052e6:	1c49      	adds	r1, r1, #1
 80052e8:	0749      	lsls	r1, r1, #29
 80052ea:	0f49      	lsrs	r1, r1, #29
 80052ec:	72c1      	strb	r1, [r0, #11]
 80052ee:	6860      	ldr	r0, [r4, #4]
 80052f0:	7106      	strb	r6, [r0, #4]
 80052f2:	8b42      	ldrh	r2, [r0, #26]
 80052f4:	4969      	ldr	r1, [pc, #420]	; (800549c <.text_33>)
 80052f6:	4011      	ands	r1, r2
 80052f8:	8341      	strh	r1, [r0, #26]
 80052fa:	4a69      	ldr	r2, [pc, #420]	; (80054a0 <.text_34>)
 80052fc:	400a      	ands	r2, r1
 80052fe:	8342      	strh	r2, [r0, #26]
 8005300:	2705      	movs	r7, #5
 8005302:	e03f      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005304:	7b01      	ldrb	r1, [r0, #12]
 8005306:	1c49      	adds	r1, r1, #1
 8005308:	7301      	strb	r1, [r0, #12]
 800530a:	6860      	ldr	r0, [r4, #4]
 800530c:	8a81      	ldrh	r1, [r0, #20]
 800530e:	2203      	movs	r2, #3
 8005310:	098b      	lsrs	r3, r1, #6
 8005312:	2403      	movs	r4, #3
 8005314:	401c      	ands	r4, r3
 8005316:	2c01      	cmp	r4, #1
 8005318:	d000      	beq.n	800531c <USBPD_PRL_SendMessage+0x358>
 800531a:	2202      	movs	r2, #2
 800531c:	7b03      	ldrb	r3, [r0, #12]
 800531e:	429a      	cmp	r2, r3
 8005320:	d306      	bcc.n	8005330 <USBPD_PRL_SendMessage+0x36c>
 8005322:	0bc9      	lsrs	r1, r1, #15
 8005324:	d001      	beq.n	800532a <USBPD_PRL_SendMessage+0x366>
 8005326:	210f      	movs	r1, #15
 8005328:	e000      	b.n	800532c <USBPD_PRL_SendMessage+0x368>
 800532a:	2108      	movs	r1, #8
 800532c:	7101      	strb	r1, [r0, #4]
 800532e:	e029      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005330:	7106      	strb	r6, [r0, #4]
 8005332:	2707      	movs	r7, #7
 8005334:	e026      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005336:	2109      	movs	r1, #9
 8005338:	7101      	strb	r1, [r0, #4]
 800533a:	2102      	movs	r1, #2
 800533c:	7481      	strb	r1, [r0, #18]
 800533e:	4668      	mov	r0, sp
 8005340:	7b00      	ldrb	r0, [r0, #12]
 8005342:	2800      	cmp	r0, #0
 8005344:	d101      	bne.n	800534a <USBPD_PRL_SendMessage+0x386>
 8005346:	2001      	movs	r0, #1
 8005348:	e000      	b.n	800534c <USBPD_PRL_SendMessage+0x388>
 800534a:	2003      	movs	r0, #3
 800534c:	4955      	ldr	r1, [pc, #340]	; (80054a4 <.text_35>)
 800534e:	f006 faf9 	bl	800b944 <USBPD_TIM_Start>
 8005352:	4850      	ldr	r0, [pc, #320]	; (8005494 <.text_31>)
 8005354:	6804      	ldr	r4, [r0, #0]
 8005356:	2c00      	cmp	r4, #0
 8005358:	d006      	beq.n	8005368 <USBPD_PRL_SendMessage+0x3a4>
 800535a:	9500      	str	r5, [sp, #0]
 800535c:	9b02      	ldr	r3, [sp, #8]
 800535e:	4668      	mov	r0, sp
 8005360:	7902      	ldrb	r2, [r0, #4]
 8005362:	7b01      	ldrb	r1, [r0, #12]
 8005364:	2002      	movs	r0, #2
 8005366:	47a0      	blx	r4
 8005368:	484f      	ldr	r0, [pc, #316]	; (80054a8 <.text_36>)
 800536a:	8803      	ldrh	r3, [r0, #0]
 800536c:	9a02      	ldr	r2, [sp, #8]
 800536e:	4668      	mov	r0, sp
 8005370:	7901      	ldrb	r1, [r0, #4]
 8005372:	7b00      	ldrb	r0, [r0, #12]
 8005374:	f004 fd5c 	bl	8009e30 <USBPD_PHY_SendMessage>
 8005378:	e004      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 800537a:	7106      	strb	r6, [r0, #4]
 800537c:	2706      	movs	r7, #6
 800537e:	e001      	b.n	8005384 <USBPD_PRL_SendMessage+0x3c0>
 8005380:	7106      	strb	r6, [r0, #4]
 8005382:	2710      	movs	r7, #16
 8005384:	0038      	movs	r0, r7
 8005386:	b005      	add	sp, #20
 8005388:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800538a <USBPD_PRL_ResetRequestReset>:
 800538a:	4947      	ldr	r1, [pc, #284]	; (80054a8 <.text_36>)
 800538c:	0080      	lsls	r0, r0, #2
 800538e:	1808      	adds	r0, r1, r0
 8005390:	6840      	ldr	r0, [r0, #4]
 8005392:	2100      	movs	r1, #0
 8005394:	7141      	strb	r1, [r0, #5]
 8005396:	4770      	bx	lr

08005398 <.text_23>:
 8005398:	0000ffe0 	.word	0x0000ffe0

0800539c <.text_24>:
 800539c:	00008fff 	.word	0x00008fff

080053a0 <USBPD_PRL_ResetRequestProcess>:
 80053a0:	b5f1      	push	{r0, r4, r5, r6, r7, lr}
 80053a2:	b082      	sub	sp, #8
 80053a4:	000d      	movs	r5, r1
 80053a6:	2403      	movs	r4, #3
 80053a8:	483f      	ldr	r0, [pc, #252]	; (80054a8 <.text_36>)
 80053aa:	4669      	mov	r1, sp
 80053ac:	7a09      	ldrb	r1, [r1, #8]
 80053ae:	0089      	lsls	r1, r1, #2
 80053b0:	1846      	adds	r6, r0, r1
 80053b2:	6871      	ldr	r1, [r6, #4]
 80053b4:	2000      	movs	r0, #0
 80053b6:	2202      	movs	r2, #2
 80053b8:	794b      	ldrb	r3, [r1, #5]
 80053ba:	2b00      	cmp	r3, #0
 80053bc:	d003      	beq.n	80053c6 <USBPD_PRL_ResetRequestProcess+0x26>
 80053be:	2b02      	cmp	r3, #2
 80053c0:	d030      	beq.n	8005424 <USBPD_PRL_ResetRequestProcess+0x84>
 80053c2:	d323      	bcc.n	800540c <USBPD_PRL_ResetRequestProcess+0x6c>
 80053c4:	e031      	b.n	800542a <USBPD_PRL_ResetRequestProcess+0x8a>
 80053c6:	7348      	strb	r0, [r1, #13]
 80053c8:	6871      	ldr	r1, [r6, #4]
 80053ca:	72c8      	strb	r0, [r1, #11]
 80053cc:	220f      	movs	r2, #15
 80053ce:	2103      	movs	r1, #3
 80053d0:	6870      	ldr	r0, [r6, #4]
 80053d2:	1d80      	adds	r0, r0, #6
 80053d4:	f007 fbad 	bl	800cb32 <__aeabi_memset>
 80053d8:	2006      	movs	r0, #6
 80053da:	6871      	ldr	r1, [r6, #4]
 80053dc:	7108      	strb	r0, [r1, #4]
 80053de:	482d      	ldr	r0, [pc, #180]	; (8005494 <.text_31>)
 80053e0:	6807      	ldr	r7, [r0, #0]
 80053e2:	2f00      	cmp	r7, #0
 80053e4:	d007      	beq.n	80053f6 <USBPD_PRL_ResetRequestProcess+0x56>
 80053e6:	2000      	movs	r0, #0
 80053e8:	9000      	str	r0, [sp, #0]
 80053ea:	2300      	movs	r3, #0
 80053ec:	2205      	movs	r2, #5
 80053ee:	4668      	mov	r0, sp
 80053f0:	7a01      	ldrb	r1, [r0, #8]
 80053f2:	2002      	movs	r0, #2
 80053f4:	47b8      	blx	r7
 80053f6:	0029      	movs	r1, r5
 80053f8:	4668      	mov	r0, sp
 80053fa:	7a00      	ldrb	r0, [r0, #8]
 80053fc:	f004 fd38 	bl	8009e70 <USBPD_PHY_ResetRequest>
 8005400:	6870      	ldr	r0, [r6, #4]
 8005402:	2101      	movs	r1, #1
 8005404:	7141      	strb	r1, [r0, #5]
 8005406:	2105      	movs	r1, #5
 8005408:	7281      	strb	r1, [r0, #10]
 800540a:	e010      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 800540c:	7b4b      	ldrb	r3, [r1, #13]
 800540e:	2b01      	cmp	r3, #1
 8005410:	d102      	bne.n	8005418 <USBPD_PRL_ResetRequestProcess+0x78>
 8005412:	714a      	strb	r2, [r1, #5]
 8005414:	7348      	strb	r0, [r1, #13]
 8005416:	e00a      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 8005418:	7a8a      	ldrb	r2, [r1, #10]
 800541a:	2a00      	cmp	r2, #0
 800541c:	d107      	bne.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 800541e:	7148      	strb	r0, [r1, #5]
 8005420:	2404      	movs	r4, #4
 8005422:	e004      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 8005424:	7148      	strb	r0, [r1, #5]
 8005426:	2400      	movs	r4, #0
 8005428:	e001      	b.n	800542e <USBPD_PRL_ResetRequestProcess+0x8e>
 800542a:	7148      	strb	r0, [r1, #5]
 800542c:	2402      	movs	r4, #2
 800542e:	0020      	movs	r0, r4
 8005430:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08005432 <USBDPD_PRL_BistCarrierEyeMode>:
 8005432:	b580      	push	{r7, lr}
 8005434:	2905      	cmp	r1, #5
 8005436:	d102      	bne.n	800543e <USBDPD_PRL_BistCarrierEyeMode+0xc>
 8005438:	f004 fbe6 	bl	8009c08 <USBPD_PHY_Send_BIST_Pattern>
 800543c:	bd02      	pop	{r1, pc}
 800543e:	2010      	movs	r0, #16
 8005440:	bd02      	pop	{r1, pc}

08005442 <USBDPD_PRL_BistCarrierEyeModeExit>:
 8005442:	b580      	push	{r7, lr}
 8005444:	2905      	cmp	r1, #5
 8005446:	d103      	bne.n	8005450 <USBDPD_PRL_BistCarrierEyeModeExit+0xe>
 8005448:	2107      	movs	r1, #7
 800544a:	f004 fbeb 	bl	8009c24 <USBPD_PHY_ExitTransmit>
 800544e:	bd02      	pop	{r1, pc}
 8005450:	2010      	movs	r0, #16
 8005452:	bd02      	pop	{r1, pc}

08005454 <USBPD_PRL_Reset>:
 8005454:	b538      	push	{r3, r4, r5, lr}
 8005456:	4914      	ldr	r1, [pc, #80]	; (80054a8 <.text_36>)
 8005458:	0080      	lsls	r0, r0, #2
 800545a:	180c      	adds	r4, r1, r0
 800545c:	6860      	ldr	r0, [r4, #4]
 800545e:	2500      	movs	r5, #0
 8005460:	7105      	strb	r5, [r0, #4]
 8005462:	7145      	strb	r5, [r0, #5]
 8005464:	7285      	strb	r5, [r0, #10]
 8005466:	6860      	ldr	r0, [r4, #4]
 8005468:	72c5      	strb	r5, [r0, #11]
 800546a:	220f      	movs	r2, #15
 800546c:	2103      	movs	r1, #3
 800546e:	6860      	ldr	r0, [r4, #4]
 8005470:	1d80      	adds	r0, r0, #6
 8005472:	f007 fb5e 	bl	800cb32 <__aeabi_memset>
 8005476:	6860      	ldr	r0, [r4, #4]
 8005478:	7305      	strb	r5, [r0, #12]
 800547a:	6860      	ldr	r0, [r4, #4]
 800547c:	7345      	strb	r5, [r0, #13]
 800547e:	6860      	ldr	r0, [r4, #4]
 8005480:	7385      	strb	r5, [r0, #14]
 8005482:	6860      	ldr	r0, [r4, #4]
 8005484:	2123      	movs	r1, #35	; 0x23
 8005486:	5445      	strb	r5, [r0, r1]
 8005488:	bd31      	pop	{r0, r4, r5, pc}
	...

0800548c <.text_29>:
 800548c:	0000f1ff 	.word	0x0000f1ff

08005490 <.text_30>:
 8005490:	0000fedf 	.word	0x0000fedf

08005494 <.text_31>:
 8005494:	200019b4 	.word	0x200019b4

08005498 <.text_32>:
 8005498:	00002710 	.word	0x00002710

0800549c <.text_33>:
 800549c:	000087ff 	.word	0x000087ff

080054a0 <.text_34>:
 80054a0:	0000fbff 	.word	0x0000fbff

080054a4 <.text_35>:
 80054a4:	000009c4 	.word	0x000009c4

080054a8 <.text_36>:
 80054a8:	200019bc 	.word	0x200019bc

080054ac <USBPD_PRL_DeInit>:
 80054ac:	4770      	bx	lr

080054ae <PRL_Received>:
 80054ae:	b5f3      	push	{r0, r1, r4, r5, r6, r7, lr}
 80054b0:	b083      	sub	sp, #12
 80054b2:	48c4      	ldr	r0, [pc, #784]	; (80057c4 <.text_39>)
 80054b4:	8800      	ldrh	r0, [r0, #0]
 80054b6:	4669      	mov	r1, sp
 80054b8:	80c8      	strh	r0, [r1, #6]
 80054ba:	48c3      	ldr	r0, [pc, #780]	; (80057c8 <.text_40>)
 80054bc:	7b09      	ldrb	r1, [r1, #12]
 80054be:	0089      	lsls	r1, r1, #2
 80054c0:	1846      	adds	r6, r0, r1
 80054c2:	6870      	ldr	r0, [r6, #4]
 80054c4:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80054c6:	780a      	ldrb	r2, [r1, #0]
 80054c8:	7849      	ldrb	r1, [r1, #1]
 80054ca:	0209      	lsls	r1, r1, #8
 80054cc:	1851      	adds	r1, r2, r1
 80054ce:	466a      	mov	r2, sp
 80054d0:	8091      	strh	r1, [r2, #4]
 80054d2:	4fbe      	ldr	r7, [pc, #760]	; (80057cc <.text_41>)
 80054d4:	683c      	ldr	r4, [r7, #0]
 80054d6:	4669      	mov	r1, sp
 80054d8:	8889      	ldrh	r1, [r1, #4]
 80054da:	0bc9      	lsrs	r1, r1, #15
 80054dc:	d00b      	beq.n	80054f6 <PRL_Received+0x48>
 80054de:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80054e0:	7898      	ldrb	r0, [r3, #2]
 80054e2:	78d9      	ldrb	r1, [r3, #3]
 80054e4:	0209      	lsls	r1, r1, #8
 80054e6:	1845      	adds	r5, r0, r1
 80054e8:	2c00      	cmp	r4, #0
 80054ea:	d013      	beq.n	8005514 <PRL_Received+0x66>
 80054ec:	05e8      	lsls	r0, r5, #23
 80054ee:	0dc0      	lsrs	r0, r0, #23
 80054f0:	1d00      	adds	r0, r0, #4
 80054f2:	9000      	str	r0, [sp, #0]
 80054f4:	e009      	b.n	800550a <PRL_Received+0x5c>
 80054f6:	2c00      	cmp	r4, #0
 80054f8:	d00c      	beq.n	8005514 <PRL_Received+0x66>
 80054fa:	4669      	mov	r1, sp
 80054fc:	8889      	ldrh	r1, [r1, #4]
 80054fe:	0449      	lsls	r1, r1, #17
 8005500:	0f49      	lsrs	r1, r1, #29
 8005502:	0089      	lsls	r1, r1, #2
 8005504:	1c89      	adds	r1, r1, #2
 8005506:	9100      	str	r1, [sp, #0]
 8005508:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800550a:	4668      	mov	r0, sp
 800550c:	7c02      	ldrb	r2, [r0, #16]
 800550e:	7b01      	ldrb	r1, [r0, #12]
 8005510:	2001      	movs	r0, #1
 8005512:	47a0      	blx	r4
 8005514:	6870      	ldr	r0, [r6, #4]
 8005516:	49c7      	ldr	r1, [pc, #796]	; (8005834 <.text_45>)
 8005518:	466a      	mov	r2, sp
 800551a:	8892      	ldrh	r2, [r2, #4]
 800551c:	400a      	ands	r2, r1
 800551e:	2a01      	cmp	r2, #1
 8005520:	d105      	bne.n	800552e <PRL_Received+0x80>
 8005522:	210a      	movs	r1, #10
 8005524:	7101      	strb	r1, [r0, #4]
 8005526:	4669      	mov	r1, sp
 8005528:	8889      	ldrh	r1, [r1, #4]
 800552a:	8301      	strh	r1, [r0, #24]
 800552c:	e13b      	b.n	80057a6 <PRL_Received+0x2f8>
 800552e:	466a      	mov	r2, sp
 8005530:	7c12      	ldrb	r2, [r2, #16]
 8005532:	7242      	strb	r2, [r0, #9]
 8005534:	2400      	movs	r4, #0
 8005536:	466a      	mov	r2, sp
 8005538:	8892      	ldrh	r2, [r2, #4]
 800553a:	4011      	ands	r1, r2
 800553c:	290d      	cmp	r1, #13
 800553e:	d108      	bne.n	8005552 <PRL_Received+0xa4>
 8005540:	72c4      	strb	r4, [r0, #11]
 8005542:	220f      	movs	r2, #15
 8005544:	2103      	movs	r1, #3
 8005546:	6870      	ldr	r0, [r6, #4]
 8005548:	1d80      	adds	r0, r0, #6
 800554a:	f007 faf2 	bl	800cb32 <__aeabi_memset>
 800554e:	6871      	ldr	r1, [r6, #4]
 8005550:	710c      	strb	r4, [r1, #4]
 8005552:	4668      	mov	r0, sp
 8005554:	88c0      	ldrh	r0, [r0, #6]
 8005556:	49bd      	ldr	r1, [pc, #756]	; (800584c <.text_47>)
 8005558:	4001      	ands	r1, r0
 800555a:	2001      	movs	r0, #1
 800555c:	4308      	orrs	r0, r1
 800555e:	4669      	mov	r1, sp
 8005560:	4abb      	ldr	r2, [pc, #748]	; (8005850 <.text_48>)
 8005562:	4002      	ands	r2, r0
 8005564:	800a      	strh	r2, [r1, #0]
 8005566:	4668      	mov	r0, sp
 8005568:	7c00      	ldrb	r0, [r0, #16]
 800556a:	2800      	cmp	r0, #0
 800556c:	d10e      	bne.n	800558c <PRL_Received+0xde>
 800556e:	6870      	ldr	r0, [r6, #4]
 8005570:	8a82      	ldrh	r2, [r0, #20]
 8005572:	2101      	movs	r1, #1
 8005574:	0953      	lsrs	r3, r2, #5
 8005576:	2001      	movs	r0, #1
 8005578:	4018      	ands	r0, r3
 800557a:	0a12      	lsrs	r2, r2, #8
 800557c:	4011      	ands	r1, r2
 800557e:	466a      	mov	r2, sp
 8005580:	8812      	ldrh	r2, [r2, #0]
 8005582:	0140      	lsls	r0, r0, #5
 8005584:	4310      	orrs	r0, r2
 8005586:	0209      	lsls	r1, r1, #8
 8005588:	4301      	orrs	r1, r0
 800558a:	e000      	b.n	800558e <PRL_Received+0xe0>
 800558c:	4611      	mov	r1, r2
 800558e:	48c2      	ldr	r0, [pc, #776]	; (8005898 <.text_50>)
 8005590:	4008      	ands	r0, r1
 8005592:	4669      	mov	r1, sp
 8005594:	8889      	ldrh	r1, [r1, #4]
 8005596:	0609      	lsls	r1, r1, #24
 8005598:	0f89      	lsrs	r1, r1, #30
 800559a:	2902      	cmp	r1, #2
 800559c:	da02      	bge.n	80055a4 <PRL_Received+0xf6>
 800559e:	0001      	movs	r1, r0
 80055a0:	2040      	movs	r0, #64	; 0x40
 80055a2:	4308      	orrs	r0, r1
 80055a4:	05c1      	lsls	r1, r0, #23
 80055a6:	0dc9      	lsrs	r1, r1, #23
 80055a8:	4668      	mov	r0, sp
 80055aa:	8882      	ldrh	r2, [r0, #4]
 80055ac:	20e0      	movs	r0, #224	; 0xe0
 80055ae:	0100      	lsls	r0, r0, #4
 80055b0:	4010      	ands	r0, r2
 80055b2:	4308      	orrs	r0, r1
 80055b4:	6872      	ldr	r2, [r6, #4]
 80055b6:	7590      	strb	r0, [r2, #22]
 80055b8:	0a00      	lsrs	r0, r0, #8
 80055ba:	6871      	ldr	r1, [r6, #4]
 80055bc:	75c8      	strb	r0, [r1, #23]
 80055be:	6870      	ldr	r0, [r6, #4]
 80055c0:	2101      	movs	r1, #1
 80055c2:	7481      	strb	r1, [r0, #18]
 80055c4:	683f      	ldr	r7, [r7, #0]
 80055c6:	2f00      	cmp	r7, #0
 80055c8:	d008      	beq.n	80055dc <PRL_Received+0x12e>
 80055ca:	2102      	movs	r1, #2
 80055cc:	9100      	str	r1, [sp, #0]
 80055ce:	0003      	movs	r3, r0
 80055d0:	3316      	adds	r3, #22
 80055d2:	4668      	mov	r0, sp
 80055d4:	7c02      	ldrb	r2, [r0, #16]
 80055d6:	7b01      	ldrb	r1, [r0, #12]
 80055d8:	2002      	movs	r0, #2
 80055da:	47b8      	blx	r7
 80055dc:	2302      	movs	r3, #2
 80055de:	6872      	ldr	r2, [r6, #4]
 80055e0:	3216      	adds	r2, #22
 80055e2:	4668      	mov	r0, sp
 80055e4:	7c01      	ldrb	r1, [r0, #16]
 80055e6:	7b00      	ldrb	r0, [r0, #12]
 80055e8:	f004 fc22 	bl	8009e30 <USBPD_PHY_SendMessage>
 80055ec:	2800      	cmp	r0, #0
 80055ee:	d19d      	bne.n	800552c <PRL_Received+0x7e>
 80055f0:	6870      	ldr	r0, [r6, #4]
 80055f2:	1d81      	adds	r1, r0, #6
 80055f4:	466a      	mov	r2, sp
 80055f6:	7c12      	ldrb	r2, [r2, #16]
 80055f8:	1889      	adds	r1, r1, r2
 80055fa:	9100      	str	r1, [sp, #0]
 80055fc:	4669      	mov	r1, sp
 80055fe:	8889      	ldrh	r1, [r1, #4]
 8005600:	0a49      	lsrs	r1, r1, #9
 8005602:	2207      	movs	r2, #7
 8005604:	9b00      	ldr	r3, [sp, #0]
 8005606:	781b      	ldrb	r3, [r3, #0]
 8005608:	2707      	movs	r7, #7
 800560a:	400f      	ands	r7, r1
 800560c:	42bb      	cmp	r3, r7
 800560e:	d100      	bne.n	8005612 <PRL_Received+0x164>
 8005610:	e0c8      	b.n	80057a4 <PRL_Received+0x2f6>
 8005612:	2007      	movs	r0, #7
 8005614:	4008      	ands	r0, r1
 8005616:	9900      	ldr	r1, [sp, #0]
 8005618:	7008      	strb	r0, [r1, #0]
 800561a:	6873      	ldr	r3, [r6, #4]
 800561c:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800561e:	7881      	ldrb	r1, [r0, #2]
 8005620:	78c7      	ldrb	r7, [r0, #3]
 8005622:	023f      	lsls	r7, r7, #8
 8005624:	19c9      	adds	r1, r1, r7
 8005626:	7907      	ldrb	r7, [r0, #4]
 8005628:	043f      	lsls	r7, r7, #16
 800562a:	19c9      	adds	r1, r1, r7
 800562c:	7940      	ldrb	r0, [r0, #5]
 800562e:	0600      	lsls	r0, r0, #24
 8005630:	1808      	adds	r0, r1, r0
 8005632:	4669      	mov	r1, sp
 8005634:	8889      	ldrh	r1, [r1, #4]
 8005636:	0b09      	lsrs	r1, r1, #12
 8005638:	4211      	tst	r1, r2
 800563a:	d00f      	beq.n	800565c <PRL_Received+0x1ae>
 800563c:	4669      	mov	r1, sp
 800563e:	8889      	ldrh	r1, [r1, #4]
 8005640:	06c9      	lsls	r1, r1, #27
 8005642:	0ec9      	lsrs	r1, r1, #27
 8005644:	2903      	cmp	r1, #3
 8005646:	d109      	bne.n	800565c <PRL_Received+0x1ae>
 8005648:	0f00      	lsrs	r0, r0, #28
 800564a:	2808      	cmp	r0, #8
 800564c:	d001      	beq.n	8005652 <PRL_Received+0x1a4>
 800564e:	2800      	cmp	r0, #0
 8005650:	d104      	bne.n	800565c <PRL_Received+0x1ae>
 8005652:	aa01      	add	r2, sp, #4
 8005654:	4668      	mov	r0, sp
 8005656:	7c01      	ldrb	r1, [r0, #16]
 8005658:	7b00      	ldrb	r0, [r0, #12]
 800565a:	e09f      	b.n	800579c <PRL_Received+0x2ee>
 800565c:	4668      	mov	r0, sp
 800565e:	8880      	ldrh	r0, [r0, #4]
 8005660:	83d8      	strh	r0, [r3, #30]
 8005662:	4668      	mov	r0, sp
 8005664:	8880      	ldrh	r0, [r0, #4]
 8005666:	0bc0      	lsrs	r0, r0, #15
 8005668:	d031      	beq.n	80056ce <PRL_Received+0x220>
 800566a:	0428      	lsls	r0, r5, #16
 800566c:	0fc0      	lsrs	r0, r0, #31
 800566e:	d02e      	beq.n	80056ce <PRL_Received+0x220>
 8005670:	839d      	strh	r5, [r3, #28]
 8005672:	200f      	movs	r0, #15
 8005674:	4669      	mov	r1, sp
 8005676:	8889      	ldrh	r1, [r1, #4]
 8005678:	0b09      	lsrs	r1, r1, #12
 800567a:	400a      	ands	r2, r1
 800567c:	21f8      	movs	r1, #248	; 0xf8
 800567e:	01c9      	lsls	r1, r1, #7
 8005680:	4029      	ands	r1, r5
 8005682:	d138      	bne.n	80056f6 <PRL_Received+0x248>
 8005684:	2a06      	cmp	r2, #6
 8005686:	dd03      	ble.n	8005690 <PRL_Received+0x1e2>
 8005688:	05e9      	lsls	r1, r5, #23
 800568a:	0dc9      	lsrs	r1, r1, #23
 800568c:	291a      	cmp	r1, #26
 800568e:	d821      	bhi.n	80056d4 <PRL_Received+0x226>
 8005690:	2100      	movs	r1, #0
 8005692:	042a      	lsls	r2, r5, #16
 8005694:	0ed2      	lsrs	r2, r2, #27
 8005696:	4010      	ands	r0, r2
 8005698:	221a      	movs	r2, #26
 800569a:	4342      	muls	r2, r0
 800569c:	2307      	movs	r3, #7
 800569e:	e007      	b.n	80056b0 <PRL_Received+0x202>
 80056a0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80056a2:	1d00      	adds	r0, r0, #4
 80056a4:	5c40      	ldrb	r0, [r0, r1]
 80056a6:	6aa4      	ldr	r4, [r4, #40]	; 0x28
 80056a8:	188f      	adds	r7, r1, r2
 80056aa:	55e0      	strb	r0, [r4, r7]
 80056ac:	1c49      	adds	r1, r1, #1
 80056ae:	b289      	uxth	r1, r1
 80056b0:	4668      	mov	r0, sp
 80056b2:	8880      	ldrh	r0, [r0, #4]
 80056b4:	0b00      	lsrs	r0, r0, #12
 80056b6:	4018      	ands	r0, r3
 80056b8:	0080      	lsls	r0, r0, #2
 80056ba:	1e80      	subs	r0, r0, #2
 80056bc:	6874      	ldr	r4, [r6, #4]
 80056be:	4281      	cmp	r1, r0
 80056c0:	dbee      	blt.n	80056a0 <PRL_Received+0x1f2>
 80056c2:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80056c4:	05e9      	lsls	r1, r5, #23
 80056c6:	0dc9      	lsrs	r1, r1, #23
 80056c8:	4288      	cmp	r0, r1
 80056ca:	da01      	bge.n	80056d0 <PRL_Received+0x222>
 80056cc:	8010      	strh	r0, [r2, #0]
 80056ce:	e060      	b.n	8005792 <PRL_Received+0x2e4>
 80056d0:	8011      	strh	r1, [r2, #0]
 80056d2:	e05e      	b.n	8005792 <PRL_Received+0x2e4>
 80056d4:	2001      	movs	r0, #1
 80056d6:	2123      	movs	r1, #35	; 0x23
 80056d8:	5458      	strb	r0, [r3, r1]
 80056da:	6870      	ldr	r0, [r6, #4]
 80056dc:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80056de:	1d09      	adds	r1, r1, #4
 80056e0:	5d09      	ldrb	r1, [r1, r4]
 80056e2:	6a80      	ldr	r0, [r0, #40]	; 0x28
 80056e4:	5501      	strb	r1, [r0, r4]
 80056e6:	1c64      	adds	r4, r4, #1
 80056e8:	2c1a      	cmp	r4, #26
 80056ea:	d3f6      	bcc.n	80056da <PRL_Received+0x22c>
 80056ec:	201a      	movs	r0, #26
 80056ee:	6871      	ldr	r1, [r6, #4]
 80056f0:	6a49      	ldr	r1, [r1, #36]	; 0x24
 80056f2:	8008      	strh	r0, [r1, #0]
 80056f4:	e04d      	b.n	8005792 <PRL_Received+0x2e4>
 80056f6:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80056f8:	8809      	ldrh	r1, [r1, #0]
 80056fa:	0092      	lsls	r2, r2, #2
 80056fc:	188a      	adds	r2, r1, r2
 80056fe:	1e92      	subs	r2, r2, #2
 8005700:	27ff      	movs	r7, #255	; 0xff
 8005702:	1dbf      	adds	r7, r7, #6
 8005704:	311a      	adds	r1, #26
 8005706:	42b9      	cmp	r1, r7
 8005708:	d21e      	bcs.n	8005748 <PRL_Received+0x29a>
 800570a:	05e9      	lsls	r1, r5, #23
 800570c:	0dc9      	lsrs	r1, r1, #23
 800570e:	428a      	cmp	r2, r1
 8005710:	da1a      	bge.n	8005748 <PRL_Received+0x29a>
 8005712:	2101      	movs	r1, #1
 8005714:	2223      	movs	r2, #35	; 0x23
 8005716:	5499      	strb	r1, [r3, r2]
 8005718:	0429      	lsls	r1, r5, #16
 800571a:	0ec9      	lsrs	r1, r1, #27
 800571c:	4008      	ands	r0, r1
 800571e:	211a      	movs	r1, #26
 8005720:	4341      	muls	r1, r0
 8005722:	2007      	movs	r0, #7
 8005724:	466a      	mov	r2, sp
 8005726:	8892      	ldrh	r2, [r2, #4]
 8005728:	0b12      	lsrs	r2, r2, #12
 800572a:	4002      	ands	r2, r0
 800572c:	0092      	lsls	r2, r2, #2
 800572e:	1e92      	subs	r2, r2, #2
 8005730:	4294      	cmp	r4, r2
 8005732:	da3a      	bge.n	80057aa <PRL_Received+0x2fc>
 8005734:	6872      	ldr	r2, [r6, #4]
 8005736:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8005738:	1d1b      	adds	r3, r3, #4
 800573a:	5d1b      	ldrb	r3, [r3, r4]
 800573c:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800573e:	1865      	adds	r5, r4, r1
 8005740:	5553      	strb	r3, [r2, r5]
 8005742:	1c64      	adds	r4, r4, #1
 8005744:	b2a4      	uxth	r4, r4
 8005746:	e7ed      	b.n	8005724 <PRL_Received+0x276>
 8005748:	42ba      	cmp	r2, r7
 800574a:	d21e      	bcs.n	800578a <PRL_Received+0x2dc>
 800574c:	05e9      	lsls	r1, r5, #23
 800574e:	0dc9      	lsrs	r1, r1, #23
 8005750:	428a      	cmp	r2, r1
 8005752:	db1a      	blt.n	800578a <PRL_Received+0x2dc>
 8005754:	2101      	movs	r1, #1
 8005756:	2223      	movs	r2, #35	; 0x23
 8005758:	5499      	strb	r1, [r3, r2]
 800575a:	0429      	lsls	r1, r5, #16
 800575c:	0ec9      	lsrs	r1, r1, #27
 800575e:	4008      	ands	r0, r1
 8005760:	211a      	movs	r1, #26
 8005762:	4341      	muls	r1, r0
 8005764:	2007      	movs	r0, #7
 8005766:	466a      	mov	r2, sp
 8005768:	8892      	ldrh	r2, [r2, #4]
 800576a:	0b12      	lsrs	r2, r2, #12
 800576c:	4002      	ands	r2, r0
 800576e:	0092      	lsls	r2, r2, #2
 8005770:	1e92      	subs	r2, r2, #2
 8005772:	4294      	cmp	r4, r2
 8005774:	da19      	bge.n	80057aa <PRL_Received+0x2fc>
 8005776:	6872      	ldr	r2, [r6, #4]
 8005778:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 800577a:	1d1b      	adds	r3, r3, #4
 800577c:	5d1b      	ldrb	r3, [r3, r4]
 800577e:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8005780:	1865      	adds	r5, r4, r1
 8005782:	5553      	strb	r3, [r2, r5]
 8005784:	1c64      	adds	r4, r4, #1
 8005786:	b2a4      	uxth	r4, r4
 8005788:	e7ed      	b.n	8005766 <PRL_Received+0x2b8>
 800578a:	2123      	movs	r1, #35	; 0x23
 800578c:	545c      	strb	r4, [r3, r1]
 800578e:	6870      	ldr	r0, [r6, #4]
 8005790:	7104      	strb	r4, [r0, #4]
 8005792:	aa01      	add	r2, sp, #4
 8005794:	4668      	mov	r0, sp
 8005796:	7c01      	ldrb	r1, [r0, #16]
 8005798:	7b00      	ldrb	r0, [r0, #12]
 800579a:	6873      	ldr	r3, [r6, #4]
 800579c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800579e:	681b      	ldr	r3, [r3, #0]
 80057a0:	4798      	blx	r3
 80057a2:	e000      	b.n	80057a6 <PRL_Received+0x2f8>
 80057a4:	7484      	strb	r4, [r0, #18]
 80057a6:	b005      	add	sp, #20
 80057a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80057aa:	6870      	ldr	r0, [r6, #4]
 80057ac:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80057ae:	8801      	ldrh	r1, [r0, #0]
 80057b0:	466a      	mov	r2, sp
 80057b2:	8892      	ldrh	r2, [r2, #4]
 80057b4:	0a92      	lsrs	r2, r2, #10
 80057b6:	231c      	movs	r3, #28
 80057b8:	4013      	ands	r3, r2
 80057ba:	1e9a      	subs	r2, r3, #2
 80057bc:	1889      	adds	r1, r1, r2
 80057be:	8001      	strh	r1, [r0, #0]
 80057c0:	e7e7      	b.n	8005792 <PRL_Received+0x2e4>
	...

080057c4 <.text_39>:
 80057c4:	0800cec0 	.word	0x0800cec0

080057c8 <.text_40>:
 80057c8:	200019bc 	.word	0x200019bc

080057cc <.text_41>:
 80057cc:	200019b4 	.word	0x200019b4

080057d0 <PRL_ResetIndicate>:
 80057d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80057d2:	0005      	movs	r5, r0
 80057d4:	000e      	movs	r6, r1
 80057d6:	4869      	ldr	r0, [pc, #420]	; (800597c <.text_53>)
 80057d8:	00a9      	lsls	r1, r5, #2
 80057da:	1844      	adds	r4, r0, r1
 80057dc:	2000      	movs	r0, #0
 80057de:	6861      	ldr	r1, [r4, #4]
 80057e0:	72c8      	strb	r0, [r1, #11]
 80057e2:	220f      	movs	r2, #15
 80057e4:	2103      	movs	r1, #3
 80057e6:	6860      	ldr	r0, [r4, #4]
 80057e8:	1d80      	adds	r0, r0, #6
 80057ea:	f007 f9a2 	bl	800cb32 <__aeabi_memset>
 80057ee:	2006      	movs	r0, #6
 80057f0:	6861      	ldr	r1, [r4, #4]
 80057f2:	7108      	strb	r0, [r1, #4]
 80057f4:	4862      	ldr	r0, [pc, #392]	; (8005980 <.text_54>)
 80057f6:	6807      	ldr	r7, [r0, #0]
 80057f8:	2f00      	cmp	r7, #0
 80057fa:	d006      	beq.n	800580a <PRL_ResetIndicate+0x3a>
 80057fc:	2000      	movs	r0, #0
 80057fe:	9000      	str	r0, [sp, #0]
 8005800:	2300      	movs	r3, #0
 8005802:	0032      	movs	r2, r6
 8005804:	0029      	movs	r1, r5
 8005806:	2001      	movs	r0, #1
 8005808:	47b8      	blx	r7
 800580a:	0031      	movs	r1, r6
 800580c:	0028      	movs	r0, r5
 800580e:	6862      	ldr	r2, [r4, #4]
 8005810:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8005812:	6892      	ldr	r2, [r2, #8]
 8005814:	4790      	blx	r2
 8005816:	bdf1      	pop	{r0, r4, r5, r6, r7, pc}

08005818 <PRL_ResetCompleted>:
 8005818:	4958      	ldr	r1, [pc, #352]	; (800597c <.text_53>)
 800581a:	0080      	lsls	r0, r0, #2
 800581c:	1808      	adds	r0, r1, r0
 800581e:	6840      	ldr	r0, [r0, #4]
 8005820:	2101      	movs	r1, #1
 8005822:	7341      	strb	r1, [r0, #13]
 8005824:	4770      	bx	lr

08005826 <PRL_IdleAfterBusy>:
 8005826:	4955      	ldr	r1, [pc, #340]	; (800597c <.text_53>)
 8005828:	0080      	lsls	r0, r0, #2
 800582a:	1808      	adds	r0, r1, r0
 800582c:	6840      	ldr	r0, [r0, #4]
 800582e:	2101      	movs	r1, #1
 8005830:	7381      	strb	r1, [r0, #14]
 8005832:	4770      	bx	lr

08005834 <.text_45>:
 8005834:	0000f01f 	.word	0x0000f01f

08005838 <PRL_BistCompleted>:
 8005838:	b580      	push	{r7, lr}
 800583a:	4b50      	ldr	r3, [pc, #320]	; (800597c <.text_53>)
 800583c:	0082      	lsls	r2, r0, #2
 800583e:	189a      	adds	r2, r3, r2
 8005840:	6852      	ldr	r2, [r2, #4]
 8005842:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8005844:	68d2      	ldr	r2, [r2, #12]
 8005846:	4790      	blx	r2
 8005848:	bd01      	pop	{r0, pc}
	...

0800584c <.text_47>:
 800584c:	0000ffe0 	.word	0x0000ffe0

08005850 <.text_48>:
 8005850:	0000fedf 	.word	0x0000fedf

08005854 <PRL_TxCompleted>:
 8005854:	b538      	push	{r3, r4, r5, lr}
 8005856:	0005      	movs	r5, r0
 8005858:	4848      	ldr	r0, [pc, #288]	; (800597c <.text_53>)
 800585a:	00a9      	lsls	r1, r5, #2
 800585c:	1844      	adds	r4, r0, r1
 800585e:	6861      	ldr	r1, [r4, #4]
 8005860:	7c88      	ldrb	r0, [r1, #18]
 8005862:	2801      	cmp	r0, #1
 8005864:	d002      	beq.n	800586c <PRL_TxCompleted+0x18>
 8005866:	2802      	cmp	r0, #2
 8005868:	d005      	beq.n	8005876 <PRL_TxCompleted+0x22>
 800586a:	e010      	b.n	800588e <PRL_TxCompleted+0x3a>
 800586c:	0028      	movs	r0, r5
 800586e:	6b09      	ldr	r1, [r1, #48]	; 0x30
 8005870:	6849      	ldr	r1, [r1, #4]
 8005872:	4788      	blx	r1
 8005874:	e00b      	b.n	800588e <PRL_TxCompleted+0x3a>
 8005876:	0028      	movs	r0, r5
 8005878:	f004 f9c2 	bl	8009c00 <USBPD_PHY_GetRetryTimerValue>
 800587c:	2d00      	cmp	r5, #0
 800587e:	d101      	bne.n	8005884 <PRL_TxCompleted+0x30>
 8005880:	2201      	movs	r2, #1
 8005882:	e000      	b.n	8005886 <PRL_TxCompleted+0x32>
 8005884:	2203      	movs	r2, #3
 8005886:	b281      	uxth	r1, r0
 8005888:	0010      	movs	r0, r2
 800588a:	f006 f85b 	bl	800b944 <USBPD_TIM_Start>
 800588e:	2000      	movs	r0, #0
 8005890:	6861      	ldr	r1, [r4, #4]
 8005892:	7488      	strb	r0, [r1, #18]
 8005894:	bd31      	pop	{r0, r4, r5, pc}
	...

08005898 <.text_50>:
 8005898:	0000ff3f 	.word	0x0000ff3f

0800589c <USBPD_PRL_PrepareExtendedTxChunkSending>:
 800589c:	b570      	push	{r4, r5, r6, lr}
 800589e:	4c37      	ldr	r4, [pc, #220]	; (800597c <.text_53>)
 80058a0:	0080      	lsls	r0, r0, #2
 80058a2:	1820      	adds	r0, r4, r0
 80058a4:	6840      	ldr	r0, [r0, #4]
 80058a6:	2480      	movs	r4, #128	; 0x80
 80058a8:	0224      	lsls	r4, r4, #8
 80058aa:	8b45      	ldrh	r5, [r0, #26]
 80058ac:	4e35      	ldr	r6, [pc, #212]	; (8005984 <.text_55>)
 80058ae:	402e      	ands	r6, r5
 80058b0:	02c9      	lsls	r1, r1, #11
 80058b2:	4331      	orrs	r1, r6
 80058b4:	25fe      	movs	r5, #254	; 0xfe
 80058b6:	022d      	lsls	r5, r5, #8
 80058b8:	400d      	ands	r5, r1
 80058ba:	05d1      	lsls	r1, r2, #23
 80058bc:	0dc9      	lsrs	r1, r1, #23
 80058be:	4329      	orrs	r1, r5
 80058c0:	4321      	orrs	r1, r4
 80058c2:	8341      	strh	r1, [r0, #26]
 80058c4:	8a81      	ldrh	r1, [r0, #20]
 80058c6:	430c      	orrs	r4, r1
 80058c8:	8284      	strh	r4, [r0, #20]
 80058ca:	4a2f      	ldr	r2, [pc, #188]	; (8005988 <.text_56>)
 80058cc:	4022      	ands	r2, r4
 80058ce:	7f81      	ldrb	r1, [r0, #30]
 80058d0:	06c9      	lsls	r1, r1, #27
 80058d2:	0ec9      	lsrs	r1, r1, #27
 80058d4:	4311      	orrs	r1, r2
 80058d6:	8281      	strh	r1, [r0, #20]
 80058d8:	7019      	strb	r1, [r3, #0]
 80058da:	8a81      	ldrh	r1, [r0, #20]
 80058dc:	0a09      	lsrs	r1, r1, #8
 80058de:	7059      	strb	r1, [r3, #1]
 80058e0:	8b41      	ldrh	r1, [r0, #26]
 80058e2:	7099      	strb	r1, [r3, #2]
 80058e4:	8b40      	ldrh	r0, [r0, #26]
 80058e6:	0a00      	lsrs	r0, r0, #8
 80058e8:	70d8      	strb	r0, [r3, #3]
 80058ea:	bd70      	pop	{r4, r5, r6, pc}

080058ec <USBPD_PRL_ManageExtendedRx>:
 80058ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80058ee:	b084      	sub	sp, #16
 80058f0:	4a22      	ldr	r2, [pc, #136]	; (800597c <.text_53>)
 80058f2:	0083      	lsls	r3, r0, #2
 80058f4:	18d2      	adds	r2, r2, r3
 80058f6:	6853      	ldr	r3, [r2, #4]
 80058f8:	8b5a      	ldrh	r2, [r3, #26]
 80058fa:	2484      	movs	r4, #132	; 0x84
 80058fc:	0224      	lsls	r4, r4, #8
 80058fe:	4314      	orrs	r4, r2
 8005900:	835c      	strh	r4, [r3, #26]
 8005902:	2286      	movs	r2, #134	; 0x86
 8005904:	0212      	lsls	r2, r2, #8
 8005906:	4022      	ands	r2, r4
 8005908:	8b9c      	ldrh	r4, [r3, #28]
 800590a:	0ae4      	lsrs	r4, r4, #11
 800590c:	1c64      	adds	r4, r4, #1
 800590e:	02e4      	lsls	r4, r4, #11
 8005910:	25f0      	movs	r5, #240	; 0xf0
 8005912:	01ed      	lsls	r5, r5, #7
 8005914:	4025      	ands	r5, r4
 8005916:	4315      	orrs	r5, r2
 8005918:	835d      	strh	r5, [r3, #26]
 800591a:	8bdd      	ldrh	r5, [r3, #30]
 800591c:	221f      	movs	r2, #31
 800591e:	261f      	movs	r6, #31
 8005920:	402e      	ands	r6, r5
 8005922:	2480      	movs	r4, #128	; 0x80
 8005924:	4334      	orrs	r4, r6
 8005926:	8a9f      	ldrh	r7, [r3, #20]
 8005928:	4e18      	ldr	r6, [pc, #96]	; (800598c <.text_57>)
 800592a:	403e      	ands	r6, r7
 800592c:	2790      	movs	r7, #144	; 0x90
 800592e:	023f      	lsls	r7, r7, #8
 8005930:	4337      	orrs	r7, r6
 8005932:	829f      	strh	r7, [r3, #20]
 8005934:	4e14      	ldr	r6, [pc, #80]	; (8005988 <.text_56>)
 8005936:	403e      	ands	r6, r7
 8005938:	402a      	ands	r2, r5
 800593a:	4332      	orrs	r2, r6
 800593c:	829a      	strh	r2, [r3, #20]
 800593e:	2506      	movs	r5, #6
 8005940:	711d      	strb	r5, [r3, #4]
 8005942:	ad02      	add	r5, sp, #8
 8005944:	702a      	strb	r2, [r5, #0]
 8005946:	8a9a      	ldrh	r2, [r3, #20]
 8005948:	0a12      	lsrs	r2, r2, #8
 800594a:	706a      	strb	r2, [r5, #1]
 800594c:	8b5a      	ldrh	r2, [r3, #26]
 800594e:	70aa      	strb	r2, [r5, #2]
 8005950:	8b5a      	ldrh	r2, [r3, #26]
 8005952:	0a12      	lsrs	r2, r2, #8
 8005954:	70ea      	strb	r2, [r5, #3]
 8005956:	2200      	movs	r2, #0
 8005958:	80aa      	strh	r2, [r5, #4]
 800595a:	0006      	movs	r6, r0
 800595c:	000d      	movs	r5, r1
 800595e:	2000      	movs	r0, #0
 8005960:	9001      	str	r0, [sp, #4]
 8005962:	2006      	movs	r0, #6
 8005964:	9000      	str	r0, [sp, #0]
 8005966:	ab02      	add	r3, sp, #8
 8005968:	0022      	movs	r2, r4
 800596a:	0029      	movs	r1, r5
 800596c:	0030      	movs	r0, r6
 800596e:	f7ff fb29 	bl	8004fc4 <USBPD_PRL_SendMessage>
 8005972:	2803      	cmp	r0, #3
 8005974:	d0f3      	beq.n	800595e <USBPD_PRL_ManageExtendedRx+0x72>
 8005976:	2000      	movs	r0, #0
 8005978:	b005      	add	sp, #20
 800597a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800597c <.text_53>:
 800597c:	200019bc 	.word	0x200019bc

08005980 <.text_54>:
 8005980:	200019b4 	.word	0x200019b4

08005984 <.text_55>:
 8005984:	000083ff 	.word	0x000083ff

08005988 <.text_56>:
 8005988:	0000ffe0 	.word	0x0000ffe0

0800598c <.text_57>:
 800598c:	00008fff 	.word	0x00008fff

08005990 <strlen>:
 8005990:	2300      	movs	r3, #0
 8005992:	5cc2      	ldrb	r2, [r0, r3]
 8005994:	3301      	adds	r3, #1
 8005996:	2a00      	cmp	r2, #0
 8005998:	d1fb      	bne.n	8005992 <strlen+0x2>
 800599a:	1e58      	subs	r0, r3, #1
 800599c:	4770      	bx	lr
	...

080059a0 <__gnu_thumb1_case_sqi>:
 80059a0:	b402      	push	{r1}
 80059a2:	4671      	mov	r1, lr
 80059a4:	0849      	lsrs	r1, r1, #1
 80059a6:	0049      	lsls	r1, r1, #1
 80059a8:	5609      	ldrsb	r1, [r1, r0]
 80059aa:	0049      	lsls	r1, r1, #1
 80059ac:	448e      	add	lr, r1
 80059ae:	bc02      	pop	{r1}
 80059b0:	4770      	bx	lr
 80059b2:	46c0      	nop			; (mov r8, r8)

080059b4 <__gnu_thumb1_case_uqi>:
 80059b4:	b402      	push	{r1}
 80059b6:	4671      	mov	r1, lr
 80059b8:	0849      	lsrs	r1, r1, #1
 80059ba:	0049      	lsls	r1, r1, #1
 80059bc:	5c09      	ldrb	r1, [r1, r0]
 80059be:	0049      	lsls	r1, r1, #1
 80059c0:	448e      	add	lr, r1
 80059c2:	bc02      	pop	{r1}
 80059c4:	4770      	bx	lr
 80059c6:	46c0      	nop			; (mov r8, r8)

080059c8 <__udivsi3>:
 80059c8:	2200      	movs	r2, #0
 80059ca:	0843      	lsrs	r3, r0, #1
 80059cc:	428b      	cmp	r3, r1
 80059ce:	d374      	bcc.n	8005aba <__udivsi3+0xf2>
 80059d0:	0903      	lsrs	r3, r0, #4
 80059d2:	428b      	cmp	r3, r1
 80059d4:	d35f      	bcc.n	8005a96 <__udivsi3+0xce>
 80059d6:	0a03      	lsrs	r3, r0, #8
 80059d8:	428b      	cmp	r3, r1
 80059da:	d344      	bcc.n	8005a66 <__udivsi3+0x9e>
 80059dc:	0b03      	lsrs	r3, r0, #12
 80059de:	428b      	cmp	r3, r1
 80059e0:	d328      	bcc.n	8005a34 <__udivsi3+0x6c>
 80059e2:	0c03      	lsrs	r3, r0, #16
 80059e4:	428b      	cmp	r3, r1
 80059e6:	d30d      	bcc.n	8005a04 <__udivsi3+0x3c>
 80059e8:	22ff      	movs	r2, #255	; 0xff
 80059ea:	0209      	lsls	r1, r1, #8
 80059ec:	ba12      	rev	r2, r2
 80059ee:	0c03      	lsrs	r3, r0, #16
 80059f0:	428b      	cmp	r3, r1
 80059f2:	d302      	bcc.n	80059fa <__udivsi3+0x32>
 80059f4:	1212      	asrs	r2, r2, #8
 80059f6:	0209      	lsls	r1, r1, #8
 80059f8:	d065      	beq.n	8005ac6 <__udivsi3+0xfe>
 80059fa:	0b03      	lsrs	r3, r0, #12
 80059fc:	428b      	cmp	r3, r1
 80059fe:	d319      	bcc.n	8005a34 <__udivsi3+0x6c>
 8005a00:	e000      	b.n	8005a04 <__udivsi3+0x3c>
 8005a02:	0a09      	lsrs	r1, r1, #8
 8005a04:	0bc3      	lsrs	r3, r0, #15
 8005a06:	428b      	cmp	r3, r1
 8005a08:	d301      	bcc.n	8005a0e <__udivsi3+0x46>
 8005a0a:	03cb      	lsls	r3, r1, #15
 8005a0c:	1ac0      	subs	r0, r0, r3
 8005a0e:	4152      	adcs	r2, r2
 8005a10:	0b83      	lsrs	r3, r0, #14
 8005a12:	428b      	cmp	r3, r1
 8005a14:	d301      	bcc.n	8005a1a <__udivsi3+0x52>
 8005a16:	038b      	lsls	r3, r1, #14
 8005a18:	1ac0      	subs	r0, r0, r3
 8005a1a:	4152      	adcs	r2, r2
 8005a1c:	0b43      	lsrs	r3, r0, #13
 8005a1e:	428b      	cmp	r3, r1
 8005a20:	d301      	bcc.n	8005a26 <__udivsi3+0x5e>
 8005a22:	034b      	lsls	r3, r1, #13
 8005a24:	1ac0      	subs	r0, r0, r3
 8005a26:	4152      	adcs	r2, r2
 8005a28:	0b03      	lsrs	r3, r0, #12
 8005a2a:	428b      	cmp	r3, r1
 8005a2c:	d301      	bcc.n	8005a32 <__udivsi3+0x6a>
 8005a2e:	030b      	lsls	r3, r1, #12
 8005a30:	1ac0      	subs	r0, r0, r3
 8005a32:	4152      	adcs	r2, r2
 8005a34:	0ac3      	lsrs	r3, r0, #11
 8005a36:	428b      	cmp	r3, r1
 8005a38:	d301      	bcc.n	8005a3e <__udivsi3+0x76>
 8005a3a:	02cb      	lsls	r3, r1, #11
 8005a3c:	1ac0      	subs	r0, r0, r3
 8005a3e:	4152      	adcs	r2, r2
 8005a40:	0a83      	lsrs	r3, r0, #10
 8005a42:	428b      	cmp	r3, r1
 8005a44:	d301      	bcc.n	8005a4a <__udivsi3+0x82>
 8005a46:	028b      	lsls	r3, r1, #10
 8005a48:	1ac0      	subs	r0, r0, r3
 8005a4a:	4152      	adcs	r2, r2
 8005a4c:	0a43      	lsrs	r3, r0, #9
 8005a4e:	428b      	cmp	r3, r1
 8005a50:	d301      	bcc.n	8005a56 <__udivsi3+0x8e>
 8005a52:	024b      	lsls	r3, r1, #9
 8005a54:	1ac0      	subs	r0, r0, r3
 8005a56:	4152      	adcs	r2, r2
 8005a58:	0a03      	lsrs	r3, r0, #8
 8005a5a:	428b      	cmp	r3, r1
 8005a5c:	d301      	bcc.n	8005a62 <__udivsi3+0x9a>
 8005a5e:	020b      	lsls	r3, r1, #8
 8005a60:	1ac0      	subs	r0, r0, r3
 8005a62:	4152      	adcs	r2, r2
 8005a64:	d2cd      	bcs.n	8005a02 <__udivsi3+0x3a>
 8005a66:	09c3      	lsrs	r3, r0, #7
 8005a68:	428b      	cmp	r3, r1
 8005a6a:	d301      	bcc.n	8005a70 <__udivsi3+0xa8>
 8005a6c:	01cb      	lsls	r3, r1, #7
 8005a6e:	1ac0      	subs	r0, r0, r3
 8005a70:	4152      	adcs	r2, r2
 8005a72:	0983      	lsrs	r3, r0, #6
 8005a74:	428b      	cmp	r3, r1
 8005a76:	d301      	bcc.n	8005a7c <__udivsi3+0xb4>
 8005a78:	018b      	lsls	r3, r1, #6
 8005a7a:	1ac0      	subs	r0, r0, r3
 8005a7c:	4152      	adcs	r2, r2
 8005a7e:	0943      	lsrs	r3, r0, #5
 8005a80:	428b      	cmp	r3, r1
 8005a82:	d301      	bcc.n	8005a88 <__udivsi3+0xc0>
 8005a84:	014b      	lsls	r3, r1, #5
 8005a86:	1ac0      	subs	r0, r0, r3
 8005a88:	4152      	adcs	r2, r2
 8005a8a:	0903      	lsrs	r3, r0, #4
 8005a8c:	428b      	cmp	r3, r1
 8005a8e:	d301      	bcc.n	8005a94 <__udivsi3+0xcc>
 8005a90:	010b      	lsls	r3, r1, #4
 8005a92:	1ac0      	subs	r0, r0, r3
 8005a94:	4152      	adcs	r2, r2
 8005a96:	08c3      	lsrs	r3, r0, #3
 8005a98:	428b      	cmp	r3, r1
 8005a9a:	d301      	bcc.n	8005aa0 <__udivsi3+0xd8>
 8005a9c:	00cb      	lsls	r3, r1, #3
 8005a9e:	1ac0      	subs	r0, r0, r3
 8005aa0:	4152      	adcs	r2, r2
 8005aa2:	0883      	lsrs	r3, r0, #2
 8005aa4:	428b      	cmp	r3, r1
 8005aa6:	d301      	bcc.n	8005aac <__udivsi3+0xe4>
 8005aa8:	008b      	lsls	r3, r1, #2
 8005aaa:	1ac0      	subs	r0, r0, r3
 8005aac:	4152      	adcs	r2, r2
 8005aae:	0843      	lsrs	r3, r0, #1
 8005ab0:	428b      	cmp	r3, r1
 8005ab2:	d301      	bcc.n	8005ab8 <__udivsi3+0xf0>
 8005ab4:	004b      	lsls	r3, r1, #1
 8005ab6:	1ac0      	subs	r0, r0, r3
 8005ab8:	4152      	adcs	r2, r2
 8005aba:	1a41      	subs	r1, r0, r1
 8005abc:	d200      	bcs.n	8005ac0 <__udivsi3+0xf8>
 8005abe:	4601      	mov	r1, r0
 8005ac0:	4152      	adcs	r2, r2
 8005ac2:	4610      	mov	r0, r2
 8005ac4:	4770      	bx	lr
 8005ac6:	e7ff      	b.n	8005ac8 <__udivsi3+0x100>
 8005ac8:	b501      	push	{r0, lr}
 8005aca:	2000      	movs	r0, #0
 8005acc:	f000 f8f0 	bl	8005cb0 <__aeabi_idiv0>
 8005ad0:	bd02      	pop	{r1, pc}
 8005ad2:	46c0      	nop			; (mov r8, r8)

08005ad4 <__aeabi_uidivmod>:
 8005ad4:	2900      	cmp	r1, #0
 8005ad6:	d0f7      	beq.n	8005ac8 <__udivsi3+0x100>
 8005ad8:	e776      	b.n	80059c8 <__udivsi3>
 8005ada:	4770      	bx	lr

08005adc <__divsi3>:
 8005adc:	4603      	mov	r3, r0
 8005ade:	430b      	orrs	r3, r1
 8005ae0:	d47f      	bmi.n	8005be2 <__divsi3+0x106>
 8005ae2:	2200      	movs	r2, #0
 8005ae4:	0843      	lsrs	r3, r0, #1
 8005ae6:	428b      	cmp	r3, r1
 8005ae8:	d374      	bcc.n	8005bd4 <__divsi3+0xf8>
 8005aea:	0903      	lsrs	r3, r0, #4
 8005aec:	428b      	cmp	r3, r1
 8005aee:	d35f      	bcc.n	8005bb0 <__divsi3+0xd4>
 8005af0:	0a03      	lsrs	r3, r0, #8
 8005af2:	428b      	cmp	r3, r1
 8005af4:	d344      	bcc.n	8005b80 <__divsi3+0xa4>
 8005af6:	0b03      	lsrs	r3, r0, #12
 8005af8:	428b      	cmp	r3, r1
 8005afa:	d328      	bcc.n	8005b4e <__divsi3+0x72>
 8005afc:	0c03      	lsrs	r3, r0, #16
 8005afe:	428b      	cmp	r3, r1
 8005b00:	d30d      	bcc.n	8005b1e <__divsi3+0x42>
 8005b02:	22ff      	movs	r2, #255	; 0xff
 8005b04:	0209      	lsls	r1, r1, #8
 8005b06:	ba12      	rev	r2, r2
 8005b08:	0c03      	lsrs	r3, r0, #16
 8005b0a:	428b      	cmp	r3, r1
 8005b0c:	d302      	bcc.n	8005b14 <__divsi3+0x38>
 8005b0e:	1212      	asrs	r2, r2, #8
 8005b10:	0209      	lsls	r1, r1, #8
 8005b12:	d065      	beq.n	8005be0 <__divsi3+0x104>
 8005b14:	0b03      	lsrs	r3, r0, #12
 8005b16:	428b      	cmp	r3, r1
 8005b18:	d319      	bcc.n	8005b4e <__divsi3+0x72>
 8005b1a:	e000      	b.n	8005b1e <__divsi3+0x42>
 8005b1c:	0a09      	lsrs	r1, r1, #8
 8005b1e:	0bc3      	lsrs	r3, r0, #15
 8005b20:	428b      	cmp	r3, r1
 8005b22:	d301      	bcc.n	8005b28 <__divsi3+0x4c>
 8005b24:	03cb      	lsls	r3, r1, #15
 8005b26:	1ac0      	subs	r0, r0, r3
 8005b28:	4152      	adcs	r2, r2
 8005b2a:	0b83      	lsrs	r3, r0, #14
 8005b2c:	428b      	cmp	r3, r1
 8005b2e:	d301      	bcc.n	8005b34 <__divsi3+0x58>
 8005b30:	038b      	lsls	r3, r1, #14
 8005b32:	1ac0      	subs	r0, r0, r3
 8005b34:	4152      	adcs	r2, r2
 8005b36:	0b43      	lsrs	r3, r0, #13
 8005b38:	428b      	cmp	r3, r1
 8005b3a:	d301      	bcc.n	8005b40 <__divsi3+0x64>
 8005b3c:	034b      	lsls	r3, r1, #13
 8005b3e:	1ac0      	subs	r0, r0, r3
 8005b40:	4152      	adcs	r2, r2
 8005b42:	0b03      	lsrs	r3, r0, #12
 8005b44:	428b      	cmp	r3, r1
 8005b46:	d301      	bcc.n	8005b4c <__divsi3+0x70>
 8005b48:	030b      	lsls	r3, r1, #12
 8005b4a:	1ac0      	subs	r0, r0, r3
 8005b4c:	4152      	adcs	r2, r2
 8005b4e:	0ac3      	lsrs	r3, r0, #11
 8005b50:	428b      	cmp	r3, r1
 8005b52:	d301      	bcc.n	8005b58 <__divsi3+0x7c>
 8005b54:	02cb      	lsls	r3, r1, #11
 8005b56:	1ac0      	subs	r0, r0, r3
 8005b58:	4152      	adcs	r2, r2
 8005b5a:	0a83      	lsrs	r3, r0, #10
 8005b5c:	428b      	cmp	r3, r1
 8005b5e:	d301      	bcc.n	8005b64 <__divsi3+0x88>
 8005b60:	028b      	lsls	r3, r1, #10
 8005b62:	1ac0      	subs	r0, r0, r3
 8005b64:	4152      	adcs	r2, r2
 8005b66:	0a43      	lsrs	r3, r0, #9
 8005b68:	428b      	cmp	r3, r1
 8005b6a:	d301      	bcc.n	8005b70 <__divsi3+0x94>
 8005b6c:	024b      	lsls	r3, r1, #9
 8005b6e:	1ac0      	subs	r0, r0, r3
 8005b70:	4152      	adcs	r2, r2
 8005b72:	0a03      	lsrs	r3, r0, #8
 8005b74:	428b      	cmp	r3, r1
 8005b76:	d301      	bcc.n	8005b7c <__divsi3+0xa0>
 8005b78:	020b      	lsls	r3, r1, #8
 8005b7a:	1ac0      	subs	r0, r0, r3
 8005b7c:	4152      	adcs	r2, r2
 8005b7e:	d2cd      	bcs.n	8005b1c <__divsi3+0x40>
 8005b80:	09c3      	lsrs	r3, r0, #7
 8005b82:	428b      	cmp	r3, r1
 8005b84:	d301      	bcc.n	8005b8a <__divsi3+0xae>
 8005b86:	01cb      	lsls	r3, r1, #7
 8005b88:	1ac0      	subs	r0, r0, r3
 8005b8a:	4152      	adcs	r2, r2
 8005b8c:	0983      	lsrs	r3, r0, #6
 8005b8e:	428b      	cmp	r3, r1
 8005b90:	d301      	bcc.n	8005b96 <__divsi3+0xba>
 8005b92:	018b      	lsls	r3, r1, #6
 8005b94:	1ac0      	subs	r0, r0, r3
 8005b96:	4152      	adcs	r2, r2
 8005b98:	0943      	lsrs	r3, r0, #5
 8005b9a:	428b      	cmp	r3, r1
 8005b9c:	d301      	bcc.n	8005ba2 <__divsi3+0xc6>
 8005b9e:	014b      	lsls	r3, r1, #5
 8005ba0:	1ac0      	subs	r0, r0, r3
 8005ba2:	4152      	adcs	r2, r2
 8005ba4:	0903      	lsrs	r3, r0, #4
 8005ba6:	428b      	cmp	r3, r1
 8005ba8:	d301      	bcc.n	8005bae <__divsi3+0xd2>
 8005baa:	010b      	lsls	r3, r1, #4
 8005bac:	1ac0      	subs	r0, r0, r3
 8005bae:	4152      	adcs	r2, r2
 8005bb0:	08c3      	lsrs	r3, r0, #3
 8005bb2:	428b      	cmp	r3, r1
 8005bb4:	d301      	bcc.n	8005bba <__divsi3+0xde>
 8005bb6:	00cb      	lsls	r3, r1, #3
 8005bb8:	1ac0      	subs	r0, r0, r3
 8005bba:	4152      	adcs	r2, r2
 8005bbc:	0883      	lsrs	r3, r0, #2
 8005bbe:	428b      	cmp	r3, r1
 8005bc0:	d301      	bcc.n	8005bc6 <__divsi3+0xea>
 8005bc2:	008b      	lsls	r3, r1, #2
 8005bc4:	1ac0      	subs	r0, r0, r3
 8005bc6:	4152      	adcs	r2, r2
 8005bc8:	0843      	lsrs	r3, r0, #1
 8005bca:	428b      	cmp	r3, r1
 8005bcc:	d301      	bcc.n	8005bd2 <__divsi3+0xf6>
 8005bce:	004b      	lsls	r3, r1, #1
 8005bd0:	1ac0      	subs	r0, r0, r3
 8005bd2:	4152      	adcs	r2, r2
 8005bd4:	1a41      	subs	r1, r0, r1
 8005bd6:	d200      	bcs.n	8005bda <__divsi3+0xfe>
 8005bd8:	4601      	mov	r1, r0
 8005bda:	4152      	adcs	r2, r2
 8005bdc:	4610      	mov	r0, r2
 8005bde:	4770      	bx	lr
 8005be0:	e05d      	b.n	8005c9e <__divsi3+0x1c2>
 8005be2:	0fca      	lsrs	r2, r1, #31
 8005be4:	d000      	beq.n	8005be8 <__divsi3+0x10c>
 8005be6:	4249      	negs	r1, r1
 8005be8:	1003      	asrs	r3, r0, #32
 8005bea:	d300      	bcc.n	8005bee <__divsi3+0x112>
 8005bec:	4240      	negs	r0, r0
 8005bee:	4053      	eors	r3, r2
 8005bf0:	2200      	movs	r2, #0
 8005bf2:	469c      	mov	ip, r3
 8005bf4:	0903      	lsrs	r3, r0, #4
 8005bf6:	428b      	cmp	r3, r1
 8005bf8:	d32d      	bcc.n	8005c56 <__divsi3+0x17a>
 8005bfa:	0a03      	lsrs	r3, r0, #8
 8005bfc:	428b      	cmp	r3, r1
 8005bfe:	d312      	bcc.n	8005c26 <__divsi3+0x14a>
 8005c00:	22fc      	movs	r2, #252	; 0xfc
 8005c02:	0189      	lsls	r1, r1, #6
 8005c04:	ba12      	rev	r2, r2
 8005c06:	0a03      	lsrs	r3, r0, #8
 8005c08:	428b      	cmp	r3, r1
 8005c0a:	d30c      	bcc.n	8005c26 <__divsi3+0x14a>
 8005c0c:	0189      	lsls	r1, r1, #6
 8005c0e:	1192      	asrs	r2, r2, #6
 8005c10:	428b      	cmp	r3, r1
 8005c12:	d308      	bcc.n	8005c26 <__divsi3+0x14a>
 8005c14:	0189      	lsls	r1, r1, #6
 8005c16:	1192      	asrs	r2, r2, #6
 8005c18:	428b      	cmp	r3, r1
 8005c1a:	d304      	bcc.n	8005c26 <__divsi3+0x14a>
 8005c1c:	0189      	lsls	r1, r1, #6
 8005c1e:	d03a      	beq.n	8005c96 <__divsi3+0x1ba>
 8005c20:	1192      	asrs	r2, r2, #6
 8005c22:	e000      	b.n	8005c26 <__divsi3+0x14a>
 8005c24:	0989      	lsrs	r1, r1, #6
 8005c26:	09c3      	lsrs	r3, r0, #7
 8005c28:	428b      	cmp	r3, r1
 8005c2a:	d301      	bcc.n	8005c30 <__divsi3+0x154>
 8005c2c:	01cb      	lsls	r3, r1, #7
 8005c2e:	1ac0      	subs	r0, r0, r3
 8005c30:	4152      	adcs	r2, r2
 8005c32:	0983      	lsrs	r3, r0, #6
 8005c34:	428b      	cmp	r3, r1
 8005c36:	d301      	bcc.n	8005c3c <__divsi3+0x160>
 8005c38:	018b      	lsls	r3, r1, #6
 8005c3a:	1ac0      	subs	r0, r0, r3
 8005c3c:	4152      	adcs	r2, r2
 8005c3e:	0943      	lsrs	r3, r0, #5
 8005c40:	428b      	cmp	r3, r1
 8005c42:	d301      	bcc.n	8005c48 <__divsi3+0x16c>
 8005c44:	014b      	lsls	r3, r1, #5
 8005c46:	1ac0      	subs	r0, r0, r3
 8005c48:	4152      	adcs	r2, r2
 8005c4a:	0903      	lsrs	r3, r0, #4
 8005c4c:	428b      	cmp	r3, r1
 8005c4e:	d301      	bcc.n	8005c54 <__divsi3+0x178>
 8005c50:	010b      	lsls	r3, r1, #4
 8005c52:	1ac0      	subs	r0, r0, r3
 8005c54:	4152      	adcs	r2, r2
 8005c56:	08c3      	lsrs	r3, r0, #3
 8005c58:	428b      	cmp	r3, r1
 8005c5a:	d301      	bcc.n	8005c60 <__divsi3+0x184>
 8005c5c:	00cb      	lsls	r3, r1, #3
 8005c5e:	1ac0      	subs	r0, r0, r3
 8005c60:	4152      	adcs	r2, r2
 8005c62:	0883      	lsrs	r3, r0, #2
 8005c64:	428b      	cmp	r3, r1
 8005c66:	d301      	bcc.n	8005c6c <__divsi3+0x190>
 8005c68:	008b      	lsls	r3, r1, #2
 8005c6a:	1ac0      	subs	r0, r0, r3
 8005c6c:	4152      	adcs	r2, r2
 8005c6e:	d2d9      	bcs.n	8005c24 <__divsi3+0x148>
 8005c70:	0843      	lsrs	r3, r0, #1
 8005c72:	428b      	cmp	r3, r1
 8005c74:	d301      	bcc.n	8005c7a <__divsi3+0x19e>
 8005c76:	004b      	lsls	r3, r1, #1
 8005c78:	1ac0      	subs	r0, r0, r3
 8005c7a:	4152      	adcs	r2, r2
 8005c7c:	1a41      	subs	r1, r0, r1
 8005c7e:	d200      	bcs.n	8005c82 <__divsi3+0x1a6>
 8005c80:	4601      	mov	r1, r0
 8005c82:	4663      	mov	r3, ip
 8005c84:	4152      	adcs	r2, r2
 8005c86:	105b      	asrs	r3, r3, #1
 8005c88:	4610      	mov	r0, r2
 8005c8a:	d301      	bcc.n	8005c90 <__divsi3+0x1b4>
 8005c8c:	4240      	negs	r0, r0
 8005c8e:	2b00      	cmp	r3, #0
 8005c90:	d500      	bpl.n	8005c94 <__divsi3+0x1b8>
 8005c92:	4249      	negs	r1, r1
 8005c94:	4770      	bx	lr
 8005c96:	4663      	mov	r3, ip
 8005c98:	105b      	asrs	r3, r3, #1
 8005c9a:	d300      	bcc.n	8005c9e <__divsi3+0x1c2>
 8005c9c:	4240      	negs	r0, r0
 8005c9e:	b501      	push	{r0, lr}
 8005ca0:	2000      	movs	r0, #0
 8005ca2:	f000 f805 	bl	8005cb0 <__aeabi_idiv0>
 8005ca6:	bd02      	pop	{r1, pc}

08005ca8 <__aeabi_idivmod>:
 8005ca8:	2900      	cmp	r1, #0
 8005caa:	d0f8      	beq.n	8005c9e <__divsi3+0x1c2>
 8005cac:	e716      	b.n	8005adc <__divsi3>
 8005cae:	4770      	bx	lr

08005cb0 <__aeabi_idiv0>:
 8005cb0:	4770      	bx	lr
 8005cb2:	46c0      	nop			; (mov r8, r8)

08005cb4 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8005cb4:	480d      	ldr	r0, [pc, #52]	; (8005cec <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8005cb6:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 8005cb8:	2100      	movs	r1, #0
  b LoopCopyDataInit
 8005cba:	e003      	b.n	8005cc4 <LoopCopyDataInit>

08005cbc <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 8005cbc:	4b0c      	ldr	r3, [pc, #48]	; (8005cf0 <LoopForever+0x6>)
  ldr r3, [r3, r1]
 8005cbe:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 8005cc0:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 8005cc2:	3104      	adds	r1, #4

08005cc4 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 8005cc4:	480b      	ldr	r0, [pc, #44]	; (8005cf4 <LoopForever+0xa>)
  ldr r3, =_edata
 8005cc6:	4b0c      	ldr	r3, [pc, #48]	; (8005cf8 <LoopForever+0xe>)
  adds r2, r0, r1
 8005cc8:	1842      	adds	r2, r0, r1
  cmp r2, r3
 8005cca:	429a      	cmp	r2, r3
  bcc CopyDataInit
 8005ccc:	d3f6      	bcc.n	8005cbc <CopyDataInit>
  ldr r2, =_sbss
 8005cce:	4a0b      	ldr	r2, [pc, #44]	; (8005cfc <LoopForever+0x12>)
  b LoopFillZerobss
 8005cd0:	e002      	b.n	8005cd8 <LoopFillZerobss>

08005cd2 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 8005cd2:	2300      	movs	r3, #0
  str  r3, [r2]
 8005cd4:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8005cd6:	3204      	adds	r2, #4

08005cd8 <LoopFillZerobss>:


LoopFillZerobss:
  ldr r3, = _ebss
 8005cd8:	4b09      	ldr	r3, [pc, #36]	; (8005d00 <LoopForever+0x16>)
  cmp r2, r3
 8005cda:	429a      	cmp	r2, r3
  bcc FillZerobss
 8005cdc:	d3f9      	bcc.n	8005cd2 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 8005cde:	f001 f9c5 	bl	800706c <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 8005ce2:	f006 ff2d 	bl	800cb40 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8005ce6:	f000 f80f 	bl	8005d08 <main>

08005cea <LoopForever>:

LoopForever:
    b LoopForever
 8005cea:	e7fe      	b.n	8005cea <LoopForever>
  ldr   r0, =_estack
 8005cec:	20004000 	.word	0x20004000
  ldr r3, =_sidata
 8005cf0:	0800cef0 	.word	0x0800cef0
  ldr r0, =_sdata
 8005cf4:	20000000 	.word	0x20000000
  ldr r3, =_edata
 8005cf8:	200002a8 	.word	0x200002a8
  ldr r2, =_sbss
 8005cfc:	200002a8 	.word	0x200002a8
  ldr r3, = _ebss
 8005d00:	20001dc8 	.word	0x20001dc8

08005d04 <ADC1_COMP_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8005d04:	e7fe      	b.n	8005d04 <ADC1_COMP_IRQHandler>
	...

08005d08 <main>:
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
 8005d08:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8005d0a:	f001 f9f1 	bl	80070f0 <HAL_Init>
  *         @arg @ref LL_FLASH_LATENCY_1
  * @retval None
  */
__STATIC_INLINE void LL_FLASH_SetLatency(uint32_t Latency)
{
  MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
 8005d0e:	2101      	movs	r1, #1
 8005d10:	4a35      	ldr	r2, [pc, #212]	; (8005de8 <main+0xe0>)
 8005d12:	6813      	ldr	r3, [r2, #0]
 8005d14:	430b      	orrs	r3, r1
 8005d16:	6013      	str	r3, [r2, #0]
  * @rmtoll CR2          HSI48ON       LL_RCC_HSI48_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI48_Enable(void)
{
  SET_BIT(RCC->CR2, RCC_CR2_HSI48ON);
 8005d18:	2280      	movs	r2, #128	; 0x80
 8005d1a:	4b34      	ldr	r3, [pc, #208]	; (8005dec <main+0xe4>)
 8005d1c:	0252      	lsls	r2, r2, #9
 8005d1e:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8005d20:	430a      	orrs	r2, r1
 8005d22:	635a      	str	r2, [r3, #52]	; 0x34
  * @rmtoll CR2          HSI48RDY      LL_RCC_HSI48_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI48_IsReady(void)
{
  return (READ_BIT(RCC->CR2, RCC_CR2_HSI48RDY) == (RCC_CR2_HSI48RDY));
 8005d24:	2280      	movs	r2, #128	; 0x80
 8005d26:	0292      	lsls	r2, r2, #10
 8005d28:	6b59      	ldr	r1, [r3, #52]	; 0x34
  /* Set FLASH latency */ 
  LL_FLASH_SetLatency(LL_FLASH_LATENCY_1);

  /* Enable HSI48 and wait for activation*/
  LL_RCC_HSI48_Enable(); 
  while(LL_RCC_HSI48_IsReady() != 1) 
 8005d2a:	4211      	tst	r1, r2
 8005d2c:	d0fc      	beq.n	8005d28 <main+0x20>
  *         @arg @ref LL_RCC_PREDIV_DIV_16
  * @retval None
  */
__STATIC_INLINE void LL_RCC_PLL_ConfigDomain_SYS(uint32_t Source, uint32_t PLLMul, uint32_t PLLDiv)
{
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL, Source | PLLMul);
 8005d2e:	685a      	ldr	r2, [r3, #4]
 8005d30:	492f      	ldr	r1, [pc, #188]	; (8005df0 <main+0xe8>)
 8005d32:	4011      	ands	r1, r2
 8005d34:	22c0      	movs	r2, #192	; 0xc0
 8005d36:	0252      	lsls	r2, r2, #9
 8005d38:	430a      	orrs	r2, r1
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, PLLDiv);
 8005d3a:	210f      	movs	r1, #15
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLMUL, Source | PLLMul);
 8005d3c:	605a      	str	r2, [r3, #4]
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_PREDIV, PLLDiv);
 8005d3e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005d40:	438a      	bics	r2, r1
 8005d42:	0011      	movs	r1, r2
 8005d44:	2201      	movs	r2, #1
 8005d46:	430a      	orrs	r2, r1
 8005d48:	62da      	str	r2, [r3, #44]	; 0x2c
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 8005d4a:	2280      	movs	r2, #128	; 0x80
 8005d4c:	6819      	ldr	r1, [r3, #0]
 8005d4e:	0452      	lsls	r2, r2, #17
 8005d50:	430a      	orrs	r2, r1
 8005d52:	601a      	str	r2, [r3, #0]
  return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
 8005d54:	2280      	movs	r2, #128	; 0x80
 8005d56:	0492      	lsls	r2, r2, #18
 8005d58:	6819      	ldr	r1, [r3, #0]
  
  /* Main PLL configuration and activation */
  LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI48, LL_RCC_PLL_MUL_2, LL_RCC_PREDIV_DIV_2);
  
  LL_RCC_PLL_Enable();
  while(LL_RCC_PLL_IsReady() != 1)
 8005d5a:	4211      	tst	r1, r2
 8005d5c:	d0fc      	beq.n	8005d58 <main+0x50>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 8005d5e:	21f0      	movs	r1, #240	; 0xf0
 8005d60:	685a      	ldr	r2, [r3, #4]
 8005d62:	438a      	bics	r2, r1
 8005d64:	605a      	str	r2, [r3, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8005d66:	685a      	ldr	r2, [r3, #4]
 8005d68:	39ed      	subs	r1, #237	; 0xed
 8005d6a:	438a      	bics	r2, r1
 8005d6c:	0011      	movs	r1, r2
 8005d6e:	2202      	movs	r2, #2
 8005d70:	430a      	orrs	r2, r1
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8005d72:	210c      	movs	r1, #12
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8005d74:	605a      	str	r2, [r3, #4]
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8005d76:	685a      	ldr	r2, [r3, #4]
 8005d78:	400a      	ands	r2, r1
  };
  
  /* Sysclk activation on the main PLL */
  LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
  LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
  while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
 8005d7a:	2a08      	cmp	r2, #8
 8005d7c:	d1fb      	bne.n	8005d76 <main+0x6e>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, Prescaler);
 8005d7e:	685a      	ldr	r2, [r3, #4]
 8005d80:	491c      	ldr	r1, [pc, #112]	; (8005df4 <main+0xec>)
  LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);
  
  /* Set systick to 1ms in using frequency set to 48MHz */
  /* This frequency can be calculated through LL RCC macro */
  /* ex: __LL_RCC_CALC_PLLCLK_FREQ (HSI48_VALUE, LL_RCC_PLL_MUL_2, LL_RCC_PREDIV_DIV_2) */
  LL_Init1msTick(48000000);
 8005d82:	481d      	ldr	r0, [pc, #116]	; (8005df8 <main+0xf0>)
 8005d84:	400a      	ands	r2, r1
 8005d86:	605a      	str	r2, [r3, #4]
 8005d88:	f003 fc6c 	bl	8009664 <LL_Init1msTick>
  
  /* Update CMSIS variable (which can be updated also through SystemCoreClockUpdate function) */
  LL_SetSystemCoreClock(48000000);
 8005d8c:	481a      	ldr	r0, [pc, #104]	; (8005df8 <main+0xf0>)
 8005d8e:	f003 fc79 	bl	8009684 <LL_SetSystemCoreClock>
  HAL_NVIC_SetPriority(SysTick_IRQn, TICK_INT_PRIORITY ,0U);
 8005d92:	2001      	movs	r0, #1
 8005d94:	2200      	movs	r2, #0
 8005d96:	4240      	negs	r0, r0
 8005d98:	2103      	movs	r1, #3
 8005d9a:	f001 fc33 	bl	8007604 <HAL_NVIC_SetPriority>
  * @rmtoll STK_CTRL     TICKINT       LL_SYSTICK_EnableIT
  * @retval None
  */
__STATIC_INLINE void LL_SYSTICK_EnableIT(void)
{
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 8005d9e:	2302      	movs	r3, #2
 8005da0:	4a16      	ldr	r2, [pc, #88]	; (8005dfc <main+0xf4>)
 8005da2:	6811      	ldr	r1, [r2, #0]
 8005da4:	430b      	orrs	r3, r1
 8005da6:	6013      	str	r3, [r2, #0]
  USBPD_BSP_LED_Init();
 8005da8:	f001 f8f8 	bl	8006f9c <USBPD_BSP_LED_Init>
  USBPD_HW_IF_GlobalHwInit();
 8005dac:	f004 fc64 	bl	800a678 <USBPD_HW_IF_GlobalHwInit>
  USBPD_BSP_UART_Init();
 8005db0:	f001 f91c 	bl	8006fec <USBPD_BSP_UART_Init>
  HAL_UART_MspInit(&huart2);
 8005db4:	4c12      	ldr	r4, [pc, #72]	; (8005e00 <main+0xf8>)
 8005db6:	0020      	movs	r0, r4
 8005db8:	f001 f930 	bl	800701c <HAL_UART_MspInit>
  uint8_t str[] = " start \r\n\0";
 8005dbc:	220b      	movs	r2, #11
 8005dbe:	4911      	ldr	r1, [pc, #68]	; (8005e04 <main+0xfc>)
 8005dc0:	a801      	add	r0, sp, #4
 8005dc2:	f006 feeb 	bl	800cb9c <memcpy>
  HAL_UART_Transmit(&huart2, str, strlen((char *)str), 50);
 8005dc6:	a801      	add	r0, sp, #4
 8005dc8:	f7ff fde2 	bl	8005990 <strlen>
 8005dcc:	2332      	movs	r3, #50	; 0x32
 8005dce:	b282      	uxth	r2, r0
 8005dd0:	a901      	add	r1, sp, #4
 8005dd2:	0020      	movs	r0, r4
 8005dd4:	f003 fb1c 	bl	8009410 <HAL_UART_Transmit>
  if( USBPD_ERROR == USBPD_DPM_Init())
 8005dd8:	f003 fcf8 	bl	80097cc <USBPD_DPM_Init>
 8005ddc:	2802      	cmp	r0, #2
 8005dde:	d100      	bne.n	8005de2 <main+0xda>
 8005de0:	e7fe      	b.n	8005de0 <main+0xd8>
}
 8005de2:	2000      	movs	r0, #0
 8005de4:	b004      	add	sp, #16
 8005de6:	bd10      	pop	{r4, pc}
 8005de8:	40022000 	.word	0x40022000
 8005dec:	40021000 	.word	0x40021000
 8005df0:	ffc27fff 	.word	0xffc27fff
 8005df4:	fffff8ff 	.word	0xfffff8ff
 8005df8:	02dc6c00 	.word	0x02dc6c00
 8005dfc:	e000e010 	.word	0xe000e010
 8005e00:	200019d4 	.word	0x200019d4
 8005e04:	0800ccdc 	.word	0x0800ccdc

08005e08 <HAL_MspInit>:
  *         level initialization (GPIOs, clock, DMA, interrupt).
  * @retval None
  */
void HAL_MspInit(void)
{
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005e08:	2001      	movs	r0, #1
 8005e0a:	4b1c      	ldr	r3, [pc, #112]	; (8005e7c <HAL_MspInit+0x74>)
{
 8005e0c:	b086      	sub	sp, #24
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005e0e:	6999      	ldr	r1, [r3, #24]
 8005e10:	4301      	orrs	r1, r0
 8005e12:	6199      	str	r1, [r3, #24]
 8005e14:	699a      	ldr	r2, [r3, #24]
 8005e16:	4002      	ands	r2, r0
  /* Enable the RCC peripheral clock associated to all the selected GPIOs */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8005e18:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8005e1a:	9200      	str	r2, [sp, #0]
 8005e1c:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8005e1e:	6959      	ldr	r1, [r3, #20]
 8005e20:	0280      	lsls	r0, r0, #10
 8005e22:	4301      	orrs	r1, r0
 8005e24:	6159      	str	r1, [r3, #20]
 8005e26:	695a      	ldr	r2, [r3, #20]
 8005e28:	4002      	ands	r2, r0
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8005e2a:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8005e2c:	9201      	str	r2, [sp, #4]
 8005e2e:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8005e30:	6959      	ldr	r1, [r3, #20]
 8005e32:	02c0      	lsls	r0, r0, #11
 8005e34:	4301      	orrs	r1, r0
 8005e36:	6159      	str	r1, [r3, #20]
 8005e38:	695a      	ldr	r2, [r3, #20]
 8005e3a:	4002      	ands	r2, r0
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8005e3c:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8005e3e:	9202      	str	r2, [sp, #8]
 8005e40:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8005e42:	6959      	ldr	r1, [r3, #20]
 8005e44:	0300      	lsls	r0, r0, #12
 8005e46:	4301      	orrs	r1, r0
 8005e48:	6159      	str	r1, [r3, #20]
 8005e4a:	695a      	ldr	r2, [r3, #20]
 8005e4c:	4002      	ands	r2, r0
#if defined(GPIOD)
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e4e:	2080      	movs	r0, #128	; 0x80
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8005e50:	9203      	str	r2, [sp, #12]
 8005e52:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e54:	6959      	ldr	r1, [r3, #20]
 8005e56:	0340      	lsls	r0, r0, #13
 8005e58:	4301      	orrs	r1, r0
 8005e5a:	6159      	str	r1, [r3, #20]
#endif /* GPIOD */
#if defined(GPIOF)
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8005e5c:	2180      	movs	r1, #128	; 0x80
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e5e:	695a      	ldr	r2, [r3, #20]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8005e60:	03c9      	lsls	r1, r1, #15
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005e62:	4002      	ands	r2, r0
 8005e64:	9204      	str	r2, [sp, #16]
 8005e66:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8005e68:	695a      	ldr	r2, [r3, #20]
 8005e6a:	430a      	orrs	r2, r1
 8005e6c:	615a      	str	r2, [r3, #20]
 8005e6e:	695b      	ldr	r3, [r3, #20]
 8005e70:	400b      	ands	r3, r1
 8005e72:	9305      	str	r3, [sp, #20]
 8005e74:	9b05      	ldr	r3, [sp, #20]
#endif /* GPIOD */
}
 8005e76:	b006      	add	sp, #24
 8005e78:	4770      	bx	lr
 8005e7a:	46c0      	nop			; (mov r8, r8)
 8005e7c:	40021000 	.word	0x40021000

08005e80 <HAL_ADC_MspInit>:
  * @brief ADC MSP Initialization
  * @param hadc: ADC handle pointer
  * @retval None
  */
void HAL_ADC_MspInit(ADC_HandleTypeDef *hadc)
{
 8005e80:	b513      	push	{r0, r1, r4, lr}
  /* Enable clock of ADCx peripheral */
  ADCx_CLK_ENABLE();
 8005e82:	2180      	movs	r1, #128	; 0x80
 8005e84:	4c0a      	ldr	r4, [pc, #40]	; (8005eb0 <HAL_ADC_MspInit+0x30>)
 8005e86:	0089      	lsls	r1, r1, #2
 8005e88:	69a2      	ldr	r2, [r4, #24]
 8005e8a:	430a      	orrs	r2, r1
 8005e8c:	61a2      	str	r2, [r4, #24]
 8005e8e:	69a3      	ldr	r3, [r4, #24]
 8005e90:	400b      	ands	r3, r1
 8005e92:	9300      	str	r3, [sp, #0]
 8005e94:	9b00      	ldr	r3, [sp, #0]
  PHY_HW_IF_ADCAnalogGPIO_Init();
 8005e96:	f004 f929 	bl	800a0ec <PHY_HW_IF_ADCAnalogGPIO_Init>
  
  /* Enable clock of DMA associated to the peripheral */
  ADCx_DMA_CLK_ENABLE();
 8005e9a:	2101      	movs	r1, #1
 8005e9c:	6962      	ldr	r2, [r4, #20]
 8005e9e:	430a      	orrs	r2, r1
 8005ea0:	6162      	str	r2, [r4, #20]
 8005ea2:	6963      	ldr	r3, [r4, #20]
 8005ea4:	400b      	ands	r3, r1
 8005ea6:	9301      	str	r3, [sp, #4]
 8005ea8:	9b01      	ldr	r3, [sp, #4]
  PHY_HW_IF_ADCDMA_Init();
 8005eaa:	f004 f93d 	bl	800a128 <PHY_HW_IF_ADCDMA_Init>
}
 8005eae:	bd13      	pop	{r0, r1, r4, pc}
 8005eb0:	40021000 	.word	0x40021000

08005eb4 <HAL_SPI_MspInit>:
  * @brief SPI MSP Initialization
  * @param hspi: SPI handle pointer
  * @retval None
  */
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8005eb4:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  
  uint8_t port_num = GET_PORT_FROM_SPI(hspi);
 8005eb6:	4b38      	ldr	r3, [pc, #224]	; (8005f98 <HAL_SPI_MspInit+0xe4>)
 8005eb8:	6804      	ldr	r4, [r0, #0]
  
  /* Peripheral clock enable */
  SPI_CLK_ENABLE(port_num);
 8005eba:	4e38      	ldr	r6, [pc, #224]	; (8005f9c <HAL_SPI_MspInit+0xe8>)
  uint8_t port_num = GET_PORT_FROM_SPI(hspi);
 8005ebc:	18e5      	adds	r5, r4, r3
 8005ebe:	1e6b      	subs	r3, r5, #1
 8005ec0:	419d      	sbcs	r5, r3
{
 8005ec2:	b089      	sub	sp, #36	; 0x24
  uint8_t port_num = GET_PORT_FROM_SPI(hspi);
 8005ec4:	b2ed      	uxtb	r5, r5
 8005ec6:	4a36      	ldr	r2, [pc, #216]	; (8005fa0 <HAL_SPI_MspInit+0xec>)
  SPI_CLK_ENABLE(port_num);
 8005ec8:	42b4      	cmp	r4, r6
 8005eca:	d159      	bne.n	8005f80 <HAL_SPI_MspInit+0xcc>
 8005ecc:	2380      	movs	r3, #128	; 0x80
 8005ece:	69d1      	ldr	r1, [r2, #28]
 8005ed0:	01db      	lsls	r3, r3, #7
 8005ed2:	4319      	orrs	r1, r3
 8005ed4:	61d1      	str	r1, [r2, #28]
 8005ed6:	69d2      	ldr	r2, [r2, #28]
 8005ed8:	401a      	ands	r2, r3
 8005eda:	9201      	str	r2, [sp, #4]
 8005edc:	9a01      	ldr	r2, [sp, #4]
  
  GPIO_InitStruct.Pin = SPI_MISO_PIN(port_num);
 8005ede:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005ee0:	2203      	movs	r2, #3
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005ee2:	2300      	movs	r3, #0
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005ee4:	2702      	movs	r7, #2
  GPIO_InitStruct.Alternate = SPI_MISO_ALTERNATE(port_num);
  HAL_GPIO_Init(SPI_MISO_PORT(port_num), &GPIO_InitStruct);
 8005ee6:	a903      	add	r1, sp, #12
 8005ee8:	482e      	ldr	r0, [pc, #184]	; (8005fa4 <HAL_SPI_MspInit+0xf0>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005eea:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Alternate = SPI_MISO_ALTERNATE(port_num);
 8005eec:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005eee:	9704      	str	r7, [sp, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005ef0:	9206      	str	r2, [sp, #24]
  HAL_GPIO_Init(SPI_MISO_PORT(port_num), &GPIO_InitStruct);
 8005ef2:	f001 fd61 	bl	80079b8 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = SPI_MOSI_PIN(port_num);
 8005ef6:	2320      	movs	r3, #32
 8005ef8:	42b4      	cmp	r4, r6
 8005efa:	d101      	bne.n	8005f00 <HAL_SPI_MspInit+0x4c>
 8005efc:	2380      	movs	r3, #128	; 0x80
 8005efe:	021b      	lsls	r3, r3, #8
 8005f00:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005f02:	2301      	movs	r3, #1
 8005f04:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005f06:	3302      	adds	r3, #2
 8005f08:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Alternate = SPI_MOSI_ALTERNATE(port_num);
 8005f0a:	2300      	movs	r3, #0
  HAL_GPIO_Init(SPI_MOSI_PORT(port_num), &GPIO_InitStruct);
 8005f0c:	a903      	add	r1, sp, #12
 8005f0e:	4825      	ldr	r0, [pc, #148]	; (8005fa4 <HAL_SPI_MspInit+0xf0>)
  GPIO_InitStruct.Alternate = SPI_MOSI_ALTERNATE(port_num);
 8005f10:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005f12:	9704      	str	r7, [sp, #16]
  HAL_GPIO_Init(SPI_MOSI_PORT(port_num), &GPIO_InitStruct);
 8005f14:	f001 fd50 	bl	80079b8 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = SPI_CLK_PIN(port_num);
 8005f18:	2308      	movs	r3, #8
 8005f1a:	42b4      	cmp	r4, r6
 8005f1c:	d101      	bne.n	8005f22 <HAL_SPI_MspInit+0x6e>
 8005f1e:	2380      	movs	r3, #128	; 0x80
 8005f20:	019b      	lsls	r3, r3, #6
 8005f22:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005f24:	2702      	movs	r7, #2
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005f26:	2601      	movs	r6, #1
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005f28:	2303      	movs	r3, #3
  GPIO_InitStruct.Alternate = SPI_CLK_ALTERNATE(port_num);
 8005f2a:	2200      	movs	r2, #0
  HAL_GPIO_Init(SPI_CLK_PORT(port_num), &GPIO_InitStruct);
 8005f2c:	a903      	add	r1, sp, #12
 8005f2e:	481d      	ldr	r0, [pc, #116]	; (8005fa4 <HAL_SPI_MspInit+0xf0>)
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005f30:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Alternate = SPI_CLK_ALTERNATE(port_num);
 8005f32:	9207      	str	r2, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005f34:	9704      	str	r7, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005f36:	9605      	str	r6, [sp, #20]
  HAL_GPIO_Init(SPI_CLK_PORT(port_num), &GPIO_InitStruct);
 8005f38:	f001 fd3e 	bl	80079b8 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = SPI_NSS_PIN(port_num);
 8005f3c:	4916      	ldr	r1, [pc, #88]	; (8005f98 <HAL_SPI_MspInit+0xe4>)
 8005f3e:	4b1a      	ldr	r3, [pc, #104]	; (8005fa8 <HAL_SPI_MspInit+0xf4>)
 8005f40:	1864      	adds	r4, r4, r1
 8005f42:	4260      	negs	r0, r4
 8005f44:	4160      	adcs	r0, r4
 8005f46:	2180      	movs	r1, #128	; 0x80
 8005f48:	4240      	negs	r0, r0
 8005f4a:	4003      	ands	r3, r0
 8005f4c:	0209      	lsls	r1, r1, #8
 8005f4e:	185b      	adds	r3, r3, r1
 8005f50:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005f52:	2303      	movs	r3, #3
  GPIO_InitStruct.Alternate = SPI_NSS_ALTERNATE(port_num);
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f54:	2480      	movs	r4, #128	; 0x80
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8005f56:	9306      	str	r3, [sp, #24]
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f58:	2390      	movs	r3, #144	; 0x90
  GPIO_InitStruct.Alternate = SPI_NSS_ALTERNATE(port_num);
 8005f5a:	2200      	movs	r2, #0
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f5c:	00e4      	lsls	r4, r4, #3
 8005f5e:	05db      	lsls	r3, r3, #23
 8005f60:	4020      	ands	r0, r4
 8005f62:	18c0      	adds	r0, r0, r3
 8005f64:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Alternate = SPI_NSS_ALTERNATE(port_num);
 8005f66:	9207      	str	r2, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8005f68:	9704      	str	r7, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005f6a:	9605      	str	r6, [sp, #20]
  HAL_GPIO_Init(SPI_NSS_PORT(port_num), &GPIO_InitStruct);
 8005f6c:	f001 fd24 	bl	80079b8 <HAL_GPIO_Init>

  /* TX DMA Initialization */
  STUSB16xx_HW_IF_TX_DMA_Init(port_num);
 8005f70:	0028      	movs	r0, r5
 8005f72:	f005 f917 	bl	800b1a4 <STUSB16xx_HW_IF_TX_DMA_Init>

  /* RX DMA Initialization */
  STUSB16xx_HW_IF_RX_DMA_Init(port_num);  
 8005f76:	0028      	movs	r0, r5
 8005f78:	f005 f950 	bl	800b21c <STUSB16xx_HW_IF_RX_DMA_Init>
}
 8005f7c:	b009      	add	sp, #36	; 0x24
 8005f7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  SPI_CLK_ENABLE(port_num);
 8005f80:	2080      	movs	r0, #128	; 0x80
 8005f82:	6991      	ldr	r1, [r2, #24]
 8005f84:	0140      	lsls	r0, r0, #5
 8005f86:	4301      	orrs	r1, r0
 8005f88:	6191      	str	r1, [r2, #24]
 8005f8a:	6993      	ldr	r3, [r2, #24]
 8005f8c:	4003      	ands	r3, r0
 8005f8e:	9302      	str	r3, [sp, #8]
 8005f90:	9b02      	ldr	r3, [sp, #8]
  GPIO_InitStruct.Pin = SPI_MISO_PIN(port_num);
 8005f92:	2310      	movs	r3, #16
 8005f94:	e7a3      	b.n	8005ede <HAL_SPI_MspInit+0x2a>
 8005f96:	46c0      	nop			; (mov r8, r8)
 8005f98:	bfffc800 	.word	0xbfffc800
 8005f9c:	40003800 	.word	0x40003800
 8005fa0:	40021000 	.word	0x40021000
 8005fa4:	48000400 	.word	0x48000400
 8005fa8:	ffff9000 	.word	0xffff9000

08005fac <HAL_I2C_MspInit>:
{
  GPIO_InitTypeDef GPIO_InitStruct;

  uint8_t port_num = GET_PORT_FROM_I2C(hi2c);

  GPIO_InitStruct.Pin       = I2C_SCL_PIN(port_num)|I2C_SDA_PIN(port_num);
 8005fac:	23c0      	movs	r3, #192	; 0xc0
{
 8005fae:	b510      	push	{r4, lr}
  GPIO_InitStruct.Pin       = I2C_SCL_PIN(port_num)|I2C_SDA_PIN(port_num);
 8005fb0:	011b      	lsls	r3, r3, #4
{
 8005fb2:	b088      	sub	sp, #32
  GPIO_InitStruct.Pin       = I2C_SCL_PIN(port_num)|I2C_SDA_PIN(port_num);
 8005fb4:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Mode      = I2C_MODE(port_num);
 8005fb6:	2312      	movs	r3, #18
 8005fb8:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pull      = I2C_PULL(port_num);
 8005fba:	2300      	movs	r3, #0
 8005fbc:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Speed     = I2C_SPEED(port_num);
 8005fbe:	3303      	adds	r3, #3
  uint8_t port_num = GET_PORT_FROM_I2C(hi2c);
 8005fc0:	6804      	ldr	r4, [r0, #0]
  GPIO_InitStruct.Speed     = I2C_SPEED(port_num);
 8005fc2:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Alternate = I2C_ALTERNATE(port_num);
  HAL_GPIO_Init(I2C_PORT(port_num), &GPIO_InitStruct);
 8005fc4:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Alternate = I2C_ALTERNATE(port_num);
 8005fc6:	3b02      	subs	r3, #2
  HAL_GPIO_Init(I2C_PORT(port_num), &GPIO_InitStruct);
 8005fc8:	480e      	ldr	r0, [pc, #56]	; (8006004 <HAL_I2C_MspInit+0x58>)
  GPIO_InitStruct.Alternate = I2C_ALTERNATE(port_num);
 8005fca:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(I2C_PORT(port_num), &GPIO_InitStruct);
 8005fcc:	f001 fcf4 	bl	80079b8 <HAL_GPIO_Init>

  /* Peripheral clock enable */
  I2C_CLK_ENABLE(port_num);
 8005fd0:	4a0d      	ldr	r2, [pc, #52]	; (8006008 <HAL_I2C_MspInit+0x5c>)
 8005fd2:	4b0e      	ldr	r3, [pc, #56]	; (800600c <HAL_I2C_MspInit+0x60>)
 8005fd4:	4294      	cmp	r4, r2
 8005fd6:	d10a      	bne.n	8005fee <HAL_I2C_MspInit+0x42>
 8005fd8:	2180      	movs	r1, #128	; 0x80
 8005fda:	69da      	ldr	r2, [r3, #28]
 8005fdc:	03c9      	lsls	r1, r1, #15
 8005fde:	430a      	orrs	r2, r1
 8005fe0:	61da      	str	r2, [r3, #28]
 8005fe2:	69db      	ldr	r3, [r3, #28]
 8005fe4:	400b      	ands	r3, r1
 8005fe6:	9301      	str	r3, [sp, #4]
 8005fe8:	9b01      	ldr	r3, [sp, #4]
  UNUSED(port_num);
}
 8005fea:	b008      	add	sp, #32
 8005fec:	bd10      	pop	{r4, pc}
  I2C_CLK_ENABLE(port_num);
 8005fee:	2180      	movs	r1, #128	; 0x80
 8005ff0:	69da      	ldr	r2, [r3, #28]
 8005ff2:	0389      	lsls	r1, r1, #14
 8005ff4:	430a      	orrs	r2, r1
 8005ff6:	61da      	str	r2, [r3, #28]
 8005ff8:	69db      	ldr	r3, [r3, #28]
 8005ffa:	400b      	ands	r3, r1
 8005ffc:	9302      	str	r3, [sp, #8]
 8005ffe:	9b02      	ldr	r3, [sp, #8]
}
 8006000:	e7f3      	b.n	8005fea <HAL_I2C_MspInit+0x3e>
 8006002:	46c0      	nop			; (mov r8, r8)
 8006004:	48000400 	.word	0x48000400
 8006008:	40005800 	.word	0x40005800
 800600c:	40021000 	.word	0x40021000

08006010 <HAL_CRC_MspInit>:
  * @retval None
  */
void HAL_CRC_MspInit(CRC_HandleTypeDef *hcrc)
{
  /* CRC Peripheral clock enable */
  __HAL_RCC_CRC_CLK_ENABLE();
 8006010:	2040      	movs	r0, #64	; 0x40
 8006012:	4a05      	ldr	r2, [pc, #20]	; (8006028 <HAL_CRC_MspInit+0x18>)
{
 8006014:	b082      	sub	sp, #8
  __HAL_RCC_CRC_CLK_ENABLE();
 8006016:	6951      	ldr	r1, [r2, #20]
 8006018:	4301      	orrs	r1, r0
 800601a:	6151      	str	r1, [r2, #20]
 800601c:	6953      	ldr	r3, [r2, #20]
 800601e:	4003      	ands	r3, r0
 8006020:	9301      	str	r3, [sp, #4]
 8006022:	9b01      	ldr	r3, [sp, #4]
}
 8006024:	b002      	add	sp, #8
 8006026:	4770      	bx	lr
 8006028:	40021000 	.word	0x40021000

0800602c <HAL_TIM_Base_MspInit>:
  * @param htim_base: TIM handle pointer
  * @retval None
  */
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
  uint8_t port_num = GET_PORT_FROM_TIM(htim_base);
 800602c:	6803      	ldr	r3, [r0, #0]
  if(IS_RX_COUNTTIM(htim_base))  /* RX COUNT TIMER IDENTIFIED */
 800602e:	4a13      	ldr	r2, [pc, #76]	; (800607c <HAL_TIM_Base_MspInit+0x50>)
{
 8006030:	b513      	push	{r0, r1, r4, lr}
  if(IS_RX_COUNTTIM(htim_base))  /* RX COUNT TIMER IDENTIFIED */
 8006032:	4293      	cmp	r3, r2
 8006034:	d113      	bne.n	800605e <HAL_TIM_Base_MspInit+0x32>
  {
    /* Peripheral clock enable */
    RX_COUNTTIM_CLK_ENABLE(port_num);
 8006036:	2080      	movs	r0, #128	; 0x80

    /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(RX_COUNTTIM_IRQN(port_num), RX_COUNTTIMIRQ_PRIO(port_num), 0);
 8006038:	2415      	movs	r4, #21
    RX_COUNTTIM_CLK_ENABLE(port_num);
 800603a:	4a11      	ldr	r2, [pc, #68]	; (8006080 <HAL_TIM_Base_MspInit+0x54>)
 800603c:	0280      	lsls	r0, r0, #10
 800603e:	6991      	ldr	r1, [r2, #24]
 8006040:	4301      	orrs	r1, r0
 8006042:	6191      	str	r1, [r2, #24]
 8006044:	6993      	ldr	r3, [r2, #24]
 8006046:	4003      	ands	r3, r0
 8006048:	9300      	str	r3, [sp, #0]
 800604a:	9b00      	ldr	r3, [sp, #0]
    HAL_NVIC_SetPriority(RX_COUNTTIM_IRQN(port_num), RX_COUNTTIMIRQ_PRIO(port_num), 0);
 800604c:	0020      	movs	r0, r4
 800604e:	2200      	movs	r2, #0
 8006050:	2101      	movs	r1, #1
 8006052:	f001 fad7 	bl	8007604 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RX_COUNTTIM_IRQN(port_num));
 8006056:	0020      	movs	r0, r4
 8006058:	f001 fafe 	bl	8007658 <HAL_NVIC_EnableIRQ>
  }
  UNUSED(port_num);
}
 800605c:	bd13      	pop	{r0, r1, r4, pc}
  if(IS_RX_COUNTTIM(htim_base))  /* RX COUNT TIMER IDENTIFIED */
 800605e:	4a09      	ldr	r2, [pc, #36]	; (8006084 <HAL_TIM_Base_MspInit+0x58>)
 8006060:	4293      	cmp	r3, r2
 8006062:	d1fb      	bne.n	800605c <HAL_TIM_Base_MspInit+0x30>
    RX_COUNTTIM_CLK_ENABLE(port_num);
 8006064:	2080      	movs	r0, #128	; 0x80
 8006066:	4a06      	ldr	r2, [pc, #24]	; (8006080 <HAL_TIM_Base_MspInit+0x54>)
 8006068:	02c0      	lsls	r0, r0, #11
 800606a:	6991      	ldr	r1, [r2, #24]
    HAL_NVIC_SetPriority(RX_COUNTTIM_IRQN(port_num), RX_COUNTTIMIRQ_PRIO(port_num), 0);
 800606c:	2416      	movs	r4, #22
    RX_COUNTTIM_CLK_ENABLE(port_num);
 800606e:	4301      	orrs	r1, r0
 8006070:	6191      	str	r1, [r2, #24]
 8006072:	6993      	ldr	r3, [r2, #24]
 8006074:	4003      	ands	r3, r0
 8006076:	9301      	str	r3, [sp, #4]
 8006078:	9b01      	ldr	r3, [sp, #4]
 800607a:	e7e7      	b.n	800604c <HAL_TIM_Base_MspInit+0x20>
 800607c:	40014400 	.word	0x40014400
 8006080:	40021000 	.word	0x40021000
 8006084:	40014800 	.word	0x40014800

08006088 <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
 8006088:	4770      	bx	lr

0800608a <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 800608a:	e7fe      	b.n	800608a <HardFault_Handler>

0800608c <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 800608c:	b510      	push	{r4, lr}
  HAL_IncTick();
 800608e:	f001 f83f 	bl	8007110 <HAL_IncTick>
  USBPD_DPM_TimerCounter();
 8006092:	f003 fc03 	bl	800989c <USBPD_DPM_TimerCounter>
}
 8006096:	bd10      	pop	{r4, pc}

08006098 <EXTI0_1_IRQHandler>:
  * @brief  This function handles EXTI line 4_15 interrupts.
  * @param  None
  * @retval None
  */
void EXTI0_1_IRQHandler(void)
{
 8006098:	b510      	push	{r4, lr}
  HAL_GPIO_EXTI_IRQHandler(ALERT_GPIO_PIN(0));
 800609a:	2002      	movs	r0, #2
 800609c:	f001 fd58 	bl	8007b50 <HAL_GPIO_EXTI_IRQHandler>
}
 80060a0:	bd10      	pop	{r4, pc}

080060a2 <EXTI2_3_IRQHandler>:
  * @brief  This function handles EXTI line 2 to 3 interrupts.
  * @param  None
  * @retval None
  */
void EXTI2_3_IRQHandler(void)
{  
 80060a2:	b510      	push	{r4, lr}
  HAL_GPIO_EXTI_IRQHandler(ALERT_GPIO_PIN(1));
 80060a4:	2004      	movs	r0, #4
 80060a6:	f001 fd53 	bl	8007b50 <HAL_GPIO_EXTI_IRQHandler>
  
}
 80060aa:	bd10      	pop	{r4, pc}

080060ac <EXTI4_15_IRQHandler>:
  * @param  None
  * @retval None
  */
void EXTI4_15_IRQHandler(void)
{
  HAL_GPIO_EXTI_IRQHandler(USER_BUTTON_PIN);
 80060ac:	2080      	movs	r0, #128	; 0x80
{
 80060ae:	b510      	push	{r4, lr}
  HAL_GPIO_EXTI_IRQHandler(USER_BUTTON_PIN);
 80060b0:	0180      	lsls	r0, r0, #6
 80060b2:	f001 fd4d 	bl	8007b50 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(SPI_NSS_PIN(0));
 80060b6:	2080      	movs	r0, #128	; 0x80
 80060b8:	0140      	lsls	r0, r0, #5
 80060ba:	f001 fd49 	bl	8007b50 <HAL_GPIO_EXTI_IRQHandler>

  HAL_GPIO_EXTI_IRQHandler(SPI_NSS_PIN(1));
 80060be:	2080      	movs	r0, #128	; 0x80
 80060c0:	0200      	lsls	r0, r0, #8
 80060c2:	f001 fd45 	bl	8007b50 <HAL_GPIO_EXTI_IRQHandler>
}
 80060c6:	bd10      	pop	{r4, pc}

080060c8 <DMA1_Channel4_5_6_7_IRQHandler>:
  * @brief  This function handles DMA Channel 4 to 7 interrupts.
  * @param  None
  * @retval None
  */
void DMA1_Channel4_5_6_7_IRQHandler(void)
{
 80060c8:	b510      	push	{r4, lr}
  USBPD_DMA_PORT0_IRQHandler();
 80060ca:	f003 fc4d 	bl	8009968 <USBPD_DMA_PORT0_IRQHandler>
}
 80060ce:	bd10      	pop	{r4, pc}

080060d0 <TIM16_IRQHandler>:
  * @brief  This function handles TIM6 interrupt.
  * @param  None
  * @retval None
  */
void TIM16_IRQHandler(void)
{
 80060d0:	b510      	push	{r4, lr}
  USBPD_RX_PORT0_COUNTTIM_IRQHandler();
 80060d2:	f003 fcd1 	bl	8009a78 <USBPD_RX_PORT0_COUNTTIM_IRQHandler>
}
 80060d6:	bd10      	pop	{r4, pc}

080060d8 <DPM_TurnOffPower.isra.0>:
/**
  * @brief  Turn Off power supply.
  * @param  PortNum The current port number
  * @retval USBPD_OK, USBPD_ERROR
  */
static USBPD_StatusTypeDef DPM_TurnOffPower(uint8_t PortNum, USBPD_PortPowerRole_TypeDef Role)
 80060d8:	b510      	push	{r4, lr}
{
  USBPD_StatusTypeDef status = USBPD_OK;

  status = USBPD_PWR_IF_VBUSDisable(PortNum);
 80060da:	f000 fbd7 	bl	800688c <USBPD_PWR_IF_VBUSDisable>
  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_OFF, 0);
 80060de:	2200      	movs	r2, #0
  status = USBPD_PWR_IF_VBUSDisable(PortNum);
 80060e0:	0004      	movs	r4, r0
  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_OFF, 0);
 80060e2:	0011      	movs	r1, r2
 80060e4:	2002      	movs	r0, #2
 80060e6:	f006 fc6b 	bl	800c9c0 <Led_Set>
  return status;
}
 80060ea:	0020      	movs	r0, r4
 80060ec:	bd10      	pop	{r4, pc}
	...

080060f0 <USBPD_DPM_UserInit>:
{
 80060f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80060f2:	b089      	sub	sp, #36	; 0x24
  Led_Init();
 80060f4:	f006 fc4e 	bl	800c994 <Led_Init>
          ((DPM_Settings[USBPD_PORT_0].PE_DefaultRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC),
 80060f8:	4b17      	ldr	r3, [pc, #92]	; (8006158 <USBPD_DPM_UserInit+0x68>)
  Led_Set(LED_PORT0_ROLE,
 80060fa:	2200      	movs	r2, #0
 80060fc:	7919      	ldrb	r1, [r3, #4]
 80060fe:	2304      	movs	r3, #4
 8006100:	4019      	ands	r1, r3
 8006102:	424b      	negs	r3, r1
 8006104:	4159      	adcs	r1, r3
 8006106:	2001      	movs	r0, #1
 8006108:	3104      	adds	r1, #4
 800610a:	f006 fc59 	bl	800c9c0 <Led_Set>
  Led_Set(LED_PORT0_ROLE, LED_MODE_OFF, 0);
 800610e:	2200      	movs	r2, #0
 8006110:	2001      	movs	r0, #1
 8006112:	0011      	movs	r1, r2
 8006114:	f006 fc54 	bl	800c9c0 <Led_Set>
  USBPD_PWR_IF_Init();
 8006118:	f000 fab6 	bl	8006688 <USBPD_PWR_IF_Init>
  if(USBPD_OK != USBPD_PWR_IF_PowerResetGlobal()) return USBPD_ERROR;
 800611c:	f000 fb88 	bl	8006830 <USBPD_PWR_IF_PowerResetGlobal>
 8006120:	1e05      	subs	r5, r0, #0
 8006122:	d003      	beq.n	800612c <USBPD_DPM_UserInit+0x3c>
 8006124:	2502      	movs	r5, #2
}
 8006126:	0028      	movs	r0, r5
 8006128:	b009      	add	sp, #36	; 0x24
 800612a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  osMessageQDef(MsgBox, DPM_BOX_MESSAGES_MAX, uint32_t);
 800612c:	a801      	add	r0, sp, #4
 800612e:	0003      	movs	r3, r0
 8006130:	4c0a      	ldr	r4, [pc, #40]	; (800615c <USBPD_DPM_UserInit+0x6c>)
 8006132:	cc06      	ldmia	r4!, {r1, r2}
 8006134:	c306      	stmia	r3!, {r1, r2}
  DPMMsgBox = osMessageCreate(osMessageQ(MsgBox), NULL);
 8006136:	0029      	movs	r1, r5
 8006138:	f005 fc73 	bl	800ba22 <osMessageCreate>
 800613c:	4908      	ldr	r1, [pc, #32]	; (8006160 <USBPD_DPM_UserInit+0x70>)
 800613e:	6008      	str	r0, [r1, #0]
  osThreadDef(DPM, USBPD_DPM_UserExecute, osPriorityLow, 0, 120);
 8006140:	a803      	add	r0, sp, #12
 8006142:	0003      	movs	r3, r0
 8006144:	ccc4      	ldmia	r4!, {r2, r6, r7}
 8006146:	c3c4      	stmia	r3!, {r2, r6, r7}
 8006148:	cc44      	ldmia	r4!, {r2, r6}
 800614a:	c344      	stmia	r3!, {r2, r6}
  if(NULL == osThreadCreate(osThread(DPM), &DPMMsgBox))
 800614c:	f005 fc43 	bl	800b9d6 <osThreadCreate>
 8006150:	2800      	cmp	r0, #0
 8006152:	d1e8      	bne.n	8006126 <USBPD_DPM_UserInit+0x36>
 8006154:	e7e6      	b.n	8006124 <USBPD_DPM_UserInit+0x34>
 8006156:	46c0      	nop			; (mov r8, r8)
 8006158:	0800cd7c 	.word	0x0800cd7c
 800615c:	0800cce8 	.word	0x0800cce8
 8006160:	20001a44 	.word	0x20001a44

08006164 <USBPD_DPM_UserTimerCounter>:
  if((DPM_Ports[PortNum].DPM_TimerSRCExtendedCapa & DPM_TIMER_READ_MSK) > 0)
 8006164:	2378      	movs	r3, #120	; 0x78
 8006166:	4343      	muls	r3, r0
 8006168:	4805      	ldr	r0, [pc, #20]	; (8006180 <USBPD_DPM_UserTimerCounter+0x1c>)
 800616a:	18c0      	adds	r0, r0, r3
 800616c:	305a      	adds	r0, #90	; 0x5a
 800616e:	8803      	ldrh	r3, [r0, #0]
 8006170:	045b      	lsls	r3, r3, #17
 8006172:	d003      	beq.n	800617c <USBPD_DPM_UserTimerCounter+0x18>
    DPM_Ports[PortNum].DPM_TimerSRCExtendedCapa--;
 8006174:	8803      	ldrh	r3, [r0, #0]
 8006176:	3b01      	subs	r3, #1
 8006178:	b29b      	uxth	r3, r3
 800617a:	8003      	strh	r3, [r0, #0]
}
 800617c:	4770      	bx	lr
 800617e:	46c0      	nop			; (mov r8, r8)
 8006180:	200002c4 	.word	0x200002c4

08006184 <USBPD_DPM_UserCableDetection>:
{
 8006184:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006186:	0007      	movs	r7, r0
 8006188:	000e      	movs	r6, r1
 800618a:	4d47      	ldr	r5, [pc, #284]	; (80062a8 <USBPD_DPM_UserCableDetection+0x124>)
 800618c:	00c4      	lsls	r4, r0, #3
  switch(State)
 800618e:	2904      	cmp	r1, #4
 8006190:	d015      	beq.n	80061be <USBPD_DPM_UserCableDetection+0x3a>
 8006192:	2907      	cmp	r1, #7
 8006194:	d04a      	beq.n	800622c <USBPD_DPM_UserCableDetection+0xa8>
 8006196:	2902      	cmp	r1, #2
 8006198:	d164      	bne.n	8006264 <USBPD_DPM_UserCableDetection+0xe0>
    if(USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 800619a:	5d2b      	ldrb	r3, [r5, r4]
 800619c:	075b      	lsls	r3, r3, #29
 800619e:	d511      	bpl.n	80061c4 <USBPD_DPM_UserCableDetection+0x40>
      if (USBPD_OK != USBPD_PWR_IF_VBUSEnable(PortNum))
 80061a0:	f000 fb60 	bl	8006864 <USBPD_PWR_IF_VBUSEnable>
 80061a4:	2800      	cmp	r0, #0
 80061a6:	d140      	bne.n	800622a <USBPD_DPM_UserCableDetection+0xa6>
 80061a8:	003e      	movs	r6, r7
 80061aa:	1e73      	subs	r3, r6, #1
 80061ac:	419e      	sbcs	r6, r3
 80061ae:	3628      	adds	r6, #40	; 0x28
      while (STUSB1602_VBUS_Valid_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_within_VALID_vrange)
 80061b0:	0030      	movs	r0, r6
 80061b2:	f000 fc2f 	bl	8006a14 <STUSB1602_VBUS_Valid_Get>
 80061b6:	2801      	cmp	r0, #1
 80061b8:	d004      	beq.n	80061c4 <USBPD_DPM_UserCableDetection+0x40>
  \brief   No Operation
  \details No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
 80061ba:	46c0      	nop			; (mov r8, r8)
 80061bc:	e7f8      	b.n	80061b0 <USBPD_DPM_UserCableDetection+0x2c>
    if(USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 80061be:	5d2b      	ldrb	r3, [r5, r4]
 80061c0:	075b      	lsls	r3, r3, #29
 80061c2:	d422      	bmi.n	800620a <USBPD_DPM_UserCableDetection+0x86>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_CC : LED_PORT0_CC) , (DPM_Params[PortNum].ActiveCCIs == CC1 ? LED_MODE_BLINK_CC1 : LED_MODE_BLINK_CC2), 0);
 80061c4:	192b      	adds	r3, r5, r4
 80061c6:	7859      	ldrb	r1, [r3, #1]
 80061c8:	2200      	movs	r2, #0
 80061ca:	0789      	lsls	r1, r1, #30
 80061cc:	0f89      	lsrs	r1, r1, #30
 80061ce:	3901      	subs	r1, #1
 80061d0:	1e4b      	subs	r3, r1, #1
 80061d2:	4199      	sbcs	r1, r3
 80061d4:	2003      	movs	r0, #3
 80061d6:	3108      	adds	r1, #8
 80061d8:	f006 fbf2 	bl	800c9c0 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_BLINK_VBUS, 0);
 80061dc:	2200      	movs	r2, #0
 80061de:	2107      	movs	r1, #7
 80061e0:	2002      	movs	r0, #2
 80061e2:	f006 fbed 	bl	800c9c0 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT0_ROLE) , ((DPM_Params[PortNum].PE_PowerRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC), 0);
 80061e6:	5d29      	ldrb	r1, [r5, r4]
 80061e8:	2200      	movs	r2, #0
 80061ea:	0749      	lsls	r1, r1, #29
 80061ec:	0fc9      	lsrs	r1, r1, #31
 80061ee:	424b      	negs	r3, r1
 80061f0:	4159      	adcs	r1, r3
 80061f2:	2001      	movs	r0, #1
 80061f4:	3104      	adds	r1, #4
 80061f6:	f006 fbe3 	bl	800c9c0 <Led_Set>
    DPM_Ports[PortNum].DPM_IsConnected = 1;
 80061fa:	2378      	movs	r3, #120	; 0x78
 80061fc:	437b      	muls	r3, r7
 80061fe:	4f2b      	ldr	r7, [pc, #172]	; (80062ac <USBPD_DPM_UserCableDetection+0x128>)
 8006200:	18ff      	adds	r7, r7, r3
 8006202:	2301      	movs	r3, #1
 8006204:	3754      	adds	r7, #84	; 0x54
 8006206:	703b      	strb	r3, [r7, #0]
}
 8006208:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (USBPD_OK != USBPD_PWR_IF_VBUSEnable(PortNum))
 800620a:	f000 fb2b 	bl	8006864 <USBPD_PWR_IF_VBUSEnable>
 800620e:	2800      	cmp	r0, #0
 8006210:	d10a      	bne.n	8006228 <USBPD_DPM_UserCableDetection+0xa4>
 8006212:	003e      	movs	r6, r7
 8006214:	1e73      	subs	r3, r6, #1
 8006216:	419e      	sbcs	r6, r3
 8006218:	3628      	adds	r6, #40	; 0x28
      while (STUSB1602_VBUS_Valid_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_within_VALID_vrange)
 800621a:	0030      	movs	r0, r6
 800621c:	f000 fbfa 	bl	8006a14 <STUSB1602_VBUS_Valid_Get>
 8006220:	2801      	cmp	r0, #1
 8006222:	d0cf      	beq.n	80061c4 <USBPD_DPM_UserCableDetection+0x40>
 8006224:	46c0      	nop			; (mov r8, r8)
 8006226:	e7f8      	b.n	800621a <USBPD_DPM_UserCableDetection+0x96>
 8006228:	e7fe      	b.n	8006228 <USBPD_DPM_UserCableDetection+0xa4>
 800622a:	e7fe      	b.n	800622a <USBPD_DPM_UserCableDetection+0xa6>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_CC : LED_PORT0_CC) , (DPM_Params[PortNum].ActiveCCIs == CC1 ? LED_MODE_BLINK_CC1 : LED_MODE_BLINK_CC2), 0);
 800622c:	192b      	adds	r3, r5, r4
 800622e:	7859      	ldrb	r1, [r3, #1]
 8006230:	2200      	movs	r2, #0
 8006232:	0789      	lsls	r1, r1, #30
 8006234:	0f89      	lsrs	r1, r1, #30
 8006236:	3901      	subs	r1, #1
 8006238:	1e4b      	subs	r3, r1, #1
 800623a:	4199      	sbcs	r1, r3
 800623c:	2003      	movs	r0, #3
 800623e:	3108      	adds	r1, #8
 8006240:	f006 fbbe 	bl	800c9c0 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_BLINK_VBUS, 0);
 8006244:	0031      	movs	r1, r6
 8006246:	2200      	movs	r2, #0
 8006248:	2002      	movs	r0, #2
 800624a:	f006 fbb9 	bl	800c9c0 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT0_ROLE) , ((DPM_Params[PortNum].PE_PowerRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC), 0);
 800624e:	5d29      	ldrb	r1, [r5, r4]
            ((DPM_Settings[PortNum].PE_DefaultRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC),
 8006250:	0749      	lsls	r1, r1, #29
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT0_ROLE),
 8006252:	0fc9      	lsrs	r1, r1, #31
 8006254:	424b      	negs	r3, r1
 8006256:	4159      	adcs	r1, r3
 8006258:	2200      	movs	r2, #0
 800625a:	3104      	adds	r1, #4
 800625c:	2001      	movs	r0, #1
 800625e:	f006 fbaf 	bl	800c9c0 <Led_Set>
}
 8006262:	e7d1      	b.n	8006208 <USBPD_DPM_UserCableDetection+0x84>
    memset(&DPM_Ports[PortNum], 0, sizeof(DPM_Ports[PortNum]));
 8006264:	2278      	movs	r2, #120	; 0x78
 8006266:	0013      	movs	r3, r2
 8006268:	4343      	muls	r3, r0
 800626a:	4810      	ldr	r0, [pc, #64]	; (80062ac <USBPD_DPM_UserCableDetection+0x128>)
 800626c:	2100      	movs	r1, #0
 800626e:	18c0      	adds	r0, r0, r3
 8006270:	f006 fc9d 	bl	800cbae <memset>
    if(USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 8006274:	5d2b      	ldrb	r3, [r5, r4]
 8006276:	075b      	lsls	r3, r3, #29
 8006278:	d505      	bpl.n	8006286 <USBPD_DPM_UserCableDetection+0x102>
      if (USBPD_OK != USBPD_PWR_IF_VBUSDisable(PortNum))
 800627a:	0038      	movs	r0, r7
 800627c:	f000 fb06 	bl	800688c <USBPD_PWR_IF_VBUSDisable>
 8006280:	2800      	cmp	r0, #0
 8006282:	d000      	beq.n	8006286 <USBPD_DPM_UserCableDetection+0x102>
 8006284:	e7fe      	b.n	8006284 <USBPD_DPM_UserCableDetection+0x100>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_CC : LED_PORT0_CC) , LED_MODE_OFF, 0);
 8006286:	2200      	movs	r2, #0
 8006288:	2003      	movs	r0, #3
 800628a:	0011      	movs	r1, r2
 800628c:	f006 fb98 	bl	800c9c0 <Led_Set>
    Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_OFF, 0);
 8006290:	2200      	movs	r2, #0
 8006292:	2002      	movs	r0, #2
 8006294:	0011      	movs	r1, r2
 8006296:	f006 fb93 	bl	800c9c0 <Led_Set>
            ((DPM_Settings[PortNum].PE_DefaultRole == USBPD_PORTPOWERROLE_SNK) ? LED_MODE_BLINK_ROLE_SNK : LED_MODE_BLINK_ROLE_SRC),
 800629a:	230c      	movs	r3, #12
 800629c:	437b      	muls	r3, r7
 800629e:	4f04      	ldr	r7, [pc, #16]	; (80062b0 <USBPD_DPM_UserCableDetection+0x12c>)
 80062a0:	18ff      	adds	r7, r7, r3
 80062a2:	7939      	ldrb	r1, [r7, #4]
 80062a4:	e7d4      	b.n	8006250 <USBPD_DPM_UserCableDetection+0xcc>
 80062a6:	46c0      	nop			; (mov r8, r8)
 80062a8:	20001c60 	.word	0x20001c60
 80062ac:	200002c4 	.word	0x200002c4
 80062b0:	0800cd7c 	.word	0x0800cd7c

080062b4 <USBPD_DPM_HardReset>:
{
 80062b4:	b570      	push	{r4, r5, r6, lr}
 80062b6:	0004      	movs	r4, r0
 80062b8:	000d      	movs	r5, r1
  switch(Status)
 80062ba:	2a06      	cmp	r2, #6
 80062bc:	d818      	bhi.n	80062f0 <USBPD_DPM_HardReset+0x3c>
 80062be:	0010      	movs	r0, r2
 80062c0:	f7ff fb78 	bl	80059b4 <__gnu_thumb1_case_uqi>
 80062c4:	16161704 	.word	0x16161704
 80062c8:	3223      	.short	0x3223
 80062ca:	4a          	.byte	0x4a
 80062cb:	00          	.byte	0x00
    if (USBPD_PORTPOWERROLE_SRC == CurrentRole)
 80062cc:	2901      	cmp	r1, #1
 80062ce:	d107      	bne.n	80062e0 <USBPD_DPM_HardReset+0x2c>
  * @param  PortNum The current port number
  * @retval None
  */
static void DPM_AssertRp(uint8_t PortNum)
{
  USBPD_CAD_AssertRp(PortNum);
 80062d0:	0020      	movs	r0, r4
 80062d2:	f7f9 ffb7 	bl	8000244 <USBPD_CAD_AssertRp>

  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT0_ROLE) , LED_MODE_BLINK_ROLE_SRC, 0);
 80062d6:	2200      	movs	r2, #0
 80062d8:	2104      	movs	r1, #4
 80062da:	0028      	movs	r0, r5
 80062dc:	f006 fb70 	bl	800c9c0 <Led_Set>
    USBPD_HW_IF_HR_Start(PortNum, CurrentRole, ACKNOWLEDGE);
 80062e0:	2200      	movs	r2, #0
    USBPD_HW_IF_HR_Start(PortNum, CurrentRole, REQUEST);
 80062e2:	0029      	movs	r1, r5
 80062e4:	0020      	movs	r0, r4
 80062e6:	f004 fb65 	bl	800a9b4 <USBPD_HW_IF_HR_Start>
    DPM_TurnOffPower(PortNum, CurrentRole);
 80062ea:	0020      	movs	r0, r4
 80062ec:	f7ff fef4 	bl	80060d8 <DPM_TurnOffPower.isra.0>
}
 80062f0:	bd70      	pop	{r4, r5, r6, pc}
    if (USBPD_PORTPOWERROLE_SRC == CurrentRole)
 80062f2:	2901      	cmp	r1, #1
 80062f4:	d107      	bne.n	8006306 <USBPD_DPM_HardReset+0x52>
  USBPD_CAD_AssertRp(PortNum);
 80062f6:	0020      	movs	r0, r4
 80062f8:	f7f9 ffa4 	bl	8000244 <USBPD_CAD_AssertRp>
  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_ROLE : LED_PORT0_ROLE) , LED_MODE_BLINK_ROLE_SRC, 0);
 80062fc:	2200      	movs	r2, #0
 80062fe:	2104      	movs	r1, #4
 8006300:	0028      	movs	r0, r5
 8006302:	f006 fb5d 	bl	800c9c0 <Led_Set>
    USBPD_HW_IF_HR_Start(PortNum, CurrentRole, REQUEST);
 8006306:	2201      	movs	r2, #1
 8006308:	e7eb      	b.n	80062e2 <USBPD_DPM_HardReset+0x2e>
    USBPD_HW_IF_HR_CheckVbusVSafe0V(PortNum, CurrentRole);
 800630a:	0020      	movs	r0, r4
 800630c:	f004 fba6 	bl	800aa5c <USBPD_HW_IF_HR_CheckVbusVSafe0V>
    if (CurrentRole == USBPD_PORTPOWERROLE_SNK)
 8006310:	2d00      	cmp	r5, #0
 8006312:	d1ed      	bne.n	80062f0 <USBPD_DPM_HardReset+0x3c>
 8006314:	1e63      	subs	r3, r4, #1
 8006316:	419c      	sbcs	r4, r3
 8006318:	3428      	adds	r4, #40	; 0x28
      while (STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_below_VSAFE0V_threshold)
 800631a:	0020      	movs	r0, r4
 800631c:	f000 fb86 	bl	8006a2c <STUSB1602_VBUS_VSAFE0V_Get>
 8006320:	2801      	cmp	r0, #1
 8006322:	d0e5      	beq.n	80062f0 <USBPD_DPM_HardReset+0x3c>
 8006324:	46c0      	nop			; (mov r8, r8)
 8006326:	e7f8      	b.n	800631a <USBPD_DPM_HardReset+0x66>
    USBPD_HW_IF_HR_End(PortNum, CurrentRole);
 8006328:	0020      	movs	r0, r4
 800632a:	f004 fba9 	bl	800aa80 <USBPD_HW_IF_HR_End>
  status = USBPD_PWR_IF_VBUSEnable(PortNum);
 800632e:	0020      	movs	r0, r4
 8006330:	f000 fa98 	bl	8006864 <USBPD_PWR_IF_VBUSEnable>
  if(USBPD_PORTPOWERROLE_SRC == Role)
 8006334:	2d01      	cmp	r5, #1
 8006336:	d005      	beq.n	8006344 <USBPD_DPM_HardReset+0x90>
  Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_BLINK_VBUS, 0);
 8006338:	2200      	movs	r2, #0
 800633a:	2107      	movs	r1, #7
 800633c:	2002      	movs	r0, #2
 800633e:	f006 fb3f 	bl	800c9c0 <Led_Set>
 8006342:	e7d5      	b.n	80062f0 <USBPD_DPM_HardReset+0x3c>
 8006344:	1e63      	subs	r3, r4, #1
 8006346:	419c      	sbcs	r4, r3
 8006348:	3428      	adds	r4, #40	; 0x28
    while (STUSB1602_VBUS_Valid_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_within_VALID_vrange)
 800634a:	0020      	movs	r0, r4
 800634c:	f000 fb62 	bl	8006a14 <STUSB1602_VBUS_Valid_Get>
 8006350:	2801      	cmp	r0, #1
 8006352:	d0f1      	beq.n	8006338 <USBPD_DPM_HardReset+0x84>
 8006354:	46c0      	nop			; (mov r8, r8)
 8006356:	e7f8      	b.n	800634a <USBPD_DPM_HardReset+0x96>
    USBPD_HW_IF_HR_End(PortNum, CurrentRole);
 8006358:	0020      	movs	r0, r4
 800635a:	f004 fb91 	bl	800aa80 <USBPD_HW_IF_HR_End>
}
 800635e:	e7c7      	b.n	80062f0 <USBPD_DPM_HardReset+0x3c>

08006360 <USBPD_DPM_SetupNewPower>:
  rdoposition = DPM_Ports[PortNum].DPM_RDOPosition;
 8006360:	2278      	movs	r2, #120	; 0x78
 8006362:	4342      	muls	r2, r0
 8006364:	4b06      	ldr	r3, [pc, #24]	; (8006380 <USBPD_DPM_SetupNewPower+0x20>)
{
 8006366:	b510      	push	{r4, lr}
  rdoposition = DPM_Ports[PortNum].DPM_RDOPosition;
 8006368:	189b      	adds	r3, r3, r2
 800636a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800636c:	b2d1      	uxtb	r1, r2
    status = USBPD_PWR_IF_SetProfile(PortNum, 0, 0);
 800636e:	1e0a      	subs	r2, r1, #0
  if (rdoposition > 0)
 8006370:	d003      	beq.n	800637a <USBPD_DPM_SetupNewPower+0x1a>
  previous_rdoposition = DPM_Ports[PortNum].DPM_RDOPositionPrevious;
 8006372:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    status = USBPD_PWR_IF_SetProfile(PortNum, rdoposition-1, previous_rdoposition);
 8006374:	3901      	subs	r1, #1
 8006376:	b2d2      	uxtb	r2, r2
 8006378:	b2c9      	uxtb	r1, r1
    status = USBPD_PWR_IF_SetProfile(PortNum, 0, 0);
 800637a:	f000 f991 	bl	80066a0 <USBPD_PWR_IF_SetProfile>
}
 800637e:	bd10      	pop	{r4, pc}
 8006380:	200002c4 	.word	0x200002c4

08006384 <USBPD_DPM_EvaluatePowerRoleSwap>:
}
 8006384:	200a      	movs	r0, #10
 8006386:	4770      	bx	lr

08006388 <USBPD_DPM_Notification>:
{
 8006388:	b510      	push	{r4, lr}
  switch(EventVal)
 800638a:	2910      	cmp	r1, #16
 800638c:	d104      	bne.n	8006398 <USBPD_DPM_Notification+0x10>
      Led_Set((PortNum == USBPD_PORT_0 ? LED_PORT0_VBUS : LED_PORT0_VBUS) , LED_MODE_ON, 0);
 800638e:	2200      	movs	r2, #0
 8006390:	390f      	subs	r1, #15
 8006392:	2002      	movs	r0, #2
 8006394:	f006 fb14 	bl	800c9c0 <Led_Set>
}
 8006398:	bd10      	pop	{r4, pc}

0800639a <USBPD_DPM_IsContractStillValid>:
}
 800639a:	2000      	movs	r0, #0
 800639c:	4770      	bx	lr
	...

080063a0 <USBPD_DPM_GetDataInfo>:
{
 80063a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80063a2:	0005      	movs	r5, r0
 80063a4:	0016      	movs	r6, r2
 80063a6:	001c      	movs	r4, r3
  switch (DataId)
 80063a8:	290d      	cmp	r1, #13
 80063aa:	d866      	bhi.n	800647a <USBPD_DPM_GetDataInfo+0xda>
 80063ac:	0008      	movs	r0, r1
 80063ae:	f7ff fb01 	bl	80059b4 <__gnu_thumb1_case_uqi>
 80063b2:	2424      	.short	0x2424
 80063b4:	07162b64 	.word	0x07162b64
 80063b8:	64393364 	.word	0x64393364
 80063bc:	43646464 	.word	0x43646464
 80063c0:	2178      	movs	r1, #120	; 0x78
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO; index++)
 80063c2:	2200      	movs	r2, #0
 80063c4:	434d      	muls	r5, r1
 80063c6:	492e      	ldr	r1, [pc, #184]	; (8006480 <USBPD_DPM_GetDataInfo+0xe0>)
 80063c8:	1948      	adds	r0, r1, r5
 80063ca:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80063cc:	4293      	cmp	r3, r2
 80063ce:	d918      	bls.n	8006402 <USBPD_DPM_GetDataInfo+0x62>
 80063d0:	0097      	lsls	r7, r2, #2
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSNKPDO[index];
 80063d2:	19eb      	adds	r3, r5, r7
 80063d4:	18cb      	adds	r3, r1, r3
 80063d6:	699b      	ldr	r3, [r3, #24]
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO; index++)
 80063d8:	3201      	adds	r2, #1
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSNKPDO[index];
 80063da:	51f3      	str	r3, [r6, r7]
 80063dc:	e7f5      	b.n	80063ca <USBPD_DPM_GetDataInfo+0x2a>
 80063de:	2178      	movs	r1, #120	; 0x78
 80063e0:	4369      	muls	r1, r5
 80063e2:	4d27      	ldr	r5, [pc, #156]	; (8006480 <USBPD_DPM_GetDataInfo+0xe0>)
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO; index++)
 80063e4:	2200      	movs	r2, #0
 80063e6:	186d      	adds	r5, r5, r1
 80063e8:	0029      	movs	r1, r5
 80063ea:	694b      	ldr	r3, [r1, #20]
 80063ec:	4293      	cmp	r3, r2
 80063ee:	d908      	bls.n	8006402 <USBPD_DPM_GetDataInfo+0x62>
 80063f0:	0093      	lsls	r3, r2, #2
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index];
 80063f2:	58e8      	ldr	r0, [r5, r3]
    for(index = 0; index < DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO; index++)
 80063f4:	3201      	adds	r2, #1
      *(uint32_t*)(Ptr + index) = DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index];
 80063f6:	50f0      	str	r0, [r6, r3]
 80063f8:	e7f7      	b.n	80063ea <USBPD_DPM_GetDataInfo+0x4a>
    USBPD_PWR_IF_GetPortPDOs(PortNum, DataId, Ptr, Size);
 80063fa:	0028      	movs	r0, r5
 80063fc:	f000 fa5a 	bl	80068b4 <USBPD_PWR_IF_GetPortPDOs>
    *Size *= 4;
 8006400:	6823      	ldr	r3, [r4, #0]
    *Size = (DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO * 4);
 8006402:	009b      	lsls	r3, r3, #2
    *Size = 0;
 8006404:	6023      	str	r3, [r4, #0]
}
 8006406:	e016      	b.n	8006436 <USBPD_DPM_GetDataInfo+0x96>
    *Ptr = DPM_Ports[PortNum].DPM_RequestedVoltage;
 8006408:	2178      	movs	r1, #120	; 0x78
 800640a:	4369      	muls	r1, r5
 800640c:	4d1c      	ldr	r5, [pc, #112]	; (8006480 <USBPD_DPM_GetDataInfo+0xe0>)
 800640e:	186d      	adds	r5, r5, r1
 8006410:	6b6b      	ldr	r3, [r5, #52]	; 0x34
    *Ptr = DPM_Ports[PortNum].DPM_RequestDOMsg;
 8006412:	6033      	str	r3, [r6, #0]
    *Size = 4;
 8006414:	2304      	movs	r3, #4
 8006416:	e7f5      	b.n	8006404 <USBPD_DPM_GetDataInfo+0x64>
    *Ptr = DPM_Ports[PortNum].DPM_RequestDOMsg;
 8006418:	2178      	movs	r1, #120	; 0x78
 800641a:	4369      	muls	r1, r5
 800641c:	4d18      	ldr	r5, [pc, #96]	; (8006480 <USBPD_DPM_GetDataInfo+0xe0>)
 800641e:	186d      	adds	r5, r5, r1
 8006420:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8006422:	e7f6      	b.n	8006412 <USBPD_DPM_GetDataInfo+0x72>
      memcpy((uint8_t*)Ptr, (uint8_t *)&DPM_USER_Settings[PortNum].DPM_SRCExtendedCapa, *Size);
 8006424:	2138      	movs	r1, #56	; 0x38
      *Size = sizeof(USBPD_SCEDB_TypeDef);
 8006426:	2218      	movs	r2, #24
      memcpy((uint8_t*)Ptr, (uint8_t *)&DPM_USER_Settings[PortNum].DPM_SRCExtendedCapa, *Size);
 8006428:	434d      	muls	r5, r1
 800642a:	4916      	ldr	r1, [pc, #88]	; (8006484 <USBPD_DPM_GetDataInfo+0xe4>)
      *Size = sizeof(USBPD_SCEDB_TypeDef);
 800642c:	601a      	str	r2, [r3, #0]
      memcpy((uint8_t*)Ptr, (uint8_t *)&DPM_USER_Settings[PortNum].DPM_SRCExtendedCapa, *Size);
 800642e:	1869      	adds	r1, r5, r1
      memcpy((uint8_t*)Ptr, (uint8_t *)manu_info, *Size);
 8006430:	0030      	movs	r0, r6
 8006432:	f006 fbb3 	bl	800cb9c <memcpy>
}
 8006436:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 8006438:	2178      	movs	r1, #120	; 0x78
 800643a:	2338      	movs	r3, #56	; 0x38
 800643c:	4369      	muls	r1, r5
 800643e:	436b      	muls	r3, r5
 8006440:	4d0f      	ldr	r5, [pc, #60]	; (8006480 <USBPD_DPM_GetDataInfo+0xe0>)
      manu_info = (USBPD_MIDB_TypeDef*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort;
 8006442:	001f      	movs	r7, r3
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 8006444:	186d      	adds	r5, r5, r1
 8006446:	0029      	movs	r1, r5
 8006448:	3174      	adds	r1, #116	; 0x74
      manu_info = (USBPD_MIDB_TypeDef*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort;
 800644a:	4a0e      	ldr	r2, [pc, #56]	; (8006484 <USBPD_DPM_GetDataInfo+0xe4>)
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 800644c:	7809      	ldrb	r1, [r1, #0]
      manu_info = (USBPD_MIDB_TypeDef*)&DPM_USER_Settings[PortNum].DPM_ManuInfoPort;
 800644e:	3718      	adds	r7, #24
 8006450:	18bf      	adds	r7, r7, r2
      if((DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget > USBPD_MANUFINFO_TARGET_BATTERY)
 8006452:	2901      	cmp	r1, #1
 8006454:	d803      	bhi.n	800645e <USBPD_DPM_GetDataInfo+0xbe>
      || (DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoRef > USBPD_MANUFINFO_REF_MAX_VALUES))
 8006456:	3575      	adds	r5, #117	; 0x75
 8006458:	7828      	ldrb	r0, [r5, #0]
 800645a:	2807      	cmp	r0, #7
 800645c:	d904      	bls.n	8006468 <USBPD_DPM_GetDataInfo+0xc8>
        *Size = 4; /* VID (2) + .PID(2) */
 800645e:	2304      	movs	r3, #4
 8006460:	6023      	str	r3, [r4, #0]
      memcpy((uint8_t*)Ptr, (uint8_t *)manu_info, *Size);
 8006462:	6822      	ldr	r2, [r4, #0]
 8006464:	0039      	movs	r1, r7
 8006466:	e7e3      	b.n	8006430 <USBPD_DPM_GetDataInfo+0x90>
        if (USBPD_MANUFINFO_TARGET_PORT_CABLE_PLUG == DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget)
 8006468:	2900      	cmp	r1, #0
 800646a:	d1f8      	bne.n	800645e <USBPD_DPM_GetDataInfo+0xbe>
          *Size = 4 + strlen((char*)(DPM_USER_Settings[PortNum].DPM_ManuInfoPort.ManuString));
 800646c:	331c      	adds	r3, #28
 800646e:	1898      	adds	r0, r3, r2
 8006470:	f7ff fa8e 	bl	8005990 <strlen>
 8006474:	3004      	adds	r0, #4
 8006476:	6020      	str	r0, [r4, #0]
 8006478:	e7f3      	b.n	8006462 <USBPD_DPM_GetDataInfo+0xc2>
    *Size = 0;
 800647a:	2300      	movs	r3, #0
 800647c:	e7c2      	b.n	8006404 <USBPD_DPM_GetDataInfo+0x64>
 800647e:	46c0      	nop			; (mov r8, r8)
 8006480:	200002c4 	.word	0x200002c4
 8006484:	0800cdf8 	.word	0x0800cdf8

08006488 <USBPD_DPM_SetDataInfo>:
{
 8006488:	b570      	push	{r4, r5, r6, lr}
 800648a:	0005      	movs	r5, r0
  switch (DataId)
 800648c:	1e88      	subs	r0, r1, #2
{
 800648e:	0014      	movs	r4, r2
  switch (DataId)
 8006490:	280a      	cmp	r0, #10
 8006492:	d811      	bhi.n	80064b8 <USBPD_DPM_SetDataInfo+0x30>
 8006494:	f7ff fa8e 	bl	80059b4 <__gnu_thumb1_case_uqi>
 8006498:	341a1106 	.word	0x341a1106
 800649c:	10584f4f 	.word	0x10584f4f
 80064a0:	1010      	.short	0x1010
 80064a2:	62          	.byte	0x62
 80064a3:	00          	.byte	0x00
    if (Size == 4)
 80064a4:	2b04      	cmp	r3, #4
 80064a6:	d107      	bne.n	80064b8 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_RDOPosition = *Ptr;
 80064a8:	2078      	movs	r0, #120	; 0x78
 80064aa:	4368      	muls	r0, r5
 80064ac:	4d31      	ldr	r5, [pc, #196]	; (8006574 <USBPD_DPM_SetDataInfo+0xec>)
 80064ae:	6813      	ldr	r3, [r2, #0]
 80064b0:	182d      	adds	r5, r5, r0
 80064b2:	632b      	str	r3, [r5, #48]	; 0x30
      DPM_Ports[PortNum].DPM_RDOPositionPrevious = *Ptr;
 80064b4:	6813      	ldr	r3, [r2, #0]
 80064b6:	642b      	str	r3, [r5, #64]	; 0x40
}
 80064b8:	bd70      	pop	{r4, r5, r6, pc}
    if (Size == 4)
 80064ba:	2b04      	cmp	r3, #4
 80064bc:	d1fc      	bne.n	80064b8 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_RequestedVoltage = *Ptr;
 80064be:	2078      	movs	r0, #120	; 0x78
 80064c0:	4368      	muls	r0, r5
 80064c2:	4d2c      	ldr	r5, [pc, #176]	; (8006574 <USBPD_DPM_SetDataInfo+0xec>)
 80064c4:	6813      	ldr	r3, [r2, #0]
 80064c6:	182d      	adds	r5, r5, r0
 80064c8:	636b      	str	r3, [r5, #52]	; 0x34
 80064ca:	e7f5      	b.n	80064b8 <USBPD_DPM_SetDataInfo+0x30>
    if (Size <= (USBPD_MAX_NB_PDO * 4))
 80064cc:	2b14      	cmp	r3, #20
 80064ce:	d8f3      	bhi.n	80064b8 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO = (Size / 4);
 80064d0:	2078      	movs	r0, #120	; 0x78
      for (index = 0; index < (Size / 4); index++)
 80064d2:	2100      	movs	r1, #0
      DPM_Ports[PortNum].DPM_NumberOfRcvSRCPDO = (Size / 4);
 80064d4:	4345      	muls	r5, r0
 80064d6:	4827      	ldr	r0, [pc, #156]	; (8006574 <USBPD_DPM_SetDataInfo+0xec>)
 80064d8:	089b      	lsrs	r3, r3, #2
 80064da:	1940      	adds	r0, r0, r5
 80064dc:	6143      	str	r3, [r0, #20]
      for (index = 0; index < (Size / 4); index++)
 80064de:	428b      	cmp	r3, r1
 80064e0:	d0ea      	beq.n	80064b8 <USBPD_DPM_SetDataInfo+0x30>
        DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index] = LE32(Ptr + index);
 80064e2:	7862      	ldrb	r2, [r4, #1]
 80064e4:	78a6      	ldrb	r6, [r4, #2]
 80064e6:	0212      	lsls	r2, r2, #8
 80064e8:	0436      	lsls	r6, r6, #16
 80064ea:	1992      	adds	r2, r2, r6
 80064ec:	7826      	ldrb	r6, [r4, #0]
 80064ee:	008d      	lsls	r5, r1, #2
 80064f0:	1992      	adds	r2, r2, r6
 80064f2:	78e6      	ldrb	r6, [r4, #3]
      for (index = 0; index < (Size / 4); index++)
 80064f4:	3101      	adds	r1, #1
        DPM_Ports[PortNum].DPM_ListOfRcvSRCPDO[index] = LE32(Ptr + index);
 80064f6:	0636      	lsls	r6, r6, #24
 80064f8:	1992      	adds	r2, r2, r6
 80064fa:	5142      	str	r2, [r0, r5]
 80064fc:	3404      	adds	r4, #4
 80064fe:	e7ee      	b.n	80064de <USBPD_DPM_SetDataInfo+0x56>
    if (Size <= (USBPD_MAX_NB_PDO * 4))
 8006500:	2b14      	cmp	r3, #20
 8006502:	d8d9      	bhi.n	80064b8 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_NumberOfRcvSNKPDO = (Size / 4);
 8006504:	2078      	movs	r0, #120	; 0x78
 8006506:	4345      	muls	r5, r0
 8006508:	4a1a      	ldr	r2, [pc, #104]	; (8006574 <USBPD_DPM_SetDataInfo+0xec>)
 800650a:	089b      	lsrs	r3, r3, #2
 800650c:	1951      	adds	r1, r2, r5
 800650e:	62cb      	str	r3, [r1, #44]	; 0x2c
 8006510:	3518      	adds	r5, #24
 8006512:	009b      	lsls	r3, r3, #2
 8006514:	1955      	adds	r5, r2, r5
 8006516:	18e3      	adds	r3, r4, r3
      for (index = 0; index < (Size / 4); index++)
 8006518:	429c      	cmp	r4, r3
 800651a:	d0cd      	beq.n	80064b8 <USBPD_DPM_SetDataInfo+0x30>
        DPM_Ports[PortNum].DPM_ListOfRcvSNKPDO[index] = LE32(Ptr + index);
 800651c:	7860      	ldrb	r0, [r4, #1]
 800651e:	78a2      	ldrb	r2, [r4, #2]
 8006520:	0200      	lsls	r0, r0, #8
 8006522:	0412      	lsls	r2, r2, #16
 8006524:	1880      	adds	r0, r0, r2
 8006526:	7822      	ldrb	r2, [r4, #0]
 8006528:	1880      	adds	r0, r0, r2
 800652a:	78e2      	ldrb	r2, [r4, #3]
 800652c:	3404      	adds	r4, #4
 800652e:	0612      	lsls	r2, r2, #24
 8006530:	1880      	adds	r0, r0, r2
 8006532:	c501      	stmia	r5!, {r0}
 8006534:	e7f0      	b.n	8006518 <USBPD_DPM_SetDataInfo+0x90>
    if (Size == 4)
 8006536:	2b04      	cmp	r3, #4
 8006538:	d1be      	bne.n	80064b8 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_RcvRequestDOMsg = *Ptr;
 800653a:	2078      	movs	r0, #120	; 0x78
 800653c:	4368      	muls	r0, r5
 800653e:	4d0d      	ldr	r5, [pc, #52]	; (8006574 <USBPD_DPM_SetDataInfo+0xec>)
 8006540:	6813      	ldr	r3, [r2, #0]
 8006542:	182d      	adds	r5, r5, r0
 8006544:	64eb      	str	r3, [r5, #76]	; 0x4c
 8006546:	e7b7      	b.n	80064b8 <USBPD_DPM_SetDataInfo+0x30>
      ext_capa = (uint8_t*)&DPM_Ports[PortNum].DPM_RcvSRCExtendedCapa;
 8006548:	2078      	movs	r0, #120	; 0x78
 800654a:	4368      	muls	r0, r5
 800654c:	4d09      	ldr	r5, [pc, #36]	; (8006574 <USBPD_DPM_SetDataInfo+0xec>)
 800654e:	305c      	adds	r0, #92	; 0x5c
 8006550:	1828      	adds	r0, r5, r0
      memcpy(ext_capa, Ptr, Size);
 8006552:	001a      	movs	r2, r3
 8006554:	0021      	movs	r1, r4
 8006556:	f006 fb21 	bl	800cb9c <memcpy>
    break;
 800655a:	e7ad      	b.n	80064b8 <USBPD_DPM_SetDataInfo+0x30>
      DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoTarget = *temp;
 800655c:	2078      	movs	r0, #120	; 0x78
 800655e:	4368      	muls	r0, r5
 8006560:	4d04      	ldr	r5, [pc, #16]	; (8006574 <USBPD_DPM_SetDataInfo+0xec>)
 8006562:	7812      	ldrb	r2, [r2, #0]
 8006564:	182d      	adds	r5, r5, r0
 8006566:	002b      	movs	r3, r5
 8006568:	3374      	adds	r3, #116	; 0x74
 800656a:	701a      	strb	r2, [r3, #0]
      DPM_Ports[PortNum].DPM_GetManufacturerInfo.ManufacturerInfoRef    = *(temp + 1);
 800656c:	7863      	ldrb	r3, [r4, #1]
 800656e:	3575      	adds	r5, #117	; 0x75
 8006570:	702b      	strb	r3, [r5, #0]
}
 8006572:	e7a1      	b.n	80064b8 <USBPD_DPM_SetDataInfo+0x30>
 8006574:	200002c4 	.word	0x200002c4

08006578 <USBPD_DPM_EvaluateRequest>:
{
 8006578:	b5f0      	push	{r4, r5, r6, r7, lr}
  rdo.d32 = pdhandle->DPM_RcvRequestDOMsg;
 800657a:	2478      	movs	r4, #120	; 0x78
 800657c:	4344      	muls	r4, r0
 800657e:	4b1a      	ldr	r3, [pc, #104]	; (80065e8 <USBPD_DPM_EvaluateRequest+0x70>)
{
 8006580:	b085      	sub	sp, #20
  rdo.d32 = pdhandle->DPM_RcvRequestDOMsg;
 8006582:	191c      	adds	r4, r3, r4
  pdhandle->DPM_RDOPosition = 0;
 8006584:	2300      	movs	r3, #0
  rdo.d32 = pdhandle->DPM_RcvRequestDOMsg;
 8006586:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
  if (USBPD_PWR_IF_SearchRequestedPDO(PortNum, rdoobjposition, &pdo.d32) != USBPD_OK)
 8006588:	af03      	add	r7, sp, #12
  rdoobjposition  = rdo.GenericRDO.ObjectPosition;
 800658a:	006e      	lsls	r6, r5, #1
 800658c:	0f76      	lsrs	r6, r6, #29
{
 800658e:	9101      	str	r1, [sp, #4]
  pdhandle->DPM_RDOPosition = 0;
 8006590:	6323      	str	r3, [r4, #48]	; 0x30
  if (USBPD_PWR_IF_SearchRequestedPDO(PortNum, rdoobjposition, &pdo.d32) != USBPD_OK)
 8006592:	003a      	movs	r2, r7
 8006594:	0031      	movs	r1, r6
 8006596:	f000 f9a9 	bl	80068ec <USBPD_PWR_IF_SearchRequestedPDO>
 800659a:	2800      	cmp	r0, #0
 800659c:	d001      	beq.n	80065a2 <USBPD_DPM_EvaluateRequest+0x2a>
      return USBPD_REJECT;
 800659e:	200c      	movs	r0, #12
 80065a0:	e01f      	b.n	80065e2 <USBPD_DPM_EvaluateRequest+0x6a>
  switch(pdo.GenericPDO.PowerObject)
 80065a2:	ab02      	add	r3, sp, #8
 80065a4:	79da      	ldrb	r2, [r3, #7]
 80065a6:	0992      	lsrs	r2, r2, #6
 80065a8:	b2d3      	uxtb	r3, r2
 80065aa:	2b00      	cmp	r3, #0
 80065ac:	d1f7      	bne.n	800659e <USBPD_DPM_EvaluateRequest+0x26>
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 80065ae:	200a      	movs	r0, #10
      pdomaxcurrent = pdo.SRCFixedPDO.MaxCurrentIn10mAunits;
 80065b0:	883b      	ldrh	r3, [r7, #0]
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 80065b2:	0007      	movs	r7, r0
      rdomaxcurrent = rdo.FixedVariableRDO.MaxOperatingCurrent10mAunits;
 80065b4:	05a9      	lsls	r1, r5, #22
      rdoopcurrent  = rdo.FixedVariableRDO.OperatingCurrentIn10mAunits;
 80065b6:	032d      	lsls	r5, r5, #12
 80065b8:	0dad      	lsrs	r5, r5, #22
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 80065ba:	436f      	muls	r7, r5
      pdomaxcurrent = pdo.SRCFixedPDO.MaxCurrentIn10mAunits;
 80065bc:	059b      	lsls	r3, r3, #22
 80065be:	0d9b      	lsrs	r3, r3, #22
      rdomaxcurrent = rdo.FixedVariableRDO.MaxOperatingCurrent10mAunits;
 80065c0:	0d89      	lsrs	r1, r1, #22
      DPM_Ports[PortNum].DPM_RequestedCurrent = rdoopcurrent * 10;
 80065c2:	63a7      	str	r7, [r4, #56]	; 0x38
      if(rdoopcurrent > pdomaxcurrent)
 80065c4:	42ab      	cmp	r3, r5
 80065c6:	d3ea      	bcc.n	800659e <USBPD_DPM_EvaluateRequest+0x26>
      if(rdomaxcurrent > pdomaxcurrent)
 80065c8:	428b      	cmp	r3, r1
 80065ca:	d3e8      	bcc.n	800659e <USBPD_DPM_EvaluateRequest+0x26>
  pdhandle->DPM_RequestedVoltage = pdo.SRCFixedPDO.VoltageIn50mVunits * 50;
 80065cc:	2132      	movs	r1, #50	; 0x32
 80065ce:	9b03      	ldr	r3, [sp, #12]
 80065d0:	031b      	lsls	r3, r3, #12
 80065d2:	0d9b      	lsrs	r3, r3, #22
 80065d4:	434b      	muls	r3, r1
 80065d6:	6363      	str	r3, [r4, #52]	; 0x34
  pdhandle->DPM_RDOPositionPrevious = pdhandle->DPM_RDOPosition;
 80065d8:	6b23      	ldr	r3, [r4, #48]	; 0x30
  pdhandle->DPM_RDOPosition = rdoobjposition;
 80065da:	6326      	str	r6, [r4, #48]	; 0x30
  pdhandle->DPM_RDOPositionPrevious = pdhandle->DPM_RDOPosition;
 80065dc:	6423      	str	r3, [r4, #64]	; 0x40
  *PtrPowerObject = pdo.GenericPDO.PowerObject;
 80065de:	9b01      	ldr	r3, [sp, #4]
 80065e0:	701a      	strb	r2, [r3, #0]
}
 80065e2:	b005      	add	sp, #20
 80065e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80065e6:	46c0      	nop			; (mov r8, r8)
 80065e8:	200002c4 	.word	0x200002c4

080065ec <USBPD_DPM_ExtendedMessageReceived>:
}
 80065ec:	4770      	bx	lr

080065ee <USBPD_DPM_EnterErrorRecovery>:
{
 80065ee:	b510      	push	{r4, lr}
 80065f0:	0004      	movs	r4, r0
  DPM_TurnOffPower(PortNum, DPM_Params[PortNum].PE_PowerRole);
 80065f2:	f7ff fd71 	bl	80060d8 <DPM_TurnOffPower.isra.0>
  USBPD_CAD_EnterErrorRecovery(PortNum);
 80065f6:	0020      	movs	r0, r4
 80065f8:	f7f9 fe2c 	bl	8000254 <USBPD_CAD_EnterErrorRecovery>
}
 80065fc:	bd10      	pop	{r4, pc}
	...

08006600 <USBPD_DPM_EvaluateDataRoleSwap>:
  if (USBPD_TRUE == DPM_USER_Settings[PortNum].PE_DataSwap)
 8006600:	2238      	movs	r2, #56	; 0x38
 8006602:	4342      	muls	r2, r0
 8006604:	4b06      	ldr	r3, [pc, #24]	; (8006620 <USBPD_DPM_EvaluateDataRoleSwap+0x20>)
{
 8006606:	b510      	push	{r4, lr}
  if (USBPD_TRUE == DPM_USER_Settings[PortNum].PE_DataSwap)
 8006608:	189b      	adds	r3, r3, r2
 800660a:	3330      	adds	r3, #48	; 0x30
 800660c:	789a      	ldrb	r2, [r3, #2]
  USBPD_StatusTypeDef status = USBPD_REJECT;
 800660e:	230c      	movs	r3, #12
  if (USBPD_TRUE == DPM_USER_Settings[PortNum].PE_DataSwap)
 8006610:	07d2      	lsls	r2, r2, #31
 8006612:	d502      	bpl.n	800661a <USBPD_DPM_EvaluateDataRoleSwap+0x1a>
    STUSB16xx_HW_IF_DataRoleSwap(PortNum);
 8006614:	f005 f8fe 	bl	800b814 <STUSB16xx_HW_IF_DataRoleSwap>
    status = USBPD_ACCEPT;
 8006618:	230a      	movs	r3, #10
}
 800661a:	0018      	movs	r0, r3
 800661c:	bd10      	pop	{r4, pc}
 800661e:	46c0      	nop			; (mov r8, r8)
 8006620:	0800cdf8 	.word	0x0800cdf8

08006624 <USBPD_DPM_IsPowerReady>:
{
 8006624:	b510      	push	{r4, lr}
  return ((USBPD_OK == USBPD_PWR_IF_SupplyReady(PortNum, Vsafe)) ? USBPD_ENABLE : USBPD_DISABLE);
 8006626:	f000 f905 	bl	8006834 <USBPD_PWR_IF_SupplyReady>
 800662a:	4243      	negs	r3, r0
 800662c:	4158      	adcs	r0, r3
 800662e:	b2c0      	uxtb	r0, r0
}
 8006630:	bd10      	pop	{r4, pc}

08006632 <USBPD_DPM_RequestGetSourceCapabilityExt>:
{
 8006632:	b510      	push	{r4, lr}
  return USBPD_PE_Request_CtrlMessage(PortNum, USBPD_CONTROLMSG_GET_SRC_CAPEXT, USBPD_SOPTYPE_SOP);
 8006634:	2200      	movs	r2, #0
 8006636:	2111      	movs	r1, #17
 8006638:	f7fc fe12 	bl	8003260 <USBPD_PE_Request_CtrlMessage>
}
 800663c:	bd10      	pop	{r4, pc}
	...

08006640 <USBPD_DPM_UserExecute>:
{
 8006640:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint32_t _timing = osWaitForever;
 8006642:	2201      	movs	r2, #1
    switch (((DPM_USER_EVENT)event.value.v & 0xF))
 8006644:	250f      	movs	r5, #15
  osMessageQId  queue = *(osMessageQId *)argument;
 8006646:	6804      	ldr	r4, [r0, #0]
  uint32_t _timing = osWaitForever;
 8006648:	4252      	negs	r2, r2
    osEvent event = osMessageGet(queue, _timing);
 800664a:	a801      	add	r0, sp, #4
 800664c:	0021      	movs	r1, r4
 800664e:	f005 fa15 	bl	800ba7c <osMessageGet>
    switch (((DPM_USER_EVENT)event.value.v & 0xF))
 8006652:	9802      	ldr	r0, [sp, #8]
 8006654:	4e09      	ldr	r6, [pc, #36]	; (800667c <USBPD_DPM_UserExecute+0x3c>)
 8006656:	4028      	ands	r0, r5
 8006658:	d109      	bne.n	800666e <USBPD_DPM_UserExecute+0x2e>
      if (DPM_TIMER_ENABLE_MSK == DPM_Ports[USBPD_PORT_0].DPM_TimerSRCExtendedCapa)
 800665a:	0033      	movs	r3, r6
 800665c:	2280      	movs	r2, #128	; 0x80
 800665e:	335a      	adds	r3, #90	; 0x5a
 8006660:	8819      	ldrh	r1, [r3, #0]
 8006662:	0212      	lsls	r2, r2, #8
 8006664:	4291      	cmp	r1, r2
 8006666:	d102      	bne.n	800666e <USBPD_DPM_UserExecute+0x2e>
        DPM_Ports[USBPD_PORT_0].DPM_TimerSRCExtendedCapa = 0;
 8006668:	8018      	strh	r0, [r3, #0]
        USBPD_DPM_RequestGetSourceCapabilityExt(USBPD_PORT_0);
 800666a:	f7ff ffe2 	bl	8006632 <USBPD_DPM_RequestGetSourceCapabilityExt>
{
  uint32_t _timing = osWaitForever;
  uint32_t _current_timing;

  /* Calculate the minimum timers to wake-up DPM tasks */
  _current_timing = DPM_Ports[USBPD_PORT_0].DPM_TimerSRCExtendedCapa & DPM_TIMER_READ_MSK;
 800666e:	365a      	adds	r6, #90	; 0x5a
 8006670:	8832      	ldrh	r2, [r6, #0]
 8006672:	0452      	lsls	r2, r2, #17
 8006674:	0c52      	lsrs	r2, r2, #17
  if(_current_timing > 0)
 8006676:	d1e8      	bne.n	800664a <USBPD_DPM_UserExecute+0xa>
  uint32_t _timing = osWaitForever;
 8006678:	3a01      	subs	r2, #1
  do{
 800667a:	e7e6      	b.n	800664a <USBPD_DPM_UserExecute+0xa>
 800667c:	200002c4 	.word	0x200002c4

08006680 <HAL_GPIO_EXTI_Callback>:
{
 8006680:	b510      	push	{r4, lr}
  USBPD_HW_IF_EXTI_Callback(GPIO_Pin);
 8006682:	f003 f94b 	bl	800991c <USBPD_HW_IF_EXTI_Callback>
}
 8006686:	bd10      	pop	{r4, pc}

08006688 <USBPD_PWR_IF_Init>:
{

  /* Set links to PDO values and number for Port 0 (defined in PDO arrays in H file).
   */
#if (PORT0_NB_SOURCEPDO > 0)
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.ListOfPDO = (uint32_t *) PORT0_PDO_ListSRC;
 8006688:	4b03      	ldr	r3, [pc, #12]	; (8006698 <USBPD_PWR_IF_Init+0x10>)
 800668a:	4a04      	ldr	r2, [pc, #16]	; (800669c <USBPD_PWR_IF_Init+0x14>)
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.NumberOfPDO = PORT0_NB_SOURCEPDO;
#endif


  return USBPD_OK;
}
 800668c:	2000      	movs	r0, #0
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.ListOfPDO = (uint32_t *) PORT0_PDO_ListSRC;
 800668e:	601a      	str	r2, [r3, #0]
  PWR_Port_PDO_Storage[USBPD_PORT_0].SourcePDO.NumberOfPDO = PORT0_NB_SOURCEPDO;
 8006690:	2205      	movs	r2, #5
 8006692:	711a      	strb	r2, [r3, #4]
}
 8006694:	4770      	bx	lr
 8006696:	46c0      	nop			; (mov r8, r8)
 8006698:	20001a48 	.word	0x20001a48
 800669c:	0800cd04 	.word	0x0800cd04

080066a0 <USBPD_PWR_IF_SetProfile>:
  * @param  PreviousPowerProfile  Number of the previous required Power Data Objects
  * @retval USBPD status
  */
USBPD_StatusTypeDef USBPD_PWR_IF_SetProfile(uint8_t PortNum, uint8_t Profile, uint8_t PreviousPowerProfile)
{
	set_PortNum=PortNum;
 80066a0:	4b5f      	ldr	r3, [pc, #380]	; (8006820 <USBPD_PWR_IF_SetProfile+0x180>)
{
 80066a2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	set_PortNum=PortNum;
 80066a4:	7018      	strb	r0, [r3, #0]
	set_profile=Profile;
 80066a6:	7059      	strb	r1, [r3, #1]
	old_profile=PreviousPowerProfile;
 80066a8:	709a      	strb	r2, [r3, #2]
  uint32_t timeout_end;
#endif /* (PORT0_NB_SOURCEPDO >= 2)|| (PORT0_NB_SOURCEAPDO > 0) */
  USBPD_StatusTypeDef      ret = USBPD_ERROR;

  /* Check if valid port */
  if ( !USBPD_PORT_IsValid(PortNum) )
 80066aa:	2800      	cmp	r0, #0
 80066ac:	d159      	bne.n	8006762 <USBPD_PWR_IF_SetProfile+0xc2>
  }

#if (PORT0_NB_SOURCEPDO >= 2)|| (PORT0_NB_SOURCEAPDO > 0)
  /* Check if profile nb is valid for this port */
  /* SRC Mode */
  if (USBPD_PORTPOWERROLE_SRC == DPM_Params[PortNum].PE_PowerRole)
 80066ae:	4a5d      	ldr	r2, [pc, #372]	; (8006824 <USBPD_PWR_IF_SetProfile+0x184>)
 80066b0:	7812      	ldrb	r2, [r2, #0]
 80066b2:	0752      	lsls	r2, r2, #29
 80066b4:	d555      	bpl.n	8006762 <USBPD_PWR_IF_SetProfile+0xc2>
  {
    if (Profile >= PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO)
 80066b6:	4a5c      	ldr	r2, [pc, #368]	; (8006828 <USBPD_PWR_IF_SetProfile+0x188>)
 80066b8:	7910      	ldrb	r0, [r2, #4]
 80066ba:	4288      	cmp	r0, r1
 80066bc:	d951      	bls.n	8006762 <USBPD_PWR_IF_SetProfile+0xc2>
    {
      return ret;
    }
    if (0 == PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO)
 80066be:	2800      	cmp	r0, #0
 80066c0:	d04f      	beq.n	8006762 <USBPD_PWR_IF_SetProfile+0xc2>
    {
      return ret;
    }
    pdo.d32 = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO[Profile];
 80066c2:	6812      	ldr	r2, [r2, #0]
 80066c4:	0089      	lsls	r1, r1, #2
 80066c6:	588d      	ldr	r5, [r1, r2]

    {
      /* Case PDO is a fixed type */
      if (pdo.GenericPDO.PowerObject == USBPD_PDO_TYPE_FIXED)
 80066c8:	223f      	movs	r2, #63	; 0x3f
 80066ca:	0e28      	lsrs	r0, r5, #24
 80066cc:	4390      	bics	r0, r2
 80066ce:	d148      	bne.n	8006762 <USBPD_PWR_IF_SetProfile+0xc2>
      {
        vbusTargetInmv = (pdo.SRCFixedPDO.VoltageIn50mVunits * 50);
 80066d0:	032d      	lsls	r5, r5, #12
 80066d2:	3a0d      	subs	r2, #13
 80066d4:	0dad      	lsrs	r5, r5, #22
 80066d6:	4355      	muls	r5, r2
        bus_target = vbusTargetInmv;
        HW_IF_PWR_SetVoltage(PortNum, vbusTargetInmv);
 80066d8:	b2af      	uxth	r7, r5
 80066da:	0039      	movs	r1, r7
        bus_target = vbusTargetInmv;
 80066dc:	605d      	str	r5, [r3, #4]
        HW_IF_PWR_SetVoltage(PortNum, vbusTargetInmv);
 80066de:	f004 f87d 	bl	800a7dc <HW_IF_PWR_SetVoltage>

       //----------------------------------------------------------
        /* Get Start Tick*/
        timeout_end = timeout;
        timeout = HAL_GetTick();
 80066e2:	f000 fd1d 	bl	8007120 <HAL_GetTick>
 80066e6:	9001      	str	r0, [sp, #4]
        /* Initialize timeout value depending on the PDO */
        while  (((  HW_IF_PWR_GetVoltage_from_reg(PortNum)) != vbusTargetInmv))
 80066e8:	2000      	movs	r0, #0
 80066ea:	f004 f8ed 	bl	800a8c8 <HW_IF_PWR_GetVoltage_from_reg>
 80066ee:	0006      	movs	r6, r0
 80066f0:	42a8      	cmp	r0, r5
 80066f2:	d12d      	bne.n	8006750 <USBPD_PWR_IF_SetProfile+0xb0>
  * @retval USBPD_ENABLE or USBPD_DISABLE
  */
USBPD_FunctionalState USBPD_PWR_IF_VBUSIsEnabled(uint8_t PortNum)
{
  /* Get the Status of the port */
  return USBPD_PORT_IsValid(PortNum) ? (USBPD_FunctionalState)HW_IF_PWR_VBUSIsEnabled(PortNum) : USBPD_DISABLE;
 80066f4:	2000      	movs	r0, #0
 80066f6:	f004 f90b 	bl	800a910 <HW_IF_PWR_VBUSIsEnabled>
    if (USBPD_ENABLE == USBPD_PWR_IF_VBUSIsEnabled(PortNum)) // HW_IF_PWR_IsEnabled(PortNum))
 80066fa:	2801      	cmp	r0, #1
 80066fc:	d000      	beq.n	8006700 <USBPD_PWR_IF_SetProfile+0x60>
 80066fe:	e082      	b.n	8006806 <USBPD_PWR_IF_SetProfile+0x166>
      origine = (uint32_t) HW_IF_PWR_GetVoltage_from_reg(PortNum); /* store setting of previous step*/
 8006700:	2000      	movs	r0, #0
 8006702:	f004 f8e1 	bl	800a8c8 <HW_IF_PWR_GetVoltage_from_reg>
 8006706:	0004      	movs	r4, r0
      if (origine != vbusTargetInmv)
 8006708:	4285      	cmp	r5, r0
 800670a:	d02a      	beq.n	8006762 <USBPD_PWR_IF_SetProfile+0xc2>
        if (vbusTargetInmv > origine)
 800670c:	d92b      	bls.n	8006766 <USBPD_PWR_IF_SetProfile+0xc6>
          delta_val = vbusTargetInmv - origine;
 800670e:	1a2d      	subs	r5, r5, r0
        if ( (delta_val > 100) && (pos == 1) )
 8006710:	2d64      	cmp	r5, #100	; 0x64
 8006712:	d92b      	bls.n	800676c <USBPD_PWR_IF_SetProfile+0xcc>
            max = (110 * new_val)/100 ;
 8006714:	206e      	movs	r0, #110	; 0x6e
            new_val = new_val + step;
 8006716:	3464      	adds	r4, #100	; 0x64
            max = (110 * new_val)/100 ;
 8006718:	2164      	movs	r1, #100	; 0x64
 800671a:	4360      	muls	r0, r4
 800671c:	f7ff f954 	bl	80059c8 <__udivsi3>
 8006720:	0007      	movs	r7, r0
            min = (90 * new_val)/100 ;
 8006722:	205a      	movs	r0, #90	; 0x5a
 8006724:	2164      	movs	r1, #100	; 0x64
 8006726:	4360      	muls	r0, r4
 8006728:	f7ff f94e 	bl	80059c8 <__udivsi3>
            HW_IF_PWR_SetVoltage(PortNum, new_val);
 800672c:	b2a1      	uxth	r1, r4
            min = (90 * new_val)/100 ;
 800672e:	0005      	movs	r5, r0
            HW_IF_PWR_SetVoltage(PortNum, new_val);
 8006730:	2000      	movs	r0, #0
 8006732:	f004 f853 	bl	800a7dc <HW_IF_PWR_SetVoltage>
            while  (((  HW_IF_PWR_GetVoltage(PortNum)) > max ) || ((  HW_IF_PWR_GetVoltage(PortNum)) < min ))            
 8006736:	2000      	movs	r0, #0
 8006738:	f004 f8ba 	bl	800a8b0 <HW_IF_PWR_GetVoltage>
 800673c:	42b8      	cmp	r0, r7
 800673e:	d82c      	bhi.n	800679a <USBPD_PWR_IF_SetProfile+0xfa>
 8006740:	2000      	movs	r0, #0
 8006742:	f004 f8b5 	bl	800a8b0 <HW_IF_PWR_GetVoltage>
 8006746:	42a8      	cmp	r0, r5
 8006748:	d327      	bcc.n	800679a <USBPD_PWR_IF_SetProfile+0xfa>
          } while ( new_val < vbusTargetInmv);
 800674a:	42a6      	cmp	r6, r4
 800674c:	d8e2      	bhi.n	8006714 <USBPD_PWR_IF_SetProfile+0x74>
 800674e:	e008      	b.n	8006762 <USBPD_PWR_IF_SetProfile+0xc2>
          osDelay(1);
 8006750:	2001      	movs	r0, #1
 8006752:	f005 f95e 	bl	800ba12 <osDelay>
          if ((HAL_GetTick() - timeout) > timeout_end)
 8006756:	f000 fce3 	bl	8007120 <HAL_GetTick>
 800675a:	9b01      	ldr	r3, [sp, #4]
 800675c:	1ac0      	subs	r0, r0, r3
 800675e:	28fa      	cmp	r0, #250	; 0xfa
 8006760:	d9c2      	bls.n	80066e8 <USBPD_PWR_IF_SetProfile+0x48>
}
 8006762:	2002      	movs	r0, #2
 8006764:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
          delta_val = origine - vbusTargetInmv;
 8006766:	1b45      	subs	r5, r0, r5
        if ( (delta_val > 100) && (pos == 1) )
 8006768:	2d64      	cmp	r5, #100	; 0x64
 800676a:	d818      	bhi.n	800679e <USBPD_PWR_IF_SetProfile+0xfe>
          HW_IF_PWR_SetVoltage(PortNum, vbusTargetInmv);
 800676c:	0039      	movs	r1, r7
 800676e:	2000      	movs	r0, #0
 8006770:	f004 f834 	bl	800a7dc <HW_IF_PWR_SetVoltage>
          HW_IF_PWR_GetVoltage_from_reg(PortNum);
 8006774:	2000      	movs	r0, #0
 8006776:	f004 f8a7 	bl	800a8c8 <HW_IF_PWR_GetVoltage_from_reg>
          vbusmin = 90* vbusTargetInmv /100;
 800677a:	205a      	movs	r0, #90	; 0x5a
 800677c:	2164      	movs	r1, #100	; 0x64
 800677e:	4370      	muls	r0, r6
 8006780:	f7ff f922 	bl	80059c8 <__udivsi3>
 8006784:	0004      	movs	r4, r0
          vbusmax = 110* vbusTargetInmv / 100;
 8006786:	206e      	movs	r0, #110	; 0x6e
 8006788:	2164      	movs	r1, #100	; 0x64
 800678a:	4370      	muls	r0, r6
 800678c:	f7ff f91c 	bl	80059c8 <__udivsi3>
 8006790:	0006      	movs	r6, r0
          timeout = HAL_GetTick();
 8006792:	f000 fcc5 	bl	8007120 <HAL_GetTick>
 8006796:	0005      	movs	r5, r0
          while  (((  HW_IF_PWR_GetVoltage_from_reg(PortNum)  ) > vbusmax) || ((  HW_IF_PWR_GetVoltage_from_reg(PortNum) ) < vbusmin))
 8006798:	e02a      	b.n	80067f0 <USBPD_PWR_IF_SetProfile+0x150>
 800679a:	46c0      	nop			; (mov r8, r8)
 800679c:	e7cb      	b.n	8006736 <USBPD_PWR_IF_SetProfile+0x96>
              max = (110 * new_val)/100 ;
 800679e:	206e      	movs	r0, #110	; 0x6e
              new_val = new_val - step;
 80067a0:	3c64      	subs	r4, #100	; 0x64
              max = (110 * new_val)/100 ;
 80067a2:	2164      	movs	r1, #100	; 0x64
 80067a4:	4360      	muls	r0, r4
 80067a6:	f7ff f90f 	bl	80059c8 <__udivsi3>
 80067aa:	0007      	movs	r7, r0
              min = (90 * new_val)/100 ;
 80067ac:	205a      	movs	r0, #90	; 0x5a
 80067ae:	2164      	movs	r1, #100	; 0x64
 80067b0:	4360      	muls	r0, r4
 80067b2:	f7ff f909 	bl	80059c8 <__udivsi3>
              HW_IF_PWR_SetVoltage(PortNum, new_val);
 80067b6:	b2a1      	uxth	r1, r4
              min = (90 * new_val)/100 ;
 80067b8:	0005      	movs	r5, r0
              HW_IF_PWR_SetVoltage(PortNum, new_val);
 80067ba:	2000      	movs	r0, #0
 80067bc:	f004 f80e 	bl	800a7dc <HW_IF_PWR_SetVoltage>
              while  (((  HW_IF_PWR_GetVoltage(PortNum)  ) > max ) || ((  HW_IF_PWR_GetVoltage(PortNum)) < min ))
 80067c0:	2000      	movs	r0, #0
 80067c2:	f004 f875 	bl	800a8b0 <HW_IF_PWR_GetVoltage>
 80067c6:	42b8      	cmp	r0, r7
 80067c8:	d807      	bhi.n	80067da <USBPD_PWR_IF_SetProfile+0x13a>
 80067ca:	2000      	movs	r0, #0
 80067cc:	f004 f870 	bl	800a8b0 <HW_IF_PWR_GetVoltage>
 80067d0:	42a8      	cmp	r0, r5
 80067d2:	d302      	bcc.n	80067da <USBPD_PWR_IF_SetProfile+0x13a>
            } while ( new_val > vbusTargetInmv);
 80067d4:	42a6      	cmp	r6, r4
 80067d6:	d3e2      	bcc.n	800679e <USBPD_PWR_IF_SetProfile+0xfe>
 80067d8:	e7c3      	b.n	8006762 <USBPD_PWR_IF_SetProfile+0xc2>
 80067da:	46c0      	nop			; (mov r8, r8)
 80067dc:	e7f0      	b.n	80067c0 <USBPD_PWR_IF_SetProfile+0x120>
            osDelay(1);
 80067de:	2001      	movs	r0, #1
 80067e0:	f005 f917 	bl	800ba12 <osDelay>
            if ((HAL_GetTick() - timeout) > timeout_end)
 80067e4:	f000 fc9c 	bl	8007120 <HAL_GetTick>
 80067e8:	9b01      	ldr	r3, [sp, #4]
 80067ea:	1b40      	subs	r0, r0, r5
 80067ec:	4298      	cmp	r0, r3
 80067ee:	d8b8      	bhi.n	8006762 <USBPD_PWR_IF_SetProfile+0xc2>
          while  (((  HW_IF_PWR_GetVoltage_from_reg(PortNum)  ) > vbusmax) || ((  HW_IF_PWR_GetVoltage_from_reg(PortNum) ) < vbusmin))
 80067f0:	2000      	movs	r0, #0
 80067f2:	f004 f869 	bl	800a8c8 <HW_IF_PWR_GetVoltage_from_reg>
 80067f6:	42b0      	cmp	r0, r6
 80067f8:	d8f1      	bhi.n	80067de <USBPD_PWR_IF_SetProfile+0x13e>
 80067fa:	2000      	movs	r0, #0
 80067fc:	f004 f864 	bl	800a8c8 <HW_IF_PWR_GetVoltage_from_reg>
 8006800:	42a0      	cmp	r0, r4
 8006802:	d3ec      	bcc.n	80067de <USBPD_PWR_IF_SetProfile+0x13e>
 8006804:	e7ad      	b.n	8006762 <USBPD_PWR_IF_SetProfile+0xc2>
      HW_IF_PWR_SetVoltage(PortNum, 5000);
 8006806:	4909      	ldr	r1, [pc, #36]	; (800682c <USBPD_PWR_IF_SetProfile+0x18c>)
 8006808:	2000      	movs	r0, #0
 800680a:	f003 ffe7 	bl	800a7dc <HW_IF_PWR_SetVoltage>
      HW_IF_PWR_GetVoltage(PortNum);
 800680e:	2000      	movs	r0, #0
 8006810:	f004 f84e 	bl	800a8b0 <HW_IF_PWR_GetVoltage>
      HW_IF_PWR_SetVoltage(PortNum, 5000);
 8006814:	4905      	ldr	r1, [pc, #20]	; (800682c <USBPD_PWR_IF_SetProfile+0x18c>)
 8006816:	2000      	movs	r0, #0
 8006818:	f003 ffe0 	bl	800a7dc <HW_IF_PWR_SetVoltage>
 800681c:	e7a1      	b.n	8006762 <USBPD_PWR_IF_SetProfile+0xc2>
 800681e:	46c0      	nop			; (mov r8, r8)
 8006820:	2000033c 	.word	0x2000033c
 8006824:	20001c60 	.word	0x20001c60
 8006828:	20001a48 	.word	0x20001a48
 800682c:	00001388 	.word	0x00001388

08006830 <USBPD_PWR_IF_PowerResetGlobal>:
}
 8006830:	2000      	movs	r0, #0
 8006832:	4770      	bx	lr

08006834 <USBPD_PWR_IF_SupplyReady>:
{
 8006834:	b510      	push	{r4, lr}
  if (!USBPD_PORT_IsValid(PortNum))
 8006836:	2800      	cmp	r0, #0
 8006838:	d10f      	bne.n	800685a <USBPD_PWR_IF_SupplyReady+0x26>
  if (USBPD_VSAFE_0V == Vsafe)
 800683a:	2900      	cmp	r1, #0
 800683c:	d107      	bne.n	800684e <USBPD_PWR_IF_SupplyReady+0x1a>
    status = (HW_IF_PWR_GetVoltage(PortNum) < CAD_threshold_VBus? USBPD_OK: USBPD_ERROR);
 800683e:	0008      	movs	r0, r1
 8006840:	f004 f836 	bl	800a8b0 <HW_IF_PWR_GetVoltage>
 8006844:	4b06      	ldr	r3, [pc, #24]	; (8006860 <USBPD_PWR_IF_SupplyReady+0x2c>)
 8006846:	4298      	cmp	r0, r3
 8006848:	d807      	bhi.n	800685a <USBPD_PWR_IF_SupplyReady+0x26>
 800684a:	2000      	movs	r0, #0
}
 800684c:	bd10      	pop	{r4, pc}
    status = (HW_IF_PWR_GetVoltage(PortNum) > CAD_threshold_VBus? USBPD_OK: USBPD_ERROR);
 800684e:	f004 f82f 	bl	800a8b0 <HW_IF_PWR_GetVoltage>
 8006852:	239b      	movs	r3, #155	; 0x9b
 8006854:	009b      	lsls	r3, r3, #2
 8006856:	4298      	cmp	r0, r3
 8006858:	d8f7      	bhi.n	800684a <USBPD_PWR_IF_SupplyReady+0x16>
    status = (HW_IF_PWR_GetVoltage(PortNum) < CAD_threshold_VBus? USBPD_OK: USBPD_ERROR);
 800685a:	2002      	movs	r0, #2
 800685c:	e7f6      	b.n	800684c <USBPD_PWR_IF_SupplyReady+0x18>
 800685e:	46c0      	nop			; (mov r8, r8)
 8006860:	0000026b 	.word	0x0000026b

08006864 <USBPD_PWR_IF_VBUSEnable>:
{
 8006864:	b507      	push	{r0, r1, r2, lr}
  USBPD_StatusTypeDef _status = USBPD_ERROR;
 8006866:	2302      	movs	r3, #2
  if (USBPD_PORT_IsValid(PortNum))
 8006868:	2800      	cmp	r0, #0
 800686a:	d10a      	bne.n	8006882 <USBPD_PWR_IF_VBUSEnable+0x1e>
    _status = (USBPD_StatusTypeDef)HW_IF_PWR_Enable(PortNum, USBPD_ENABLE, DPM_Params[PortNum].VconnCCIs, DPM_Params[PortNum].VconnStatus, USBPD_PORTPOWERROLE_SRC);
 800686c:	2101      	movs	r1, #1
 800686e:	4b06      	ldr	r3, [pc, #24]	; (8006888 <USBPD_PWR_IF_VBUSEnable+0x24>)
 8006870:	789a      	ldrb	r2, [r3, #2]
 8006872:	9100      	str	r1, [sp, #0]
 8006874:	0753      	lsls	r3, r2, #29
 8006876:	0792      	lsls	r2, r2, #30
 8006878:	0fdb      	lsrs	r3, r3, #31
 800687a:	0f92      	lsrs	r2, r2, #30
 800687c:	f004 f82c 	bl	800a8d8 <HW_IF_PWR_Enable>
 8006880:	0003      	movs	r3, r0
}
 8006882:	0018      	movs	r0, r3
 8006884:	bd0e      	pop	{r1, r2, r3, pc}
 8006886:	46c0      	nop			; (mov r8, r8)
 8006888:	20001c60 	.word	0x20001c60

0800688c <USBPD_PWR_IF_VBUSDisable>:
{
 800688c:	b507      	push	{r0, r1, r2, lr}
  USBPD_StatusTypeDef _status = USBPD_ERROR;
 800688e:	2302      	movs	r3, #2
  if (USBPD_PORT_IsValid(PortNum))
 8006890:	2800      	cmp	r0, #0
 8006892:	d10b      	bne.n	80068ac <USBPD_PWR_IF_VBUSDisable+0x20>
    _status = (USBPD_StatusTypeDef)HW_IF_PWR_Enable(PortNum, USBPD_DISABLE, DPM_Params[PortNum].VconnCCIs, DPM_Params[PortNum].VconnStatus, USBPD_PORTPOWERROLE_SRC);
 8006894:	2101      	movs	r1, #1
 8006896:	4b06      	ldr	r3, [pc, #24]	; (80068b0 <USBPD_PWR_IF_VBUSDisable+0x24>)
 8006898:	789a      	ldrb	r2, [r3, #2]
 800689a:	9100      	str	r1, [sp, #0]
 800689c:	0753      	lsls	r3, r2, #29
 800689e:	0792      	lsls	r2, r2, #30
 80068a0:	0fdb      	lsrs	r3, r3, #31
 80068a2:	0f92      	lsrs	r2, r2, #30
 80068a4:	0001      	movs	r1, r0
 80068a6:	f004 f817 	bl	800a8d8 <HW_IF_PWR_Enable>
 80068aa:	0003      	movs	r3, r0
}
 80068ac:	0018      	movs	r0, r3
 80068ae:	bd0e      	pop	{r1, r2, r3, pc}
 80068b0:	20001c60 	.word	0x20001c60

080068b4 <USBPD_PWR_IF_GetPortPDOs>:
  * @param  Ptr Pointer on address where PDO values should be written (u32 pointer)
  * @param  Size Pointer on nb of u32 written by PWR_IF (nb of PDOs)
  * @retval None
  */
void USBPD_PWR_IF_GetPortPDOs(uint8_t PortNum, USBPD_CORE_DataInfoType_TypeDef DataId, uint32_t *Ptr, uint32_t *Size)
{
 80068b4:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t   nbpdo, index, nb_valid_pdo = 0;
  uint32_t   *ptpdoarray = NULL;

  /* Check if valid port */
  if (USBPD_PORT_IsValid(PortNum))
 80068b6:	2800      	cmp	r0, #0
 80068b8:	d10a      	bne.n	80068d0 <USBPD_PWR_IF_GetPortPDOs+0x1c>
    case USBPD_CORE_DATATYPE_SRC_PDO:
      nbpdo       = PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO;
      ptpdoarray  = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO;
      break;
    default:
      nbpdo = 0;
 80068ba:	0006      	movs	r6, r0
    switch (DataId)
 80068bc:	2900      	cmp	r1, #0
 80068be:	d102      	bne.n	80068c6 <USBPD_PWR_IF_GetPortPDOs+0x12>
      nbpdo       = PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO;
 80068c0:	4909      	ldr	r1, [pc, #36]	; (80068e8 <USBPD_PWR_IF_GetPortPDOs+0x34>)
 80068c2:	790e      	ldrb	r6, [r1, #4]
      ptpdoarray  = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO;
 80068c4:	6808      	ldr	r0, [r1, #0]
 80068c6:	00b4      	lsls	r4, r6, #2
 80068c8:	1904      	adds	r4, r0, r4
      break;
    }

    /* Copy PDO data in output buffer */
    for (index = 0; index < nbpdo; index++)
 80068ca:	42a0      	cmp	r0, r4
 80068cc:	d101      	bne.n	80068d2 <USBPD_PWR_IF_GetPortPDOs+0x1e>
        nb_valid_pdo++;
      }
      ptpdoarray++;
    }
    /* Set nb of read PDO (nb of u32 elements); */
    *Size = nb_valid_pdo;
 80068ce:	601e      	str	r6, [r3, #0]
  }
}
 80068d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80068d2:	2100      	movs	r1, #0
        USPBPD_WRITE32((uint32_t *)(Ptr + nb_valid_pdo), *ptpdoarray);
 80068d4:	6807      	ldr	r7, [r0, #0]
 80068d6:	00cd      	lsls	r5, r1, #3
 80068d8:	40ef      	lsrs	r7, r5
 80068da:	5457      	strb	r7, [r2, r1]
 80068dc:	3101      	adds	r1, #1
 80068de:	2904      	cmp	r1, #4
 80068e0:	d1f8      	bne.n	80068d4 <USBPD_PWR_IF_GetPortPDOs+0x20>
      ptpdoarray++;
 80068e2:	3004      	adds	r0, #4
 80068e4:	3204      	adds	r2, #4
 80068e6:	e7f0      	b.n	80068ca <USBPD_PWR_IF_GetPortPDOs+0x16>
 80068e8:	20001a48 	.word	0x20001a48

080068ec <USBPD_PWR_IF_SearchRequestedPDO>:
  * @retval Status of search
  *         USBPD_OK : Src PDO found for requested DO position (output Pdo parameter is set)
  *         USBPD_FAIL : Position is not compliant with current Src PDO for this port (no corresponding PDO value)
  */
USBPD_StatusTypeDef USBPD_PWR_IF_SearchRequestedPDO(uint8_t PortNum, uint32_t RdoPosition, uint32_t *Pdo)
{
 80068ec:	0003      	movs	r3, r0
 80068ee:	b530      	push	{r4, r5, lr}
  if((RdoPosition == 0) || (RdoPosition > PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO))
  {
    /* Invalid PDO index */
    return USBPD_FAIL;
 80068f0:	2010      	movs	r0, #16
  if((RdoPosition == 0) || (RdoPosition > PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO))
 80068f2:	2900      	cmp	r1, #0
 80068f4:	d00d      	beq.n	8006912 <USBPD_PWR_IF_SearchRequestedPDO+0x26>
 80068f6:	4c07      	ldr	r4, [pc, #28]	; (8006914 <USBPD_PWR_IF_SearchRequestedPDO+0x28>)
 80068f8:	00db      	lsls	r3, r3, #3
 80068fa:	18e0      	adds	r0, r4, r3
 80068fc:	7905      	ldrb	r5, [r0, #4]
    return USBPD_FAIL;
 80068fe:	2010      	movs	r0, #16
  if((RdoPosition == 0) || (RdoPosition > PWR_Port_PDO_Storage[PortNum].SourcePDO.NumberOfPDO))
 8006900:	428d      	cmp	r5, r1
 8006902:	d306      	bcc.n	8006912 <USBPD_PWR_IF_SearchRequestedPDO+0x26>
  }

  *Pdo = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO[RdoPosition - 1];
 8006904:	4804      	ldr	r0, [pc, #16]	; (8006918 <USBPD_PWR_IF_SearchRequestedPDO+0x2c>)
 8006906:	591b      	ldr	r3, [r3, r4]
 8006908:	1809      	adds	r1, r1, r0
  return USBPD_OK;
 800690a:	2000      	movs	r0, #0
  *Pdo = PWR_Port_PDO_Storage[PortNum].SourcePDO.ListOfPDO[RdoPosition - 1];
 800690c:	0089      	lsls	r1, r1, #2
 800690e:	58cb      	ldr	r3, [r1, r3]
 8006910:	6013      	str	r3, [r2, #0]
}
 8006912:	bd30      	pop	{r4, r5, pc}
 8006914:	20001a48 	.word	0x20001a48
 8006918:	3fffffff 	.word	0x3fffffff

0800691c <STUSB1602_Driver_Init>:
  * @param  PortNum     Port number value
  * @param  I2CxHandle  External I2C handle
  * @retval None
  */
void STUSB1602_Driver_Init(uint8_t PortNum, I2C_HandleTypeDef I2CxHandle)
{
 800691c:	b084      	sub	sp, #16
 800691e:	b510      	push	{r4, lr}
 8006920:	9103      	str	r1, [sp, #12]
 8006922:	9204      	str	r2, [sp, #16]
 8006924:	9305      	str	r3, [sp, #20]
  if (0 == PortNum)
  {
    STUSB16xx_I2CxHandle = I2CxHandle;
 8006926:	224c      	movs	r2, #76	; 0x4c
 8006928:	a903      	add	r1, sp, #12
  if (0 == PortNum)
 800692a:	2800      	cmp	r0, #0
 800692c:	d106      	bne.n	800693c <STUSB1602_Driver_Init+0x20>
    STUSB16xx_I2CxHandle = I2CxHandle;
 800692e:	4804      	ldr	r0, [pc, #16]	; (8006940 <STUSB1602_Driver_Init+0x24>)
  }
  else
  {
    STUSB16xx_I2CxHandle_P1 = I2CxHandle;
 8006930:	f006 f934 	bl	800cb9c <memcpy>
  }
}
 8006934:	bc10      	pop	{r4}
 8006936:	bc08      	pop	{r3}
 8006938:	b004      	add	sp, #16
 800693a:	4718      	bx	r3
    STUSB16xx_I2CxHandle_P1 = I2CxHandle;
 800693c:	4801      	ldr	r0, [pc, #4]	; (8006944 <STUSB1602_Driver_Init+0x28>)
 800693e:	e7f7      	b.n	8006930 <STUSB1602_Driver_Init+0x14>
 8006940:	20001a50 	.word	0x20001a50
 8006944:	20001ba0 	.word	0x20001ba0

08006948 <STUSB1602_ReadReg>:
  * @param Reg          Address of first register to be read
  * @param Size         Amount of bytes to be read
  * @retval STUSB1602_StatusTypeDef Allowed values are STUSB1602_OK, STUSB1602_ERROR, STUSB1602_BUSY, STUSB1602_TIMEOUT
  */
STUSB1602_StatusTypeDef STUSB1602_ReadReg(uint8_t* pBuffer, uint8_t Addr, uint8_t Reg, uint16_t Size)
  {
 8006948:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if (Addr == 0x29)
    {
      return STUSB1602_OK;
    }
#endif
    status = (STUSB1602_StatusTypeDef) HAL_I2C_Mem_Read(&STUSB16xx_I2CxHandle, (Addr<<1), (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size, TIMEOUT_MAX);
 800694a:	24fa      	movs	r4, #250	; 0xfa
 800694c:	00e4      	lsls	r4, r4, #3
 800694e:	9301      	str	r3, [sp, #4]
 8006950:	9000      	str	r0, [sp, #0]
 8006952:	b292      	uxth	r2, r2
 8006954:	0049      	lsls	r1, r1, #1
 8006956:	9402      	str	r4, [sp, #8]
 8006958:	2301      	movs	r3, #1
 800695a:	4802      	ldr	r0, [pc, #8]	; (8006964 <STUSB1602_ReadReg+0x1c>)
 800695c:	f001 fb5a 	bl	8008014 <HAL_I2C_Mem_Read>
    return status;
  }
 8006960:	b004      	add	sp, #16
 8006962:	bd10      	pop	{r4, pc}
 8006964:	20001a50 	.word	0x20001a50

08006968 <STUSB1602_WriteReg>:
  * @param Reg          Address of first register to be write
  * @param Size         Amount of bytes to be write
  * @retval STUSB1602_StatusTypeDef Allowed values are STUSB1602_OK, STUSB1602_ERROR, STUSB1602_BUSY, STUSB1602_TIMEOUT
  */
STUSB1602_StatusTypeDef STUSB1602_WriteReg(uint8_t* pBuffer, uint8_t Addr, uint8_t Reg, uint16_t Size)
  {
 8006968:	b51f      	push	{r0, r1, r2, r3, r4, lr}
      return STUSB1602_OK;
    }
#endif
    STUSB1602_StatusTypeDef status = STUSB1602_OK;

    status = (STUSB1602_StatusTypeDef)HAL_I2C_Mem_Write(&STUSB16xx_I2CxHandle, (Addr<<1), (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Size,
 800696a:	24fa      	movs	r4, #250	; 0xfa
 800696c:	00e4      	lsls	r4, r4, #3
 800696e:	9301      	str	r3, [sp, #4]
 8006970:	9000      	str	r0, [sp, #0]
 8006972:	b292      	uxth	r2, r2
 8006974:	0049      	lsls	r1, r1, #1
 8006976:	9402      	str	r4, [sp, #8]
 8006978:	2301      	movs	r3, #1
 800697a:	4802      	ldr	r0, [pc, #8]	; (8006984 <STUSB1602_WriteReg+0x1c>)
 800697c:	f001 fa90 	bl	8007ea0 <HAL_I2C_Mem_Write>
                            TIMEOUT_MAX);
 
    return status;
  }
 8006980:	b004      	add	sp, #16
 8006982:	bd10      	pop	{r4, pc}
 8006984:	20001a50 	.word	0x20001a50

08006988 <STUSB1602_Alert_Monitoring_Get>:
  * @brief  Check registers from 0x0B to 0x12
  * @param  Addr I2C address of port controller device
  * @retval STUSB1602_ALERT_MONITORING_TypeDef 
  */ 
STUSB1602_ALERT_MONITORING_TypeDef STUSB1602_Alert_Monitoring_Get(uint8_t Addr)
{
 8006988:	b513      	push	{r0, r1, r4, lr}
 800698a:	0004      	movs	r4, r0
    STUSB1602_ALERT_MONITORING_TypeDef reg;

    STUSB1602_ReadReg(&reg.reg_0B.d8, Addr, STUSB1602_ALERT_STATUS_REG, 8); 
 800698c:	2308      	movs	r3, #8
 800698e:	220b      	movs	r2, #11
 8006990:	4668      	mov	r0, sp
 8006992:	f7ff ffd9 	bl	8006948 <STUSB1602_ReadReg>

    return (reg);
 8006996:	2208      	movs	r2, #8
 8006998:	4669      	mov	r1, sp
 800699a:	0020      	movs	r0, r4
 800699c:	f006 f8fe 	bl	800cb9c <memcpy>
}
 80069a0:	0020      	movs	r0, r4
 80069a2:	bd16      	pop	{r1, r2, r4, pc}

080069a4 <STUSB1602_CC_Detect_Alrt_Int_Mask_Set>:
  * @param  Addr I2C address of port controller device
  * @param  st Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */ 
STUSB1602_StatusTypeDef STUSB1602_CC_Detect_Alrt_Int_Mask_Set(uint8_t Addr, CC_Detect_Alrt_Int_Mask_Status_TypeDef st)
{
 80069a4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  

    STUSB1602_ALERT_STATUS_MASK_reg_TypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_ALERT_STATUS_MASK_REG, 1); 
 80069a6:	ac01      	add	r4, sp, #4
{
 80069a8:	0005      	movs	r5, r0
 80069aa:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_ALERT_STATUS_MASK_REG, 1); 
 80069ac:	2301      	movs	r3, #1
 80069ae:	0001      	movs	r1, r0
 80069b0:	220c      	movs	r2, #12
 80069b2:	0020      	movs	r0, r4
 80069b4:	f7ff ffc8 	bl	8006948 <STUSB1602_ReadReg>

    reg.b.CC_DETECTION_STATUS_AL_MASK = st;
 80069b8:	2301      	movs	r3, #1
 80069ba:	2240      	movs	r2, #64	; 0x40
 80069bc:	7821      	ldrb	r1, [r4, #0]
 80069be:	401e      	ands	r6, r3
 80069c0:	01b6      	lsls	r6, r6, #6
 80069c2:	4391      	bics	r1, r2
 80069c4:	4331      	orrs	r1, r6
 80069c6:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_ALERT_STATUS_MASK_REG, 1);
 80069c8:	3a34      	subs	r2, #52	; 0x34
 80069ca:	0029      	movs	r1, r5
 80069cc:	0020      	movs	r0, r4
 80069ce:	f7ff ffcb 	bl	8006968 <STUSB1602_WriteReg>

    return status;
}
 80069d2:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

080069d4 <STUSB1602_Attach_State_Trans_Get>:
  * @brief  STUSB1602 Checks Attach State Transition Reg (Bit0 0x0D -- RC)
  * @param  Addr I2C address of port controller device
  * @retval Attach_State_Trans_TypeDef 
  */ 
Attach_State_Trans_TypeDef STUSB1602_Attach_State_Trans_Get(uint8_t Addr)
{
 80069d4:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_DETECTION_STATUS_TRANS_RegTypeDef reg;

    /* Check if a Transition occurred on ATTACH_STATE bit */
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_TRANS_REG, 1); 
 80069d6:	ac01      	add	r4, sp, #4
{
 80069d8:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_TRANS_REG, 1); 
 80069da:	2301      	movs	r3, #1
 80069dc:	220d      	movs	r2, #13
 80069de:	0020      	movs	r0, r4
 80069e0:	f7ff ffb2 	bl	8006948 <STUSB1602_ReadReg>

    return (Attach_State_Trans_TypeDef)(reg.b.ATTACH_STATE_TRANS);
 80069e4:	7820      	ldrb	r0, [r4, #0]
 80069e6:	07c0      	lsls	r0, r0, #31
 80069e8:	0fc0      	lsrs	r0, r0, #31
}
 80069ea:	bd16      	pop	{r1, r2, r4, pc}

080069ec <STUSB1602_CC_Detection_Status_Get>:
  * @brief  STUSB1602 CC Detection Status  (Register 0x0E -- RO)
  * @param  Addr I2C address of port controller device
  * @retval STUSB1602_CC_DETECTION_STATUS_RegTypeDef
  */ 
STUSB1602_CC_DETECTION_STATUS_RegTypeDef STUSB1602_CC_Detection_Status_Get(uint8_t Addr)
{
 80069ec:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_DETECTION_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_REG, 1); 
 80069ee:	ac01      	add	r4, sp, #4
{
 80069f0:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_DETECTION_STATUS_REG, 1); 
 80069f2:	2301      	movs	r3, #1
 80069f4:	220e      	movs	r2, #14
 80069f6:	0020      	movs	r0, r4
 80069f8:	f7ff ffa6 	bl	8006948 <STUSB1602_ReadReg>

    return (reg);
 80069fc:	7820      	ldrb	r0, [r4, #0]
}
 80069fe:	bd16      	pop	{r1, r2, r4, pc}

08006a00 <STUSB1602_Monitoring_Status_Trans_Reg_Get>:
  * @brief STUSB1602 checks the entire Monitoring_Status_Trans_Reg (bit0-7 0x0F -- RC)
  * @param Addr I2C address of port controller device 
  * @retval STUSB1602_MONITORING_STATUS_TRANS_RegTypeDef
  */ 
STUSB1602_MONITORING_STATUS_TRANS_RegTypeDef STUSB1602_Monitoring_Status_Trans_Reg_Get(uint8_t Addr)
{
 8006a00:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_TRANS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_TRANS_REG, 1); 
 8006a02:	ac01      	add	r4, sp, #4
{
 8006a04:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_TRANS_REG, 1); 
 8006a06:	2301      	movs	r3, #1
 8006a08:	220f      	movs	r2, #15
 8006a0a:	0020      	movs	r0, r4
 8006a0c:	f7ff ff9c 	bl	8006948 <STUSB1602_ReadReg>

    return (reg);
 8006a10:	7820      	ldrb	r0, [r4, #0]
}
 8006a12:	bd16      	pop	{r1, r2, r4, pc}

08006a14 <STUSB1602_VBUS_Valid_Get>:
  * @brief STUSB1602 checks VBUS_Valid (bit3 0x10 -- RO)
  * @param Addr I2C address of port controller device  
  * @retval @ref VBUS_Valid_TypeDef
  */ 
VBUS_Valid_TypeDef STUSB1602_VBUS_Valid_Get(uint8_t Addr)
{
 8006a14:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 8006a16:	ac01      	add	r4, sp, #4
{
 8006a18:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 8006a1a:	2301      	movs	r3, #1
 8006a1c:	2210      	movs	r2, #16
 8006a1e:	0020      	movs	r0, r4
 8006a20:	f7ff ff92 	bl	8006948 <STUSB1602_ReadReg>

    return (VBUS_Valid_TypeDef)(reg.b.VBUS_VALID);
 8006a24:	7820      	ldrb	r0, [r4, #0]
 8006a26:	0700      	lsls	r0, r0, #28
 8006a28:	0fc0      	lsrs	r0, r0, #31
}
 8006a2a:	bd16      	pop	{r1, r2, r4, pc}

08006a2c <STUSB1602_VBUS_VSAFE0V_Get>:
  * @brief  STUSB1602 checks VBUS_VSAFE0V (bit2 0x10 -- RO)
  * @param Addr I2C address of port controller device   
  * @retval @ref VBUS_VSAFE0V_TypeDef
  */
VBUS_VSAFE0V_TypeDef STUSB1602_VBUS_VSAFE0V_Get(uint8_t Addr)
{
 8006a2c:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 8006a2e:	ac01      	add	r4, sp, #4
{
 8006a30:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 8006a32:	2301      	movs	r3, #1
 8006a34:	2210      	movs	r2, #16
 8006a36:	0020      	movs	r0, r4
 8006a38:	f7ff ff86 	bl	8006948 <STUSB1602_ReadReg>

    return (VBUS_VSAFE0V_TypeDef)(reg.b.VBUS_VSAFE0V);
 8006a3c:	7820      	ldrb	r0, [r4, #0]
 8006a3e:	0740      	lsls	r0, r0, #29
 8006a40:	0fc0      	lsrs	r0, r0, #31
}
 8006a42:	bd16      	pop	{r1, r2, r4, pc}

08006a44 <STUSB1602_VBUS_Presence_Get>:
  * @brief STUSB1602 checks VBUS_Presence (bit1 0x10 -- RO)
  * @param Addr I2C address of port controller device   
  * @retval VBUS_Presence_TypeDef
  */ 
VBUS_Presence_TypeDef STUSB1602_VBUS_Presence_Get(uint8_t Addr)
{
 8006a44:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_MONITORING_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 8006a46:	ac01      	add	r4, sp, #4
{
 8006a48:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MONITORING_STATUS_REG, 1); 
 8006a4a:	2301      	movs	r3, #1
 8006a4c:	2210      	movs	r2, #16
 8006a4e:	0020      	movs	r0, r4
 8006a50:	f7ff ff7a 	bl	8006948 <STUSB1602_ReadReg>

    return (VBUS_Presence_TypeDef)(reg.b.VBUS_PRESENCE);
 8006a54:	7820      	ldrb	r0, [r4, #0]
 8006a56:	0780      	lsls	r0, r0, #30
 8006a58:	0fc0      	lsrs	r0, r0, #31
}
 8006a5a:	bd16      	pop	{r1, r2, r4, pc}

08006a5c <STUSB1602_Sink_Power_State_Get>:
  * @brief STUSB1602 checks the Sink_Power_State mode (bit6-5 0x11 -- RO)
  * @param Addr I2C address of port controller device
  * @retval Sink_Power_State_TypeDef
  */ 
Sink_Power_State_TypeDef STUSB1602_Sink_Power_State_Get(uint8_t Addr)
{
 8006a5c:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_CONNECTION_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 8006a5e:	ac01      	add	r4, sp, #4
{
 8006a60:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 8006a62:	2301      	movs	r3, #1
 8006a64:	2211      	movs	r2, #17
 8006a66:	0020      	movs	r0, r4
 8006a68:	f7ff ff6e 	bl	8006948 <STUSB1602_ReadReg>

    return (Sink_Power_State_TypeDef)(reg.b.SINK_POWER_STATE);
 8006a6c:	7820      	ldrb	r0, [r4, #0]
 8006a6e:	0640      	lsls	r0, r0, #25
 8006a70:	0f80      	lsrs	r0, r0, #30
}
 8006a72:	bd16      	pop	{r1, r2, r4, pc}

08006a74 <STUSB1602_TypeC_FSM_State_Get>:
  * @brief STUSB1602 checks the TypeC_FSM_State (bit4-0 0x11 -- RO)
  * @param Addr I2C address of port controller device
  * @retval TypeC_FSM_State_TypeDef
  */
TypeC_FSM_State_TypeDef STUSB1602_TypeC_FSM_State_Get(uint8_t Addr)
{
 8006a74:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_CC_CONNECTION_STATUS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 8006a76:	ac01      	add	r4, sp, #4
{
 8006a78:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CONNECTION_STATUS_REG, 1); 
 8006a7a:	2301      	movs	r3, #1
 8006a7c:	2211      	movs	r2, #17
 8006a7e:	0020      	movs	r0, r4
 8006a80:	f7ff ff62 	bl	8006948 <STUSB1602_ReadReg>

    return (TypeC_FSM_State_TypeDef)(reg.b.TYPEC_FSM_STATE);
 8006a84:	7820      	ldrb	r0, [r4, #0]
 8006a86:	06c0      	lsls	r0, r0, #27
 8006a88:	0ec0      	lsrs	r0, r0, #27
}
 8006a8a:	bd16      	pop	{r1, r2, r4, pc}

08006a8c <STUSB1602_Hard_Fault_Trans_Status_Get>:
  * @brief STUSB1602 checks the entire HW_FAULT_STATUS_TRANS reg (bit7 0x12 -- RC)
  * @param Addr Address of the used port
  * @retval     STUSB1602_HW_FAULT_STATUS_TRANS_RegTypeDef
  */
STUSB1602_HW_FAULT_STATUS_TRANS_RegTypeDef STUSB1602_Hard_Fault_Trans_Status_Get(uint8_t Addr)
{
 8006a8c:	b513      	push	{r0, r1, r4, lr}
    STUSB1602_HW_FAULT_STATUS_TRANS_RegTypeDef reg;

    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_HW_FAULT_STATUS_TRANS_REG, 1); 
 8006a8e:	ac01      	add	r4, sp, #4
{
 8006a90:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_HW_FAULT_STATUS_TRANS_REG, 1); 
 8006a92:	2301      	movs	r3, #1
 8006a94:	2212      	movs	r2, #18
 8006a96:	0020      	movs	r0, r4
 8006a98:	f7ff ff56 	bl	8006948 <STUSB1602_ReadReg>

    return (reg);
 8006a9c:	7820      	ldrb	r0, [r4, #0]
}  
 8006a9e:	bd16      	pop	{r1, r2, r4, pc}

08006aa0 <STUSB1602_Current_Advertised_Set>:
  * @param Addr I2C address of port controller device
  * @param curr_cap Current Capability Advertised  of the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_Current_Advertised_Set(uint8_t Addr, Current_Capability_Advertised_TypeDef curr_cap)
{
 8006aa0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006aa2:	ac01      	add	r4, sp, #4
{
 8006aa4:	0005      	movs	r5, r0
 8006aa6:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006aa8:	2301      	movs	r3, #1
 8006aaa:	0001      	movs	r1, r0
 8006aac:	2218      	movs	r2, #24
 8006aae:	0020      	movs	r0, r4
 8006ab0:	f7ff ff4a 	bl	8006948 <STUSB1602_ReadReg>
    
    reg.b.CC_CURRENT_ADVERTISED = curr_cap;
 8006ab4:	233f      	movs	r3, #63	; 0x3f
 8006ab6:	7821      	ldrb	r1, [r4, #0]
 8006ab8:	01b6      	lsls	r6, r6, #6
 8006aba:	4019      	ands	r1, r3
 8006abc:	4331      	orrs	r1, r6
 8006abe:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006ac0:	3b3e      	subs	r3, #62	; 0x3e
 8006ac2:	0029      	movs	r1, r5
 8006ac4:	2218      	movs	r2, #24
 8006ac6:	0020      	movs	r0, r4
 8006ac8:	f7ff ff4e 	bl	8006968 <STUSB1602_WriteReg>
       
    return status;
}
 8006acc:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006ace <STUSB1602_SNK_Disconnect_Mode_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st SNK_DISCONNECT_MODE to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_SNK_Disconnect_Mode_Status_Set(uint8_t Addr, SNK_Disconnect_Mode_TypeDef st)
{
 8006ace:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006ad0:	ac01      	add	r4, sp, #4
{
 8006ad2:	0005      	movs	r5, r0
 8006ad4:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006ad6:	2301      	movs	r3, #1
 8006ad8:	0001      	movs	r1, r0
 8006ada:	2218      	movs	r2, #24
 8006adc:	0020      	movs	r0, r4
 8006ade:	f7ff ff33 	bl	8006948 <STUSB1602_ReadReg>

    reg.b.SNK_DISCONNECT_MODE = st;
 8006ae2:	2301      	movs	r3, #1
 8006ae4:	2220      	movs	r2, #32
 8006ae6:	7821      	ldrb	r1, [r4, #0]
 8006ae8:	401e      	ands	r6, r3
 8006aea:	0176      	lsls	r6, r6, #5
 8006aec:	4391      	bics	r1, r2
 8006aee:	4331      	orrs	r1, r6
 8006af0:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006af2:	3a08      	subs	r2, #8
 8006af4:	0029      	movs	r1, r5
 8006af6:	0020      	movs	r0, r4
 8006af8:	f7ff ff36 	bl	8006968 <STUSB1602_WriteReg>

    return status;
}
 8006afc:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006afe <STUSB1602_VCONN_Discharge_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st VCONN_Discharge_Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Discharge_Status_Set(uint8_t Addr, VCONN_Discharge_Status_TypeDef st)
{
 8006afe:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006b00:	ac01      	add	r4, sp, #4
{
 8006b02:	0005      	movs	r5, r0
 8006b04:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006b06:	2301      	movs	r3, #1
 8006b08:	0001      	movs	r1, r0
 8006b0a:	2218      	movs	r2, #24
 8006b0c:	0020      	movs	r0, r4
 8006b0e:	f7ff ff1b 	bl	8006948 <STUSB1602_ReadReg>
    
    reg.b.CC_VCONN_DISCHARGE_EN = st;
 8006b12:	2301      	movs	r3, #1
 8006b14:	2210      	movs	r2, #16
 8006b16:	7821      	ldrb	r1, [r4, #0]
 8006b18:	401e      	ands	r6, r3
 8006b1a:	0136      	lsls	r6, r6, #4
 8006b1c:	4391      	bics	r1, r2
 8006b1e:	4331      	orrs	r1, r6
 8006b20:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006b22:	3208      	adds	r2, #8
 8006b24:	0029      	movs	r1, r5
 8006b26:	0020      	movs	r0, r4
 8006b28:	f7ff ff1e 	bl	8006968 <STUSB1602_WriteReg>
       
    return status;
}
 8006b2c:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006b2e <STUSB1602_Data_Role_Swap_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */ 
STUSB1602_StatusTypeDef STUSB1602_Data_Role_Swap_Status_Set(uint8_t Addr, Data_Role_Swap_TypeDef st)
{
 8006b2e:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 8006b30:	ac01      	add	r4, sp, #4
{
 8006b32:	0005      	movs	r5, r0
 8006b34:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 8006b36:	2301      	movs	r3, #1
 8006b38:	0001      	movs	r1, r0
 8006b3a:	2218      	movs	r2, #24
 8006b3c:	0020      	movs	r0, r4
 8006b3e:	f7ff ff03 	bl	8006948 <STUSB1602_ReadReg>
    
    reg.b.DR_SWAP_EN = st;
 8006b42:	2301      	movs	r3, #1
 8006b44:	2208      	movs	r2, #8
 8006b46:	7821      	ldrb	r1, [r4, #0]
 8006b48:	401e      	ands	r6, r3
 8006b4a:	00f6      	lsls	r6, r6, #3
 8006b4c:	4391      	bics	r1, r2
 8006b4e:	4331      	orrs	r1, r6
 8006b50:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006b52:	3210      	adds	r2, #16
 8006b54:	0029      	movs	r1, r5
 8006b56:	0020      	movs	r0, r4
 8006b58:	f7ff ff06 	bl	8006968 <STUSB1602_WriteReg>
    
    return status;
}
 8006b5c:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006b5e <STUSB1602_Power_Role_Swap_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */ 
STUSB1602_StatusTypeDef STUSB1602_Power_Role_Swap_Status_Set(uint8_t Addr, Power_Role_Swap_TypeDef st)
{
 8006b5e:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 8006b60:	ac01      	add	r4, sp, #4
{
 8006b62:	0005      	movs	r5, r0
 8006b64:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);     
 8006b66:	2301      	movs	r3, #1
 8006b68:	0001      	movs	r1, r0
 8006b6a:	2218      	movs	r2, #24
 8006b6c:	0020      	movs	r0, r4
 8006b6e:	f7ff feeb 	bl	8006948 <STUSB1602_ReadReg>
    
    reg.b.PR_SWAP_EN = st;
 8006b72:	2301      	movs	r3, #1
 8006b74:	2204      	movs	r2, #4
 8006b76:	7821      	ldrb	r1, [r4, #0]
 8006b78:	401e      	ands	r6, r3
 8006b7a:	00b6      	lsls	r6, r6, #2
 8006b7c:	4391      	bics	r1, r2
 8006b7e:	4331      	orrs	r1, r6
 8006b80:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006b82:	3214      	adds	r2, #20
 8006b84:	0029      	movs	r1, r5
 8006b86:	0020      	movs	r0, r4
 8006b88:	f7ff feee 	bl	8006968 <STUSB1602_WriteReg>
    
    return status;
}
 8006b8c:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006b8e <STUSB1602_VCONN_Supply_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st VCONN_Supply_Status to be set on the used port
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Supply_Status_Set(uint8_t Addr, VCONN_Supply_Status_TypeDef st)
{
 8006b8e:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
  
    STUSB1602_CC_CAPABILITY_CTRL_RegTypeDef reg;  
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006b90:	ac01      	add	r4, sp, #4
{
 8006b92:	0005      	movs	r5, r0
 8006b94:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1); 
 8006b96:	2301      	movs	r3, #1
 8006b98:	0001      	movs	r1, r0
 8006b9a:	2218      	movs	r2, #24
 8006b9c:	0020      	movs	r0, r4
 8006b9e:	f7ff fed3 	bl	8006948 <STUSB1602_ReadReg>
    
    reg.b.CC_VCONN_SUPPLY_EN = st;
 8006ba2:	2301      	movs	r3, #1
 8006ba4:	7821      	ldrb	r1, [r4, #0]
 8006ba6:	401e      	ands	r6, r3
 8006ba8:	4399      	bics	r1, r3
 8006baa:	4331      	orrs	r1, r6
 8006bac:	7021      	strb	r1, [r4, #0]
    status =  STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_CAPABILITY_CTRL_REG, 1);
 8006bae:	2218      	movs	r2, #24
 8006bb0:	0029      	movs	r1, r5
 8006bb2:	0020      	movs	r0, r4
 8006bb4:	f7ff fed8 	bl	8006968 <STUSB1602_WriteReg>
       
    return status;
}
 8006bb8:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006bba <STUSB1602_VCONN_Switch_Current_Limit_Set>:
  * @param Addr I2C address of port controller device
  * @param curr_lim Current limit value to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Switch_Current_Limit_Set(uint8_t Addr, VCONN_Switch_Current_Limit_TypeDef curr_lim)
{
 8006bba:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_CC_VCONN_SWITCH_CTRL_RegTypeDef reg; 
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_VCONN_SWITCH_CTRL_REG, 1); 
 8006bbc:	ac01      	add	r4, sp, #4
{
 8006bbe:	0005      	movs	r5, r0
 8006bc0:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_VCONN_SWITCH_CTRL_REG, 1); 
 8006bc2:	2301      	movs	r3, #1
 8006bc4:	0001      	movs	r1, r0
 8006bc6:	221e      	movs	r2, #30
 8006bc8:	0020      	movs	r0, r4
 8006bca:	f7ff febd 	bl	8006948 <STUSB1602_ReadReg>
  
    reg.b.CC_VCONN_SWITCH_ILIM = curr_lim;
 8006bce:	230f      	movs	r3, #15
 8006bd0:	7821      	ldrb	r1, [r4, #0]
 8006bd2:	401e      	ands	r6, r3
 8006bd4:	4399      	bics	r1, r3
 8006bd6:	4331      	orrs	r1, r6
 8006bd8:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_VCONN_SWITCH_CTRL_REG, 1);
 8006bda:	3b0e      	subs	r3, #14
 8006bdc:	0029      	movs	r1, r5
 8006bde:	221e      	movs	r2, #30
 8006be0:	0020      	movs	r0, r4
 8006be2:	f7ff fec1 	bl	8006968 <STUSB1602_WriteReg>

    return status;
}
 8006be6:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006be8 <STUSB1602_Type_C_Control_Set>:
  * @param Addr I2C address of port controller device
  * @param Ctrl Control to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_Type_C_Control_Set(uint8_t Addr, Type_C_CTRL_TypeDef Ctrl)
{
 8006be8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_CC_MODE_CTRL_RegTypeDef reg; 
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_MODE_CTRL_REG, 1); 
 8006bea:	ac01      	add	r4, sp, #4
{
 8006bec:	0005      	movs	r5, r0
 8006bee:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_MODE_CTRL_REG, 1); 
 8006bf0:	2301      	movs	r3, #1
 8006bf2:	0001      	movs	r1, r0
 8006bf4:	221f      	movs	r2, #31
 8006bf6:	0020      	movs	r0, r4
 8006bf8:	f7ff fea6 	bl	8006948 <STUSB1602_ReadReg>
  
    reg.b.TYPEC_CTRL = Ctrl;
 8006bfc:	230f      	movs	r3, #15
 8006bfe:	7821      	ldrb	r1, [r4, #0]
 8006c00:	0136      	lsls	r6, r6, #4
 8006c02:	4019      	ands	r1, r3
 8006c04:	4331      	orrs	r1, r6
 8006c06:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_MODE_CTRL_REG, 1);
 8006c08:	3b0e      	subs	r3, #14
 8006c0a:	0029      	movs	r1, r5
 8006c0c:	221f      	movs	r2, #31
 8006c0e:	0020      	movs	r0, r4
 8006c10:	f7ff feaa 	bl	8006968 <STUSB1602_WriteReg>

    return status;
}
 8006c14:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006c16 <STUSB1602_VCONN_Monitor_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param st Power mode to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_Monitor_Status_Set(uint8_t Addr, VCONN_Monitoring_TypeDef st)
{
 8006c16:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VCONN_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006c18:	ac01      	add	r4, sp, #4
{
 8006c1a:	0005      	movs	r5, r0
 8006c1c:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006c1e:	2301      	movs	r3, #1
 8006c20:	0001      	movs	r1, r0
 8006c22:	2220      	movs	r2, #32
 8006c24:	0020      	movs	r0, r4
 8006c26:	f7ff fe8f 	bl	8006948 <STUSB1602_ReadReg>
  
    reg.b.VCONN_MONITORING_EN = st;
 8006c2a:	237f      	movs	r3, #127	; 0x7f
 8006c2c:	7821      	ldrb	r1, [r4, #0]
 8006c2e:	01f6      	lsls	r6, r6, #7
 8006c30:	4019      	ands	r1, r3
 8006c32:	4331      	orrs	r1, r6
 8006c34:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1);
 8006c36:	3b7e      	subs	r3, #126	; 0x7e
 8006c38:	0029      	movs	r1, r5
 8006c3a:	2220      	movs	r2, #32
 8006c3c:	0020      	movs	r0, r4
 8006c3e:	f7ff fe93 	bl	8006968 <STUSB1602_WriteReg>

    return status;
}
 8006c42:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006c44 <STUSB1602_VCONN_UVLO_Thresh_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param thr Power mode to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VCONN_UVLO_Thresh_Status_Set(uint8_t Addr, VCONN_UVLO_Threshold_TypeDef thr)
{
 8006c44:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VCONN_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006c46:	ac01      	add	r4, sp, #4
{
 8006c48:	0005      	movs	r5, r0
 8006c4a:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1); 
 8006c4c:	2301      	movs	r3, #1
 8006c4e:	0001      	movs	r1, r0
 8006c50:	2220      	movs	r2, #32
 8006c52:	0020      	movs	r0, r4
 8006c54:	f7ff fe78 	bl	8006948 <STUSB1602_ReadReg>
  
    reg.b.VCONN_UVLO_THRESHOLD = thr;
 8006c58:	2301      	movs	r3, #1
 8006c5a:	2240      	movs	r2, #64	; 0x40
 8006c5c:	7821      	ldrb	r1, [r4, #0]
 8006c5e:	401e      	ands	r6, r3
 8006c60:	01b6      	lsls	r6, r6, #6
 8006c62:	4391      	bics	r1, r2
 8006c64:	4331      	orrs	r1, r6
 8006c66:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VCONN_MONITORING_CTRL_REG, 1);
 8006c68:	3a20      	subs	r2, #32
 8006c6a:	0029      	movs	r1, r5
 8006c6c:	0020      	movs	r0, r4
 8006c6e:	f7ff fe7b 	bl	8006968 <STUSB1602_WriteReg>

    return status;
}
 8006c72:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006c74 <STUSB1602_VBUS_Select_Status_Get>:
  * @brief STUSB1602 checks the VBUS_SELECT (bit7:0 0x21 -- R/W)
  * @param Addr I2C address of port controller device
  * @retval uint16_t 
  */   
uint16_t STUSB1602_VBUS_Select_Status_Get(uint8_t Addr)
{
 8006c74:	b513      	push	{r0, r1, r4, lr}
    uint8_t reg; /* first default value = 50 */
    uint16_t DAC_mV=0;
#ifndef __VVAR     
    STUSB1602_ReadReg(&reg, Addr, STUSB1602_VBUS_SELECT_REG, 1);
 8006c76:	466b      	mov	r3, sp
 8006c78:	1ddc      	adds	r4, r3, #7
{
 8006c7a:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg, Addr, STUSB1602_VBUS_SELECT_REG, 1);
 8006c7c:	2301      	movs	r3, #1
 8006c7e:	2221      	movs	r2, #33	; 0x21
 8006c80:	0020      	movs	r0, r4
 8006c82:	f7ff fe61 	bl	8006948 <STUSB1602_ReadReg>
#else
    STUSB1602_ReadReg_P1(&reg, Addr+1, STUSB1602_VBUS_SELECT_REG, 1);
#endif
    DAC_mV=(uint16_t)(reg*100);
 8006c86:	2364      	movs	r3, #100	; 0x64
 8006c88:	7820      	ldrb	r0, [r4, #0]
 8006c8a:	4358      	muls	r0, r3
    
    return DAC_mV;
}
 8006c8c:	bd16      	pop	{r1, r2, r4, pc}
	...

08006c90 <STUSB1602_VBUS_Select_Status_Set>:
  * @param Addr I2C address of port controller device
  * @param mV The value (expressed in mV) to set the internal reference DAC
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_Select_Status_Set(uint8_t Addr, uint16_t mV)
{
 8006c90:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8006c92:	0004      	movs	r4, r0
 8006c94:	0008      	movs	r0, r1
    
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    uint8_t reg; /* first default value = 50 */     
    
    reg =(uint8_t)(mV/100);
 8006c96:	2164      	movs	r1, #100	; 0x64
 8006c98:	f7fe fe96 	bl	80059c8 <__udivsi3>
 8006c9c:	466b      	mov	r3, sp
    real_val[k] = reg;
 8006c9e:	4907      	ldr	r1, [pc, #28]	; (8006cbc <STUSB1602_VBUS_Select_Status_Set+0x2c>)
    reg =(uint8_t)(mV/100);
 8006ca0:	b2c2      	uxtb	r2, r0
    real_val[k] = reg;
 8006ca2:	4d07      	ldr	r5, [pc, #28]	; (8006cc0 <STUSB1602_VBUS_Select_Status_Set+0x30>)
    reg =(uint8_t)(mV/100);
 8006ca4:	1dd8      	adds	r0, r3, #7
    real_val[k] = reg;
 8006ca6:	780b      	ldrb	r3, [r1, #0]
    reg =(uint8_t)(mV/100);
 8006ca8:	7002      	strb	r2, [r0, #0]
    real_val[k] = reg;
 8006caa:	54ea      	strb	r2, [r5, r3]
      
    k++;
 8006cac:	3301      	adds	r3, #1
 8006cae:	700b      	strb	r3, [r1, #0]
#ifdef __VVAR
    STUSB1602_WriteReg_P1(&reg, Addr+1, STUSB1602_VBUS_SELECT_REG, 1);
#endif
    status = STUSB1602_WriteReg(&reg, Addr, STUSB1602_VBUS_SELECT_REG, 1);
 8006cb0:	2221      	movs	r2, #33	; 0x21
 8006cb2:	2301      	movs	r3, #1
 8006cb4:	0021      	movs	r1, r4
 8006cb6:	f7ff fe57 	bl	8006968 <STUSB1602_WriteReg>
             
    return status;
}
 8006cba:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
 8006cbc:	20001a9c 	.word	0x20001a9c
 8006cc0:	20001a9d 	.word	0x20001a9d

08006cc4 <STUSB1602_VBUS_VShift_High_Set>:
  * @param Addr I2C address of port controller device
  * @param Set The VShift_High value >= 5% (expressed in %) to set the high threshold value  
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_VShift_High_Set(uint8_t Addr, uint8_t Set)
{
 8006cc4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VBUS_RANGE_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006cc6:	ac01      	add	r4, sp, #4
{
 8006cc8:	0005      	movs	r5, r0
 8006cca:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006ccc:	2301      	movs	r3, #1
 8006cce:	0001      	movs	r1, r0
 8006cd0:	2222      	movs	r2, #34	; 0x22
 8006cd2:	0020      	movs	r0, r4
 8006cd4:	f7ff fe38 	bl	8006948 <STUSB1602_ReadReg>
  
    reg.b.VBUS_VSHIFT_HIGH = (Set - 5);
 8006cd8:	230f      	movs	r3, #15
 8006cda:	7821      	ldrb	r1, [r4, #0]
 8006cdc:	3e05      	subs	r6, #5
 8006cde:	0136      	lsls	r6, r6, #4
 8006ce0:	4019      	ands	r1, r3
 8006ce2:	4331      	orrs	r1, r6
 8006ce4:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1);
 8006ce6:	3b0e      	subs	r3, #14
 8006ce8:	0029      	movs	r1, r5
 8006cea:	2222      	movs	r2, #34	; 0x22
 8006cec:	0020      	movs	r0, r4
 8006cee:	f7ff fe3b 	bl	8006968 <STUSB1602_WriteReg>
        
    return status;
}
 8006cf2:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006cf4 <STUSB1602_VBUS_VShift_Low_Set>:
  * @param Addr I2C address of port controller device
  * @param Set The VShift_Low value <=5% (expressed in %) to set the low threshold value
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_VShift_Low_Set(uint8_t Addr, int8_t Set)
{
 8006cf4:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8006cf6:	000c      	movs	r4, r1
    Set = (Set>0) ? -Set : Set;
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_VBUS_RANGE_MONITORING_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006cf8:	ad01      	add	r5, sp, #4
{
 8006cfa:	0006      	movs	r6, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1); 
 8006cfc:	0001      	movs	r1, r0
 8006cfe:	2301      	movs	r3, #1
 8006d00:	0028      	movs	r0, r5
 8006d02:	2222      	movs	r2, #34	; 0x22
 8006d04:	f7ff fe20 	bl	8006948 <STUSB1602_ReadReg>
  
    reg.b.VBUS_VSHIFT_LOW = (-Set - 5);
 8006d08:	220f      	movs	r2, #15
    Set = (Set>0) ? -Set : Set;
 8006d0a:	17e3      	asrs	r3, r4, #31
 8006d0c:	18e4      	adds	r4, r4, r3
 8006d0e:	405c      	eors	r4, r3
    reg.b.VBUS_VSHIFT_LOW = (-Set - 5);
 8006d10:	782b      	ldrb	r3, [r5, #0]
 8006d12:	3c05      	subs	r4, #5
 8006d14:	4393      	bics	r3, r2
 8006d16:	4014      	ands	r4, r2
 8006d18:	431c      	orrs	r4, r3
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1);
 8006d1a:	0031      	movs	r1, r6
 8006d1c:	0028      	movs	r0, r5
 8006d1e:	2301      	movs	r3, #1
 8006d20:	3213      	adds	r2, #19
    reg.b.VBUS_VSHIFT_LOW = (-Set - 5);
 8006d22:	702c      	strb	r4, [r5, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_RANGE_MONITORING_CTRL_REG, 1);
 8006d24:	f7ff fe20 	bl	8006968 <STUSB1602_WriteReg>
        
    return status;
}
 8006d28:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006d2a <STUSB1602_SW_RESET_Set>:
  * @param Addr I2C address of port controller device
  * @param Rst Enable or Disable of the SW RST function
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_SW_RESET_Set(uint8_t Addr, SW_RESET_TypeDef Rst)
{  
 8006d2a:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
    STUSB1602_RESET_CTRL_RegTypeDef reg;
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_RESET_CTRL_REG, 1); 
 8006d2c:	ac01      	add	r4, sp, #4
{  
 8006d2e:	0005      	movs	r5, r0
 8006d30:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_RESET_CTRL_REG, 1); 
 8006d32:	2301      	movs	r3, #1
 8006d34:	0001      	movs	r1, r0
 8006d36:	2223      	movs	r2, #35	; 0x23
 8006d38:	0020      	movs	r0, r4
 8006d3a:	f7ff fe05 	bl	8006948 <STUSB1602_ReadReg>
  
    reg.b.SW_RESET_EN = Rst;
 8006d3e:	2301      	movs	r3, #1
 8006d40:	7821      	ldrb	r1, [r4, #0]
 8006d42:	401e      	ands	r6, r3
 8006d44:	4399      	bics	r1, r3
 8006d46:	4331      	orrs	r1, r6
 8006d48:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_RESET_CTRL_REG, 1);
 8006d4a:	2223      	movs	r2, #35	; 0x23
 8006d4c:	0029      	movs	r1, r5
 8006d4e:	0020      	movs	r0, r4
 8006d50:	f7ff fe0a 	bl	8006968 <STUSB1602_WriteReg>
             
    return status;
}
 8006d54:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006d56 <STUSB1602_Pwr_Acc_Detect_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_Pwr_Acc_Detect_Set(uint8_t Addr, Pwr_Acc_Detect_TypeDef st)
{    
 8006d56:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;  
    
   STUSB1602_CC_POWERED_ACCESSORY_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_POWERED_ACCESSORY_CTRL_REG, 1);
 8006d58:	ac01      	add	r4, sp, #4
{    
 8006d5a:	0005      	movs	r5, r0
 8006d5c:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_CC_POWERED_ACCESSORY_CTRL_REG, 1);
 8006d5e:	2301      	movs	r3, #1
 8006d60:	0001      	movs	r1, r0
 8006d62:	2224      	movs	r2, #36	; 0x24
 8006d64:	0020      	movs	r0, r4
 8006d66:	f7ff fdef 	bl	8006948 <STUSB1602_ReadReg>
  
   reg.b.PWR_ACC_DETECT_EN = st;    
 8006d6a:	2301      	movs	r3, #1
 8006d6c:	7821      	ldrb	r1, [r4, #0]
 8006d6e:	401e      	ands	r6, r3
 8006d70:	4399      	bics	r1, r3
 8006d72:	4331      	orrs	r1, r6
 8006d74:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_CC_POWERED_ACCESSORY_CTRL_REG, 1);
 8006d76:	2224      	movs	r2, #36	; 0x24
 8006d78:	0029      	movs	r1, r5
 8006d7a:	0020      	movs	r0, r4
 8006d7c:	f7ff fdf4 	bl	8006968 <STUSB1602_WriteReg>
             
   return status;
}
 8006d80:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006d82 <STUSB1602_VBUS_Discharge_Time_to_0V_Set>:
  * @param Addr I2C address of port controller device
  * @param tim  VBUS discharge time in msec
  * @retval STUSB1602_StatusTypeDef
  */
STUSB1602_StatusTypeDef STUSB1602_VBUS_Discharge_Time_to_0V_Set(uint8_t Addr, uint16_t tim)
{
 8006d82:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8006d84:	000e      	movs	r6, r1
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_DISCHARGE_TIME_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006d86:	ac01      	add	r4, sp, #4
{
 8006d88:	0005      	movs	r5, r0
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006d8a:	2301      	movs	r3, #1
 8006d8c:	2225      	movs	r2, #37	; 0x25
 8006d8e:	0001      	movs	r1, r0
 8006d90:	0020      	movs	r0, r4
 8006d92:	f7ff fdd9 	bl	8006948 <STUSB1602_ReadReg>
   
   reg.b.VBUS_DISCHARGE_TIME_TO_0V = (uint8_t)(tim/84);
 8006d96:	0030      	movs	r0, r6
 8006d98:	2154      	movs	r1, #84	; 0x54
 8006d9a:	f7fe fe15 	bl	80059c8 <__udivsi3>
 8006d9e:	220f      	movs	r2, #15
 8006da0:	0103      	lsls	r3, r0, #4
 8006da2:	7820      	ldrb	r0, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1); 
 8006da4:	0029      	movs	r1, r5
   reg.b.VBUS_DISCHARGE_TIME_TO_0V = (uint8_t)(tim/84);
 8006da6:	4010      	ands	r0, r2
 8006da8:	4318      	orrs	r0, r3
 8006daa:	7020      	strb	r0, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1); 
 8006dac:	2301      	movs	r3, #1
 8006dae:	3216      	adds	r2, #22
 8006db0:	0020      	movs	r0, r4
 8006db2:	f7ff fdd9 	bl	8006968 <STUSB1602_WriteReg>
    
   return status;
}
 8006db6:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006db8 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>:
  * @param Addr I2C address of port controller device
  * @param tim VBUS discharge time in msec
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_Discharge_Time_to_PDO_Set(uint8_t Addr, uint16_t tim)
{
 8006db8:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8006dba:	000e      	movs	r6, r1
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_DISCHARGE_TIME_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006dbc:	ac01      	add	r4, sp, #4
{
 8006dbe:	0005      	movs	r5, r0
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1);
 8006dc0:	2301      	movs	r3, #1
 8006dc2:	2225      	movs	r2, #37	; 0x25
 8006dc4:	0001      	movs	r1, r0
 8006dc6:	0020      	movs	r0, r4
 8006dc8:	f7ff fdbe 	bl	8006948 <STUSB1602_ReadReg>
   
   reg.b.VBUS_DISCHARGE_TIME_TO_PDO = (uint8_t)(tim/20);
 8006dcc:	0030      	movs	r0, r6
 8006dce:	2114      	movs	r1, #20
 8006dd0:	f7fe fdfa 	bl	80059c8 <__udivsi3>
 8006dd4:	220f      	movs	r2, #15
 8006dd6:	0003      	movs	r3, r0
 8006dd8:	7820      	ldrb	r0, [r4, #0]
 8006dda:	4013      	ands	r3, r2
 8006ddc:	4390      	bics	r0, r2
 8006dde:	4318      	orrs	r0, r3
 8006de0:	7020      	strb	r0, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_TIME_CTRL_REG, 1); 
 8006de2:	0029      	movs	r1, r5
 8006de4:	2301      	movs	r3, #1
 8006de6:	3216      	adds	r2, #22
 8006de8:	0020      	movs	r0, r4
 8006dea:	f7ff fdbd 	bl	8006968 <STUSB1602_WriteReg>
    
   return status;
}
 8006dee:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006df0 <STUSB1602_VBUS_Discharge_State_Set>:
  * @param Addr I2C address of port controller device
  * @param st Status to be set
  * @retval STUSB1602_StatusTypeDef 
  */
STUSB1602_StatusTypeDef STUSB1602_VBUS_Discharge_State_Set(uint8_t Addr, VBUS_Discharge_State_TypeDef st)
{    
 8006df0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_DISCHARGE_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1); 
 8006df2:	ac01      	add	r4, sp, #4
{    
 8006df4:	0005      	movs	r5, r0
 8006df6:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1); 
 8006df8:	2301      	movs	r3, #1
 8006dfa:	0001      	movs	r1, r0
 8006dfc:	2226      	movs	r2, #38	; 0x26
 8006dfe:	0020      	movs	r0, r4
 8006e00:	f7ff fda2 	bl	8006948 <STUSB1602_ReadReg>
   
   reg.b.VBUS_DISCHARGE_EN = st;
 8006e04:	237f      	movs	r3, #127	; 0x7f
 8006e06:	7821      	ldrb	r1, [r4, #0]
 8006e08:	01f6      	lsls	r6, r6, #7
 8006e0a:	4019      	ands	r1, r3
 8006e0c:	4331      	orrs	r1, r6
 8006e0e:	7021      	strb	r1, [r4, #0]
#ifdef __VVAR
   STUSB1602_WriteReg_P1(&reg.d8, Addr+1, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1);
#endif
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_DISCHARGE_CTRL_REG, 1);
 8006e10:	3b7e      	subs	r3, #126	; 0x7e
 8006e12:	0029      	movs	r1, r5
 8006e14:	2226      	movs	r2, #38	; 0x26
 8006e16:	0020      	movs	r0, r4
 8006e18:	f7ff fda6 	bl	8006968 <STUSB1602_WriteReg>
   
   return status;   
}
 8006e1c:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006e1e <STUSB1602_Power_Mode_Set>:
  * @param Addr I2C address of port controller device
  * @param Pwr Power mode to be set
  * @retval STUSB1602_StatusTypeDef
  */   
STUSB1602_StatusTypeDef STUSB1602_Power_Mode_Set(uint8_t Addr, Power_Mode_TypeDef Pwr)
{
 8006e1e:	b573      	push	{r0, r1, r4, r5, r6, lr}
    STUSB1602_StatusTypeDef status = STUSB1602_OK;
    
    STUSB1602_MODE_CTRL_RegTypeDef reg; 
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MODE_CTRL_REG, 1); 
 8006e20:	ac01      	add	r4, sp, #4
{
 8006e22:	0005      	movs	r5, r0
 8006e24:	000e      	movs	r6, r1
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_MODE_CTRL_REG, 1); 
 8006e26:	2301      	movs	r3, #1
 8006e28:	0001      	movs	r1, r0
 8006e2a:	2228      	movs	r2, #40	; 0x28
 8006e2c:	0020      	movs	r0, r4
 8006e2e:	f7ff fd8b 	bl	8006948 <STUSB1602_ReadReg>
  
    reg.b.POWER_MODE = Pwr;
 8006e32:	2307      	movs	r3, #7
 8006e34:	7821      	ldrb	r1, [r4, #0]
 8006e36:	401e      	ands	r6, r3
 8006e38:	4399      	bics	r1, r3
 8006e3a:	4331      	orrs	r1, r6
 8006e3c:	7021      	strb	r1, [r4, #0]
    status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_MODE_CTRL_REG, 1);
 8006e3e:	3b06      	subs	r3, #6
 8006e40:	0029      	movs	r1, r5
 8006e42:	2228      	movs	r2, #40	; 0x28
 8006e44:	0020      	movs	r0, r4
 8006e46:	f7ff fd8f 	bl	8006968 <STUSB1602_WriteReg>
             
    return status;
}
 8006e4a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006e4c <STUSB1602_NVM_OK_Get>:
  * @brief It checks if NVM is loaded correctly (bit0:1 0x2F -- R)
  * @param Addr I2C address of port controller device
  * @retval NVM_OK_TypeDef 
  */  
NVM_OK_TypeDef STUSB1602_NVM_OK_Get(uint8_t Addr)
{
 8006e4c:	b513      	push	{r0, r1, r4, lr}
   STUSB1602_DEVICE_CUT_RegTypeDef reg;
        
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006e4e:	ac01      	add	r4, sp, #4
{
 8006e50:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006e52:	2301      	movs	r3, #1
 8006e54:	222f      	movs	r2, #47	; 0x2f
 8006e56:	0020      	movs	r0, r4
 8006e58:	f7ff fd76 	bl	8006948 <STUSB1602_ReadReg>
      
    return (NVM_OK_TypeDef)(reg.b.Reserved_0_2);
 8006e5c:	7820      	ldrb	r0, [r4, #0]
 8006e5e:	0780      	lsls	r0, r0, #30
 8006e60:	0f80      	lsrs	r0, r0, #30
}
 8006e62:	bd16      	pop	{r1, r2, r4, pc}

08006e64 <STUSB1602_DEVICE_CUT_Get>:
  * @brief It gets the cut number (bit2:4 0x2F -- R)
  * @param Addr I2C address of port controller device
  * @retval DEVICE_CUT_TypeDef 
  */ 
DEVICE_CUT_TypeDef STUSB1602_DEVICE_CUT_Get(uint8_t Addr)
{
 8006e64:	b513      	push	{r0, r1, r4, lr}
   STUSB1602_DEVICE_CUT_RegTypeDef reg;
        
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006e66:	ac01      	add	r4, sp, #4
{
 8006e68:	0001      	movs	r1, r0
    STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_DEVICE_CUT_REG, 1);
 8006e6a:	2301      	movs	r3, #1
 8006e6c:	222f      	movs	r2, #47	; 0x2f
 8006e6e:	0020      	movs	r0, r4
 8006e70:	f7ff fd6a 	bl	8006948 <STUSB1602_ReadReg>
      
    return (DEVICE_CUT_TypeDef)(reg.b.DEVICE_CUT);
 8006e74:	7820      	ldrb	r0, [r4, #0]
 8006e76:	06c0      	lsls	r0, r0, #27
 8006e78:	0f40      	lsrs	r0, r0, #29
}
 8006e7a:	bd16      	pop	{r1, r2, r4, pc}

08006e7c <STUSB1602_VDD_OVLO_Threshold_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VDD_OVLO_Threshold_Set(uint8_t Addr, VDD_OVLO_Threshold_TypeDef st)
{      
 8006e7c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006e7e:	ac01      	add	r4, sp, #4
{      
 8006e80:	0005      	movs	r5, r0
 8006e82:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006e84:	2301      	movs	r3, #1
 8006e86:	0001      	movs	r1, r0
 8006e88:	222e      	movs	r2, #46	; 0x2e
 8006e8a:	0020      	movs	r0, r4
 8006e8c:	f7ff fd5c 	bl	8006948 <STUSB1602_ReadReg>
   
   reg.b.VDD_OVLO_DISABLE = st;
 8006e90:	2301      	movs	r3, #1
 8006e92:	2240      	movs	r2, #64	; 0x40
 8006e94:	7821      	ldrb	r1, [r4, #0]
 8006e96:	401e      	ands	r6, r3
 8006e98:	01b6      	lsls	r6, r6, #6
 8006e9a:	4391      	bics	r1, r2
 8006e9c:	4331      	orrs	r1, r6
 8006e9e:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006ea0:	3a12      	subs	r2, #18
 8006ea2:	0029      	movs	r1, r5
 8006ea4:	0020      	movs	r0, r4
 8006ea6:	f7ff fd5f 	bl	8006968 <STUSB1602_WriteReg>
     
   return status;  
}
 8006eaa:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006eac <STUSB1602_VBUS_Range_State_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_Range_State_Set(uint8_t Addr, VBUS_Range_State_TypeDef st)
{      
 8006eac:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006eae:	ac01      	add	r4, sp, #4
{      
 8006eb0:	0005      	movs	r5, r0
 8006eb2:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006eb4:	2301      	movs	r3, #1
 8006eb6:	0001      	movs	r1, r0
 8006eb8:	222e      	movs	r2, #46	; 0x2e
 8006eba:	0020      	movs	r0, r4
 8006ebc:	f7ff fd44 	bl	8006948 <STUSB1602_ReadReg>
   
   reg.b.VBUS_RANGE_DISABLE = st;
 8006ec0:	2301      	movs	r3, #1
 8006ec2:	2210      	movs	r2, #16
 8006ec4:	7821      	ldrb	r1, [r4, #0]
 8006ec6:	401e      	ands	r6, r3
 8006ec8:	0136      	lsls	r6, r6, #4
 8006eca:	4391      	bics	r1, r2
 8006ecc:	4331      	orrs	r1, r6
 8006ece:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006ed0:	321e      	adds	r2, #30
 8006ed2:	0029      	movs	r1, r5
 8006ed4:	0020      	movs	r0, r4
 8006ed6:	f7ff fd47 	bl	8006968 <STUSB1602_WriteReg>
     
   return status;  
}
 8006eda:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006edc <STUSB1602_VBUS_VSAFE0V_Threshold_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VBUS_VSAFE0V_Threshold_Set(uint8_t Addr, VBUS_VSAFE0V_Threshold_TypeDef st)
{      
 8006edc:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006ede:	ac01      	add	r4, sp, #4
{      
 8006ee0:	0005      	movs	r5, r0
 8006ee2:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006ee4:	2301      	movs	r3, #1
 8006ee6:	0001      	movs	r1, r0
 8006ee8:	222e      	movs	r2, #46	; 0x2e
 8006eea:	0020      	movs	r0, r4
 8006eec:	f7ff fd2c 	bl	8006948 <STUSB1602_ReadReg>
   
   reg.b.VBUS_VSAFE0V_THRESHOLD = st;
 8006ef0:	2103      	movs	r1, #3
 8006ef2:	2306      	movs	r3, #6
 8006ef4:	400e      	ands	r6, r1
 8006ef6:	7821      	ldrb	r1, [r4, #0]
 8006ef8:	0076      	lsls	r6, r6, #1
 8006efa:	4399      	bics	r1, r3
 8006efc:	4331      	orrs	r1, r6
 8006efe:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006f00:	3b05      	subs	r3, #5
 8006f02:	0029      	movs	r1, r5
 8006f04:	222e      	movs	r2, #46	; 0x2e
 8006f06:	0020      	movs	r0, r4
 8006f08:	f7ff fd2e 	bl	8006968 <STUSB1602_WriteReg>
     
   return status;  
}
 8006f0c:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006f0e <STUSB1602_VDD_UVLO_Threshold_Set>:
  * @param Addr I2C address of port controller device
  * @param st status to be set 
  * @retval STUSB1602_StatusTypeDef 
  */   
STUSB1602_StatusTypeDef STUSB1602_VDD_UVLO_Threshold_Set(uint8_t Addr, VDD_UVLO_Threshold_TypeDef st)
{      
 8006f0e:	b573      	push	{r0, r1, r4, r5, r6, lr}
   STUSB1602_StatusTypeDef status = STUSB1602_OK;
   
   STUSB1602_VBUS_MONITORING_CTRL_RegTypeDef reg;
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006f10:	ac01      	add	r4, sp, #4
{      
 8006f12:	0005      	movs	r5, r0
 8006f14:	000e      	movs	r6, r1
   STUSB1602_ReadReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1); 
 8006f16:	2301      	movs	r3, #1
 8006f18:	0001      	movs	r1, r0
 8006f1a:	222e      	movs	r2, #46	; 0x2e
 8006f1c:	0020      	movs	r0, r4
 8006f1e:	f7ff fd13 	bl	8006948 <STUSB1602_ReadReg>
   
   reg.b.VDD_UVLO_DISABLE = st;
 8006f22:	2301      	movs	r3, #1
 8006f24:	7821      	ldrb	r1, [r4, #0]
 8006f26:	401e      	ands	r6, r3
 8006f28:	4399      	bics	r1, r3
 8006f2a:	4331      	orrs	r1, r6
 8006f2c:	7021      	strb	r1, [r4, #0]
   status = STUSB1602_WriteReg(&reg.d8, Addr, STUSB1602_VBUS_MONITORING_CTRL_REG, 1);
 8006f2e:	222e      	movs	r2, #46	; 0x2e
 8006f30:	0029      	movs	r1, r5
 8006f32:	0020      	movs	r0, r4
 8006f34:	f7ff fd18 	bl	8006968 <STUSB1602_WriteReg>
     
   return status;  
}
 8006f38:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08006f3a <STUSB1602_Type_C_Command>:
  * @param Addr I2C address of port controller device
  * @param Ctrl Control to be set
  * @retval STUSB1602_StatusTypeDef
  */
STUSB1602_StatusTypeDef STUSB1602_Type_C_Command(uint8_t Addr, Type_C_CTRL_TypeDef Ctrl)
{
 8006f3a:	b510      	push	{r4, lr}
    STUSB1602_StatusTypeDef ret = STUSB1602_Type_C_Control_Set(Addr, Ctrl); /* register */
 8006f3c:	f7ff fe54 	bl	8006be8 <STUSB1602_Type_C_Control_Set>
    return timeout > 0 ? ret : STUSB1602_TIMEOUT;
#else
    return ret;
#endif /* _DEBUG_ACK_ENABLE */

}
 8006f40:	bd10      	pop	{r4, pc}
	...

08006f44 <USBPD_BSP_LED_Set>:
  * @param  Value: value to set the led on or off.
  * @retval None
  */
  void USBPD_BSP_LED_Set(USBPD_BSP_Led_TypeDef Led, uint8_t Value)
  {
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, Value ? GPIO_PIN_RESET : GPIO_PIN_SET);
 8006f44:	230c      	movs	r3, #12
 8006f46:	424a      	negs	r2, r1
 8006f48:	414a      	adcs	r2, r1
 8006f4a:	4358      	muls	r0, r3
  {
 8006f4c:	b510      	push	{r4, lr}
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, Value ? GPIO_PIN_RESET : GPIO_PIN_SET);
 8006f4e:	4c04      	ldr	r4, [pc, #16]	; (8006f60 <USBPD_BSP_LED_Set+0x1c>)
 8006f50:	b2d2      	uxtb	r2, r2
 8006f52:	1823      	adds	r3, r4, r0
 8006f54:	8899      	ldrh	r1, [r3, #4]
 8006f56:	5900      	ldr	r0, [r0, r4]
 8006f58:	f000 fdf0 	bl	8007b3c <HAL_GPIO_WritePin>
  }
 8006f5c:	bd10      	pop	{r4, pc}
 8006f5e:	46c0      	nop			; (mov r8, r8)
 8006f60:	20000000 	.word	0x20000000

08006f64 <USBPD_BSP_LED_On>:
  * @retval None
  */  
  
  void USBPD_BSP_LED_On(USBPD_BSP_Led_TypeDef Led)
  {
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_RESET);
 8006f64:	230c      	movs	r3, #12
 8006f66:	4358      	muls	r0, r3
  {
 8006f68:	b510      	push	{r4, lr}
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_RESET);
 8006f6a:	4c04      	ldr	r4, [pc, #16]	; (8006f7c <USBPD_BSP_LED_On+0x18>)
 8006f6c:	2200      	movs	r2, #0
 8006f6e:	1823      	adds	r3, r4, r0
 8006f70:	8899      	ldrh	r1, [r3, #4]
 8006f72:	5900      	ldr	r0, [r0, r4]
 8006f74:	f000 fde2 	bl	8007b3c <HAL_GPIO_WritePin>
  }
 8006f78:	bd10      	pop	{r4, pc}
 8006f7a:	46c0      	nop			; (mov r8, r8)
 8006f7c:	20000000 	.word	0x20000000

08006f80 <USBPD_BSP_LED_Off>:
  * @retval None
  */  
  
  void USBPD_BSP_LED_Off(USBPD_BSP_Led_TypeDef Led)
  {
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_SET);
 8006f80:	230c      	movs	r3, #12
 8006f82:	4358      	muls	r0, r3
  {
 8006f84:	b510      	push	{r4, lr}
    HAL_GPIO_WritePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin, GPIO_PIN_SET);
 8006f86:	4c04      	ldr	r4, [pc, #16]	; (8006f98 <USBPD_BSP_LED_Off+0x18>)
 8006f88:	2201      	movs	r2, #1
 8006f8a:	1823      	adds	r3, r4, r0
 8006f8c:	8899      	ldrh	r1, [r3, #4]
 8006f8e:	5900      	ldr	r0, [r0, r4]
 8006f90:	f000 fdd4 	bl	8007b3c <HAL_GPIO_WritePin>
  }
 8006f94:	bd10      	pop	{r4, pc}
 8006f96:	46c0      	nop			; (mov r8, r8)
 8006f98:	20000000 	.word	0x20000000

08006f9c <USBPD_BSP_LED_Init>:
  {
 8006f9c:	b530      	push	{r4, r5, lr}
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8006f9e:	2301      	movs	r3, #1
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006fa0:	2400      	movs	r4, #0
 8006fa2:	250c      	movs	r5, #12
  {
 8006fa4:	b087      	sub	sp, #28
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8006fa6:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006fa8:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;    
 8006faa:	9404      	str	r4, [sp, #16]
 8006fac:	002a      	movs	r2, r5
 8006fae:	4362      	muls	r2, r4
        GPIO_InitStruct.Pin = USBPD_BSP_LEDs[led].GPIO_Pin;
 8006fb0:	4b07      	ldr	r3, [pc, #28]	; (8006fd0 <USBPD_BSP_LED_Init+0x34>)
 8006fb2:	1899      	adds	r1, r3, r2
 8006fb4:	8889      	ldrh	r1, [r1, #4]
        HAL_GPIO_Init(USBPD_BSP_LEDs[led].GPIOx, &GPIO_InitStruct);
 8006fb6:	58d0      	ldr	r0, [r2, r3]
        GPIO_InitStruct.Pin = USBPD_BSP_LEDs[led].GPIO_Pin;
 8006fb8:	9101      	str	r1, [sp, #4]
        HAL_GPIO_Init(USBPD_BSP_LEDs[led].GPIOx, &GPIO_InitStruct);
 8006fba:	a901      	add	r1, sp, #4
 8006fbc:	f000 fcfc 	bl	80079b8 <HAL_GPIO_Init>
        USBPD_BSP_LED_Off((USBPD_BSP_Led_TypeDef)led);
 8006fc0:	b260      	sxtb	r0, r4
 8006fc2:	3401      	adds	r4, #1
 8006fc4:	f7ff ffdc 	bl	8006f80 <USBPD_BSP_LED_Off>
    for(led=0;led<USBPD_BSP_LEDn;led++)
 8006fc8:	2c04      	cmp	r4, #4
 8006fca:	d1ef      	bne.n	8006fac <USBPD_BSP_LED_Init+0x10>
  }
 8006fcc:	b007      	add	sp, #28
 8006fce:	bd30      	pop	{r4, r5, pc}
 8006fd0:	20000000 	.word	0x20000000

08006fd4 <USBPD_BSP_LED_Toggle>:
  * @retval None
  */ 
  
  void USBPD_BSP_LED_Toggle(USBPD_BSP_Led_TypeDef Led)
  {
    HAL_GPIO_TogglePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin);
 8006fd4:	230c      	movs	r3, #12
 8006fd6:	4358      	muls	r0, r3
  {
 8006fd8:	b510      	push	{r4, lr}
    HAL_GPIO_TogglePin(USBPD_BSP_LEDs[Led].GPIOx, USBPD_BSP_LEDs[Led].GPIO_Pin);
 8006fda:	4a03      	ldr	r2, [pc, #12]	; (8006fe8 <USBPD_BSP_LED_Toggle+0x14>)
 8006fdc:	1813      	adds	r3, r2, r0
 8006fde:	8899      	ldrh	r1, [r3, #4]
 8006fe0:	5880      	ldr	r0, [r0, r2]
 8006fe2:	f000 fdb1 	bl	8007b48 <HAL_GPIO_TogglePin>
  }
 8006fe6:	bd10      	pop	{r4, pc}
 8006fe8:	20000000 	.word	0x20000000

08006fec <USBPD_BSP_UART_Init>:
  */

void USBPD_BSP_UART_Init(void)
{
    /* Init huart_usbpdm1 */
    huart_handle.Instance = USBPD_BSP_USART;
 8006fec:	4809      	ldr	r0, [pc, #36]	; (8007014 <USBPD_BSP_UART_Init+0x28>)
 8006fee:	4b0a      	ldr	r3, [pc, #40]	; (8007018 <USBPD_BSP_UART_Init+0x2c>)
{
 8006ff0:	b510      	push	{r4, lr}
    huart_handle.Instance = USBPD_BSP_USART;
 8006ff2:	6003      	str	r3, [r0, #0]
    huart_handle.Init.BaudRate = BAUDRATE;
 8006ff4:	23e1      	movs	r3, #225	; 0xe1
 8006ff6:	025b      	lsls	r3, r3, #9
 8006ff8:	6043      	str	r3, [r0, #4]
    huart_handle.Init.WordLength = UART_WORDLENGTH_8B;
    huart_handle.Init.StopBits = UART_STOPBITS_1;
    huart_handle.Init.Parity = UART_PARITY_NONE;
    huart_handle.Init.Mode = UART_MODE_TX_RX;
 8006ffa:	220c      	movs	r2, #12
    huart_handle.Init.WordLength = UART_WORDLENGTH_8B;
 8006ffc:	2300      	movs	r3, #0
    huart_handle.Init.Mode = UART_MODE_TX_RX;
 8006ffe:	6142      	str	r2, [r0, #20]
    huart_handle.Init.WordLength = UART_WORDLENGTH_8B;
 8007000:	6083      	str	r3, [r0, #8]
    huart_handle.Init.StopBits = UART_STOPBITS_1;
 8007002:	60c3      	str	r3, [r0, #12]
    huart_handle.Init.Parity = UART_PARITY_NONE;
 8007004:	6103      	str	r3, [r0, #16]
    huart_handle.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8007006:	6183      	str	r3, [r0, #24]
    huart_handle.Init.OverSampling = UART_OVERSAMPLING_16;
 8007008:	61c3      	str	r3, [r0, #28]
    huart_handle.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800700a:	6203      	str	r3, [r0, #32]
    huart_handle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800700c:	6243      	str	r3, [r0, #36]	; 0x24

    /* Init of the peripheral */
    HAL_UART_Init(&huart_handle);
 800700e:	f002 faa3 	bl	8009558 <HAL_UART_Init>
}
 8007012:	bd10      	pop	{r4, pc}
 8007014:	20001bec 	.word	0x20001bec
 8007018:	40004400 	.word	0x40004400

0800701c <HAL_UART_MspInit>:
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
    GPIO_InitTypeDef GPIO_InitStruct;

    /* Peripheral clock enable */
    USBPD_BSP_USARTCLK_ENABLE();
 800701c:	2080      	movs	r0, #128	; 0x80
 800701e:	4a12      	ldr	r2, [pc, #72]	; (8007068 <HAL_UART_MspInit+0x4c>)
{
 8007020:	b530      	push	{r4, r5, lr}
    USBPD_BSP_USARTCLK_ENABLE();
 8007022:	69d1      	ldr	r1, [r2, #28]
 8007024:	0280      	lsls	r0, r0, #10
 8007026:	4301      	orrs	r1, r0
 8007028:	61d1      	str	r1, [r2, #28]
 800702a:	69d3      	ldr	r3, [r2, #28]
{
 800702c:	b087      	sub	sp, #28
    USBPD_BSP_USARTCLK_ENABLE();
 800702e:	4003      	ands	r3, r0
 8007030:	9300      	str	r3, [sp, #0]
 8007032:	9b00      	ldr	r3, [sp, #0]

    /* USART GPIO Configuration */
    GPIO_InitStruct.Pin = USART_TX_PIN | USART_RX_PIN;
 8007034:	230c      	movs	r3, #12
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = USART_PIN_GPIOAF;
    HAL_GPIO_Init(USART_TX_PORT, &GPIO_InitStruct);
 8007036:	2090      	movs	r0, #144	; 0x90
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8007038:	2500      	movs	r5, #0
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800703a:	2403      	movs	r4, #3
    GPIO_InitStruct.Pin = USART_TX_PIN | USART_RX_PIN;
 800703c:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800703e:	3b0a      	subs	r3, #10
 8007040:	9302      	str	r3, [sp, #8]
    HAL_GPIO_Init(USART_TX_PORT, &GPIO_InitStruct);
 8007042:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Alternate = USART_PIN_GPIOAF;
 8007044:	3b01      	subs	r3, #1
    HAL_GPIO_Init(USART_TX_PORT, &GPIO_InitStruct);
 8007046:	05c0      	lsls	r0, r0, #23
    GPIO_InitStruct.Alternate = USART_PIN_GPIOAF;
 8007048:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800704a:	9503      	str	r5, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800704c:	9404      	str	r4, [sp, #16]
    HAL_GPIO_Init(USART_TX_PORT, &GPIO_InitStruct);
 800704e:	f000 fcb3 	bl	80079b8 <HAL_GPIO_Init>
    
    /* Peripheral interrupt init*/
    HAL_NVIC_SetPriority(USART_IRQ, 3, 0);
 8007052:	002a      	movs	r2, r5
 8007054:	0021      	movs	r1, r4
 8007056:	201c      	movs	r0, #28
 8007058:	f000 fad4 	bl	8007604 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART_IRQ);
 800705c:	201c      	movs	r0, #28
 800705e:	f000 fafb 	bl	8007658 <HAL_NVIC_EnableIRQ>
}
 8007062:	b007      	add	sp, #28
 8007064:	bd30      	pop	{r4, r5, pc}
 8007066:	46c0      	nop			; (mov r8, r8)
 8007068:	40021000 	.word	0x40021000

0800706c <SystemInit>:
  */
void SystemInit(void)
{
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001U;
 800706c:	2101      	movs	r1, #1
 800706e:	4b11      	ldr	r3, [pc, #68]	; (80070b4 <SystemInit+0x48>)
#if defined (STM32F051x8) || defined (STM32F058x8)
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE and MCOSEL[2:0] bits */
  RCC->CFGR &= (uint32_t)0xF8FFB80CU;
#else
  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */
  RCC->CFGR &= (uint32_t)0x08FFB80CU;
 8007070:	4811      	ldr	r0, [pc, #68]	; (80070b8 <SystemInit+0x4c>)
  RCC->CR |= (uint32_t)0x00000001U;
 8007072:	681a      	ldr	r2, [r3, #0]
 8007074:	430a      	orrs	r2, r1
 8007076:	601a      	str	r2, [r3, #0]
  RCC->CFGR &= (uint32_t)0x08FFB80CU;
 8007078:	685a      	ldr	r2, [r3, #4]
 800707a:	4002      	ands	r2, r0
 800707c:	605a      	str	r2, [r3, #4]
#endif /* STM32F051x8 or STM32F058x8 */
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFFU;
 800707e:	681a      	ldr	r2, [r3, #0]
 8007080:	480e      	ldr	r0, [pc, #56]	; (80070bc <SystemInit+0x50>)
 8007082:	4002      	ands	r2, r0
 8007084:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFFU;
 8007086:	681a      	ldr	r2, [r3, #0]
 8007088:	480d      	ldr	r0, [pc, #52]	; (80070c0 <SystemInit+0x54>)
 800708a:	4002      	ands	r2, r0
 800708c:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  RCC->CFGR &= (uint32_t)0xFFC0FFFFU;
 800708e:	685a      	ldr	r2, [r3, #4]
 8007090:	480c      	ldr	r0, [pc, #48]	; (80070c4 <SystemInit+0x58>)
 8007092:	4002      	ands	r2, r0

  /* Reset PREDIV[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0U;
 8007094:	200f      	movs	r0, #15
  RCC->CFGR &= (uint32_t)0xFFC0FFFFU;
 8007096:	605a      	str	r2, [r3, #4]
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0U;
 8007098:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800709a:	4382      	bics	r2, r0
 800709c:	62da      	str	r2, [r3, #44]	; 0x2c

#if defined (STM32F072xB) || defined (STM32F078xx)
  /* Reset USART2SW[1:0], USART1SW[1:0], I2C1SW, CECSW, USBSW and ADCSW bits */
  RCC->CFGR3 &= (uint32_t)0xFFFCFE2CU;
 800709e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80070a0:	4809      	ldr	r0, [pc, #36]	; (80070c8 <SystemInit+0x5c>)
 80070a2:	4002      	ands	r2, r0
 80070a4:	631a      	str	r2, [r3, #48]	; 0x30
#else
 #warning "No target selected"
#endif

  /* Reset HSI14 bit */
  RCC->CR2 &= (uint32_t)0xFFFFFFFEU;
 80070a6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80070a8:	438a      	bics	r2, r1
 80070aa:	635a      	str	r2, [r3, #52]	; 0x34

  /* Disable all interrupts */
  RCC->CIR = 0x00000000U;
 80070ac:	2200      	movs	r2, #0
 80070ae:	609a      	str	r2, [r3, #8]

}
 80070b0:	4770      	bx	lr
 80070b2:	46c0      	nop			; (mov r8, r8)
 80070b4:	40021000 	.word	0x40021000
 80070b8:	08ffb80c 	.word	0x08ffb80c
 80070bc:	fef6ffff 	.word	0xfef6ffff
 80070c0:	fffbffff 	.word	0xfffbffff
 80070c4:	ffc0ffff 	.word	0xffc0ffff
 80070c8:	fffcfe2c 	.word	0xfffcfe2c

080070cc <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80070cc:	b510      	push	{r4, lr}
 80070ce:	0004      	movs	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000U);
 80070d0:	f001 f8c6 	bl	8008260 <HAL_RCC_GetHCLKFreq>
 80070d4:	21fa      	movs	r1, #250	; 0xfa
 80070d6:	0089      	lsls	r1, r1, #2
 80070d8:	f7fe fc76 	bl	80059c8 <__udivsi3>
 80070dc:	f000 fac6 	bl	800766c <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 80070e0:	2001      	movs	r0, #1
 80070e2:	2200      	movs	r2, #0
 80070e4:	0021      	movs	r1, r4
 80070e6:	4240      	negs	r0, r0
 80070e8:	f000 fa8c 	bl	8007604 <HAL_NVIC_SetPriority>

   /* Return function status */
  return HAL_OK;
}
 80070ec:	2000      	movs	r0, #0
 80070ee:	bd10      	pop	{r4, pc}

080070f0 <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80070f0:	2310      	movs	r3, #16
 80070f2:	4a06      	ldr	r2, [pc, #24]	; (800710c <HAL_Init+0x1c>)
{
 80070f4:	b510      	push	{r4, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80070f6:	6811      	ldr	r1, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 80070f8:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80070fa:	430b      	orrs	r3, r1
 80070fc:	6013      	str	r3, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 80070fe:	f7ff ffe5 	bl	80070cc <HAL_InitTick>
  HAL_MspInit();
 8007102:	f7fe fe81 	bl	8005e08 <HAL_MspInit>
}
 8007106:	2000      	movs	r0, #0
 8007108:	bd10      	pop	{r4, pc}
 800710a:	46c0      	nop			; (mov r8, r8)
 800710c:	40022000 	.word	0x40022000

08007110 <HAL_IncTick>:
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8007110:	4a02      	ldr	r2, [pc, #8]	; (800711c <HAL_IncTick+0xc>)
 8007112:	6813      	ldr	r3, [r2, #0]
 8007114:	3301      	adds	r3, #1
 8007116:	6013      	str	r3, [r2, #0]
}
 8007118:	4770      	bx	lr
 800711a:	46c0      	nop			; (mov r8, r8)
 800711c:	20001c5c 	.word	0x20001c5c

08007120 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8007120:	4b01      	ldr	r3, [pc, #4]	; (8007128 <HAL_GetTick+0x8>)
 8007122:	6818      	ldr	r0, [r3, #0]
}
 8007124:	4770      	bx	lr
 8007126:	46c0      	nop			; (mov r8, r8)
 8007128:	20001c5c 	.word	0x20001c5c

0800712c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 800712c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800712e:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = HAL_GetTick();
 8007130:	f7ff fff6 	bl	8007120 <HAL_GetTick>
  uint32_t wait = Delay;
 8007134:	9c01      	ldr	r4, [sp, #4]
  uint32_t tickstart = HAL_GetTick();
 8007136:	0005      	movs	r5, r0
  
  /* Add a period to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
  {
     wait++;
 8007138:	1c63      	adds	r3, r4, #1
 800713a:	1e5a      	subs	r2, r3, #1
 800713c:	4193      	sbcs	r3, r2
 800713e:	18e4      	adds	r4, r4, r3
  }
  
  while((HAL_GetTick() - tickstart) < wait)
 8007140:	f7ff ffee 	bl	8007120 <HAL_GetTick>
 8007144:	1b40      	subs	r0, r0, r5
 8007146:	42a0      	cmp	r0, r4
 8007148:	d3fa      	bcc.n	8007140 <HAL_Delay+0x14>
  {
  }
}
 800714a:	bd37      	pop	{r0, r1, r2, r4, r5, pc}

0800714c <ADC_Enable>:
  * @retval HAL status.
  */
static HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
{
  uint32_t tickstart = 0U;
  __IO uint32_t wait_loop_index = 0U;
 800714c:	2300      	movs	r3, #0
{
 800714e:	b573      	push	{r0, r1, r4, r5, r6, lr}
  
  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (ADC_IS_ENABLE(hadc) == RESET)
 8007150:	2103      	movs	r1, #3
  __IO uint32_t wait_loop_index = 0U;
 8007152:	9301      	str	r3, [sp, #4]
  if (ADC_IS_ENABLE(hadc) == RESET)
 8007154:	6803      	ldr	r3, [r0, #0]
{
 8007156:	0004      	movs	r4, r0
  if (ADC_IS_ENABLE(hadc) == RESET)
 8007158:	689a      	ldr	r2, [r3, #8]
 800715a:	400a      	ands	r2, r1
 800715c:	2a01      	cmp	r2, #1
 800715e:	d107      	bne.n	8007170 <ADC_Enable+0x24>
 8007160:	6819      	ldr	r1, [r3, #0]
 8007162:	4211      	tst	r1, r2
 8007164:	d001      	beq.n	800716a <ADC_Enable+0x1e>
    }   
    
  }
   
  /* Return HAL status */
  return HAL_OK;
 8007166:	2000      	movs	r0, #0
}
 8007168:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
  if (ADC_IS_ENABLE(hadc) == RESET)
 800716a:	68da      	ldr	r2, [r3, #12]
 800716c:	0412      	lsls	r2, r2, #16
 800716e:	d4fa      	bmi.n	8007166 <ADC_Enable+0x1a>
    if (ADC_ENABLING_CONDITIONS(hadc) == RESET)
 8007170:	6899      	ldr	r1, [r3, #8]
 8007172:	4a19      	ldr	r2, [pc, #100]	; (80071d8 <ADC_Enable+0x8c>)
 8007174:	4211      	tst	r1, r2
 8007176:	d008      	beq.n	800718a <ADC_Enable+0x3e>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007178:	2310      	movs	r3, #16
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800717a:	2001      	movs	r0, #1
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800717c:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800717e:	4313      	orrs	r3, r2
 8007180:	6463      	str	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007182:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8007184:	4303      	orrs	r3, r0
 8007186:	64a3      	str	r3, [r4, #72]	; 0x48
      return HAL_ERROR;
 8007188:	e7ee      	b.n	8007168 <ADC_Enable+0x1c>
    __HAL_ADC_ENABLE(hadc);
 800718a:	2201      	movs	r2, #1
 800718c:	6899      	ldr	r1, [r3, #8]
 800718e:	430a      	orrs	r2, r1
 8007190:	609a      	str	r2, [r3, #8]
    wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 8007192:	4b12      	ldr	r3, [pc, #72]	; (80071dc <ADC_Enable+0x90>)
 8007194:	4912      	ldr	r1, [pc, #72]	; (80071e0 <ADC_Enable+0x94>)
 8007196:	6818      	ldr	r0, [r3, #0]
 8007198:	f7fe fc16 	bl	80059c8 <__udivsi3>
 800719c:	9001      	str	r0, [sp, #4]
    while(wait_loop_index != 0U)
 800719e:	9b01      	ldr	r3, [sp, #4]
 80071a0:	2b00      	cmp	r3, #0
 80071a2:	d115      	bne.n	80071d0 <ADC_Enable+0x84>
    tickstart = HAL_GetTick();
 80071a4:	f7ff ffbc 	bl	8007120 <HAL_GetTick>
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
 80071a8:	2501      	movs	r5, #1
    tickstart = HAL_GetTick();
 80071aa:	0006      	movs	r6, r0
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
 80071ac:	6823      	ldr	r3, [r4, #0]
 80071ae:	681b      	ldr	r3, [r3, #0]
 80071b0:	422b      	tst	r3, r5
 80071b2:	d1d8      	bne.n	8007166 <ADC_Enable+0x1a>
      if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 80071b4:	f7ff ffb4 	bl	8007120 <HAL_GetTick>
 80071b8:	1b80      	subs	r0, r0, r6
 80071ba:	2802      	cmp	r0, #2
 80071bc:	d9f6      	bls.n	80071ac <ADC_Enable+0x60>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80071be:	2310      	movs	r3, #16
 80071c0:	6c62      	ldr	r2, [r4, #68]	; 0x44
        return HAL_ERROR;
 80071c2:	2001      	movs	r0, #1
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80071c4:	4313      	orrs	r3, r2
 80071c6:	6463      	str	r3, [r4, #68]	; 0x44
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80071c8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80071ca:	432b      	orrs	r3, r5
 80071cc:	64a3      	str	r3, [r4, #72]	; 0x48
        return HAL_ERROR;
 80071ce:	e7cb      	b.n	8007168 <ADC_Enable+0x1c>
      wait_loop_index--;
 80071d0:	9b01      	ldr	r3, [sp, #4]
 80071d2:	3b01      	subs	r3, #1
 80071d4:	9301      	str	r3, [sp, #4]
 80071d6:	e7e2      	b.n	800719e <ADC_Enable+0x52>
 80071d8:	80000017 	.word	0x80000017
 80071dc:	20000030 	.word	0x20000030
 80071e0:	000f4240 	.word	0x000f4240

080071e4 <HAL_ADC_Init>:
{
 80071e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80071e6:	0004      	movs	r4, r0
    return HAL_ERROR;
 80071e8:	2001      	movs	r0, #1
  if(hadc == NULL)
 80071ea:	2c00      	cmp	r4, #0
 80071ec:	d07d      	beq.n	80072ea <HAL_ADC_Init+0x106>
  if (hadc->State == HAL_ADC_STATE_RESET)
 80071ee:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80071f0:	2b00      	cmp	r3, #0
 80071f2:	d106      	bne.n	8007202 <HAL_ADC_Init+0x1e>
    hadc->Lock = HAL_UNLOCKED;
 80071f4:	0022      	movs	r2, r4
 80071f6:	3240      	adds	r2, #64	; 0x40
    ADC_CLEAR_ERRORCODE(hadc);
 80071f8:	64a3      	str	r3, [r4, #72]	; 0x48
    HAL_ADC_MspInit(hadc);
 80071fa:	0020      	movs	r0, r4
    hadc->Lock = HAL_UNLOCKED;
 80071fc:	7013      	strb	r3, [r2, #0]
    HAL_ADC_MspInit(hadc);
 80071fe:	f7fe fe3f 	bl	8005e80 <HAL_ADC_MspInit>
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
 8007202:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007204:	06db      	lsls	r3, r3, #27
 8007206:	d500      	bpl.n	800720a <HAL_ADC_Init+0x26>
 8007208:	e084      	b.n	8007314 <HAL_ADC_Init+0x130>
      (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)          )
 800720a:	2204      	movs	r2, #4
 800720c:	6823      	ldr	r3, [r4, #0]
 800720e:	6898      	ldr	r0, [r3, #8]
 8007210:	4010      	ands	r0, r2
      (tmp_hal_status == HAL_OK)                                &&
 8007212:	d000      	beq.n	8007216 <HAL_ADC_Init+0x32>
 8007214:	e07e      	b.n	8007314 <HAL_ADC_Init+0x130>
    ADC_STATE_CLR_SET(hadc->State,
 8007216:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8007218:	4941      	ldr	r1, [pc, #260]	; (8007320 <HAL_ADC_Init+0x13c>)
 800721a:	4011      	ands	r1, r2
 800721c:	2202      	movs	r2, #2
 800721e:	430a      	orrs	r2, r1
    if (ADC_IS_ENABLE(hadc) == RESET)
 8007220:	2103      	movs	r1, #3
    ADC_STATE_CLR_SET(hadc->State,
 8007222:	6462      	str	r2, [r4, #68]	; 0x44
    if (ADC_IS_ENABLE(hadc) == RESET)
 8007224:	689a      	ldr	r2, [r3, #8]
 8007226:	400a      	ands	r2, r1
 8007228:	2a01      	cmp	r2, #1
 800722a:	d105      	bne.n	8007238 <HAL_ADC_Init+0x54>
 800722c:	6819      	ldr	r1, [r3, #0]
 800722e:	4211      	tst	r1, r2
 8007230:	d10e      	bne.n	8007250 <HAL_ADC_Init+0x6c>
 8007232:	68da      	ldr	r2, [r3, #12]
 8007234:	0412      	lsls	r2, r2, #16
 8007236:	d40b      	bmi.n	8007250 <HAL_ADC_Init+0x6c>
      MODIFY_REG(hadc->Instance->CFGR1,
 8007238:	2118      	movs	r1, #24
 800723a:	68da      	ldr	r2, [r3, #12]
 800723c:	438a      	bics	r2, r1
 800723e:	68a1      	ldr	r1, [r4, #8]
 8007240:	430a      	orrs	r2, r1
 8007242:	60da      	str	r2, [r3, #12]
      MODIFY_REG(hadc->Instance->CFGR2    ,
 8007244:	6919      	ldr	r1, [r3, #16]
 8007246:	6862      	ldr	r2, [r4, #4]
 8007248:	0089      	lsls	r1, r1, #2
 800724a:	0889      	lsrs	r1, r1, #2
 800724c:	4311      	orrs	r1, r2
 800724e:	6119      	str	r1, [r3, #16]
    hadc->Instance->CFGR1 &= ~( ADC_CFGR1_DISCEN  |
 8007250:	68da      	ldr	r2, [r3, #12]
 8007252:	4934      	ldr	r1, [pc, #208]	; (8007324 <HAL_ADC_Init+0x140>)
                 ADC_CFGR1_CONTINUOUS(hadc->Init.ContinuousConvMode)    |
 8007254:	6a25      	ldr	r5, [r4, #32]
    hadc->Instance->CFGR1 &= ~( ADC_CFGR1_DISCEN  |
 8007256:	400a      	ands	r2, r1
 8007258:	60da      	str	r2, [r3, #12]
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
 800725a:	69a2      	ldr	r2, [r4, #24]
                 ADC_CFGR1_CONTINUOUS(hadc->Init.ContinuousConvMode)    |
 800725c:	036f      	lsls	r7, r5, #13
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
 800725e:	0391      	lsls	r1, r2, #14
                 ADC_CFGR1_AUTOOFF(hadc->Init.LowPowerAutoPowerOff)     |
 8007260:	69e2      	ldr	r2, [r4, #28]
 8007262:	03d2      	lsls	r2, r2, #15
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT(hadc->Init.LowPowerAutoWait)        |
 8007264:	4311      	orrs	r1, r2
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                  |
 8007266:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8007268:	3a01      	subs	r2, #1
 800726a:	1e56      	subs	r6, r2, #1
 800726c:	41b2      	sbcs	r2, r6
 800726e:	0316      	lsls	r6, r2, #12
 8007270:	68e2      	ldr	r2, [r4, #12]
 8007272:	4311      	orrs	r1, r2
                 ADC_SCANDIR(hadc->Init.ScanConvMode)                   |
 8007274:	6922      	ldr	r2, [r4, #16]
 8007276:	430f      	orrs	r7, r1
 8007278:	2a02      	cmp	r2, #2
 800727a:	d100      	bne.n	800727e <HAL_ADC_Init+0x9a>
 800727c:	2004      	movs	r0, #4
                 ADC_CFGR1_DMACONTREQ(hadc->Init.DMAContinuousRequests)  );
 800727e:	6b22      	ldr	r2, [r4, #48]	; 0x30
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8007280:	6a61      	ldr	r1, [r4, #36]	; 0x24
                 ADC_CFGR1_DMACONTREQ(hadc->Init.DMAContinuousRequests)  );
 8007282:	0052      	lsls	r2, r2, #1
                 ADC_SCANDIR(hadc->Init.ScanConvMode)                   |
 8007284:	433a      	orrs	r2, r7
 8007286:	4332      	orrs	r2, r6
 8007288:	4302      	orrs	r2, r0
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 800728a:	2901      	cmp	r1, #1
 800728c:	d104      	bne.n	8007298 <HAL_ADC_Init+0xb4>
      if (hadc->Init.ContinuousConvMode == DISABLE)
 800728e:	2d00      	cmp	r5, #0
 8007290:	d12c      	bne.n	80072ec <HAL_ADC_Init+0x108>
        tmpCFGR1 |= ADC_CFGR1_DISCEN;
 8007292:	2180      	movs	r1, #128	; 0x80
 8007294:	0249      	lsls	r1, r1, #9
 8007296:	430a      	orrs	r2, r1
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8007298:	20c2      	movs	r0, #194	; 0xc2
 800729a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800729c:	30ff      	adds	r0, #255	; 0xff
 800729e:	4281      	cmp	r1, r0
 80072a0:	d002      	beq.n	80072a8 <HAL_ADC_Init+0xc4>
      tmpCFGR1 |= ( hadc->Init.ExternalTrigConv    |
 80072a2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80072a4:	4301      	orrs	r1, r0
 80072a6:	430a      	orrs	r2, r1
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80072a8:	2080      	movs	r0, #128	; 0x80
    hadc->Instance->CFGR1 |= tmpCFGR1;
 80072aa:	68d9      	ldr	r1, [r3, #12]
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80072ac:	0540      	lsls	r0, r0, #21
    hadc->Instance->CFGR1 |= tmpCFGR1;
 80072ae:	4311      	orrs	r1, r2
 80072b0:	60d9      	str	r1, [r3, #12]
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 80072b2:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80072b4:	4281      	cmp	r1, r0
 80072b6:	d002      	beq.n	80072be <HAL_ADC_Init+0xda>
 80072b8:	1e48      	subs	r0, r1, #1
 80072ba:	2806      	cmp	r0, #6
 80072bc:	d807      	bhi.n	80072ce <HAL_ADC_Init+0xea>
      hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 80072be:	2507      	movs	r5, #7
 80072c0:	6958      	ldr	r0, [r3, #20]
      hadc->Instance->SMPR |= ADC_SMPR_SET(hadc->Init.SamplingTimeCommon);
 80072c2:	4029      	ands	r1, r5
      hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 80072c4:	43a8      	bics	r0, r5
 80072c6:	6158      	str	r0, [r3, #20]
      hadc->Instance->SMPR |= ADC_SMPR_SET(hadc->Init.SamplingTimeCommon);
 80072c8:	6958      	ldr	r0, [r3, #20]
 80072ca:	4301      	orrs	r1, r0
 80072cc:	6159      	str	r1, [r3, #20]
    if ((hadc->Instance->CFGR1 & ~(ADC_CFGR1_AWDCH | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL | ADC_CFGR1_RES))
 80072ce:	68db      	ldr	r3, [r3, #12]
 80072d0:	4915      	ldr	r1, [pc, #84]	; (8007328 <HAL_ADC_Init+0x144>)
 80072d2:	400b      	ands	r3, r1
 80072d4:	4293      	cmp	r3, r2
 80072d6:	d111      	bne.n	80072fc <HAL_ADC_Init+0x118>
      ADC_CLEAR_ERRORCODE(hadc);
 80072d8:	2000      	movs	r0, #0
      ADC_STATE_CLR_SET(hadc->State,
 80072da:	2203      	movs	r2, #3
      ADC_CLEAR_ERRORCODE(hadc);
 80072dc:	64a0      	str	r0, [r4, #72]	; 0x48
      ADC_STATE_CLR_SET(hadc->State,
 80072de:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80072e0:	4393      	bics	r3, r2
 80072e2:	001a      	movs	r2, r3
 80072e4:	2301      	movs	r3, #1
 80072e6:	4313      	orrs	r3, r2
 80072e8:	6463      	str	r3, [r4, #68]	; 0x44
}
 80072ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80072ec:	2020      	movs	r0, #32
 80072ee:	6c65      	ldr	r5, [r4, #68]	; 0x44
 80072f0:	4328      	orrs	r0, r5
 80072f2:	6460      	str	r0, [r4, #68]	; 0x44
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80072f4:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 80072f6:	4301      	orrs	r1, r0
 80072f8:	64a1      	str	r1, [r4, #72]	; 0x48
 80072fa:	e7cd      	b.n	8007298 <HAL_ADC_Init+0xb4>
      ADC_STATE_CLR_SET(hadc->State,
 80072fc:	2212      	movs	r2, #18
 80072fe:	6c63      	ldr	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8007300:	2001      	movs	r0, #1
      ADC_STATE_CLR_SET(hadc->State,
 8007302:	4393      	bics	r3, r2
 8007304:	001a      	movs	r2, r3
 8007306:	2310      	movs	r3, #16
 8007308:	4313      	orrs	r3, r2
 800730a:	6463      	str	r3, [r4, #68]	; 0x44
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800730c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800730e:	4303      	orrs	r3, r0
 8007310:	64a3      	str	r3, [r4, #72]	; 0x48
 8007312:	e7ea      	b.n	80072ea <HAL_ADC_Init+0x106>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007314:	2310      	movs	r3, #16
 8007316:	6c62      	ldr	r2, [r4, #68]	; 0x44
    tmp_hal_status = HAL_ERROR;
 8007318:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800731a:	4313      	orrs	r3, r2
 800731c:	6463      	str	r3, [r4, #68]	; 0x44
 800731e:	e7e4      	b.n	80072ea <HAL_ADC_Init+0x106>
 8007320:	fffffefd 	.word	0xfffffefd
 8007324:	fffe0219 	.word	0xfffe0219
 8007328:	833fffe7 	.word	0x833fffe7

0800732c <HAL_ADC_Start_DMA>:
{
 800732c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 800732e:	6803      	ldr	r3, [r0, #0]
{
 8007330:	0004      	movs	r4, r0
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8007332:	689b      	ldr	r3, [r3, #8]
{
 8007334:	000f      	movs	r7, r1
 8007336:	9201      	str	r2, [sp, #4]
    tmp_hal_status = HAL_BUSY;
 8007338:	2002      	movs	r0, #2
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 800733a:	075b      	lsls	r3, r3, #29
 800733c:	d430      	bmi.n	80073a0 <HAL_ADC_Start_DMA+0x74>
    __HAL_LOCK(hadc);
 800733e:	0026      	movs	r6, r4
 8007340:	3640      	adds	r6, #64	; 0x40
 8007342:	7833      	ldrb	r3, [r6, #0]
 8007344:	2b01      	cmp	r3, #1
 8007346:	d02b      	beq.n	80073a0 <HAL_ADC_Start_DMA+0x74>
 8007348:	2301      	movs	r3, #1
 800734a:	7033      	strb	r3, [r6, #0]
    if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
 800734c:	69e3      	ldr	r3, [r4, #28]
 800734e:	2b01      	cmp	r3, #1
 8007350:	d127      	bne.n	80073a2 <HAL_ADC_Start_DMA+0x76>
      ADC_STATE_CLR_SET(hadc->State,
 8007352:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007354:	4a16      	ldr	r2, [pc, #88]	; (80073b0 <HAL_ADC_Start_DMA+0x84>)
      ADC_CLEAR_ERRORCODE(hadc);
 8007356:	2500      	movs	r5, #0
      ADC_STATE_CLR_SET(hadc->State,
 8007358:	401a      	ands	r2, r3
 800735a:	2380      	movs	r3, #128	; 0x80
 800735c:	005b      	lsls	r3, r3, #1
 800735e:	4313      	orrs	r3, r2
 8007360:	6463      	str	r3, [r4, #68]	; 0x44
      hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 8007362:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8007364:	4b13      	ldr	r3, [pc, #76]	; (80073b4 <HAL_ADC_Start_DMA+0x88>)
      ADC_CLEAR_ERRORCODE(hadc);
 8007366:	64a5      	str	r5, [r4, #72]	; 0x48
      __HAL_UNLOCK(hadc);
 8007368:	7035      	strb	r5, [r6, #0]
      hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 800736a:	6283      	str	r3, [r0, #40]	; 0x28
      hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 800736c:	4b12      	ldr	r3, [pc, #72]	; (80073b8 <HAL_ADC_Start_DMA+0x8c>)
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 800736e:	6821      	ldr	r1, [r4, #0]
      hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 8007370:	62c3      	str	r3, [r0, #44]	; 0x2c
      hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 8007372:	4b12      	ldr	r3, [pc, #72]	; (80073bc <HAL_ADC_Start_DMA+0x90>)
 8007374:	6303      	str	r3, [r0, #48]	; 0x30
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8007376:	231c      	movs	r3, #28
 8007378:	600b      	str	r3, [r1, #0]
      __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 800737a:	684a      	ldr	r2, [r1, #4]
 800737c:	3b0c      	subs	r3, #12
 800737e:	4313      	orrs	r3, r2
 8007380:	604b      	str	r3, [r1, #4]
      hadc->Instance->CFGR1 |= ADC_CFGR1_DMAEN;
 8007382:	2301      	movs	r3, #1
 8007384:	68ca      	ldr	r2, [r1, #12]
 8007386:	4313      	orrs	r3, r2
 8007388:	60cb      	str	r3, [r1, #12]
      HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 800738a:	003a      	movs	r2, r7
 800738c:	3140      	adds	r1, #64	; 0x40
 800738e:	9b01      	ldr	r3, [sp, #4]
 8007390:	f000 fac0 	bl	8007914 <HAL_DMA_Start_IT>
      hadc->Instance->CR |= ADC_CR_ADSTART;
 8007394:	2304      	movs	r3, #4
 8007396:	0028      	movs	r0, r5
 8007398:	6822      	ldr	r2, [r4, #0]
 800739a:	6891      	ldr	r1, [r2, #8]
 800739c:	430b      	orrs	r3, r1
 800739e:	6093      	str	r3, [r2, #8]
}
 80073a0:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      tmp_hal_status = ADC_Enable(hadc);
 80073a2:	0020      	movs	r0, r4
 80073a4:	f7ff fed2 	bl	800714c <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 80073a8:	2800      	cmp	r0, #0
 80073aa:	d0d2      	beq.n	8007352 <HAL_ADC_Start_DMA+0x26>
 80073ac:	e7f8      	b.n	80073a0 <HAL_ADC_Start_DMA+0x74>
 80073ae:	46c0      	nop			; (mov r8, r8)
 80073b0:	fffff0fe 	.word	0xfffff0fe
 80073b4:	080073c5 	.word	0x080073c5
 80073b8:	08007437 	.word	0x08007437
 80073bc:	08007443 	.word	0x08007443

080073c0 <HAL_ADC_ConvCpltCallback>:
 80073c0:	4770      	bx	lr
	...

080073c4 <ADC_DMAConvCplt>:
{
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Update state machine on conversion status if not in error state */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
 80073c4:	2250      	movs	r2, #80	; 0x50
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 80073c6:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
 80073c8:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
 80073ca:	6c59      	ldr	r1, [r3, #68]	; 0x44
 80073cc:	4211      	tst	r1, r2
 80073ce:	d12a      	bne.n	8007426 <ADC_DMAConvCplt+0x62>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
 80073d0:	6c59      	ldr	r1, [r3, #68]	; 0x44
 80073d2:	32b1      	adds	r2, #177	; 0xb1
 80073d4:	32ff      	adds	r2, #255	; 0xff
 80073d6:	430a      	orrs	r2, r1
    
    /* Determine whether any further conversion upcoming on group regular     */
    /* by external trigger, continuous mode or scan sequence on going.        */
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 80073d8:	21c0      	movs	r1, #192	; 0xc0
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
 80073da:	645a      	str	r2, [r3, #68]	; 0x44
    if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 80073dc:	681a      	ldr	r2, [r3, #0]
 80073de:	0109      	lsls	r1, r1, #4
 80073e0:	68d0      	ldr	r0, [r2, #12]
 80073e2:	4208      	tst	r0, r1
 80073e4:	d112      	bne.n	800740c <ADC_DMAConvCplt+0x48>
 80073e6:	6a19      	ldr	r1, [r3, #32]
 80073e8:	2900      	cmp	r1, #0
 80073ea:	d10f      	bne.n	800740c <ADC_DMAConvCplt+0x48>
       (hadc->Init.ContinuousConvMode == DISABLE)   )
    {
      /* If End of Sequence is reached, disable interrupts */
      if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )
 80073ec:	6811      	ldr	r1, [r2, #0]
 80073ee:	0709      	lsls	r1, r1, #28
 80073f0:	d50c      	bpl.n	800740c <ADC_DMAConvCplt+0x48>
      {
        /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit           */
        /* ADSTART==0 (no conversion on going)                                */
        if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 80073f2:	6891      	ldr	r1, [r2, #8]
 80073f4:	0749      	lsls	r1, r1, #29
 80073f6:	d40d      	bmi.n	8007414 <ADC_DMAConvCplt+0x50>
        {
          /* Disable ADC end of single conversion interrupt on group regular */
          /* Note: Overrun interrupt was enabled with EOC interrupt in        */
          /* HAL_Start_IT(), but is not disabled here because can be used     */
          /* by overrun IRQ process below.                                    */
          __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 80073f8:	200c      	movs	r0, #12
 80073fa:	6851      	ldr	r1, [r2, #4]
 80073fc:	4381      	bics	r1, r0
 80073fe:	6051      	str	r1, [r2, #4]
          
          /* Set ADC state */
          ADC_STATE_CLR_SET(hadc->State,
 8007400:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8007402:	490b      	ldr	r1, [pc, #44]	; (8007430 <ADC_DMAConvCplt+0x6c>)
 8007404:	4011      	ands	r1, r2
 8007406:	2201      	movs	r2, #1
 8007408:	430a      	orrs	r2, r1
 800740a:	645a      	str	r2, [r3, #68]	; 0x44
        }
      }
    }

    /* Conversion complete callback */
    HAL_ADC_ConvCpltCallback(hadc); 
 800740c:	0018      	movs	r0, r3
 800740e:	f7ff ffd7 	bl	80073c0 <HAL_ADC_ConvCpltCallback>
  {
    /* Call DMA error callback */
    hadc->DMA_Handle->XferErrorCallback(hdma);
  }

}
 8007412:	bd10      	pop	{r4, pc}
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8007414:	2220      	movs	r2, #32
 8007416:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8007418:	430a      	orrs	r2, r1
 800741a:	645a      	str	r2, [r3, #68]	; 0x44
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800741c:	2201      	movs	r2, #1
 800741e:	6c99      	ldr	r1, [r3, #72]	; 0x48
 8007420:	430a      	orrs	r2, r1
 8007422:	649a      	str	r2, [r3, #72]	; 0x48
 8007424:	e7f2      	b.n	800740c <ADC_DMAConvCplt+0x48>
    hadc->DMA_Handle->XferErrorCallback(hdma);
 8007426:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8007428:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800742a:	4798      	blx	r3
}
 800742c:	e7f1      	b.n	8007412 <ADC_DMAConvCplt+0x4e>
 800742e:	46c0      	nop			; (mov r8, r8)
 8007430:	fffffefe 	.word	0xfffffefe

08007434 <HAL_ADC_ConvHalfCpltCallback>:
 8007434:	4770      	bx	lr

08007436 <ADC_DMAHalfConvCplt>:
  * @brief  DMA half transfer complete callback. 
  * @param  hdma: pointer to DMA handle.
  * @retval None
  */
static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
{
 8007436:	b510      	push	{r4, lr}
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Half conversion callback */
  HAL_ADC_ConvHalfCpltCallback(hadc); 
 8007438:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800743a:	f7ff fffb 	bl	8007434 <HAL_ADC_ConvHalfCpltCallback>
}
 800743e:	bd10      	pop	{r4, pc}

08007440 <HAL_ADC_ErrorCallback>:
 8007440:	4770      	bx	lr

08007442 <ADC_DMAError>:
{
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
  
  /* Set ADC state */
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 8007442:	2340      	movs	r3, #64	; 0x40
  ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8007444:	6a40      	ldr	r0, [r0, #36]	; 0x24
{
 8007446:	b510      	push	{r4, lr}
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 8007448:	6c42      	ldr	r2, [r0, #68]	; 0x44
 800744a:	4313      	orrs	r3, r2
 800744c:	6443      	str	r3, [r0, #68]	; 0x44
  
  /* Set ADC error code to DMA error */
  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
 800744e:	2304      	movs	r3, #4
 8007450:	6c82      	ldr	r2, [r0, #72]	; 0x48
 8007452:	4313      	orrs	r3, r2
 8007454:	6483      	str	r3, [r0, #72]	; 0x48
  
  /* Error callback */
  HAL_ADC_ErrorCallback(hadc); 
 8007456:	f7ff fff3 	bl	8007440 <HAL_ADC_ErrorCallback>
}
 800745a:	bd10      	pop	{r4, pc}

0800745c <HAL_ADC_ConfigChannel>:
{
 800745c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __IO uint32_t wait_loop_index = 0U;
 800745e:	2200      	movs	r2, #0
  __HAL_LOCK(hadc);
 8007460:	0004      	movs	r4, r0
  __IO uint32_t wait_loop_index = 0U;
 8007462:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 8007464:	3440      	adds	r4, #64	; 0x40
 8007466:	7822      	ldrb	r2, [r4, #0]
{
 8007468:	0003      	movs	r3, r0
  __HAL_LOCK(hadc);
 800746a:	2002      	movs	r0, #2
 800746c:	2a01      	cmp	r2, #1
 800746e:	d02b      	beq.n	80074c8 <HAL_ADC_ConfigChannel+0x6c>
 8007470:	2201      	movs	r2, #1
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8007472:	681d      	ldr	r5, [r3, #0]
  if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8007474:	6b9e      	ldr	r6, [r3, #56]	; 0x38
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8007476:	68a8      	ldr	r0, [r5, #8]
  __HAL_LOCK(hadc);
 8007478:	7022      	strb	r2, [r4, #0]
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 800747a:	0740      	lsls	r0, r0, #29
 800747c:	d45a      	bmi.n	8007534 <HAL_ADC_ConfigChannel+0xd8>
 800747e:	680b      	ldr	r3, [r1, #0]
    if (sConfig->Rank != ADC_RANK_NONE)
 8007480:	482f      	ldr	r0, [pc, #188]	; (8007540 <HAL_ADC_ConfigChannel+0xe4>)
 8007482:	001f      	movs	r7, r3
 8007484:	4684      	mov	ip, r0
 8007486:	6848      	ldr	r0, [r1, #4]
 8007488:	409a      	lsls	r2, r3
 800748a:	3f10      	subs	r7, #16
 800748c:	4560      	cmp	r0, ip
 800748e:	d03b      	beq.n	8007508 <HAL_ADC_ConfigChannel+0xac>
      hadc->Instance->CHSELR |= ADC_CHSELR_CHANNEL(sConfig->Channel);
 8007490:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 8007492:	4310      	orrs	r0, r2
      if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8007494:	2280      	movs	r2, #128	; 0x80
      hadc->Instance->CHSELR |= ADC_CHSELR_CHANNEL(sConfig->Channel);
 8007496:	62a8      	str	r0, [r5, #40]	; 0x28
      if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8007498:	0552      	lsls	r2, r2, #21
 800749a:	4296      	cmp	r6, r2
 800749c:	d00f      	beq.n	80074be <HAL_ADC_ConfigChannel+0x62>
 800749e:	3e01      	subs	r6, #1
 80074a0:	2e06      	cmp	r6, #6
 80074a2:	d90c      	bls.n	80074be <HAL_ADC_ConfigChannel+0x62>
        if (sConfig->SamplingTime != ADC_GET_SAMPLINGTIME(hadc))
 80074a4:	688a      	ldr	r2, [r1, #8]
 80074a6:	2107      	movs	r1, #7
 80074a8:	6968      	ldr	r0, [r5, #20]
 80074aa:	4008      	ands	r0, r1
 80074ac:	4282      	cmp	r2, r0
 80074ae:	d006      	beq.n	80074be <HAL_ADC_ConfigChannel+0x62>
          hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 80074b0:	6968      	ldr	r0, [r5, #20]
          hadc->Instance->SMPR |= ADC_SMPR_SET(sConfig->SamplingTime);
 80074b2:	400a      	ands	r2, r1
          hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 80074b4:	4388      	bics	r0, r1
 80074b6:	6168      	str	r0, [r5, #20]
          hadc->Instance->SMPR |= ADC_SMPR_SET(sConfig->SamplingTime);
 80074b8:	6968      	ldr	r0, [r5, #20]
 80074ba:	4302      	orrs	r2, r0
 80074bc:	616a      	str	r2, [r5, #20]
      if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 80074be:	2f02      	cmp	r7, #2
 80074c0:	d903      	bls.n	80074ca <HAL_ADC_ConfigChannel+0x6e>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80074c2:	2000      	movs	r0, #0
  __HAL_UNLOCK(hadc);
 80074c4:	2300      	movs	r3, #0
 80074c6:	7023      	strb	r3, [r4, #0]
}
 80074c8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        ADC->CCR |= ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 80074ca:	4a1e      	ldr	r2, [pc, #120]	; (8007544 <HAL_ADC_ConfigChannel+0xe8>)
 80074cc:	2080      	movs	r0, #128	; 0x80
 80074ce:	6811      	ldr	r1, [r2, #0]
 80074d0:	2b10      	cmp	r3, #16
 80074d2:	d015      	beq.n	8007500 <HAL_ADC_ConfigChannel+0xa4>
 80074d4:	2b11      	cmp	r3, #17
 80074d6:	d115      	bne.n	8007504 <HAL_ADC_ConfigChannel+0xa8>
 80074d8:	03c0      	lsls	r0, r0, #15
 80074da:	4301      	orrs	r1, r0
 80074dc:	6011      	str	r1, [r2, #0]
        if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80074de:	2b10      	cmp	r3, #16
 80074e0:	d1ef      	bne.n	80074c2 <HAL_ADC_ConfigChannel+0x66>
          wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 80074e2:	4b19      	ldr	r3, [pc, #100]	; (8007548 <HAL_ADC_ConfigChannel+0xec>)
 80074e4:	4919      	ldr	r1, [pc, #100]	; (800754c <HAL_ADC_ConfigChannel+0xf0>)
 80074e6:	6818      	ldr	r0, [r3, #0]
 80074e8:	f7fe fa6e 	bl	80059c8 <__udivsi3>
 80074ec:	230a      	movs	r3, #10
 80074ee:	4358      	muls	r0, r3
 80074f0:	9001      	str	r0, [sp, #4]
          while(wait_loop_index != 0U)
 80074f2:	9b01      	ldr	r3, [sp, #4]
 80074f4:	2b00      	cmp	r3, #0
 80074f6:	d0e4      	beq.n	80074c2 <HAL_ADC_ConfigChannel+0x66>
            wait_loop_index--;
 80074f8:	9b01      	ldr	r3, [sp, #4]
 80074fa:	3b01      	subs	r3, #1
 80074fc:	9301      	str	r3, [sp, #4]
 80074fe:	e7f8      	b.n	80074f2 <HAL_ADC_ConfigChannel+0x96>
        ADC->CCR |= ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 8007500:	0400      	lsls	r0, r0, #16
 8007502:	e7ea      	b.n	80074da <HAL_ADC_ConfigChannel+0x7e>
 8007504:	0440      	lsls	r0, r0, #17
 8007506:	e7e8      	b.n	80074da <HAL_ADC_ConfigChannel+0x7e>
      hadc->Instance->CHSELR &= ~ADC_CHSELR_CHANNEL(sConfig->Channel);
 8007508:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 800750a:	4391      	bics	r1, r2
 800750c:	62a9      	str	r1, [r5, #40]	; 0x28
      if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 800750e:	2f02      	cmp	r7, #2
 8007510:	d8d7      	bhi.n	80074c2 <HAL_ADC_ConfigChannel+0x66>
        ADC->CCR &= ~ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 8007512:	4a0c      	ldr	r2, [pc, #48]	; (8007544 <HAL_ADC_ConfigChannel+0xe8>)
 8007514:	6811      	ldr	r1, [r2, #0]
 8007516:	2b10      	cmp	r3, #16
 8007518:	d00a      	beq.n	8007530 <HAL_ADC_ConfigChannel+0xd4>
 800751a:	3b11      	subs	r3, #17
 800751c:	1e58      	subs	r0, r3, #1
 800751e:	4183      	sbcs	r3, r0
 8007520:	480b      	ldr	r0, [pc, #44]	; (8007550 <HAL_ADC_ConfigChannel+0xf4>)
 8007522:	425b      	negs	r3, r3
 8007524:	4003      	ands	r3, r0
 8007526:	480b      	ldr	r0, [pc, #44]	; (8007554 <HAL_ADC_ConfigChannel+0xf8>)
 8007528:	181b      	adds	r3, r3, r0
 800752a:	400b      	ands	r3, r1
 800752c:	6013      	str	r3, [r2, #0]
 800752e:	e7c8      	b.n	80074c2 <HAL_ADC_ConfigChannel+0x66>
 8007530:	4b09      	ldr	r3, [pc, #36]	; (8007558 <HAL_ADC_ConfigChannel+0xfc>)
 8007532:	e7fa      	b.n	800752a <HAL_ADC_ConfigChannel+0xce>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8007534:	2120      	movs	r1, #32
 8007536:	6c58      	ldr	r0, [r3, #68]	; 0x44
 8007538:	4301      	orrs	r1, r0
 800753a:	6459      	str	r1, [r3, #68]	; 0x44
    tmp_hal_status = HAL_ERROR;
 800753c:	0010      	movs	r0, r2
 800753e:	e7c1      	b.n	80074c4 <HAL_ADC_ConfigChannel+0x68>
 8007540:	00001001 	.word	0x00001001
 8007544:	40012708 	.word	0x40012708
 8007548:	20000030 	.word	0x20000030
 800754c:	000f4240 	.word	0x000f4240
 8007550:	ff400000 	.word	0xff400000
 8007554:	ffbfffff 	.word	0xffbfffff
 8007558:	ff7fffff 	.word	0xff7fffff

0800755c <HAL_ADCEx_Calibration_Start>:
  *         HAL_ADC_GetValue() (value on 7 bits: from DR[6;0]).
  * @param  hadc: ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef* hadc)
{
 800755c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Process locked */
  __HAL_LOCK(hadc);
 800755e:	0006      	movs	r6, r0
 8007560:	3640      	adds	r6, #64	; 0x40
 8007562:	7833      	ldrb	r3, [r6, #0]
{
 8007564:	0004      	movs	r4, r0
  __HAL_LOCK(hadc);
 8007566:	2002      	movs	r0, #2
 8007568:	2b01      	cmp	r3, #1
 800756a:	d042      	beq.n	80075f2 <HAL_ADCEx_Calibration_Start+0x96>
 800756c:	2301      	movs	r3, #1
  
  /* Calibration prerequisite: ADC must be disabled. */
  if (ADC_IS_ENABLE(hadc) == RESET)
 800756e:	2103      	movs	r1, #3
  __HAL_LOCK(hadc);
 8007570:	7033      	strb	r3, [r6, #0]
  if (ADC_IS_ENABLE(hadc) == RESET)
 8007572:	6823      	ldr	r3, [r4, #0]
 8007574:	689a      	ldr	r2, [r3, #8]
 8007576:	400a      	ands	r2, r1
 8007578:	2a01      	cmp	r2, #1
 800757a:	d105      	bne.n	8007588 <HAL_ADCEx_Calibration_Start+0x2c>
 800757c:	6819      	ldr	r1, [r3, #0]
 800757e:	4211      	tst	r1, r2
 8007580:	d138      	bne.n	80075f4 <HAL_ADCEx_Calibration_Start+0x98>
 8007582:	68da      	ldr	r2, [r3, #12]
 8007584:	0412      	lsls	r2, r2, #16
 8007586:	d435      	bmi.n	80075f4 <HAL_ADCEx_Calibration_Start+0x98>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State, 
 8007588:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800758a:	491d      	ldr	r1, [pc, #116]	; (8007600 <HAL_ADCEx_Calibration_Start+0xa4>)
 800758c:	4011      	ands	r1, r2
 800758e:	2202      	movs	r2, #2
 8007590:	430a      	orrs	r2, r1
    /*       available in data register and also transfered by DMA.           */
    /*       To not insert ADC calibration factor among ADC conversion data   */
    /*       in array variable, DMA transfer must be disabled during          */
    /*       calibration.                                                     */
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 8007592:	2103      	movs	r1, #3
    ADC_STATE_CLR_SET(hadc->State, 
 8007594:	6462      	str	r2, [r4, #68]	; 0x44
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 8007596:	68dd      	ldr	r5, [r3, #12]
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 8007598:	68da      	ldr	r2, [r3, #12]
 800759a:	438a      	bics	r2, r1
 800759c:	60da      	str	r2, [r3, #12]

    /* Start ADC calibration */
    hadc->Instance->CR |= ADC_CR_ADCAL;
 800759e:	2280      	movs	r2, #128	; 0x80
 80075a0:	6899      	ldr	r1, [r3, #8]
 80075a2:	0612      	lsls	r2, r2, #24
 80075a4:	430a      	orrs	r2, r1
 80075a6:	609a      	str	r2, [r3, #8]

    tickstart = HAL_GetTick();  
 80075a8:	f7ff fdba 	bl	8007120 <HAL_GetTick>
 80075ac:	0007      	movs	r7, r0

    /* Wait for calibration completion */
    while(HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADCAL))
 80075ae:	6823      	ldr	r3, [r4, #0]
 80075b0:	689a      	ldr	r2, [r3, #8]
 80075b2:	2a00      	cmp	r2, #0
 80075b4:	db0e      	blt.n	80075d4 <HAL_ADCEx_Calibration_Start+0x78>
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 80075b6:	2203      	movs	r2, #3
        return HAL_ERROR;
      }
    }
    
    /* Restore ADC DMA transfer request after calibration */
    SET_BIT(hadc->Instance->CFGR1, backup_setting_adc_dma_transfer);
 80075b8:	68d9      	ldr	r1, [r3, #12]
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 80075ba:	4015      	ands	r5, r2
    SET_BIT(hadc->Instance->CFGR1, backup_setting_adc_dma_transfer);
 80075bc:	430d      	orrs	r5, r1
 80075be:	60dd      	str	r5, [r3, #12]

    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 80075c0:	6c63      	ldr	r3, [r4, #68]	; 0x44
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80075c2:	2000      	movs	r0, #0
    ADC_STATE_CLR_SET(hadc->State,
 80075c4:	4393      	bics	r3, r2
 80075c6:	001a      	movs	r2, r3
 80075c8:	2301      	movs	r3, #1
 80075ca:	4313      	orrs	r3, r2
 80075cc:	6463      	str	r3, [r4, #68]	; 0x44
    
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80075ce:	2300      	movs	r3, #0
 80075d0:	7033      	strb	r3, [r6, #0]
  
  /* Return function status */
  return tmp_hal_status;
 80075d2:	e00e      	b.n	80075f2 <HAL_ADCEx_Calibration_Start+0x96>
      if((HAL_GetTick() - tickstart) > ADC_CALIBRATION_TIMEOUT)
 80075d4:	f7ff fda4 	bl	8007120 <HAL_GetTick>
 80075d8:	1bc0      	subs	r0, r0, r7
 80075da:	2802      	cmp	r0, #2
 80075dc:	d9e7      	bls.n	80075ae <HAL_ADCEx_Calibration_Start+0x52>
        ADC_STATE_CLR_SET(hadc->State,
 80075de:	2212      	movs	r2, #18
 80075e0:	6c63      	ldr	r3, [r4, #68]	; 0x44
        return HAL_ERROR;
 80075e2:	2001      	movs	r0, #1
        ADC_STATE_CLR_SET(hadc->State,
 80075e4:	4393      	bics	r3, r2
 80075e6:	001a      	movs	r2, r3
 80075e8:	2310      	movs	r3, #16
 80075ea:	4313      	orrs	r3, r2
 80075ec:	6463      	str	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hadc);
 80075ee:	2300      	movs	r3, #0
 80075f0:	7033      	strb	r3, [r6, #0]
}
 80075f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80075f4:	2320      	movs	r3, #32
 80075f6:	6c62      	ldr	r2, [r4, #68]	; 0x44
    tmp_hal_status = HAL_ERROR;
 80075f8:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80075fa:	4313      	orrs	r3, r2
 80075fc:	6463      	str	r3, [r4, #68]	; 0x44
 80075fe:	e7e6      	b.n	80075ce <HAL_ADCEx_Calibration_Start+0x72>
 8007600:	fffffefd 	.word	0xfffffefd

08007604 <HAL_NVIC_SetPriority>:
  *         with stm32f0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0 based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8007604:	b530      	push	{r4, r5, lr}
 8007606:	25ff      	movs	r5, #255	; 0xff
 8007608:	2403      	movs	r4, #3
 800760a:	002a      	movs	r2, r5
 800760c:	b2c3      	uxtb	r3, r0
 800760e:	401c      	ands	r4, r3
 8007610:	00e4      	lsls	r4, r4, #3
 8007612:	40a2      	lsls	r2, r4
 8007614:	0189      	lsls	r1, r1, #6
 8007616:	4029      	ands	r1, r5
 8007618:	43d2      	mvns	r2, r2
 800761a:	40a1      	lsls	r1, r4
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 800761c:	2800      	cmp	r0, #0
 800761e:	da0b      	bge.n	8007638 <HAL_NVIC_SetPriority+0x34>
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8007620:	200f      	movs	r0, #15
 8007622:	4003      	ands	r3, r0
 8007624:	3b08      	subs	r3, #8
 8007626:	480a      	ldr	r0, [pc, #40]	; (8007650 <HAL_NVIC_SetPriority+0x4c>)
 8007628:	089b      	lsrs	r3, r3, #2
 800762a:	009b      	lsls	r3, r3, #2
 800762c:	181b      	adds	r3, r3, r0
 800762e:	69d8      	ldr	r0, [r3, #28]
 8007630:	4002      	ands	r2, r0
 8007632:	4311      	orrs	r1, r2
 8007634:	61d9      	str	r1, [r3, #28]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
}
 8007636:	bd30      	pop	{r4, r5, pc}
 8007638:	4b06      	ldr	r3, [pc, #24]	; (8007654 <HAL_NVIC_SetPriority+0x50>)
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800763a:	0880      	lsrs	r0, r0, #2
 800763c:	0080      	lsls	r0, r0, #2
 800763e:	18c0      	adds	r0, r0, r3
 8007640:	23c0      	movs	r3, #192	; 0xc0
 8007642:	009b      	lsls	r3, r3, #2
 8007644:	58c4      	ldr	r4, [r0, r3]
 8007646:	4022      	ands	r2, r4
 8007648:	4311      	orrs	r1, r2
 800764a:	50c1      	str	r1, [r0, r3]
 800764c:	e7f3      	b.n	8007636 <HAL_NVIC_SetPriority+0x32>
 800764e:	46c0      	nop			; (mov r8, r8)
 8007650:	e000ed00 	.word	0xe000ed00
 8007654:	e000e100 	.word	0xe000e100

08007658 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8007658:	231f      	movs	r3, #31
 800765a:	4018      	ands	r0, r3
 800765c:	3b1e      	subs	r3, #30
 800765e:	4083      	lsls	r3, r0
 8007660:	4a01      	ldr	r2, [pc, #4]	; (8007668 <HAL_NVIC_EnableIRQ+0x10>)
 8007662:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8007664:	4770      	bx	lr
 8007666:	46c0      	nop			; (mov r8, r8)
 8007668:	e000e100 	.word	0xe000e100

0800766c <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800766c:	4a09      	ldr	r2, [pc, #36]	; (8007694 <HAL_SYSTICK_Config+0x28>)
 800766e:	1e43      	subs	r3, r0, #1
  {
    return (1UL);                                                   /* Reload value impossible */
 8007670:	2001      	movs	r0, #1
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8007672:	4293      	cmp	r3, r2
 8007674:	d80d      	bhi.n	8007692 <HAL_SYSTICK_Config+0x26>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8007676:	21c0      	movs	r1, #192	; 0xc0
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8007678:	4a07      	ldr	r2, [pc, #28]	; (8007698 <HAL_SYSTICK_Config+0x2c>)
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800767a:	4808      	ldr	r0, [pc, #32]	; (800769c <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800767c:	6053      	str	r3, [r2, #4]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800767e:	6a03      	ldr	r3, [r0, #32]
 8007680:	0609      	lsls	r1, r1, #24
 8007682:	021b      	lsls	r3, r3, #8
 8007684:	0a1b      	lsrs	r3, r3, #8
 8007686:	430b      	orrs	r3, r1
 8007688:	6203      	str	r3, [r0, #32]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800768a:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800768c:	2307      	movs	r3, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800768e:	6090      	str	r0, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8007690:	6013      	str	r3, [r2, #0]
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8007692:	4770      	bx	lr
 8007694:	00ffffff 	.word	0x00ffffff
 8007698:	e000e010 	.word	0xe000e010
 800769c:	e000ed00 	.word	0xe000ed00

080076a0 <CRC_Handle_8>:
  * @param  pBuffer: pointer to the input data buffer
  * @param  BufferLength: input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 80076a0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80076a2:	000e      	movs	r6, r1
  uint32_t i = 0U; /* input data buffer index */
  
   /* Processing time optimization: 4 bytes are entered in a row with a single word write,
    * last bytes must be carefully fed to the CRC calculator to ensure a correct type
    * handling by the IP */
   for(i = 0U; i < (BufferLength/4U); i++)
 80076a4:	0895      	lsrs	r5, r2, #2
 80076a6:	00ad      	lsls	r5, r5, #2
 80076a8:	186b      	adds	r3, r5, r1
 80076aa:	9301      	str	r3, [sp, #4]
 80076ac:	6803      	ldr	r3, [r0, #0]
 80076ae:	9c01      	ldr	r4, [sp, #4]
 80076b0:	42a6      	cmp	r6, r4
 80076b2:	d107      	bne.n	80076c4 <CRC_Handle_8+0x24>
   {
      hcrc->Instance->DR = ((uint32_t)pBuffer[4U*i]<<24U) | ((uint32_t)pBuffer[4U*i+1]<<16U) | ((uint32_t)pBuffer[4U*i+2]<<8U) | (uint32_t)pBuffer[4U*i+3];      
   }
   /* last bytes specific handling */
   if ((BufferLength%4U) != 0U)
 80076b4:	2403      	movs	r4, #3
 80076b6:	4022      	ands	r2, r4
 80076b8:	d019      	beq.n	80076ee <CRC_Handle_8+0x4e>
   {
     if  (BufferLength%4U == 1U)
 80076ba:	2a01      	cmp	r2, #1
 80076bc:	d10f      	bne.n	80076de <CRC_Handle_8+0x3e>
     {
       *(uint8_t volatile*) (&hcrc->Instance->DR) = pBuffer[4*i];
 80076be:	5d4a      	ldrb	r2, [r1, r5]
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
     }
     if  (BufferLength%4U == 3U)
     {
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
       *(uint8_t volatile*) (&hcrc->Instance->DR) = pBuffer[4*i+2];       
 80076c0:	701a      	strb	r2, [r3, #0]
 80076c2:	e014      	b.n	80076ee <CRC_Handle_8+0x4e>
      hcrc->Instance->DR = ((uint32_t)pBuffer[4U*i]<<24U) | ((uint32_t)pBuffer[4U*i+1]<<16U) | ((uint32_t)pBuffer[4U*i+2]<<8U) | (uint32_t)pBuffer[4U*i+3];      
 80076c4:	7834      	ldrb	r4, [r6, #0]
 80076c6:	7877      	ldrb	r7, [r6, #1]
 80076c8:	0624      	lsls	r4, r4, #24
 80076ca:	043f      	lsls	r7, r7, #16
 80076cc:	433c      	orrs	r4, r7
 80076ce:	78f7      	ldrb	r7, [r6, #3]
 80076d0:	433c      	orrs	r4, r7
 80076d2:	78b7      	ldrb	r7, [r6, #2]
 80076d4:	3604      	adds	r6, #4
 80076d6:	023f      	lsls	r7, r7, #8
 80076d8:	433c      	orrs	r4, r7
 80076da:	601c      	str	r4, [r3, #0]
 80076dc:	e7e7      	b.n	80076ae <CRC_Handle_8+0xe>
 80076de:	186c      	adds	r4, r5, r1
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
 80076e0:	5d49      	ldrb	r1, [r1, r5]
 80076e2:	0209      	lsls	r1, r1, #8
     if  (BufferLength%4U == 2U)
 80076e4:	2a02      	cmp	r2, #2
 80076e6:	d105      	bne.n	80076f4 <CRC_Handle_8+0x54>
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
 80076e8:	7862      	ldrb	r2, [r4, #1]
 80076ea:	430a      	orrs	r2, r1
 80076ec:	801a      	strh	r2, [r3, #0]
     }
   }
  
  /* Return the CRC computed value */ 
  return hcrc->Instance->DR;
 80076ee:	6803      	ldr	r3, [r0, #0]
 80076f0:	6818      	ldr	r0, [r3, #0]
}
 80076f2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
       *(uint16_t volatile*) (&hcrc->Instance->DR) = ((uint32_t)pBuffer[4*i]<<8) | (uint32_t)pBuffer[4*i+1];
 80076f4:	7862      	ldrb	r2, [r4, #1]
 80076f6:	430a      	orrs	r2, r1
 80076f8:	801a      	strh	r2, [r3, #0]
       *(uint8_t volatile*) (&hcrc->Instance->DR) = pBuffer[4*i+2];       
 80076fa:	78a2      	ldrb	r2, [r4, #2]
 80076fc:	e7e0      	b.n	80076c0 <CRC_Handle_8+0x20>

080076fe <CRC_Handle_16>:
  * @param  pBuffer: pointer to the input data buffer
  * @param  BufferLength: input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */  
static uint32_t CRC_Handle_16(CRC_HandleTypeDef *hcrc, uint16_t pBuffer[], uint32_t BufferLength)
{
 80076fe:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007700:	000d      	movs	r5, r1
  uint32_t i = 0U;  /* input data buffer index */
  
  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure 
   * a correct type handling by the IP */
  for(i = 0U; i < (BufferLength/2U); i++)
 8007702:	2600      	movs	r6, #0
 8007704:	6800      	ldr	r0, [r0, #0]
 8007706:	0854      	lsrs	r4, r2, #1
 8007708:	42b4      	cmp	r4, r6
 800770a:	d106      	bne.n	800771a <CRC_Handle_16+0x1c>
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U*i]<<16U) | (uint32_t)pBuffer[2U*i+1];     
  }
  if ((BufferLength%2U) != 0U)
 800770c:	07d3      	lsls	r3, r2, #31
 800770e:	d502      	bpl.n	8007716 <CRC_Handle_16+0x18>
  {
       *(uint16_t volatile*) (&hcrc->Instance->DR) = pBuffer[2*i]; 
 8007710:	00a4      	lsls	r4, r4, #2
 8007712:	5a63      	ldrh	r3, [r4, r1]
 8007714:	8003      	strh	r3, [r0, #0]
  }
   
  /* Return the CRC computed value */ 
  return hcrc->Instance->DR;
 8007716:	6800      	ldr	r0, [r0, #0]
}
 8007718:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U*i]<<16U) | (uint32_t)pBuffer[2U*i+1];     
 800771a:	882b      	ldrh	r3, [r5, #0]
 800771c:	886f      	ldrh	r7, [r5, #2]
 800771e:	041b      	lsls	r3, r3, #16
 8007720:	433b      	orrs	r3, r7
 8007722:	6003      	str	r3, [r0, #0]
  for(i = 0U; i < (BufferLength/2U); i++)
 8007724:	3601      	adds	r6, #1
 8007726:	3504      	adds	r5, #4
 8007728:	e7ee      	b.n	8007708 <CRC_Handle_16+0xa>

0800772a <HAL_CRC_Init>:
{
 800772a:	b510      	push	{r4, lr}
 800772c:	1e04      	subs	r4, r0, #0
  if(hcrc == NULL)
 800772e:	d101      	bne.n	8007734 <HAL_CRC_Init+0xa>
    return HAL_ERROR;
 8007730:	2001      	movs	r0, #1
}
 8007732:	bd10      	pop	{r4, pc}
  if(hcrc->State == HAL_CRC_STATE_RESET)
 8007734:	7f43      	ldrb	r3, [r0, #29]
 8007736:	b2db      	uxtb	r3, r3
 8007738:	2b00      	cmp	r3, #0
 800773a:	d102      	bne.n	8007742 <HAL_CRC_Init+0x18>
    hcrc->Lock = HAL_UNLOCKED;
 800773c:	7703      	strb	r3, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 800773e:	f7fe fc67 	bl	8006010 <HAL_CRC_MspInit>
  hcrc->State = HAL_CRC_STATE_BUSY; 
 8007742:	2302      	movs	r3, #2
  if (HAL_CRCEx_Init(hcrc) != HAL_OK)
 8007744:	0020      	movs	r0, r4
  hcrc->State = HAL_CRC_STATE_BUSY; 
 8007746:	7763      	strb	r3, [r4, #29]
  if (HAL_CRCEx_Init(hcrc) != HAL_OK)
 8007748:	f000 f870 	bl	800782c <HAL_CRCEx_Init>
 800774c:	2800      	cmp	r0, #0
 800774e:	d1ef      	bne.n	8007730 <HAL_CRC_Init+0x6>
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 8007750:	7962      	ldrb	r2, [r4, #5]
 8007752:	6823      	ldr	r3, [r4, #0]
 8007754:	2a00      	cmp	r2, #0
 8007756:	d110      	bne.n	800777a <HAL_CRC_Init+0x50>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);  
 8007758:	3a01      	subs	r2, #1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 800775a:	2160      	movs	r1, #96	; 0x60
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 800775c:	611a      	str	r2, [r3, #16]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 800775e:	689a      	ldr	r2, [r3, #8]
 8007760:	438a      	bics	r2, r1
 8007762:	6961      	ldr	r1, [r4, #20]
 8007764:	430a      	orrs	r2, r1
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);  
 8007766:	2180      	movs	r1, #128	; 0x80
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode); 
 8007768:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);  
 800776a:	689a      	ldr	r2, [r3, #8]
 800776c:	438a      	bics	r2, r1
 800776e:	69a1      	ldr	r1, [r4, #24]
 8007770:	430a      	orrs	r2, r1
 8007772:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 8007774:	2301      	movs	r3, #1
 8007776:	7763      	strb	r3, [r4, #29]
  return HAL_OK;
 8007778:	e7db      	b.n	8007732 <HAL_CRC_Init+0x8>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 800777a:	6922      	ldr	r2, [r4, #16]
 800777c:	e7ed      	b.n	800775a <HAL_CRC_Init+0x30>

0800777e <HAL_CRC_Calculate>:
{
 800777e:	b570      	push	{r4, r5, r6, lr}
 8007780:	2502      	movs	r5, #2
  __HAL_LOCK(hcrc); 
 8007782:	7f03      	ldrb	r3, [r0, #28]
{
 8007784:	0004      	movs	r4, r0
  __HAL_LOCK(hcrc); 
 8007786:	0028      	movs	r0, r5
 8007788:	2b01      	cmp	r3, #1
 800778a:	d01b      	beq.n	80077c4 <HAL_CRC_Calculate+0x46>
 800778c:	2301      	movs	r3, #1
  __HAL_CRC_DR_RESET(hcrc);
 800778e:	6820      	ldr	r0, [r4, #0]
  hcrc->State = HAL_CRC_STATE_BUSY;
 8007790:	7765      	strb	r5, [r4, #29]
  __HAL_CRC_DR_RESET(hcrc);
 8007792:	6885      	ldr	r5, [r0, #8]
  __HAL_LOCK(hcrc); 
 8007794:	7723      	strb	r3, [r4, #28]
  __HAL_CRC_DR_RESET(hcrc);
 8007796:	432b      	orrs	r3, r5
 8007798:	6083      	str	r3, [r0, #8]
  switch (hcrc->InputDataFormat)
 800779a:	6a23      	ldr	r3, [r4, #32]
 800779c:	2b02      	cmp	r3, #2
 800779e:	d015      	beq.n	80077cc <HAL_CRC_Calculate+0x4e>
 80077a0:	2b03      	cmp	r3, #3
 80077a2:	d006      	beq.n	80077b2 <HAL_CRC_Calculate+0x34>
  uint32_t temp = 0U;  /* CRC output (read from hcrc->Instance->DR register) */
 80077a4:	2000      	movs	r0, #0
  switch (hcrc->InputDataFormat)
 80077a6:	2b01      	cmp	r3, #1
 80077a8:	d108      	bne.n	80077bc <HAL_CRC_Calculate+0x3e>
      temp = CRC_Handle_8(hcrc, (uint8_t*)pBuffer, BufferLength);
 80077aa:	0020      	movs	r0, r4
 80077ac:	f7ff ff78 	bl	80076a0 <CRC_Handle_8>
      break;
 80077b0:	e004      	b.n	80077bc <HAL_CRC_Calculate+0x3e>
 80077b2:	0092      	lsls	r2, r2, #2
 80077b4:	188a      	adds	r2, r1, r2
      for(index = 0U; index < BufferLength; index++)
 80077b6:	4291      	cmp	r1, r2
 80077b8:	d105      	bne.n	80077c6 <HAL_CRC_Calculate+0x48>
      temp = hcrc->Instance->DR;
 80077ba:	6800      	ldr	r0, [r0, #0]
  hcrc->State = HAL_CRC_STATE_READY; 
 80077bc:	2301      	movs	r3, #1
 80077be:	7763      	strb	r3, [r4, #29]
  __HAL_UNLOCK(hcrc);
 80077c0:	2300      	movs	r3, #0
 80077c2:	7723      	strb	r3, [r4, #28]
}
 80077c4:	bd70      	pop	{r4, r5, r6, pc}
        hcrc->Instance->DR = pBuffer[index];
 80077c6:	c908      	ldmia	r1!, {r3}
 80077c8:	6003      	str	r3, [r0, #0]
 80077ca:	e7f4      	b.n	80077b6 <HAL_CRC_Calculate+0x38>
      temp = CRC_Handle_16(hcrc, (uint16_t*)pBuffer, BufferLength);
 80077cc:	0020      	movs	r0, r4
 80077ce:	f7ff ff96 	bl	80076fe <CRC_Handle_16>
      break;
 80077d2:	e7f3      	b.n	80077bc <HAL_CRC_Calculate+0x3e>

080077d4 <HAL_CRCEx_Polynomial_Set>:
  *          @arg CRC_POLYLENGTH_16B: 16-bit long CRC (generating polynomial of degree 16)
  *          @arg CRC_POLYLENGTH_32B: 32-bit long CRC (generating polynomial of degree 32)                
  * @retval HAL status
  */                                   
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
 80077d4:	b530      	push	{r4, r5, lr}
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 80077d6:	231f      	movs	r3, #31
{
 80077d8:	0004      	movs	r4, r0
   * definition. HAL_ERROR is reported if Pol degree is 
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while (((Pol & (1U << msb)) == 0U) && (msb-- > 0U))
 80077da:	2001      	movs	r0, #1
 80077dc:	0005      	movs	r5, r0
 80077de:	409d      	lsls	r5, r3
 80077e0:	4229      	tst	r1, r5
 80077e2:	d109      	bne.n	80077f8 <HAL_CRCEx_Polynomial_Set+0x24>
 80077e4:	3b01      	subs	r3, #1
 80077e6:	d2f9      	bcs.n	80077dc <HAL_CRCEx_Polynomial_Set+0x8>
  {}

  switch (PolyLength)
 80077e8:	2a10      	cmp	r2, #16
 80077ea:	d003      	beq.n	80077f4 <HAL_CRCEx_Polynomial_Set+0x20>
 80077ec:	2a18      	cmp	r2, #24
 80077ee:	d001      	beq.n	80077f4 <HAL_CRCEx_Polynomial_Set+0x20>
 80077f0:	2a08      	cmp	r2, #8
 80077f2:	d112      	bne.n	800781a <HAL_CRCEx_Polynomial_Set+0x46>
  {
    case CRC_POLYLENGTH_7B:
      if (msb >= HAL_CRC_LENGTH_7B)
      {
        return  HAL_ERROR;
 80077f4:	2001      	movs	r0, #1
 80077f6:	e00c      	b.n	8007812 <HAL_CRCEx_Polynomial_Set+0x3e>
  switch (PolyLength)
 80077f8:	2a10      	cmp	r2, #16
 80077fa:	d00b      	beq.n	8007814 <HAL_CRCEx_Polynomial_Set+0x40>
 80077fc:	2a18      	cmp	r2, #24
 80077fe:	d005      	beq.n	800780c <HAL_CRCEx_Polynomial_Set+0x38>
 8007800:	2a08      	cmp	r2, #8
 8007802:	d10a      	bne.n	800781a <HAL_CRCEx_Polynomial_Set+0x46>
        return  HAL_ERROR;
 8007804:	2001      	movs	r0, #1
      { 
        return  HAL_ERROR;
      }
      break;
    case CRC_POLYLENGTH_16B:
      if (msb >= HAL_CRC_LENGTH_16B)
 8007806:	2b0f      	cmp	r3, #15
 8007808:	d907      	bls.n	800781a <HAL_CRCEx_Polynomial_Set+0x46>
 800780a:	e002      	b.n	8007812 <HAL_CRCEx_Polynomial_Set+0x3e>
        return  HAL_ERROR;
 800780c:	2001      	movs	r0, #1
      if (msb >= HAL_CRC_LENGTH_7B)
 800780e:	2b06      	cmp	r3, #6
 8007810:	d903      	bls.n	800781a <HAL_CRCEx_Polynomial_Set+0x46>
  /* set generating polynomial size */
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);  
  
  /* Return function status */
  return HAL_OK;
}
 8007812:	bd30      	pop	{r4, r5, pc}
        return  HAL_ERROR;
 8007814:	2001      	movs	r0, #1
      if (msb >= HAL_CRC_LENGTH_8B)
 8007816:	2b07      	cmp	r3, #7
 8007818:	d8fb      	bhi.n	8007812 <HAL_CRCEx_Polynomial_Set+0x3e>
  WRITE_REG(hcrc->Instance->POL, Pol);
 800781a:	6820      	ldr	r0, [r4, #0]
 800781c:	6141      	str	r1, [r0, #20]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);  
 800781e:	2118      	movs	r1, #24
 8007820:	6883      	ldr	r3, [r0, #8]
 8007822:	438b      	bics	r3, r1
 8007824:	431a      	orrs	r2, r3
 8007826:	6082      	str	r2, [r0, #8]
 8007828:	2000      	movs	r0, #0
 800782a:	e7f2      	b.n	8007812 <HAL_CRCEx_Polynomial_Set+0x3e>

0800782c <HAL_CRCEx_Init>:
{
 800782c:	b510      	push	{r4, lr}
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 800782e:	7903      	ldrb	r3, [r0, #4]
 8007830:	2b00      	cmp	r3, #0
 8007832:	d108      	bne.n	8007846 <HAL_CRCEx_Init+0x1a>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);  
 8007834:	6802      	ldr	r2, [r0, #0]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 8007836:	2018      	movs	r0, #24
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);  
 8007838:	4907      	ldr	r1, [pc, #28]	; (8007858 <HAL_CRCEx_Init+0x2c>)
 800783a:	6151      	str	r1, [r2, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 800783c:	6891      	ldr	r1, [r2, #8]
 800783e:	4381      	bics	r1, r0
   return HAL_OK;
 8007840:	0018      	movs	r0, r3
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 8007842:	6091      	str	r1, [r2, #8]
}
 8007844:	bd10      	pop	{r4, pc}
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 8007846:	68c2      	ldr	r2, [r0, #12]
 8007848:	6881      	ldr	r1, [r0, #8]
 800784a:	f7ff ffc3 	bl	80077d4 <HAL_CRCEx_Polynomial_Set>
 800784e:	1e43      	subs	r3, r0, #1
 8007850:	4198      	sbcs	r0, r3
      return HAL_ERROR;
 8007852:	b2c0      	uxtb	r0, r0
 8007854:	e7f6      	b.n	8007844 <HAL_CRCEx_Init+0x18>
 8007856:	46c0      	nop			; (mov r8, r8)
 8007858:	04c11db7 	.word	0x04c11db7

0800785c <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
 800785c:	b570      	push	{r4, r5, r6, lr}
 800785e:	0004      	movs	r4, r0
  uint32_t tmp = 0U;
  
  /* Check the DMA handle allocation */
  if(NULL == hdma)
  {
    return HAL_ERROR;
 8007860:	2501      	movs	r5, #1
  if(NULL == hdma)
 8007862:	2800      	cmp	r0, #0
 8007864:	d028      	beq.n	80078b8 <HAL_DMA_Init+0x5c>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
  
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8007866:	2302      	movs	r3, #2
 8007868:	1c86      	adds	r6, r0, #2

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 800786a:	6800      	ldr	r0, [r0, #0]
  hdma->State = HAL_DMA_STATE_BUSY;
 800786c:	77f3      	strb	r3, [r6, #31]
  tmp = hdma->Instance->CCR;
 800786e:	6802      	ldr	r2, [r0, #0]
  
  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8007870:	4b12      	ldr	r3, [pc, #72]	; (80078bc <HAL_DMA_Init+0x60>)
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8007872:	68a1      	ldr	r1, [r4, #8]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8007874:	401a      	ands	r2, r3
  tmp |=  hdma->Init.Direction        |
 8007876:	6863      	ldr	r3, [r4, #4]
 8007878:	430b      	orrs	r3, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800787a:	68e1      	ldr	r1, [r4, #12]
 800787c:	430b      	orrs	r3, r1
 800787e:	6921      	ldr	r1, [r4, #16]
 8007880:	430b      	orrs	r3, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8007882:	6961      	ldr	r1, [r4, #20]
 8007884:	430b      	orrs	r3, r1
 8007886:	69a1      	ldr	r1, [r4, #24]
 8007888:	430b      	orrs	r3, r1
          hdma->Init.Mode                | hdma->Init.Priority;
 800788a:	69e1      	ldr	r1, [r4, #28]
 800788c:	430b      	orrs	r3, r1
  tmp |=  hdma->Init.Direction        |
 800788e:	4313      	orrs	r3, r2

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;  
 8007890:	6003      	str	r3, [r0, #0]
    hdma->DmaBaseAddress = DMA2;
  }
#else
  /* calculation of the channel index */
  /* DMA1 */
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 8007892:	4b0b      	ldr	r3, [pc, #44]	; (80078c0 <HAL_DMA_Init+0x64>)
 8007894:	2114      	movs	r1, #20
 8007896:	18c0      	adds	r0, r0, r3
 8007898:	f7fe f896 	bl	80059c8 <__udivsi3>
  hdma->DmaBaseAddress = DMA1;
 800789c:	4b09      	ldr	r3, [pc, #36]	; (80078c4 <HAL_DMA_Init+0x68>)
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 800789e:	0080      	lsls	r0, r0, #2
  hdma->DmaBaseAddress = DMA1;
 80078a0:	63e3      	str	r3, [r4, #60]	; 0x3c
  hdma->XferCpltCallback = NULL;
 80078a2:	2300      	movs	r3, #0
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80078a4:	6420      	str	r0, [r4, #64]	; 0x40
  hdma->XferCpltCallback = NULL;
 80078a6:	62a3      	str	r3, [r4, #40]	; 0x28
  hdma->XferHalfCpltCallback = NULL;
 80078a8:	62e3      	str	r3, [r4, #44]	; 0x2c
  hdma->XferErrorCallback = NULL;
 80078aa:	6323      	str	r3, [r4, #48]	; 0x30
  hdma->XferAbortCallback = NULL;
 80078ac:	6363      	str	r3, [r4, #52]	; 0x34
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80078ae:	63a3      	str	r3, [r4, #56]	; 0x38
  hdma->State = HAL_DMA_STATE_READY;
 80078b0:	77f5      	strb	r5, [r6, #31]
  hdma->Lock = HAL_UNLOCKED;
 80078b2:	1964      	adds	r4, r4, r5
  return HAL_OK;
 80078b4:	001d      	movs	r5, r3
  hdma->Lock = HAL_UNLOCKED;
 80078b6:	77e3      	strb	r3, [r4, #31]
}  
 80078b8:	0028      	movs	r0, r5
 80078ba:	bd70      	pop	{r4, r5, r6, pc}
 80078bc:	ffffc00f 	.word	0xffffc00f
 80078c0:	bffdfff8 	.word	0xbffdfff8
 80078c4:	40020000 	.word	0x40020000

080078c8 <HAL_DMA_DeInit>:
{
 80078c8:	b570      	push	{r4, r5, r6, lr}
 80078ca:	0004      	movs	r4, r0
 80078cc:	2601      	movs	r6, #1
  if(NULL == hdma)
 80078ce:	2800      	cmp	r0, #0
 80078d0:	d019      	beq.n	8007906 <HAL_DMA_DeInit+0x3e>
  hdma->Instance->CCR  = 0U;
 80078d2:	2500      	movs	r5, #0
  hdma->Instance->CCR &= ~DMA_CCR_EN;
 80078d4:	6800      	ldr	r0, [r0, #0]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80078d6:	2114      	movs	r1, #20
  hdma->Instance->CCR &= ~DMA_CCR_EN;
 80078d8:	6803      	ldr	r3, [r0, #0]
 80078da:	43b3      	bics	r3, r6
 80078dc:	6003      	str	r3, [r0, #0]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80078de:	4b0b      	ldr	r3, [pc, #44]	; (800790c <HAL_DMA_DeInit+0x44>)
  hdma->Instance->CCR  = 0U;
 80078e0:	6005      	str	r5, [r0, #0]
  hdma->Instance->CNDTR = 0U;
 80078e2:	6045      	str	r5, [r0, #4]
  hdma->Instance->CPAR  = 0U;
 80078e4:	6085      	str	r5, [r0, #8]
  hdma->Instance->CMAR = 0U;
 80078e6:	60c5      	str	r5, [r0, #12]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80078e8:	18c0      	adds	r0, r0, r3
 80078ea:	f7fe f86d 	bl	80059c8 <__udivsi3>
 80078ee:	0080      	lsls	r0, r0, #2
  hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 80078f0:	4086      	lsls	r6, r0
  hdma->DmaBaseAddress = DMA1;
 80078f2:	4b07      	ldr	r3, [pc, #28]	; (8007910 <HAL_DMA_DeInit+0x48>)
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80078f4:	6420      	str	r0, [r4, #64]	; 0x40
  hdma->DmaBaseAddress = DMA1;
 80078f6:	63e3      	str	r3, [r4, #60]	; 0x3c
  hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 80078f8:	605e      	str	r6, [r3, #4]
  return HAL_OK;
 80078fa:	002e      	movs	r6, r5
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80078fc:	63a5      	str	r5, [r4, #56]	; 0x38
  hdma->State = HAL_DMA_STATE_RESET;
 80078fe:	1ca3      	adds	r3, r4, #2
  __HAL_UNLOCK(hdma);
 8007900:	3401      	adds	r4, #1
  hdma->State = HAL_DMA_STATE_RESET;
 8007902:	77dd      	strb	r5, [r3, #31]
  __HAL_UNLOCK(hdma);
 8007904:	77e5      	strb	r5, [r4, #31]
}
 8007906:	0030      	movs	r0, r6
 8007908:	bd70      	pop	{r4, r5, r6, pc}
 800790a:	46c0      	nop			; (mov r8, r8)
 800790c:	bffdfff8 	.word	0xbffdfff8
 8007910:	40020000 	.word	0x40020000

08007914 <HAL_DMA_Start_IT>:
{
 8007914:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(hdma);
 8007916:	1c44      	adds	r4, r0, #1
 8007918:	7fe6      	ldrb	r6, [r4, #31]
{
 800791a:	0005      	movs	r5, r0
  __HAL_LOCK(hdma);
 800791c:	2002      	movs	r0, #2
 800791e:	2e01      	cmp	r6, #1
 8007920:	d027      	beq.n	8007972 <HAL_DMA_Start_IT+0x5e>
 8007922:	3801      	subs	r0, #1
 8007924:	77e0      	strb	r0, [r4, #31]
  if(HAL_DMA_STATE_READY == hdma->State)
 8007926:	1ca8      	adds	r0, r5, #2
 8007928:	7fc6      	ldrb	r6, [r0, #31]
 800792a:	4684      	mov	ip, r0
 800792c:	b2f6      	uxtb	r6, r6
 800792e:	2002      	movs	r0, #2
 8007930:	2700      	movs	r7, #0
 8007932:	2e01      	cmp	r6, #1
 8007934:	d128      	bne.n	8007988 <HAL_DMA_Start_IT+0x74>
  	hdma->State = HAL_DMA_STATE_BUSY;
 8007936:	4664      	mov	r4, ip
 8007938:	77e0      	strb	r0, [r4, #31]
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 800793a:	682c      	ldr	r4, [r5, #0]
  	hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800793c:	63af      	str	r7, [r5, #56]	; 0x38
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 800793e:	6820      	ldr	r0, [r4, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8007940:	6c2f      	ldr	r7, [r5, #64]	; 0x40
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8007942:	43b0      	bics	r0, r6
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8007944:	40be      	lsls	r6, r7
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8007946:	6020      	str	r0, [r4, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8007948:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 800794a:	6046      	str	r6, [r0, #4]
  hdma->Instance->CNDTR = DataLength;
 800794c:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 800794e:	686b      	ldr	r3, [r5, #4]
 8007950:	6828      	ldr	r0, [r5, #0]
 8007952:	2b10      	cmp	r3, #16
 8007954:	d10e      	bne.n	8007974 <HAL_DMA_Start_IT+0x60>
    hdma->Instance->CPAR = DstAddress;
 8007956:	60a2      	str	r2, [r4, #8]
    hdma->Instance->CMAR = SrcAddress;
 8007958:	60e1      	str	r1, [r4, #12]
    if(NULL != hdma->XferHalfCpltCallback )
 800795a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
      hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800795c:	6822      	ldr	r2, [r4, #0]
    if(NULL != hdma->XferHalfCpltCallback )
 800795e:	2b00      	cmp	r3, #0
 8007960:	d00b      	beq.n	800797a <HAL_DMA_Start_IT+0x66>
      hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8007962:	230e      	movs	r3, #14
 8007964:	4313      	orrs	r3, r2
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 8007966:	6023      	str	r3, [r4, #0]
  	hdma->Instance->CCR |= DMA_CCR_EN;
 8007968:	2301      	movs	r3, #1
 800796a:	6802      	ldr	r2, [r0, #0]
 800796c:	4313      	orrs	r3, r2
 800796e:	6003      	str	r3, [r0, #0]
	HAL_StatusTypeDef status = HAL_OK;
 8007970:	2000      	movs	r0, #0
} 
 8007972:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hdma->Instance->CPAR = SrcAddress;
 8007974:	60a1      	str	r1, [r4, #8]
    hdma->Instance->CMAR = DstAddress;
 8007976:	60e2      	str	r2, [r4, #12]
 8007978:	e7ef      	b.n	800795a <HAL_DMA_Start_IT+0x46>
  		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
 800797a:	230a      	movs	r3, #10
 800797c:	4313      	orrs	r3, r2
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 800797e:	2204      	movs	r2, #4
  		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
 8007980:	6023      	str	r3, [r4, #0]
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 8007982:	6823      	ldr	r3, [r4, #0]
 8007984:	4393      	bics	r3, r2
 8007986:	e7ee      	b.n	8007966 <HAL_DMA_Start_IT+0x52>
    __HAL_UNLOCK(hdma); 
 8007988:	77e7      	strb	r7, [r4, #31]
 800798a:	e7f2      	b.n	8007972 <HAL_DMA_Start_IT+0x5e>

0800798c <HAL_DMA_Abort>:
	 hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 800798c:	210e      	movs	r1, #14
 800798e:	6803      	ldr	r3, [r0, #0]
{
 8007990:	b510      	push	{r4, lr}
	 hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8007992:	681a      	ldr	r2, [r3, #0]
	hdma->DmaBaseAddress->IFCR = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8007994:	6c04      	ldr	r4, [r0, #64]	; 0x40
	 hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8007996:	438a      	bics	r2, r1
 8007998:	601a      	str	r2, [r3, #0]
	hdma->Instance->CCR &= ~DMA_CCR_EN;
 800799a:	2201      	movs	r2, #1
 800799c:	6819      	ldr	r1, [r3, #0]
 800799e:	4391      	bics	r1, r2
 80079a0:	6019      	str	r1, [r3, #0]
	hdma->DmaBaseAddress->IFCR = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 80079a2:	0011      	movs	r1, r2
 80079a4:	40a1      	lsls	r1, r4
 80079a6:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 80079a8:	6059      	str	r1, [r3, #4]
	hdma->State = HAL_DMA_STATE_READY; 
 80079aa:	1c83      	adds	r3, r0, #2
 80079ac:	77da      	strb	r2, [r3, #31]
	__HAL_UNLOCK(hdma);
 80079ae:	1883      	adds	r3, r0, r2
 80079b0:	2000      	movs	r0, #0
 80079b2:	77d8      	strb	r0, [r3, #31]
}
 80079b4:	bd10      	pop	{r4, pc}
	...

080079b8 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{ 
 80079b8:	b5f0      	push	{r4, r5, r6, r7, lr}
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
  
        temp = SYSCFG->EXTICR[position >> 2];
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80079ba:	4a56      	ldr	r2, [pc, #344]	; (8007b14 <HAL_GPIO_Init+0x15c>)
  while (((GPIO_Init->Pin) >> position) != RESET)
 80079bc:	680b      	ldr	r3, [r1, #0]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80079be:	1882      	adds	r2, r0, r2
 80079c0:	1e54      	subs	r4, r2, #1
 80079c2:	41a2      	sbcs	r2, r4
{ 
 80079c4:	b089      	sub	sp, #36	; 0x24
  while (((GPIO_Init->Pin) >> position) != RESET)
 80079c6:	9303      	str	r3, [sp, #12]
  uint32_t position = 0x00U;
 80079c8:	2300      	movs	r3, #0
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80079ca:	3204      	adds	r2, #4
 80079cc:	9205      	str	r2, [sp, #20]
  while (((GPIO_Init->Pin) >> position) != RESET)
 80079ce:	9a03      	ldr	r2, [sp, #12]
 80079d0:	40da      	lsrs	r2, r3
 80079d2:	d101      	bne.n	80079d8 <HAL_GPIO_Init+0x20>
      }
    }
    
    position++;
  } 
}
 80079d4:	b009      	add	sp, #36	; 0x24
 80079d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 80079d8:	2201      	movs	r2, #1
 80079da:	409a      	lsls	r2, r3
 80079dc:	4694      	mov	ip, r2
 80079de:	4664      	mov	r4, ip
 80079e0:	9a03      	ldr	r2, [sp, #12]
 80079e2:	4022      	ands	r2, r4
 80079e4:	9202      	str	r2, [sp, #8]
    if(iocurrent)
 80079e6:	d100      	bne.n	80079ea <HAL_GPIO_Init+0x32>
 80079e8:	e092      	b.n	8007b10 <HAL_GPIO_Init+0x158>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
 80079ea:	684a      	ldr	r2, [r1, #4]
 80079ec:	9201      	str	r2, [sp, #4]
 80079ee:	2210      	movs	r2, #16
 80079f0:	9e01      	ldr	r6, [sp, #4]
 80079f2:	4396      	bics	r6, r2
 80079f4:	2e02      	cmp	r6, #2
 80079f6:	d10d      	bne.n	8007a14 <HAL_GPIO_Init+0x5c>
        CLEAR_BIT(temp, 0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;      
 80079f8:	2407      	movs	r4, #7
 80079fa:	270f      	movs	r7, #15
 80079fc:	401c      	ands	r4, r3
 80079fe:	00a4      	lsls	r4, r4, #2
 8007a00:	40a7      	lsls	r7, r4
        temp = GPIOx->AFR[position >> 3];
 8007a02:	08da      	lsrs	r2, r3, #3
 8007a04:	0092      	lsls	r2, r2, #2
 8007a06:	1882      	adds	r2, r0, r2
 8007a08:	6a15      	ldr	r5, [r2, #32]
        CLEAR_BIT(temp, 0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;      
 8007a0a:	43bd      	bics	r5, r7
        SET_BIT(temp, (uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));       
 8007a0c:	690f      	ldr	r7, [r1, #16]
 8007a0e:	40a7      	lsls	r7, r4
 8007a10:	433d      	orrs	r5, r7
        GPIOx->AFR[position >> 3U] = temp;
 8007a12:	6215      	str	r5, [r2, #32]
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
 8007a14:	2203      	movs	r2, #3
 8007a16:	0014      	movs	r4, r2
 8007a18:	005d      	lsls	r5, r3, #1
 8007a1a:	40ac      	lsls	r4, r5
 8007a1c:	43e4      	mvns	r4, r4
      temp = GPIOx->MODER;
 8007a1e:	6807      	ldr	r7, [r0, #0]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8007a20:	3e01      	subs	r6, #1
      CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
 8007a22:	4027      	ands	r7, r4
 8007a24:	9704      	str	r7, [sp, #16]
      SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8007a26:	9f01      	ldr	r7, [sp, #4]
 8007a28:	403a      	ands	r2, r7
 8007a2a:	40aa      	lsls	r2, r5
 8007a2c:	9f04      	ldr	r7, [sp, #16]
 8007a2e:	433a      	orrs	r2, r7
      GPIOx->MODER = temp;
 8007a30:	6002      	str	r2, [r0, #0]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8007a32:	2e01      	cmp	r6, #1
 8007a34:	d80e      	bhi.n	8007a54 <HAL_GPIO_Init+0x9c>
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 8007a36:	68ca      	ldr	r2, [r1, #12]
        temp = GPIOx->OSPEEDR; 
 8007a38:	6886      	ldr	r6, [r0, #8]
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 8007a3a:	40aa      	lsls	r2, r5
        CLEAR_BIT(temp, GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8007a3c:	4026      	ands	r6, r4
        SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 8007a3e:	4332      	orrs	r2, r6
        GPIOx->OSPEEDR = temp;
 8007a40:	6082      	str	r2, [r0, #8]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 8007a42:	4662      	mov	r2, ip
        temp = GPIOx->OTYPER;
 8007a44:	6846      	ldr	r6, [r0, #4]
        CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 8007a46:	4396      	bics	r6, r2
        SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8007a48:	9a01      	ldr	r2, [sp, #4]
 8007a4a:	06d2      	lsls	r2, r2, #27
 8007a4c:	0fd2      	lsrs	r2, r2, #31
 8007a4e:	409a      	lsls	r2, r3
 8007a50:	4332      	orrs	r2, r6
        GPIOx->OTYPER = temp;
 8007a52:	6042      	str	r2, [r0, #4]
      temp = GPIOx->PUPDR;
 8007a54:	68c2      	ldr	r2, [r0, #12]
      CLEAR_BIT(temp, GPIO_PUPDR_PUPDR0 << (position * 2U));
 8007a56:	4014      	ands	r4, r2
      SET_BIT(temp, (GPIO_Init->Pull) << (position * 2U));
 8007a58:	688a      	ldr	r2, [r1, #8]
 8007a5a:	40aa      	lsls	r2, r5
 8007a5c:	4314      	orrs	r4, r2
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 8007a5e:	9a01      	ldr	r2, [sp, #4]
      GPIOx->PUPDR = temp;
 8007a60:	60c4      	str	r4, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 8007a62:	00d2      	lsls	r2, r2, #3
 8007a64:	d554      	bpl.n	8007b10 <HAL_GPIO_Init+0x158>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8007a66:	2601      	movs	r6, #1
 8007a68:	4a2b      	ldr	r2, [pc, #172]	; (8007b18 <HAL_GPIO_Init+0x160>)
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 8007a6a:	001d      	movs	r5, r3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8007a6c:	6994      	ldr	r4, [r2, #24]
 8007a6e:	4334      	orrs	r4, r6
 8007a70:	6194      	str	r4, [r2, #24]
 8007a72:	6992      	ldr	r2, [r2, #24]
        temp = SYSCFG->EXTICR[position >> 2];
 8007a74:	089c      	lsrs	r4, r3, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8007a76:	4032      	ands	r2, r6
 8007a78:	9207      	str	r2, [sp, #28]
 8007a7a:	9a07      	ldr	r2, [sp, #28]
 8007a7c:	4a27      	ldr	r2, [pc, #156]	; (8007b1c <HAL_GPIO_Init+0x164>)
 8007a7e:	00a4      	lsls	r4, r4, #2
 8007a80:	18a4      	adds	r4, r4, r2
        temp = SYSCFG->EXTICR[position >> 2];
 8007a82:	68a2      	ldr	r2, [r4, #8]
 8007a84:	4694      	mov	ip, r2
        CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 8007a86:	2203      	movs	r2, #3
 8007a88:	4015      	ands	r5, r2
 8007a8a:	00ad      	lsls	r5, r5, #2
 8007a8c:	320c      	adds	r2, #12
 8007a8e:	40aa      	lsls	r2, r5
 8007a90:	4667      	mov	r7, ip
 8007a92:	4397      	bics	r7, r2
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8007a94:	2290      	movs	r2, #144	; 0x90
 8007a96:	05d2      	lsls	r2, r2, #23
 8007a98:	4694      	mov	ip, r2
 8007a9a:	2200      	movs	r2, #0
 8007a9c:	4560      	cmp	r0, ip
 8007a9e:	d00d      	beq.n	8007abc <HAL_GPIO_Init+0x104>
 8007aa0:	4a1f      	ldr	r2, [pc, #124]	; (8007b20 <HAL_GPIO_Init+0x168>)
 8007aa2:	4694      	mov	ip, r2
 8007aa4:	0032      	movs	r2, r6
 8007aa6:	4560      	cmp	r0, ip
 8007aa8:	d008      	beq.n	8007abc <HAL_GPIO_Init+0x104>
 8007aaa:	4e1e      	ldr	r6, [pc, #120]	; (8007b24 <HAL_GPIO_Init+0x16c>)
 8007aac:	1892      	adds	r2, r2, r2
 8007aae:	42b0      	cmp	r0, r6
 8007ab0:	d004      	beq.n	8007abc <HAL_GPIO_Init+0x104>
 8007ab2:	4e1d      	ldr	r6, [pc, #116]	; (8007b28 <HAL_GPIO_Init+0x170>)
 8007ab4:	3201      	adds	r2, #1
 8007ab6:	42b0      	cmp	r0, r6
 8007ab8:	d000      	beq.n	8007abc <HAL_GPIO_Init+0x104>
 8007aba:	9a05      	ldr	r2, [sp, #20]
 8007abc:	40aa      	lsls	r2, r5
 8007abe:	433a      	orrs	r2, r7
        SYSCFG->EXTICR[position >> 2] = temp;
 8007ac0:	60a2      	str	r2, [r4, #8]
        temp = EXTI->IMR;
 8007ac2:	4a1a      	ldr	r2, [pc, #104]	; (8007b2c <HAL_GPIO_Init+0x174>)
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 8007ac4:	9c02      	ldr	r4, [sp, #8]
        temp = EXTI->IMR;
 8007ac6:	6816      	ldr	r6, [r2, #0]
          SET_BIT(temp, iocurrent); 
 8007ac8:	9d02      	ldr	r5, [sp, #8]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8007aca:	9f01      	ldr	r7, [sp, #4]
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 8007acc:	43e4      	mvns	r4, r4
          SET_BIT(temp, iocurrent); 
 8007ace:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8007ad0:	03ff      	lsls	r7, r7, #15
 8007ad2:	d401      	bmi.n	8007ad8 <HAL_GPIO_Init+0x120>
        CLEAR_BIT(temp, (uint32_t)iocurrent);
 8007ad4:	0035      	movs	r5, r6
 8007ad6:	4025      	ands	r5, r4
        EXTI->IMR = temp;
 8007ad8:	6015      	str	r5, [r2, #0]
        temp = EXTI->EMR;
 8007ada:	6856      	ldr	r6, [r2, #4]
          SET_BIT(temp, iocurrent); 
 8007adc:	9d02      	ldr	r5, [sp, #8]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8007ade:	9f01      	ldr	r7, [sp, #4]
          SET_BIT(temp, iocurrent); 
 8007ae0:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8007ae2:	03bf      	lsls	r7, r7, #14
 8007ae4:	d401      	bmi.n	8007aea <HAL_GPIO_Init+0x132>
        CLEAR_BIT(temp, (uint32_t)iocurrent);      
 8007ae6:	0035      	movs	r5, r6
 8007ae8:	4025      	ands	r5, r4
        EXTI->EMR = temp;
 8007aea:	6055      	str	r5, [r2, #4]
        temp = EXTI->RTSR;
 8007aec:	6896      	ldr	r6, [r2, #8]
          SET_BIT(temp, iocurrent); 
 8007aee:	9d02      	ldr	r5, [sp, #8]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8007af0:	9f01      	ldr	r7, [sp, #4]
          SET_BIT(temp, iocurrent); 
 8007af2:	4335      	orrs	r5, r6
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8007af4:	02ff      	lsls	r7, r7, #11
 8007af6:	d401      	bmi.n	8007afc <HAL_GPIO_Init+0x144>
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 8007af8:	0035      	movs	r5, r6
 8007afa:	4025      	ands	r5, r4
        EXTI->RTSR = temp;
 8007afc:	6095      	str	r5, [r2, #8]
        temp = EXTI->FTSR;
 8007afe:	68d5      	ldr	r5, [r2, #12]
          SET_BIT(temp, iocurrent); 
 8007b00:	9e02      	ldr	r6, [sp, #8]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8007b02:	9f01      	ldr	r7, [sp, #4]
          SET_BIT(temp, iocurrent); 
 8007b04:	432e      	orrs	r6, r5
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8007b06:	02bf      	lsls	r7, r7, #10
 8007b08:	d401      	bmi.n	8007b0e <HAL_GPIO_Init+0x156>
        CLEAR_BIT(temp, (uint32_t)iocurrent); 
 8007b0a:	4025      	ands	r5, r4
 8007b0c:	002e      	movs	r6, r5
        EXTI->FTSR = temp;
 8007b0e:	60d6      	str	r6, [r2, #12]
    position++;
 8007b10:	3301      	adds	r3, #1
 8007b12:	e75c      	b.n	80079ce <HAL_GPIO_Init+0x16>
 8007b14:	b7fff000 	.word	0xb7fff000
 8007b18:	40021000 	.word	0x40021000
 8007b1c:	40010000 	.word	0x40010000
 8007b20:	48000400 	.word	0x48000400
 8007b24:	48000800 	.word	0x48000800
 8007b28:	48000c00 	.word	0x48000c00
 8007b2c:	40010400 	.word	0x40010400

08007b30 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8007b30:	6900      	ldr	r0, [r0, #16]
 8007b32:	4008      	ands	r0, r1
 8007b34:	1e41      	subs	r1, r0, #1
 8007b36:	4188      	sbcs	r0, r1
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
 8007b38:	b2c0      	uxtb	r0, r0
  }
 8007b3a:	4770      	bx	lr

08007b3c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8007b3c:	2a00      	cmp	r2, #0
 8007b3e:	d001      	beq.n	8007b44 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8007b40:	6181      	str	r1, [r0, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 8007b42:	4770      	bx	lr
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8007b44:	6281      	str	r1, [r0, #40]	; 0x28
}
 8007b46:	e7fc      	b.n	8007b42 <HAL_GPIO_WritePin+0x6>

08007b48 <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8007b48:	6943      	ldr	r3, [r0, #20]
 8007b4a:	4059      	eors	r1, r3
 8007b4c:	6141      	str	r1, [r0, #20]
}
 8007b4e:	4770      	bx	lr

08007b50 <HAL_GPIO_EXTI_IRQHandler>:
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) 
 8007b50:	4b04      	ldr	r3, [pc, #16]	; (8007b64 <HAL_GPIO_EXTI_IRQHandler+0x14>)
{
 8007b52:	b510      	push	{r4, lr}
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET) 
 8007b54:	695a      	ldr	r2, [r3, #20]
 8007b56:	4210      	tst	r0, r2
 8007b58:	d002      	beq.n	8007b60 <HAL_GPIO_EXTI_IRQHandler+0x10>
  { 
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8007b5a:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8007b5c:	f7fe fd90 	bl	8006680 <HAL_GPIO_EXTI_Callback>
  }
}
 8007b60:	bd10      	pop	{r4, pc}
 8007b62:	46c0      	nop			; (mov r8, r8)
 8007b64:	40010400 	.word	0x40010400

08007b68 <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8007b68:	6803      	ldr	r3, [r0, #0]
 8007b6a:	699a      	ldr	r2, [r3, #24]
 8007b6c:	0792      	lsls	r2, r2, #30
 8007b6e:	d501      	bpl.n	8007b74 <I2C_Flush_TXDR+0xc>
  {
     hi2c->Instance->TXDR = 0x00U;
 8007b70:	2200      	movs	r2, #0
 8007b72:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8007b74:	2201      	movs	r2, #1
 8007b76:	6999      	ldr	r1, [r3, #24]
 8007b78:	4211      	tst	r1, r2
 8007b7a:	d102      	bne.n	8007b82 <I2C_Flush_TXDR+0x1a>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8007b7c:	6999      	ldr	r1, [r3, #24]
 8007b7e:	430a      	orrs	r2, r1
 8007b80:	619a      	str	r2, [r3, #24]
  }
}
 8007b82:	4770      	bx	lr

08007b84 <I2C_TransferConfig>:
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Get the CR2 register value */
  tmpreg = hi2c->Instance->CR2;
 8007b84:	6800      	ldr	r0, [r0, #0]
{
 8007b86:	b530      	push	{r4, r5, lr}
  tmpreg = hi2c->Instance->CR2;
 8007b88:	6845      	ldr	r5, [r0, #4]

  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8007b8a:	4c06      	ldr	r4, [pc, #24]	; (8007ba4 <I2C_TransferConfig+0x20>)

  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8007b8c:	0412      	lsls	r2, r2, #16
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8007b8e:	402c      	ands	r4, r5
  tmpreg |= (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << 16 ) & I2C_CR2_NBYTES) | \
 8007b90:	9d03      	ldr	r5, [sp, #12]
 8007b92:	0589      	lsls	r1, r1, #22
 8007b94:	432b      	orrs	r3, r5
 8007b96:	431a      	orrs	r2, r3
 8007b98:	0d89      	lsrs	r1, r1, #22
 8007b9a:	430a      	orrs	r2, r1
 8007b9c:	4322      	orrs	r2, r4
            (uint32_t)Mode | (uint32_t)Request);

  /* update CR2 register */
  hi2c->Instance->CR2 = tmpreg;
 8007b9e:	6042      	str	r2, [r0, #4]
}
 8007ba0:	bd30      	pop	{r4, r5, pc}
 8007ba2:	46c0      	nop			; (mov r8, r8)
 8007ba4:	fc009800 	.word	0xfc009800

08007ba8 <I2C_WaitOnFlagUntilTimeout>:
{
 8007ba8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007baa:	0004      	movs	r4, r0
 8007bac:	000e      	movs	r6, r1
 8007bae:	0017      	movs	r7, r2
 8007bb0:	001d      	movs	r5, r3
  while(__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8007bb2:	6822      	ldr	r2, [r4, #0]
 8007bb4:	6993      	ldr	r3, [r2, #24]
 8007bb6:	4033      	ands	r3, r6
 8007bb8:	1b9b      	subs	r3, r3, r6
 8007bba:	4259      	negs	r1, r3
 8007bbc:	414b      	adcs	r3, r1
 8007bbe:	42bb      	cmp	r3, r7
 8007bc0:	d001      	beq.n	8007bc6 <I2C_WaitOnFlagUntilTimeout+0x1e>
  return HAL_OK;
 8007bc2:	2000      	movs	r0, #0
 8007bc4:	e00e      	b.n	8007be4 <I2C_WaitOnFlagUntilTimeout+0x3c>
    if(Timeout != HAL_MAX_DELAY)
 8007bc6:	1c6b      	adds	r3, r5, #1
 8007bc8:	d0f4      	beq.n	8007bb4 <I2C_WaitOnFlagUntilTimeout+0xc>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8007bca:	2d00      	cmp	r5, #0
 8007bcc:	d10b      	bne.n	8007be6 <I2C_WaitOnFlagUntilTimeout+0x3e>
        hi2c->State= HAL_I2C_STATE_READY;
 8007bce:	0023      	movs	r3, r4
 8007bd0:	2220      	movs	r2, #32
 8007bd2:	3341      	adds	r3, #65	; 0x41
 8007bd4:	701a      	strb	r2, [r3, #0]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007bd6:	0022      	movs	r2, r4
 8007bd8:	2300      	movs	r3, #0
        return HAL_TIMEOUT;
 8007bda:	2003      	movs	r0, #3
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007bdc:	3242      	adds	r2, #66	; 0x42
        __HAL_UNLOCK(hi2c);
 8007bde:	3440      	adds	r4, #64	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007be0:	7013      	strb	r3, [r2, #0]
        __HAL_UNLOCK(hi2c);
 8007be2:	7023      	strb	r3, [r4, #0]
}
 8007be4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8007be6:	f7ff fa9b 	bl	8007120 <HAL_GetTick>
 8007bea:	9b06      	ldr	r3, [sp, #24]
 8007bec:	1ac0      	subs	r0, r0, r3
 8007bee:	42a8      	cmp	r0, r5
 8007bf0:	d9df      	bls.n	8007bb2 <I2C_WaitOnFlagUntilTimeout+0xa>
 8007bf2:	e7ec      	b.n	8007bce <I2C_WaitOnFlagUntilTimeout+0x26>

08007bf4 <I2C_IsAcknowledgeFailed>:
{
 8007bf4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007bf6:	6803      	ldr	r3, [r0, #0]
{
 8007bf8:	0004      	movs	r4, r0
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007bfa:	6998      	ldr	r0, [r3, #24]
 8007bfc:	2310      	movs	r3, #16
{
 8007bfe:	000e      	movs	r6, r1
 8007c00:	0017      	movs	r7, r2
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007c02:	4018      	ands	r0, r3
    while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007c04:	2520      	movs	r5, #32
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007c06:	2800      	cmp	r0, #0
 8007c08:	d115      	bne.n	8007c36 <I2C_IsAcknowledgeFailed+0x42>
}
 8007c0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(Timeout != HAL_MAX_DELAY)
 8007c0c:	1c72      	adds	r2, r6, #1
 8007c0e:	d013      	beq.n	8007c38 <I2C_IsAcknowledgeFailed+0x44>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007c10:	2e00      	cmp	r6, #0
 8007c12:	d004      	beq.n	8007c1e <I2C_IsAcknowledgeFailed+0x2a>
 8007c14:	f7ff fa84 	bl	8007120 <HAL_GetTick>
 8007c18:	1bc0      	subs	r0, r0, r7
 8007c1a:	4286      	cmp	r6, r0
 8007c1c:	d20b      	bcs.n	8007c36 <I2C_IsAcknowledgeFailed+0x42>
          hi2c->State= HAL_I2C_STATE_READY;
 8007c1e:	0023      	movs	r3, r4
 8007c20:	2220      	movs	r2, #32
 8007c22:	3341      	adds	r3, #65	; 0x41
 8007c24:	701a      	strb	r2, [r3, #0]
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c26:	0022      	movs	r2, r4
 8007c28:	2300      	movs	r3, #0
 8007c2a:	3242      	adds	r2, #66	; 0x42
          __HAL_UNLOCK(hi2c);
 8007c2c:	3440      	adds	r4, #64	; 0x40
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c2e:	7013      	strb	r3, [r2, #0]
          return HAL_TIMEOUT;
 8007c30:	2003      	movs	r0, #3
          __HAL_UNLOCK(hi2c);
 8007c32:	7023      	strb	r3, [r4, #0]
 8007c34:	e7e9      	b.n	8007c0a <I2C_IsAcknowledgeFailed+0x16>
    while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007c36:	6823      	ldr	r3, [r4, #0]
 8007c38:	699a      	ldr	r2, [r3, #24]
 8007c3a:	422a      	tst	r2, r5
 8007c3c:	d0e6      	beq.n	8007c0c <I2C_IsAcknowledgeFailed+0x18>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007c3e:	2210      	movs	r2, #16
    I2C_Flush_TXDR(hi2c);
 8007c40:	0020      	movs	r0, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007c42:	61da      	str	r2, [r3, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007c44:	61dd      	str	r5, [r3, #28]
    I2C_Flush_TXDR(hi2c);
 8007c46:	f7ff ff8f 	bl	8007b68 <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
 8007c4a:	6822      	ldr	r2, [r4, #0]
 8007c4c:	4908      	ldr	r1, [pc, #32]	; (8007c70 <I2C_IsAcknowledgeFailed+0x7c>)
 8007c4e:	6853      	ldr	r3, [r2, #4]
    return HAL_ERROR;
 8007c50:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
 8007c52:	400b      	ands	r3, r1
 8007c54:	6053      	str	r3, [r2, #4]
    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8007c56:	2304      	movs	r3, #4
 8007c58:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State= HAL_I2C_STATE_READY;
 8007c5a:	0023      	movs	r3, r4
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c5c:	0022      	movs	r2, r4
    hi2c->State= HAL_I2C_STATE_READY;
 8007c5e:	3341      	adds	r3, #65	; 0x41
 8007c60:	701d      	strb	r5, [r3, #0]
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c62:	2300      	movs	r3, #0
 8007c64:	3242      	adds	r2, #66	; 0x42
    __HAL_UNLOCK(hi2c);
 8007c66:	3440      	adds	r4, #64	; 0x40
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c68:	7013      	strb	r3, [r2, #0]
    __HAL_UNLOCK(hi2c);
 8007c6a:	7023      	strb	r3, [r4, #0]
 8007c6c:	e7cd      	b.n	8007c0a <I2C_IsAcknowledgeFailed+0x16>
 8007c6e:	46c0      	nop			; (mov r8, r8)
 8007c70:	fe00e800 	.word	0xfe00e800

08007c74 <I2C_WaitOnTXISFlagUntilTimeout>:
{
 8007c74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007c76:	0004      	movs	r4, r0
 8007c78:	000d      	movs	r5, r1
 8007c7a:	0016      	movs	r6, r2
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8007c7c:	2702      	movs	r7, #2
 8007c7e:	6823      	ldr	r3, [r4, #0]
 8007c80:	699b      	ldr	r3, [r3, #24]
 8007c82:	423b      	tst	r3, r7
 8007c84:	d001      	beq.n	8007c8a <I2C_WaitOnTXISFlagUntilTimeout+0x16>
  return HAL_OK;
 8007c86:	2000      	movs	r0, #0
 8007c88:	e018      	b.n	8007cbc <I2C_WaitOnTXISFlagUntilTimeout+0x48>
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8007c8a:	0032      	movs	r2, r6
 8007c8c:	0029      	movs	r1, r5
 8007c8e:	0020      	movs	r0, r4
 8007c90:	f7ff ffb0 	bl	8007bf4 <I2C_IsAcknowledgeFailed>
 8007c94:	2800      	cmp	r0, #0
 8007c96:	d118      	bne.n	8007cca <I2C_WaitOnTXISFlagUntilTimeout+0x56>
    if(Timeout != HAL_MAX_DELAY)
 8007c98:	1c6b      	adds	r3, r5, #1
 8007c9a:	d0f0      	beq.n	8007c7e <I2C_WaitOnTXISFlagUntilTimeout+0xa>
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007c9c:	2d00      	cmp	r5, #0
 8007c9e:	d10e      	bne.n	8007cbe <I2C_WaitOnTXISFlagUntilTimeout+0x4a>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007ca0:	2220      	movs	r2, #32
 8007ca2:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8007ca4:	2003      	movs	r0, #3
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007ca6:	4313      	orrs	r3, r2
 8007ca8:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State= HAL_I2C_STATE_READY;
 8007caa:	0023      	movs	r3, r4
 8007cac:	3341      	adds	r3, #65	; 0x41
 8007cae:	701a      	strb	r2, [r3, #0]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007cb0:	0022      	movs	r2, r4
 8007cb2:	2300      	movs	r3, #0
 8007cb4:	3242      	adds	r2, #66	; 0x42
        __HAL_UNLOCK(hi2c);
 8007cb6:	3440      	adds	r4, #64	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007cb8:	7013      	strb	r3, [r2, #0]
        __HAL_UNLOCK(hi2c);
 8007cba:	7023      	strb	r3, [r4, #0]
}
 8007cbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007cbe:	f7ff fa2f 	bl	8007120 <HAL_GetTick>
 8007cc2:	1b80      	subs	r0, r0, r6
 8007cc4:	42a8      	cmp	r0, r5
 8007cc6:	d9da      	bls.n	8007c7e <I2C_WaitOnTXISFlagUntilTimeout+0xa>
 8007cc8:	e7ea      	b.n	8007ca0 <I2C_WaitOnTXISFlagUntilTimeout+0x2c>
      return HAL_ERROR;
 8007cca:	2001      	movs	r0, #1
 8007ccc:	e7f6      	b.n	8007cbc <I2C_WaitOnTXISFlagUntilTimeout+0x48>

08007cce <I2C_RequestMemoryWrite>:
{
 8007cce:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8007cd0:	0015      	movs	r5, r2
 8007cd2:	001e      	movs	r6, r3
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8007cd4:	b2da      	uxtb	r2, r3
 8007cd6:	2380      	movs	r3, #128	; 0x80
 8007cd8:	019b      	lsls	r3, r3, #6
 8007cda:	9300      	str	r3, [sp, #0]
 8007cdc:	2380      	movs	r3, #128	; 0x80
{
 8007cde:	0004      	movs	r4, r0
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8007ce0:	045b      	lsls	r3, r3, #17
 8007ce2:	f7ff ff4f 	bl	8007b84 <I2C_TransferConfig>
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007ce6:	9a07      	ldr	r2, [sp, #28]
 8007ce8:	9906      	ldr	r1, [sp, #24]
 8007cea:	0020      	movs	r0, r4
 8007cec:	f7ff ffc2 	bl	8007c74 <I2C_WaitOnTXISFlagUntilTimeout>
 8007cf0:	2800      	cmp	r0, #0
 8007cf2:	d005      	beq.n	8007d00 <I2C_RequestMemoryWrite+0x32>
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007cf4:	6c63      	ldr	r3, [r4, #68]	; 0x44
      return HAL_ERROR;
 8007cf6:	2001      	movs	r0, #1
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007cf8:	2b04      	cmp	r3, #4
 8007cfa:	d000      	beq.n	8007cfe <I2C_RequestMemoryWrite+0x30>
      return HAL_TIMEOUT;
 8007cfc:	2003      	movs	r0, #3
}
 8007cfe:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 8007d00:	6823      	ldr	r3, [r4, #0]
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8007d02:	2e01      	cmp	r6, #1
 8007d04:	d10c      	bne.n	8007d20 <I2C_RequestMemoryWrite+0x52>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007d06:	b2ed      	uxtb	r5, r5
 8007d08:	629d      	str	r5, [r3, #40]	; 0x28
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 8007d0a:	9b07      	ldr	r3, [sp, #28]
 8007d0c:	2200      	movs	r2, #0
 8007d0e:	9300      	str	r3, [sp, #0]
 8007d10:	2180      	movs	r1, #128	; 0x80
 8007d12:	9b06      	ldr	r3, [sp, #24]
 8007d14:	0020      	movs	r0, r4
 8007d16:	f7ff ff47 	bl	8007ba8 <I2C_WaitOnFlagUntilTimeout>
 8007d1a:	2800      	cmp	r0, #0
 8007d1c:	d0ef      	beq.n	8007cfe <I2C_RequestMemoryWrite+0x30>
 8007d1e:	e7ed      	b.n	8007cfc <I2C_RequestMemoryWrite+0x2e>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8007d20:	0a2a      	lsrs	r2, r5, #8
 8007d22:	629a      	str	r2, [r3, #40]	; 0x28
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007d24:	9906      	ldr	r1, [sp, #24]
 8007d26:	9a07      	ldr	r2, [sp, #28]
 8007d28:	0020      	movs	r0, r4
 8007d2a:	f7ff ffa3 	bl	8007c74 <I2C_WaitOnTXISFlagUntilTimeout>
 8007d2e:	2800      	cmp	r0, #0
 8007d30:	d1e0      	bne.n	8007cf4 <I2C_RequestMemoryWrite+0x26>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007d32:	6823      	ldr	r3, [r4, #0]
 8007d34:	e7e7      	b.n	8007d06 <I2C_RequestMemoryWrite+0x38>

08007d36 <I2C_RequestMemoryRead>:
{
 8007d36:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8007d38:	0015      	movs	r5, r2
 8007d3a:	001e      	movs	r6, r3
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8007d3c:	b2da      	uxtb	r2, r3
 8007d3e:	2380      	movs	r3, #128	; 0x80
{
 8007d40:	0004      	movs	r4, r0
  I2C_TransferConfig(hi2c,DevAddress,MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8007d42:	019b      	lsls	r3, r3, #6
 8007d44:	9300      	str	r3, [sp, #0]
 8007d46:	2300      	movs	r3, #0
 8007d48:	f7ff ff1c 	bl	8007b84 <I2C_TransferConfig>
  if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007d4c:	9a07      	ldr	r2, [sp, #28]
 8007d4e:	9906      	ldr	r1, [sp, #24]
 8007d50:	0020      	movs	r0, r4
 8007d52:	f7ff ff8f 	bl	8007c74 <I2C_WaitOnTXISFlagUntilTimeout>
 8007d56:	2800      	cmp	r0, #0
 8007d58:	d005      	beq.n	8007d66 <I2C_RequestMemoryRead+0x30>
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007d5a:	6c63      	ldr	r3, [r4, #68]	; 0x44
      return HAL_ERROR;
 8007d5c:	2001      	movs	r0, #1
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007d5e:	2b04      	cmp	r3, #4
 8007d60:	d000      	beq.n	8007d64 <I2C_RequestMemoryRead+0x2e>
      return HAL_TIMEOUT;
 8007d62:	2003      	movs	r0, #3
}
 8007d64:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 8007d66:	6823      	ldr	r3, [r4, #0]
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8007d68:	2e01      	cmp	r6, #1
 8007d6a:	d10c      	bne.n	8007d86 <I2C_RequestMemoryRead+0x50>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007d6c:	b2ed      	uxtb	r5, r5
 8007d6e:	629d      	str	r5, [r3, #40]	; 0x28
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 8007d70:	9b07      	ldr	r3, [sp, #28]
 8007d72:	2200      	movs	r2, #0
 8007d74:	9300      	str	r3, [sp, #0]
 8007d76:	2140      	movs	r1, #64	; 0x40
 8007d78:	9b06      	ldr	r3, [sp, #24]
 8007d7a:	0020      	movs	r0, r4
 8007d7c:	f7ff ff14 	bl	8007ba8 <I2C_WaitOnFlagUntilTimeout>
 8007d80:	2800      	cmp	r0, #0
 8007d82:	d0ef      	beq.n	8007d64 <I2C_RequestMemoryRead+0x2e>
 8007d84:	e7ed      	b.n	8007d62 <I2C_RequestMemoryRead+0x2c>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8007d86:	0a2a      	lsrs	r2, r5, #8
 8007d88:	629a      	str	r2, [r3, #40]	; 0x28
    if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007d8a:	9906      	ldr	r1, [sp, #24]
 8007d8c:	9a07      	ldr	r2, [sp, #28]
 8007d8e:	0020      	movs	r0, r4
 8007d90:	f7ff ff70 	bl	8007c74 <I2C_WaitOnTXISFlagUntilTimeout>
 8007d94:	2800      	cmp	r0, #0
 8007d96:	d1e0      	bne.n	8007d5a <I2C_RequestMemoryRead+0x24>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007d98:	6823      	ldr	r3, [r4, #0]
 8007d9a:	e7e7      	b.n	8007d6c <I2C_RequestMemoryRead+0x36>

08007d9c <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 8007d9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007d9e:	0004      	movs	r4, r0
 8007da0:	000d      	movs	r5, r1
 8007da2:	0016      	movs	r6, r2
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007da4:	2720      	movs	r7, #32
 8007da6:	6823      	ldr	r3, [r4, #0]
 8007da8:	699b      	ldr	r3, [r3, #24]
 8007daa:	423b      	tst	r3, r7
 8007dac:	d001      	beq.n	8007db2 <I2C_WaitOnSTOPFlagUntilTimeout+0x16>
  return HAL_OK;
 8007dae:	2000      	movs	r0, #0
 8007db0:	e016      	b.n	8007de0 <I2C_WaitOnSTOPFlagUntilTimeout+0x44>
    if(I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8007db2:	0032      	movs	r2, r6
 8007db4:	0029      	movs	r1, r5
 8007db6:	0020      	movs	r0, r4
 8007db8:	f7ff ff1c 	bl	8007bf4 <I2C_IsAcknowledgeFailed>
 8007dbc:	2800      	cmp	r0, #0
 8007dbe:	d116      	bne.n	8007dee <I2C_WaitOnSTOPFlagUntilTimeout+0x52>
    if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007dc0:	2d00      	cmp	r5, #0
 8007dc2:	d10e      	bne.n	8007de2 <I2C_WaitOnSTOPFlagUntilTimeout+0x46>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007dc4:	2220      	movs	r2, #32
 8007dc6:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8007dc8:	2003      	movs	r0, #3
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007dca:	4313      	orrs	r3, r2
 8007dcc:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State= HAL_I2C_STATE_READY;
 8007dce:	0023      	movs	r3, r4
 8007dd0:	3341      	adds	r3, #65	; 0x41
 8007dd2:	701a      	strb	r2, [r3, #0]
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007dd4:	0022      	movs	r2, r4
 8007dd6:	2300      	movs	r3, #0
 8007dd8:	3242      	adds	r2, #66	; 0x42
        __HAL_UNLOCK(hi2c);
 8007dda:	3440      	adds	r4, #64	; 0x40
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007ddc:	7013      	strb	r3, [r2, #0]
        __HAL_UNLOCK(hi2c);
 8007dde:	7023      	strb	r3, [r4, #0]
}
 8007de0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((Timeout == 0U)||((HAL_GetTick() - Tickstart) > Timeout))
 8007de2:	f7ff f99d 	bl	8007120 <HAL_GetTick>
 8007de6:	1b80      	subs	r0, r0, r6
 8007de8:	42a8      	cmp	r0, r5
 8007dea:	d9dc      	bls.n	8007da6 <I2C_WaitOnSTOPFlagUntilTimeout+0xa>
 8007dec:	e7ea      	b.n	8007dc4 <I2C_WaitOnSTOPFlagUntilTimeout+0x28>
      return HAL_ERROR;
 8007dee:	2001      	movs	r0, #1
 8007df0:	e7f6      	b.n	8007de0 <I2C_WaitOnSTOPFlagUntilTimeout+0x44>
	...

08007df4 <HAL_I2C_Init>:
{
 8007df4:	b570      	push	{r4, r5, r6, lr}
 8007df6:	0004      	movs	r4, r0
    return HAL_ERROR;
 8007df8:	2001      	movs	r0, #1
  if(hi2c == NULL)
 8007dfa:	2c00      	cmp	r4, #0
 8007dfc:	d03f      	beq.n	8007e7e <HAL_I2C_Init+0x8a>
  if(hi2c->State == HAL_I2C_STATE_RESET)
 8007dfe:	0025      	movs	r5, r4
 8007e00:	3541      	adds	r5, #65	; 0x41
 8007e02:	782b      	ldrb	r3, [r5, #0]
 8007e04:	b2db      	uxtb	r3, r3
 8007e06:	2b00      	cmp	r3, #0
 8007e08:	d105      	bne.n	8007e16 <HAL_I2C_Init+0x22>
    hi2c->Lock = HAL_UNLOCKED;
 8007e0a:	0022      	movs	r2, r4
 8007e0c:	3240      	adds	r2, #64	; 0x40
 8007e0e:	7013      	strb	r3, [r2, #0]
    HAL_I2C_MspInit(hi2c);
 8007e10:	0020      	movs	r0, r4
 8007e12:	f7fe f8cb 	bl	8005fac <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8007e16:	2324      	movs	r3, #36	; 0x24
  __HAL_I2C_DISABLE(hi2c);
 8007e18:	2101      	movs	r1, #1
  hi2c->State = HAL_I2C_STATE_BUSY;
 8007e1a:	702b      	strb	r3, [r5, #0]
  __HAL_I2C_DISABLE(hi2c);
 8007e1c:	6823      	ldr	r3, [r4, #0]
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8007e1e:	68e0      	ldr	r0, [r4, #12]
  __HAL_I2C_DISABLE(hi2c);
 8007e20:	681a      	ldr	r2, [r3, #0]
 8007e22:	68a6      	ldr	r6, [r4, #8]
 8007e24:	438a      	bics	r2, r1
 8007e26:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8007e28:	6861      	ldr	r1, [r4, #4]
 8007e2a:	4a1a      	ldr	r2, [pc, #104]	; (8007e94 <HAL_I2C_Init+0xa0>)
 8007e2c:	400a      	ands	r2, r1
 8007e2e:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8007e30:	6899      	ldr	r1, [r3, #8]
 8007e32:	4a19      	ldr	r2, [pc, #100]	; (8007e98 <HAL_I2C_Init+0xa4>)
 8007e34:	4011      	ands	r1, r2
 8007e36:	6099      	str	r1, [r3, #8]
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8007e38:	2801      	cmp	r0, #1
 8007e3a:	d121      	bne.n	8007e80 <HAL_I2C_Init+0x8c>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8007e3c:	2180      	movs	r1, #128	; 0x80
 8007e3e:	0209      	lsls	r1, r1, #8
 8007e40:	4331      	orrs	r1, r6
 8007e42:	6099      	str	r1, [r3, #8]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8007e44:	6858      	ldr	r0, [r3, #4]
 8007e46:	4915      	ldr	r1, [pc, #84]	; (8007e9c <HAL_I2C_Init+0xa8>)
 8007e48:	4301      	orrs	r1, r0
 8007e4a:	6059      	str	r1, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8007e4c:	68d9      	ldr	r1, [r3, #12]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007e4e:	2000      	movs	r0, #0
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8007e50:	400a      	ands	r2, r1
 8007e52:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8007e54:	6961      	ldr	r1, [r4, #20]
 8007e56:	6922      	ldr	r2, [r4, #16]
 8007e58:	430a      	orrs	r2, r1
 8007e5a:	69a1      	ldr	r1, [r4, #24]
 8007e5c:	0209      	lsls	r1, r1, #8
 8007e5e:	430a      	orrs	r2, r1
 8007e60:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8007e62:	6a21      	ldr	r1, [r4, #32]
 8007e64:	69e2      	ldr	r2, [r4, #28]
 8007e66:	430a      	orrs	r2, r1
 8007e68:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 8007e6a:	2201      	movs	r2, #1
 8007e6c:	6819      	ldr	r1, [r3, #0]
 8007e6e:	430a      	orrs	r2, r1
 8007e70:	601a      	str	r2, [r3, #0]
  hi2c->State = HAL_I2C_STATE_READY;
 8007e72:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007e74:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8007e76:	702b      	strb	r3, [r5, #0]
  hi2c->PreviousState = I2C_STATE_NONE;
 8007e78:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007e7a:	3442      	adds	r4, #66	; 0x42
 8007e7c:	7020      	strb	r0, [r4, #0]
}
 8007e7e:	bd70      	pop	{r4, r5, r6, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8007e80:	2184      	movs	r1, #132	; 0x84
 8007e82:	0209      	lsls	r1, r1, #8
 8007e84:	4331      	orrs	r1, r6
 8007e86:	6099      	str	r1, [r3, #8]
  if(hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8007e88:	2802      	cmp	r0, #2
 8007e8a:	d1db      	bne.n	8007e44 <HAL_I2C_Init+0x50>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8007e8c:	2180      	movs	r1, #128	; 0x80
 8007e8e:	0109      	lsls	r1, r1, #4
 8007e90:	6059      	str	r1, [r3, #4]
 8007e92:	e7d7      	b.n	8007e44 <HAL_I2C_Init+0x50>
 8007e94:	f0ffffff 	.word	0xf0ffffff
 8007e98:	ffff7fff 	.word	0xffff7fff
 8007e9c:	02008000 	.word	0x02008000

08007ea0 <HAL_I2C_Mem_Write>:
{
 8007ea0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007ea2:	b089      	sub	sp, #36	; 0x24
 8007ea4:	9307      	str	r3, [sp, #28]
 8007ea6:	ab0e      	add	r3, sp, #56	; 0x38
 8007ea8:	9206      	str	r2, [sp, #24]
 8007eaa:	cb04      	ldmia	r3!, {r2}
 8007eac:	0004      	movs	r4, r0
 8007eae:	881b      	ldrh	r3, [r3, #0]
 8007eb0:	9203      	str	r2, [sp, #12]
 8007eb2:	9304      	str	r3, [sp, #16]
  if(hi2c->State == HAL_I2C_STATE_READY)
 8007eb4:	0003      	movs	r3, r0
 8007eb6:	3341      	adds	r3, #65	; 0x41
 8007eb8:	9305      	str	r3, [sp, #20]
 8007eba:	781b      	ldrb	r3, [r3, #0]
{
 8007ebc:	000d      	movs	r5, r1
    return HAL_BUSY;
 8007ebe:	2002      	movs	r0, #2
  if(hi2c->State == HAL_I2C_STATE_READY)
 8007ec0:	2b20      	cmp	r3, #32
 8007ec2:	d102      	bne.n	8007eca <HAL_I2C_Mem_Write+0x2a>
    if((pData == NULL) || (Size == 0U))
 8007ec4:	2a00      	cmp	r2, #0
 8007ec6:	d102      	bne.n	8007ece <HAL_I2C_Mem_Write+0x2e>
        return HAL_ERROR;
 8007ec8:	2001      	movs	r0, #1
}
 8007eca:	b009      	add	sp, #36	; 0x24
 8007ecc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((pData == NULL) || (Size == 0U))
 8007ece:	9b04      	ldr	r3, [sp, #16]
 8007ed0:	2b00      	cmp	r3, #0
 8007ed2:	d0f9      	beq.n	8007ec8 <HAL_I2C_Mem_Write+0x28>
    __HAL_LOCK(hi2c);
 8007ed4:	0027      	movs	r7, r4
 8007ed6:	3740      	adds	r7, #64	; 0x40
 8007ed8:	783b      	ldrb	r3, [r7, #0]
 8007eda:	2b01      	cmp	r3, #1
 8007edc:	d0f5      	beq.n	8007eca <HAL_I2C_Mem_Write+0x2a>
 8007ede:	2301      	movs	r3, #1
 8007ee0:	703b      	strb	r3, [r7, #0]
    tickstart = HAL_GetTick();
 8007ee2:	f7ff f91d 	bl	8007120 <HAL_GetTick>
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8007ee6:	2180      	movs	r1, #128	; 0x80
    tickstart = HAL_GetTick();
 8007ee8:	9002      	str	r0, [sp, #8]
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8007eea:	9000      	str	r0, [sp, #0]
 8007eec:	2319      	movs	r3, #25
 8007eee:	2201      	movs	r2, #1
 8007ef0:	0209      	lsls	r1, r1, #8
 8007ef2:	0020      	movs	r0, r4
 8007ef4:	f7ff fe58 	bl	8007ba8 <I2C_WaitOnFlagUntilTimeout>
 8007ef8:	1e06      	subs	r6, r0, #0
 8007efa:	d11e      	bne.n	8007f3a <HAL_I2C_Mem_Write+0x9a>
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8007efc:	2321      	movs	r3, #33	; 0x21
 8007efe:	9a05      	ldr	r2, [sp, #20]
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8007f00:	0029      	movs	r1, r5
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8007f02:	7013      	strb	r3, [r2, #0]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8007f04:	0023      	movs	r3, r4
 8007f06:	3342      	adds	r3, #66	; 0x42
 8007f08:	9305      	str	r3, [sp, #20]
 8007f0a:	2340      	movs	r3, #64	; 0x40
 8007f0c:	9a05      	ldr	r2, [sp, #20]
 8007f0e:	7013      	strb	r3, [r2, #0]
    hi2c->pBuffPtr  = pData;
 8007f10:	9b03      	ldr	r3, [sp, #12]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007f12:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->pBuffPtr  = pData;
 8007f14:	6263      	str	r3, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
 8007f16:	9b04      	ldr	r3, [sp, #16]
    hi2c->XferISR   = NULL;
 8007f18:	6360      	str	r0, [r4, #52]	; 0x34
    hi2c->XferCount = Size;
 8007f1a:	8563      	strh	r3, [r4, #42]	; 0x2a
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8007f1c:	9b02      	ldr	r3, [sp, #8]
 8007f1e:	9a06      	ldr	r2, [sp, #24]
 8007f20:	9301      	str	r3, [sp, #4]
 8007f22:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007f24:	0020      	movs	r0, r4
 8007f26:	9300      	str	r3, [sp, #0]
 8007f28:	9b07      	ldr	r3, [sp, #28]
 8007f2a:	f7ff fed0 	bl	8007cce <I2C_RequestMemoryWrite>
 8007f2e:	2800      	cmp	r0, #0
 8007f30:	d005      	beq.n	8007f3e <HAL_I2C_Mem_Write+0x9e>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007f32:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 8007f34:	703e      	strb	r6, [r7, #0]
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007f36:	2b04      	cmp	r3, #4
 8007f38:	d0c6      	beq.n	8007ec8 <HAL_I2C_Mem_Write+0x28>
          return HAL_TIMEOUT;
 8007f3a:	2003      	movs	r0, #3
 8007f3c:	e7c5      	b.n	8007eca <HAL_I2C_Mem_Write+0x2a>
    if(hi2c->XferCount > MAX_NBYTE_SIZE)
 8007f3e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007f40:	2bff      	cmp	r3, #255	; 0xff
 8007f42:	d914      	bls.n	8007f6e <HAL_I2C_Mem_Write+0xce>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8007f44:	22ff      	movs	r2, #255	; 0xff
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007f46:	2380      	movs	r3, #128	; 0x80
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8007f48:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007f4a:	045b      	lsls	r3, r3, #17
 8007f4c:	9000      	str	r0, [sp, #0]
 8007f4e:	0029      	movs	r1, r5
 8007f50:	0020      	movs	r0, r4
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f52:	2680      	movs	r6, #128	; 0x80
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007f54:	f7ff fe16 	bl	8007b84 <I2C_TransferConfig>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8007f58:	27ff      	movs	r7, #255	; 0xff
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f5a:	04b6      	lsls	r6, r6, #18
      if(I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8007f5c:	9a02      	ldr	r2, [sp, #8]
 8007f5e:	9910      	ldr	r1, [sp, #64]	; 0x40
 8007f60:	0020      	movs	r0, r4
 8007f62:	f7ff fe87 	bl	8007c74 <I2C_WaitOnTXISFlagUntilTimeout>
 8007f66:	2800      	cmp	r0, #0
 8007f68:	d009      	beq.n	8007f7e <HAL_I2C_Mem_Write+0xde>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8007f6a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007f6c:	e7e3      	b.n	8007f36 <HAL_I2C_Mem_Write+0x96>
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f6e:	2380      	movs	r3, #128	; 0x80
      hi2c->XferSize = hi2c->XferCount;
 8007f70:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f72:	049b      	lsls	r3, r3, #18
      hi2c->XferSize = hi2c->XferCount;
 8007f74:	b292      	uxth	r2, r2
 8007f76:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f78:	b2d2      	uxtb	r2, r2
 8007f7a:	9000      	str	r0, [sp, #0]
 8007f7c:	e7e7      	b.n	8007f4e <HAL_I2C_Mem_Write+0xae>
      hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
 8007f7e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007f80:	1c5a      	adds	r2, r3, #1
 8007f82:	6262      	str	r2, [r4, #36]	; 0x24
 8007f84:	781b      	ldrb	r3, [r3, #0]
 8007f86:	6822      	ldr	r2, [r4, #0]
 8007f88:	6293      	str	r3, [r2, #40]	; 0x28
      hi2c->XferCount--;
 8007f8a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007f8c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007f8e:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 8007f90:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 8007f92:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8007f94:	b292      	uxth	r2, r2
      hi2c->XferCount--;
 8007f96:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007f98:	8522      	strh	r2, [r4, #40]	; 0x28
      if((hi2c->XferSize == 0U) && (hi2c->XferCount!=0U))
 8007f9a:	2a00      	cmp	r2, #0
 8007f9c:	d117      	bne.n	8007fce <HAL_I2C_Mem_Write+0x12e>
 8007f9e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007fa0:	2b00      	cmp	r3, #0
 8007fa2:	d014      	beq.n	8007fce <HAL_I2C_Mem_Write+0x12e>
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8007fa4:	9b02      	ldr	r3, [sp, #8]
 8007fa6:	2180      	movs	r1, #128	; 0x80
 8007fa8:	9300      	str	r3, [sp, #0]
 8007faa:	0020      	movs	r0, r4
 8007fac:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007fae:	f7ff fdfb 	bl	8007ba8 <I2C_WaitOnFlagUntilTimeout>
 8007fb2:	2800      	cmp	r0, #0
 8007fb4:	d1c1      	bne.n	8007f3a <HAL_I2C_Mem_Write+0x9a>
        if(hi2c->XferCount > MAX_NBYTE_SIZE)
 8007fb6:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007fb8:	2bff      	cmp	r3, #255	; 0xff
 8007fba:	d921      	bls.n	8008000 <HAL_I2C_Mem_Write+0x160>
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007fbc:	2380      	movs	r3, #128	; 0x80
 8007fbe:	22ff      	movs	r2, #255	; 0xff
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8007fc0:	8527      	strh	r7, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007fc2:	045b      	lsls	r3, r3, #17
 8007fc4:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007fc6:	0029      	movs	r1, r5
 8007fc8:	0020      	movs	r0, r4
 8007fca:	f7ff fddb 	bl	8007b84 <I2C_TransferConfig>
    }while(hi2c->XferCount > 0U);
 8007fce:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007fd0:	2b00      	cmp	r3, #0
 8007fd2:	d1c3      	bne.n	8007f5c <HAL_I2C_Mem_Write+0xbc>
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8007fd4:	9a02      	ldr	r2, [sp, #8]
 8007fd6:	9910      	ldr	r1, [sp, #64]	; 0x40
 8007fd8:	0020      	movs	r0, r4
 8007fda:	f7ff fedf 	bl	8007d9c <I2C_WaitOnSTOPFlagUntilTimeout>
 8007fde:	2800      	cmp	r0, #0
 8007fe0:	d1c3      	bne.n	8007f6a <HAL_I2C_Mem_Write+0xca>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007fe2:	2120      	movs	r1, #32
 8007fe4:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
 8007fe6:	4d0a      	ldr	r5, [pc, #40]	; (8008010 <HAL_I2C_Mem_Write+0x170>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007fe8:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8007fea:	685a      	ldr	r2, [r3, #4]
 8007fec:	402a      	ands	r2, r5
 8007fee:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8007ff0:	0023      	movs	r3, r4
 8007ff2:	3341      	adds	r3, #65	; 0x41
 8007ff4:	7019      	strb	r1, [r3, #0]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8007ff6:	9b05      	ldr	r3, [sp, #20]
    __HAL_UNLOCK(hi2c);
 8007ff8:	3440      	adds	r4, #64	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8007ffa:	7018      	strb	r0, [r3, #0]
    __HAL_UNLOCK(hi2c);
 8007ffc:	7020      	strb	r0, [r4, #0]
    return HAL_OK;
 8007ffe:	e764      	b.n	8007eca <HAL_I2C_Mem_Write+0x2a>
          hi2c->XferSize = hi2c->XferCount;
 8008000:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8008002:	0033      	movs	r3, r6
          hi2c->XferSize = hi2c->XferCount;
 8008004:	b292      	uxth	r2, r2
 8008006:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8008008:	b2d2      	uxtb	r2, r2
 800800a:	9000      	str	r0, [sp, #0]
 800800c:	e7db      	b.n	8007fc6 <HAL_I2C_Mem_Write+0x126>
 800800e:	46c0      	nop			; (mov r8, r8)
 8008010:	fe00e800 	.word	0xfe00e800

08008014 <HAL_I2C_Mem_Read>:
{
 8008014:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008016:	b089      	sub	sp, #36	; 0x24
 8008018:	9307      	str	r3, [sp, #28]
 800801a:	ab0e      	add	r3, sp, #56	; 0x38
 800801c:	9206      	str	r2, [sp, #24]
 800801e:	cb04      	ldmia	r3!, {r2}
 8008020:	0004      	movs	r4, r0
 8008022:	881b      	ldrh	r3, [r3, #0]
 8008024:	9203      	str	r2, [sp, #12]
 8008026:	9304      	str	r3, [sp, #16]
  if(hi2c->State == HAL_I2C_STATE_READY)
 8008028:	0003      	movs	r3, r0
 800802a:	3341      	adds	r3, #65	; 0x41
 800802c:	9305      	str	r3, [sp, #20]
 800802e:	781b      	ldrb	r3, [r3, #0]
{
 8008030:	000d      	movs	r5, r1
    return HAL_BUSY;
 8008032:	2002      	movs	r0, #2
  if(hi2c->State == HAL_I2C_STATE_READY)
 8008034:	2b20      	cmp	r3, #32
 8008036:	d102      	bne.n	800803e <HAL_I2C_Mem_Read+0x2a>
    if((pData == NULL) || (Size == 0U))
 8008038:	2a00      	cmp	r2, #0
 800803a:	d102      	bne.n	8008042 <HAL_I2C_Mem_Read+0x2e>
        return HAL_ERROR;
 800803c:	2001      	movs	r0, #1
}
 800803e:	b009      	add	sp, #36	; 0x24
 8008040:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((pData == NULL) || (Size == 0U))
 8008042:	9b04      	ldr	r3, [sp, #16]
 8008044:	2b00      	cmp	r3, #0
 8008046:	d0f9      	beq.n	800803c <HAL_I2C_Mem_Read+0x28>
    __HAL_LOCK(hi2c);
 8008048:	0027      	movs	r7, r4
 800804a:	3740      	adds	r7, #64	; 0x40
 800804c:	783b      	ldrb	r3, [r7, #0]
 800804e:	2b01      	cmp	r3, #1
 8008050:	d0f5      	beq.n	800803e <HAL_I2C_Mem_Read+0x2a>
 8008052:	2301      	movs	r3, #1
 8008054:	703b      	strb	r3, [r7, #0]
    tickstart = HAL_GetTick();
 8008056:	f7ff f863 	bl	8007120 <HAL_GetTick>
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800805a:	2180      	movs	r1, #128	; 0x80
    tickstart = HAL_GetTick();
 800805c:	9002      	str	r0, [sp, #8]
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800805e:	9000      	str	r0, [sp, #0]
 8008060:	2319      	movs	r3, #25
 8008062:	2201      	movs	r2, #1
 8008064:	0209      	lsls	r1, r1, #8
 8008066:	0020      	movs	r0, r4
 8008068:	f7ff fd9e 	bl	8007ba8 <I2C_WaitOnFlagUntilTimeout>
 800806c:	1e06      	subs	r6, r0, #0
 800806e:	d11e      	bne.n	80080ae <HAL_I2C_Mem_Read+0x9a>
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8008070:	2322      	movs	r3, #34	; 0x22
 8008072:	9a05      	ldr	r2, [sp, #20]
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8008074:	0029      	movs	r1, r5
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8008076:	7013      	strb	r3, [r2, #0]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8008078:	0023      	movs	r3, r4
 800807a:	3342      	adds	r3, #66	; 0x42
 800807c:	9305      	str	r3, [sp, #20]
 800807e:	2340      	movs	r3, #64	; 0x40
 8008080:	9a05      	ldr	r2, [sp, #20]
 8008082:	7013      	strb	r3, [r2, #0]
    hi2c->pBuffPtr  = pData;
 8008084:	9b03      	ldr	r3, [sp, #12]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8008086:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->pBuffPtr  = pData;
 8008088:	6263      	str	r3, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
 800808a:	9b04      	ldr	r3, [sp, #16]
    hi2c->XferISR   = NULL;
 800808c:	6360      	str	r0, [r4, #52]	; 0x34
    hi2c->XferCount = Size;
 800808e:	8563      	strh	r3, [r4, #42]	; 0x2a
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8008090:	9b02      	ldr	r3, [sp, #8]
 8008092:	9a06      	ldr	r2, [sp, #24]
 8008094:	9301      	str	r3, [sp, #4]
 8008096:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8008098:	0020      	movs	r0, r4
 800809a:	9300      	str	r3, [sp, #0]
 800809c:	9b07      	ldr	r3, [sp, #28]
 800809e:	f7ff fe4a 	bl	8007d36 <I2C_RequestMemoryRead>
 80080a2:	2800      	cmp	r0, #0
 80080a4:	d005      	beq.n	80080b2 <HAL_I2C_Mem_Read+0x9e>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80080a6:	6c63      	ldr	r3, [r4, #68]	; 0x44
        __HAL_UNLOCK(hi2c);
 80080a8:	703e      	strb	r6, [r7, #0]
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80080aa:	2b04      	cmp	r3, #4
 80080ac:	d0c6      	beq.n	800803c <HAL_I2C_Mem_Read+0x28>
        return HAL_TIMEOUT;
 80080ae:	2003      	movs	r0, #3
 80080b0:	e7c5      	b.n	800803e <HAL_I2C_Mem_Read+0x2a>
 80080b2:	2390      	movs	r3, #144	; 0x90
    if(hi2c->XferCount > MAX_NBYTE_SIZE)
 80080b4:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 80080b6:	019b      	lsls	r3, r3, #6
 80080b8:	2aff      	cmp	r2, #255	; 0xff
 80080ba:	d949      	bls.n	8008150 <HAL_I2C_Mem_Read+0x13c>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80080bc:	22ff      	movs	r2, #255	; 0xff
 80080be:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 80080c0:	9300      	str	r3, [sp, #0]
 80080c2:	2380      	movs	r3, #128	; 0x80
 80080c4:	045b      	lsls	r3, r3, #17
 80080c6:	0029      	movs	r1, r5
 80080c8:	0020      	movs	r0, r4
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 80080ca:	2680      	movs	r6, #128	; 0x80
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 80080cc:	f7ff fd5a 	bl	8007b84 <I2C_TransferConfig>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80080d0:	27ff      	movs	r7, #255	; 0xff
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 80080d2:	04b6      	lsls	r6, r6, #18
      if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 80080d4:	9b02      	ldr	r3, [sp, #8]
 80080d6:	2200      	movs	r2, #0
 80080d8:	9300      	str	r3, [sp, #0]
 80080da:	2104      	movs	r1, #4
 80080dc:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80080de:	0020      	movs	r0, r4
 80080e0:	f7ff fd62 	bl	8007ba8 <I2C_WaitOnFlagUntilTimeout>
 80080e4:	2800      	cmp	r0, #0
 80080e6:	d1e2      	bne.n	80080ae <HAL_I2C_Mem_Read+0x9a>
      (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
 80080e8:	6823      	ldr	r3, [r4, #0]
 80080ea:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80080ec:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80080ee:	1c59      	adds	r1, r3, #1
 80080f0:	6261      	str	r1, [r4, #36]	; 0x24
 80080f2:	701a      	strb	r2, [r3, #0]
      hi2c->XferSize--;
 80080f4:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 80080f6:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 80080f8:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 80080fa:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 80080fc:	b292      	uxth	r2, r2
      hi2c->XferCount--;
 80080fe:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8008100:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8008102:	8563      	strh	r3, [r4, #42]	; 0x2a
      if((hi2c->XferSize == 0U) && (hi2c->XferCount != 0U))
 8008104:	2a00      	cmp	r2, #0
 8008106:	d117      	bne.n	8008138 <HAL_I2C_Mem_Read+0x124>
 8008108:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800810a:	2b00      	cmp	r3, #0
 800810c:	d014      	beq.n	8008138 <HAL_I2C_Mem_Read+0x124>
        if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800810e:	9b02      	ldr	r3, [sp, #8]
 8008110:	2180      	movs	r1, #128	; 0x80
 8008112:	9300      	str	r3, [sp, #0]
 8008114:	0020      	movs	r0, r4
 8008116:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8008118:	f7ff fd46 	bl	8007ba8 <I2C_WaitOnFlagUntilTimeout>
 800811c:	2800      	cmp	r0, #0
 800811e:	d1c6      	bne.n	80080ae <HAL_I2C_Mem_Read+0x9a>
        if(hi2c->XferCount > MAX_NBYTE_SIZE)
 8008120:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8008122:	2bff      	cmp	r3, #255	; 0xff
 8008124:	d91c      	bls.n	8008160 <HAL_I2C_Mem_Read+0x14c>
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8008126:	2380      	movs	r3, #128	; 0x80
 8008128:	22ff      	movs	r2, #255	; 0xff
          hi2c->XferSize = MAX_NBYTE_SIZE;
 800812a:	8527      	strh	r7, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 800812c:	045b      	lsls	r3, r3, #17
 800812e:	9000      	str	r0, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8008130:	0029      	movs	r1, r5
 8008132:	0020      	movs	r0, r4
 8008134:	f7ff fd26 	bl	8007b84 <I2C_TransferConfig>
    }while(hi2c->XferCount > 0U);
 8008138:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800813a:	2b00      	cmp	r3, #0
 800813c:	d1ca      	bne.n	80080d4 <HAL_I2C_Mem_Read+0xc0>
    if(I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800813e:	9a02      	ldr	r2, [sp, #8]
 8008140:	9910      	ldr	r1, [sp, #64]	; 0x40
 8008142:	0020      	movs	r0, r4
 8008144:	f7ff fe2a 	bl	8007d9c <I2C_WaitOnSTOPFlagUntilTimeout>
 8008148:	2800      	cmp	r0, #0
 800814a:	d010      	beq.n	800816e <HAL_I2C_Mem_Read+0x15a>
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800814c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800814e:	e7ac      	b.n	80080aa <HAL_I2C_Mem_Read+0x96>
      hi2c->XferSize = hi2c->XferCount;
 8008150:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8008152:	b292      	uxth	r2, r2
 8008154:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 8008156:	9300      	str	r3, [sp, #0]
 8008158:	2380      	movs	r3, #128	; 0x80
 800815a:	b2d2      	uxtb	r2, r2
 800815c:	049b      	lsls	r3, r3, #18
 800815e:	e7b2      	b.n	80080c6 <HAL_I2C_Mem_Read+0xb2>
          hi2c->XferSize = hi2c->XferCount;
 8008160:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8008162:	0033      	movs	r3, r6
          hi2c->XferSize = hi2c->XferCount;
 8008164:	b292      	uxth	r2, r2
 8008166:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8008168:	b2d2      	uxtb	r2, r2
 800816a:	9000      	str	r0, [sp, #0]
 800816c:	e7e0      	b.n	8008130 <HAL_I2C_Mem_Read+0x11c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800816e:	2120      	movs	r1, #32
 8008170:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
 8008172:	4d06      	ldr	r5, [pc, #24]	; (800818c <HAL_I2C_Mem_Read+0x178>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8008174:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8008176:	685a      	ldr	r2, [r3, #4]
 8008178:	402a      	ands	r2, r5
 800817a:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 800817c:	0023      	movs	r3, r4
 800817e:	3341      	adds	r3, #65	; 0x41
 8008180:	7019      	strb	r1, [r3, #0]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8008182:	9b05      	ldr	r3, [sp, #20]
    __HAL_UNLOCK(hi2c);
 8008184:	3440      	adds	r4, #64	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8008186:	7018      	strb	r0, [r3, #0]
    __HAL_UNLOCK(hi2c);
 8008188:	7020      	strb	r0, [r4, #0]
    return HAL_OK;
 800818a:	e758      	b.n	800803e <HAL_I2C_Mem_Read+0x2a>
 800818c:	fe00e800 	.word	0xfe00e800

08008190 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 8008190:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if(hi2c->State == HAL_I2C_STATE_READY)
 8008192:	0004      	movs	r4, r0
 8008194:	3441      	adds	r4, #65	; 0x41
 8008196:	7822      	ldrb	r2, [r4, #0]
{
 8008198:	0003      	movs	r3, r0
  if(hi2c->State == HAL_I2C_STATE_READY)
 800819a:	b2d2      	uxtb	r2, r2

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 800819c:	2002      	movs	r0, #2
  if(hi2c->State == HAL_I2C_STATE_READY)
 800819e:	2a20      	cmp	r2, #32
 80081a0:	d118      	bne.n	80081d4 <HAL_I2CEx_ConfigAnalogFilter+0x44>
    __HAL_LOCK(hi2c);
 80081a2:	001d      	movs	r5, r3
 80081a4:	3540      	adds	r5, #64	; 0x40
 80081a6:	782e      	ldrb	r6, [r5, #0]
 80081a8:	2e01      	cmp	r6, #1
 80081aa:	d013      	beq.n	80081d4 <HAL_I2CEx_ConfigAnalogFilter+0x44>
    __HAL_I2C_DISABLE(hi2c);
 80081ac:	681b      	ldr	r3, [r3, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 80081ae:	3022      	adds	r0, #34	; 0x22
 80081b0:	7020      	strb	r0, [r4, #0]
    __HAL_I2C_DISABLE(hi2c);
 80081b2:	681e      	ldr	r6, [r3, #0]
 80081b4:	3823      	subs	r0, #35	; 0x23
 80081b6:	4386      	bics	r6, r0
 80081b8:	601e      	str	r6, [r3, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 80081ba:	681e      	ldr	r6, [r3, #0]
 80081bc:	4f06      	ldr	r7, [pc, #24]	; (80081d8 <HAL_I2CEx_ConfigAnalogFilter+0x48>)
 80081be:	403e      	ands	r6, r7
 80081c0:	601e      	str	r6, [r3, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
 80081c2:	681e      	ldr	r6, [r3, #0]
 80081c4:	4331      	orrs	r1, r6
 80081c6:	6019      	str	r1, [r3, #0]
    __HAL_I2C_ENABLE(hi2c);
 80081c8:	6819      	ldr	r1, [r3, #0]
 80081ca:	4308      	orrs	r0, r1
 80081cc:	6018      	str	r0, [r3, #0]
    __HAL_UNLOCK(hi2c);
 80081ce:	2000      	movs	r0, #0
    hi2c->State = HAL_I2C_STATE_READY;
 80081d0:	7022      	strb	r2, [r4, #0]
    __HAL_UNLOCK(hi2c);
 80081d2:	7028      	strb	r0, [r5, #0]
  }
}
 80081d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80081d6:	46c0      	nop			; (mov r8, r8)
 80081d8:	ffffefff 	.word	0xffffefff

080081dc <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80081dc:	b530      	push	{r4, r5, lr}
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 80081de:	4c1b      	ldr	r4, [pc, #108]	; (800824c <HAL_RCC_GetSysClockFreq+0x70>)
{
 80081e0:	b089      	sub	sp, #36	; 0x24
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 80081e2:	2210      	movs	r2, #16
 80081e4:	0021      	movs	r1, r4
 80081e6:	4668      	mov	r0, sp
 80081e8:	f004 fcd8 	bl	800cb9c <memcpy>
                                         10U, 11U, 12U, 13U, 14U, 15U, 16U, 16U};
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 80081ec:	0021      	movs	r1, r4
 80081ee:	ad04      	add	r5, sp, #16
 80081f0:	2210      	movs	r2, #16
 80081f2:	3110      	adds	r1, #16
 80081f4:	0028      	movs	r0, r5
 80081f6:	f004 fcd1 	bl	800cb9c <memcpy>
  uint32_t sysclockfreq = 0U;
  
  tmpreg = RCC->CFGR;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 80081fa:	200c      	movs	r0, #12
  tmpreg = RCC->CFGR;
 80081fc:	4a14      	ldr	r2, [pc, #80]	; (8008250 <HAL_RCC_GetSysClockFreq+0x74>)
 80081fe:	6853      	ldr	r3, [r2, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 8008200:	4018      	ands	r0, r3
 8008202:	2808      	cmp	r0, #8
 8008204:	d009      	beq.n	800821a <HAL_RCC_GetSysClockFreq+0x3e>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    {
      sysclockfreq = HSE_VALUE;
 8008206:	380c      	subs	r0, #12
 8008208:	4243      	negs	r3, r0
 800820a:	4158      	adcs	r0, r3
 800820c:	4b11      	ldr	r3, [pc, #68]	; (8008254 <HAL_RCC_GetSysClockFreq+0x78>)
 800820e:	4240      	negs	r0, r0
 8008210:	4018      	ands	r0, r3
 8008212:	4b11      	ldr	r3, [pc, #68]	; (8008258 <HAL_RCC_GetSysClockFreq+0x7c>)
 8008214:	18c0      	adds	r0, r0, r3
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8008216:	b009      	add	sp, #36	; 0x24
 8008218:	bd30      	pop	{r4, r5, pc}
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 800821a:	200f      	movs	r0, #15
 800821c:	466c      	mov	r4, sp
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 800821e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 8008220:	0c99      	lsrs	r1, r3, #18
 8008222:	4001      	ands	r1, r0
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 8008224:	4002      	ands	r2, r0
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 8008226:	5c64      	ldrb	r4, [r4, r1]
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 8008228:	5ca9      	ldrb	r1, [r5, r2]
      if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 800822a:	22c0      	movs	r2, #192	; 0xc0
 800822c:	2080      	movs	r0, #128	; 0x80
 800822e:	0252      	lsls	r2, r2, #9
 8008230:	4013      	ands	r3, r2
 8008232:	0240      	lsls	r0, r0, #9
 8008234:	4283      	cmp	r3, r0
 8008236:	d101      	bne.n	800823c <HAL_RCC_GetSysClockFreq+0x60>
        pllclk = (HSI_VALUE / prediv) * pllmul;
 8008238:	4807      	ldr	r0, [pc, #28]	; (8008258 <HAL_RCC_GetSysClockFreq+0x7c>)
 800823a:	e002      	b.n	8008242 <HAL_RCC_GetSysClockFreq+0x66>
      else if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSI48)
 800823c:	4293      	cmp	r3, r2
 800823e:	d1fb      	bne.n	8008238 <HAL_RCC_GetSysClockFreq+0x5c>
        pllclk = (HSI48_VALUE / prediv) * pllmul;
 8008240:	4806      	ldr	r0, [pc, #24]	; (800825c <HAL_RCC_GetSysClockFreq+0x80>)
        pllclk = (HSI_VALUE / prediv) * pllmul;
 8008242:	f7fd fbc1 	bl	80059c8 <__udivsi3>
 8008246:	4360      	muls	r0, r4
 8008248:	e7e5      	b.n	8008216 <HAL_RCC_GetSysClockFreq+0x3a>
 800824a:	46c0      	nop			; (mov r8, r8)
 800824c:	0800cd30 	.word	0x0800cd30
 8008250:	40021000 	.word	0x40021000
 8008254:	02625a00 	.word	0x02625a00
 8008258:	007a1200 	.word	0x007a1200
 800825c:	02dc6c00 	.word	0x02dc6c00

08008260 <HAL_RCC_GetHCLKFreq>:
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
 8008260:	4b01      	ldr	r3, [pc, #4]	; (8008268 <HAL_RCC_GetHCLKFreq+0x8>)
 8008262:	6818      	ldr	r0, [r3, #0]
}
 8008264:	4770      	bx	lr
 8008266:	46c0      	nop			; (mov r8, r8)
 8008268:	20000030 	.word	0x20000030

0800826c <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE) >> RCC_CFGR_PPRE_BITNUMBER]);
 800826c:	4b04      	ldr	r3, [pc, #16]	; (8008280 <HAL_RCC_GetPCLK1Freq+0x14>)
 800826e:	4a05      	ldr	r2, [pc, #20]	; (8008284 <HAL_RCC_GetPCLK1Freq+0x18>)
 8008270:	685b      	ldr	r3, [r3, #4]
 8008272:	055b      	lsls	r3, r3, #21
 8008274:	0f5b      	lsrs	r3, r3, #29
 8008276:	5cd3      	ldrb	r3, [r2, r3]
 8008278:	4a03      	ldr	r2, [pc, #12]	; (8008288 <HAL_RCC_GetPCLK1Freq+0x1c>)
 800827a:	6810      	ldr	r0, [r2, #0]
 800827c:	40d8      	lsrs	r0, r3
}    
 800827e:	4770      	bx	lr
 8008280:	40021000 	.word	0x40021000
 8008284:	0800cd28 	.word	0x0800cd28
 8008288:	20000030 	.word	0x20000030

0800828c <SPI_WaitFifoStateUntilTimeout.part.1>:
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800828c:	21e0      	movs	r1, #224	; 0xe0
 800828e:	6803      	ldr	r3, [r0, #0]
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State,
 8008290:	b510      	push	{r4, lr}
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8008292:	685a      	ldr	r2, [r3, #4]
 8008294:	438a      	bics	r2, r1
 8008296:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8008298:	2282      	movs	r2, #130	; 0x82
 800829a:	6841      	ldr	r1, [r0, #4]
 800829c:	0052      	lsls	r2, r2, #1
 800829e:	4291      	cmp	r1, r2
 80082a0:	d10c      	bne.n	80082bc <SPI_WaitFifoStateUntilTimeout.part.1+0x30>
 80082a2:	2180      	movs	r1, #128	; 0x80
 80082a4:	6882      	ldr	r2, [r0, #8]
 80082a6:	0209      	lsls	r1, r1, #8
 80082a8:	428a      	cmp	r2, r1
 80082aa:	d003      	beq.n	80082b4 <SPI_WaitFifoStateUntilTimeout.part.1+0x28>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80082ac:	2180      	movs	r1, #128	; 0x80
 80082ae:	00c9      	lsls	r1, r1, #3
 80082b0:	428a      	cmp	r2, r1
 80082b2:	d103      	bne.n	80082bc <SPI_WaitFifoStateUntilTimeout.part.1+0x30>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 80082b4:	2140      	movs	r1, #64	; 0x40
 80082b6:	681a      	ldr	r2, [r3, #0]
 80082b8:	438a      	bics	r2, r1
 80082ba:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80082bc:	2180      	movs	r1, #128	; 0x80
 80082be:	6a82      	ldr	r2, [r0, #40]	; 0x28
 80082c0:	0189      	lsls	r1, r1, #6
 80082c2:	428a      	cmp	r2, r1
 80082c4:	d106      	bne.n	80082d4 <SPI_WaitFifoStateUntilTimeout.part.1+0x48>
        {
          SPI_RESET_CRC(hspi);
 80082c6:	6819      	ldr	r1, [r3, #0]
 80082c8:	4c07      	ldr	r4, [pc, #28]	; (80082e8 <SPI_WaitFifoStateUntilTimeout.part.1+0x5c>)
 80082ca:	4021      	ands	r1, r4
 80082cc:	6019      	str	r1, [r3, #0]
 80082ce:	6819      	ldr	r1, [r3, #0]
 80082d0:	430a      	orrs	r2, r1
 80082d2:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 80082d4:	0003      	movs	r3, r0
 80082d6:	2201      	movs	r2, #1
 80082d8:	335d      	adds	r3, #93	; 0x5d
 80082da:	701a      	strb	r2, [r3, #0]

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 80082dc:	2300      	movs	r3, #0
 80082de:	305c      	adds	r0, #92	; 0x5c
 80082e0:	7003      	strb	r3, [r0, #0]
      }
    }
  }

  return HAL_OK;
}
 80082e2:	2003      	movs	r0, #3
 80082e4:	bd10      	pop	{r4, pc}
 80082e6:	46c0      	nop			; (mov r8, r8)
 80082e8:	ffffdfff 	.word	0xffffdfff

080082ec <SPI_WaitFlagStateUntilTimeout>:
{
 80082ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80082ee:	0006      	movs	r6, r0
 80082f0:	000d      	movs	r5, r1
 80082f2:	0017      	movs	r7, r2
 80082f4:	001c      	movs	r4, r3
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 80082f6:	6832      	ldr	r2, [r6, #0]
 80082f8:	6893      	ldr	r3, [r2, #8]
 80082fa:	402b      	ands	r3, r5
 80082fc:	1b5b      	subs	r3, r3, r5
 80082fe:	4259      	negs	r1, r3
 8008300:	414b      	adcs	r3, r1
 8008302:	429f      	cmp	r7, r3
 8008304:	d101      	bne.n	800830a <SPI_WaitFlagStateUntilTimeout+0x1e>
  return HAL_OK;
 8008306:	2000      	movs	r0, #0
 8008308:	e006      	b.n	8008318 <SPI_WaitFlagStateUntilTimeout+0x2c>
    if (Timeout != HAL_MAX_DELAY)
 800830a:	1c63      	adds	r3, r4, #1
 800830c:	d0f4      	beq.n	80082f8 <SPI_WaitFlagStateUntilTimeout+0xc>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 800830e:	2c00      	cmp	r4, #0
 8008310:	d103      	bne.n	800831a <SPI_WaitFlagStateUntilTimeout+0x2e>
 8008312:	0030      	movs	r0, r6
 8008314:	f7ff ffba 	bl	800828c <SPI_WaitFifoStateUntilTimeout.part.1>
}
 8008318:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 800831a:	f7fe ff01 	bl	8007120 <HAL_GetTick>
 800831e:	9b06      	ldr	r3, [sp, #24]
 8008320:	1ac0      	subs	r0, r0, r3
 8008322:	42a0      	cmp	r0, r4
 8008324:	d3e7      	bcc.n	80082f6 <SPI_WaitFlagStateUntilTimeout+0xa>
 8008326:	e7f4      	b.n	8008312 <SPI_WaitFlagStateUntilTimeout+0x26>

08008328 <SPI_WaitFifoStateUntilTimeout>:
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8008328:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800832a:	0007      	movs	r7, r0
 800832c:	000e      	movs	r6, r1
 800832e:	0015      	movs	r5, r2
 8008330:	001c      	movs	r4, r3

  while ((hspi->Instance->SR & Fifo) != State)
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
    {
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 8008332:	466b      	mov	r3, sp
  while ((hspi->Instance->SR & Fifo) != State)
 8008334:	6839      	ldr	r1, [r7, #0]
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 8008336:	1dda      	adds	r2, r3, #7
  while ((hspi->Instance->SR & Fifo) != State)
 8008338:	688b      	ldr	r3, [r1, #8]
 800833a:	4033      	ands	r3, r6
 800833c:	42ab      	cmp	r3, r5
 800833e:	d101      	bne.n	8008344 <SPI_WaitFifoStateUntilTimeout+0x1c>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 8008340:	2000      	movs	r0, #0
 8008342:	e010      	b.n	8008366 <SPI_WaitFifoStateUntilTimeout+0x3e>
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 8008344:	23c0      	movs	r3, #192	; 0xc0
 8008346:	00db      	lsls	r3, r3, #3
 8008348:	429e      	cmp	r6, r3
 800834a:	d105      	bne.n	8008358 <SPI_WaitFifoStateUntilTimeout+0x30>
 800834c:	2d00      	cmp	r5, #0
 800834e:	d103      	bne.n	8008358 <SPI_WaitFifoStateUntilTimeout+0x30>
      tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
 8008350:	7b0b      	ldrb	r3, [r1, #12]
 8008352:	b2db      	uxtb	r3, r3
 8008354:	7013      	strb	r3, [r2, #0]
      UNUSED(tmpreg);
 8008356:	7813      	ldrb	r3, [r2, #0]
    if (Timeout != HAL_MAX_DELAY)
 8008358:	1c63      	adds	r3, r4, #1
 800835a:	d0ed      	beq.n	8008338 <SPI_WaitFifoStateUntilTimeout+0x10>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 800835c:	2c00      	cmp	r4, #0
 800835e:	d103      	bne.n	8008368 <SPI_WaitFifoStateUntilTimeout+0x40>
 8008360:	0038      	movs	r0, r7
 8008362:	f7ff ff93 	bl	800828c <SPI_WaitFifoStateUntilTimeout.part.1>
}
 8008366:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) >= Timeout))
 8008368:	f7fe feda 	bl	8007120 <HAL_GetTick>
 800836c:	9b08      	ldr	r3, [sp, #32]
 800836e:	1ac0      	subs	r0, r0, r3
 8008370:	42a0      	cmp	r0, r4
 8008372:	d3de      	bcc.n	8008332 <SPI_WaitFifoStateUntilTimeout+0xa>
 8008374:	e7f4      	b.n	8008360 <SPI_WaitFifoStateUntilTimeout+0x38>

08008376 <SPI_EndRxTransaction>:
  * @param  Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
{
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8008376:	2382      	movs	r3, #130	; 0x82
{
 8008378:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800837a:	0017      	movs	r7, r2
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800837c:	6842      	ldr	r2, [r0, #4]
{
 800837e:	0004      	movs	r4, r0
 8008380:	000e      	movs	r6, r1
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8008382:	005b      	lsls	r3, r3, #1
 8008384:	429a      	cmp	r2, r3
 8008386:	d10d      	bne.n	80083a4 <SPI_EndRxTransaction+0x2e>
 8008388:	2280      	movs	r2, #128	; 0x80
 800838a:	6883      	ldr	r3, [r0, #8]
 800838c:	0212      	lsls	r2, r2, #8
 800838e:	4293      	cmp	r3, r2
 8008390:	d003      	beq.n	800839a <SPI_EndRxTransaction+0x24>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8008392:	2280      	movs	r2, #128	; 0x80
 8008394:	00d2      	lsls	r2, r2, #3
 8008396:	4293      	cmp	r3, r2
 8008398:	d104      	bne.n	80083a4 <SPI_EndRxTransaction+0x2e>
  {
    /* Disable SPI peripheral */
    __HAL_SPI_DISABLE(hspi);
 800839a:	2140      	movs	r1, #64	; 0x40
 800839c:	6822      	ldr	r2, [r4, #0]
 800839e:	6813      	ldr	r3, [r2, #0]
 80083a0:	438b      	bics	r3, r1
 80083a2:	6013      	str	r3, [r2, #0]
  }

  /* Control the BSY flag */
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 80083a4:	9700      	str	r7, [sp, #0]
 80083a6:	0033      	movs	r3, r6
 80083a8:	2200      	movs	r2, #0
 80083aa:	2180      	movs	r1, #128	; 0x80
 80083ac:	0020      	movs	r0, r4
 80083ae:	f7ff ff9d 	bl	80082ec <SPI_WaitFlagStateUntilTimeout>
 80083b2:	1e05      	subs	r5, r0, #0
 80083b4:	d005      	beq.n	80083c2 <SPI_EndRxTransaction+0x4c>
  }

  /* Control if the RX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80083b6:	2320      	movs	r3, #32
 80083b8:	6e22      	ldr	r2, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 80083ba:	2503      	movs	r5, #3
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80083bc:	4313      	orrs	r3, r2
 80083be:	6623      	str	r3, [r4, #96]	; 0x60
 80083c0:	e017      	b.n	80083f2 <SPI_EndRxTransaction+0x7c>
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80083c2:	2382      	movs	r3, #130	; 0x82
 80083c4:	6862      	ldr	r2, [r4, #4]
 80083c6:	005b      	lsls	r3, r3, #1
 80083c8:	429a      	cmp	r2, r3
 80083ca:	d112      	bne.n	80083f2 <SPI_EndRxTransaction+0x7c>
 80083cc:	2280      	movs	r2, #128	; 0x80
 80083ce:	68a3      	ldr	r3, [r4, #8]
 80083d0:	0212      	lsls	r2, r2, #8
 80083d2:	4293      	cmp	r3, r2
 80083d4:	d003      	beq.n	80083de <SPI_EndRxTransaction+0x68>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80083d6:	2280      	movs	r2, #128	; 0x80
 80083d8:	00d2      	lsls	r2, r2, #3
 80083da:	4293      	cmp	r3, r2
 80083dc:	d109      	bne.n	80083f2 <SPI_EndRxTransaction+0x7c>
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80083de:	21c0      	movs	r1, #192	; 0xc0
 80083e0:	9700      	str	r7, [sp, #0]
 80083e2:	0033      	movs	r3, r6
 80083e4:	2200      	movs	r2, #0
 80083e6:	00c9      	lsls	r1, r1, #3
 80083e8:	0020      	movs	r0, r4
 80083ea:	f7ff ff9d 	bl	8008328 <SPI_WaitFifoStateUntilTimeout>
 80083ee:	2800      	cmp	r0, #0
 80083f0:	d1e1      	bne.n	80083b6 <SPI_EndRxTransaction+0x40>
}
 80083f2:	0028      	movs	r0, r5
 80083f4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

080083f6 <SPI_EndRxTxTransaction>:
{
 80083f6:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80083f8:	000b      	movs	r3, r1
{
 80083fa:	000d      	movs	r5, r1
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80083fc:	21c0      	movs	r1, #192	; 0xc0
 80083fe:	9200      	str	r2, [sp, #0]
{
 8008400:	0016      	movs	r6, r2
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8008402:	0149      	lsls	r1, r1, #5
 8008404:	2200      	movs	r2, #0
{
 8008406:	0004      	movs	r4, r0
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8008408:	f7ff ff8e 	bl	8008328 <SPI_WaitFifoStateUntilTimeout>
 800840c:	1e02      	subs	r2, r0, #0
 800840e:	d005      	beq.n	800841c <SPI_EndRxTxTransaction+0x26>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8008410:	2320      	movs	r3, #32
 8008412:	6e22      	ldr	r2, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 8008414:	2003      	movs	r0, #3
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8008416:	4313      	orrs	r3, r2
 8008418:	6623      	str	r3, [r4, #96]	; 0x60
 800841a:	e010      	b.n	800843e <SPI_EndRxTxTransaction+0x48>
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 800841c:	9600      	str	r6, [sp, #0]
 800841e:	002b      	movs	r3, r5
 8008420:	2180      	movs	r1, #128	; 0x80
 8008422:	0020      	movs	r0, r4
 8008424:	f7ff ff62 	bl	80082ec <SPI_WaitFlagStateUntilTimeout>
 8008428:	1e02      	subs	r2, r0, #0
 800842a:	d1f1      	bne.n	8008410 <SPI_EndRxTxTransaction+0x1a>
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 800842c:	21c0      	movs	r1, #192	; 0xc0
 800842e:	9600      	str	r6, [sp, #0]
 8008430:	002b      	movs	r3, r5
 8008432:	00c9      	lsls	r1, r1, #3
 8008434:	0020      	movs	r0, r4
 8008436:	f7ff ff77 	bl	8008328 <SPI_WaitFifoStateUntilTimeout>
 800843a:	2800      	cmp	r0, #0
 800843c:	d1e8      	bne.n	8008410 <SPI_EndRxTxTransaction+0x1a>
  }
  return HAL_OK;
}
 800843e:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

08008440 <HAL_SPI_Init>:
{
 8008440:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8008442:	0004      	movs	r4, r0
    return HAL_ERROR;
 8008444:	2001      	movs	r0, #1
  if (hspi == NULL)
 8008446:	2c00      	cmp	r4, #0
 8008448:	d05f      	beq.n	800850a <HAL_SPI_Init+0xca>
  if (hspi->State == HAL_SPI_STATE_RESET)
 800844a:	0025      	movs	r5, r4
 800844c:	355d      	adds	r5, #93	; 0x5d
 800844e:	782b      	ldrb	r3, [r5, #0]
 8008450:	b2db      	uxtb	r3, r3
 8008452:	2b00      	cmp	r3, #0
 8008454:	d105      	bne.n	8008462 <HAL_SPI_Init+0x22>
    hspi->Lock = HAL_UNLOCKED;
 8008456:	0022      	movs	r2, r4
 8008458:	325c      	adds	r2, #92	; 0x5c
 800845a:	7013      	strb	r3, [r2, #0]
    HAL_SPI_MspInit(hspi);
 800845c:	0020      	movs	r0, r4
 800845e:	f7fd fd29 	bl	8005eb4 <HAL_SPI_MspInit>
  hspi->State = HAL_SPI_STATE_BUSY;
 8008462:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);
 8008464:	2140      	movs	r1, #64	; 0x40
 8008466:	6822      	ldr	r2, [r4, #0]
  hspi->State = HAL_SPI_STATE_BUSY;
 8008468:	702b      	strb	r3, [r5, #0]
  __HAL_SPI_DISABLE(hspi);
 800846a:	6813      	ldr	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800846c:	68e0      	ldr	r0, [r4, #12]
  __HAL_SPI_DISABLE(hspi);
 800846e:	438b      	bics	r3, r1
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008470:	21e0      	movs	r1, #224	; 0xe0
  __HAL_SPI_DISABLE(hspi);
 8008472:	6013      	str	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008474:	00c9      	lsls	r1, r1, #3
 8008476:	2300      	movs	r3, #0
 8008478:	4288      	cmp	r0, r1
 800847a:	d847      	bhi.n	800850c <HAL_SPI_Init+0xcc>
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 800847c:	2680      	movs	r6, #128	; 0x80
 800847e:	0176      	lsls	r6, r6, #5
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8008480:	4288      	cmp	r0, r1
 8008482:	d101      	bne.n	8008488 <HAL_SPI_Init+0x48>
 8008484:	e001      	b.n	800848a <HAL_SPI_Init+0x4a>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8008486:	001e      	movs	r6, r3
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8008488:	62a3      	str	r3, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 800848a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800848c:	2b00      	cmp	r3, #0
 800848e:	d104      	bne.n	800849a <HAL_SPI_Init+0x5a>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 8008490:	3302      	adds	r3, #2
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008492:	4288      	cmp	r0, r1
 8008494:	d800      	bhi.n	8008498 <HAL_SPI_Init+0x58>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 8008496:	2301      	movs	r3, #1
 8008498:	6323      	str	r3, [r4, #48]	; 0x30
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 800849a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800849c:	68a7      	ldr	r7, [r4, #8]
 800849e:	9301      	str	r3, [sp, #4]
 80084a0:	6863      	ldr	r3, [r4, #4]
 80084a2:	69a1      	ldr	r1, [r4, #24]
 80084a4:	433b      	orrs	r3, r7
 80084a6:	6927      	ldr	r7, [r4, #16]
 80084a8:	433b      	orrs	r3, r7
 80084aa:	6967      	ldr	r7, [r4, #20]
 80084ac:	433b      	orrs	r3, r7
 80084ae:	69e7      	ldr	r7, [r4, #28]
 80084b0:	433b      	orrs	r3, r7
 80084b2:	6a27      	ldr	r7, [r4, #32]
 80084b4:	433b      	orrs	r3, r7
 80084b6:	9f01      	ldr	r7, [sp, #4]
 80084b8:	433b      	orrs	r3, r7
 80084ba:	2780      	movs	r7, #128	; 0x80
 80084bc:	00bf      	lsls	r7, r7, #2
 80084be:	400f      	ands	r7, r1
 80084c0:	433b      	orrs	r3, r7
 80084c2:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 80084c4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80084c6:	2b02      	cmp	r3, #2
 80084c8:	d106      	bne.n	80084d8 <HAL_SPI_Init+0x98>
    hspi->Instance->CR1 |= SPI_CR1_CRCL;
 80084ca:	6813      	ldr	r3, [r2, #0]
 80084cc:	469c      	mov	ip, r3
 80084ce:	2380      	movs	r3, #128	; 0x80
 80084d0:	4667      	mov	r7, ip
 80084d2:	011b      	lsls	r3, r3, #4
 80084d4:	433b      	orrs	r3, r7
 80084d6:	6013      	str	r3, [r2, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 80084d8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80084da:	0c09      	lsrs	r1, r1, #16
 80084dc:	4318      	orrs	r0, r3
 80084de:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80084e0:	4318      	orrs	r0, r3
 80084e2:	2304      	movs	r3, #4
 80084e4:	4019      	ands	r1, r3
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80084e6:	2380      	movs	r3, #128	; 0x80
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 80084e8:	4301      	orrs	r1, r0
 80084ea:	430e      	orrs	r6, r1
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80084ec:	9901      	ldr	r1, [sp, #4]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 80084ee:	6056      	str	r6, [r2, #4]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80084f0:	019b      	lsls	r3, r3, #6
 80084f2:	4299      	cmp	r1, r3
 80084f4:	d101      	bne.n	80084fa <HAL_SPI_Init+0xba>
    WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
 80084f6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80084f8:	6113      	str	r3, [r2, #16]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80084fa:	69d3      	ldr	r3, [r2, #28]
 80084fc:	4906      	ldr	r1, [pc, #24]	; (8008518 <HAL_SPI_Init+0xd8>)
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80084fe:	2000      	movs	r0, #0
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8008500:	400b      	ands	r3, r1
 8008502:	61d3      	str	r3, [r2, #28]
  hspi->State     = HAL_SPI_STATE_READY;
 8008504:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8008506:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8008508:	702b      	strb	r3, [r5, #0]
}
 800850a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 800850c:	26f0      	movs	r6, #240	; 0xf0
 800850e:	0136      	lsls	r6, r6, #4
 8008510:	42b0      	cmp	r0, r6
 8008512:	d1b8      	bne.n	8008486 <HAL_SPI_Init+0x46>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8008514:	001e      	movs	r6, r3
 8008516:	e7b8      	b.n	800848a <HAL_SPI_Init+0x4a>
 8008518:	fffff7ff 	.word	0xfffff7ff

0800851c <HAL_SPI_Transmit_DMA>:
{
 800851c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hspi);
 800851e:	0005      	movs	r5, r0
 8008520:	355c      	adds	r5, #92	; 0x5c
 8008522:	782b      	ldrb	r3, [r5, #0]
{
 8008524:	0004      	movs	r4, r0
  __HAL_LOCK(hspi);
 8008526:	2002      	movs	r0, #2
 8008528:	2b01      	cmp	r3, #1
 800852a:	d069      	beq.n	8008600 <HAL_SPI_Transmit_DMA+0xe4>
 800852c:	2301      	movs	r3, #1
  if (hspi->State != HAL_SPI_STATE_READY)
 800852e:	0026      	movs	r6, r4
  __HAL_LOCK(hspi);
 8008530:	702b      	strb	r3, [r5, #0]
  if (hspi->State != HAL_SPI_STATE_READY)
 8008532:	365d      	adds	r6, #93	; 0x5d
 8008534:	7833      	ldrb	r3, [r6, #0]
 8008536:	b2db      	uxtb	r3, r3
 8008538:	2b01      	cmp	r3, #1
 800853a:	d15f      	bne.n	80085fc <HAL_SPI_Transmit_DMA+0xe0>
    errorcode = HAL_ERROR;
 800853c:	0018      	movs	r0, r3
  if ((pData == NULL) || (Size == 0U))
 800853e:	2900      	cmp	r1, #0
 8008540:	d05c      	beq.n	80085fc <HAL_SPI_Transmit_DMA+0xe0>
 8008542:	2a00      	cmp	r2, #0
 8008544:	d05a      	beq.n	80085fc <HAL_SPI_Transmit_DMA+0xe0>
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8008546:	3302      	adds	r3, #2
 8008548:	7033      	strb	r3, [r6, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800854a:	2300      	movs	r3, #0
  hspi->TxXferSize  = Size;
 800854c:	87a2      	strh	r2, [r4, #60]	; 0x3c
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800854e:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->TxXferCount = Size;
 8008550:	87e2      	strh	r2, [r4, #62]	; 0x3e
  hspi->RxXferSize  = 0U;
 8008552:	1da2      	adds	r2, r4, #6
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8008554:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->TxISR       = NULL;
 8008556:	6523      	str	r3, [r4, #80]	; 0x50
  hspi->RxISR       = NULL;
 8008558:	64e3      	str	r3, [r4, #76]	; 0x4c
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 800855a:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->RxXferCount = 0U;
 800855c:	3202      	adds	r2, #2
  hspi->RxXferSize  = 0U;
 800855e:	8793      	strh	r3, [r2, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 8008560:	87d3      	strh	r3, [r2, #62]	; 0x3e
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8008562:	2380      	movs	r3, #128	; 0x80
 8008564:	68a0      	ldr	r0, [r4, #8]
 8008566:	6822      	ldr	r2, [r4, #0]
 8008568:	021b      	lsls	r3, r3, #8
 800856a:	4298      	cmp	r0, r3
 800856c:	d104      	bne.n	8008578 <HAL_SPI_Transmit_DMA+0x5c>
    SPI_1LINE_TX(hspi);
 800856e:	2380      	movs	r3, #128	; 0x80
 8008570:	6810      	ldr	r0, [r2, #0]
 8008572:	01db      	lsls	r3, r3, #7
 8008574:	4303      	orrs	r3, r0
 8008576:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008578:	2080      	movs	r0, #128	; 0x80
 800857a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800857c:	0180      	lsls	r0, r0, #6
 800857e:	4283      	cmp	r3, r0
 8008580:	d106      	bne.n	8008590 <HAL_SPI_Transmit_DMA+0x74>
    SPI_RESET_CRC(hspi);
 8008582:	6810      	ldr	r0, [r2, #0]
 8008584:	4e23      	ldr	r6, [pc, #140]	; (8008614 <HAL_SPI_Transmit_DMA+0xf8>)
 8008586:	4030      	ands	r0, r6
 8008588:	6010      	str	r0, [r2, #0]
 800858a:	6810      	ldr	r0, [r2, #0]
 800858c:	4303      	orrs	r3, r0
 800858e:	6013      	str	r3, [r2, #0]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 8008590:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8008592:	4b21      	ldr	r3, [pc, #132]	; (8008618 <HAL_SPI_Transmit_DMA+0xfc>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8008594:	6856      	ldr	r6, [r2, #4]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 8008596:	62c3      	str	r3, [r0, #44]	; 0x2c
  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
 8008598:	4b20      	ldr	r3, [pc, #128]	; (800861c <HAL_SPI_Transmit_DMA+0x100>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 800859a:	4f21      	ldr	r7, [pc, #132]	; (8008620 <HAL_SPI_Transmit_DMA+0x104>)
  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
 800859c:	6283      	str	r3, [r0, #40]	; 0x28
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 800859e:	4b21      	ldr	r3, [pc, #132]	; (8008624 <HAL_SPI_Transmit_DMA+0x108>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80085a0:	403e      	ands	r6, r7
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 80085a2:	6303      	str	r3, [r0, #48]	; 0x30
  hspi->hdmatx->XferAbortCallback = NULL;
 80085a4:	2300      	movs	r3, #0
 80085a6:	6343      	str	r3, [r0, #52]	; 0x34
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 80085a8:	23e0      	movs	r3, #224	; 0xe0
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80085aa:	6056      	str	r6, [r2, #4]
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 80085ac:	68e6      	ldr	r6, [r4, #12]
 80085ae:	00db      	lsls	r3, r3, #3
 80085b0:	429e      	cmp	r6, r3
 80085b2:	d80d      	bhi.n	80085d0 <HAL_SPI_Transmit_DMA+0xb4>
 80085b4:	2380      	movs	r3, #128	; 0x80
 80085b6:	6946      	ldr	r6, [r0, #20]
 80085b8:	00db      	lsls	r3, r3, #3
 80085ba:	429e      	cmp	r6, r3
 80085bc:	d108      	bne.n	80085d0 <HAL_SPI_Transmit_DMA+0xb4>
    if ((hspi->TxXferCount & 0x1U) == 0U)
 80085be:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80085c0:	07db      	lsls	r3, r3, #31
 80085c2:	d41e      	bmi.n	8008602 <HAL_SPI_Transmit_DMA+0xe6>
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 80085c4:	6853      	ldr	r3, [r2, #4]
 80085c6:	403b      	ands	r3, r7
 80085c8:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U);
 80085ca:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80085cc:	085b      	lsrs	r3, r3, #1
      hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 80085ce:	87e3      	strh	r3, [r4, #62]	; 0x3e
  HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
 80085d0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80085d2:	320c      	adds	r2, #12
 80085d4:	b29b      	uxth	r3, r3
 80085d6:	f7ff f99d 	bl	8007914 <HAL_DMA_Start_IT>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80085da:	2240      	movs	r2, #64	; 0x40
 80085dc:	6823      	ldr	r3, [r4, #0]
 80085de:	6819      	ldr	r1, [r3, #0]
 80085e0:	4211      	tst	r1, r2
 80085e2:	d102      	bne.n	80085ea <HAL_SPI_Transmit_DMA+0xce>
    __HAL_SPI_ENABLE(hspi);
 80085e4:	6819      	ldr	r1, [r3, #0]
 80085e6:	430a      	orrs	r2, r1
 80085e8:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 80085ea:	2220      	movs	r2, #32
 80085ec:	6859      	ldr	r1, [r3, #4]
  HAL_StatusTypeDef errorcode = HAL_OK;
 80085ee:	2000      	movs	r0, #0
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 80085f0:	430a      	orrs	r2, r1
 80085f2:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 80085f4:	2202      	movs	r2, #2
 80085f6:	6859      	ldr	r1, [r3, #4]
 80085f8:	430a      	orrs	r2, r1
 80085fa:	605a      	str	r2, [r3, #4]
  __HAL_UNLOCK(hspi);
 80085fc:	2300      	movs	r3, #0
 80085fe:	702b      	strb	r3, [r5, #0]
}
 8008600:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8008602:	2380      	movs	r3, #128	; 0x80
 8008604:	6856      	ldr	r6, [r2, #4]
 8008606:	01db      	lsls	r3, r3, #7
 8008608:	4333      	orrs	r3, r6
 800860a:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 800860c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800860e:	085b      	lsrs	r3, r3, #1
 8008610:	3301      	adds	r3, #1
 8008612:	e7dc      	b.n	80085ce <HAL_SPI_Transmit_DMA+0xb2>
 8008614:	ffffdfff 	.word	0xffffdfff
 8008618:	08008975 	.word	0x08008975
 800861c:	080089bd 	.word	0x080089bd
 8008620:	ffffbfff 	.word	0xffffbfff
 8008624:	08008999 	.word	0x08008999

08008628 <HAL_SPI_TransmitReceive_DMA>:
{
 8008628:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  __HAL_LOCK(hspi);
 800862a:	0006      	movs	r6, r0
 800862c:	365c      	adds	r6, #92	; 0x5c
 800862e:	9601      	str	r6, [sp, #4]
 8008630:	7835      	ldrb	r5, [r6, #0]
{
 8008632:	0004      	movs	r4, r0
  __HAL_LOCK(hspi);
 8008634:	2002      	movs	r0, #2
 8008636:	2d01      	cmp	r5, #1
 8008638:	d07d      	beq.n	8008736 <HAL_SPI_TransmitReceive_DMA+0x10e>
 800863a:	0035      	movs	r5, r6
 800863c:	3801      	subs	r0, #1
 800863e:	7030      	strb	r0, [r6, #0]
  tmp  = hspi->State;
 8008640:	3501      	adds	r5, #1
 8008642:	782f      	ldrb	r7, [r5, #0]
 8008644:	b2ff      	uxtb	r7, r7
  if (!((tmp == HAL_SPI_STATE_READY) ||
 8008646:	4287      	cmp	r7, r0
 8008648:	d00c      	beq.n	8008664 <HAL_SPI_TransmitReceive_DMA+0x3c>
 800864a:	3004      	adds	r0, #4
 800864c:	30ff      	adds	r0, #255	; 0xff
 800864e:	4684      	mov	ip, r0
 8008650:	6866      	ldr	r6, [r4, #4]
    errorcode = HAL_BUSY;
 8008652:	3803      	subs	r0, #3
 8008654:	38ff      	subs	r0, #255	; 0xff
  if (!((tmp == HAL_SPI_STATE_READY) ||
 8008656:	4566      	cmp	r6, ip
 8008658:	d16a      	bne.n	8008730 <HAL_SPI_TransmitReceive_DMA+0x108>
        ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
 800865a:	68a6      	ldr	r6, [r4, #8]
 800865c:	2e00      	cmp	r6, #0
 800865e:	d167      	bne.n	8008730 <HAL_SPI_TransmitReceive_DMA+0x108>
 8008660:	2f04      	cmp	r7, #4
 8008662:	d165      	bne.n	8008730 <HAL_SPI_TransmitReceive_DMA+0x108>
    errorcode = HAL_ERROR;
 8008664:	2001      	movs	r0, #1
  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 8008666:	2900      	cmp	r1, #0
 8008668:	d062      	beq.n	8008730 <HAL_SPI_TransmitReceive_DMA+0x108>
 800866a:	2a00      	cmp	r2, #0
 800866c:	d060      	beq.n	8008730 <HAL_SPI_TransmitReceive_DMA+0x108>
 800866e:	2b00      	cmp	r3, #0
 8008670:	d05e      	beq.n	8008730 <HAL_SPI_TransmitReceive_DMA+0x108>
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8008672:	7828      	ldrb	r0, [r5, #0]
 8008674:	2804      	cmp	r0, #4
 8008676:	d001      	beq.n	800867c <HAL_SPI_TransmitReceive_DMA+0x54>
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 8008678:	2005      	movs	r0, #5
 800867a:	7028      	strb	r0, [r5, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800867c:	2000      	movs	r0, #0
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800867e:	2780      	movs	r7, #128	; 0x80
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8008680:	6422      	str	r2, [r4, #64]	; 0x40
  hspi->RxXferSize  = Size;
 8008682:	1da2      	adds	r2, r4, #6
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8008684:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 8008686:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->TxXferSize  = Size;
 8008688:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->TxXferCount = Size;
 800868a:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->RxXferCount = Size;
 800868c:	3202      	adds	r2, #2
  hspi->RxXferSize  = Size;
 800868e:	8793      	strh	r3, [r2, #60]	; 0x3c
  hspi->RxXferCount = Size;
 8008690:	87d3      	strh	r3, [r2, #62]	; 0x3e
  hspi->RxISR       = NULL;
 8008692:	64e0      	str	r0, [r4, #76]	; 0x4c
  hspi->TxISR       = NULL;
 8008694:	6520      	str	r0, [r4, #80]	; 0x50
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008696:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8008698:	6821      	ldr	r1, [r4, #0]
 800869a:	01bf      	lsls	r7, r7, #6
 800869c:	42b8      	cmp	r0, r7
 800869e:	d106      	bne.n	80086ae <HAL_SPI_TransmitReceive_DMA+0x86>
    SPI_RESET_CRC(hspi);
 80086a0:	680f      	ldr	r7, [r1, #0]
 80086a2:	4e45      	ldr	r6, [pc, #276]	; (80087b8 <HAL_SPI_TransmitReceive_DMA+0x190>)
 80086a4:	4037      	ands	r7, r6
 80086a6:	600f      	str	r7, [r1, #0]
 80086a8:	680f      	ldr	r7, [r1, #0]
 80086aa:	4338      	orrs	r0, r7
 80086ac:	6008      	str	r0, [r1, #0]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
 80086ae:	6848      	ldr	r0, [r1, #4]
 80086b0:	4f42      	ldr	r7, [pc, #264]	; (80087bc <HAL_SPI_TransmitReceive_DMA+0x194>)
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80086b2:	68e6      	ldr	r6, [r4, #12]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX | SPI_CR2_LDMARX);
 80086b4:	4038      	ands	r0, r7
 80086b6:	6048      	str	r0, [r1, #4]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80086b8:	20e0      	movs	r0, #224	; 0xe0
 80086ba:	00c0      	lsls	r0, r0, #3
 80086bc:	4286      	cmp	r6, r0
 80086be:	d93b      	bls.n	8008738 <HAL_SPI_TransmitReceive_DMA+0x110>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80086c0:	684b      	ldr	r3, [r1, #4]
 80086c2:	483f      	ldr	r0, [pc, #252]	; (80087c0 <HAL_SPI_TransmitReceive_DMA+0x198>)
 80086c4:	4003      	ands	r3, r0
 80086c6:	604b      	str	r3, [r1, #4]
  if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 80086c8:	782b      	ldrb	r3, [r5, #0]
 80086ca:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80086cc:	2b04      	cmp	r3, #4
 80086ce:	d000      	beq.n	80086d2 <HAL_SPI_TransmitReceive_DMA+0xaa>
 80086d0:	e06d      	b.n	80087ae <HAL_SPI_TransmitReceive_DMA+0x186>
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 80086d2:	4b3c      	ldr	r3, [pc, #240]	; (80087c4 <HAL_SPI_TransmitReceive_DMA+0x19c>)
 80086d4:	62c3      	str	r3, [r0, #44]	; 0x2c
    hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
 80086d6:	4b3c      	ldr	r3, [pc, #240]	; (80087c8 <HAL_SPI_TransmitReceive_DMA+0x1a0>)
  hspi->hdmarx->XferAbortCallback = NULL;
 80086d8:	2500      	movs	r5, #0
    hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
 80086da:	6283      	str	r3, [r0, #40]	; 0x28
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 80086dc:	4b3b      	ldr	r3, [pc, #236]	; (80087cc <HAL_SPI_TransmitReceive_DMA+0x1a4>)
  hspi->hdmarx->XferAbortCallback = NULL;
 80086de:	6345      	str	r5, [r0, #52]	; 0x34
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 80086e0:	6303      	str	r3, [r0, #48]	; 0x30
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 80086e2:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 80086e4:	310c      	adds	r1, #12
 80086e6:	b29b      	uxth	r3, r3
 80086e8:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80086ea:	f7ff f913 	bl	8007914 <HAL_DMA_Start_IT>
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 80086ee:	2301      	movs	r3, #1
 80086f0:	6822      	ldr	r2, [r4, #0]
  hspi->hdmatx->XferHalfCpltCallback = NULL;
 80086f2:	6d60      	ldr	r0, [r4, #84]	; 0x54
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 80086f4:	6851      	ldr	r1, [r2, #4]
 80086f6:	430b      	orrs	r3, r1
 80086f8:	6053      	str	r3, [r2, #4]
  hspi->hdmatx->XferHalfCpltCallback = NULL;
 80086fa:	62c5      	str	r5, [r0, #44]	; 0x2c
  hspi->hdmatx->XferCpltCallback     = NULL;
 80086fc:	6285      	str	r5, [r0, #40]	; 0x28
  hspi->hdmatx->XferErrorCallback    = NULL;
 80086fe:	6305      	str	r5, [r0, #48]	; 0x30
  hspi->hdmatx->XferAbortCallback    = NULL;
 8008700:	6345      	str	r5, [r0, #52]	; 0x34
  HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
 8008702:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8008704:	320c      	adds	r2, #12
 8008706:	b29b      	uxth	r3, r3
 8008708:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800870a:	f7ff f903 	bl	8007914 <HAL_DMA_Start_IT>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800870e:	2240      	movs	r2, #64	; 0x40
 8008710:	6823      	ldr	r3, [r4, #0]
 8008712:	6819      	ldr	r1, [r3, #0]
 8008714:	4211      	tst	r1, r2
 8008716:	d102      	bne.n	800871e <HAL_SPI_TransmitReceive_DMA+0xf6>
    __HAL_SPI_ENABLE(hspi);
 8008718:	6819      	ldr	r1, [r3, #0]
 800871a:	430a      	orrs	r2, r1
 800871c:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 800871e:	2220      	movs	r2, #32
 8008720:	6859      	ldr	r1, [r3, #4]
  HAL_StatusTypeDef errorcode = HAL_OK;
 8008722:	2000      	movs	r0, #0
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 8008724:	430a      	orrs	r2, r1
 8008726:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8008728:	2202      	movs	r2, #2
 800872a:	6859      	ldr	r1, [r3, #4]
 800872c:	430a      	orrs	r2, r1
 800872e:	605a      	str	r2, [r3, #4]
  __HAL_UNLOCK(hspi);
 8008730:	2300      	movs	r3, #0
 8008732:	9a01      	ldr	r2, [sp, #4]
 8008734:	7013      	strb	r3, [r2, #0]
}
 8008736:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8008738:	2080      	movs	r0, #128	; 0x80
 800873a:	684f      	ldr	r7, [r1, #4]
 800873c:	0140      	lsls	r0, r0, #5
 800873e:	4338      	orrs	r0, r7
 8008740:	6048      	str	r0, [r1, #4]
    if (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8008742:	2080      	movs	r0, #128	; 0x80
 8008744:	6d67      	ldr	r7, [r4, #84]	; 0x54
 8008746:	00c0      	lsls	r0, r0, #3
 8008748:	697f      	ldr	r7, [r7, #20]
 800874a:	4287      	cmp	r7, r0
 800874c:	d108      	bne.n	8008760 <HAL_SPI_TransmitReceive_DMA+0x138>
      if ((hspi->TxXferSize & 0x1U) == 0x0U)
 800874e:	07db      	lsls	r3, r3, #31
 8008750:	d41b      	bmi.n	800878a <HAL_SPI_TransmitReceive_DMA+0x162>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8008752:	684b      	ldr	r3, [r1, #4]
 8008754:	481e      	ldr	r0, [pc, #120]	; (80087d0 <HAL_SPI_TransmitReceive_DMA+0x1a8>)
 8008756:	4003      	ands	r3, r0
 8008758:	604b      	str	r3, [r1, #4]
        hspi->TxXferCount = hspi->TxXferCount >> 1U;
 800875a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 800875c:	085b      	lsrs	r3, r3, #1
        hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 800875e:	87e3      	strh	r3, [r4, #62]	; 0x3e
    if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8008760:	2380      	movs	r3, #128	; 0x80
 8008762:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8008764:	00db      	lsls	r3, r3, #3
 8008766:	6940      	ldr	r0, [r0, #20]
 8008768:	4298      	cmp	r0, r3
 800876a:	d1ad      	bne.n	80086c8 <HAL_SPI_TransmitReceive_DMA+0xa0>
      CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 800876c:	684b      	ldr	r3, [r1, #4]
 800876e:	4814      	ldr	r0, [pc, #80]	; (80087c0 <HAL_SPI_TransmitReceive_DMA+0x198>)
 8008770:	4003      	ands	r3, r0
 8008772:	604b      	str	r3, [r1, #4]
      if ((hspi->RxXferCount & 0x1U) == 0x0U)
 8008774:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 8008776:	07db      	lsls	r3, r3, #31
 8008778:	d410      	bmi.n	800879c <HAL_SPI_TransmitReceive_DMA+0x174>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 800877a:	684b      	ldr	r3, [r1, #4]
 800877c:	480e      	ldr	r0, [pc, #56]	; (80087b8 <HAL_SPI_TransmitReceive_DMA+0x190>)
 800877e:	4003      	ands	r3, r0
 8008780:	604b      	str	r3, [r1, #4]
        hspi->RxXferCount = hspi->RxXferCount >> 1U;
 8008782:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 8008784:	085b      	lsrs	r3, r3, #1
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 8008786:	87d3      	strh	r3, [r2, #62]	; 0x3e
 8008788:	e79e      	b.n	80086c8 <HAL_SPI_TransmitReceive_DMA+0xa0>
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 800878a:	2380      	movs	r3, #128	; 0x80
 800878c:	6848      	ldr	r0, [r1, #4]
 800878e:	01db      	lsls	r3, r3, #7
 8008790:	4303      	orrs	r3, r0
 8008792:	604b      	str	r3, [r1, #4]
        hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 8008794:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8008796:	085b      	lsrs	r3, r3, #1
 8008798:	3301      	adds	r3, #1
 800879a:	e7e0      	b.n	800875e <HAL_SPI_TransmitReceive_DMA+0x136>
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 800879c:	2380      	movs	r3, #128	; 0x80
 800879e:	6848      	ldr	r0, [r1, #4]
 80087a0:	019b      	lsls	r3, r3, #6
 80087a2:	4303      	orrs	r3, r0
 80087a4:	604b      	str	r3, [r1, #4]
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 80087a6:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
 80087a8:	085b      	lsrs	r3, r3, #1
 80087aa:	3301      	adds	r3, #1
 80087ac:	e7eb      	b.n	8008786 <HAL_SPI_TransmitReceive_DMA+0x15e>
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
 80087ae:	4b09      	ldr	r3, [pc, #36]	; (80087d4 <HAL_SPI_TransmitReceive_DMA+0x1ac>)
 80087b0:	62c3      	str	r3, [r0, #44]	; 0x2c
    hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
 80087b2:	4b09      	ldr	r3, [pc, #36]	; (80087d8 <HAL_SPI_TransmitReceive_DMA+0x1b0>)
 80087b4:	e790      	b.n	80086d8 <HAL_SPI_TransmitReceive_DMA+0xb0>
 80087b6:	46c0      	nop			; (mov r8, r8)
 80087b8:	ffffdfff 	.word	0xffffdfff
 80087bc:	ffff9fff 	.word	0xffff9fff
 80087c0:	ffffefff 	.word	0xffffefff
 80087c4:	08008981 	.word	0x08008981
 80087c8:	08008a2d 	.word	0x08008a2d
 80087cc:	08008999 	.word	0x08008999
 80087d0:	ffffbfff 	.word	0xffffbfff
 80087d4:	0800898d 	.word	0x0800898d
 80087d8:	08008b11 	.word	0x08008b11

080087dc <HAL_SPI_Receive_DMA>:
  if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 80087dc:	6883      	ldr	r3, [r0, #8]
{
 80087de:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80087e0:	0005      	movs	r5, r0
  if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
 80087e2:	2b00      	cmp	r3, #0
 80087e4:	d10f      	bne.n	8008806 <HAL_SPI_Receive_DMA+0x2a>
 80087e6:	2082      	movs	r0, #130	; 0x82
 80087e8:	686c      	ldr	r4, [r5, #4]
 80087ea:	0040      	lsls	r0, r0, #1
 80087ec:	4284      	cmp	r4, r0
 80087ee:	d10a      	bne.n	8008806 <HAL_SPI_Receive_DMA+0x2a>
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 80087f0:	002b      	movs	r3, r5
 80087f2:	3801      	subs	r0, #1
 80087f4:	335d      	adds	r3, #93	; 0x5d
 80087f6:	38ff      	subs	r0, #255	; 0xff
 80087f8:	7018      	strb	r0, [r3, #0]
    return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
 80087fa:	0013      	movs	r3, r2
 80087fc:	0028      	movs	r0, r5
 80087fe:	000a      	movs	r2, r1
 8008800:	f7ff ff12 	bl	8008628 <HAL_SPI_TransmitReceive_DMA>
}
 8008804:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(hspi);
 8008806:	002e      	movs	r6, r5
 8008808:	365c      	adds	r6, #92	; 0x5c
 800880a:	7834      	ldrb	r4, [r6, #0]
 800880c:	2002      	movs	r0, #2
 800880e:	2c01      	cmp	r4, #1
 8008810:	d0f8      	beq.n	8008804 <HAL_SPI_Receive_DMA+0x28>
  if (hspi->State != HAL_SPI_STATE_READY)
 8008812:	002f      	movs	r7, r5
  __HAL_LOCK(hspi);
 8008814:	3801      	subs	r0, #1
 8008816:	7030      	strb	r0, [r6, #0]
  if (hspi->State != HAL_SPI_STATE_READY)
 8008818:	375d      	adds	r7, #93	; 0x5d
 800881a:	783c      	ldrb	r4, [r7, #0]
    errorcode = HAL_BUSY;
 800881c:	3001      	adds	r0, #1
  if (hspi->State != HAL_SPI_STATE_READY)
 800881e:	b2e4      	uxtb	r4, r4
 8008820:	2c01      	cmp	r4, #1
 8008822:	d156      	bne.n	80088d2 <HAL_SPI_Receive_DMA+0xf6>
    errorcode = HAL_ERROR;
 8008824:	0020      	movs	r0, r4
  if ((pData == NULL) || (Size == 0U))
 8008826:	2900      	cmp	r1, #0
 8008828:	d053      	beq.n	80088d2 <HAL_SPI_Receive_DMA+0xf6>
 800882a:	2a00      	cmp	r2, #0
 800882c:	d051      	beq.n	80088d2 <HAL_SPI_Receive_DMA+0xf6>
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 800882e:	3003      	adds	r0, #3
 8008830:	7038      	strb	r0, [r7, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8008832:	2000      	movs	r0, #0
  hspi->RxXferCount = Size;
 8008834:	3f55      	subs	r7, #85	; 0x55
  hspi->RxXferSize  = Size;
 8008836:	1dac      	adds	r4, r5, #6
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8008838:	6628      	str	r0, [r5, #96]	; 0x60
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 800883a:	6429      	str	r1, [r5, #64]	; 0x40
  hspi->RxXferSize  = Size;
 800883c:	87e2      	strh	r2, [r4, #62]	; 0x3e
  hspi->RxXferCount = Size;
 800883e:	87fa      	strh	r2, [r7, #62]	; 0x3e
  hspi->RxISR       = NULL;
 8008840:	64e8      	str	r0, [r5, #76]	; 0x4c
  hspi->TxISR       = NULL;
 8008842:	6528      	str	r0, [r5, #80]	; 0x50
  hspi->TxXferSize  = 0U;
 8008844:	87a8      	strh	r0, [r5, #60]	; 0x3c
  hspi->TxXferCount = 0U;
 8008846:	87e8      	strh	r0, [r5, #62]	; 0x3e
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8008848:	2080      	movs	r0, #128	; 0x80
  hspi->RxXferCount = Size;
 800884a:	9701      	str	r7, [sp, #4]
 800884c:	682a      	ldr	r2, [r5, #0]
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800884e:	0200      	lsls	r0, r0, #8
 8008850:	4283      	cmp	r3, r0
 8008852:	d103      	bne.n	800885c <HAL_SPI_Receive_DMA+0x80>
    SPI_1LINE_RX(hspi);
 8008854:	6813      	ldr	r3, [r2, #0]
 8008856:	4834      	ldr	r0, [pc, #208]	; (8008928 <HAL_SPI_Receive_DMA+0x14c>)
 8008858:	4003      	ands	r3, r0
 800885a:	6013      	str	r3, [r2, #0]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800885c:	2080      	movs	r0, #128	; 0x80
 800885e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8008860:	0180      	lsls	r0, r0, #6
 8008862:	4c32      	ldr	r4, [pc, #200]	; (800892c <HAL_SPI_Receive_DMA+0x150>)
 8008864:	4283      	cmp	r3, r0
 8008866:	d105      	bne.n	8008874 <HAL_SPI_Receive_DMA+0x98>
    SPI_RESET_CRC(hspi);
 8008868:	6810      	ldr	r0, [r2, #0]
 800886a:	4020      	ands	r0, r4
 800886c:	6010      	str	r0, [r2, #0]
 800886e:	6810      	ldr	r0, [r2, #0]
 8008870:	4303      	orrs	r3, r0
 8008872:	6013      	str	r3, [r2, #0]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 8008874:	6853      	ldr	r3, [r2, #4]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008876:	68ef      	ldr	r7, [r5, #12]
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 8008878:	4023      	ands	r3, r4
 800887a:	6053      	str	r3, [r2, #4]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 800887c:	23e0      	movs	r3, #224	; 0xe0
 800887e:	6da8      	ldr	r0, [r5, #88]	; 0x58
 8008880:	00db      	lsls	r3, r3, #3
 8008882:	429f      	cmp	r7, r3
 8008884:	d928      	bls.n	80088d8 <HAL_SPI_Receive_DMA+0xfc>
    CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 8008886:	6853      	ldr	r3, [r2, #4]
 8008888:	4c29      	ldr	r4, [pc, #164]	; (8008930 <HAL_SPI_Receive_DMA+0x154>)
 800888a:	4023      	ands	r3, r4
 800888c:	6053      	str	r3, [r2, #4]
  hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 800888e:	4b29      	ldr	r3, [pc, #164]	; (8008934 <HAL_SPI_Receive_DMA+0x158>)
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 8008890:	320c      	adds	r2, #12
  hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 8008892:	62c3      	str	r3, [r0, #44]	; 0x2c
  hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
 8008894:	4b28      	ldr	r3, [pc, #160]	; (8008938 <HAL_SPI_Receive_DMA+0x15c>)
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 8008896:	0014      	movs	r4, r2
  hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
 8008898:	6283      	str	r3, [r0, #40]	; 0x28
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 800889a:	4b28      	ldr	r3, [pc, #160]	; (800893c <HAL_SPI_Receive_DMA+0x160>)
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 800889c:	000a      	movs	r2, r1
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 800889e:	6303      	str	r3, [r0, #48]	; 0x30
  hspi->hdmarx->XferAbortCallback = NULL;
 80088a0:	2300      	movs	r3, #0
 80088a2:	6343      	str	r3, [r0, #52]	; 0x34
  HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
 80088a4:	9b01      	ldr	r3, [sp, #4]
 80088a6:	0021      	movs	r1, r4
 80088a8:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 80088aa:	b29b      	uxth	r3, r3
 80088ac:	f7ff f832 	bl	8007914 <HAL_DMA_Start_IT>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80088b0:	2240      	movs	r2, #64	; 0x40
 80088b2:	682b      	ldr	r3, [r5, #0]
 80088b4:	6819      	ldr	r1, [r3, #0]
 80088b6:	4211      	tst	r1, r2
 80088b8:	d102      	bne.n	80088c0 <HAL_SPI_Receive_DMA+0xe4>
    __HAL_SPI_ENABLE(hspi);
 80088ba:	6819      	ldr	r1, [r3, #0]
 80088bc:	430a      	orrs	r2, r1
 80088be:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 80088c0:	2220      	movs	r2, #32
 80088c2:	6859      	ldr	r1, [r3, #4]
  HAL_StatusTypeDef errorcode = HAL_OK;
 80088c4:	2000      	movs	r0, #0
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 80088c6:	430a      	orrs	r2, r1
 80088c8:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 80088ca:	2201      	movs	r2, #1
 80088cc:	6859      	ldr	r1, [r3, #4]
 80088ce:	430a      	orrs	r2, r1
 80088d0:	605a      	str	r2, [r3, #4]
  __HAL_UNLOCK(hspi);
 80088d2:	2300      	movs	r3, #0
 80088d4:	7033      	strb	r3, [r6, #0]
  return errorcode;
 80088d6:	e795      	b.n	8008804 <HAL_SPI_Receive_DMA+0x28>
    SET_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80088d8:	6853      	ldr	r3, [r2, #4]
 80088da:	469c      	mov	ip, r3
 80088dc:	2380      	movs	r3, #128	; 0x80
 80088de:	4667      	mov	r7, ip
 80088e0:	015b      	lsls	r3, r3, #5
 80088e2:	433b      	orrs	r3, r7
 80088e4:	6053      	str	r3, [r2, #4]
    if (hspi->hdmarx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 80088e6:	2380      	movs	r3, #128	; 0x80
 80088e8:	6947      	ldr	r7, [r0, #20]
 80088ea:	00db      	lsls	r3, r3, #3
 80088ec:	429f      	cmp	r7, r3
 80088ee:	d1ce      	bne.n	800888e <HAL_SPI_Receive_DMA+0xb2>
      CLEAR_BIT(hspi->Instance->CR2, SPI_RXFIFO_THRESHOLD);
 80088f0:	6853      	ldr	r3, [r2, #4]
 80088f2:	4f0f      	ldr	r7, [pc, #60]	; (8008930 <HAL_SPI_Receive_DMA+0x154>)
 80088f4:	403b      	ands	r3, r7
 80088f6:	6053      	str	r3, [r2, #4]
      if ((hspi->RxXferCount & 0x1U) == 0x0U)
 80088f8:	002b      	movs	r3, r5
 80088fa:	3308      	adds	r3, #8
 80088fc:	8fdf      	ldrh	r7, [r3, #62]	; 0x3e
 80088fe:	07ff      	lsls	r7, r7, #31
 8008900:	d406      	bmi.n	8008910 <HAL_SPI_Receive_DMA+0x134>
        CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 8008902:	6857      	ldr	r7, [r2, #4]
 8008904:	403c      	ands	r4, r7
 8008906:	6054      	str	r4, [r2, #4]
        hspi->RxXferCount = hspi->RxXferCount >> 1U;
 8008908:	8fdc      	ldrh	r4, [r3, #62]	; 0x3e
 800890a:	0864      	lsrs	r4, r4, #1
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 800890c:	87dc      	strh	r4, [r3, #62]	; 0x3e
 800890e:	e7be      	b.n	800888e <HAL_SPI_Receive_DMA+0xb2>
        SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMARX);
 8008910:	6854      	ldr	r4, [r2, #4]
 8008912:	46a4      	mov	ip, r4
 8008914:	2480      	movs	r4, #128	; 0x80
 8008916:	4667      	mov	r7, ip
 8008918:	01a4      	lsls	r4, r4, #6
 800891a:	433c      	orrs	r4, r7
 800891c:	6054      	str	r4, [r2, #4]
        hspi->RxXferCount = (hspi->RxXferCount >> 1U) + 1U;
 800891e:	8fdc      	ldrh	r4, [r3, #62]	; 0x3e
 8008920:	0864      	lsrs	r4, r4, #1
 8008922:	3401      	adds	r4, #1
 8008924:	e7f2      	b.n	800890c <HAL_SPI_Receive_DMA+0x130>
 8008926:	46c0      	nop			; (mov r8, r8)
 8008928:	ffffbfff 	.word	0xffffbfff
 800892c:	ffffdfff 	.word	0xffffdfff
 8008930:	ffffefff 	.word	0xffffefff
 8008934:	08008981 	.word	0x08008981
 8008938:	08008a2d 	.word	0x08008a2d
 800893c:	08008999 	.word	0x08008999

08008940 <HAL_SPI_DMAStop>:
{
 8008940:	b510      	push	{r4, lr}
 8008942:	0004      	movs	r4, r0
  if (hspi->hdmatx != NULL)
 8008944:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8008946:	2800      	cmp	r0, #0
 8008948:	d001      	beq.n	800894e <HAL_SPI_DMAStop+0xe>
    HAL_DMA_Abort(hspi->hdmatx);
 800894a:	f7ff f81f 	bl	800798c <HAL_DMA_Abort>
  if (hspi->hdmarx != NULL)
 800894e:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8008950:	2800      	cmp	r0, #0
 8008952:	d001      	beq.n	8008958 <HAL_SPI_DMAStop+0x18>
    HAL_DMA_Abort(hspi->hdmarx);
 8008954:	f7ff f81a 	bl	800798c <HAL_DMA_Abort>
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008958:	2103      	movs	r1, #3
 800895a:	6822      	ldr	r2, [r4, #0]
  hspi->State = HAL_SPI_STATE_READY;
 800895c:	345d      	adds	r4, #93	; 0x5d
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800895e:	6853      	ldr	r3, [r2, #4]
}
 8008960:	2000      	movs	r0, #0
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008962:	438b      	bics	r3, r1
 8008964:	6053      	str	r3, [r2, #4]
  hspi->State = HAL_SPI_STATE_READY;
 8008966:	2301      	movs	r3, #1
 8008968:	7023      	strb	r3, [r4, #0]
}
 800896a:	bd10      	pop	{r4, pc}

0800896c <HAL_SPI_TxCpltCallback>:
 800896c:	4770      	bx	lr

0800896e <HAL_SPI_RxCpltCallback>:
 800896e:	4770      	bx	lr

08008970 <HAL_SPI_TxRxCpltCallback>:
 8008970:	4770      	bx	lr

08008972 <HAL_SPI_TxHalfCpltCallback>:
 8008972:	4770      	bx	lr

08008974 <SPI_DMAHalfTransmitCplt>:
{
 8008974:	b510      	push	{r4, lr}
  HAL_SPI_TxHalfCpltCallback(hspi);
 8008976:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8008978:	f7ff fffb 	bl	8008972 <HAL_SPI_TxHalfCpltCallback>
}
 800897c:	bd10      	pop	{r4, pc}

0800897e <HAL_SPI_RxHalfCpltCallback>:
 800897e:	4770      	bx	lr

08008980 <SPI_DMAHalfReceiveCplt>:
{
 8008980:	b510      	push	{r4, lr}
  HAL_SPI_RxHalfCpltCallback(hspi);
 8008982:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8008984:	f7ff fffb 	bl	800897e <HAL_SPI_RxHalfCpltCallback>
}
 8008988:	bd10      	pop	{r4, pc}

0800898a <HAL_SPI_TxRxHalfCpltCallback>:
 800898a:	4770      	bx	lr

0800898c <SPI_DMAHalfTransmitReceiveCplt>:
{
 800898c:	b510      	push	{r4, lr}
  HAL_SPI_TxRxHalfCpltCallback(hspi);
 800898e:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8008990:	f7ff fffb 	bl	800898a <HAL_SPI_TxRxHalfCpltCallback>
}
 8008994:	bd10      	pop	{r4, pc}

08008996 <HAL_SPI_ErrorCallback>:
 8008996:	4770      	bx	lr

08008998 <SPI_DMAError>:
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008998:	2103      	movs	r1, #3
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800899a:	6a40      	ldr	r0, [r0, #36]	; 0x24
{
 800899c:	b510      	push	{r4, lr}
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 800899e:	6802      	ldr	r2, [r0, #0]
 80089a0:	6853      	ldr	r3, [r2, #4]
 80089a2:	438b      	bics	r3, r1
 80089a4:	6053      	str	r3, [r2, #4]
  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 80089a6:	2310      	movs	r3, #16
 80089a8:	6e02      	ldr	r2, [r0, #96]	; 0x60
 80089aa:	4313      	orrs	r3, r2
 80089ac:	6603      	str	r3, [r0, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_READY;
 80089ae:	0003      	movs	r3, r0
 80089b0:	2201      	movs	r2, #1
 80089b2:	335d      	adds	r3, #93	; 0x5d
 80089b4:	701a      	strb	r2, [r3, #0]
  HAL_SPI_ErrorCallback(hspi);
 80089b6:	f7ff ffee 	bl	8008996 <HAL_SPI_ErrorCallback>
}
 80089ba:	bd10      	pop	{r4, pc}

080089bc <SPI_DMATransmitCplt>:
{
 80089bc:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80089be:	0005      	movs	r5, r0
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80089c0:	6a44      	ldr	r4, [r0, #36]	; 0x24
  tickstart = HAL_GetTick();
 80089c2:	f7fe fbad 	bl	8007120 <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 80089c6:	682b      	ldr	r3, [r5, #0]
 80089c8:	2520      	movs	r5, #32
 80089ca:	681b      	ldr	r3, [r3, #0]
  tickstart = HAL_GetTick();
 80089cc:	0002      	movs	r2, r0
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 80089ce:	422b      	tst	r3, r5
 80089d0:	d127      	bne.n	8008a22 <SPI_DMATransmitCplt+0x66>
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 80089d2:	2002      	movs	r0, #2
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 80089d4:	6823      	ldr	r3, [r4, #0]
 80089d6:	6859      	ldr	r1, [r3, #4]
 80089d8:	43a9      	bics	r1, r5
 80089da:	6059      	str	r1, [r3, #4]
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 80089dc:	6859      	ldr	r1, [r3, #4]
 80089de:	4381      	bics	r1, r0
 80089e0:	6059      	str	r1, [r3, #4]
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 80089e2:	0020      	movs	r0, r4
 80089e4:	2164      	movs	r1, #100	; 0x64
 80089e6:	f7ff fd06 	bl	80083f6 <SPI_EndRxTxTransaction>
 80089ea:	2800      	cmp	r0, #0
 80089ec:	d002      	beq.n	80089f4 <SPI_DMATransmitCplt+0x38>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80089ee:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80089f0:	431d      	orrs	r5, r3
 80089f2:	6625      	str	r5, [r4, #96]	; 0x60
    if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 80089f4:	68a3      	ldr	r3, [r4, #8]
 80089f6:	2b00      	cmp	r3, #0
 80089f8:	d106      	bne.n	8008a08 <SPI_DMATransmitCplt+0x4c>
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 80089fa:	9301      	str	r3, [sp, #4]
 80089fc:	6823      	ldr	r3, [r4, #0]
 80089fe:	68da      	ldr	r2, [r3, #12]
 8008a00:	9201      	str	r2, [sp, #4]
 8008a02:	689b      	ldr	r3, [r3, #8]
 8008a04:	9301      	str	r3, [sp, #4]
 8008a06:	9b01      	ldr	r3, [sp, #4]
    hspi->TxXferCount = 0U;
 8008a08:	2300      	movs	r3, #0
 8008a0a:	87e3      	strh	r3, [r4, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 8008a0c:	0023      	movs	r3, r4
 8008a0e:	2201      	movs	r2, #1
 8008a10:	335d      	adds	r3, #93	; 0x5d
 8008a12:	701a      	strb	r2, [r3, #0]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8008a14:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8008a16:	2b00      	cmp	r3, #0
 8008a18:	d003      	beq.n	8008a22 <SPI_DMATransmitCplt+0x66>
      HAL_SPI_ErrorCallback(hspi);
 8008a1a:	0020      	movs	r0, r4
 8008a1c:	f7ff ffbb 	bl	8008996 <HAL_SPI_ErrorCallback>
}
 8008a20:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
  HAL_SPI_TxCpltCallback(hspi);
 8008a22:	0020      	movs	r0, r4
 8008a24:	f7ff ffa2 	bl	800896c <HAL_SPI_TxCpltCallback>
 8008a28:	e7fa      	b.n	8008a20 <SPI_DMATransmitCplt+0x64>
	...

08008a2c <SPI_DMAReceiveCplt>:
{
 8008a2c:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO uint16_t tmpreg = 0U;
 8008a2e:	250e      	movs	r5, #14
 8008a30:	2300      	movs	r3, #0
{
 8008a32:	0006      	movs	r6, r0
 8008a34:	b085      	sub	sp, #20
  __IO uint16_t tmpreg = 0U;
 8008a36:	446d      	add	r5, sp
 8008a38:	802b      	strh	r3, [r5, #0]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008a3a:	6a44      	ldr	r4, [r0, #36]	; 0x24
  tickstart = HAL_GetTick();
 8008a3c:	f7fe fb70 	bl	8007120 <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8008a40:	2120      	movs	r1, #32
 8008a42:	6833      	ldr	r3, [r6, #0]
  tickstart = HAL_GetTick();
 8008a44:	0007      	movs	r7, r0
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8008a46:	681b      	ldr	r3, [r3, #0]
 8008a48:	420b      	tst	r3, r1
 8008a4a:	d15b      	bne.n	8008b04 <SPI_DMAReceiveCplt+0xd8>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 8008a4c:	6822      	ldr	r2, [r4, #0]
 8008a4e:	6853      	ldr	r3, [r2, #4]
 8008a50:	438b      	bics	r3, r1
 8008a52:	6053      	str	r3, [r2, #4]
    if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008a54:	2380      	movs	r3, #128	; 0x80
 8008a56:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8008a58:	019b      	lsls	r3, r3, #6
 8008a5a:	429a      	cmp	r2, r3
 8008a5c:	d116      	bne.n	8008a8c <SPI_DMAReceiveCplt+0x60>
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008a5e:	2201      	movs	r2, #1
 8008a60:	9000      	str	r0, [sp, #0]
 8008a62:	2364      	movs	r3, #100	; 0x64
 8008a64:	0011      	movs	r1, r2
 8008a66:	0020      	movs	r0, r4
 8008a68:	f7ff fc40 	bl	80082ec <SPI_WaitFlagStateUntilTimeout>
 8008a6c:	2800      	cmp	r0, #0
 8008a6e:	d003      	beq.n	8008a78 <SPI_DMAReceiveCplt+0x4c>
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008a70:	2302      	movs	r3, #2
 8008a72:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8008a74:	4313      	orrs	r3, r2
 8008a76:	6623      	str	r3, [r4, #96]	; 0x60
      if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8008a78:	22e0      	movs	r2, #224	; 0xe0
 8008a7a:	68e1      	ldr	r1, [r4, #12]
 8008a7c:	6823      	ldr	r3, [r4, #0]
 8008a7e:	00d2      	lsls	r2, r2, #3
 8008a80:	4291      	cmp	r1, r2
 8008a82:	d92a      	bls.n	8008ada <SPI_DMAReceiveCplt+0xae>
        tmpreg = hspi->Instance->DR;
 8008a84:	68db      	ldr	r3, [r3, #12]
 8008a86:	b29b      	uxth	r3, r3
          tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8008a88:	802b      	strh	r3, [r5, #0]
          UNUSED(tmpreg);
 8008a8a:	882b      	ldrh	r3, [r5, #0]
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008a8c:	2103      	movs	r1, #3
 8008a8e:	6822      	ldr	r2, [r4, #0]
    if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008a90:	0020      	movs	r0, r4
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008a92:	6853      	ldr	r3, [r2, #4]
 8008a94:	438b      	bics	r3, r1
 8008a96:	6053      	str	r3, [r2, #4]
    if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008a98:	3161      	adds	r1, #97	; 0x61
 8008a9a:	003a      	movs	r2, r7
 8008a9c:	f7ff fc6b 	bl	8008376 <SPI_EndRxTransaction>
 8008aa0:	2800      	cmp	r0, #0
 8008aa2:	d001      	beq.n	8008aa8 <SPI_DMAReceiveCplt+0x7c>
      hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8008aa4:	2320      	movs	r3, #32
 8008aa6:	6623      	str	r3, [r4, #96]	; 0x60
    hspi->RxXferCount = 0U;
 8008aa8:	0023      	movs	r3, r4
 8008aaa:	2200      	movs	r2, #0
 8008aac:	3308      	adds	r3, #8
 8008aae:	87da      	strh	r2, [r3, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 8008ab0:	3201      	adds	r2, #1
 8008ab2:	3355      	adds	r3, #85	; 0x55
 8008ab4:	701a      	strb	r2, [r3, #0]
    if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 8008ab6:	6822      	ldr	r2, [r4, #0]
 8008ab8:	6893      	ldr	r3, [r2, #8]
 8008aba:	06db      	lsls	r3, r3, #27
 8008abc:	d505      	bpl.n	8008aca <SPI_DMAReceiveCplt+0x9e>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008abe:	2302      	movs	r3, #2
 8008ac0:	6e21      	ldr	r1, [r4, #96]	; 0x60
 8008ac2:	430b      	orrs	r3, r1
 8008ac4:	6623      	str	r3, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 8008ac6:	4b11      	ldr	r3, [pc, #68]	; (8008b0c <SPI_DMAReceiveCplt+0xe0>)
 8008ac8:	6093      	str	r3, [r2, #8]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8008aca:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8008acc:	2b00      	cmp	r3, #0
 8008ace:	d019      	beq.n	8008b04 <SPI_DMAReceiveCplt+0xd8>
      HAL_SPI_ErrorCallback(hspi);
 8008ad0:	0020      	movs	r0, r4
 8008ad2:	f7ff ff60 	bl	8008996 <HAL_SPI_ErrorCallback>
}
 8008ad6:	b005      	add	sp, #20
 8008ad8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8008ada:	7b1b      	ldrb	r3, [r3, #12]
        if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8008adc:	6b26      	ldr	r6, [r4, #48]	; 0x30
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8008ade:	802b      	strh	r3, [r5, #0]
        UNUSED(tmpreg);
 8008ae0:	882b      	ldrh	r3, [r5, #0]
        if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 8008ae2:	2e02      	cmp	r6, #2
 8008ae4:	d1d2      	bne.n	8008a8c <SPI_DMAReceiveCplt+0x60>
          if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008ae6:	2201      	movs	r2, #1
 8008ae8:	9700      	str	r7, [sp, #0]
 8008aea:	2364      	movs	r3, #100	; 0x64
 8008aec:	0011      	movs	r1, r2
 8008aee:	0020      	movs	r0, r4
 8008af0:	f7ff fbfc 	bl	80082ec <SPI_WaitFlagStateUntilTimeout>
 8008af4:	2800      	cmp	r0, #0
 8008af6:	d002      	beq.n	8008afe <SPI_DMAReceiveCplt+0xd2>
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008af8:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8008afa:	431e      	orrs	r6, r3
 8008afc:	6626      	str	r6, [r4, #96]	; 0x60
          tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8008afe:	6823      	ldr	r3, [r4, #0]
 8008b00:	7b1b      	ldrb	r3, [r3, #12]
 8008b02:	e7c1      	b.n	8008a88 <SPI_DMAReceiveCplt+0x5c>
  HAL_SPI_RxCpltCallback(hspi);
 8008b04:	0020      	movs	r0, r4
 8008b06:	f7ff ff32 	bl	800896e <HAL_SPI_RxCpltCallback>
 8008b0a:	e7e4      	b.n	8008ad6 <SPI_DMAReceiveCplt+0xaa>
 8008b0c:	0000ffef 	.word	0x0000ffef

08008b10 <SPI_DMATransmitReceiveCplt>:
{
 8008b10:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO int16_t tmpreg = 0U;
 8008b12:	250e      	movs	r5, #14
 8008b14:	2300      	movs	r3, #0
{
 8008b16:	0007      	movs	r7, r0
 8008b18:	b085      	sub	sp, #20
  __IO int16_t tmpreg = 0U;
 8008b1a:	446d      	add	r5, sp
 8008b1c:	802b      	strh	r3, [r5, #0]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8008b1e:	6a44      	ldr	r4, [r0, #36]	; 0x24
  tickstart = HAL_GetTick();
 8008b20:	f7fe fafe 	bl	8007120 <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8008b24:	2120      	movs	r1, #32
 8008b26:	683b      	ldr	r3, [r7, #0]
  tickstart = HAL_GetTick();
 8008b28:	0006      	movs	r6, r0
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8008b2a:	681b      	ldr	r3, [r3, #0]
 8008b2c:	420b      	tst	r3, r1
 8008b2e:	d160      	bne.n	8008bf2 <SPI_DMATransmitReceiveCplt+0xe2>
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 8008b30:	6822      	ldr	r2, [r4, #0]
 8008b32:	6853      	ldr	r3, [r2, #4]
 8008b34:	438b      	bics	r3, r1
 8008b36:	6053      	str	r3, [r2, #4]
    if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8008b38:	2380      	movs	r3, #128	; 0x80
 8008b3a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8008b3c:	019b      	lsls	r3, r3, #6
 8008b3e:	429a      	cmp	r2, r3
 8008b40:	d11a      	bne.n	8008b78 <SPI_DMATransmitReceiveCplt+0x68>
      if ((hspi->Init.DataSize == SPI_DATASIZE_8BIT) && (hspi->Init.CRCLength == SPI_CRC_LENGTH_8BIT))
 8008b42:	23e0      	movs	r3, #224	; 0xe0
 8008b44:	68e2      	ldr	r2, [r4, #12]
 8008b46:	00db      	lsls	r3, r3, #3
 8008b48:	429a      	cmp	r2, r3
 8008b4a:	d13f      	bne.n	8008bcc <SPI_DMATransmitReceiveCplt+0xbc>
 8008b4c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8008b4e:	2b01      	cmp	r3, #1
 8008b50:	d13c      	bne.n	8008bcc <SPI_DMATransmitReceiveCplt+0xbc>
        if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_QUARTER_FULL, SPI_DEFAULT_TIMEOUT,
 8008b52:	2280      	movs	r2, #128	; 0x80
 8008b54:	21c0      	movs	r1, #192	; 0xc0
 8008b56:	9000      	str	r0, [sp, #0]
 8008b58:	3363      	adds	r3, #99	; 0x63
 8008b5a:	0092      	lsls	r2, r2, #2
 8008b5c:	00c9      	lsls	r1, r1, #3
 8008b5e:	0020      	movs	r0, r4
 8008b60:	f7ff fbe2 	bl	8008328 <SPI_WaitFifoStateUntilTimeout>
 8008b64:	2800      	cmp	r0, #0
 8008b66:	d003      	beq.n	8008b70 <SPI_DMATransmitReceiveCplt+0x60>
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008b68:	2302      	movs	r3, #2
 8008b6a:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8008b6c:	4313      	orrs	r3, r2
 8008b6e:	6623      	str	r3, [r4, #96]	; 0x60
        tmpreg = *(__IO uint8_t *)&hspi->Instance->DR;
 8008b70:	6823      	ldr	r3, [r4, #0]
 8008b72:	7b1b      	ldrb	r3, [r3, #12]
        tmpreg = hspi->Instance->DR;
 8008b74:	802b      	strh	r3, [r5, #0]
        UNUSED(tmpreg);
 8008b76:	882b      	ldrh	r3, [r5, #0]
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008b78:	0032      	movs	r2, r6
 8008b7a:	2164      	movs	r1, #100	; 0x64
 8008b7c:	0020      	movs	r0, r4
 8008b7e:	f7ff fc3a 	bl	80083f6 <SPI_EndRxTxTransaction>
 8008b82:	2800      	cmp	r0, #0
 8008b84:	d003      	beq.n	8008b8e <SPI_DMATransmitReceiveCplt+0x7e>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8008b86:	2320      	movs	r3, #32
 8008b88:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8008b8a:	4313      	orrs	r3, r2
 8008b8c:	6623      	str	r3, [r4, #96]	; 0x60
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008b8e:	2103      	movs	r1, #3
 8008b90:	6823      	ldr	r3, [r4, #0]
 8008b92:	685a      	ldr	r2, [r3, #4]
 8008b94:	438a      	bics	r2, r1
    hspi->RxXferCount = 0U;
 8008b96:	0021      	movs	r1, r4
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8008b98:	605a      	str	r2, [r3, #4]
    hspi->TxXferCount = 0U;
 8008b9a:	2200      	movs	r2, #0
    hspi->RxXferCount = 0U;
 8008b9c:	3108      	adds	r1, #8
    hspi->TxXferCount = 0U;
 8008b9e:	87e2      	strh	r2, [r4, #62]	; 0x3e
    hspi->RxXferCount = 0U;
 8008ba0:	87ca      	strh	r2, [r1, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 8008ba2:	0022      	movs	r2, r4
 8008ba4:	2101      	movs	r1, #1
 8008ba6:	325d      	adds	r2, #93	; 0x5d
 8008ba8:	7011      	strb	r1, [r2, #0]
    if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
 8008baa:	689a      	ldr	r2, [r3, #8]
 8008bac:	06d2      	lsls	r2, r2, #27
 8008bae:	d505      	bpl.n	8008bbc <SPI_DMATransmitReceiveCplt+0xac>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008bb0:	2202      	movs	r2, #2
 8008bb2:	6e21      	ldr	r1, [r4, #96]	; 0x60
 8008bb4:	430a      	orrs	r2, r1
 8008bb6:	6622      	str	r2, [r4, #96]	; 0x60
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
 8008bb8:	4a10      	ldr	r2, [pc, #64]	; (8008bfc <SPI_DMATransmitReceiveCplt+0xec>)
 8008bba:	609a      	str	r2, [r3, #8]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8008bbc:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8008bbe:	2b00      	cmp	r3, #0
 8008bc0:	d017      	beq.n	8008bf2 <SPI_DMATransmitReceiveCplt+0xe2>
      HAL_SPI_ErrorCallback(hspi);
 8008bc2:	0020      	movs	r0, r4
 8008bc4:	f7ff fee7 	bl	8008996 <HAL_SPI_ErrorCallback>
}
 8008bc8:	b005      	add	sp, #20
 8008bca:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_HALF_FULL, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8008bcc:	2280      	movs	r2, #128	; 0x80
 8008bce:	21c0      	movs	r1, #192	; 0xc0
 8008bd0:	9600      	str	r6, [sp, #0]
 8008bd2:	2364      	movs	r3, #100	; 0x64
 8008bd4:	00d2      	lsls	r2, r2, #3
 8008bd6:	00c9      	lsls	r1, r1, #3
 8008bd8:	0020      	movs	r0, r4
 8008bda:	f7ff fba5 	bl	8008328 <SPI_WaitFifoStateUntilTimeout>
 8008bde:	2800      	cmp	r0, #0
 8008be0:	d003      	beq.n	8008bea <SPI_DMATransmitReceiveCplt+0xda>
          SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
 8008be2:	2302      	movs	r3, #2
 8008be4:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8008be6:	4313      	orrs	r3, r2
 8008be8:	6623      	str	r3, [r4, #96]	; 0x60
        tmpreg = hspi->Instance->DR;
 8008bea:	6823      	ldr	r3, [r4, #0]
 8008bec:	68db      	ldr	r3, [r3, #12]
 8008bee:	b21b      	sxth	r3, r3
 8008bf0:	e7c0      	b.n	8008b74 <SPI_DMATransmitReceiveCplt+0x64>
  HAL_SPI_TxRxCpltCallback(hspi);
 8008bf2:	0020      	movs	r0, r4
 8008bf4:	f7ff febc 	bl	8008970 <HAL_SPI_TxRxCpltCallback>
 8008bf8:	e7e6      	b.n	8008bc8 <SPI_DMATransmitReceiveCplt+0xb8>
 8008bfa:	46c0      	nop			; (mov r8, r8)
 8008bfc:	0000ffef 	.word	0x0000ffef

08008c00 <TIM_OC1_SetConfig>:
  uint32_t tmpccmrx = 0U;
  uint32_t tmpccer = 0U;
  uint32_t tmpcr2 = 0U;

   /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8008c00:	2201      	movs	r2, #1
 8008c02:	6a03      	ldr	r3, [r0, #32]
{
 8008c04:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8008c06:	4393      	bics	r3, r2
 8008c08:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8008c0a:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8008c0c:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8008c0e:	6985      	ldr	r5, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8008c10:	3272      	adds	r2, #114	; 0x72
 8008c12:	4395      	bics	r5, r2
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8008c14:	680a      	ldr	r2, [r1, #0]
 8008c16:	4315      	orrs	r5, r2

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 8008c18:	2202      	movs	r2, #2
 8008c1a:	4393      	bics	r3, r2
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8008c1c:	688a      	ldr	r2, [r1, #8]
 8008c1e:	4313      	orrs	r3, r2

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8008c20:	4a14      	ldr	r2, [pc, #80]	; (8008c74 <TIM_OC1_SetConfig+0x74>)
 8008c22:	4290      	cmp	r0, r2
 8008c24:	d008      	beq.n	8008c38 <TIM_OC1_SetConfig+0x38>
 8008c26:	4e14      	ldr	r6, [pc, #80]	; (8008c78 <TIM_OC1_SetConfig+0x78>)
 8008c28:	42b0      	cmp	r0, r6
 8008c2a:	d005      	beq.n	8008c38 <TIM_OC1_SetConfig+0x38>
 8008c2c:	4e13      	ldr	r6, [pc, #76]	; (8008c7c <TIM_OC1_SetConfig+0x7c>)
 8008c2e:	42b0      	cmp	r0, r6
 8008c30:	d002      	beq.n	8008c38 <TIM_OC1_SetConfig+0x38>
 8008c32:	4e13      	ldr	r6, [pc, #76]	; (8008c80 <TIM_OC1_SetConfig+0x80>)
 8008c34:	42b0      	cmp	r0, r6
 8008c36:	d116      	bne.n	8008c66 <TIM_OC1_SetConfig+0x66>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 8008c38:	2608      	movs	r6, #8
 8008c3a:	43b3      	bics	r3, r6
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8008c3c:	68ce      	ldr	r6, [r1, #12]
 8008c3e:	4333      	orrs	r3, r6
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 8008c40:	2604      	movs	r6, #4
 8008c42:	43b3      	bics	r3, r6
  }

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8008c44:	4290      	cmp	r0, r2
 8008c46:	d008      	beq.n	8008c5a <TIM_OC1_SetConfig+0x5a>
 8008c48:	4a0b      	ldr	r2, [pc, #44]	; (8008c78 <TIM_OC1_SetConfig+0x78>)
 8008c4a:	4290      	cmp	r0, r2
 8008c4c:	d005      	beq.n	8008c5a <TIM_OC1_SetConfig+0x5a>
 8008c4e:	4a0b      	ldr	r2, [pc, #44]	; (8008c7c <TIM_OC1_SetConfig+0x7c>)
 8008c50:	4290      	cmp	r0, r2
 8008c52:	d002      	beq.n	8008c5a <TIM_OC1_SetConfig+0x5a>
 8008c54:	4a0a      	ldr	r2, [pc, #40]	; (8008c80 <TIM_OC1_SetConfig+0x80>)
 8008c56:	4290      	cmp	r0, r2
 8008c58:	d105      	bne.n	8008c66 <TIM_OC1_SetConfig+0x66>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8008c5a:	4a0a      	ldr	r2, [pc, #40]	; (8008c84 <TIM_OC1_SetConfig+0x84>)
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8008c5c:	698e      	ldr	r6, [r1, #24]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8008c5e:	4022      	ands	r2, r4
    tmpcr2 |= OC_Config->OCNIdleState;
 8008c60:	694c      	ldr	r4, [r1, #20]
 8008c62:	4334      	orrs	r4, r6
 8008c64:	4314      	orrs	r4, r2

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8008c66:	684a      	ldr	r2, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8008c68:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 8008c6a:	6185      	str	r5, [r0, #24]
  TIMx->CCR1 = OC_Config->Pulse;
 8008c6c:	6342      	str	r2, [r0, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8008c6e:	6203      	str	r3, [r0, #32]
}
 8008c70:	bd70      	pop	{r4, r5, r6, pc}
 8008c72:	46c0      	nop			; (mov r8, r8)
 8008c74:	40012c00 	.word	0x40012c00
 8008c78:	40014000 	.word	0x40014000
 8008c7c:	40014400 	.word	0x40014400
 8008c80:	40014800 	.word	0x40014800
 8008c84:	fffffcff 	.word	0xfffffcff

08008c88 <TIM_OC3_SetConfig>:
  * @param  TIMx  to select the TIM peripheral
  * @param  OC_Config : The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8008c88:	b570      	push	{r4, r5, r6, lr}
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8008c8a:	2573      	movs	r5, #115	; 0x73
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8008c8c:	6a03      	ldr	r3, [r0, #32]
 8008c8e:	4a17      	ldr	r2, [pc, #92]	; (8008cec <TIM_OC3_SetConfig+0x64>)
 8008c90:	4013      	ands	r3, r2
 8008c92:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8008c94:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 8008c96:	6842      	ldr	r2, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
 8008c98:	69c4      	ldr	r4, [r0, #28]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8008c9a:	43ac      	bics	r4, r5
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8008c9c:	680d      	ldr	r5, [r1, #0]
 8008c9e:	432c      	orrs	r4, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8008ca0:	4d13      	ldr	r5, [pc, #76]	; (8008cf0 <TIM_OC3_SetConfig+0x68>)
 8008ca2:	402b      	ands	r3, r5
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8008ca4:	688d      	ldr	r5, [r1, #8]
 8008ca6:	022d      	lsls	r5, r5, #8
 8008ca8:	432b      	orrs	r3, r5

  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8008caa:	4d12      	ldr	r5, [pc, #72]	; (8008cf4 <TIM_OC3_SetConfig+0x6c>)
 8008cac:	42a8      	cmp	r0, r5
 8008cae:	d10e      	bne.n	8008cce <TIM_OC3_SetConfig+0x46>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 8008cb0:	4d11      	ldr	r5, [pc, #68]	; (8008cf8 <TIM_OC3_SetConfig+0x70>)
 8008cb2:	401d      	ands	r5, r3
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8008cb4:	68cb      	ldr	r3, [r1, #12]
 8008cb6:	021b      	lsls	r3, r3, #8
 8008cb8:	432b      	orrs	r3, r5
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 8008cba:	4d10      	ldr	r5, [pc, #64]	; (8008cfc <TIM_OC3_SetConfig+0x74>)
 8008cbc:	402b      	ands	r3, r5
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8008cbe:	4d10      	ldr	r5, [pc, #64]	; (8008d00 <TIM_OC3_SetConfig+0x78>)
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8008cc0:	694e      	ldr	r6, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8008cc2:	4015      	ands	r5, r2
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8008cc4:	698a      	ldr	r2, [r1, #24]
 8008cc6:	4332      	orrs	r2, r6
 8008cc8:	0112      	lsls	r2, r2, #4
 8008cca:	432a      	orrs	r2, r5
 8008ccc:	e008      	b.n	8008ce0 <TIM_OC3_SetConfig+0x58>
  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8008cce:	4d0d      	ldr	r5, [pc, #52]	; (8008d04 <TIM_OC3_SetConfig+0x7c>)
 8008cd0:	42a8      	cmp	r0, r5
 8008cd2:	d0f4      	beq.n	8008cbe <TIM_OC3_SetConfig+0x36>
 8008cd4:	4d0c      	ldr	r5, [pc, #48]	; (8008d08 <TIM_OC3_SetConfig+0x80>)
 8008cd6:	42a8      	cmp	r0, r5
 8008cd8:	d0f1      	beq.n	8008cbe <TIM_OC3_SetConfig+0x36>
 8008cda:	4d0c      	ldr	r5, [pc, #48]	; (8008d0c <TIM_OC3_SetConfig+0x84>)
 8008cdc:	42a8      	cmp	r0, r5
 8008cde:	d0ee      	beq.n	8008cbe <TIM_OC3_SetConfig+0x36>
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8008ce0:	6042      	str	r2, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8008ce2:	684a      	ldr	r2, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 8008ce4:	61c4      	str	r4, [r0, #28]
  TIMx->CCR3 = OC_Config->Pulse;
 8008ce6:	63c2      	str	r2, [r0, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8008ce8:	6203      	str	r3, [r0, #32]
}
 8008cea:	bd70      	pop	{r4, r5, r6, pc}
 8008cec:	fffffeff 	.word	0xfffffeff
 8008cf0:	fffffdff 	.word	0xfffffdff
 8008cf4:	40012c00 	.word	0x40012c00
 8008cf8:	fffff7ff 	.word	0xfffff7ff
 8008cfc:	fffffbff 	.word	0xfffffbff
 8008d00:	ffffcfff 	.word	0xffffcfff
 8008d04:	40014000 	.word	0x40014000
 8008d08:	40014400 	.word	0x40014400
 8008d0c:	40014800 	.word	0x40014800

08008d10 <TIM_OC4_SetConfig>:
  uint32_t tmpccmrx = 0U;
  uint32_t tmpccer = 0U;
  uint32_t tmpcr2 = 0U;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8008d10:	6a03      	ldr	r3, [r0, #32]
 8008d12:	4a14      	ldr	r2, [pc, #80]	; (8008d64 <TIM_OC4_SetConfig+0x54>)
{
 8008d14:	b530      	push	{r4, r5, lr}
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8008d16:	4013      	ands	r3, r2
 8008d18:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8008d1a:	6a02      	ldr	r2, [r0, #32]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8008d1c:	4c12      	ldr	r4, [pc, #72]	; (8008d68 <TIM_OC4_SetConfig+0x58>)
  tmpcr2 =  TIMx->CR2;
 8008d1e:	6843      	ldr	r3, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
 8008d20:	69c5      	ldr	r5, [r0, #28]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8008d22:	4025      	ands	r5, r4

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8008d24:	680c      	ldr	r4, [r1, #0]
 8008d26:	0224      	lsls	r4, r4, #8
 8008d28:	4325      	orrs	r5, r4

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8008d2a:	4c10      	ldr	r4, [pc, #64]	; (8008d6c <TIM_OC4_SetConfig+0x5c>)
 8008d2c:	4022      	ands	r2, r4
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8008d2e:	688c      	ldr	r4, [r1, #8]
 8008d30:	0324      	lsls	r4, r4, #12
 8008d32:	4322      	orrs	r2, r4

  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8008d34:	4c0e      	ldr	r4, [pc, #56]	; (8008d70 <TIM_OC4_SetConfig+0x60>)
 8008d36:	42a0      	cmp	r0, r4
 8008d38:	d008      	beq.n	8008d4c <TIM_OC4_SetConfig+0x3c>
 8008d3a:	4c0e      	ldr	r4, [pc, #56]	; (8008d74 <TIM_OC4_SetConfig+0x64>)
 8008d3c:	42a0      	cmp	r0, r4
 8008d3e:	d005      	beq.n	8008d4c <TIM_OC4_SetConfig+0x3c>
 8008d40:	4c0d      	ldr	r4, [pc, #52]	; (8008d78 <TIM_OC4_SetConfig+0x68>)
 8008d42:	42a0      	cmp	r0, r4
 8008d44:	d002      	beq.n	8008d4c <TIM_OC4_SetConfig+0x3c>
 8008d46:	4c0d      	ldr	r4, [pc, #52]	; (8008d7c <TIM_OC4_SetConfig+0x6c>)
 8008d48:	42a0      	cmp	r0, r4
 8008d4a:	d104      	bne.n	8008d56 <TIM_OC4_SetConfig+0x46>
  {
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

   /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 8008d4c:	4c0c      	ldr	r4, [pc, #48]	; (8008d80 <TIM_OC4_SetConfig+0x70>)
 8008d4e:	4023      	ands	r3, r4
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8008d50:	694c      	ldr	r4, [r1, #20]
 8008d52:	01a4      	lsls	r4, r4, #6
 8008d54:	4323      	orrs	r3, r4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8008d56:	6043      	str	r3, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8008d58:	684b      	ldr	r3, [r1, #4]
  TIMx->CCMR2 = tmpccmrx;
 8008d5a:	61c5      	str	r5, [r0, #28]
  TIMx->CCR4 = OC_Config->Pulse;
 8008d5c:	6403      	str	r3, [r0, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8008d5e:	6202      	str	r2, [r0, #32]
}
 8008d60:	bd30      	pop	{r4, r5, pc}
 8008d62:	46c0      	nop			; (mov r8, r8)
 8008d64:	ffffefff 	.word	0xffffefff
 8008d68:	ffff8cff 	.word	0xffff8cff
 8008d6c:	ffffdfff 	.word	0xffffdfff
 8008d70:	40012c00 	.word	0x40012c00
 8008d74:	40014000 	.word	0x40014000
 8008d78:	40014400 	.word	0x40014400
 8008d7c:	40014800 	.word	0x40014800
 8008d80:	ffffbfff 	.word	0xffffbfff

08008d84 <HAL_TIM_Base_Stop_IT>:
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 8008d84:	2101      	movs	r1, #1
 8008d86:	6803      	ldr	r3, [r0, #0]
 8008d88:	68da      	ldr	r2, [r3, #12]
 8008d8a:	438a      	bics	r2, r1
 8008d8c:	60da      	str	r2, [r3, #12]
  __HAL_TIM_DISABLE(htim);
 8008d8e:	6a18      	ldr	r0, [r3, #32]
 8008d90:	4a05      	ldr	r2, [pc, #20]	; (8008da8 <HAL_TIM_Base_Stop_IT+0x24>)
 8008d92:	4210      	tst	r0, r2
 8008d94:	d106      	bne.n	8008da4 <HAL_TIM_Base_Stop_IT+0x20>
 8008d96:	6a18      	ldr	r0, [r3, #32]
 8008d98:	4a04      	ldr	r2, [pc, #16]	; (8008dac <HAL_TIM_Base_Stop_IT+0x28>)
 8008d9a:	4210      	tst	r0, r2
 8008d9c:	d102      	bne.n	8008da4 <HAL_TIM_Base_Stop_IT+0x20>
 8008d9e:	681a      	ldr	r2, [r3, #0]
 8008da0:	438a      	bics	r2, r1
 8008da2:	601a      	str	r2, [r3, #0]
}
 8008da4:	2000      	movs	r0, #0
 8008da6:	4770      	bx	lr
 8008da8:	00001111 	.word	0x00001111
 8008dac:	00000444 	.word	0x00000444

08008db0 <HAL_TIM_OC_MspInit>:
 8008db0:	4770      	bx	lr
	...

08008db4 <TIM_Base_SetConfig>:
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8008db4:	4a20      	ldr	r2, [pc, #128]	; (8008e38 <TIM_Base_SetConfig+0x84>)
{
 8008db6:	b510      	push	{r4, lr}
  tmpcr1 = TIMx->CR1;
 8008db8:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8008dba:	4290      	cmp	r0, r2
 8008dbc:	d006      	beq.n	8008dcc <TIM_Base_SetConfig+0x18>
 8008dbe:	2480      	movs	r4, #128	; 0x80
 8008dc0:	05e4      	lsls	r4, r4, #23
 8008dc2:	42a0      	cmp	r0, r4
 8008dc4:	d002      	beq.n	8008dcc <TIM_Base_SetConfig+0x18>
 8008dc6:	4c1d      	ldr	r4, [pc, #116]	; (8008e3c <TIM_Base_SetConfig+0x88>)
 8008dc8:	42a0      	cmp	r0, r4
 8008dca:	d10c      	bne.n	8008de6 <TIM_Base_SetConfig+0x32>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8008dcc:	2470      	movs	r4, #112	; 0x70
 8008dce:	43a3      	bics	r3, r4
    tmpcr1 |= Structure->CounterMode;
 8008dd0:	684c      	ldr	r4, [r1, #4]
 8008dd2:	4323      	orrs	r3, r4
  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8008dd4:	4290      	cmp	r0, r2
 8008dd6:	d012      	beq.n	8008dfe <TIM_Base_SetConfig+0x4a>
 8008dd8:	2480      	movs	r4, #128	; 0x80
 8008dda:	05e4      	lsls	r4, r4, #23
 8008ddc:	42a0      	cmp	r0, r4
 8008dde:	d00e      	beq.n	8008dfe <TIM_Base_SetConfig+0x4a>
 8008de0:	4c16      	ldr	r4, [pc, #88]	; (8008e3c <TIM_Base_SetConfig+0x88>)
 8008de2:	42a0      	cmp	r0, r4
 8008de4:	d00b      	beq.n	8008dfe <TIM_Base_SetConfig+0x4a>
 8008de6:	4c16      	ldr	r4, [pc, #88]	; (8008e40 <TIM_Base_SetConfig+0x8c>)
 8008de8:	42a0      	cmp	r0, r4
 8008dea:	d008      	beq.n	8008dfe <TIM_Base_SetConfig+0x4a>
 8008dec:	4c15      	ldr	r4, [pc, #84]	; (8008e44 <TIM_Base_SetConfig+0x90>)
 8008dee:	42a0      	cmp	r0, r4
 8008df0:	d005      	beq.n	8008dfe <TIM_Base_SetConfig+0x4a>
 8008df2:	4c15      	ldr	r4, [pc, #84]	; (8008e48 <TIM_Base_SetConfig+0x94>)
 8008df4:	42a0      	cmp	r0, r4
 8008df6:	d002      	beq.n	8008dfe <TIM_Base_SetConfig+0x4a>
 8008df8:	4c14      	ldr	r4, [pc, #80]	; (8008e4c <TIM_Base_SetConfig+0x98>)
 8008dfa:	42a0      	cmp	r0, r4
 8008dfc:	d103      	bne.n	8008e06 <TIM_Base_SetConfig+0x52>
    tmpcr1 &= ~TIM_CR1_CKD;
 8008dfe:	4c14      	ldr	r4, [pc, #80]	; (8008e50 <TIM_Base_SetConfig+0x9c>)
 8008e00:	4023      	ands	r3, r4
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8008e02:	68cc      	ldr	r4, [r1, #12]
 8008e04:	4323      	orrs	r3, r4
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8008e06:	2480      	movs	r4, #128	; 0x80
 8008e08:	43a3      	bics	r3, r4
 8008e0a:	694c      	ldr	r4, [r1, #20]
 8008e0c:	4323      	orrs	r3, r4
  TIMx->CR1 = tmpcr1;
 8008e0e:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8008e10:	688b      	ldr	r3, [r1, #8]
 8008e12:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8008e14:	680b      	ldr	r3, [r1, #0]
 8008e16:	6283      	str	r3, [r0, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8008e18:	4290      	cmp	r0, r2
 8008e1a:	d008      	beq.n	8008e2e <TIM_Base_SetConfig+0x7a>
 8008e1c:	4b09      	ldr	r3, [pc, #36]	; (8008e44 <TIM_Base_SetConfig+0x90>)
 8008e1e:	4298      	cmp	r0, r3
 8008e20:	d005      	beq.n	8008e2e <TIM_Base_SetConfig+0x7a>
 8008e22:	4b09      	ldr	r3, [pc, #36]	; (8008e48 <TIM_Base_SetConfig+0x94>)
 8008e24:	4298      	cmp	r0, r3
 8008e26:	d002      	beq.n	8008e2e <TIM_Base_SetConfig+0x7a>
 8008e28:	4b08      	ldr	r3, [pc, #32]	; (8008e4c <TIM_Base_SetConfig+0x98>)
 8008e2a:	4298      	cmp	r0, r3
 8008e2c:	d101      	bne.n	8008e32 <TIM_Base_SetConfig+0x7e>
    TIMx->RCR = Structure->RepetitionCounter;
 8008e2e:	690b      	ldr	r3, [r1, #16]
 8008e30:	6303      	str	r3, [r0, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 8008e32:	2301      	movs	r3, #1
 8008e34:	6143      	str	r3, [r0, #20]
}
 8008e36:	bd10      	pop	{r4, pc}
 8008e38:	40012c00 	.word	0x40012c00
 8008e3c:	40000400 	.word	0x40000400
 8008e40:	40002000 	.word	0x40002000
 8008e44:	40014000 	.word	0x40014000
 8008e48:	40014400 	.word	0x40014400
 8008e4c:	40014800 	.word	0x40014800
 8008e50:	fffffcff 	.word	0xfffffcff

08008e54 <HAL_TIM_Base_Init>:
{
 8008e54:	b570      	push	{r4, r5, r6, lr}
 8008e56:	0004      	movs	r4, r0
    return HAL_ERROR;
 8008e58:	2001      	movs	r0, #1
  if(htim == NULL)
 8008e5a:	2c00      	cmp	r4, #0
 8008e5c:	d014      	beq.n	8008e88 <HAL_TIM_Base_Init+0x34>
  if(htim->State == HAL_TIM_STATE_RESET)
 8008e5e:	0025      	movs	r5, r4
 8008e60:	353d      	adds	r5, #61	; 0x3d
 8008e62:	782b      	ldrb	r3, [r5, #0]
 8008e64:	b2db      	uxtb	r3, r3
 8008e66:	2b00      	cmp	r3, #0
 8008e68:	d105      	bne.n	8008e76 <HAL_TIM_Base_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 8008e6a:	0022      	movs	r2, r4
 8008e6c:	323c      	adds	r2, #60	; 0x3c
 8008e6e:	7013      	strb	r3, [r2, #0]
    HAL_TIM_Base_MspInit(htim);
 8008e70:	0020      	movs	r0, r4
 8008e72:	f7fd f8db 	bl	800602c <HAL_TIM_Base_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 8008e76:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8008e78:	6820      	ldr	r0, [r4, #0]
  htim->State= HAL_TIM_STATE_BUSY;
 8008e7a:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8008e7c:	1d21      	adds	r1, r4, #4
 8008e7e:	f7ff ff99 	bl	8008db4 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8008e82:	2301      	movs	r3, #1
  return HAL_OK;
 8008e84:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 8008e86:	702b      	strb	r3, [r5, #0]
}
 8008e88:	bd70      	pop	{r4, r5, r6, pc}

08008e8a <HAL_TIM_OC_Init>:
{
 8008e8a:	b570      	push	{r4, r5, r6, lr}
 8008e8c:	0004      	movs	r4, r0
    return HAL_ERROR;
 8008e8e:	2001      	movs	r0, #1
  if(htim == NULL)
 8008e90:	2c00      	cmp	r4, #0
 8008e92:	d014      	beq.n	8008ebe <HAL_TIM_OC_Init+0x34>
  if(htim->State == HAL_TIM_STATE_RESET)
 8008e94:	0025      	movs	r5, r4
 8008e96:	353d      	adds	r5, #61	; 0x3d
 8008e98:	782b      	ldrb	r3, [r5, #0]
 8008e9a:	b2db      	uxtb	r3, r3
 8008e9c:	2b00      	cmp	r3, #0
 8008e9e:	d105      	bne.n	8008eac <HAL_TIM_OC_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 8008ea0:	0022      	movs	r2, r4
 8008ea2:	323c      	adds	r2, #60	; 0x3c
 8008ea4:	7013      	strb	r3, [r2, #0]
    HAL_TIM_OC_MspInit(htim);
 8008ea6:	0020      	movs	r0, r4
 8008ea8:	f7ff ff82 	bl	8008db0 <HAL_TIM_OC_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 8008eac:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 8008eae:	6820      	ldr	r0, [r4, #0]
  htim->State= HAL_TIM_STATE_BUSY;
 8008eb0:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance,  &htim->Init);
 8008eb2:	1d21      	adds	r1, r4, #4
 8008eb4:	f7ff ff7e 	bl	8008db4 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8008eb8:	2301      	movs	r3, #1
  return HAL_OK;
 8008eba:	2000      	movs	r0, #0
  htim->State= HAL_TIM_STATE_READY;
 8008ebc:	702b      	strb	r3, [r5, #0]
}
 8008ebe:	bd70      	pop	{r4, r5, r6, pc}

08008ec0 <TIM_OC2_SetConfig>:
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8008ec0:	2210      	movs	r2, #16
 8008ec2:	6a03      	ldr	r3, [r0, #32]
{
 8008ec4:	b570      	push	{r4, r5, r6, lr}
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8008ec6:	4393      	bics	r3, r2
 8008ec8:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8008eca:	6a02      	ldr	r2, [r0, #32]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8008ecc:	4d16      	ldr	r5, [pc, #88]	; (8008f28 <TIM_OC2_SetConfig+0x68>)
  tmpcr2 =  TIMx->CR2;
 8008ece:	6843      	ldr	r3, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 8008ed0:	6984      	ldr	r4, [r0, #24]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8008ed2:	402c      	ands	r4, r5
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8008ed4:	680d      	ldr	r5, [r1, #0]
 8008ed6:	022d      	lsls	r5, r5, #8
 8008ed8:	432c      	orrs	r4, r5
  tmpccer &= ~TIM_CCER_CC2P;
 8008eda:	2520      	movs	r5, #32
 8008edc:	43aa      	bics	r2, r5
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8008ede:	688d      	ldr	r5, [r1, #8]
 8008ee0:	012d      	lsls	r5, r5, #4
 8008ee2:	432a      	orrs	r2, r5
  if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8008ee4:	4d11      	ldr	r5, [pc, #68]	; (8008f2c <TIM_OC2_SetConfig+0x6c>)
 8008ee6:	42a8      	cmp	r0, r5
 8008ee8:	d10f      	bne.n	8008f0a <TIM_OC2_SetConfig+0x4a>
    tmpccer &= ~TIM_CCER_CC2NP;
 8008eea:	2580      	movs	r5, #128	; 0x80
 8008eec:	43aa      	bics	r2, r5
 8008eee:	0015      	movs	r5, r2
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8008ef0:	68ca      	ldr	r2, [r1, #12]
 8008ef2:	0112      	lsls	r2, r2, #4
 8008ef4:	432a      	orrs	r2, r5
    tmpccer &= ~TIM_CCER_CC2NE;
 8008ef6:	2540      	movs	r5, #64	; 0x40
 8008ef8:	43aa      	bics	r2, r5
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8008efa:	4d0d      	ldr	r5, [pc, #52]	; (8008f30 <TIM_OC2_SetConfig+0x70>)
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8008efc:	694e      	ldr	r6, [r1, #20]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8008efe:	401d      	ands	r5, r3
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8008f00:	698b      	ldr	r3, [r1, #24]
 8008f02:	4333      	orrs	r3, r6
 8008f04:	009b      	lsls	r3, r3, #2
 8008f06:	432b      	orrs	r3, r5
 8008f08:	e008      	b.n	8008f1c <TIM_OC2_SetConfig+0x5c>
  if(IS_TIM_BREAK_INSTANCE(TIMx))
 8008f0a:	4d0a      	ldr	r5, [pc, #40]	; (8008f34 <TIM_OC2_SetConfig+0x74>)
 8008f0c:	42a8      	cmp	r0, r5
 8008f0e:	d0f4      	beq.n	8008efa <TIM_OC2_SetConfig+0x3a>
 8008f10:	4d09      	ldr	r5, [pc, #36]	; (8008f38 <TIM_OC2_SetConfig+0x78>)
 8008f12:	42a8      	cmp	r0, r5
 8008f14:	d0f1      	beq.n	8008efa <TIM_OC2_SetConfig+0x3a>
 8008f16:	4d09      	ldr	r5, [pc, #36]	; (8008f3c <TIM_OC2_SetConfig+0x7c>)
 8008f18:	42a8      	cmp	r0, r5
 8008f1a:	d0ee      	beq.n	8008efa <TIM_OC2_SetConfig+0x3a>
  TIMx->CR2 = tmpcr2;
 8008f1c:	6043      	str	r3, [r0, #4]
  TIMx->CCR2 = OC_Config->Pulse;
 8008f1e:	684b      	ldr	r3, [r1, #4]
  TIMx->CCMR1 = tmpccmrx;
 8008f20:	6184      	str	r4, [r0, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8008f22:	6383      	str	r3, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
 8008f24:	6202      	str	r2, [r0, #32]
}
 8008f26:	bd70      	pop	{r4, r5, r6, pc}
 8008f28:	ffff8cff 	.word	0xffff8cff
 8008f2c:	40012c00 	.word	0x40012c00
 8008f30:	fffff3ff 	.word	0xfffff3ff
 8008f34:	40014000 	.word	0x40014000
 8008f38:	40014400 	.word	0x40014400
 8008f3c:	40014800 	.word	0x40014800

08008f40 <HAL_TIM_OC_ConfigChannel>:
{
 8008f40:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(htim);
 8008f42:	0004      	movs	r4, r0
 8008f44:	2602      	movs	r6, #2
 8008f46:	343c      	adds	r4, #60	; 0x3c
 8008f48:	7825      	ldrb	r5, [r4, #0]
{
 8008f4a:	0003      	movs	r3, r0
  __HAL_LOCK(htim);
 8008f4c:	0030      	movs	r0, r6
 8008f4e:	2d01      	cmp	r5, #1
 8008f50:	d017      	beq.n	8008f82 <HAL_TIM_OC_ConfigChannel+0x42>
  htim->State = HAL_TIM_STATE_BUSY;
 8008f52:	001d      	movs	r5, r3
  __HAL_LOCK(htim);
 8008f54:	3801      	subs	r0, #1
  htim->State = HAL_TIM_STATE_BUSY;
 8008f56:	353d      	adds	r5, #61	; 0x3d
  __HAL_LOCK(htim);
 8008f58:	7020      	strb	r0, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8008f5a:	702e      	strb	r6, [r5, #0]
  switch (Channel)
 8008f5c:	2a0c      	cmp	r2, #12
 8008f5e:	d80c      	bhi.n	8008f7a <HAL_TIM_OC_ConfigChannel+0x3a>
 8008f60:	0010      	movs	r0, r2
 8008f62:	f7fc fd27 	bl	80059b4 <__gnu_thumb1_case_uqi>
 8008f66:	0a07      	.short	0x0a07
 8008f68:	0a0f0a0a 	.word	0x0a0f0a0a
 8008f6c:	0a130a0a 	.word	0x0a130a0a
 8008f70:	0a0a      	.short	0x0a0a
 8008f72:	17          	.byte	0x17
 8008f73:	00          	.byte	0x00
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8008f74:	6818      	ldr	r0, [r3, #0]
 8008f76:	f7ff fe43 	bl	8008c00 <TIM_OC1_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
 8008f7a:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
 8008f7c:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8008f7e:	702b      	strb	r3, [r5, #0]
  __HAL_UNLOCK(htim);
 8008f80:	7020      	strb	r0, [r4, #0]
}
 8008f82:	bd70      	pop	{r4, r5, r6, pc}
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8008f84:	6818      	ldr	r0, [r3, #0]
 8008f86:	f7ff ff9b 	bl	8008ec0 <TIM_OC2_SetConfig>
    break;
 8008f8a:	e7f6      	b.n	8008f7a <HAL_TIM_OC_ConfigChannel+0x3a>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8008f8c:	6818      	ldr	r0, [r3, #0]
 8008f8e:	f7ff fe7b 	bl	8008c88 <TIM_OC3_SetConfig>
    break;
 8008f92:	e7f2      	b.n	8008f7a <HAL_TIM_OC_ConfigChannel+0x3a>
       TIM_OC4_SetConfig(htim->Instance, sConfig);
 8008f94:	6818      	ldr	r0, [r3, #0]
 8008f96:	f7ff febb 	bl	8008d10 <TIM_OC4_SetConfig>
    break;
 8008f9a:	e7ee      	b.n	8008f7a <HAL_TIM_OC_ConfigChannel+0x3a>

08008f9c <TIM_CCxChannelCmd>:
  * @param  ChannelState : specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
{
 8008f9c:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << Channel;
 8008f9e:	2401      	movs	r4, #1
 8008fa0:	408c      	lsls	r4, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;

  /* Set or reset the CCxE Bit */
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 8008fa2:	408a      	lsls	r2, r1
  TIMx->CCER &= ~tmp;
 8008fa4:	6a03      	ldr	r3, [r0, #32]
 8008fa6:	43a3      	bics	r3, r4
 8008fa8:	6203      	str	r3, [r0, #32]
  TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
 8008faa:	6a03      	ldr	r3, [r0, #32]
 8008fac:	431a      	orrs	r2, r3
 8008fae:	6202      	str	r2, [r0, #32]
}
 8008fb0:	bd10      	pop	{r4, pc}
	...

08008fb4 <HAL_TIM_OC_Start_IT>:
{
 8008fb4:	b510      	push	{r4, lr}
 8008fb6:	6803      	ldr	r3, [r0, #0]
 8008fb8:	0004      	movs	r4, r0
  switch (Channel)
 8008fba:	290c      	cmp	r1, #12
 8008fbc:	d80d      	bhi.n	8008fda <HAL_TIM_OC_Start_IT+0x26>
 8008fbe:	0008      	movs	r0, r1
 8008fc0:	f7fc fcf8 	bl	80059b4 <__gnu_thumb1_case_uqi>
 8008fc4:	0b0b0b07 	.word	0x0b0b0b07
 8008fc8:	0b0b0b27 	.word	0x0b0b0b27
 8008fcc:	0b0b0b2a 	.word	0x0b0b0b2a
 8008fd0:	2d          	.byte	0x2d
 8008fd1:	00          	.byte	0x00
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 8008fd2:	2202      	movs	r2, #2
 8008fd4:	68d8      	ldr	r0, [r3, #12]
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 8008fd6:	4302      	orrs	r2, r0
 8008fd8:	60da      	str	r2, [r3, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8008fda:	2201      	movs	r2, #1
 8008fdc:	0018      	movs	r0, r3
 8008fde:	f7ff ffdd 	bl	8008f9c <TIM_CCxChannelCmd>
  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8008fe2:	6823      	ldr	r3, [r4, #0]
 8008fe4:	4a0f      	ldr	r2, [pc, #60]	; (8009024 <HAL_TIM_OC_Start_IT+0x70>)
 8008fe6:	4293      	cmp	r3, r2
 8008fe8:	d008      	beq.n	8008ffc <HAL_TIM_OC_Start_IT+0x48>
 8008fea:	4a0f      	ldr	r2, [pc, #60]	; (8009028 <HAL_TIM_OC_Start_IT+0x74>)
 8008fec:	4293      	cmp	r3, r2
 8008fee:	d005      	beq.n	8008ffc <HAL_TIM_OC_Start_IT+0x48>
 8008ff0:	4a0e      	ldr	r2, [pc, #56]	; (800902c <HAL_TIM_OC_Start_IT+0x78>)
 8008ff2:	4293      	cmp	r3, r2
 8008ff4:	d002      	beq.n	8008ffc <HAL_TIM_OC_Start_IT+0x48>
 8008ff6:	4a0e      	ldr	r2, [pc, #56]	; (8009030 <HAL_TIM_OC_Start_IT+0x7c>)
 8008ff8:	4293      	cmp	r3, r2
 8008ffa:	d104      	bne.n	8009006 <HAL_TIM_OC_Start_IT+0x52>
    __HAL_TIM_MOE_ENABLE(htim);
 8008ffc:	2280      	movs	r2, #128	; 0x80
 8008ffe:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8009000:	0212      	lsls	r2, r2, #8
 8009002:	430a      	orrs	r2, r1
 8009004:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_ENABLE(htim);
 8009006:	2201      	movs	r2, #1
 8009008:	6819      	ldr	r1, [r3, #0]
}
 800900a:	2000      	movs	r0, #0
  __HAL_TIM_ENABLE(htim);
 800900c:	430a      	orrs	r2, r1
 800900e:	601a      	str	r2, [r3, #0]
}
 8009010:	bd10      	pop	{r4, pc}
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 8009012:	68d8      	ldr	r0, [r3, #12]
 8009014:	2204      	movs	r2, #4
 8009016:	e7de      	b.n	8008fd6 <HAL_TIM_OC_Start_IT+0x22>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 8009018:	68d8      	ldr	r0, [r3, #12]
 800901a:	2208      	movs	r2, #8
 800901c:	e7db      	b.n	8008fd6 <HAL_TIM_OC_Start_IT+0x22>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 800901e:	68d8      	ldr	r0, [r3, #12]
 8009020:	2210      	movs	r2, #16
 8009022:	e7d8      	b.n	8008fd6 <HAL_TIM_OC_Start_IT+0x22>
 8009024:	40012c00 	.word	0x40012c00
 8009028:	40014000 	.word	0x40014000
 800902c:	40014400 	.word	0x40014400
 8009030:	40014800 	.word	0x40014800

08009034 <HAL_TIM_OC_Stop_IT>:
{
 8009034:	b510      	push	{r4, lr}
 8009036:	6803      	ldr	r3, [r0, #0]
 8009038:	0004      	movs	r4, r0
  switch (Channel)
 800903a:	290c      	cmp	r1, #12
 800903c:	d80d      	bhi.n	800905a <HAL_TIM_OC_Stop_IT+0x26>
 800903e:	0008      	movs	r0, r1
 8009040:	f7fc fcb8 	bl	80059b4 <__gnu_thumb1_case_uqi>
 8009044:	0b0b0b07 	.word	0x0b0b0b07
 8009048:	0b0b0b35 	.word	0x0b0b0b35
 800904c:	0b0b0b38 	.word	0x0b0b0b38
 8009050:	3b          	.byte	0x3b
 8009051:	00          	.byte	0x00
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
 8009052:	2002      	movs	r0, #2
 8009054:	68da      	ldr	r2, [r3, #12]
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 8009056:	4382      	bics	r2, r0
 8009058:	60da      	str	r2, [r3, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 800905a:	2200      	movs	r2, #0
 800905c:	0018      	movs	r0, r3
 800905e:	f7ff ff9d 	bl	8008f9c <TIM_CCxChannelCmd>
  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8009062:	6823      	ldr	r3, [r4, #0]
 8009064:	4a16      	ldr	r2, [pc, #88]	; (80090c0 <HAL_TIM_OC_Stop_IT+0x8c>)
 8009066:	4917      	ldr	r1, [pc, #92]	; (80090c4 <HAL_TIM_OC_Stop_IT+0x90>)
 8009068:	4293      	cmp	r3, r2
 800906a:	d008      	beq.n	800907e <HAL_TIM_OC_Stop_IT+0x4a>
 800906c:	4a16      	ldr	r2, [pc, #88]	; (80090c8 <HAL_TIM_OC_Stop_IT+0x94>)
 800906e:	4293      	cmp	r3, r2
 8009070:	d005      	beq.n	800907e <HAL_TIM_OC_Stop_IT+0x4a>
 8009072:	4a16      	ldr	r2, [pc, #88]	; (80090cc <HAL_TIM_OC_Stop_IT+0x98>)
 8009074:	4293      	cmp	r3, r2
 8009076:	d002      	beq.n	800907e <HAL_TIM_OC_Stop_IT+0x4a>
 8009078:	4a15      	ldr	r2, [pc, #84]	; (80090d0 <HAL_TIM_OC_Stop_IT+0x9c>)
 800907a:	4293      	cmp	r3, r2
 800907c:	d10a      	bne.n	8009094 <HAL_TIM_OC_Stop_IT+0x60>
    __HAL_TIM_MOE_DISABLE(htim);
 800907e:	6a1a      	ldr	r2, [r3, #32]
 8009080:	420a      	tst	r2, r1
 8009082:	d107      	bne.n	8009094 <HAL_TIM_OC_Stop_IT+0x60>
 8009084:	6a18      	ldr	r0, [r3, #32]
 8009086:	4a13      	ldr	r2, [pc, #76]	; (80090d4 <HAL_TIM_OC_Stop_IT+0xa0>)
 8009088:	4210      	tst	r0, r2
 800908a:	d103      	bne.n	8009094 <HAL_TIM_OC_Stop_IT+0x60>
 800908c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800908e:	4812      	ldr	r0, [pc, #72]	; (80090d8 <HAL_TIM_OC_Stop_IT+0xa4>)
 8009090:	4002      	ands	r2, r0
 8009092:	645a      	str	r2, [r3, #68]	; 0x44
  __HAL_TIM_DISABLE(htim);
 8009094:	6a1a      	ldr	r2, [r3, #32]
 8009096:	420a      	tst	r2, r1
 8009098:	d107      	bne.n	80090aa <HAL_TIM_OC_Stop_IT+0x76>
 800909a:	6a19      	ldr	r1, [r3, #32]
 800909c:	4a0d      	ldr	r2, [pc, #52]	; (80090d4 <HAL_TIM_OC_Stop_IT+0xa0>)
 800909e:	4211      	tst	r1, r2
 80090a0:	d103      	bne.n	80090aa <HAL_TIM_OC_Stop_IT+0x76>
 80090a2:	2101      	movs	r1, #1
 80090a4:	681a      	ldr	r2, [r3, #0]
 80090a6:	438a      	bics	r2, r1
 80090a8:	601a      	str	r2, [r3, #0]
}
 80090aa:	2000      	movs	r0, #0
 80090ac:	bd10      	pop	{r4, pc}
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
 80090ae:	68da      	ldr	r2, [r3, #12]
 80090b0:	2004      	movs	r0, #4
 80090b2:	e7d0      	b.n	8009056 <HAL_TIM_OC_Stop_IT+0x22>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
 80090b4:	68da      	ldr	r2, [r3, #12]
 80090b6:	2008      	movs	r0, #8
 80090b8:	e7cd      	b.n	8009056 <HAL_TIM_OC_Stop_IT+0x22>
      __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
 80090ba:	68da      	ldr	r2, [r3, #12]
 80090bc:	2010      	movs	r0, #16
 80090be:	e7ca      	b.n	8009056 <HAL_TIM_OC_Stop_IT+0x22>
 80090c0:	40012c00 	.word	0x40012c00
 80090c4:	00001111 	.word	0x00001111
 80090c8:	40014000 	.word	0x40014000
 80090cc:	40014400 	.word	0x40014400
 80090d0:	40014800 	.word	0x40014800
 80090d4:	00000444 	.word	0x00000444
 80090d8:	ffff7fff 	.word	0xffff7fff

080090dc <HAL_TIMEx_ConfigBreakDeadTime>:
  *         contains the BDTR Register configuration  information for the TIM peripheral.
  * @retval HAL status
  */    
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
                                                TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
{
 80090dc:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));

  /* Process Locked */
  __HAL_LOCK(htim);
 80090de:	0004      	movs	r4, r0
 80090e0:	2302      	movs	r3, #2
 80090e2:	343c      	adds	r4, #60	; 0x3c
 80090e4:	7825      	ldrb	r5, [r4, #0]
{
 80090e6:	0002      	movs	r2, r0
  __HAL_LOCK(htim);
 80090e8:	0018      	movs	r0, r3
 80090ea:	2d01      	cmp	r5, #1
 80090ec:	d024      	beq.n	8009138 <HAL_TIMEx_ConfigBreakDeadTime+0x5c>

  htim->State = HAL_TIM_STATE_BUSY;
 80090ee:	0010      	movs	r0, r2
 80090f0:	303d      	adds	r0, #61	; 0x3d
  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  
  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 80090f2:	68cd      	ldr	r5, [r1, #12]
  htim->State = HAL_TIM_STATE_BUSY;
 80090f4:	7003      	strb	r3, [r0, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 80090f6:	4b11      	ldr	r3, [pc, #68]	; (800913c <HAL_TIMEx_ConfigBreakDeadTime+0x60>)
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
  
  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
 80090f8:	6812      	ldr	r2, [r2, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 80090fa:	402b      	ands	r3, r5
 80090fc:	688d      	ldr	r5, [r1, #8]
 80090fe:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 8009100:	4d0f      	ldr	r5, [pc, #60]	; (8009140 <HAL_TIMEx_ConfigBreakDeadTime+0x64>)
 8009102:	402b      	ands	r3, r5
 8009104:	684d      	ldr	r5, [r1, #4]
 8009106:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8009108:	4d0e      	ldr	r5, [pc, #56]	; (8009144 <HAL_TIMEx_ConfigBreakDeadTime+0x68>)
 800910a:	402b      	ands	r3, r5
 800910c:	680d      	ldr	r5, [r1, #0]
 800910e:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8009110:	4d0d      	ldr	r5, [pc, #52]	; (8009148 <HAL_TIMEx_ConfigBreakDeadTime+0x6c>)
 8009112:	402b      	ands	r3, r5
 8009114:	690d      	ldr	r5, [r1, #16]
 8009116:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8009118:	4d0c      	ldr	r5, [pc, #48]	; (800914c <HAL_TIMEx_ConfigBreakDeadTime+0x70>)
 800911a:	402b      	ands	r3, r5
 800911c:	694d      	ldr	r5, [r1, #20]
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 800911e:	6989      	ldr	r1, [r1, #24]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8009120:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8009122:	4d0b      	ldr	r5, [pc, #44]	; (8009150 <HAL_TIMEx_ConfigBreakDeadTime+0x74>)
 8009124:	402b      	ands	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
 8009126:	4d0b      	ldr	r5, [pc, #44]	; (8009154 <HAL_TIMEx_ConfigBreakDeadTime+0x78>)
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8009128:	430b      	orrs	r3, r1
  MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, sBreakDeadTimeConfig->AutomaticOutput);
 800912a:	402b      	ands	r3, r5
 800912c:	430b      	orrs	r3, r1
  htim->Instance->BDTR = tmpbdtr;
 800912e:	6453      	str	r3, [r2, #68]	; 0x44
  
  htim->State = HAL_TIM_STATE_READY;
 8009130:	2301      	movs	r3, #1
 8009132:	7003      	strb	r3, [r0, #0]

  __HAL_UNLOCK(htim);
 8009134:	2000      	movs	r0, #0
 8009136:	7020      	strb	r0, [r4, #0]

  return HAL_OK;
}
 8009138:	bd30      	pop	{r4, r5, pc}
 800913a:	46c0      	nop			; (mov r8, r8)
 800913c:	fffffcff 	.word	0xfffffcff
 8009140:	fffffbff 	.word	0xfffffbff
 8009144:	fffff7ff 	.word	0xfffff7ff
 8009148:	ffffefff 	.word	0xffffefff
 800914c:	ffffdfff 	.word	0xffffdfff
 8009150:	ffffbfff 	.word	0xffffbfff
 8009154:	ffff7fff 	.word	0xffff7fff

08009158 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart: UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8009158:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800915a:	0004      	movs	r4, r0
   *  set the M bits according to huart->Init.WordLength value
   *  set PCE and PS bits according to huart->Init.Parity value
   *  set TE and RE bits according to huart->Init.Mode value
   *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 800915c:	6805      	ldr	r5, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800915e:	69c2      	ldr	r2, [r0, #28]
 8009160:	6883      	ldr	r3, [r0, #8]
 8009162:	6900      	ldr	r0, [r0, #16]
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8009164:	6829      	ldr	r1, [r5, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8009166:	4303      	orrs	r3, r0
 8009168:	6960      	ldr	r0, [r4, #20]
 800916a:	4303      	orrs	r3, r0
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 800916c:	4850      	ldr	r0, [pc, #320]	; (80092b0 <UART_SetConfig+0x158>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800916e:	4313      	orrs	r3, r2
  MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 8009170:	4001      	ands	r1, r0
 8009172:	430b      	orrs	r3, r1
 8009174:	602b      	str	r3, [r5, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
   * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8009176:	686b      	ldr	r3, [r5, #4]
 8009178:	494e      	ldr	r1, [pc, #312]	; (80092b4 <UART_SetConfig+0x15c>)
  /* Configure
   * - UART HardWare Flow Control: set CTSE and RTSE bits according
   *   to huart->Init.HwFlowCtl value
   * - one-bit sampling method versus three samples' majority rule according
   *   to huart->Init.OneBitSampling */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 800917a:	6a20      	ldr	r0, [r4, #32]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800917c:	400b      	ands	r3, r1
 800917e:	68e1      	ldr	r1, [r4, #12]
 8009180:	430b      	orrs	r3, r1
 8009182:	606b      	str	r3, [r5, #4]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 8009184:	69a3      	ldr	r3, [r4, #24]
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 8009186:	68a9      	ldr	r1, [r5, #8]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 8009188:	4303      	orrs	r3, r0
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 800918a:	484b      	ldr	r0, [pc, #300]	; (80092b8 <UART_SetConfig+0x160>)
 800918c:	4001      	ands	r1, r0
 800918e:	430b      	orrs	r3, r1
 8009190:	60ab      	str	r3, [r5, #8]

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8009192:	4b4a      	ldr	r3, [pc, #296]	; (80092bc <UART_SetConfig+0x164>)
 8009194:	429d      	cmp	r5, r3
 8009196:	d113      	bne.n	80091c0 <UART_SetConfig+0x68>
 8009198:	2103      	movs	r1, #3
 800919a:	4b49      	ldr	r3, [pc, #292]	; (80092c0 <UART_SetConfig+0x168>)
 800919c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800919e:	400b      	ands	r3, r1
 80091a0:	4948      	ldr	r1, [pc, #288]	; (80092c4 <UART_SetConfig+0x16c>)
 80091a2:	5cc8      	ldrb	r0, [r1, r3]
  
  /* Check UART Over Sampling to set Baud Rate Register */
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80091a4:	2380      	movs	r3, #128	; 0x80
 80091a6:	021b      	lsls	r3, r3, #8
 80091a8:	429a      	cmp	r2, r3
 80091aa:	d14a      	bne.n	8009242 <UART_SetConfig+0xea>
  {
    switch (clocksource)
 80091ac:	2808      	cmp	r0, #8
 80091ae:	d900      	bls.n	80091b2 <UART_SetConfig+0x5a>
 80091b0:	e07b      	b.n	80092aa <UART_SetConfig+0x152>
 80091b2:	f7fc fbff 	bl	80059b4 <__gnu_thumb1_case_uqi>
 80091b6:	7a40      	.short	0x7a40
 80091b8:	7a6e7a25 	.word	0x7a6e7a25
 80091bc:	7a7a      	.short	0x7a7a
 80091be:	73          	.byte	0x73
 80091bf:	00          	.byte	0x00
 80091c0:	2180      	movs	r1, #128	; 0x80
  UART_GETCLOCKSOURCE(huart, clocksource);
 80091c2:	4b41      	ldr	r3, [pc, #260]	; (80092c8 <UART_SetConfig+0x170>)
 80091c4:	0209      	lsls	r1, r1, #8
 80091c6:	429d      	cmp	r5, r3
 80091c8:	d12d      	bne.n	8009226 <UART_SetConfig+0xce>
 80091ca:	20c0      	movs	r0, #192	; 0xc0
 80091cc:	2680      	movs	r6, #128	; 0x80
 80091ce:	4b3c      	ldr	r3, [pc, #240]	; (80092c0 <UART_SetConfig+0x168>)
 80091d0:	0280      	lsls	r0, r0, #10
 80091d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80091d4:	0276      	lsls	r6, r6, #9
 80091d6:	4003      	ands	r3, r0
 80091d8:	42b3      	cmp	r3, r6
 80091da:	d058      	beq.n	800928e <UART_SetConfig+0x136>
 80091dc:	000f      	movs	r7, r1
 80091de:	42b3      	cmp	r3, r6
 80091e0:	d806      	bhi.n	80091f0 <UART_SetConfig+0x98>
 80091e2:	2000      	movs	r0, #0
 80091e4:	4283      	cmp	r3, r0
 80091e6:	d0dd      	beq.n	80091a4 <UART_SetConfig+0x4c>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80091e8:	42ba      	cmp	r2, r7
 80091ea:	d05e      	beq.n	80092aa <UART_SetConfig+0x152>
      case UART_CLOCKSOURCE_LSE:
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
        break;
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 80091ec:	2001      	movs	r0, #1
        break;
    }
  }

  return ret;
 80091ee:	e019      	b.n	8009224 <UART_SetConfig+0xcc>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80091f0:	2680      	movs	r6, #128	; 0x80
 80091f2:	02b6      	lsls	r6, r6, #10
 80091f4:	42b3      	cmp	r3, r6
 80091f6:	d04f      	beq.n	8009298 <UART_SetConfig+0x140>
 80091f8:	4283      	cmp	r3, r0
 80091fa:	d1f5      	bne.n	80091e8 <UART_SetConfig+0x90>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80091fc:	428a      	cmp	r2, r1
 80091fe:	d135      	bne.n	800926c <UART_SetConfig+0x114>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 8009200:	6863      	ldr	r3, [r4, #4]
 8009202:	0858      	lsrs	r0, r3, #1
 8009204:	4b31      	ldr	r3, [pc, #196]	; (80092cc <UART_SetConfig+0x174>)
 8009206:	18c0      	adds	r0, r0, r3
 8009208:	6861      	ldr	r1, [r4, #4]
 800920a:	f7fc fbdd 	bl	80059c8 <__udivsi3>
 800920e:	b283      	uxth	r3, r0
  HAL_StatusTypeDef ret               = HAL_OK;
 8009210:	2000      	movs	r0, #0
    brrtemp = usartdiv & 0xFFF0U;
 8009212:	220f      	movs	r2, #15
 8009214:	0019      	movs	r1, r3
 8009216:	4391      	bics	r1, r2
 8009218:	000a      	movs	r2, r1
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800921a:	071b      	lsls	r3, r3, #28
    huart->Instance->BRR = brrtemp;
 800921c:	6821      	ldr	r1, [r4, #0]
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800921e:	0f5b      	lsrs	r3, r3, #29
    huart->Instance->BRR = brrtemp;
 8009220:	4313      	orrs	r3, r2
 8009222:	60cb      	str	r3, [r1, #12]

}
 8009224:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 8009226:	4b2a      	ldr	r3, [pc, #168]	; (80092d0 <UART_SetConfig+0x178>)
 8009228:	429d      	cmp	r5, r3
 800922a:	d002      	beq.n	8009232 <UART_SetConfig+0xda>
 800922c:	4b29      	ldr	r3, [pc, #164]	; (80092d4 <UART_SetConfig+0x17c>)
 800922e:	429d      	cmp	r5, r3
 8009230:	d139      	bne.n	80092a6 <UART_SetConfig+0x14e>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8009232:	428a      	cmp	r2, r1
 8009234:	d10e      	bne.n	8009254 <UART_SetConfig+0xfc>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8009236:	f7ff f819 	bl	800826c <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800923a:	6863      	ldr	r3, [r4, #4]
 800923c:	0040      	lsls	r0, r0, #1
 800923e:	085b      	lsrs	r3, r3, #1
 8009240:	e7e1      	b.n	8009206 <UART_SetConfig+0xae>
    switch (clocksource)
 8009242:	2808      	cmp	r0, #8
 8009244:	d8d2      	bhi.n	80091ec <UART_SetConfig+0x94>
 8009246:	f7fc fbab 	bl	80059a0 <__gnu_thumb1_case_sqi>
 800924a:	d105      	.short	0xd105
 800924c:	d11ad111 	.word	0xd11ad111
 8009250:	d1d1      	.short	0xd1d1
 8009252:	1d          	.byte	0x1d
 8009253:	00          	.byte	0x00
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8009254:	f7ff f80a 	bl	800826c <HAL_RCC_GetPCLK1Freq>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8009258:	6861      	ldr	r1, [r4, #4]
 800925a:	6824      	ldr	r4, [r4, #0]
 800925c:	084b      	lsrs	r3, r1, #1
 800925e:	1818      	adds	r0, r3, r0
 8009260:	f7fc fbb2 	bl	80059c8 <__udivsi3>
 8009264:	b280      	uxth	r0, r0
 8009266:	60e0      	str	r0, [r4, #12]
  HAL_StatusTypeDef ret               = HAL_OK;
 8009268:	2000      	movs	r0, #0
        break;
 800926a:	e7db      	b.n	8009224 <UART_SetConfig+0xcc>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 800926c:	6861      	ldr	r1, [r4, #4]
 800926e:	4b1a      	ldr	r3, [pc, #104]	; (80092d8 <UART_SetConfig+0x180>)
 8009270:	0848      	lsrs	r0, r1, #1
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8009272:	18c0      	adds	r0, r0, r3
 8009274:	f7fc fba8 	bl	80059c8 <__udivsi3>
 8009278:	b280      	uxth	r0, r0
 800927a:	60e8      	str	r0, [r5, #12]
 800927c:	e7f4      	b.n	8009268 <UART_SetConfig+0x110>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800927e:	f7fe ffad 	bl	80081dc <HAL_RCC_GetSysClockFreq>
 8009282:	e7e9      	b.n	8009258 <UART_SetConfig+0x100>
        huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8009284:	2380      	movs	r3, #128	; 0x80
 8009286:	6861      	ldr	r1, [r4, #4]
 8009288:	021b      	lsls	r3, r3, #8
 800928a:	0848      	lsrs	r0, r1, #1
 800928c:	e7f1      	b.n	8009272 <UART_SetConfig+0x11a>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800928e:	428a      	cmp	r2, r1
 8009290:	d1f5      	bne.n	800927e <UART_SetConfig+0x126>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8009292:	f7fe ffa3 	bl	80081dc <HAL_RCC_GetSysClockFreq>
 8009296:	e7d0      	b.n	800923a <UART_SetConfig+0xe2>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8009298:	428a      	cmp	r2, r1
 800929a:	d1f3      	bne.n	8009284 <UART_SetConfig+0x12c>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 800929c:	6863      	ldr	r3, [r4, #4]
 800929e:	0858      	lsrs	r0, r3, #1
 80092a0:	2380      	movs	r3, #128	; 0x80
 80092a2:	025b      	lsls	r3, r3, #9
 80092a4:	e7af      	b.n	8009206 <UART_SetConfig+0xae>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80092a6:	428a      	cmp	r2, r1
 80092a8:	d1a0      	bne.n	80091ec <UART_SetConfig+0x94>
        ret = HAL_ERROR;
 80092aa:	2001      	movs	r0, #1
  uint16_t usartdiv                   = 0x0000U;
 80092ac:	2300      	movs	r3, #0
 80092ae:	e7b0      	b.n	8009212 <UART_SetConfig+0xba>
 80092b0:	efff69f3 	.word	0xefff69f3
 80092b4:	ffffcfff 	.word	0xffffcfff
 80092b8:	fffff4ff 	.word	0xfffff4ff
 80092bc:	40013800 	.word	0x40013800
 80092c0:	40021000 	.word	0x40021000
 80092c4:	0800cd50 	.word	0x0800cd50
 80092c8:	40004400 	.word	0x40004400
 80092cc:	00f42400 	.word	0x00f42400
 80092d0:	40004800 	.word	0x40004800
 80092d4:	40004c00 	.word	0x40004c00
 80092d8:	007a1200 	.word	0x007a1200

080092dc <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80092dc:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
 80092de:	b530      	push	{r4, r5, lr}
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80092e0:	07da      	lsls	r2, r3, #31
 80092e2:	d506      	bpl.n	80092f2 <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80092e4:	6801      	ldr	r1, [r0, #0]
 80092e6:	4c28      	ldr	r4, [pc, #160]	; (8009388 <UART_AdvFeatureConfig+0xac>)
 80092e8:	684a      	ldr	r2, [r1, #4]
 80092ea:	4022      	ands	r2, r4
 80092ec:	6a84      	ldr	r4, [r0, #40]	; 0x28
 80092ee:	4322      	orrs	r2, r4
 80092f0:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 80092f2:	079a      	lsls	r2, r3, #30
 80092f4:	d506      	bpl.n	8009304 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80092f6:	6801      	ldr	r1, [r0, #0]
 80092f8:	4c24      	ldr	r4, [pc, #144]	; (800938c <UART_AdvFeatureConfig+0xb0>)
 80092fa:	684a      	ldr	r2, [r1, #4]
 80092fc:	4022      	ands	r2, r4
 80092fe:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 8009300:	4322      	orrs	r2, r4
 8009302:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8009304:	075a      	lsls	r2, r3, #29
 8009306:	d506      	bpl.n	8009316 <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8009308:	6801      	ldr	r1, [r0, #0]
 800930a:	4c21      	ldr	r4, [pc, #132]	; (8009390 <UART_AdvFeatureConfig+0xb4>)
 800930c:	684a      	ldr	r2, [r1, #4]
 800930e:	4022      	ands	r2, r4
 8009310:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8009312:	4322      	orrs	r2, r4
 8009314:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8009316:	071a      	lsls	r2, r3, #28
 8009318:	d506      	bpl.n	8009328 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800931a:	6801      	ldr	r1, [r0, #0]
 800931c:	4c1d      	ldr	r4, [pc, #116]	; (8009394 <UART_AdvFeatureConfig+0xb8>)
 800931e:	684a      	ldr	r2, [r1, #4]
 8009320:	4022      	ands	r2, r4
 8009322:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8009324:	4322      	orrs	r2, r4
 8009326:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8009328:	06da      	lsls	r2, r3, #27
 800932a:	d506      	bpl.n	800933a <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800932c:	6801      	ldr	r1, [r0, #0]
 800932e:	4c1a      	ldr	r4, [pc, #104]	; (8009398 <UART_AdvFeatureConfig+0xbc>)
 8009330:	688a      	ldr	r2, [r1, #8]
 8009332:	4022      	ands	r2, r4
 8009334:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8009336:	4322      	orrs	r2, r4
 8009338:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800933a:	069a      	lsls	r2, r3, #26
 800933c:	d506      	bpl.n	800934c <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800933e:	6801      	ldr	r1, [r0, #0]
 8009340:	4c16      	ldr	r4, [pc, #88]	; (800939c <UART_AdvFeatureConfig+0xc0>)
 8009342:	688a      	ldr	r2, [r1, #8]
 8009344:	4022      	ands	r2, r4
 8009346:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 8009348:	4322      	orrs	r2, r4
 800934a:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800934c:	065a      	lsls	r2, r3, #25
 800934e:	d510      	bpl.n	8009372 <UART_AdvFeatureConfig+0x96>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8009350:	6801      	ldr	r1, [r0, #0]
 8009352:	4d13      	ldr	r5, [pc, #76]	; (80093a0 <UART_AdvFeatureConfig+0xc4>)
 8009354:	684a      	ldr	r2, [r1, #4]
 8009356:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8009358:	402a      	ands	r2, r5
 800935a:	4322      	orrs	r2, r4
 800935c:	604a      	str	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if(huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800935e:	2280      	movs	r2, #128	; 0x80
 8009360:	0352      	lsls	r2, r2, #13
 8009362:	4294      	cmp	r4, r2
 8009364:	d105      	bne.n	8009372 <UART_AdvFeatureConfig+0x96>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8009366:	684a      	ldr	r2, [r1, #4]
 8009368:	4c0e      	ldr	r4, [pc, #56]	; (80093a4 <UART_AdvFeatureConfig+0xc8>)
 800936a:	4022      	ands	r2, r4
 800936c:	6c44      	ldr	r4, [r0, #68]	; 0x44
 800936e:	4322      	orrs	r2, r4
 8009370:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if(HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8009372:	061b      	lsls	r3, r3, #24
 8009374:	d506      	bpl.n	8009384 <UART_AdvFeatureConfig+0xa8>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8009376:	6802      	ldr	r2, [r0, #0]
 8009378:	490b      	ldr	r1, [pc, #44]	; (80093a8 <UART_AdvFeatureConfig+0xcc>)
 800937a:	6853      	ldr	r3, [r2, #4]
 800937c:	400b      	ands	r3, r1
 800937e:	6c81      	ldr	r1, [r0, #72]	; 0x48
 8009380:	430b      	orrs	r3, r1
 8009382:	6053      	str	r3, [r2, #4]
  }
}
 8009384:	bd30      	pop	{r4, r5, pc}
 8009386:	46c0      	nop			; (mov r8, r8)
 8009388:	fffdffff 	.word	0xfffdffff
 800938c:	fffeffff 	.word	0xfffeffff
 8009390:	fffbffff 	.word	0xfffbffff
 8009394:	ffff7fff 	.word	0xffff7fff
 8009398:	ffffefff 	.word	0xffffefff
 800939c:	ffffdfff 	.word	0xffffdfff
 80093a0:	ffefffff 	.word	0xffefffff
 80093a4:	ff9fffff 	.word	0xff9fffff
 80093a8:	fff7ffff 	.word	0xfff7ffff

080093ac <UART_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 80093ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80093ae:	0004      	movs	r4, r0
 80093b0:	000e      	movs	r6, r1
 80093b2:	0015      	movs	r5, r2
 80093b4:	001f      	movs	r7, r3
  /* Wait until flag is set */
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80093b6:	6822      	ldr	r2, [r4, #0]
 80093b8:	69d3      	ldr	r3, [r2, #28]
 80093ba:	4033      	ands	r3, r6
 80093bc:	1b9b      	subs	r3, r3, r6
 80093be:	4259      	negs	r1, r3
 80093c0:	414b      	adcs	r3, r1
 80093c2:	42ab      	cmp	r3, r5
 80093c4:	d001      	beq.n	80093ca <UART_WaitOnFlagUntilTimeout+0x1e>
        __HAL_UNLOCK(huart);
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 80093c6:	2000      	movs	r0, #0
 80093c8:	e018      	b.n	80093fc <UART_WaitOnFlagUntilTimeout+0x50>
    if(Timeout != HAL_MAX_DELAY)
 80093ca:	9b06      	ldr	r3, [sp, #24]
 80093cc:	3301      	adds	r3, #1
 80093ce:	d0f3      	beq.n	80093b8 <UART_WaitOnFlagUntilTimeout+0xc>
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 80093d0:	9b06      	ldr	r3, [sp, #24]
 80093d2:	2b00      	cmp	r3, #0
 80093d4:	d113      	bne.n	80093fe <UART_WaitOnFlagUntilTimeout+0x52>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80093d6:	6823      	ldr	r3, [r4, #0]
 80093d8:	490c      	ldr	r1, [pc, #48]	; (800940c <UART_WaitOnFlagUntilTimeout+0x60>)
 80093da:	681a      	ldr	r2, [r3, #0]
        __HAL_UNLOCK(huart);
 80093dc:	2003      	movs	r0, #3
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80093de:	400a      	ands	r2, r1
 80093e0:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80093e2:	689a      	ldr	r2, [r3, #8]
 80093e4:	31a3      	adds	r1, #163	; 0xa3
 80093e6:	31ff      	adds	r1, #255	; 0xff
 80093e8:	438a      	bics	r2, r1
 80093ea:	609a      	str	r2, [r3, #8]
        huart->gState  = HAL_UART_STATE_READY;
 80093ec:	0022      	movs	r2, r4
 80093ee:	2320      	movs	r3, #32
 80093f0:	3269      	adds	r2, #105	; 0x69
 80093f2:	7013      	strb	r3, [r2, #0]
        huart->RxState = HAL_UART_STATE_READY;
 80093f4:	7053      	strb	r3, [r2, #1]
        __HAL_UNLOCK(huart);
 80093f6:	2300      	movs	r3, #0
 80093f8:	3468      	adds	r4, #104	; 0x68
 80093fa:	7023      	strb	r3, [r4, #0]
}
 80093fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 80093fe:	f7fd fe8f 	bl	8007120 <HAL_GetTick>
 8009402:	9b06      	ldr	r3, [sp, #24]
 8009404:	1bc0      	subs	r0, r0, r7
 8009406:	4298      	cmp	r0, r3
 8009408:	d9d5      	bls.n	80093b6 <UART_WaitOnFlagUntilTimeout+0xa>
 800940a:	e7e4      	b.n	80093d6 <UART_WaitOnFlagUntilTimeout+0x2a>
 800940c:	fffffe5f 	.word	0xfffffe5f

08009410 <HAL_UART_Transmit>:
{
 8009410:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(huart->gState == HAL_UART_STATE_READY)
 8009412:	0007      	movs	r7, r0
{
 8009414:	b085      	sub	sp, #20
 8009416:	9303      	str	r3, [sp, #12]
  if(huart->gState == HAL_UART_STATE_READY)
 8009418:	3769      	adds	r7, #105	; 0x69
 800941a:	783b      	ldrb	r3, [r7, #0]
{
 800941c:	0004      	movs	r4, r0
 800941e:	000d      	movs	r5, r1
 8009420:	0016      	movs	r6, r2
    return HAL_BUSY;
 8009422:	2002      	movs	r0, #2
  if(huart->gState == HAL_UART_STATE_READY)
 8009424:	2b20      	cmp	r3, #32
 8009426:	d146      	bne.n	80094b6 <HAL_UART_Transmit+0xa6>
      return  HAL_ERROR;
 8009428:	3801      	subs	r0, #1
    if((pData == NULL ) || (Size == 0U))
 800942a:	2900      	cmp	r1, #0
 800942c:	d043      	beq.n	80094b6 <HAL_UART_Transmit+0xa6>
 800942e:	2a00      	cmp	r2, #0
 8009430:	d041      	beq.n	80094b6 <HAL_UART_Transmit+0xa6>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8009432:	2380      	movs	r3, #128	; 0x80
 8009434:	68a2      	ldr	r2, [r4, #8]
 8009436:	015b      	lsls	r3, r3, #5
 8009438:	429a      	cmp	r2, r3
 800943a:	d104      	bne.n	8009446 <HAL_UART_Transmit+0x36>
 800943c:	6923      	ldr	r3, [r4, #16]
 800943e:	2b00      	cmp	r3, #0
 8009440:	d101      	bne.n	8009446 <HAL_UART_Transmit+0x36>
      if((((uint32_t)pData)&1U) != 0U)
 8009442:	4201      	tst	r1, r0
 8009444:	d137      	bne.n	80094b6 <HAL_UART_Transmit+0xa6>
    __HAL_LOCK(huart);
 8009446:	0023      	movs	r3, r4
 8009448:	3368      	adds	r3, #104	; 0x68
 800944a:	781a      	ldrb	r2, [r3, #0]
    return HAL_BUSY;
 800944c:	2002      	movs	r0, #2
    __HAL_LOCK(huart);
 800944e:	2a01      	cmp	r2, #1
 8009450:	d031      	beq.n	80094b6 <HAL_UART_Transmit+0xa6>
 8009452:	2201      	movs	r2, #1
 8009454:	701a      	strb	r2, [r3, #0]
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8009456:	2300      	movs	r3, #0
 8009458:	66e3      	str	r3, [r4, #108]	; 0x6c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800945a:	3321      	adds	r3, #33	; 0x21
 800945c:	703b      	strb	r3, [r7, #0]
    tickstart = HAL_GetTick();
 800945e:	f7fd fe5f 	bl	8007120 <HAL_GetTick>
    huart->TxXferSize = Size;
 8009462:	0023      	movs	r3, r4
 8009464:	3350      	adds	r3, #80	; 0x50
 8009466:	801e      	strh	r6, [r3, #0]
    huart->TxXferCount = Size;
 8009468:	805e      	strh	r6, [r3, #2]
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800946a:	2680      	movs	r6, #128	; 0x80
    tickstart = HAL_GetTick();
 800946c:	9002      	str	r0, [sp, #8]
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800946e:	0176      	lsls	r6, r6, #5
    while(huart->TxXferCount > 0)
 8009470:	0021      	movs	r1, r4
 8009472:	3152      	adds	r1, #82	; 0x52
 8009474:	880a      	ldrh	r2, [r1, #0]
 8009476:	b292      	uxth	r2, r2
 8009478:	2a00      	cmp	r2, #0
 800947a:	d10d      	bne.n	8009498 <HAL_UART_Transmit+0x88>
    if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800947c:	9b03      	ldr	r3, [sp, #12]
 800947e:	2140      	movs	r1, #64	; 0x40
 8009480:	9300      	str	r3, [sp, #0]
 8009482:	0020      	movs	r0, r4
 8009484:	9b02      	ldr	r3, [sp, #8]
 8009486:	f7ff ff91 	bl	80093ac <UART_WaitOnFlagUntilTimeout>
 800948a:	2800      	cmp	r0, #0
 800948c:	d112      	bne.n	80094b4 <HAL_UART_Transmit+0xa4>
    huart->gState = HAL_UART_STATE_READY;
 800948e:	2320      	movs	r3, #32
    __HAL_UNLOCK(huart);
 8009490:	3468      	adds	r4, #104	; 0x68
    huart->gState = HAL_UART_STATE_READY;
 8009492:	703b      	strb	r3, [r7, #0]
    __HAL_UNLOCK(huart);
 8009494:	7020      	strb	r0, [r4, #0]
    return HAL_OK;
 8009496:	e00e      	b.n	80094b6 <HAL_UART_Transmit+0xa6>
      huart->TxXferCount--;
 8009498:	880b      	ldrh	r3, [r1, #0]
      if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800949a:	2200      	movs	r2, #0
      huart->TxXferCount--;
 800949c:	3b01      	subs	r3, #1
 800949e:	b29b      	uxth	r3, r3
 80094a0:	800b      	strh	r3, [r1, #0]
      if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80094a2:	9b03      	ldr	r3, [sp, #12]
 80094a4:	2180      	movs	r1, #128	; 0x80
 80094a6:	9300      	str	r3, [sp, #0]
 80094a8:	0020      	movs	r0, r4
 80094aa:	9b02      	ldr	r3, [sp, #8]
 80094ac:	f7ff ff7e 	bl	80093ac <UART_WaitOnFlagUntilTimeout>
 80094b0:	2800      	cmp	r0, #0
 80094b2:	d002      	beq.n	80094ba <HAL_UART_Transmit+0xaa>
        return HAL_TIMEOUT;
 80094b4:	2003      	movs	r0, #3
}
 80094b6:	b005      	add	sp, #20
 80094b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80094ba:	68a3      	ldr	r3, [r4, #8]
 80094bc:	6822      	ldr	r2, [r4, #0]
 80094be:	42b3      	cmp	r3, r6
 80094c0:	d108      	bne.n	80094d4 <HAL_UART_Transmit+0xc4>
 80094c2:	6923      	ldr	r3, [r4, #16]
 80094c4:	2b00      	cmp	r3, #0
 80094c6:	d105      	bne.n	80094d4 <HAL_UART_Transmit+0xc4>
        huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
 80094c8:	882b      	ldrh	r3, [r5, #0]
        pData += 2;
 80094ca:	3502      	adds	r5, #2
        huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
 80094cc:	05db      	lsls	r3, r3, #23
 80094ce:	0ddb      	lsrs	r3, r3, #23
 80094d0:	8513      	strh	r3, [r2, #40]	; 0x28
        pData += 2;
 80094d2:	e7cd      	b.n	8009470 <HAL_UART_Transmit+0x60>
        huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
 80094d4:	782b      	ldrb	r3, [r5, #0]
 80094d6:	3501      	adds	r5, #1
 80094d8:	8513      	strh	r3, [r2, #40]	; 0x28
 80094da:	e7c9      	b.n	8009470 <HAL_UART_Transmit+0x60>

080094dc <UART_CheckIdleState>:
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80094dc:	2300      	movs	r3, #0
{
 80094de:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80094e0:	0004      	movs	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80094e2:	66c3      	str	r3, [r0, #108]	; 0x6c
  tickstart = HAL_GetTick();
 80094e4:	f7fd fe1c 	bl	8007120 <HAL_GetTick>
  if (IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance))
 80094e8:	6823      	ldr	r3, [r4, #0]
 80094ea:	4a18      	ldr	r2, [pc, #96]	; (800954c <UART_CheckIdleState+0x70>)
  tickstart = HAL_GetTick();
 80094ec:	0005      	movs	r5, r0
  if (IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance))
 80094ee:	4293      	cmp	r3, r2
 80094f0:	d00b      	beq.n	800950a <UART_CheckIdleState+0x2e>
 80094f2:	4a17      	ldr	r2, [pc, #92]	; (8009550 <UART_CheckIdleState+0x74>)
 80094f4:	4293      	cmp	r3, r2
 80094f6:	d008      	beq.n	800950a <UART_CheckIdleState+0x2e>
  huart->gState  = HAL_UART_STATE_READY;
 80094f8:	0022      	movs	r2, r4
 80094fa:	2320      	movs	r3, #32
  __HAL_UNLOCK(huart);
 80094fc:	2000      	movs	r0, #0
  huart->gState  = HAL_UART_STATE_READY;
 80094fe:	3269      	adds	r2, #105	; 0x69
  __HAL_UNLOCK(huart);
 8009500:	3468      	adds	r4, #104	; 0x68
  huart->gState  = HAL_UART_STATE_READY;
 8009502:	7013      	strb	r3, [r2, #0]
  huart->RxState = HAL_UART_STATE_READY;
 8009504:	7053      	strb	r3, [r2, #1]
  __HAL_UNLOCK(huart);
 8009506:	7020      	strb	r0, [r4, #0]
}
 8009508:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800950a:	681b      	ldr	r3, [r3, #0]
 800950c:	071b      	lsls	r3, r3, #28
 800950e:	d40f      	bmi.n	8009530 <UART_CheckIdleState+0x54>
    if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8009510:	6823      	ldr	r3, [r4, #0]
 8009512:	681b      	ldr	r3, [r3, #0]
 8009514:	075b      	lsls	r3, r3, #29
 8009516:	d5ef      	bpl.n	80094f8 <UART_CheckIdleState+0x1c>
      if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8009518:	2180      	movs	r1, #128	; 0x80
 800951a:	4b0e      	ldr	r3, [pc, #56]	; (8009554 <UART_CheckIdleState+0x78>)
 800951c:	2200      	movs	r2, #0
 800951e:	9300      	str	r3, [sp, #0]
 8009520:	03c9      	lsls	r1, r1, #15
 8009522:	002b      	movs	r3, r5
 8009524:	0020      	movs	r0, r4
 8009526:	f7ff ff41 	bl	80093ac <UART_WaitOnFlagUntilTimeout>
 800952a:	2800      	cmp	r0, #0
 800952c:	d0e4      	beq.n	80094f8 <UART_CheckIdleState+0x1c>
 800952e:	e00a      	b.n	8009546 <UART_CheckIdleState+0x6a>
      if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8009530:	2180      	movs	r1, #128	; 0x80
 8009532:	4b08      	ldr	r3, [pc, #32]	; (8009554 <UART_CheckIdleState+0x78>)
 8009534:	2200      	movs	r2, #0
 8009536:	9300      	str	r3, [sp, #0]
 8009538:	0389      	lsls	r1, r1, #14
 800953a:	002b      	movs	r3, r5
 800953c:	0020      	movs	r0, r4
 800953e:	f7ff ff35 	bl	80093ac <UART_WaitOnFlagUntilTimeout>
 8009542:	2800      	cmp	r0, #0
 8009544:	d0e4      	beq.n	8009510 <UART_CheckIdleState+0x34>
        return HAL_TIMEOUT;
 8009546:	2003      	movs	r0, #3
 8009548:	e7de      	b.n	8009508 <UART_CheckIdleState+0x2c>
 800954a:	46c0      	nop			; (mov r8, r8)
 800954c:	40013800 	.word	0x40013800
 8009550:	40004400 	.word	0x40004400
 8009554:	01ffffff 	.word	0x01ffffff

08009558 <HAL_UART_Init>:
{
 8009558:	b570      	push	{r4, r5, r6, lr}
 800955a:	1e04      	subs	r4, r0, #0
  if(huart == NULL)
 800955c:	d101      	bne.n	8009562 <HAL_UART_Init+0xa>
    return HAL_ERROR;
 800955e:	2001      	movs	r0, #1
}
 8009560:	bd70      	pop	{r4, r5, r6, pc}
  if(huart->gState == HAL_UART_STATE_RESET)
 8009562:	0005      	movs	r5, r0
 8009564:	3569      	adds	r5, #105	; 0x69
 8009566:	782b      	ldrb	r3, [r5, #0]
 8009568:	b2db      	uxtb	r3, r3
 800956a:	2b00      	cmp	r3, #0
 800956c:	d104      	bne.n	8009578 <HAL_UART_Init+0x20>
    huart->Lock = HAL_UNLOCKED;
 800956e:	0002      	movs	r2, r0
 8009570:	3268      	adds	r2, #104	; 0x68
 8009572:	7013      	strb	r3, [r2, #0]
    HAL_UART_MspInit(huart);
 8009574:	f7fd fd52 	bl	800701c <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 8009578:	2324      	movs	r3, #36	; 0x24
  __HAL_UART_DISABLE(huart);
 800957a:	2101      	movs	r1, #1
 800957c:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800957e:	702b      	strb	r3, [r5, #0]
  __HAL_UART_DISABLE(huart);
 8009580:	6813      	ldr	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8009582:	0020      	movs	r0, r4
  __HAL_UART_DISABLE(huart);
 8009584:	438b      	bics	r3, r1
 8009586:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8009588:	f7ff fde6 	bl	8009158 <UART_SetConfig>
 800958c:	2801      	cmp	r0, #1
 800958e:	d0e6      	beq.n	800955e <HAL_UART_Init+0x6>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8009590:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8009592:	2b00      	cmp	r3, #0
 8009594:	d002      	beq.n	800959c <HAL_UART_Init+0x44>
    UART_AdvFeatureConfig(huart);
 8009596:	0020      	movs	r0, r4
 8009598:	f7ff fea0 	bl	80092dc <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800959c:	6823      	ldr	r3, [r4, #0]
 800959e:	4908      	ldr	r1, [pc, #32]	; (80095c0 <HAL_UART_Init+0x68>)
 80095a0:	685a      	ldr	r2, [r3, #4]
  return (UART_CheckIdleState(huart));
 80095a2:	0020      	movs	r0, r4
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80095a4:	400a      	ands	r2, r1
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80095a6:	212a      	movs	r1, #42	; 0x2a
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80095a8:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80095aa:	689a      	ldr	r2, [r3, #8]
 80095ac:	438a      	bics	r2, r1
 80095ae:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 80095b0:	2201      	movs	r2, #1
 80095b2:	6819      	ldr	r1, [r3, #0]
 80095b4:	430a      	orrs	r2, r1
 80095b6:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 80095b8:	f7ff ff90 	bl	80094dc <UART_CheckIdleState>
 80095bc:	e7d0      	b.n	8009560 <HAL_UART_Init+0x8>
 80095be:	46c0      	nop			; (mov r8, r8)
 80095c0:	ffffb7ff 	.word	0xffffb7ff

080095c4 <LL_EXTI_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: EXTI registers are initialized
  *          - ERROR: not applicable
  */
uint32_t LL_EXTI_Init(LL_EXTI_InitTypeDef *EXTI_InitStruct)
{
 80095c4:	b510      	push	{r4, lr}
  assert_param(IS_LL_EXTI_LINE_0_31(EXTI_InitStruct->Line_0_31));
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->LineCommand));
  assert_param(IS_LL_EXTI_MODE(EXTI_InitStruct->Mode));

  /* ENABLE LineCommand */
  if (EXTI_InitStruct->LineCommand != DISABLE)
 80095c6:	7902      	ldrb	r2, [r0, #4]
 80095c8:	6803      	ldr	r3, [r0, #0]
 80095ca:	2a00      	cmp	r2, #0
 80095cc:	d03c      	beq.n	8009648 <LL_EXTI_Init+0x84>
  ErrorStatus status = SUCCESS;
 80095ce:	2201      	movs	r2, #1
  {
    assert_param(IS_LL_EXTI_TRIGGER(EXTI_InitStruct->Trigger));

    /* Configure EXTI Lines in range from 0 to 31 */
    if (EXTI_InitStruct->Line_0_31 != LL_EXTI_LINE_NONE)
 80095d0:	2b00      	cmp	r3, #0
 80095d2:	d01f      	beq.n	8009614 <LL_EXTI_Init+0x50>
    {
      switch (EXTI_InitStruct->Mode)
 80095d4:	7941      	ldrb	r1, [r0, #5]
 80095d6:	4291      	cmp	r1, r2
 80095d8:	d01e      	beq.n	8009618 <LL_EXTI_Init+0x54>
 80095da:	2900      	cmp	r1, #0
 80095dc:	d003      	beq.n	80095e6 <LL_EXTI_Init+0x22>
 80095de:	2902      	cmp	r1, #2
 80095e0:	d022      	beq.n	8009628 <LL_EXTI_Init+0x64>
          /* Directly Enable IT & Event on provided Lines */
          LL_EXTI_EnableIT_0_31(EXTI_InitStruct->Line_0_31);
          LL_EXTI_EnableEvent_0_31(EXTI_InitStruct->Line_0_31);
          break;
        default:
          status = ERROR;
 80095e2:	2200      	movs	r2, #0
 80095e4:	e006      	b.n	80095f4 <LL_EXTI_Init+0x30>
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableEvent_0_31(uint32_t ExtiLine)
{
  CLEAR_BIT(EXTI->EMR, ExtiLine);
 80095e6:	491e      	ldr	r1, [pc, #120]	; (8009660 <LL_EXTI_Init+0x9c>)
 80095e8:	684c      	ldr	r4, [r1, #4]
 80095ea:	439c      	bics	r4, r3
 80095ec:	604c      	str	r4, [r1, #4]
  SET_BIT(EXTI->IMR, ExtiLine);
 80095ee:	680c      	ldr	r4, [r1, #0]
 80095f0:	431c      	orrs	r4, r3
 80095f2:	600c      	str	r4, [r1, #0]
          break;
      }
      if (EXTI_InitStruct->Trigger != LL_EXTI_TRIGGER_NONE)
 80095f4:	7981      	ldrb	r1, [r0, #6]
 80095f6:	2900      	cmp	r1, #0
 80095f8:	d00c      	beq.n	8009614 <LL_EXTI_Init+0x50>
      {
        switch (EXTI_InitStruct->Trigger)
 80095fa:	2902      	cmp	r1, #2
 80095fc:	d018      	beq.n	8009630 <LL_EXTI_Init+0x6c>
 80095fe:	2903      	cmp	r1, #3
 8009600:	d01e      	beq.n	8009640 <LL_EXTI_Init+0x7c>
 8009602:	2901      	cmp	r1, #1
 8009604:	d12a      	bne.n	800965c <LL_EXTI_Init+0x98>
  * @note   Please check each device line mapping for EXTI Line availability
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_DisableFallingTrig_0_31(uint32_t ExtiLine)
{
  CLEAR_BIT(EXTI->FTSR, ExtiLine);
 8009606:	4916      	ldr	r1, [pc, #88]	; (8009660 <LL_EXTI_Init+0x9c>)
 8009608:	68c8      	ldr	r0, [r1, #12]
 800960a:	4398      	bics	r0, r3
 800960c:	60c8      	str	r0, [r1, #12]
  SET_BIT(EXTI->RTSR, ExtiLine);
 800960e:	6888      	ldr	r0, [r1, #8]
 8009610:	4303      	orrs	r3, r0
 8009612:	608b      	str	r3, [r1, #8]
    /* De-configure EXTI Lines in range from 0 to 31 */
    LL_EXTI_DisableIT_0_31(EXTI_InitStruct->Line_0_31);
    LL_EXTI_DisableEvent_0_31(EXTI_InitStruct->Line_0_31);
  }
  return status;
}
 8009614:	0010      	movs	r0, r2
 8009616:	bd10      	pop	{r4, pc}
  CLEAR_BIT(EXTI->IMR, ExtiLine);
 8009618:	4911      	ldr	r1, [pc, #68]	; (8009660 <LL_EXTI_Init+0x9c>)
 800961a:	680c      	ldr	r4, [r1, #0]
 800961c:	439c      	bics	r4, r3
  SET_BIT(EXTI->IMR, ExtiLine);
 800961e:	600c      	str	r4, [r1, #0]
  SET_BIT(EXTI->EMR, ExtiLine);
 8009620:	684c      	ldr	r4, [r1, #4]
 8009622:	431c      	orrs	r4, r3
 8009624:	604c      	str	r4, [r1, #4]
 8009626:	e7e5      	b.n	80095f4 <LL_EXTI_Init+0x30>
  SET_BIT(EXTI->IMR, ExtiLine);
 8009628:	490d      	ldr	r1, [pc, #52]	; (8009660 <LL_EXTI_Init+0x9c>)
 800962a:	680c      	ldr	r4, [r1, #0]
 800962c:	431c      	orrs	r4, r3
 800962e:	e7f6      	b.n	800961e <LL_EXTI_Init+0x5a>
  CLEAR_BIT(EXTI->RTSR, ExtiLine);
 8009630:	490b      	ldr	r1, [pc, #44]	; (8009660 <LL_EXTI_Init+0x9c>)
 8009632:	6888      	ldr	r0, [r1, #8]
 8009634:	4398      	bics	r0, r3
  SET_BIT(EXTI->RTSR, ExtiLine);
 8009636:	6088      	str	r0, [r1, #8]
  SET_BIT(EXTI->FTSR, ExtiLine);
 8009638:	68c8      	ldr	r0, [r1, #12]
 800963a:	4303      	orrs	r3, r0
 800963c:	60cb      	str	r3, [r1, #12]
 800963e:	e7e9      	b.n	8009614 <LL_EXTI_Init+0x50>
  SET_BIT(EXTI->RTSR, ExtiLine);
 8009640:	4907      	ldr	r1, [pc, #28]	; (8009660 <LL_EXTI_Init+0x9c>)
 8009642:	6888      	ldr	r0, [r1, #8]
 8009644:	4318      	orrs	r0, r3
 8009646:	e7f6      	b.n	8009636 <LL_EXTI_Init+0x72>
  CLEAR_BIT(EXTI->IMR, ExtiLine);
 8009648:	43db      	mvns	r3, r3
 800964a:	4a05      	ldr	r2, [pc, #20]	; (8009660 <LL_EXTI_Init+0x9c>)
 800964c:	6811      	ldr	r1, [r2, #0]
 800964e:	4019      	ands	r1, r3
 8009650:	6011      	str	r1, [r2, #0]
  CLEAR_BIT(EXTI->EMR, ExtiLine);
 8009652:	6851      	ldr	r1, [r2, #4]
 8009654:	400b      	ands	r3, r1
 8009656:	6053      	str	r3, [r2, #4]
  ErrorStatus status = SUCCESS;
 8009658:	2201      	movs	r2, #1
 800965a:	e7db      	b.n	8009614 <LL_EXTI_Init+0x50>
            status = ERROR;
 800965c:	2200      	movs	r2, #0
 800965e:	e7d9      	b.n	8009614 <LL_EXTI_Init+0x50>
 8009660:	40010400 	.word	0x40010400

08009664 <LL_Init1msTick>:
  * @retval None
  */
__STATIC_INLINE void LL_InitTick(uint32_t HCLKFrequency, uint32_t Ticks)
{
  /* Configure the SysTick to have interrupt in 1ms time base */
  SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
 8009664:	21fa      	movs	r1, #250	; 0xfa
  * @param  HCLKFrequency HCLK frequency in Hz
  * @note   HCLK frequency can be calculated thanks to RCC helper macro or function @ref LL_RCC_GetSystemClocksFreq
  * @retval None
  */
void LL_Init1msTick(uint32_t HCLKFrequency)
{
 8009666:	b510      	push	{r4, lr}
 8009668:	0089      	lsls	r1, r1, #2
 800966a:	f7fc f9ad 	bl	80059c8 <__udivsi3>
  SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
 800966e:	2200      	movs	r2, #0
  SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
 8009670:	4b03      	ldr	r3, [pc, #12]	; (8009680 <LL_Init1msTick+0x1c>)
 8009672:	3801      	subs	r0, #1
 8009674:	6058      	str	r0, [r3, #4]
  SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
 8009676:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8009678:	3205      	adds	r2, #5
 800967a:	601a      	str	r2, [r3, #0]
  /* Use frequency provided in argument */
  LL_InitTick(HCLKFrequency, 1000U);
}
 800967c:	bd10      	pop	{r4, pc}
 800967e:	46c0      	nop			; (mov r8, r8)
 8009680:	e000e010 	.word	0xe000e010

08009684 <LL_SetSystemCoreClock>:
  * @retval None
  */
void LL_SetSystemCoreClock(uint32_t HCLKFrequency)
{
  /* HCLK clock frequency */
  SystemCoreClock = HCLKFrequency;
 8009684:	4b01      	ldr	r3, [pc, #4]	; (800968c <LL_SetSystemCoreClock+0x8>)
 8009686:	6018      	str	r0, [r3, #0]
}
 8009688:	4770      	bx	lr
 800968a:	46c0      	nop			; (mov r8, r8)
 800968c:	20000030 	.word	0x20000030

08009690 <USBPD_PE_TaskWakeUp>:
  * @retval None
  */
static void USBPD_PE_TaskWakeUp(uint8_t PortNum)
{
#ifdef _RTOS
  osMessagePut(PEQueueId[PortNum], 0xFFFF, osWaitForever);
 8009690:	2201      	movs	r2, #1
{
 8009692:	b510      	push	{r4, lr}
  osMessagePut(PEQueueId[PortNum], 0xFFFF, osWaitForever);
 8009694:	4b03      	ldr	r3, [pc, #12]	; (80096a4 <USBPD_PE_TaskWakeUp+0x14>)
 8009696:	0080      	lsls	r0, r0, #2
 8009698:	4252      	negs	r2, r2
 800969a:	4903      	ldr	r1, [pc, #12]	; (80096a8 <USBPD_PE_TaskWakeUp+0x18>)
 800969c:	58c0      	ldr	r0, [r0, r3]
 800969e:	f002 f9c7 	bl	800ba30 <osMessagePut>
#endif
}
 80096a2:	bd10      	pop	{r4, pc}
 80096a4:	20000344 	.word	0x20000344
 80096a8:	0000ffff 	.word	0x0000ffff

080096ac <USBPD_DPM_CADTaskWakeUp>:
  * @retval None
  */
static void USBPD_DPM_CADTaskWakeUp(void)
{
#ifdef _RTOS
  osMessagePut(CADQueueId, 0xFFFF, osWaitForever);
 80096ac:	2201      	movs	r2, #1
{
 80096ae:	b510      	push	{r4, lr}
  osMessagePut(CADQueueId, 0xFFFF, osWaitForever);
 80096b0:	4b03      	ldr	r3, [pc, #12]	; (80096c0 <USBPD_DPM_CADTaskWakeUp+0x14>)
 80096b2:	4252      	negs	r2, r2
 80096b4:	4903      	ldr	r1, [pc, #12]	; (80096c4 <USBPD_DPM_CADTaskWakeUp+0x18>)
 80096b6:	6858      	ldr	r0, [r3, #4]
 80096b8:	f002 f9ba 	bl	800ba30 <osMessagePut>
#endif
}
 80096bc:	bd10      	pop	{r4, pc}
 80096be:	46c0      	nop			; (mov r8, r8)
 80096c0:	20000344 	.word	0x20000344
 80096c4:	0000ffff 	.word	0x0000ffff

080096c8 <USBPD_PE_Task>:
  * @brief  Main task for PE layer
  * @param  argument Not used
  * @retval None
  */
void USBPD_PE_Task(void const *argument)
{
 80096c8:	b530      	push	{r4, r5, lr}
#elif defined(_SRC)
    USBPD_PE_StateMachine_SRC(_port);
#elif defined(_SNK)
    USBPD_PE_StateMachine_SNK(_port);
#endif
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 80096ca:	b2c4      	uxtb	r4, r0
{
 80096cc:	b085      	sub	sp, #20
  uint8_t _port = (uint32_t)argument;
 80096ce:	b2c5      	uxtb	r5, r0
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 80096d0:	00a4      	lsls	r4, r4, #2
    USBPD_PE_StateMachine_SRC(_port);
 80096d2:	0028      	movs	r0, r5
 80096d4:	f7f6 ff1a 	bl	800050c <USBPD_PE_StateMachine_SRC>
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 80096d8:	4b03      	ldr	r3, [pc, #12]	; (80096e8 <USBPD_PE_Task+0x20>)
    USBPD_PE_StateMachine_SRC(_port);
 80096da:	0002      	movs	r2, r0
    osMessageGet(PEQueueId[_port], DPM_Sleep_time[_port]);
 80096dc:	58e1      	ldr	r1, [r4, r3]
 80096de:	4668      	mov	r0, sp
 80096e0:	f002 f9cc 	bl	800ba7c <osMessageGet>
 80096e4:	e7f5      	b.n	80096d2 <USBPD_PE_Task+0xa>
 80096e6:	46c0      	nop			; (mov r8, r8)
 80096e8:	20000344 	.word	0x20000344

080096ec <USBPD_CAD_Task>:
  * @brief  Main task for CAD layer
  * @param  argument Not used
  * @retval None
  */
void USBPD_CAD_Task(void const *argument)
{
 80096ec:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  for(;;)
  {
    DPM_Sleep_time[USBPD_THREAD_CAD] = USBPD_CAD_Process();
 80096ee:	f7f6 fd4d 	bl	800018c <USBPD_CAD_Process>
    osMessageGet(CADQueueId, DPM_Sleep_time[USBPD_THREAD_CAD]);
 80096f2:	4b03      	ldr	r3, [pc, #12]	; (8009700 <USBPD_CAD_Task+0x14>)
    DPM_Sleep_time[USBPD_THREAD_CAD] = USBPD_CAD_Process();
 80096f4:	0002      	movs	r2, r0
    osMessageGet(CADQueueId, DPM_Sleep_time[USBPD_THREAD_CAD]);
 80096f6:	6859      	ldr	r1, [r3, #4]
 80096f8:	4668      	mov	r0, sp
 80096fa:	f002 f9bf 	bl	800ba7c <osMessageGet>
 80096fe:	e7f6      	b.n	80096ee <USBPD_CAD_Task+0x2>
 8009700:	20000344 	.word	0x20000344

08009704 <USBPD_DPM_CADCallback>:
  * @param  State     CAD state
  * @param  Cc        The Communication Channel for the USBPD communication
  * @retval None
  */
void USBPD_DPM_CADCallback(uint8_t PortNum, USBPD_CAD_EVENT State, CCxPin_TypeDef Cc)
{
 8009704:	b570      	push	{r4, r5, r6, lr}
 8009706:	0004      	movs	r4, r0
#ifdef _TRACE
  USBPD_TRACE_Add(USBPD_TRACE_CADEVENT, PortNum, State, NULL, 0);
#endif /* _TRACE */

  switch(State)
 8009708:	1e48      	subs	r0, r1, #1
{
 800970a:	000d      	movs	r5, r1
  switch(State)
 800970c:	2806      	cmp	r0, #6
 800970e:	d827      	bhi.n	8009760 <USBPD_DPM_CADCallback+0x5c>
 8009710:	f7fc f950 	bl	80059b4 <__gnu_thumb1_case_uqi>
 8009714:	04280428 	.word	0x04280428
 8009718:	2626      	.short	0x2626
 800971a:	42          	.byte	0x42
 800971b:	00          	.byte	0x00
  case USBPD_CAD_EVENT_ATTACHED :
#ifdef _VCONN_SUPPORT
    if(CC1 == Cc) DPM_Params[PortNum].VconnCCIs = CC2;
    if(CC2 == Cc) DPM_Params[PortNum].VconnCCIs = CC1;
#endif /* _VCONN_SUPPORT */
    DPM_Params[PortNum].ActiveCCIs = Cc;
 800971c:	2003      	movs	r0, #3
 800971e:	4928      	ldr	r1, [pc, #160]	; (80097c0 <USBPD_DPM_CADCallback+0xbc>)
 8009720:	00e3      	lsls	r3, r4, #3
 8009722:	18c9      	adds	r1, r1, r3
 8009724:	784b      	ldrb	r3, [r1, #1]
 8009726:	4002      	ands	r2, r0
 8009728:	4383      	bics	r3, r0
 800972a:	431a      	orrs	r2, r3
 800972c:	704a      	strb	r2, [r1, #1]
    USBPD_PE_IsCableConnected(PortNum, 1);
 800972e:	0020      	movs	r0, r4
 8009730:	2101      	movs	r1, #1
 8009732:	f7f6 fec2 	bl	80004ba <USBPD_PE_IsCableConnected>

    USBPD_DPM_UserCableDetection(PortNum, State);
 8009736:	0029      	movs	r1, r5
 8009738:	0020      	movs	r0, r4
 800973a:	f7fc fd23 	bl	8006184 <USBPD_DPM_UserCableDetection>
    USBPD_DPM_WaitForTime(6);
#endif /* USBPD_TCPM_MODULE_ENABLED */

#ifdef _RTOS
    /* Create PE task */
    if (DPM_Thread_Table[PortNum] == NULL)
 800973e:	4d21      	ldr	r5, [pc, #132]	; (80097c4 <USBPD_DPM_CADCallback+0xc0>)
 8009740:	00a6      	lsls	r6, r4, #2
 8009742:	19ab      	adds	r3, r5, r6
 8009744:	689b      	ldr	r3, [r3, #8]
 8009746:	2b00      	cmp	r3, #0
 8009748:	d10a      	bne.n	8009760 <USBPD_DPM_CADCallback+0x5c>
 800974a:	481f      	ldr	r0, [pc, #124]	; (80097c8 <USBPD_DPM_CADCallback+0xc4>)
    {
      DPM_Thread_Table[PortNum] = osThreadCreate(OSTHREAD_PE(PortNum), (void *)((uint32_t)PortNum));
 800974c:	2c00      	cmp	r4, #0
 800974e:	d000      	beq.n	8009752 <USBPD_DPM_CADCallback+0x4e>
 8009750:	3014      	adds	r0, #20
 8009752:	0021      	movs	r1, r4
 8009754:	f002 f93f 	bl	800b9d6 <osThreadCreate>
      if (DPM_Thread_Table[PortNum] == NULL)
 8009758:	2800      	cmp	r0, #0
 800975a:	d002      	beq.n	8009762 <USBPD_DPM_CADCallback+0x5e>
      DPM_Thread_Table[PortNum] = osThreadCreate(OSTHREAD_PE(PortNum), (void *)((uint32_t)PortNum));
 800975c:	19ad      	adds	r5, r5, r6
 800975e:	60a8      	str	r0, [r5, #8]
    break;
  default :
    /* nothing to do */
    break;
  }
}
 8009760:	bd70      	pop	{r4, r5, r6, pc}
 8009762:	e7fe      	b.n	8009762 <USBPD_DPM_CADCallback+0x5e>
    USBPD_PE_IsCableConnected(PortNum, 0);
 8009764:	2100      	movs	r1, #0
 8009766:	0020      	movs	r0, r4
 8009768:	f7f6 fea7 	bl	80004ba <USBPD_PE_IsCableConnected>
    if (DPM_Thread_Table[PortNum] != NULL)
 800976c:	4e15      	ldr	r6, [pc, #84]	; (80097c4 <USBPD_DPM_CADCallback+0xc0>)
 800976e:	00a3      	lsls	r3, r4, #2
 8009770:	18f6      	adds	r6, r6, r3
 8009772:	68b0      	ldr	r0, [r6, #8]
 8009774:	2800      	cmp	r0, #0
 8009776:	d003      	beq.n	8009780 <USBPD_DPM_CADCallback+0x7c>
      osThreadTerminate(DPM_Thread_Table[PortNum]);
 8009778:	f002 f946 	bl	800ba08 <osThreadTerminate>
      DPM_Thread_Table[PortNum] = NULL;
 800977c:	2300      	movs	r3, #0
 800977e:	60b3      	str	r3, [r6, #8]
    USBPD_DPM_UserCableDetection(PortNum, State);
 8009780:	0020      	movs	r0, r4
 8009782:	0029      	movs	r1, r5
 8009784:	f7fc fcfe 	bl	8006184 <USBPD_DPM_UserCableDetection>
    DPM_Params[PortNum].PE_Power   = USBPD_POWER_NO;
 8009788:	228c      	movs	r2, #140	; 0x8c
    DPM_Params[PortNum].ActiveCCIs = CCNONE;
 800978a:	4b0d      	ldr	r3, [pc, #52]	; (80097c0 <USBPD_DPM_CADCallback+0xbc>)
 800978c:	00e4      	lsls	r4, r4, #3
 800978e:	191c      	adds	r4, r3, r4
 8009790:	7863      	ldrb	r3, [r4, #1]
    DPM_Params[PortNum].PE_Power   = USBPD_POWER_NO;
 8009792:	4013      	ands	r3, r2
 8009794:	7063      	strb	r3, [r4, #1]
    break;
 8009796:	e7e3      	b.n	8009760 <USBPD_DPM_CADCallback+0x5c>
    DPM_Params[PortNum].ActiveCCIs  = Cc;
 8009798:	4909      	ldr	r1, [pc, #36]	; (80097c0 <USBPD_DPM_CADCallback+0xbc>)
 800979a:	00e3      	lsls	r3, r4, #3
 800979c:	18c9      	adds	r1, r1, r3
 800979e:	2003      	movs	r0, #3
 80097a0:	0013      	movs	r3, r2
 80097a2:	784a      	ldrb	r2, [r1, #1]
 80097a4:	4003      	ands	r3, r0
 80097a6:	4382      	bics	r2, r0
    DPM_Params[PortNum].PE_Power    = USBPD_POWER_DEFAULT5V;
 80097a8:	431a      	orrs	r2, r3
 80097aa:	2370      	movs	r3, #112	; 0x70
 80097ac:	439a      	bics	r2, r3
 80097ae:	3b60      	subs	r3, #96	; 0x60
 80097b0:	431a      	orrs	r2, r3
 80097b2:	704a      	strb	r2, [r1, #1]
    USBPD_DPM_UserCableDetection(PortNum, State);
 80097b4:	0020      	movs	r0, r4
 80097b6:	2107      	movs	r1, #7
 80097b8:	f7fc fce4 	bl	8006184 <USBPD_DPM_UserCableDetection>
}
 80097bc:	e7d0      	b.n	8009760 <USBPD_DPM_CADCallback+0x5c>
 80097be:	46c0      	nop			; (mov r8, r8)
 80097c0:	20001c60 	.word	0x20001c60
 80097c4:	20000344 	.word	0x20000344
 80097c8:	0800cd54 	.word	0x0800cd54

080097cc <USBPD_DPM_Init>:
{
 80097cc:	b5f0      	push	{r4, r5, r6, r7, lr}
  if( USBPD_TRUE != USBPD_PE_CheckLIB(_LIB_ID))
 80097ce:	482e      	ldr	r0, [pc, #184]	; (8009888 <USBPD_DPM_Init+0xbc>)
{
 80097d0:	b089      	sub	sp, #36	; 0x24
  if( USBPD_TRUE != USBPD_PE_CheckLIB(_LIB_ID))
 80097d2:	f7f6 fde1 	bl	8000398 <USBPD_PE_CheckLIB>
 80097d6:	9001      	str	r0, [sp, #4]
 80097d8:	2801      	cmp	r0, #1
 80097da:	d003      	beq.n	80097e4 <USBPD_DPM_Init+0x18>
    return USBPD_ERROR;
 80097dc:	2602      	movs	r6, #2
}
 80097de:	0030      	movs	r0, r6
 80097e0:	b009      	add	sp, #36	; 0x24
 80097e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  stack_dynamemsize = USBPD_PE_GetMemoryConsumption();
 80097e4:	f7f6 fddf 	bl	80003a6 <USBPD_PE_GetMemoryConsumption>
  DPM_Params[USBPD_PORT_0].PE_SpecRevision  = DPM_Settings[USBPD_PORT_0].PE_SpecRevision;
 80097e8:	2203      	movs	r2, #3
  DPM_Params[USBPD_PORT_0].PE_PowerRole     = DPM_Settings[USBPD_PORT_0].PE_DefaultRole;
 80097ea:	2302      	movs	r3, #2
  DPM_Params[USBPD_PORT_0].DPM_Initialized = USBPD_FALSE;
 80097ec:	4c27      	ldr	r4, [pc, #156]	; (800988c <USBPD_DPM_Init+0xc0>)
 80097ee:	2504      	movs	r5, #4
  DPM_Params[USBPD_PORT_0].PE_SpecRevision  = DPM_Settings[USBPD_PORT_0].PE_SpecRevision;
 80097f0:	7820      	ldrb	r0, [r4, #0]
  DPM_Params[USBPD_PORT_0].DPM_Initialized = USBPD_FALSE;
 80097f2:	7861      	ldrb	r1, [r4, #1]
  DPM_Params[USBPD_PORT_0].PE_SpecRevision  = DPM_Settings[USBPD_PORT_0].PE_SpecRevision;
 80097f4:	4390      	bics	r0, r2
  DPM_Params[USBPD_PORT_0].PE_PowerRole     = DPM_Settings[USBPD_PORT_0].PE_DefaultRole;
 80097f6:	4303      	orrs	r3, r0
  DPM_Params[USBPD_PORT_0].PE_SwapOngoing   = 0;
 80097f8:	2010      	movs	r0, #16
 80097fa:	432b      	orrs	r3, r5
 80097fc:	4383      	bics	r3, r0
 80097fe:	7023      	strb	r3, [r4, #0]
  DPM_Params[USBPD_PORT_0].ActiveCCIs       = CCNONE;
 8009800:	000b      	movs	r3, r1
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 8009802:	4e23      	ldr	r6, [pc, #140]	; (8009890 <USBPD_DPM_Init+0xc4>)
  DPM_Params[USBPD_PORT_0].ActiveCCIs       = CCNONE;
 8009804:	43ab      	bics	r3, r5
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 8009806:	0037      	movs	r7, r6
 8009808:	0031      	movs	r1, r6
  DPM_Params[USBPD_PORT_0].ActiveCCIs       = CCNONE;
 800980a:	4393      	bics	r3, r2
 800980c:	7063      	strb	r3, [r4, #1]
  DPM_Params[USBPD_PORT_0].VconnCCIs        = CCNONE;
 800980e:	78a3      	ldrb	r3, [r4, #2]
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 8009810:	3728      	adds	r7, #40	; 0x28
  DPM_Params[USBPD_PORT_0].VconnStatus      = USBPD_FALSE;
 8009812:	4393      	bics	r3, r2
 8009814:	43ab      	bics	r3, r5
 8009816:	70a3      	strb	r3, [r4, #2]
  CHECK_CAD_FUNCTION_CALL(USBPD_CAD_Init(USBPD_PORT_0, (USBPD_CAD_Callbacks*)&CAD_cbs, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0]));
 8009818:	3134      	adds	r1, #52	; 0x34
 800981a:	0023      	movs	r3, r4
 800981c:	003a      	movs	r2, r7
 800981e:	2000      	movs	r0, #0
 8009820:	f7f6 fc72 	bl	8000108 <USBPD_CAD_Init>
 8009824:	2800      	cmp	r0, #0
 8009826:	d1d9      	bne.n	80097dc <USBPD_DPM_Init+0x10>
  CHECK_PE_FUNCTION_CALL(USBPD_PE_Init(USBPD_PORT_0, (USBPD_SettingsTypeDef *)&DPM_Settings[USBPD_PORT_0], &DPM_Params[USBPD_PORT_0], &dpmCallbacks));
 8009828:	0033      	movs	r3, r6
 800982a:	0022      	movs	r2, r4
 800982c:	333c      	adds	r3, #60	; 0x3c
 800982e:	0039      	movs	r1, r7
 8009830:	f7f6 fd1a 	bl	8000268 <USBPD_PE_Init>
 8009834:	1e06      	subs	r6, r0, #0
 8009836:	d1d1      	bne.n	80097dc <USBPD_DPM_Init+0x10>
  DPM_Params[USBPD_PORT_0].DPM_Initialized = USBPD_TRUE;
 8009838:	7863      	ldrb	r3, [r4, #1]
 800983a:	431d      	orrs	r5, r3
 800983c:	7065      	strb	r5, [r4, #1]
  USBPD_DPM_UserInit();
 800983e:	f7fc fc57 	bl	80060f0 <USBPD_DPM_UserInit>
  USBPD_CAD_PortEnable(USBPD_PORT_0, USBPD_CAD_ENABLE);
 8009842:	9901      	ldr	r1, [sp, #4]
 8009844:	0030      	movs	r0, r6
 8009846:	f7f6 fc99 	bl	800017c <USBPD_CAD_PortEnable>
  osThreadDef(CAD, USBPD_CAD_Task, osPriorityNormal, 0, 150);
 800984a:	4c12      	ldr	r4, [pc, #72]	; (8009894 <USBPD_DPM_Init+0xc8>)
 800984c:	a803      	add	r0, sp, #12
 800984e:	0003      	movs	r3, r0
 8009850:	0022      	movs	r2, r4
 8009852:	caa2      	ldmia	r2!, {r1, r5, r7}
 8009854:	c3a2      	stmia	r3!, {r1, r5, r7}
 8009856:	ca22      	ldmia	r2!, {r1, r5}
 8009858:	c322      	stmia	r3!, {r1, r5}
  if((DPM_Thread_Table[USBPD_THREAD_CAD] = osThreadCreate(osThread(CAD), NULL)) == NULL)
 800985a:	0031      	movs	r1, r6
 800985c:	f002 f8bb 	bl	800b9d6 <osThreadCreate>
 8009860:	4d0d      	ldr	r5, [pc, #52]	; (8009898 <USBPD_DPM_Init+0xcc>)
 8009862:	60e8      	str	r0, [r5, #12]
 8009864:	2800      	cmp	r0, #0
 8009866:	d0b9      	beq.n	80097dc <USBPD_DPM_Init+0x10>
  CADQueueId = osMessageCreate(osMessageQ(queueCAD), NULL);
 8009868:	0020      	movs	r0, r4
 800986a:	0031      	movs	r1, r6
 800986c:	3014      	adds	r0, #20
 800986e:	f002 f8d8 	bl	800ba22 <osMessageCreate>
 8009872:	6068      	str	r0, [r5, #4]
  PEQueueId[0] = osMessageCreate(osMessageQ(queuePE), NULL);
 8009874:	0020      	movs	r0, r4
 8009876:	0031      	movs	r1, r6
 8009878:	301c      	adds	r0, #28
 800987a:	f002 f8d2 	bl	800ba22 <osMessageCreate>
  DPM_Thread_Table[USBPD_THREAD_PORT_0] = NULL;
 800987e:	60ae      	str	r6, [r5, #8]
  PEQueueId[0] = osMessageCreate(osMessageQ(queuePE), NULL);
 8009880:	6028      	str	r0, [r5, #0]
  osKernelStart();
 8009882:	f002 f8a3 	bl	800b9cc <osKernelStart>
  return USBPD_OK;
 8009886:	e7aa      	b.n	80097de <USBPD_DPM_Init+0x12>
 8009888:	30210001 	.word	0x30210001
 800988c:	20001c60 	.word	0x20001c60
 8009890:	0800cd54 	.word	0x0800cd54
 8009894:	0800cdd4 	.word	0x0800cdd4
 8009898:	20000344 	.word	0x20000344

0800989c <USBPD_DPM_TimerCounter>:
  if (USBPD_TRUE == DPM_Params[USBPD_PORT_0].DPM_Initialized)
 800989c:	4b0a      	ldr	r3, [pc, #40]	; (80098c8 <USBPD_DPM_TimerCounter+0x2c>)
{
 800989e:	b510      	push	{r4, lr}
  if (USBPD_TRUE == DPM_Params[USBPD_PORT_0].DPM_Initialized)
 80098a0:	785b      	ldrb	r3, [r3, #1]
 80098a2:	075b      	lsls	r3, r3, #29
 80098a4:	d508      	bpl.n	80098b8 <USBPD_DPM_TimerCounter+0x1c>
    USBPD_DPM_UserTimerCounter(USBPD_PORT_0);
 80098a6:	2000      	movs	r0, #0
 80098a8:	f7fc fc5c 	bl	8006164 <USBPD_DPM_UserTimerCounter>
    USBPD_PE_TimerCounter(USBPD_PORT_0);
 80098ac:	2000      	movs	r0, #0
 80098ae:	f7f6 fd85 	bl	80003bc <USBPD_PE_TimerCounter>
    USBPD_PRL_TimerCounter(USBPD_PORT_0);
 80098b2:	2000      	movs	r0, #0
 80098b4:	f7fb fab2 	bl	8004e1c <USBPD_PRL_TimerCounter>
  if (uxTaskGetNumberOfTasks() != 0)
 80098b8:	f002 fd1e 	bl	800c2f8 <uxTaskGetNumberOfTasks>
 80098bc:	2800      	cmp	r0, #0
 80098be:	d001      	beq.n	80098c4 <USBPD_DPM_TimerCounter+0x28>
    osSystickHandler();
 80098c0:	f002 f916 	bl	800baf0 <osSystickHandler>
}
 80098c4:	bd10      	pop	{r4, pc}
 80098c6:	46c0      	nop			; (mov r8, r8)
 80098c8:	20001c60 	.word	0x20001c60

080098cc <CAD_Init>:
void CAD_Init(uint8_t PortNum, USBPD_SettingsTypeDef *Settings, USBPD_ParamsTypeDef *Params,  void (*WakeUp)(void))
{
  CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
  
  /* store the settings and parameters */
  _handle->params = Params;
 80098cc:	2318      	movs	r3, #24
 80098ce:	4343      	muls	r3, r0
{
 80098d0:	b570      	push	{r4, r5, r6, lr}
  _handle->params = Params;
 80098d2:	4d0e      	ldr	r5, [pc, #56]	; (800990c <CAD_Init+0x40>)
{
 80098d4:	0004      	movs	r4, r0
  _handle->settings = Settings;
 80098d6:	5159      	str	r1, [r3, r5]
  _handle->params = Params;
 80098d8:	18e8      	adds	r0, r5, r3
  _handle->state = USBPD_CAD_STATE_RESET;
  _handle->cc = CCNONE;
 80098da:	25c0      	movs	r5, #192	; 0xc0
  _handle->state = USBPD_CAD_STATE_RESET;
 80098dc:	7c01      	ldrb	r1, [r0, #16]
  _handle->params = Params;
 80098de:	6042      	str	r2, [r0, #4]
  _handle->cc = CCNONE;
 80098e0:	4029      	ands	r1, r5
 80098e2:	7401      	strb	r1, [r0, #16]
  _handle->CurrentHWcondition = _handle->OldHWCondtion = HW_Detachment;
 80098e4:	490a      	ldr	r1, [pc, #40]	; (8009910 <CAD_Init+0x44>)
  _handle->SNK_Source_Current_Adv = vRd_Undefined;
  
  if(_handle->params->PE_PowerRole == USBPD_PORTPOWERROLE_SRC)
  {
    USBPDM1_DeAssertRd(PortNum);
 80098e6:	0020      	movs	r0, r4
  _handle->CurrentHWcondition = _handle->OldHWCondtion = HW_Detachment;
 80098e8:	185b      	adds	r3, r3, r1
 80098ea:	2100      	movs	r1, #0
 80098ec:	7059      	strb	r1, [r3, #1]
  if(_handle->params->PE_PowerRole == USBPD_PORTPOWERROLE_SRC)
 80098ee:	7813      	ldrb	r3, [r2, #0]
 80098f0:	075b      	lsls	r3, r3, #29
 80098f2:	d505      	bpl.n	8009900 <CAD_Init+0x34>
    USBPDM1_DeAssertRd(PortNum);
 80098f4:	f001 f85d 	bl	800a9b2 <USBPDM1_DeAssertRd>
    USBPDM1_AssertRp(PortNum);
 80098f8:	0020      	movs	r0, r4
 80098fa:	f001 f857 	bl	800a9ac <USBPDM1_AssertRp>
  else
  {
    USBPDM1_DeAssertRp(PortNum);
    USBPDM1_AssertRd(PortNum);
  }
}
 80098fe:	bd70      	pop	{r4, r5, r6, pc}
    USBPDM1_DeAssertRp(PortNum);
 8009900:	f001 f855 	bl	800a9ae <USBPDM1_DeAssertRp>
    USBPDM1_AssertRd(PortNum);
 8009904:	0020      	movs	r0, r4
 8009906:	f001 f853 	bl	800a9b0 <USBPDM1_AssertRd>
}
 800990a:	e7f8      	b.n	80098fe <CAD_Init+0x32>
 800990c:	20001c68 	.word	0x20001c68
 8009910:	20001c78 	.word	0x20001c78

08009914 <CAD_Enter_ErrorRecovery>:
  * @brief  CAD enters in error recovery mode 
  * @param  PortNum  Number of the port
  * @retval None
  */ 
void CAD_Enter_ErrorRecovery(uint8_t PortNum)
{
 8009914:	b510      	push	{r4, lr}
  /* remove resistor terminaison 
     switch CAD_StateMachine to Error Recovery state
     wakeup CAD task */
  USBPD_HW_IF_ErrorRecovery(PortNum);
 8009916:	f001 f8d3 	bl	800aac0 <USBPD_HW_IF_ErrorRecovery>
}
 800991a:	bd10      	pop	{r4, pc}

0800991c <USBPD_HW_IF_EXTI_Callback>:
  * @arg     ALERT_GPIO_PIN(1)    ** Defined in usbpd_porthandle.h **
  * @arg     SPI_NSS_PIN(1)       ** Defined in usbpd_porthandle.h **
  * @retval None
  */
void USBPD_HW_IF_EXTI_Callback(uint16_t GPIO_Pin)
{
 800991c:	b570      	push	{r4, r5, r6, lr}
 800991e:	0001      	movs	r1, r0
  uint8_t PortNum=0;
  GPIO_PinState NSSCurrentState;
  switch (GPIO_Pin)
 8009920:	2802      	cmp	r0, #2
 8009922:	d005      	beq.n	8009930 <USBPD_HW_IF_EXTI_Callback+0x14>
 8009924:	2380      	movs	r3, #128	; 0x80
 8009926:	015b      	lsls	r3, r3, #5
 8009928:	4298      	cmp	r0, r3
 800992a:	d005      	beq.n	8009938 <USBPD_HW_IF_EXTI_Callback+0x1c>
 800992c:	46c0      	nop			; (mov r8, r8)
    
  default:
    __NOP();
    break;
  }
}
 800992e:	e002      	b.n	8009936 <USBPD_HW_IF_EXTI_Callback+0x1a>
    STUSB16xx_HW_IF_Alert_Check(ALERT_PORT_INDEX(0));
 8009930:	2000      	movs	r0, #0
 8009932:	f001 fd81 	bl	800b438 <STUSB16xx_HW_IF_Alert_Check>
}
 8009936:	bd70      	pop	{r4, r5, r6, pc}
    NSSCurrentState = HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum));
 8009938:	4809      	ldr	r0, [pc, #36]	; (8009960 <USBPD_HW_IF_EXTI_Callback+0x44>)
 800993a:	f7fe f8f9 	bl	8007b30 <HAL_GPIO_ReadPin>
 800993e:	4d09      	ldr	r5, [pc, #36]	; (8009964 <USBPD_HW_IF_EXTI_Callback+0x48>)
 8009940:	0004      	movs	r4, r0
    if( NSSCurrentState == GPIO_PIN_SET || RxNSSStatus[PortNum] == GPIO_PIN_RESET) 
 8009942:	2801      	cmp	r0, #1
 8009944:	d002      	beq.n	800994c <USBPD_HW_IF_EXTI_Callback+0x30>
 8009946:	782b      	ldrb	r3, [r5, #0]
 8009948:	2b00      	cmp	r3, #0
 800994a:	d102      	bne.n	8009952 <USBPD_HW_IF_EXTI_Callback+0x36>
      PHY_HW_IF_RX_Stop(PortNum);
 800994c:	2000      	movs	r0, #0
 800994e:	f000 fc0f 	bl	800a170 <PHY_HW_IF_RX_Stop>
    if( NSSCurrentState == GPIO_PIN_RESET )
 8009952:	2c00      	cmp	r4, #0
 8009954:	d102      	bne.n	800995c <USBPD_HW_IF_EXTI_Callback+0x40>
      PHY_HW_IF_RX_Start(PortNum);
 8009956:	0020      	movs	r0, r4
 8009958:	f000 fec8 	bl	800a6ec <PHY_HW_IF_RX_Start>
    RxNSSStatus[PortNum] = NSSCurrentState;
 800995c:	702c      	strb	r4, [r5, #0]
    break;    
 800995e:	e7ea      	b.n	8009936 <USBPD_HW_IF_EXTI_Callback+0x1a>
 8009960:	48000400 	.word	0x48000400
 8009964:	20000034 	.word	0x20000034

08009968 <USBPD_DMA_PORT0_IRQHandler>:
/**
  * @brief   This function handles DMA interrupts on channels 4, 5, 6 and 7
  * @retval  None
  */
void USBPD_DMA_PORT0_IRQHandler(void)
{
 8009968:	b570      	push	{r4, r5, r6, lr}
  uint8_t *end;
  
  /* Handler DMA TX PORT 0  */
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmatx)) != RESET)
 800996a:	4d39      	ldr	r5, [pc, #228]	; (8009a50 <USBPD_DMA_PORT0_IRQHandler+0xe8>)
 800996c:	4c39      	ldr	r4, [pc, #228]	; (8009a54 <USBPD_DMA_PORT0_IRQHandler+0xec>)
 800996e:	002b      	movs	r3, r5
 8009970:	33a4      	adds	r3, #164	; 0xa4
 8009972:	681a      	ldr	r2, [r3, #0]
 8009974:	4838      	ldr	r0, [pc, #224]	; (8009a58 <USBPD_DMA_PORT0_IRQHandler+0xf0>)
 8009976:	6821      	ldr	r1, [r4, #0]
 8009978:	2302      	movs	r3, #2
 800997a:	4282      	cmp	r2, r0
 800997c:	d016      	beq.n	80099ac <USBPD_DMA_PORT0_IRQHandler+0x44>
 800997e:	4e37      	ldr	r6, [pc, #220]	; (8009a5c <USBPD_DMA_PORT0_IRQHandler+0xf4>)
 8009980:	331e      	adds	r3, #30
 8009982:	42b2      	cmp	r2, r6
 8009984:	d012      	beq.n	80099ac <USBPD_DMA_PORT0_IRQHandler+0x44>
 8009986:	4b36      	ldr	r3, [pc, #216]	; (8009a60 <USBPD_DMA_PORT0_IRQHandler+0xf8>)
 8009988:	429a      	cmp	r2, r3
 800998a:	d01a      	beq.n	80099c2 <USBPD_DMA_PORT0_IRQHandler+0x5a>
 800998c:	4b35      	ldr	r3, [pc, #212]	; (8009a64 <USBPD_DMA_PORT0_IRQHandler+0xfc>)
 800998e:	429a      	cmp	r2, r3
 8009990:	d01a      	beq.n	80099c8 <USBPD_DMA_PORT0_IRQHandler+0x60>
 8009992:	4b35      	ldr	r3, [pc, #212]	; (8009a68 <USBPD_DMA_PORT0_IRQHandler+0x100>)
 8009994:	429a      	cmp	r2, r3
 8009996:	d01a      	beq.n	80099ce <USBPD_DMA_PORT0_IRQHandler+0x66>
 8009998:	4b34      	ldr	r3, [pc, #208]	; (8009a6c <USBPD_DMA_PORT0_IRQHandler+0x104>)
 800999a:	18d2      	adds	r2, r2, r3
 800999c:	4253      	negs	r3, r2
 800999e:	4153      	adcs	r3, r2
 80099a0:	4a33      	ldr	r2, [pc, #204]	; (8009a70 <USBPD_DMA_PORT0_IRQHandler+0x108>)
 80099a2:	425b      	negs	r3, r3
 80099a4:	4013      	ands	r3, r2
 80099a6:	2280      	movs	r2, #128	; 0x80
 80099a8:	0492      	lsls	r2, r2, #18
 80099aa:	189b      	adds	r3, r3, r2
 80099ac:	420b      	tst	r3, r1
 80099ae:	d025      	beq.n	80099fc <USBPD_DMA_PORT0_IRQHandler+0x94>
  {
    /* Transfer complete interrupt is used to end the transmission */
    if (Ports[0].State!=HAL_USBPD_PORT_STATE_BIST)
 80099b0:	7e6b      	ldrb	r3, [r5, #25]
 80099b2:	2b08      	cmp	r3, #8
 80099b4:	d00e      	beq.n	80099d4 <USBPD_DMA_PORT0_IRQHandler+0x6c>
    {
      PHY_HW_IF_TX_Done(0);
 80099b6:	2000      	movs	r0, #0
 80099b8:	f000 fd4e 	bl	800a458 <PHY_HW_IF_TX_Done>
  else if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmarx)) != RESET)
  {
    __NOP();
  }
  
  __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 80099bc:	4b2d      	ldr	r3, [pc, #180]	; (8009a74 <USBPD_DMA_PORT0_IRQHandler+0x10c>)
 80099be:	6063      	str	r3, [r4, #4]
}
 80099c0:	bd70      	pop	{r4, r5, r6, pc}
  if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmatx)) != RESET)
 80099c2:	2380      	movs	r3, #128	; 0x80
 80099c4:	009b      	lsls	r3, r3, #2
 80099c6:	e7f1      	b.n	80099ac <USBPD_DMA_PORT0_IRQHandler+0x44>
 80099c8:	2380      	movs	r3, #128	; 0x80
 80099ca:	019b      	lsls	r3, r3, #6
 80099cc:	e7ee      	b.n	80099ac <USBPD_DMA_PORT0_IRQHandler+0x44>
 80099ce:	2380      	movs	r3, #128	; 0x80
 80099d0:	029b      	lsls	r3, r3, #10
 80099d2:	e7eb      	b.n	80099ac <USBPD_DMA_PORT0_IRQHandler+0x44>
      Ports[0].BIST_index+=1;
 80099d4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80099d6:	3301      	adds	r3, #1
 80099d8:	626b      	str	r3, [r5, #36]	; 0x24
      if(Ports[0].BIST_index == BIST_MAX_LENGTH) 
 80099da:	2b1e      	cmp	r3, #30
 80099dc:	d105      	bne.n	80099ea <USBPD_DMA_PORT0_IRQHandler+0x82>
        end[(TX_BUFFER_LEN)*2 - 1] = 0;
 80099de:	2000      	movs	r0, #0
 80099e0:	686b      	ldr	r3, [r5, #4]
 80099e2:	3337      	adds	r3, #55	; 0x37
 80099e4:	7018      	strb	r0, [r3, #0]
        STUSB16xx_HW_IF_Set_DMA_Normal_Mode(0); 
 80099e6:	f001 fc51 	bl	800b28c <STUSB16xx_HW_IF_Set_DMA_Normal_Mode>
      if(Ports[0].BIST_index > BIST_MAX_LENGTH) 
 80099ea:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80099ec:	2b1e      	cmp	r3, #30
 80099ee:	d9e5      	bls.n	80099bc <USBPD_DMA_PORT0_IRQHandler+0x54>
        PHY_HW_IF_TX_Done(0);
 80099f0:	2000      	movs	r0, #0
 80099f2:	f000 fd31 	bl	800a458 <PHY_HW_IF_TX_Done>
        Ports[0].BIST_index=0;
 80099f6:	2300      	movs	r3, #0
 80099f8:	626b      	str	r3, [r5, #36]	; 0x24
 80099fa:	e7df      	b.n	80099bc <USBPD_DMA_PORT0_IRQHandler+0x54>
  else if(__HAL_DMA_GET_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(&Ports[0].hdmarx)) != RESET)
 80099fc:	35e8      	adds	r5, #232	; 0xe8
 80099fe:	682a      	ldr	r2, [r5, #0]
 8009a00:	6821      	ldr	r1, [r4, #0]
 8009a02:	2302      	movs	r3, #2
 8009a04:	4282      	cmp	r2, r0
 8009a06:	d016      	beq.n	8009a36 <USBPD_DMA_PORT0_IRQHandler+0xce>
 8009a08:	4814      	ldr	r0, [pc, #80]	; (8009a5c <USBPD_DMA_PORT0_IRQHandler+0xf4>)
 8009a0a:	331e      	adds	r3, #30
 8009a0c:	4282      	cmp	r2, r0
 8009a0e:	d012      	beq.n	8009a36 <USBPD_DMA_PORT0_IRQHandler+0xce>
 8009a10:	4b13      	ldr	r3, [pc, #76]	; (8009a60 <USBPD_DMA_PORT0_IRQHandler+0xf8>)
 8009a12:	429a      	cmp	r2, r3
 8009a14:	d013      	beq.n	8009a3e <USBPD_DMA_PORT0_IRQHandler+0xd6>
 8009a16:	4b13      	ldr	r3, [pc, #76]	; (8009a64 <USBPD_DMA_PORT0_IRQHandler+0xfc>)
 8009a18:	429a      	cmp	r2, r3
 8009a1a:	d013      	beq.n	8009a44 <USBPD_DMA_PORT0_IRQHandler+0xdc>
 8009a1c:	4b12      	ldr	r3, [pc, #72]	; (8009a68 <USBPD_DMA_PORT0_IRQHandler+0x100>)
 8009a1e:	429a      	cmp	r2, r3
 8009a20:	d013      	beq.n	8009a4a <USBPD_DMA_PORT0_IRQHandler+0xe2>
 8009a22:	4b12      	ldr	r3, [pc, #72]	; (8009a6c <USBPD_DMA_PORT0_IRQHandler+0x104>)
 8009a24:	18d2      	adds	r2, r2, r3
 8009a26:	4253      	negs	r3, r2
 8009a28:	4153      	adcs	r3, r2
 8009a2a:	4a11      	ldr	r2, [pc, #68]	; (8009a70 <USBPD_DMA_PORT0_IRQHandler+0x108>)
 8009a2c:	425b      	negs	r3, r3
 8009a2e:	4013      	ands	r3, r2
 8009a30:	2280      	movs	r2, #128	; 0x80
 8009a32:	0492      	lsls	r2, r2, #18
 8009a34:	189b      	adds	r3, r3, r2
 8009a36:	420b      	tst	r3, r1
 8009a38:	d0c0      	beq.n	80099bc <USBPD_DMA_PORT0_IRQHandler+0x54>
 8009a3a:	46c0      	nop			; (mov r8, r8)
 8009a3c:	e7be      	b.n	80099bc <USBPD_DMA_PORT0_IRQHandler+0x54>
 8009a3e:	2380      	movs	r3, #128	; 0x80
 8009a40:	009b      	lsls	r3, r3, #2
 8009a42:	e7f8      	b.n	8009a36 <USBPD_DMA_PORT0_IRQHandler+0xce>
 8009a44:	2380      	movs	r3, #128	; 0x80
 8009a46:	019b      	lsls	r3, r3, #6
 8009a48:	e7f5      	b.n	8009a36 <USBPD_DMA_PORT0_IRQHandler+0xce>
 8009a4a:	2380      	movs	r3, #128	; 0x80
 8009a4c:	029b      	lsls	r3, r3, #10
 8009a4e:	e7f2      	b.n	8009a36 <USBPD_DMA_PORT0_IRQHandler+0xce>
 8009a50:	20000058 	.word	0x20000058
 8009a54:	40020000 	.word	0x40020000
 8009a58:	40020008 	.word	0x40020008
 8009a5c:	4002001c 	.word	0x4002001c
 8009a60:	40020030 	.word	0x40020030
 8009a64:	40020044 	.word	0x40020044
 8009a68:	40020058 	.word	0x40020058
 8009a6c:	bffdff94 	.word	0xbffdff94
 8009a70:	fe200000 	.word	0xfe200000
 8009a74:	0fffffff 	.word	0x0fffffff

08009a78 <USBPD_RX_PORT0_COUNTTIM_IRQHandler>:
  * @brief   This function handles interrupts of RX timer associated to port 0
  * @details This timer is used to trigger the data decoding procedure on port 0
  * @retval  None
  */
void USBPD_RX_PORT0_COUNTTIM_IRQHandler(void)
{
 8009a78:	b570      	push	{r4, r5, r6, lr}
  * @retval None
  */
static inline void SINGLE_TIM_IRQHandler(TIM_HandleTypeDef *htim, uint32_t Flag, uint32_t Timit)
{
  /* Capture compare event */
  if(__HAL_TIM_GET_FLAG(htim, Flag) != RESET)
 8009a7a:	4c0b      	ldr	r4, [pc, #44]	; (8009aa8 <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x30>)
 8009a7c:	2202      	movs	r2, #2
 8009a7e:	0023      	movs	r3, r4
 8009a80:	33fc      	adds	r3, #252	; 0xfc
 8009a82:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009a84:	6919      	ldr	r1, [r3, #16]
 8009a86:	4211      	tst	r1, r2
 8009a88:	d00d      	beq.n	8009aa6 <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x2e>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, Timit) != RESET)
 8009a8a:	68d9      	ldr	r1, [r3, #12]
 8009a8c:	4211      	tst	r1, r2
 8009a8e:	d00a      	beq.n	8009aa6 <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x2e>
    {
        __HAL_TIM_CLEAR_IT(htim, Timit);
 8009a90:	3a05      	subs	r2, #5
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8009a92:	25ca      	movs	r5, #202	; 0xca
        __HAL_TIM_CLEAR_IT(htim, Timit);
 8009a94:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8009a96:	2301      	movs	r3, #1
 8009a98:	006d      	lsls	r5, r5, #1
 8009a9a:	5563      	strb	r3, [r4, r5]
        /* Output compare event */
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8009a9c:	4803      	ldr	r0, [pc, #12]	; (8009aac <USBPD_RX_PORT0_COUNTTIM_IRQHandler+0x34>)
 8009a9e:	f000 fc0b 	bl	800a2b8 <HAL_TIM_OC_DelayElapsedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8009aa2:	2300      	movs	r3, #0
 8009aa4:	5563      	strb	r3, [r4, r5]
}
 8009aa6:	bd70      	pop	{r4, r5, r6, pc}
 8009aa8:	20000058 	.word	0x20000058
 8009aac:	200001d0 	.word	0x200001d0

08009ab0 <PHY_BistCompleted>:
 * @param  bistmode  Modality of the BIST
 * @retval none.
 */
void PHY_BistCompleted(uint8_t PortNum, USBPD_BISTMsg_TypeDef bistmode)
{
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_BistCompleted)
 8009ab0:	237c      	movs	r3, #124	; 0x7c
 8009ab2:	4343      	muls	r3, r0
 8009ab4:	4a03      	ldr	r2, [pc, #12]	; (8009ac4 <PHY_BistCompleted+0x14>)
{
 8009ab6:	b510      	push	{r4, lr}
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_BistCompleted)
 8009ab8:	589b      	ldr	r3, [r3, r2]
 8009aba:	691b      	ldr	r3, [r3, #16]
 8009abc:	2b00      	cmp	r3, #0
 8009abe:	d000      	beq.n	8009ac2 <PHY_BistCompleted+0x12>
  {
    PHY_Ports[PortNum].cbs->USBPD_PHY_BistCompleted(PortNum,bistmode);
 8009ac0:	4798      	blx	r3
  }
}
 8009ac2:	bd10      	pop	{r4, pc}
 8009ac4:	20000354 	.word	0x20000354

08009ac8 <PHY_TxCompleted>:
 * @param  PortNum  Number of the port.
 * @retval none.
 */
void PHY_TxCompleted(uint8_t PortNum)
{
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009ac8:	237c      	movs	r3, #124	; 0x7c
{
 8009aca:	b510      	push	{r4, lr}
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009acc:	2400      	movs	r4, #0
 8009ace:	4343      	muls	r3, r0
 8009ad0:	4a04      	ldr	r2, [pc, #16]	; (8009ae4 <PHY_TxCompleted+0x1c>)
 8009ad2:	18d1      	adds	r1, r2, r3
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_TxCompleted)
 8009ad4:	589b      	ldr	r3, [r3, r2]
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009ad6:	720c      	strb	r4, [r1, #8]
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_TxCompleted)
 8009ad8:	695b      	ldr	r3, [r3, #20]
 8009ada:	42a3      	cmp	r3, r4
 8009adc:	d000      	beq.n	8009ae0 <PHY_TxCompleted+0x18>
  {
    PHY_Ports[PortNum].cbs->USBPD_PHY_TxCompleted(PortNum);
 8009ade:	4798      	blx	r3
  }
}
 8009ae0:	bd10      	pop	{r4, pc}
 8009ae2:	46c0      	nop			; (mov r8, r8)
 8009ae4:	20000354 	.word	0x20000354

08009ae8 <PHY_Rx_Reset>:
{
  /* Get the pointer to the decoding structure */
  PHY_RxDecodingTypeDef *pRxData = (PHY_RxDecodingTypeDef *)&PHY_Ports[PortNum].RxDec;

  /* reset the status of the RX process */
  pRxData->Status = USBPD_PHY_RX_STATUS_NONE;
 8009ae8:	237c      	movs	r3, #124	; 0x7c
 8009aea:	4358      	muls	r0, r3
 8009aec:	4a0a      	ldr	r2, [pc, #40]	; (8009b18 <PHY_Rx_Reset+0x30>)
{
 8009aee:	b570      	push	{r4, r5, r6, lr}
  pRxData->Status = USBPD_PHY_RX_STATUS_NONE;
 8009af0:	1814      	adds	r4, r2, r0
 8009af2:	0026      	movs	r6, r4
 8009af4:	2500      	movs	r5, #0
 8009af6:	3640      	adds	r6, #64	; 0x40

  /* reset the variable of count and memory */
  pRxData->DataCount = 0;
  memset(pRxData->Data, 0, __RX_DATA_LEN);
 8009af8:	3049      	adds	r0, #73	; 0x49
  pRxData->Status = USBPD_PHY_RX_STATUS_NONE;
 8009afa:	7035      	strb	r5, [r6, #0]
  pRxData->DataCount = 0;
 8009afc:	6765      	str	r5, [r4, #116]	; 0x74
  memset(pRxData->Data, 0, __RX_DATA_LEN);
 8009afe:	0029      	movs	r1, r5
 8009b00:	1810      	adds	r0, r2, r0
 8009b02:	2228      	movs	r2, #40	; 0x28
 8009b04:	f003 f853 	bl	800cbae <memset>

  /* reset the type of SOP */
  pRxData->MsgType = USBPD_SOPTYPE_INVALID;
 8009b08:	0023      	movs	r3, r4
 8009b0a:	22ff      	movs	r2, #255	; 0xff
 8009b0c:	3348      	adds	r3, #72	; 0x48

  /* reset the type of OrderSet received */
  pRxData->OrderSet = 0x00;
 8009b0e:	6465      	str	r5, [r4, #68]	; 0x44
  pRxData->MsgType = USBPD_SOPTYPE_INVALID;
 8009b10:	701a      	strb	r2, [r3, #0]

  return pRxData->Status;
 8009b12:	7830      	ldrb	r0, [r6, #0]
}
 8009b14:	bd70      	pop	{r4, r5, r6, pc}
 8009b16:	46c0      	nop			; (mov r8, r8)
 8009b18:	20000354 	.word	0x20000354

08009b1c <PHY_Rx_Completed>:
  * @brief  Callback to notify the end of the current reception
  * @param  PortNum  Number of the port
  * @retval Status of current reception
  */
USBPD_PHY_RX_Status_TypeDef PHY_Rx_Completed(uint8_t PortNum)
{
 8009b1c:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t crc_read,crc_calc;
  PHY_RxDecodingTypeDef * pRxData = (PHY_RxDecodingTypeDef *)&PHY_Ports[PortNum].RxDec;
  if (pRxData->Status != USBPD_PHY_RX_STATUS_MESSAGE_READY)
 8009b1e:	257c      	movs	r5, #124	; 0x7c
 8009b20:	4345      	muls	r5, r0
 8009b22:	4e2b      	ldr	r6, [pc, #172]	; (8009bd0 <PHY_Rx_Completed+0xb4>)
{
 8009b24:	0007      	movs	r7, r0
  if (pRxData->Status != USBPD_PHY_RX_STATUS_MESSAGE_READY)
 8009b26:	1974      	adds	r4, r6, r5
 8009b28:	0023      	movs	r3, r4
 8009b2a:	3340      	adds	r3, #64	; 0x40
 8009b2c:	7818      	ldrb	r0, [r3, #0]
{
 8009b2e:	b085      	sub	sp, #20
  if (pRxData->Status != USBPD_PHY_RX_STATUS_MESSAGE_READY)
 8009b30:	9301      	str	r3, [sp, #4]
 8009b32:	2804      	cmp	r0, #4
 8009b34:	d111      	bne.n	8009b5a <PHY_Rx_Completed+0x3e>
  {
    return pRxData->Status;
  }

  if (pRxData->MsgType == USBPD_SOPTYPE_HARD_RESET || pRxData->MsgType == USBPD_SOPTYPE_CABLE_RESET)
 8009b36:	3308      	adds	r3, #8
 8009b38:	7819      	ldrb	r1, [r3, #0]
 8009b3a:	9302      	str	r3, [sp, #8]
 8009b3c:	1f4b      	subs	r3, r1, #5
 8009b3e:	2b01      	cmp	r3, #1
 8009b40:	d80d      	bhi.n	8009b5e <PHY_Rx_Completed+0x42>
  {
    /* received a hard reset, call the callback, no other checks */
    if (PHY_Ports[PortNum].cbs->USBPD_PHY_ResetIndication != NULL)
 8009b42:	59ab      	ldr	r3, [r5, r6]
 8009b44:	685b      	ldr	r3, [r3, #4]
 8009b46:	2b00      	cmp	r3, #0
 8009b48:	d001      	beq.n	8009b4e <PHY_Rx_Completed+0x32>
    {
      PHY_Ports[PortNum].cbs->USBPD_PHY_ResetIndication(PortNum, pRxData->MsgType);
 8009b4a:	0038      	movs	r0, r7
 8009b4c:	4798      	blx	r3
    }
    return pRxData->Status = USBPD_PHY_RX_STATUS_OK;
 8009b4e:	237c      	movs	r3, #124	; 0x7c
 8009b50:	2001      	movs	r0, #1
 8009b52:	435f      	muls	r7, r3
 8009b54:	19f6      	adds	r6, r6, r7
 8009b56:	3640      	adds	r6, #64	; 0x40
 8009b58:	7030      	strb	r0, [r6, #0]
  {
    PHY_Ports[PortNum].cbs->USBPD_PHY_MessageReceived(PortNum, pRxData->MsgType);
  }

  return pRxData->Status = USBPD_PHY_RX_STATUS_OK;
}
 8009b5a:	b005      	add	sp, #20
 8009b5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  uint8_t *pRxBuffer = PHY_Ports[PortNum].pRxBuffer;
 8009b5e:	6863      	ldr	r3, [r4, #4]
 8009b60:	9303      	str	r3, [sp, #12]
  crc_calc = USBPD_HW_IF_CRC_Calculate(pRxData->Data, pRxData->DataCount - 4);
 8009b62:	002b      	movs	r3, r5
 8009b64:	3349      	adds	r3, #73	; 0x49
 8009b66:	18f3      	adds	r3, r6, r3
 8009b68:	9300      	str	r3, [sp, #0]
 8009b6a:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8009b6c:	9800      	ldr	r0, [sp, #0]
 8009b6e:	1f19      	subs	r1, r3, #4
 8009b70:	b2c9      	uxtb	r1, r1
 8009b72:	f000 fa3d 	bl	8009ff0 <USBPD_HW_IF_CRC_Calculate>
 8009b76:	4684      	mov	ip, r0
  uint8_t *pCrcField = &pRxData->Data[pRxData->DataCount - 4];
 8009b78:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8009b7a:	1f1a      	subs	r2, r3, #4
 8009b7c:	1951      	adds	r1, r2, r5
 8009b7e:	3149      	adds	r1, #73	; 0x49
 8009b80:	1871      	adds	r1, r6, r1
  crc_read = *pCrcField;
 8009b82:	18a4      	adds	r4, r4, r2
  crc_read |= ((*pCrcField) << 8);
 8009b84:	784b      	ldrb	r3, [r1, #1]
  crc_read |= ((*pCrcField) << 16);
 8009b86:	7888      	ldrb	r0, [r1, #2]
  crc_read = *pCrcField;
 8009b88:	3449      	adds	r4, #73	; 0x49
 8009b8a:	7824      	ldrb	r4, [r4, #0]
  crc_read |= ((*pCrcField) << 8);
 8009b8c:	021b      	lsls	r3, r3, #8
  crc_read |= ((*pCrcField) << 16);
 8009b8e:	0400      	lsls	r0, r0, #16
 8009b90:	4303      	orrs	r3, r0
 8009b92:	4323      	orrs	r3, r4
  crc_read |= ((*pCrcField) << 24);
 8009b94:	78cc      	ldrb	r4, [r1, #3]
 8009b96:	0624      	lsls	r4, r4, #24
 8009b98:	431c      	orrs	r4, r3
  if (crc_read != crc_calc)
 8009b9a:	45a4      	cmp	ip, r4
 8009b9c:	d003      	beq.n	8009ba6 <PHY_Rx_Completed+0x8a>
    return pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_CRC_FAILED;
 8009b9e:	200a      	movs	r0, #10
 8009ba0:	9b01      	ldr	r3, [sp, #4]
 8009ba2:	7018      	strb	r0, [r3, #0]
 8009ba4:	e7d9      	b.n	8009b5a <PHY_Rx_Completed+0x3e>
  memcpy(pRxBuffer, pRxData->Data, pRxData->DataCount - 4);
 8009ba6:	9900      	ldr	r1, [sp, #0]
 8009ba8:	9803      	ldr	r0, [sp, #12]
 8009baa:	f002 fff7 	bl	800cb9c <memcpy>
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_MessageReceived != NULL)
 8009bae:	59ab      	ldr	r3, [r5, r6]
 8009bb0:	681b      	ldr	r3, [r3, #0]
 8009bb2:	2b00      	cmp	r3, #0
 8009bb4:	d003      	beq.n	8009bbe <PHY_Rx_Completed+0xa2>
    PHY_Ports[PortNum].cbs->USBPD_PHY_MessageReceived(PortNum, pRxData->MsgType);
 8009bb6:	9a02      	ldr	r2, [sp, #8]
 8009bb8:	0038      	movs	r0, r7
 8009bba:	7811      	ldrb	r1, [r2, #0]
 8009bbc:	4798      	blx	r3
  return pRxData->Status = USBPD_PHY_RX_STATUS_OK;
 8009bbe:	267c      	movs	r6, #124	; 0x7c
 8009bc0:	2001      	movs	r0, #1
 8009bc2:	437e      	muls	r6, r7
 8009bc4:	4f02      	ldr	r7, [pc, #8]	; (8009bd0 <PHY_Rx_Completed+0xb4>)
 8009bc6:	19bf      	adds	r7, r7, r6
 8009bc8:	3740      	adds	r7, #64	; 0x40
 8009bca:	7038      	strb	r0, [r7, #0]
 8009bcc:	e7c5      	b.n	8009b5a <PHY_Rx_Completed+0x3e>
 8009bce:	46c0      	nop			; (mov r8, r8)
 8009bd0:	20000354 	.word	0x20000354

08009bd4 <PHY_Encode5b_Short>:
{
 8009bd4:	b510      	push	{r4, lr}
  return coding4b5b[val & 0x0F] | (coding4b5b[(val >> 4) & 0x0F] << 5);
 8009bd6:	240f      	movs	r4, #15
 8009bd8:	4908      	ldr	r1, [pc, #32]	; (8009bfc <PHY_Encode5b_Short+0x28>)
  return PHY_Encode5b_Byte(val & 0x00FF) | (PHY_Encode5b_Byte((val >> 8) & 0x00FF) << 10);
 8009bda:	b2c2      	uxtb	r2, r0
 8009bdc:	0a00      	lsrs	r0, r0, #8
  return coding4b5b[val & 0x0F] | (coding4b5b[(val >> 4) & 0x0F] << 5);
 8009bde:	0903      	lsrs	r3, r0, #4
 8009be0:	5ccb      	ldrb	r3, [r1, r3]
 8009be2:	4020      	ands	r0, r4
 8009be4:	5c08      	ldrb	r0, [r1, r0]
 8009be6:	015b      	lsls	r3, r3, #5
 8009be8:	4303      	orrs	r3, r0
 8009bea:	0910      	lsrs	r0, r2, #4
 8009bec:	5c08      	ldrb	r0, [r1, r0]
 8009bee:	4022      	ands	r2, r4
 8009bf0:	5c8a      	ldrb	r2, [r1, r2]
 8009bf2:	0140      	lsls	r0, r0, #5
  return PHY_Encode5b_Byte(val & 0x00FF) | (PHY_Encode5b_Byte((val >> 8) & 0x00FF) << 10);
 8009bf4:	029b      	lsls	r3, r3, #10
  return coding4b5b[val & 0x0F] | (coding4b5b[(val >> 4) & 0x0F] << 5);
 8009bf6:	4310      	orrs	r0, r2
  return PHY_Encode5b_Byte(val & 0x00FF) | (PHY_Encode5b_Byte((val >> 8) & 0x00FF) << 10);
 8009bf8:	4318      	orrs	r0, r3
}
 8009bfa:	bd10      	pop	{r4, pc}
 8009bfc:	0800ce30 	.word	0x0800ce30

08009c00 <USBPD_PHY_GetRetryTimerValue>:
  return 920u;
 8009c00:	20e6      	movs	r0, #230	; 0xe6
}
 8009c02:	0080      	lsls	r0, r0, #2
 8009c04:	4770      	bx	lr
	...

08009c08 <USBPD_PHY_Send_BIST_Pattern>:
  PHY_Ports[PortNum].State = PHY_StateBusyBIST_Tx;
 8009c08:	237c      	movs	r3, #124	; 0x7c
 8009c0a:	4343      	muls	r3, r0
{
 8009c0c:	b510      	push	{r4, lr}
  PHY_Ports[PortNum].State = PHY_StateBusyBIST_Tx;
 8009c0e:	4c04      	ldr	r4, [pc, #16]	; (8009c20 <USBPD_PHY_Send_BIST_Pattern+0x18>)
 8009c10:	18e4      	adds	r4, r4, r3
 8009c12:	2305      	movs	r3, #5
 8009c14:	7223      	strb	r3, [r4, #8]
  USBPD_HW_IF_Send_BIST_Pattern(PortNum);
 8009c16:	f000 fa2b 	bl	800a070 <USBPD_HW_IF_Send_BIST_Pattern>
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009c1a:	2000      	movs	r0, #0
 8009c1c:	7220      	strb	r0, [r4, #8]
}
 8009c1e:	bd10      	pop	{r4, pc}
 8009c20:	20000354 	.word	0x20000354

08009c24 <USBPD_PHY_ExitTransmit>:
}
 8009c24:	2000      	movs	r0, #0
 8009c26:	4770      	bx	lr

08009c28 <USBPD_PHY_SetResistor_SinkTxNG>:
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_1_5_A);
 8009c28:	1e43      	subs	r3, r0, #1
 8009c2a:	4198      	sbcs	r0, r3
{
 8009c2c:	b510      	push	{r4, lr}
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_1_5_A);
 8009c2e:	3028      	adds	r0, #40	; 0x28
 8009c30:	2101      	movs	r1, #1
 8009c32:	f7fc ff35 	bl	8006aa0 <STUSB1602_Current_Advertised_Set>
}
 8009c36:	bd10      	pop	{r4, pc}

08009c38 <USBPD_PHY_SetResistor_SinkTxOK>:
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 8009c38:	1e43      	subs	r3, r0, #1
 8009c3a:	4198      	sbcs	r0, r3
{
 8009c3c:	b510      	push	{r4, lr}
  STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 8009c3e:	3028      	adds	r0, #40	; 0x28
 8009c40:	2102      	movs	r1, #2
 8009c42:	f7fc ff2d 	bl	8006aa0 <STUSB1602_Current_Advertised_Set>
}
 8009c46:	bd10      	pop	{r4, pc}

08009c48 <USBPD_PHY_SOPSupported>:
}
 8009c48:	4770      	bx	lr

08009c4a <USBPD_PHY_IsResistor_SinkTxOk>:
{
 8009c4a:	b510      	push	{r4, lr}
  return USBPD_16xx_IsResistor_SinkTxOk(PortNum);
 8009c4c:	f001 fe00 	bl	800b850 <USBPD_16xx_IsResistor_SinkTxOk>
}
 8009c50:	bd10      	pop	{r4, pc}

08009c52 <USBPD_PHY_FastRoleSwapSignalling>:
 8009c52:	4770      	bx	lr

08009c54 <PHY_TxBuffer_Reset>:
{
 8009c54:	b570      	push	{r4, r5, r6, lr}
  memset((void *)PHY_Ports[PortNum].TxBuffer, 0, __TX_BUFF_SIZE);
 8009c56:	257c      	movs	r5, #124	; 0x7c
 8009c58:	4345      	muls	r5, r0
 8009c5a:	0028      	movs	r0, r5
 8009c5c:	4c05      	ldr	r4, [pc, #20]	; (8009c74 <PHY_TxBuffer_Reset+0x20>)
 8009c5e:	300c      	adds	r0, #12
 8009c60:	1820      	adds	r0, r4, r0
 8009c62:	2230      	movs	r2, #48	; 0x30
 8009c64:	2100      	movs	r1, #0
 8009c66:	f002 ffa2 	bl	800cbae <memset>
  PHY_Ports[PortNum].TxDatabitLen = 0;
 8009c6a:	2300      	movs	r3, #0
 8009c6c:	1964      	adds	r4, r4, r5
 8009c6e:	63e3      	str	r3, [r4, #60]	; 0x3c
}
 8009c70:	bd70      	pop	{r4, r5, r6, pc}
 8009c72:	46c0      	nop			; (mov r8, r8)
 8009c74:	20000354 	.word	0x20000354

08009c78 <USBPD_PHY_Reset>:
{
 8009c78:	b510      	push	{r4, lr}
  PHY_TxBuffer_Reset(PortNum);
 8009c7a:	f7ff ffeb 	bl	8009c54 <PHY_TxBuffer_Reset>
}
 8009c7e:	bd10      	pop	{r4, pc}

08009c80 <USBPD_PHY_Init>:
{
 8009c80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8009c82:	0016      	movs	r6, r2
  hwif_cbs.USBPD_HW_IF_RX_Reset       = PHY_Rx_Reset;
 8009c84:	4a11      	ldr	r2, [pc, #68]	; (8009ccc <USBPD_PHY_Init+0x4c>)
{
 8009c86:	b08b      	sub	sp, #44	; 0x2c
  hwif_cbs.USBPD_HW_IF_RX_Reset       = PHY_Rx_Reset;
 8009c88:	9207      	str	r2, [sp, #28]
  hwif_cbs.USBPD_HW_IF_RX_Accumulate  = PHY_Rx_Accumulate;
 8009c8a:	4a11      	ldr	r2, [pc, #68]	; (8009cd0 <USBPD_PHY_Init+0x50>)
{
 8009c8c:	0004      	movs	r4, r0
  hwif_cbs.USBPD_HW_IF_RX_Accumulate  = PHY_Rx_Accumulate;
 8009c8e:	9208      	str	r2, [sp, #32]
  hwif_cbs.USBPD_HW_IF_RX_Completed   = PHY_Rx_Completed;
 8009c90:	4a10      	ldr	r2, [pc, #64]	; (8009cd4 <USBPD_PHY_Init+0x54>)
  USBPD_HW_IF_PortHwInit(PortNum, hwif_cbs, PowerRole);
 8009c92:	9303      	str	r3, [sp, #12]
  hwif_cbs.USBPD_HW_IF_RX_Completed   = PHY_Rx_Completed;
 8009c94:	9209      	str	r2, [sp, #36]	; 0x24
  USBPD_HW_IF_PortHwInit(PortNum, hwif_cbs, PowerRole);
 8009c96:	466a      	mov	r2, sp
 8009c98:	ab07      	add	r3, sp, #28
{
 8009c9a:	000d      	movs	r5, r1
  USBPD_HW_IF_PortHwInit(PortNum, hwif_cbs, PowerRole);
 8009c9c:	cb83      	ldmia	r3!, {r0, r1, r7}
 8009c9e:	c283      	stmia	r2!, {r0, r1, r7}
 8009ca0:	4a0d      	ldr	r2, [pc, #52]	; (8009cd8 <USBPD_PHY_Init+0x58>)
 8009ca2:	9904      	ldr	r1, [sp, #16]
 8009ca4:	4b0d      	ldr	r3, [pc, #52]	; (8009cdc <USBPD_PHY_Init+0x5c>)
 8009ca6:	0020      	movs	r0, r4
 8009ca8:	f001 fb5a 	bl	800b360 <USBPD_HW_IF_PortHwInit>
  PHY_Ports[PortNum].pRxBuffer    = pRxBuffer;
 8009cac:	237c      	movs	r3, #124	; 0x7c
 8009cae:	4363      	muls	r3, r4
 8009cb0:	4a0b      	ldr	r2, [pc, #44]	; (8009ce0 <USBPD_PHY_Init+0x60>)
  PHY_Ports[PortNum].SupportedSOP = SupportedSOP;
 8009cb2:	9910      	ldr	r1, [sp, #64]	; 0x40
  PHY_Ports[PortNum].pRxBuffer    = pRxBuffer;
 8009cb4:	18d7      	adds	r7, r2, r3
  PHY_TxBuffer_Reset(PortNum);
 8009cb6:	0020      	movs	r0, r4
  PHY_Ports[PortNum].pRxBuffer    = pRxBuffer;
 8009cb8:	607e      	str	r6, [r7, #4]
  PHY_Ports[PortNum].SupportedSOP = SupportedSOP;
 8009cba:	67b9      	str	r1, [r7, #120]	; 0x78
  PHY_Ports[PortNum].cbs = pCallback;
 8009cbc:	509d      	str	r5, [r3, r2]
  PHY_TxBuffer_Reset(PortNum);
 8009cbe:	f7ff ffc9 	bl	8009c54 <PHY_TxBuffer_Reset>
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009cc2:	2000      	movs	r0, #0
 8009cc4:	7238      	strb	r0, [r7, #8]
}
 8009cc6:	b00b      	add	sp, #44	; 0x2c
 8009cc8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009cca:	46c0      	nop			; (mov r8, r8)
 8009ccc:	08009ae9 	.word	0x08009ae9
 8009cd0:	08009f15 	.word	0x08009f15
 8009cd4:	08009b1d 	.word	0x08009b1d
 8009cd8:	08009ac9 	.word	0x08009ac9
 8009cdc:	08009ab1 	.word	0x08009ab1
 8009ce0:	20000354 	.word	0x20000354

08009ce4 <PHY_TxBuffer_Append>:
{
 8009ce4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009ce6:	247c      	movs	r4, #124	; 0x7c
  uint32_t map = __BITMASK(nbit);
 8009ce8:	2601      	movs	r6, #1
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009cea:	4344      	muls	r4, r0
  uint32_t bit = *pOffset % __SIZEBIT;
 8009cec:	271f      	movs	r7, #31
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009cee:	0023      	movs	r3, r4
  uint32_t map = __BITMASK(nbit);
 8009cf0:	4096      	lsls	r6, r2
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009cf2:	4d16      	ldr	r5, [pc, #88]	; (8009d4c <PHY_TxBuffer_Append+0x68>)
 8009cf4:	330c      	adds	r3, #12
  uint32_t pos = *pOffset / __SIZEBIT;
 8009cf6:	192c      	adds	r4, r5, r4
 8009cf8:	6be4      	ldr	r4, [r4, #60]	; 0x3c
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009cfa:	18eb      	adds	r3, r5, r3
  uint32_t bit = *pOffset % __SIZEBIT;
 8009cfc:	4027      	ands	r7, r4
  uint32_t pos = *pOffset / __SIZEBIT;
 8009cfe:	0964      	lsrs	r4, r4, #5
  uint32_t map = __BITMASK(nbit);
 8009d00:	3e01      	subs	r6, #1
  pBuffer[pos] |= (value << bit);
 8009d02:	00a4      	lsls	r4, r4, #2
  uint32_t value = val & map;
 8009d04:	4031      	ands	r1, r6
  pBuffer[pos] |= (value << bit);
 8009d06:	191e      	adds	r6, r3, r4
 8009d08:	46b4      	mov	ip, r6
 8009d0a:	000e      	movs	r6, r1
  uint32_t *pBuffer = (uint32_t *)PHY_Ports[PortNum].TxBuffer;
 8009d0c:	9301      	str	r3, [sp, #4]
  pBuffer[pos] |= (value << bit);
 8009d0e:	4663      	mov	r3, ip
 8009d10:	40be      	lsls	r6, r7
 8009d12:	681b      	ldr	r3, [r3, #0]
 8009d14:	431e      	orrs	r6, r3
 8009d16:	4663      	mov	r3, ip
 8009d18:	601e      	str	r6, [r3, #0]
  if (bit > (__SIZEBIT - MIN(nbit, __SIZEBIT)))
 8009d1a:	1c16      	adds	r6, r2, #0
 8009d1c:	2a20      	cmp	r2, #32
 8009d1e:	d900      	bls.n	8009d22 <PHY_TxBuffer_Append+0x3e>
 8009d20:	2620      	movs	r6, #32
 8009d22:	b2f3      	uxtb	r3, r6
 8009d24:	2620      	movs	r6, #32
 8009d26:	1af3      	subs	r3, r6, r3
 8009d28:	42bb      	cmp	r3, r7
 8009d2a:	d207      	bcs.n	8009d3c <PHY_TxBuffer_Append+0x58>
    pBuffer[pos + 1] |= (value >> (__SIZEBIT - bit));
 8009d2c:	1bf7      	subs	r7, r6, r7
 8009d2e:	40f9      	lsrs	r1, r7
 8009d30:	9b01      	ldr	r3, [sp, #4]
 8009d32:	3404      	adds	r4, #4
 8009d34:	191b      	adds	r3, r3, r4
 8009d36:	681c      	ldr	r4, [r3, #0]
 8009d38:	4321      	orrs	r1, r4
 8009d3a:	6019      	str	r1, [r3, #0]
  *pOffset += nbit;
 8009d3c:	237c      	movs	r3, #124	; 0x7c
 8009d3e:	4358      	muls	r0, r3
 8009d40:	182d      	adds	r5, r5, r0
 8009d42:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8009d44:	189a      	adds	r2, r3, r2
 8009d46:	63ea      	str	r2, [r5, #60]	; 0x3c
}
 8009d48:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 8009d4a:	46c0      	nop			; (mov r8, r8)
 8009d4c:	20000354 	.word	0x20000354

08009d50 <PHY_PreparePacket>:
{
 8009d50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint8_t resetRequired = Type == USBPD_SOPTYPE_HARD_RESET || Type == USBPD_SOPTYPE_CABLE_RESET;
 8009d52:	1f4c      	subs	r4, r1, #5
 8009d54:	b2e4      	uxtb	r4, r4
{
 8009d56:	000f      	movs	r7, r1
 8009d58:	0015      	movs	r5, r2
 8009d5a:	001e      	movs	r6, r3
  if (!resetRequired  && ((Size < 2) || (Size > 30) || (( (Size - 2) % __SIZE) != 0))) 
 8009d5c:	2c01      	cmp	r4, #1
 8009d5e:	d95f      	bls.n	8009e20 <PHY_PreparePacket+0xd0>
 8009d60:	3b02      	subs	r3, #2
 8009d62:	b2da      	uxtb	r2, r3
 8009d64:	2a1c      	cmp	r2, #28
 8009d66:	d801      	bhi.n	8009d6c <PHY_PreparePacket+0x1c>
 8009d68:	079b      	lsls	r3, r3, #30
 8009d6a:	d00e      	beq.n	8009d8a <PHY_PreparePacket+0x3a>
  return FRAME_5B_BitSizeIsValid(*pOffset) ? USBPD_OK : USBPD_ERROR;
 8009d6c:	2002      	movs	r0, #2
 8009d6e:	e056      	b.n	8009e1e <PHY_PreparePacket+0xce>
      val16 = pBuffer[i] | (pBuffer[i + 1] << 8);
 8009d70:	7863      	ldrb	r3, [r4, #1]
 8009d72:	7820      	ldrb	r0, [r4, #0]
 8009d74:	021b      	lsls	r3, r3, #8
      value = PHY_Encode5b_Short(val16);
 8009d76:	4318      	orrs	r0, r3
 8009d78:	f7ff ff2c 	bl	8009bd4 <PHY_Encode5b_Short>
      PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 8009d7c:	2214      	movs	r2, #20
      value = PHY_Encode5b_Short(val16);
 8009d7e:	0001      	movs	r1, r0
      PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 8009d80:	2000      	movs	r0, #0
 8009d82:	f7ff ffaf 	bl	8009ce4 <PHY_TxBuffer_Append>
 8009d86:	3402      	adds	r4, #2
 8009d88:	e016      	b.n	8009db8 <PHY_PreparePacket+0x68>
  if (!USBPD_PORT_IsValid(PortNum) || (!resetRequired && pBuffer == NULL))
 8009d8a:	2800      	cmp	r0, #0
 8009d8c:	d1ee      	bne.n	8009d6c <PHY_PreparePacket+0x1c>
 8009d8e:	2d00      	cmp	r5, #0
 8009d90:	d0ec      	beq.n	8009d6c <PHY_PreparePacket+0x1c>
  PHY_TxBuffer_Reset(PortNum);
 8009d92:	2000      	movs	r0, #0
 8009d94:	f7ff ff5e 	bl	8009c54 <PHY_TxBuffer_Reset>
  PHY_TxBuffer_Append(PortNum, OrderSets[(uint8_t)Type], OS_BITSIZE);
 8009d98:	4b23      	ldr	r3, [pc, #140]	; (8009e28 <PHY_PreparePacket+0xd8>)
 8009d9a:	00bf      	lsls	r7, r7, #2
 8009d9c:	19df      	adds	r7, r3, r7
 8009d9e:	2214      	movs	r2, #20
 8009da0:	6939      	ldr	r1, [r7, #16]
 8009da2:	2000      	movs	r0, #0
 8009da4:	f7ff ff9e 	bl	8009ce4 <PHY_TxBuffer_Append>
  if (!resetRequired)
 8009da8:	2c01      	cmp	r4, #1
 8009daa:	d91d      	bls.n	8009de8 <PHY_PreparePacket+0x98>
    crc_value = USBPD_HW_IF_CRC_Calculate(pBuffer, Size);
 8009dac:	0031      	movs	r1, r6
 8009dae:	0028      	movs	r0, r5
 8009db0:	f000 f91e 	bl	8009ff0 <USBPD_HW_IF_CRC_Calculate>
    for (i = 0; i < Size; i += 2)
 8009db4:	002c      	movs	r4, r5
    crc_value = USBPD_HW_IF_CRC_Calculate(pBuffer, Size);
 8009db6:	0007      	movs	r7, r0
    for (i = 0; i < Size; i += 2)
 8009db8:	1b63      	subs	r3, r4, r5
 8009dba:	429e      	cmp	r6, r3
 8009dbc:	d8d8      	bhi.n	8009d70 <PHY_PreparePacket+0x20>
    value = PHY_Encode5b_Short(crc_value & 0x0000FFFF);
 8009dbe:	b2b8      	uxth	r0, r7
 8009dc0:	f7ff ff08 	bl	8009bd4 <PHY_Encode5b_Short>
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 8009dc4:	2214      	movs	r2, #20
    value = PHY_Encode5b_Short(crc_value & 0x0000FFFF);
 8009dc6:	0001      	movs	r1, r0
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 8009dc8:	2000      	movs	r0, #0
 8009dca:	f7ff ff8b 	bl	8009ce4 <PHY_TxBuffer_Append>
    value = PHY_Encode5b_Short((crc_value >> 16) & 0x0000FFFF);
 8009dce:	0c38      	lsrs	r0, r7, #16
 8009dd0:	f7ff ff00 	bl	8009bd4 <PHY_Encode5b_Short>
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 8009dd4:	2214      	movs	r2, #20
    value = PHY_Encode5b_Short((crc_value >> 16) & 0x0000FFFF);
 8009dd6:	0001      	movs	r1, r0
    PHY_TxBuffer_Append(PortNum, value, CODE_5B_ITEM4_BITSIZE);
 8009dd8:	2000      	movs	r0, #0
 8009dda:	f7ff ff83 	bl	8009ce4 <PHY_TxBuffer_Append>
    PHY_TxBuffer_Append(PortNum, KC_S_EOP, CODE_5B_ITEM1_BITSIZE);
 8009dde:	2205      	movs	r2, #5
 8009de0:	210d      	movs	r1, #13
 8009de2:	2000      	movs	r0, #0
 8009de4:	f7ff ff7e 	bl	8009ce4 <PHY_TxBuffer_Append>
  return FRAME_5B_BitSizeIsValid(*pOffset) ? USBPD_OK : USBPD_ERROR;
 8009de8:	4b10      	ldr	r3, [pc, #64]	; (8009e2c <PHY_PreparePacket+0xdc>)
 8009dea:	2000      	movs	r0, #0
 8009dec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009dee:	2b14      	cmp	r3, #20
 8009df0:	d015      	beq.n	8009e1e <PHY_PreparePacket+0xce>
 8009df2:	2b55      	cmp	r3, #85	; 0x55
 8009df4:	d013      	beq.n	8009e1e <PHY_PreparePacket+0xce>
 8009df6:	2b7d      	cmp	r3, #125	; 0x7d
 8009df8:	d011      	beq.n	8009e1e <PHY_PreparePacket+0xce>
 8009dfa:	2ba5      	cmp	r3, #165	; 0xa5
 8009dfc:	d00f      	beq.n	8009e1e <PHY_PreparePacket+0xce>
 8009dfe:	2bcd      	cmp	r3, #205	; 0xcd
 8009e00:	d00d      	beq.n	8009e1e <PHY_PreparePacket+0xce>
 8009e02:	2bf5      	cmp	r3, #245	; 0xf5
 8009e04:	d00b      	beq.n	8009e1e <PHY_PreparePacket+0xce>
 8009e06:	221e      	movs	r2, #30
 8009e08:	32ff      	adds	r2, #255	; 0xff
 8009e0a:	4293      	cmp	r3, r2
 8009e0c:	d007      	beq.n	8009e1e <PHY_PreparePacket+0xce>
 8009e0e:	2246      	movs	r2, #70	; 0x46
 8009e10:	32ff      	adds	r2, #255	; 0xff
 8009e12:	4293      	cmp	r3, r2
 8009e14:	d003      	beq.n	8009e1e <PHY_PreparePacket+0xce>
 8009e16:	226e      	movs	r2, #110	; 0x6e
 8009e18:	32ff      	adds	r2, #255	; 0xff
 8009e1a:	4293      	cmp	r3, r2
 8009e1c:	d1a6      	bne.n	8009d6c <PHY_PreparePacket+0x1c>
}
 8009e1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (!USBPD_PORT_IsValid(PortNum) || (!resetRequired && pBuffer == NULL))
 8009e20:	2800      	cmp	r0, #0
 8009e22:	d1a3      	bne.n	8009d6c <PHY_PreparePacket+0x1c>
 8009e24:	e7b5      	b.n	8009d92 <PHY_PreparePacket+0x42>
 8009e26:	46c0      	nop			; (mov r8, r8)
 8009e28:	0800ce30 	.word	0x0800ce30
 8009e2c:	20000354 	.word	0x20000354

08009e30 <USBPD_PHY_SendMessage>:
{
 8009e30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (PHY_Ports[PortNum].State != PHY_StateNone)
 8009e32:	247c      	movs	r4, #124	; 0x7c
 8009e34:	4344      	muls	r4, r0
{
 8009e36:	0006      	movs	r6, r0
  if (PHY_Ports[PortNum].State != PHY_StateNone)
 8009e38:	480c      	ldr	r0, [pc, #48]	; (8009e6c <USBPD_PHY_SendMessage+0x3c>)
 8009e3a:	1905      	adds	r5, r0, r4
 8009e3c:	7a2f      	ldrb	r7, [r5, #8]
    return USBPD_BUSY;
 8009e3e:	2003      	movs	r0, #3
  if (PHY_Ports[PortNum].State != PHY_StateNone)
 8009e40:	2f00      	cmp	r7, #0
 8009e42:	d112      	bne.n	8009e6a <USBPD_PHY_SendMessage+0x3a>
  res = PHY_PreparePacket(PortNum, Type, pBuffer, Size);
 8009e44:	b2db      	uxtb	r3, r3
 8009e46:	0030      	movs	r0, r6
 8009e48:	f7ff ff82 	bl	8009d50 <PHY_PreparePacket>
 8009e4c:	0007      	movs	r7, r0
    return USBPD_ERROR;
 8009e4e:	2002      	movs	r0, #2
  if (res == USBPD_OK)
 8009e50:	2f00      	cmp	r7, #0
 8009e52:	d10a      	bne.n	8009e6a <USBPD_PHY_SendMessage+0x3a>
    PHY_Ports[PortNum].State = PHY_StateBusyTxStart;
 8009e54:	2303      	movs	r3, #3
    res = USBPD_HW_IF_SendBuffer(PortNum, (uint8_t *)PHY_Ports[PortNum].TxBuffer,  PHY_Ports[PortNum].TxDatabitLen);
 8009e56:	0021      	movs	r1, r4
    PHY_Ports[PortNum].State = PHY_StateBusyTxStart;
 8009e58:	722b      	strb	r3, [r5, #8]
    res = USBPD_HW_IF_SendBuffer(PortNum, (uint8_t *)PHY_Ports[PortNum].TxBuffer,  PHY_Ports[PortNum].TxDatabitLen);
 8009e5a:	4b04      	ldr	r3, [pc, #16]	; (8009e6c <USBPD_PHY_SendMessage+0x3c>)
 8009e5c:	310c      	adds	r1, #12
 8009e5e:	1859      	adds	r1, r3, r1
 8009e60:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 8009e62:	0030      	movs	r0, r6
 8009e64:	f000 f8ce 	bl	800a004 <USBPD_HW_IF_SendBuffer>
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009e68:	722f      	strb	r7, [r5, #8]
}
 8009e6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009e6c:	20000354 	.word	0x20000354

08009e70 <USBPD_PHY_ResetRequest>:
  if (USBPD_PHY_SendMessage(PortNum, Type, NULL, 0) != USBPD_OK)
 8009e70:	2300      	movs	r3, #0
{
 8009e72:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (USBPD_PHY_SendMessage(PortNum, Type, NULL, 0) != USBPD_OK)
 8009e74:	001a      	movs	r2, r3
{
 8009e76:	0004      	movs	r4, r0
 8009e78:	9101      	str	r1, [sp, #4]
  if (USBPD_PHY_SendMessage(PortNum, Type, NULL, 0) != USBPD_OK)
 8009e7a:	f7ff ffd9 	bl	8009e30 <USBPD_PHY_SendMessage>
 8009e7e:	1e06      	subs	r6, r0, #0
 8009e80:	d116      	bne.n	8009eb0 <USBPD_PHY_ResetRequest+0x40>
  PHY_Ports[PortNum].State = PHY_StateBusy;
 8009e82:	257c      	movs	r5, #124	; 0x7c
 8009e84:	2202      	movs	r2, #2
 8009e86:	4365      	muls	r5, r4
 8009e88:	4f0a      	ldr	r7, [pc, #40]	; (8009eb4 <USBPD_PHY_ResetRequest+0x44>)
  PHY_TxBuffer_Reset(PortNum);
 8009e8a:	0020      	movs	r0, r4
  PHY_Ports[PortNum].State = PHY_StateBusy;
 8009e8c:	197b      	adds	r3, r7, r5
 8009e8e:	721a      	strb	r2, [r3, #8]
  PHY_TxBuffer_Reset(PortNum);
 8009e90:	f7ff fee0 	bl	8009c54 <PHY_TxBuffer_Reset>
  if (PHY_Ports[PortNum].cbs->USBPD_PHY_ResetCompleted != NULL)
 8009e94:	59eb      	ldr	r3, [r5, r7]
 8009e96:	689b      	ldr	r3, [r3, #8]
 8009e98:	2b00      	cmp	r3, #0
 8009e9a:	d002      	beq.n	8009ea2 <USBPD_PHY_ResetRequest+0x32>
    PHY_Ports[PortNum].cbs->USBPD_PHY_ResetCompleted(PortNum, Type);
 8009e9c:	9901      	ldr	r1, [sp, #4]
 8009e9e:	0020      	movs	r0, r4
 8009ea0:	4798      	blx	r3
  PHY_Ports[PortNum].State = PHY_StateNone;
 8009ea2:	237c      	movs	r3, #124	; 0x7c
 8009ea4:	435c      	muls	r4, r3
 8009ea6:	2300      	movs	r3, #0
 8009ea8:	193c      	adds	r4, r7, r4
 8009eaa:	7223      	strb	r3, [r4, #8]
}
 8009eac:	0030      	movs	r0, r6
 8009eae:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    return USBPD_ERROR;
 8009eb0:	2602      	movs	r6, #2
 8009eb2:	e7fb      	b.n	8009eac <USBPD_PHY_ResetRequest+0x3c>
 8009eb4:	20000354 	.word	0x20000354

08009eb8 <PHY_SopDetect>:
    temp = OrderSets[index] ^ OrderSet;
 8009eb8:	4b15      	ldr	r3, [pc, #84]	; (8009f10 <PHY_SopDetect+0x58>)
{
 8009eba:	b5f0      	push	{r4, r5, r6, r7, lr}
    temp = OrderSets[index] ^ OrderSet;
 8009ebc:	3310      	adds	r3, #16
      if (temp & 0x00007C00)
 8009ebe:	26f8      	movs	r6, #248	; 0xf8
      if (temp & 0x000003E0)
 8009ec0:	27f8      	movs	r7, #248	; 0xf8
  for (index = 0; index < OS_NUM; index++)
 8009ec2:	2000      	movs	r0, #0
    temp = OrderSets[index] ^ OrderSet;
 8009ec4:	469c      	mov	ip, r3
      if (temp & 0x00007C00)
 8009ec6:	01f6      	lsls	r6, r6, #7
      if (temp & 0x000003E0)
 8009ec8:	00bf      	lsls	r7, r7, #2
    temp = OrderSets[index] ^ OrderSet;
 8009eca:	4662      	mov	r2, ip
 8009ecc:	0083      	lsls	r3, r0, #2
 8009ece:	589b      	ldr	r3, [r3, r2]
 8009ed0:	001a      	movs	r2, r3
 8009ed2:	404a      	eors	r2, r1
    if (temp)
 8009ed4:	428b      	cmp	r3, r1
 8009ed6:	d014      	beq.n	8009f02 <PHY_SopDetect+0x4a>
      if (temp & 0x000F8000)
 8009ed8:	23f8      	movs	r3, #248	; 0xf8
 8009eda:	0014      	movs	r4, r2
 8009edc:	031b      	lsls	r3, r3, #12
 8009ede:	401c      	ands	r4, r3
    count = 0;
 8009ee0:	0023      	movs	r3, r4
 8009ee2:	1e5d      	subs	r5, r3, #1
 8009ee4:	41ab      	sbcs	r3, r5
      if (temp & 0x00007C00)
 8009ee6:	4232      	tst	r2, r6
 8009ee8:	d002      	beq.n	8009ef0 <PHY_SopDetect+0x38>
      if (count > 1)
 8009eea:	2c00      	cmp	r4, #0
 8009eec:	d10b      	bne.n	8009f06 <PHY_SopDetect+0x4e>
 8009eee:	2301      	movs	r3, #1
      if (temp & 0x000003E0)
 8009ef0:	423a      	tst	r2, r7
 8009ef2:	d002      	beq.n	8009efa <PHY_SopDetect+0x42>
      if (count > 1)
 8009ef4:	2b01      	cmp	r3, #1
 8009ef6:	d006      	beq.n	8009f06 <PHY_SopDetect+0x4e>
 8009ef8:	2301      	movs	r3, #1
      if (temp & 0x0000001F)
 8009efa:	06d2      	lsls	r2, r2, #27
 8009efc:	d001      	beq.n	8009f02 <PHY_SopDetect+0x4a>
      if (count > 1)
 8009efe:	2b01      	cmp	r3, #1
 8009f00:	d001      	beq.n	8009f06 <PHY_SopDetect+0x4e>
    type = (USBPD_SOPType_TypeDef)index;
 8009f02:	b2c0      	uxtb	r0, r0
}
 8009f04:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for (index = 0; index < OS_NUM; index++)
 8009f06:	3001      	adds	r0, #1
 8009f08:	2807      	cmp	r0, #7
 8009f0a:	d1de      	bne.n	8009eca <PHY_SopDetect+0x12>
  USBPD_SOPType_TypeDef type = USBPD_SOPTYPE_INVALID;
 8009f0c:	30f8      	adds	r0, #248	; 0xf8
 8009f0e:	e7f9      	b.n	8009f04 <PHY_SopDetect+0x4c>
 8009f10:	0800ce30 	.word	0x0800ce30

08009f14 <PHY_Rx_Accumulate>:
{
 8009f14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009f16:	0006      	movs	r6, r0
  switch (pRxData->Status)
 8009f18:	207c      	movs	r0, #124	; 0x7c
 8009f1a:	4370      	muls	r0, r6
 8009f1c:	4c32      	ldr	r4, [pc, #200]	; (8009fe8 <PHY_Rx_Accumulate+0xd4>)
 8009f1e:	1825      	adds	r5, r4, r0
 8009f20:	002f      	movs	r7, r5
 8009f22:	3740      	adds	r7, #64	; 0x40
 8009f24:	783b      	ldrb	r3, [r7, #0]
 8009f26:	2b02      	cmp	r3, #2
 8009f28:	d00c      	beq.n	8009f44 <PHY_Rx_Accumulate+0x30>
 8009f2a:	2b03      	cmp	r3, #3
 8009f2c:	d034      	beq.n	8009f98 <PHY_Rx_Accumulate+0x84>
 8009f2e:	2b00      	cmp	r3, #0
 8009f30:	d151      	bne.n	8009fd6 <PHY_Rx_Accumulate+0xc2>
    pRxData->OrderSet = data;
 8009f32:	6469      	str	r1, [r5, #68]	; 0x44
    pRxData->Status = USBPD_PHY_RX_STATUS_SOP_DETECTING;
 8009f34:	3302      	adds	r3, #2
      pRxData->Status = USBPD_PHY_RX_STATUS_MESSAGE_READY;
 8009f36:	703b      	strb	r3, [r7, #0]
  return pRxData->Status;
 8009f38:	237c      	movs	r3, #124	; 0x7c
 8009f3a:	435e      	muls	r6, r3
 8009f3c:	19a4      	adds	r4, r4, r6
 8009f3e:	3440      	adds	r4, #64	; 0x40
 8009f40:	7820      	ldrb	r0, [r4, #0]
}
 8009f42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    pRxData->OrderSet |= data<<10;
 8009f44:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8009f46:	0289      	lsls	r1, r1, #10
 8009f48:	4319      	orrs	r1, r3
 8009f4a:	6469      	str	r1, [r5, #68]	; 0x44
    pRxData->MsgType = PHY_SopDetect(PortNum, pRxData->OrderSet);
 8009f4c:	0030      	movs	r0, r6
 8009f4e:	f7ff ffb3 	bl	8009eb8 <PHY_SopDetect>
 8009f52:	3548      	adds	r5, #72	; 0x48
 8009f54:	7028      	strb	r0, [r5, #0]
    switch(pRxData->MsgType)
 8009f56:	2806      	cmp	r0, #6
 8009f58:	d81c      	bhi.n	8009f94 <PHY_Rx_Accumulate+0x80>
 8009f5a:	237c      	movs	r3, #124	; 0x7c
      if(PHY_Ports[PortNum].SupportedSOP & 0x1E)
 8009f5c:	4373      	muls	r3, r6
 8009f5e:	18e3      	adds	r3, r4, r3
    switch(pRxData->MsgType)
 8009f60:	f7fb fd28 	bl	80059b4 <__gnu_thumb1_case_uqi>
 8009f64:	0f0f0f0f 	.word	0x0f0f0f0f
 8009f68:	040f      	.short	0x040f
 8009f6a:	08          	.byte	0x08
 8009f6b:	00          	.byte	0x00
      pRxData->Status = USBPD_PHY_RX_STATUS_MESSAGE_READY;
 8009f6c:	3340      	adds	r3, #64	; 0x40
 8009f6e:	2204      	movs	r2, #4
        pRxData->Data[pRxData->DataCount++] = data4b_temp;
 8009f70:	701a      	strb	r2, [r3, #0]
 8009f72:	e7e1      	b.n	8009f38 <PHY_Rx_Accumulate+0x24>
      if(PHY_Ports[PortNum].SupportedSOP & 0x1E)
 8009f74:	221e      	movs	r2, #30
 8009f76:	6f99      	ldr	r1, [r3, #120]	; 0x78
 8009f78:	3340      	adds	r3, #64	; 0x40
 8009f7a:	4211      	tst	r1, r2
 8009f7c:	d1f7      	bne.n	8009f6e <PHY_Rx_Accumulate+0x5a>
        pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_UNSUPPORTED_SOP;
 8009f7e:	2206      	movs	r2, #6
 8009f80:	e7f6      	b.n	8009f70 <PHY_Rx_Accumulate+0x5c>
      if(PHY_Ports[PortNum].SupportedSOP & (0x1 << pRxData->MsgType))
 8009f82:	2101      	movs	r1, #1
 8009f84:	4081      	lsls	r1, r0
 8009f86:	000a      	movs	r2, r1
 8009f88:	6f99      	ldr	r1, [r3, #120]	; 0x78
 8009f8a:	3340      	adds	r3, #64	; 0x40
 8009f8c:	4211      	tst	r1, r2
 8009f8e:	d0f6      	beq.n	8009f7e <PHY_Rx_Accumulate+0x6a>
        pRxData->Status = USBPD_PHY_RX_STATUS_DATA;
 8009f90:	2203      	movs	r2, #3
 8009f92:	e7ed      	b.n	8009f70 <PHY_Rx_Accumulate+0x5c>
      pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_INVALID_SOP;
 8009f94:	2307      	movs	r3, #7
 8009f96:	e7ce      	b.n	8009f36 <PHY_Rx_Accumulate+0x22>
    if ((data & CODE_5B_ITEM1_MASK) == KC_S_EOP)
 8009f98:	201f      	movs	r0, #31
 8009f9a:	000a      	movs	r2, r1
 8009f9c:	4002      	ands	r2, r0
 8009f9e:	2a0d      	cmp	r2, #13
 8009fa0:	d101      	bne.n	8009fa6 <PHY_Rx_Accumulate+0x92>
      pRxData->Status = USBPD_PHY_RX_STATUS_MESSAGE_READY;
 8009fa2:	2304      	movs	r3, #4
 8009fa4:	e7c7      	b.n	8009f36 <PHY_Rx_Accumulate+0x22>
  v0 = decoding5b4b[(value >>  0) & 0x1F]; /* decoding first nibble */
 8009fa6:	4b11      	ldr	r3, [pc, #68]	; (8009fec <PHY_Rx_Accumulate+0xd8>)
  v1 = decoding5b4b[(value >>  5) & 0x1F]; /* decoding second nibble */
 8009fa8:	0949      	lsrs	r1, r1, #5
  v0 = decoding5b4b[(value >>  0) & 0x1F]; /* decoding first nibble */
 8009faa:	332c      	adds	r3, #44	; 0x2c
 8009fac:	5c9a      	ldrb	r2, [r3, r2]
  v1 = decoding5b4b[(value >>  5) & 0x1F]; /* decoding second nibble */
 8009fae:	4001      	ands	r1, r0
 8009fb0:	5c59      	ldrb	r1, [r3, r1]
  if (v0 == CODE_5B_INVALID || v1 == CODE_5B_INVALID) 
 8009fb2:	2aff      	cmp	r2, #255	; 0xff
 8009fb4:	d009      	beq.n	8009fca <PHY_Rx_Accumulate+0xb6>
 8009fb6:	29ff      	cmp	r1, #255	; 0xff
 8009fb8:	d007      	beq.n	8009fca <PHY_Rx_Accumulate+0xb6>
        pRxData->Data[pRxData->DataCount++] = data4b_temp;
 8009fba:	6f6b      	ldr	r3, [r5, #116]	; 0x74
  return v0 | (v1<<4);
 8009fbc:	0109      	lsls	r1, r1, #4
        pRxData->Data[pRxData->DataCount++] = data4b_temp;
 8009fbe:	1c58      	adds	r0, r3, #1
 8009fc0:	18eb      	adds	r3, r5, r3
 8009fc2:	6768      	str	r0, [r5, #116]	; 0x74
 8009fc4:	3349      	adds	r3, #73	; 0x49
  return v0 | (v1<<4);
 8009fc6:	430a      	orrs	r2, r1
 8009fc8:	e7d2      	b.n	8009f70 <PHY_Rx_Accumulate+0x5c>
        pRxData->Status = USBPD_PHY_RX_STATUS_ERROR_INVALID_SYMBOL;
 8009fca:	237c      	movs	r3, #124	; 0x7c
 8009fcc:	4373      	muls	r3, r6
 8009fce:	18e3      	adds	r3, r4, r3
 8009fd0:	3340      	adds	r3, #64	; 0x40
 8009fd2:	2208      	movs	r2, #8
 8009fd4:	e7cc      	b.n	8009f70 <PHY_Rx_Accumulate+0x5c>
    pRxData->DataCount = 0;
 8009fd6:	2100      	movs	r1, #0
    memset(pRxData->Data, 0, __RX_DATA_LEN);
 8009fd8:	3049      	adds	r0, #73	; 0x49
    pRxData->DataCount = 0;
 8009fda:	6769      	str	r1, [r5, #116]	; 0x74
    memset(pRxData->Data, 0, __RX_DATA_LEN);
 8009fdc:	1820      	adds	r0, r4, r0
 8009fde:	2228      	movs	r2, #40	; 0x28
 8009fe0:	f002 fde5 	bl	800cbae <memset>
    break;
 8009fe4:	e7a8      	b.n	8009f38 <PHY_Rx_Accumulate+0x24>
 8009fe6:	46c0      	nop			; (mov r8, r8)
 8009fe8:	20000354 	.word	0x20000354
 8009fec:	0800ce30 	.word	0x0800ce30

08009ff0 <USBPD_HW_IF_CRC_Calculate>:
  * @param  *pBuffer    Pointer to the input data buffer
  * @param  len         Input data buffer length
  * @retval uint32_t    CRC value
  */
uint32_t USBPD_HW_IF_CRC_Calculate(uint8_t *pBuffer, uint8_t len)
{
 8009ff0:	b510      	push	{r4, lr}
 8009ff2:	000a      	movs	r2, r1
  uint32_t crc;

  crc = HAL_CRC_Calculate(&hcrc, (uint32_t *)pBuffer, len);
 8009ff4:	0001      	movs	r1, r0
 8009ff6:	4802      	ldr	r0, [pc, #8]	; (800a000 <USBPD_HW_IF_CRC_Calculate+0x10>)
 8009ff8:	f7fd fbc1 	bl	800777e <HAL_CRC_Calculate>
  crc ^= 0xFFFFFFFF;
 8009ffc:	43c0      	mvns	r0, r0
  return crc;
}
 8009ffe:	bd10      	pop	{r4, pc}
 800a000:	20001cdc 	.word	0x20001cdc

0800a004 <USBPD_HW_IF_SendBuffer>:
* @param  *pBuffer      Pointer to the TX data buffer
* @param  Bitsize:      Amount of bits to be transmitted
* @retval USBPD status
*/
USBPD_StatusTypeDef USBPD_HW_IF_SendBuffer(uint8_t PortNum, uint8_t *pBuffer, uint32_t Bitsize)
{
 800a004:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Check if the port is still receiving */
  if (Ports[PortNum].State == HAL_USBPD_PORT_STATE_BUSY_RX)
 800a006:	24f0      	movs	r4, #240	; 0xf0
 800a008:	0064      	lsls	r4, r4, #1
 800a00a:	4344      	muls	r4, r0
 800a00c:	4b17      	ldr	r3, [pc, #92]	; (800a06c <USBPD_HW_IF_SendBuffer+0x68>)
{
 800a00e:	b085      	sub	sp, #20
  if (Ports[PortNum].State == HAL_USBPD_PORT_STATE_BUSY_RX)
 800a010:	191c      	adds	r4, r3, r4
 800a012:	7e63      	ldrb	r3, [r4, #25]
{
 800a014:	0006      	movs	r6, r0
 800a016:	9103      	str	r1, [sp, #12]
 800a018:	9202      	str	r2, [sp, #8]
    return USBPD_BUSY;
 800a01a:	2003      	movs	r0, #3
  if (Ports[PortNum].State == HAL_USBPD_PORT_STATE_BUSY_RX)
 800a01c:	2b04      	cmp	r3, #4
 800a01e:	d022      	beq.n	800a066 <USBPD_HW_IF_SendBuffer+0x62>

  uint8_t *pTxBuffer = (uint8_t *)Ports[PortNum].pTxBuffPtr;
  uint16_t size = DIV_ROUND_UP(Bitsize, 8)+TX_PREAMBLE_SIZE;
 800a020:	0013      	movs	r3, r2
  uint8_t *pTxBuffer = (uint8_t *)Ports[PortNum].pTxBuffPtr;
 800a022:	6865      	ldr	r5, [r4, #4]
  uint16_t size = DIV_ROUND_UP(Bitsize, 8)+TX_PREAMBLE_SIZE;
 800a024:	3307      	adds	r3, #7
 800a026:	40c3      	lsrs	r3, r0
 800a028:	002f      	movs	r7, r5
 800a02a:	3308      	adds	r3, #8
 800a02c:	3708      	adds	r7, #8
 800a02e:	b29b      	uxth	r3, r3

  memset((uint8_t *)pTxBuffer, 0x00, TX_BUFFER_SIZE);
 800a030:	2230      	movs	r2, #48	; 0x30
 800a032:	2100      	movs	r1, #0
 800a034:	0038      	movs	r0, r7
  uint16_t size = DIV_ROUND_UP(Bitsize, 8)+TX_PREAMBLE_SIZE;
 800a036:	9301      	str	r3, [sp, #4]
  memset((uint8_t *)pTxBuffer, 0x00, TX_BUFFER_SIZE);
 800a038:	f002 fdb9 	bl	800cbae <memset>
  memset((uint8_t *)pTxBuffer, TX_PREAMBLE, TX_PREAMBLE_SIZE);                          /* preamble is added */
 800a03c:	2208      	movs	r2, #8
 800a03e:	21aa      	movs	r1, #170	; 0xaa
 800a040:	0028      	movs	r0, r5
 800a042:	f002 fdb4 	bl	800cbae <memset>
  memcpy((uint8_t *)(pTxBuffer+TX_PREAMBLE_SIZE), pBuffer, (size-TX_PREAMBLE_SIZE));    /* data are added */
 800a046:	9a01      	ldr	r2, [sp, #4]
 800a048:	9903      	ldr	r1, [sp, #12]
 800a04a:	3a08      	subs	r2, #8
 800a04c:	0038      	movs	r0, r7
 800a04e:	f002 fda5 	bl	800cb9c <memcpy>

  /* Spare clock cycles at the end of transmission are calculated */
  Ports[PortNum].TxSpareBits = (Bitsize % 8);
 800a052:	2307      	movs	r3, #7
 800a054:	9a02      	ldr	r2, [sp, #8]
 800a056:	342a      	adds	r4, #42	; 0x2a
 800a058:	4013      	ands	r3, r2
 800a05a:	7023      	strb	r3, [r4, #0]

  /* Packet is ready to be sent to SPI */
  USBPD_StatusTypeDef ret = USBPD_OK;
  ret = STUSB16xx_HW_IF_Send_Packet(PortNum, pTxBuffer, size);
 800a05c:	9a01      	ldr	r2, [sp, #4]
 800a05e:	0029      	movs	r1, r5
 800a060:	0030      	movs	r0, r6
 800a062:	f001 fba9 	bl	800b7b8 <STUSB16xx_HW_IF_Send_Packet>
  return ret;
}
 800a066:	b005      	add	sp, #20
 800a068:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a06a:	46c0      	nop			; (mov r8, r8)
 800a06c:	20000058 	.word	0x20000058

0800a070 <USBPD_HW_IF_Send_BIST_Pattern>:
* @brief  It sends BIST pattern  
* @param  PortNum       The port index
* @retval USBPD status
*/
USBPD_StatusTypeDef USBPD_HW_IF_Send_BIST_Pattern(uint8_t PortNum)
{
 800a070:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USBPD_StatusTypeDef ret = USBPD_ERROR;
  
  /* BIST Carrier mode flag set */
  Ports[PortNum].State=HAL_USBPD_PORT_STATE_BIST;
 800a072:	24f0      	movs	r4, #240	; 0xf0
 800a074:	0064      	lsls	r4, r4, #1
 800a076:	4344      	muls	r4, r0
 800a078:	4b15      	ldr	r3, [pc, #84]	; (800a0d0 <USBPD_HW_IF_Send_BIST_Pattern+0x60>)
{
 800a07a:	0005      	movs	r5, r0
  Ports[PortNum].State=HAL_USBPD_PORT_STATE_BIST;
 800a07c:	191f      	adds	r7, r3, r4
 800a07e:	2308      	movs	r3, #8
  STUSB16xx_HW_IF_Set_DMA_Circular_Mode(PortNum);
  
  /* Set the SPI in TX mode */
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
  
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a080:	0026      	movs	r6, r4
  Ports[PortNum].State=HAL_USBPD_PORT_STATE_BIST;
 800a082:	767b      	strb	r3, [r7, #25]
  memset(Ports[PortNum].pTxBuffPtr, 0xAA, TX_BUFFER_LEN*2);
 800a084:	2238      	movs	r2, #56	; 0x38
 800a086:	21aa      	movs	r1, #170	; 0xaa
 800a088:	6878      	ldr	r0, [r7, #4]
 800a08a:	f002 fd90 	bl	800cbae <memset>
  STUSB16xx_HW_IF_Set_DMA_Circular_Mode(PortNum);
 800a08e:	0028      	movs	r0, r5
 800a090:	f001 f916 	bl	800b2c0 <STUSB16xx_HW_IF_Set_DMA_Circular_Mode>
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 800a094:	2100      	movs	r1, #0
 800a096:	0028      	movs	r0, r5
 800a098:	f001 f936 	bl	800b308 <STUSB16xx_HW_IF_Switch_Mode>
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a09c:	4b0c      	ldr	r3, [pc, #48]	; (800a0d0 <USBPD_HW_IF_Send_BIST_Pattern+0x60>)
 800a09e:	3640      	adds	r6, #64	; 0x40
 800a0a0:	18f6      	adds	r6, r6, r3
 800a0a2:	0030      	movs	r0, r6
 800a0a4:	f7fe fc4c 	bl	8008940 <HAL_SPI_DMAStop>
  HAL_DMA_Abort(&Ports[PortNum].hdmarx);
 800a0a8:	0020      	movs	r0, r4
 800a0aa:	4b09      	ldr	r3, [pc, #36]	; (800a0d0 <USBPD_HW_IF_Send_BIST_Pattern+0x60>)
 800a0ac:	30e8      	adds	r0, #232	; 0xe8
 800a0ae:	18c0      	adds	r0, r0, r3
 800a0b0:	f7fd fc6c 	bl	800798c <HAL_DMA_Abort>
  __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 800a0b4:	4b07      	ldr	r3, [pc, #28]	; (800a0d4 <USBPD_HW_IF_Send_BIST_Pattern+0x64>)
 800a0b6:	4a08      	ldr	r2, [pc, #32]	; (800a0d8 <USBPD_HW_IF_Send_BIST_Pattern+0x68>)
  
  /* Send TX Buffer by SPI DMA */
  HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, (uint8_t*)(Ports[PortNum].pTxBuffPtr), TX_BUFFER_LEN*2);
 800a0b8:	6879      	ldr	r1, [r7, #4]
  __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 800a0ba:	605a      	str	r2, [r3, #4]
  HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, (uint8_t*)(Ports[PortNum].pTxBuffPtr), TX_BUFFER_LEN*2);
 800a0bc:	0030      	movs	r0, r6
 800a0be:	2238      	movs	r2, #56	; 0x38
 800a0c0:	f7fe fa2c 	bl	800851c <HAL_SPI_Transmit_DMA>
  
  /* Start transmission */
  STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_SET);
 800a0c4:	0028      	movs	r0, r5
 800a0c6:	2101      	movs	r1, #1
 800a0c8:	f001 f92c 	bl	800b324 <STUSB16xx_HW_IF_TX_EN_Status>
  
  ret = USBPD_OK;
  return ret;
}
 800a0cc:	2000      	movs	r0, #0
 800a0ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800a0d0:	20000058 	.word	0x20000058
 800a0d4:	40020000 	.word	0x40020000
 800a0d8:	0fffffff 	.word	0x0fffffff

0800a0dc <USBPD_HW_IF_GPIO_Off>:
 * @brief   It resets the state of GPIO pin
 * @param   gpio The GPIO structure
 * @retval  None
 */
void USBPD_HW_IF_GPIO_Off(USBPD_BSP_GPIOPins_TypeDef gpio)
{
 800a0dc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  HAL_GPIO_WritePin(gpio.GPIOx, gpio.GPIO_Pin, PinState);
 800a0de:	b289      	uxth	r1, r1
 800a0e0:	2200      	movs	r2, #0
 800a0e2:	f7fd fd2b 	bl	8007b3c <HAL_GPIO_WritePin>
  /* Resets the pin */
  USBPD_HW_IF_GPIO_Set(gpio, GPIO_PIN_RESET);
}
 800a0e6:	b005      	add	sp, #20
 800a0e8:	bd00      	pop	{pc}
	...

0800a0ec <PHY_HW_IF_ADCAnalogGPIO_Init>:
{
  GPIO_InitTypeDef      GPIO_InitStruct;
  uint8_t ch = 0;

  /* Configure all GPIO port pins in Analog mode */
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800a0ec:	2303      	movs	r3, #3
{
 800a0ee:	b510      	push	{r4, lr}
 800a0f0:	b086      	sub	sp, #24
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800a0f2:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a0f4:	2300      	movs	r3, #0

  for(ch=0;ch<USBPD_ADCn;ch++)
  {
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a0f6:	4c0b      	ldr	r4, [pc, #44]	; (800a124 <PHY_HW_IF_ADCAnalogGPIO_Init+0x38>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a0f8:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a0fa:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 800a0fc:	3310      	adds	r3, #16
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a0fe:	0020      	movs	r0, r4
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 800a100:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a102:	f7fd fc59 	bl	80079b8 <HAL_GPIO_Init>
 800a106:	2090      	movs	r0, #144	; 0x90
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 800a108:	2380      	movs	r3, #128	; 0x80
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a10a:	a901      	add	r1, sp, #4
 800a10c:	05c0      	lsls	r0, r0, #23
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 800a10e:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a110:	f7fd fc52 	bl	80079b8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 800a114:	2301      	movs	r3, #1
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a116:	a901      	add	r1, sp, #4
 800a118:	0020      	movs	r0, r4
    GPIO_InitStruct.Pin = USBPD_ADCs[ch].GPIO_Pin;
 800a11a:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(USBPD_ADCs[ch].GPIOx, &GPIO_InitStruct);
 800a11c:	f7fd fc4c 	bl	80079b8 <HAL_GPIO_Init>
  }
}
 800a120:	b006      	add	sp, #24
 800a122:	bd10      	pop	{r4, pc}
 800a124:	48000800 	.word	0x48000800

0800a128 <PHY_HW_IF_ADCDMA_Init>:
/**
  * @brief  Initialization of the ADC DMA
  * @retval None
  */
void PHY_HW_IF_ADCDMA_Init(void)
{
 800a128:	b510      	push	{r4, lr}
  /* Configuration of DMA parameters */
  DmaHandle.Instance = ADCx_DMA;
 800a12a:	4b0e      	ldr	r3, [pc, #56]	; (800a164 <PHY_HW_IF_ADCDMA_Init+0x3c>)
 800a12c:	4c0e      	ldr	r4, [pc, #56]	; (800a168 <PHY_HW_IF_ADCDMA_Init+0x40>)
 800a12e:	6023      	str	r3, [r4, #0]

  DmaHandle.Init.Direction           = DMA_PERIPH_TO_MEMORY;
 800a130:	2300      	movs	r3, #0
 800a132:	6063      	str	r3, [r4, #4]
  DmaHandle.Init.PeriphInc           = DMA_PINC_DISABLE;
 800a134:	60a3      	str	r3, [r4, #8]
  DmaHandle.Init.MemInc              = DMA_MINC_ENABLE;
 800a136:	3380      	adds	r3, #128	; 0x80
 800a138:	60e3      	str	r3, [r4, #12]
  DmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;   /* Transfer from ADC by half-word to match with ADC configuration: ADC resolution 10 or 12 bits */
 800a13a:	3380      	adds	r3, #128	; 0x80
 800a13c:	6123      	str	r3, [r4, #16]
  DmaHandle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;       /* Transfer to memory by half-word to match with buffer variable type: half-word */
 800a13e:	2380      	movs	r3, #128	; 0x80
 800a140:	011b      	lsls	r3, r3, #4
 800a142:	6163      	str	r3, [r4, #20]
  DmaHandle.Init.Mode                = DMA_CIRCULAR;              /* DMA in circular mode to match with ADC configuration: DMA continuous requests */
 800a144:	2320      	movs	r3, #32
 800a146:	61a3      	str	r3, [r4, #24]
  DmaHandle.Init.Priority            = DMA_PRIORITY_HIGH;
 800a148:	2380      	movs	r3, #128	; 0x80

  /* Initialization of the DMA associated to the peripheral */
  HAL_DMA_DeInit(&DmaHandle);
 800a14a:	0020      	movs	r0, r4
  DmaHandle.Init.Priority            = DMA_PRIORITY_HIGH;
 800a14c:	019b      	lsls	r3, r3, #6
 800a14e:	61e3      	str	r3, [r4, #28]
  HAL_DMA_DeInit(&DmaHandle);
 800a150:	f7fd fbba 	bl	80078c8 <HAL_DMA_DeInit>
  HAL_DMA_Init(&DmaHandle);
 800a154:	0020      	movs	r0, r4
 800a156:	f7fd fb81 	bl	800785c <HAL_DMA_Init>

  /* Association of the initialized DMA handle to the ADC handle */
  __HAL_LINKDMA(&usbpdm1_hadc, DMA_Handle, DmaHandle);
 800a15a:	4b04      	ldr	r3, [pc, #16]	; (800a16c <PHY_HW_IF_ADCDMA_Init+0x44>)
 800a15c:	63dc      	str	r4, [r3, #60]	; 0x3c
 800a15e:	6263      	str	r3, [r4, #36]	; 0x24
}
 800a160:	bd10      	pop	{r4, pc}
 800a162:	46c0      	nop			; (mov r8, r8)
 800a164:	40020008 	.word	0x40020008
 800a168:	20001d3c 	.word	0x20001d3c
 800a16c:	20001c84 	.word	0x20001c84

0800a170 <PHY_HW_IF_RX_Stop>:
  * @brief  PHY accomplishes the data receiving phase
  * @param  PortNum The port index
  * @retval None
  */
void PHY_HW_IF_RX_Stop(uint8_t PortNum)
{
 800a170:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a172:	0005      	movs	r5, r0
   * 3 - PHY_HW_IF_RX_Stop function is ongoing
   */

  UnwrapData_TypeDef* ud = &(Ports[PortNum].unwrapdata);
  
  if (ud->exed_flag == 3)
 800a174:	20f0      	movs	r0, #240	; 0xf0
 800a176:	0040      	lsls	r0, r0, #1
 800a178:	4368      	muls	r0, r5
 800a17a:	4c49      	ldr	r4, [pc, #292]	; (800a2a0 <PHY_HW_IF_RX_Stop+0x130>)
 800a17c:	0002      	movs	r2, r0
 800a17e:	1826      	adds	r6, r4, r0
 800a180:	0033      	movs	r3, r6
 800a182:	3279      	adds	r2, #121	; 0x79
 800a184:	332c      	adds	r3, #44	; 0x2c
 800a186:	32ff      	adds	r2, #255	; 0xff
 800a188:	781f      	ldrb	r7, [r3, #0]
{
 800a18a:	b089      	sub	sp, #36	; 0x24
 800a18c:	1912      	adds	r2, r2, r4
  if (ud->exed_flag == 3)
 800a18e:	9001      	str	r0, [sp, #4]
 800a190:	9202      	str	r2, [sp, #8]
 800a192:	2f03      	cmp	r7, #3
 800a194:	d105      	bne.n	800a1a2 <PHY_HW_IF_RX_Stop+0x32>
  {
    HAL_TIM_OC_Stop_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a196:	2100      	movs	r1, #0
 800a198:	0010      	movs	r0, r2
 800a19a:	f7fe ff4b 	bl	8009034 <HAL_TIM_OC_Stop_IT>
  /* Callback core phy completed */
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed != NULL)
  {
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed(PortNum);
  }
}
 800a19e:	b009      	add	sp, #36	; 0x24
 800a1a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  ud->exed_flag = 3;
 800a1a2:	2203      	movs	r2, #3
{
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Disable the TIM Capture/Compare 1 interrupt */
  __HAL_TIM_DISABLE_IT(htim, tim_it);
 800a1a4:	36fc      	adds	r6, #252	; 0xfc
 800a1a6:	6ff0      	ldr	r0, [r6, #124]	; 0x7c
  ud->exed_flag = 3;
 800a1a8:	701a      	strb	r2, [r3, #0]
  __HAL_TIM_DISABLE_IT(htim, tim_it);
 800a1aa:	68c3      	ldr	r3, [r0, #12]
 800a1ac:	3a01      	subs	r2, #1
 800a1ae:	4393      	bics	r3, r2

  /* Disable the Output compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 800a1b0:	2200      	movs	r2, #0
  __HAL_TIM_DISABLE_IT(htim, tim_it);
 800a1b2:	60c3      	str	r3, [r0, #12]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 800a1b4:	0011      	movs	r1, r2
 800a1b6:	f7fe fef1 	bl	8008f9c <TIM_CCxChannelCmd>

  if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800a1ba:	6ff3      	ldr	r3, [r6, #124]	; 0x7c
 800a1bc:	4a39      	ldr	r2, [pc, #228]	; (800a2a4 <PHY_HW_IF_RX_Stop+0x134>)
 800a1be:	483a      	ldr	r0, [pc, #232]	; (800a2a8 <PHY_HW_IF_RX_Stop+0x138>)
 800a1c0:	4293      	cmp	r3, r2
 800a1c2:	d008      	beq.n	800a1d6 <PHY_HW_IF_RX_Stop+0x66>
 800a1c4:	4a39      	ldr	r2, [pc, #228]	; (800a2ac <PHY_HW_IF_RX_Stop+0x13c>)
 800a1c6:	4293      	cmp	r3, r2
 800a1c8:	d005      	beq.n	800a1d6 <PHY_HW_IF_RX_Stop+0x66>
 800a1ca:	4a39      	ldr	r2, [pc, #228]	; (800a2b0 <PHY_HW_IF_RX_Stop+0x140>)
 800a1cc:	4293      	cmp	r3, r2
 800a1ce:	d002      	beq.n	800a1d6 <PHY_HW_IF_RX_Stop+0x66>
 800a1d0:	4a38      	ldr	r2, [pc, #224]	; (800a2b4 <PHY_HW_IF_RX_Stop+0x144>)
 800a1d2:	4293      	cmp	r3, r2
 800a1d4:	d102      	bne.n	800a1dc <PHY_HW_IF_RX_Stop+0x6c>
  {
    /* Disable the Main Ouput */
    htim->Instance->BDTR &= ~(TIM_BDTR_MOE);
 800a1d6:	6c59      	ldr	r1, [r3, #68]	; 0x44
 800a1d8:	4001      	ands	r1, r0
 800a1da:	6459      	str	r1, [r3, #68]	; 0x44
  }
  /* Disable the Peripheral */
  htim->Instance->BDTR &= ~(TIM_BDTR_MOE);
 800a1dc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800a1de:	4002      	ands	r2, r0
 800a1e0:	645a      	str	r2, [r3, #68]	; 0x44
  if (ud_ef == 0)
 800a1e2:	2f00      	cmp	r7, #0
 800a1e4:	d13f      	bne.n	800a266 <PHY_HW_IF_RX_Stop+0xf6>
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 800a1e6:	23f0      	movs	r3, #240	; 0xf0
 800a1e8:	005b      	lsls	r3, r3, #1
 800a1ea:	436b      	muls	r3, r5
 800a1ec:	18e4      	adds	r4, r4, r3
 800a1ee:	68e2      	ldr	r2, [r4, #12]
  uint32_t temp_data = 0;
 800a1f0:	9707      	str	r7, [sp, #28]
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 800a1f2:	9203      	str	r2, [sp, #12]
  uint16_t lastindex = (RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR);
 800a1f4:	0022      	movs	r2, r4
 800a1f6:	32e8      	adds	r2, #232	; 0xe8
 800a1f8:	6812      	ldr	r2, [r2, #0]
 800a1fa:	6852      	ldr	r2, [r2, #4]
 800a1fc:	9204      	str	r2, [sp, #16]
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate == NULL)
 800a1fe:	0022      	movs	r2, r4
 800a200:	32c9      	adds	r2, #201	; 0xc9
 800a202:	32ff      	adds	r2, #255	; 0xff
 800a204:	6812      	ldr	r2, [r2, #0]
 800a206:	2a00      	cmp	r2, #0
 800a208:	d02c      	beq.n	800a264 <PHY_HW_IF_RX_Stop+0xf4>
  while(ud->index <= lastindex)
 800a20a:	9305      	str	r3, [sp, #20]
  uint16_t lastindex = (RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR);
 800a20c:	233c      	movs	r3, #60	; 0x3c
 800a20e:	9a04      	ldr	r2, [sp, #16]
  while(ud->index <= lastindex)
 800a210:	6ba6      	ldr	r6, [r4, #56]	; 0x38
  uint16_t lastindex = (RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR);
 800a212:	1a9b      	subs	r3, r3, r2
  while(ud->index <= lastindex)
 800a214:	b29b      	uxth	r3, r3
 800a216:	429e      	cmp	r6, r3
 800a218:	d825      	bhi.n	800a266 <PHY_HW_IF_RX_Stop+0xf6>
    memcpy(&temp_data, &pbuff_in[ud->index], 3);
 800a21a:	9b03      	ldr	r3, [sp, #12]
 800a21c:	2203      	movs	r2, #3
 800a21e:	1999      	adds	r1, r3, r6
 800a220:	a807      	add	r0, sp, #28
 800a222:	f002 fcbb 	bl	800cb9c <memcpy>
    ud->index += ud->offset <= 5 ? 1 : 2;
 800a226:	2305      	movs	r3, #5
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a228:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800a22a:	9f07      	ldr	r7, [sp, #28]
    ud->index += ud->offset <= 5 ? 1 : 2;
 800a22c:	4293      	cmp	r3, r2
 800a22e:	419b      	sbcs	r3, r3
 800a230:	425b      	negs	r3, r3
 800a232:	3301      	adds	r3, #1
 800a234:	469c      	mov	ip, r3
 800a236:	481a      	ldr	r0, [pc, #104]	; (800a2a0 <PHY_HW_IF_RX_Stop+0x130>)
 800a238:	9b05      	ldr	r3, [sp, #20]
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a23a:	40d7      	lsrs	r7, r2
    ud->index += ud->offset <= 5 ? 1 : 2;
 800a23c:	18c0      	adds	r0, r0, r3
    ud->offset = (ud->offset + 2) & 7;
 800a23e:	2307      	movs	r3, #7
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a240:	05b9      	lsls	r1, r7, #22
    ud->offset = (ud->offset + 2) & 7;
 800a242:	3202      	adds	r2, #2
 800a244:	401a      	ands	r2, r3
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a246:	0d89      	lsrs	r1, r1, #22
    ud->index += ud->offset <= 5 ? 1 : 2;
 800a248:	4466      	add	r6, ip
    temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a24a:	9107      	str	r1, [sp, #28]
    ud->index += ud->offset <= 5 ? 1 : 2;
 800a24c:	6386      	str	r6, [r0, #56]	; 0x38
    ud->offset = (ud->offset + 2) & 7;
 800a24e:	63c2      	str	r2, [r0, #60]	; 0x3c
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate(PortNum, temp_data);
 800a250:	30c9      	adds	r0, #201	; 0xc9
 800a252:	30ff      	adds	r0, #255	; 0xff
 800a254:	6803      	ldr	r3, [r0, #0]
 800a256:	0028      	movs	r0, r5
 800a258:	4798      	blx	r3
    if ((temp_data & 0x1F) == 0x0D)
 800a25a:	231f      	movs	r3, #31
 800a25c:	401f      	ands	r7, r3
 800a25e:	2f0d      	cmp	r7, #13
 800a260:	d1d4      	bne.n	800a20c <PHY_HW_IF_RX_Stop+0x9c>
 800a262:	e000      	b.n	800a266 <PHY_HW_IF_RX_Stop+0xf6>
 800a264:	46c0      	nop			; (mov r8, r8)
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800a266:	24f0      	movs	r4, #240	; 0xf0
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a268:	9801      	ldr	r0, [sp, #4]
 800a26a:	4e0d      	ldr	r6, [pc, #52]	; (800a2a0 <PHY_HW_IF_RX_Stop+0x130>)
 800a26c:	3040      	adds	r0, #64	; 0x40
 800a26e:	1980      	adds	r0, r0, r6
 800a270:	f7fe fb66 	bl	8008940 <HAL_SPI_DMAStop>
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800a274:	2301      	movs	r3, #1
 800a276:	0064      	lsls	r4, r4, #1
 800a278:	436c      	muls	r4, r5
 800a27a:	1934      	adds	r4, r6, r4
 800a27c:	7663      	strb	r3, [r4, #25]
  HAL_TIM_Base_Stop_IT(&(Ports[PortNum].htimcountrx));
 800a27e:	9802      	ldr	r0, [sp, #8]
 800a280:	f7fe fd80 	bl	8008d84 <HAL_TIM_Base_Stop_IT>
  Ports[PortNum].htimcountrx.Instance->CNT = 0;
 800a284:	0023      	movs	r3, r4
 800a286:	2200      	movs	r2, #0
 800a288:	33fc      	adds	r3, #252	; 0xfc
 800a28a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed != NULL)
 800a28c:	34cd      	adds	r4, #205	; 0xcd
 800a28e:	34ff      	adds	r4, #255	; 0xff
  Ports[PortNum].htimcountrx.Instance->CNT = 0;
 800a290:	625a      	str	r2, [r3, #36]	; 0x24
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed != NULL)
 800a292:	6823      	ldr	r3, [r4, #0]
 800a294:	4293      	cmp	r3, r2
 800a296:	d100      	bne.n	800a29a <PHY_HW_IF_RX_Stop+0x12a>
 800a298:	e781      	b.n	800a19e <PHY_HW_IF_RX_Stop+0x2e>
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Completed(PortNum);
 800a29a:	0028      	movs	r0, r5
 800a29c:	4798      	blx	r3
 800a29e:	e77e      	b.n	800a19e <PHY_HW_IF_RX_Stop+0x2e>
 800a2a0:	20000058 	.word	0x20000058
 800a2a4:	40012c00 	.word	0x40012c00
 800a2a8:	ffff7fff 	.word	0xffff7fff
 800a2ac:	40014000 	.word	0x40014000
 800a2b0:	40014400 	.word	0x40014400
 800a2b4:	40014800 	.word	0x40014800

0800a2b8 <HAL_TIM_OC_DelayElapsedCallback>:
  uint32_t temp_data = 0;
 800a2b8:	2300      	movs	r3, #0
{
 800a2ba:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 800a2bc:	4c62      	ldr	r4, [pc, #392]	; (800a448 <HAL_TIM_OC_DelayElapsedCallback+0x190>)
{
 800a2be:	b085      	sub	sp, #20
  uint32_t temp_data = 0;
 800a2c0:	9303      	str	r3, [sp, #12]
  uint32_t tim_count = Ports[PortNum].htimcountrx.Instance->CNT;
 800a2c2:	0023      	movs	r3, r4
 800a2c4:	33fc      	adds	r3, #252	; 0xfc
 800a2c6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  uint8_t* pbuff_in = Ports[PortNum].pRxBuffPtr;
 800a2c8:	68e6      	ldr	r6, [r4, #12]
  uint32_t tim_count = Ports[PortNum].htimcountrx.Instance->CNT;
 800a2ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a2cc:	9301      	str	r3, [sp, #4]
         (ud->exed_flag == 0) &&
 800a2ce:	0022      	movs	r2, r4
 800a2d0:	322c      	adds	r2, #44	; 0x2c
  while (
 800a2d2:	7812      	ldrb	r2, [r2, #0]
 800a2d4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a2d6:	2a00      	cmp	r2, #0
 800a2d8:	d100      	bne.n	800a2dc <HAL_TIM_OC_DelayElapsedCallback+0x24>
 800a2da:	e084      	b.n	800a3e6 <HAL_TIM_OC_DelayElapsedCallback+0x12e>
  Ports[PortNum].ud_index_current[Ports[PortNum].modulo] = ud->index ;
 800a2dc:	27ee      	movs	r7, #238	; 0xee
 800a2de:	007f      	lsls	r7, r7, #1
 800a2e0:	5de0      	ldrb	r0, [r4, r7]
 800a2e2:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 800a2e4:	1823      	adds	r3, r4, r0
 800a2e6:	33da      	adds	r3, #218	; 0xda
 800a2e8:	33ff      	adds	r3, #255	; 0xff
  Ports[PortNum].modulo++;
 800a2ea:	3001      	adds	r0, #1
  Ports[PortNum].ud_index_current[Ports[PortNum].modulo] = ud->index ;
 800a2ec:	701e      	strb	r6, [r3, #0]
  Ports[PortNum].modulo = Ports[PortNum].modulo%3;
 800a2ee:	b2c0      	uxtb	r0, r0
 800a2f0:	2103      	movs	r1, #3
 800a2f2:	f7fb fbef 	bl	8005ad4 <__aeabi_uidivmod>
 800a2f6:	b2cd      	uxtb	r5, r1
      (Ports[PortNum].ud_index_current[Ports[PortNum].modulo] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3]) &&
 800a2f8:	1963      	adds	r3, r4, r5
 800a2fa:	33da      	adds	r3, #218	; 0xda
  Ports[PortNum].modulo = Ports[PortNum].modulo%3;
 800a2fc:	55e5      	strb	r5, [r4, r7]
      (Ports[PortNum].ud_index_current[Ports[PortNum].modulo] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3]) &&
 800a2fe:	33ff      	adds	r3, #255	; 0xff
 800a300:	781b      	ldrb	r3, [r3, #0]
 800a302:	1c68      	adds	r0, r5, #1
 800a304:	2103      	movs	r1, #3
 800a306:	9301      	str	r3, [sp, #4]
 800a308:	f7fb fcce 	bl	8005ca8 <__aeabi_idivmod>
 800a30c:	1861      	adds	r1, r4, r1
 800a30e:	31da      	adds	r1, #218	; 0xda
 800a310:	31ff      	adds	r1, #255	; 0xff
  if (
 800a312:	780f      	ldrb	r7, [r1, #0]
 800a314:	9b01      	ldr	r3, [sp, #4]
 800a316:	429f      	cmp	r7, r3
 800a318:	d10f      	bne.n	800a33a <HAL_TIM_OC_DelayElapsedCallback+0x82>
        (Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+2)%3]) &&
 800a31a:	1ca8      	adds	r0, r5, #2
 800a31c:	2103      	movs	r1, #3
 800a31e:	f7fb fcc3 	bl	8005ca8 <__aeabi_idivmod>
 800a322:	1861      	adds	r1, r4, r1
 800a324:	31da      	adds	r1, #218	; 0xda
 800a326:	31ff      	adds	r1, #255	; 0xff
      (Ports[PortNum].ud_index_current[Ports[PortNum].modulo] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3]) &&
 800a328:	780b      	ldrb	r3, [r1, #0]
 800a32a:	42bb      	cmp	r3, r7
 800a32c:	d105      	bne.n	800a33a <HAL_TIM_OC_DelayElapsedCallback+0x82>
        (Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+1)%3] == Ports[PortNum].ud_index_current[(Ports[PortNum].modulo+2)%3]) &&
 800a32e:	2e05      	cmp	r6, #5
 800a330:	d903      	bls.n	800a33a <HAL_TIM_OC_DelayElapsedCallback+0x82>
    ud->exed_flag = 3;
 800a332:	0023      	movs	r3, r4
 800a334:	2203      	movs	r2, #3
 800a336:	332c      	adds	r3, #44	; 0x2c
 800a338:	701a      	strb	r2, [r3, #0]
  if (ud->exed_flag == 2)
 800a33a:	342c      	adds	r4, #44	; 0x2c
 800a33c:	7823      	ldrb	r3, [r4, #0]
 800a33e:	2b02      	cmp	r3, #2
 800a340:	d102      	bne.n	800a348 <HAL_TIM_OC_DelayElapsedCallback+0x90>
    PHY_HW_IF_RX_Stop(PortNum);
 800a342:	2000      	movs	r0, #0
 800a344:	f7ff ff14 	bl	800a170 <PHY_HW_IF_RX_Stop>
}
 800a348:	b005      	add	sp, #20
 800a34a:	bdf0      	pop	{r4, r5, r6, r7, pc}
          curr_bit = (pbuff_in[ud->index]>>ud->offset) & 0x01;
 800a34c:	2701      	movs	r7, #1
        prev_bit = (pbuff_in[ud->index-1]>>7) & 0x01;
 800a34e:	3a01      	subs	r2, #1
 800a350:	5cb0      	ldrb	r0, [r6, r2]
 800a352:	09c0      	lsrs	r0, r0, #7
        while (ud->offset < 8)
 800a354:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800a356:	2b07      	cmp	r3, #7
 800a358:	d8b9      	bhi.n	800a2ce <HAL_TIM_OC_DelayElapsedCallback+0x16>
          curr_bit = (pbuff_in[ud->index]>>ud->offset) & 0x01;
 800a35a:	7829      	ldrb	r1, [r5, #0]
 800a35c:	4119      	asrs	r1, r3
 800a35e:	4039      	ands	r1, r7
          if (prev_bit == curr_bit)
 800a360:	4288      	cmp	r0, r1
 800a362:	d114      	bne.n	800a38e <HAL_TIM_OC_DelayElapsedCallback+0xd6>
            if (curr_bit == 0)
 800a364:	2800      	cmp	r0, #0
 800a366:	d104      	bne.n	800a372 <HAL_TIM_OC_DelayElapsedCallback+0xba>
              if (ud->offset == 0)
 800a368:	2b00      	cmp	r3, #0
 800a36a:	d10d      	bne.n	800a388 <HAL_TIM_OC_DelayElapsedCallback+0xd0>
                ud->offset = 7;
 800a36c:	3307      	adds	r3, #7
 800a36e:	63e3      	str	r3, [r4, #60]	; 0x3c
                ud->index--;
 800a370:	63a2      	str	r2, [r4, #56]	; 0x38
            ud->preamble = 1;
 800a372:	0023      	movs	r3, r4
 800a374:	2201      	movs	r2, #1
 800a376:	332d      	adds	r3, #45	; 0x2d
 800a378:	701a      	strb	r2, [r3, #0]
            preamble_offset = ud->offset;
 800a37a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800a37c:	4b33      	ldr	r3, [pc, #204]	; (800a44c <HAL_TIM_OC_DelayElapsedCallback+0x194>)
 800a37e:	701a      	strb	r2, [r3, #0]
            preamble_index = ud->index;
 800a380:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800a382:	4b33      	ldr	r3, [pc, #204]	; (800a450 <HAL_TIM_OC_DelayElapsedCallback+0x198>)
        ud->exed_flag = 2;
 800a384:	701a      	strb	r2, [r3, #0]
 800a386:	e7a2      	b.n	800a2ce <HAL_TIM_OC_DelayElapsedCallback+0x16>
                ud->offset--;
 800a388:	3b01      	subs	r3, #1
 800a38a:	63e3      	str	r3, [r4, #60]	; 0x3c
 800a38c:	e7f1      	b.n	800a372 <HAL_TIM_OC_DelayElapsedCallback+0xba>
          ud->offset++;
 800a38e:	3301      	adds	r3, #1
 800a390:	63e3      	str	r3, [r4, #60]	; 0x3c
 800a392:	0008      	movs	r0, r1
 800a394:	e7de      	b.n	800a354 <HAL_TIM_OC_DelayElapsedCallback+0x9c>
 800a396:	46c0      	nop			; (mov r8, r8)
      memcpy(&temp_data, &pbuff_in[ud->index], 3);
 800a398:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 800a39a:	2203      	movs	r2, #3
 800a39c:	19f1      	adds	r1, r6, r7
 800a39e:	a803      	add	r0, sp, #12
 800a3a0:	f002 fbfc 	bl	800cb9c <memcpy>
      ud->index += ud->offset <= 5 ? 1 : 2;
 800a3a4:	2205      	movs	r2, #5
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a3a6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800a3a8:	9d03      	ldr	r5, [sp, #12]
      ud->index += ud->offset <= 5 ? 1 : 2;
 800a3aa:	429a      	cmp	r2, r3
 800a3ac:	4192      	sbcs	r2, r2
 800a3ae:	4252      	negs	r2, r2
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a3b0:	40dd      	lsrs	r5, r3
      ud->index += ud->offset <= 5 ? 1 : 2;
 800a3b2:	3201      	adds	r2, #1
 800a3b4:	18bf      	adds	r7, r7, r2
      ud->offset = (ud->offset + 2) & 7;
 800a3b6:	2207      	movs	r2, #7
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a3b8:	05a9      	lsls	r1, r5, #22
      ud->offset = (ud->offset + 2) & 7;
 800a3ba:	3302      	adds	r3, #2
 800a3bc:	4013      	ands	r3, r2
      temp_data = (temp_data >> ud->offset) & 0x3FF;
 800a3be:	0d89      	lsrs	r1, r1, #22
 800a3c0:	9103      	str	r1, [sp, #12]
      ud->offset = (ud->offset + 2) & 7;
 800a3c2:	63e3      	str	r3, [r4, #60]	; 0x3c
      if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate != NULL)
 800a3c4:	23e4      	movs	r3, #228	; 0xe4
 800a3c6:	005b      	lsls	r3, r3, #1
 800a3c8:	58e3      	ldr	r3, [r4, r3]
      ud->index += ud->offset <= 5 ? 1 : 2;
 800a3ca:	63a7      	str	r7, [r4, #56]	; 0x38
      if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate != NULL)
 800a3cc:	2b00      	cmp	r3, #0
 800a3ce:	d001      	beq.n	800a3d4 <HAL_TIM_OC_DelayElapsedCallback+0x11c>
        Ports[PortNum].cbs.USBPD_HW_IF_RX_Accumulate(PortNum, temp_data);
 800a3d0:	2000      	movs	r0, #0
 800a3d2:	4798      	blx	r3
      if ((temp_data & 0x1F) == 0x0D) /* EOP */
 800a3d4:	231f      	movs	r3, #31
 800a3d6:	401d      	ands	r5, r3
 800a3d8:	2d0d      	cmp	r5, #13
 800a3da:	d000      	beq.n	800a3de <HAL_TIM_OC_DelayElapsedCallback+0x126>
 800a3dc:	e777      	b.n	800a2ce <HAL_TIM_OC_DelayElapsedCallback+0x16>
        ud->exed_flag = 2;
 800a3de:	0023      	movs	r3, r4
 800a3e0:	2202      	movs	r2, #2
 800a3e2:	332c      	adds	r3, #44	; 0x2c
 800a3e4:	e7ce      	b.n	800a384 <HAL_TIM_OC_DelayElapsedCallback+0xcc>
           ((RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR)>(ud->index + 2)) &&                /* checking if in the buffer the are enough data */
 800a3e6:	0022      	movs	r2, r4
 800a3e8:	213c      	movs	r1, #60	; 0x3c
 800a3ea:	32e8      	adds	r2, #232	; 0xe8
 800a3ec:	6812      	ldr	r2, [r2, #0]
 800a3ee:	3302      	adds	r3, #2
 800a3f0:	6852      	ldr	r2, [r2, #4]
 800a3f2:	1a8a      	subs	r2, r1, r2
         (ud->exed_flag == 0) &&
 800a3f4:	429a      	cmp	r2, r3
 800a3f6:	d800      	bhi.n	800a3fa <HAL_TIM_OC_DelayElapsedCallback+0x142>
 800a3f8:	e770      	b.n	800a2dc <HAL_TIM_OC_DelayElapsedCallback+0x24>
             (Ports[PortNum].htimcountrx.Instance->CNT < tim_count + DMA_TIME_TASK) &&
 800a3fa:	0023      	movs	r3, r4
 800a3fc:	33fc      	adds	r3, #252	; 0xfc
 800a3fe:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800a400:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a402:	9b01      	ldr	r3, [sp, #4]
 800a404:	3314      	adds	r3, #20
           ((RX_BUFFER_SIZE - Ports[PortNum].hdmarx.Instance->CNDTR)>(ud->index + 2)) &&                /* checking if in the buffer the are enough data */
 800a406:	429a      	cmp	r2, r3
 800a408:	d300      	bcc.n	800a40c <HAL_TIM_OC_DelayElapsedCallback+0x154>
 800a40a:	e767      	b.n	800a2dc <HAL_TIM_OC_DelayElapsedCallback+0x24>
               (HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET)        /* stopping the decoding in case of NSS is high */
 800a40c:	2180      	movs	r1, #128	; 0x80
 800a40e:	4811      	ldr	r0, [pc, #68]	; (800a454 <HAL_TIM_OC_DelayElapsedCallback+0x19c>)
 800a410:	0149      	lsls	r1, r1, #5
 800a412:	f7fd fb8d 	bl	8007b30 <HAL_GPIO_ReadPin>
             (Ports[PortNum].htimcountrx.Instance->CNT < tim_count + DMA_TIME_TASK) &&
 800a416:	2800      	cmp	r0, #0
 800a418:	d000      	beq.n	800a41c <HAL_TIM_OC_DelayElapsedCallback+0x164>
 800a41a:	e75f      	b.n	800a2dc <HAL_TIM_OC_DelayElapsedCallback+0x24>
    if (pbuff_in[ud->index]==0xFF)
 800a41c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800a41e:	5cf3      	ldrb	r3, [r6, r3]
 800a420:	2bff      	cmp	r3, #255	; 0xff
 800a422:	d100      	bne.n	800a426 <HAL_TIM_OC_DelayElapsedCallback+0x16e>
 800a424:	46c0      	nop			; (mov r8, r8)
    if (!ud->preamble)                  /* The end of preamble hasn't identified yet */ 
 800a426:	0023      	movs	r3, r4
 800a428:	332d      	adds	r3, #45	; 0x2d
 800a42a:	781b      	ldrb	r3, [r3, #0]
 800a42c:	2b00      	cmp	r3, #0
 800a42e:	d1b2      	bne.n	800a396 <HAL_TIM_OC_DelayElapsedCallback+0xde>
      r = pbuff_in[ud->index]^0xAA;
 800a430:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800a432:	3b56      	subs	r3, #86	; 0x56
 800a434:	18b5      	adds	r5, r6, r2
 800a436:	7829      	ldrb	r1, [r5, #0]
 800a438:	404b      	eors	r3, r1
      if (r == 0x00 || r == 0xFF)       /* The end of preamble is not part of the received data */ 
 800a43a:	3b01      	subs	r3, #1
 800a43c:	b2db      	uxtb	r3, r3
 800a43e:	2bfd      	cmp	r3, #253	; 0xfd
 800a440:	d984      	bls.n	800a34c <HAL_TIM_OC_DelayElapsedCallback+0x94>
        ud->index++;
 800a442:	3201      	adds	r2, #1
 800a444:	63a2      	str	r2, [r4, #56]	; 0x38
 800a446:	e742      	b.n	800a2ce <HAL_TIM_OC_DelayElapsedCallback+0x16>
 800a448:	20000058 	.word	0x20000058
 800a44c:	20001c80 	.word	0x20001c80
 800a450:	20001d80 	.word	0x20001d80
 800a454:	48000400 	.word	0x48000400

0800a458 <PHY_HW_IF_TX_Done>:
  if (Ports[PortNum].TxSpareBits == 0)
 800a458:	23f0      	movs	r3, #240	; 0xf0
 800a45a:	005b      	lsls	r3, r3, #1
 800a45c:	4343      	muls	r3, r0
{
 800a45e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (Ports[PortNum].TxSpareBits == 0)
 800a460:	4d5e      	ldr	r5, [pc, #376]	; (800a5dc <PHY_HW_IF_TX_Done+0x184>)
{
 800a462:	0004      	movs	r4, r0
  if (Ports[PortNum].TxSpareBits == 0)
 800a464:	18eb      	adds	r3, r5, r3
 800a466:	001a      	movs	r2, r3
 800a468:	322a      	adds	r2, #42	; 0x2a
 800a46a:	7812      	ldrb	r2, [r2, #0]
    while (((((Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL)) >> SPI_SR_FTLVL_Pos) & 0x03) > 1)
 800a46c:	2103      	movs	r1, #3
  if (Ports[PortNum].TxSpareBits == 0)
 800a46e:	2a00      	cmp	r2, #0
 800a470:	d143      	bne.n	800a4fa <PHY_HW_IF_TX_Done+0xa2>
 800a472:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    if (Ports[PortNum].Device_cut == Cut_1)
 800a474:	33d9      	adds	r3, #217	; 0xd9
 800a476:	33ff      	adds	r3, #255	; 0xff
 800a478:	7819      	ldrb	r1, [r3, #0]
 800a47a:	2903      	cmp	r1, #3
 800a47c:	d005      	beq.n	800a48a <PHY_HW_IF_TX_Done+0x32>
      while ( (Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL) != 0);  /* != 0x0800 */
 800a47e:	23c0      	movs	r3, #192	; 0xc0
 800a480:	015b      	lsls	r3, r3, #5
 800a482:	6891      	ldr	r1, [r2, #8]
 800a484:	4219      	tst	r1, r3
 800a486:	d1fc      	bne.n	800a482 <PHY_HW_IF_TX_Done+0x2a>
 800a488:	e004      	b.n	800a494 <PHY_HW_IF_TX_Done+0x3c>
      while (((((Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL)) >> SPI_SR_FTLVL_Pos) & 0x03) > 1);
 800a48a:	6893      	ldr	r3, [r2, #8]
 800a48c:	0adb      	lsrs	r3, r3, #11
 800a48e:	400b      	ands	r3, r1
 800a490:	2b01      	cmp	r3, #1
 800a492:	d8fa      	bhi.n	800a48a <PHY_HW_IF_TX_Done+0x32>
  while ( (Ports[PortNum].hspi.Instance->SR & SPI_SR_BSY) > 0);
 800a494:	23f0      	movs	r3, #240	; 0xf0
 800a496:	005b      	lsls	r3, r3, #1
 800a498:	001a      	movs	r2, r3
 800a49a:	4362      	muls	r2, r4
 800a49c:	18aa      	adds	r2, r5, r2
 800a49e:	6c10      	ldr	r0, [r2, #64]	; 0x40
 800a4a0:	2280      	movs	r2, #128	; 0x80
 800a4a2:	6881      	ldr	r1, [r0, #8]
 800a4a4:	4211      	tst	r1, r2
 800a4a6:	d1fc      	bne.n	800a4a2 <PHY_HW_IF_TX_Done+0x4a>
  if (Ports[PortNum].Device_cut == Cut_1)
 800a4a8:	4363      	muls	r3, r4
 800a4aa:	18eb      	adds	r3, r5, r3
 800a4ac:	001a      	movs	r2, r3
 800a4ae:	32d9      	adds	r2, #217	; 0xd9
 800a4b0:	32ff      	adds	r2, #255	; 0xff
 800a4b2:	7812      	ldrb	r2, [r2, #0]
 800a4b4:	2a03      	cmp	r2, #3
 800a4b6:	d027      	beq.n	800a508 <PHY_HW_IF_TX_Done+0xb0>
 800a4b8:	2708      	movs	r7, #8
 800a4ba:	2c00      	cmp	r4, #0
 800a4bc:	d101      	bne.n	800a4c2 <PHY_HW_IF_TX_Done+0x6a>
 800a4be:	4b48      	ldr	r3, [pc, #288]	; (800a5e0 <PHY_HW_IF_TX_Done+0x188>)
 800a4c0:	881f      	ldrh	r7, [r3, #0]
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 800a4c2:	23f0      	movs	r3, #240	; 0xf0
 800a4c4:	2600      	movs	r6, #0
 800a4c6:	005b      	lsls	r3, r3, #1
 800a4c8:	4363      	muls	r3, r4
 800a4ca:	18eb      	adds	r3, r5, r3
 800a4cc:	332a      	adds	r3, #42	; 0x2a
 800a4ce:	b2bf      	uxth	r7, r7
 800a4d0:	9301      	str	r3, [sp, #4]
 800a4d2:	9b01      	ldr	r3, [sp, #4]
 800a4d4:	781b      	ldrb	r3, [r3, #0]
 800a4d6:	42b3      	cmp	r3, r6
 800a4d8:	d933      	bls.n	800a542 <PHY_HW_IF_TX_Done+0xea>
      while (!HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 800a4da:	0039      	movs	r1, r7
 800a4dc:	4841      	ldr	r0, [pc, #260]	; (800a5e4 <PHY_HW_IF_TX_Done+0x18c>)
 800a4de:	f7fd fb27 	bl	8007b30 <HAL_GPIO_ReadPin>
 800a4e2:	2800      	cmp	r0, #0
 800a4e4:	d0f9      	beq.n	800a4da <PHY_HW_IF_TX_Done+0x82>
      while (HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 800a4e6:	0039      	movs	r1, r7
 800a4e8:	483e      	ldr	r0, [pc, #248]	; (800a5e4 <PHY_HW_IF_TX_Done+0x18c>)
 800a4ea:	f7fd fb21 	bl	8007b30 <HAL_GPIO_ReadPin>
 800a4ee:	2800      	cmp	r0, #0
 800a4f0:	d1f9      	bne.n	800a4e6 <PHY_HW_IF_TX_Done+0x8e>
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 800a4f2:	3601      	adds	r6, #1
 800a4f4:	b2f6      	uxtb	r6, r6
 800a4f6:	e7ec      	b.n	800a4d2 <PHY_HW_IF_TX_Done+0x7a>
 800a4f8:	46c0      	nop			; (mov r8, r8)
    while (((((Ports[PortNum].hspi.Instance->SR & SPI_SR_FTLVL)) >> SPI_SR_FTLVL_Pos) & 0x03) > 1)
 800a4fa:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800a4fc:	6892      	ldr	r2, [r2, #8]
 800a4fe:	0ad2      	lsrs	r2, r2, #11
 800a500:	400a      	ands	r2, r1
 800a502:	2a01      	cmp	r2, #1
 800a504:	d8f8      	bhi.n	800a4f8 <PHY_HW_IF_TX_Done+0xa0>
 800a506:	e7c5      	b.n	800a494 <PHY_HW_IF_TX_Done+0x3c>
 800a508:	332a      	adds	r3, #42	; 0x2a
 800a50a:	781a      	ldrb	r2, [r3, #0]
    if (Ports[PortNum].TxSpareBits == 0)
 800a50c:	2a00      	cmp	r2, #0
 800a50e:	d14f      	bne.n	800a5b0 <PHY_HW_IF_TX_Done+0x158>
      Ports[PortNum].TxSpareBits = 7;
 800a510:	3207      	adds	r2, #7
      Ports[PortNum].TxSpareBits = (Ports[PortNum].TxSpareBits - 1);
 800a512:	701a      	strb	r2, [r3, #0]
 800a514:	2608      	movs	r6, #8
 800a516:	2c00      	cmp	r4, #0
 800a518:	d101      	bne.n	800a51e <PHY_HW_IF_TX_Done+0xc6>
 800a51a:	4b31      	ldr	r3, [pc, #196]	; (800a5e0 <PHY_HW_IF_TX_Done+0x188>)
 800a51c:	881e      	ldrh	r6, [r3, #0]
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 800a51e:	23f0      	movs	r3, #240	; 0xf0
{
 800a520:	2700      	movs	r7, #0
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 800a522:	005b      	lsls	r3, r3, #1
 800a524:	4363      	muls	r3, r4
 800a526:	18eb      	adds	r3, r5, r3
 800a528:	332a      	adds	r3, #42	; 0x2a
 800a52a:	b2b6      	uxth	r6, r6
 800a52c:	9301      	str	r3, [sp, #4]
 800a52e:	9b01      	ldr	r3, [sp, #4]
 800a530:	781b      	ldrb	r3, [r3, #0]
 800a532:	42bb      	cmp	r3, r7
 800a534:	d83e      	bhi.n	800a5b4 <PHY_HW_IF_TX_Done+0x15c>
    while (HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 800a536:	0031      	movs	r1, r6
 800a538:	482a      	ldr	r0, [pc, #168]	; (800a5e4 <PHY_HW_IF_TX_Done+0x18c>)
 800a53a:	f7fd faf9 	bl	8007b30 <HAL_GPIO_ReadPin>
 800a53e:	2800      	cmp	r0, #0
 800a540:	d1f9      	bne.n	800a536 <PHY_HW_IF_TX_Done+0xde>
  STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_RESET);
 800a542:	2100      	movs	r1, #0
 800a544:	0020      	movs	r0, r4
 800a546:	f000 feed 	bl	800b324 <STUSB16xx_HW_IF_TX_EN_Status>
  __HAL_SPI_DISABLE(&Ports[PortNum].hspi);
 800a54a:	23f0      	movs	r3, #240	; 0xf0
 800a54c:	005b      	lsls	r3, r3, #1
 800a54e:	001a      	movs	r2, r3
 800a550:	2040      	movs	r0, #64	; 0x40
 800a552:	4362      	muls	r2, r4
 800a554:	18aa      	adds	r2, r5, r2
 800a556:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a558:	6811      	ldr	r1, [r2, #0]
 800a55a:	4381      	bics	r1, r0
 800a55c:	6011      	str	r1, [r2, #0]
  while ((Ports[PortNum].hspi.Instance->SR & SPI_SR_FRLVL) != 0)
 800a55e:	21c0      	movs	r1, #192	; 0xc0
 800a560:	00c9      	lsls	r1, r1, #3
 800a562:	6896      	ldr	r6, [r2, #8]
 800a564:	400e      	ands	r6, r1
 800a566:	d134      	bne.n	800a5d2 <PHY_HW_IF_TX_Done+0x17a>
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a568:	4363      	muls	r3, r4
 800a56a:	0018      	movs	r0, r3
 800a56c:	001f      	movs	r7, r3
 800a56e:	3040      	adds	r0, #64	; 0x40
 800a570:	1828      	adds	r0, r5, r0
  if(Ports[PortNum].State==HAL_USBPD_PORT_STATE_BIST)
 800a572:	19ef      	adds	r7, r5, r7
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a574:	f7fe f9e4 	bl	8008940 <HAL_SPI_DMAStop>
  if(Ports[PortNum].State==HAL_USBPD_PORT_STATE_BIST)
 800a578:	7e7a      	ldrb	r2, [r7, #25]
 800a57a:	2a08      	cmp	r2, #8
 800a57c:	d12b      	bne.n	800a5d6 <PHY_HW_IF_TX_Done+0x17e>
    Ports[PortNum].State=HAL_USBPD_PORT_STATE_RESET;
 800a57e:	767e      	strb	r6, [r7, #25]
    if ((Ports[PortNum].cbs.USBPD_HW_IF_BistCompleted != NULL) )
 800a580:	37c1      	adds	r7, #193	; 0xc1
 800a582:	37ff      	adds	r7, #255	; 0xff
 800a584:	683b      	ldr	r3, [r7, #0]
 800a586:	2b00      	cmp	r3, #0
 800a588:	d002      	beq.n	800a590 <PHY_HW_IF_TX_Done+0x138>
      Ports[PortNum].cbs.USBPD_HW_IF_BistCompleted(PortNum,USBPD_BIST_CARRIER_MODE2);
 800a58a:	2105      	movs	r1, #5
 800a58c:	0020      	movs	r0, r4
 800a58e:	4798      	blx	r3
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_RX);
 800a590:	2101      	movs	r1, #1
 800a592:	0020      	movs	r0, r4
 800a594:	f000 feb8 	bl	800b308 <STUSB16xx_HW_IF_Switch_Mode>
  if (Ports[PortNum].cbs.USBPD_HW_IF_TxCompleted != NULL)
 800a598:	23f0      	movs	r3, #240	; 0xf0
 800a59a:	005b      	lsls	r3, r3, #1
 800a59c:	4363      	muls	r3, r4
 800a59e:	18ed      	adds	r5, r5, r3
 800a5a0:	35bd      	adds	r5, #189	; 0xbd
 800a5a2:	35ff      	adds	r5, #255	; 0xff
 800a5a4:	682b      	ldr	r3, [r5, #0]
 800a5a6:	2b00      	cmp	r3, #0
 800a5a8:	d001      	beq.n	800a5ae <PHY_HW_IF_TX_Done+0x156>
    Ports[PortNum].cbs.USBPD_HW_IF_TxCompleted(PortNum);
 800a5aa:	0020      	movs	r0, r4
 800a5ac:	4798      	blx	r3
}
 800a5ae:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
      Ports[PortNum].TxSpareBits = (Ports[PortNum].TxSpareBits - 1);
 800a5b0:	3a01      	subs	r2, #1
 800a5b2:	e7ae      	b.n	800a512 <PHY_HW_IF_TX_Done+0xba>
      while (HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 800a5b4:	0031      	movs	r1, r6
 800a5b6:	480b      	ldr	r0, [pc, #44]	; (800a5e4 <PHY_HW_IF_TX_Done+0x18c>)
 800a5b8:	f7fd faba 	bl	8007b30 <HAL_GPIO_ReadPin>
 800a5bc:	2800      	cmp	r0, #0
 800a5be:	d1f9      	bne.n	800a5b4 <PHY_HW_IF_TX_Done+0x15c>
      while (!HAL_GPIO_ReadPin(SPI_CLK_PORT(PortNum), SPI_CLK_PIN(PortNum)));
 800a5c0:	0031      	movs	r1, r6
 800a5c2:	4808      	ldr	r0, [pc, #32]	; (800a5e4 <PHY_HW_IF_TX_Done+0x18c>)
 800a5c4:	f7fd fab4 	bl	8007b30 <HAL_GPIO_ReadPin>
 800a5c8:	2800      	cmp	r0, #0
 800a5ca:	d0f9      	beq.n	800a5c0 <PHY_HW_IF_TX_Done+0x168>
    for(i=0; i<(Ports[PortNum].TxSpareBits); i++)
 800a5cc:	3701      	adds	r7, #1
 800a5ce:	b2ff      	uxtb	r7, r7
 800a5d0:	e7ad      	b.n	800a52e <PHY_HW_IF_TX_Done+0xd6>
    dummyDR= *(__IO uint8_t *)&Ports[PortNum].hspi.Instance->DR;
 800a5d2:	7b10      	ldrb	r0, [r2, #12]
 800a5d4:	e7c5      	b.n	800a562 <PHY_HW_IF_TX_Done+0x10a>
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_WAITING;
 800a5d6:	2205      	movs	r2, #5
 800a5d8:	767a      	strb	r2, [r7, #25]
 800a5da:	e7d9      	b.n	800a590 <PHY_HW_IF_TX_Done+0x138>
 800a5dc:	20000058 	.word	0x20000058
 800a5e0:	0800ced4 	.word	0x0800ced4
 800a5e4:	48000400 	.word	0x48000400

0800a5e8 <HW_IF_CRC_Init>:
  hcrc.Instance = CRC;
 800a5e8:	4807      	ldr	r0, [pc, #28]	; (800a608 <HW_IF_CRC_Init+0x20>)
 800a5ea:	4b08      	ldr	r3, [pc, #32]	; (800a60c <HW_IF_CRC_Init+0x24>)
{
 800a5ec:	b510      	push	{r4, lr}
  hcrc.Instance = CRC;
 800a5ee:	6003      	str	r3, [r0, #0]
 800a5f0:	2300      	movs	r3, #0
 800a5f2:	8083      	strh	r3, [r0, #4]
  hcrc.Init.InputDataInversionMode =   CRC_INPUTDATA_INVERSION_BYTE;           /* The input data are inverted by WORD */
 800a5f4:	3320      	adds	r3, #32
 800a5f6:	6143      	str	r3, [r0, #20]
  hcrc.Init.OutputDataInversionMode =   CRC_OUTPUTDATA_INVERSION_ENABLE;        /* The output data are Bit-reversed format */
 800a5f8:	3360      	adds	r3, #96	; 0x60
 800a5fa:	6183      	str	r3, [r0, #24]
  hcrc.InputDataFormat =           CRC_INPUTDATA_FORMAT_BYTES;             /* The input data are 32 bits lenght */
 800a5fc:	3b7f      	subs	r3, #127	; 0x7f
 800a5fe:	6203      	str	r3, [r0, #32]
  HAL_CRC_Init(&hcrc);
 800a600:	f7fd f893 	bl	800772a <HAL_CRC_Init>
}
 800a604:	bd10      	pop	{r4, pc}
 800a606:	46c0      	nop			; (mov r8, r8)
 800a608:	20001cdc 	.word	0x20001cdc
 800a60c:	40023000 	.word	0x40023000

0800a610 <HW_IF_ADC_Init>:
{
 800a610:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  usbpdm1_hadc.Instance = HW_IF_ADC;
 800a612:	4c17      	ldr	r4, [pc, #92]	; (800a670 <HW_IF_ADC_Init+0x60>)
 800a614:	4b17      	ldr	r3, [pc, #92]	; (800a674 <HW_IF_ADC_Init+0x64>)
  usbpdm1_hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 800a616:	2201      	movs	r2, #1
  usbpdm1_hadc.Instance = HW_IF_ADC;
 800a618:	6023      	str	r3, [r4, #0]
  usbpdm1_hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 800a61a:	2104      	movs	r1, #4
  usbpdm1_hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 800a61c:	2300      	movs	r3, #0
  HAL_ADC_Init(&usbpdm1_hadc);
 800a61e:	0020      	movs	r0, r4
  usbpdm1_hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 800a620:	6122      	str	r2, [r4, #16]
  usbpdm1_hadc.Init.ContinuousConvMode = ENABLE;
 800a622:	6222      	str	r2, [r4, #32]
  usbpdm1_hadc.Init.DMAContinuousRequests = ENABLE;
 800a624:	6322      	str	r2, [r4, #48]	; 0x30
  usbpdm1_hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 800a626:	6362      	str	r2, [r4, #52]	; 0x34
  usbpdm1_hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 800a628:	6063      	str	r3, [r4, #4]
  usbpdm1_hadc.Init.Resolution = ADC_RESOLUTION_12B;
 800a62a:	60a3      	str	r3, [r4, #8]
  usbpdm1_hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 800a62c:	60e3      	str	r3, [r4, #12]
  usbpdm1_hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 800a62e:	6161      	str	r1, [r4, #20]
  usbpdm1_hadc.Init.LowPowerAutoWait = DISABLE;
 800a630:	61a3      	str	r3, [r4, #24]
  usbpdm1_hadc.Init.LowPowerAutoPowerOff = DISABLE;
 800a632:	61e3      	str	r3, [r4, #28]
  usbpdm1_hadc.Init.DiscontinuousConvMode = DISABLE;
 800a634:	6263      	str	r3, [r4, #36]	; 0x24
  usbpdm1_hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 800a636:	62e3      	str	r3, [r4, #44]	; 0x2c
  HAL_ADC_Init(&usbpdm1_hadc);
 800a638:	f7fc fdd4 	bl	80071e4 <HAL_ADC_Init>
  sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 800a63c:	2380      	movs	r3, #128	; 0x80
 800a63e:	015b      	lsls	r3, r3, #5
 800a640:	9302      	str	r3, [sp, #8]
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 800a642:	2380      	movs	r3, #128	; 0x80
 800a644:	055b      	lsls	r3, r3, #21
 800a646:	9303      	str	r3, [sp, #12]
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a648:	230e      	movs	r3, #14
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a64a:	a901      	add	r1, sp, #4
 800a64c:	0020      	movs	r0, r4
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a64e:	9301      	str	r3, [sp, #4]
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a650:	f7fc ff04 	bl	800745c <HAL_ADC_ConfigChannel>
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a654:	2307      	movs	r3, #7
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a656:	a901      	add	r1, sp, #4
 800a658:	0020      	movs	r0, r4
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a65a:	9301      	str	r3, [sp, #4]
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a65c:	f7fc fefe 	bl	800745c <HAL_ADC_ConfigChannel>
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a660:	230a      	movs	r3, #10
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a662:	a901      	add	r1, sp, #4
 800a664:	0020      	movs	r0, r4
    sConfig.Channel = USBPD_ADCs[ch].ADCCH;
 800a666:	9301      	str	r3, [sp, #4]
    HAL_ADC_ConfigChannel(&usbpdm1_hadc, &sConfig);
 800a668:	f7fc fef8 	bl	800745c <HAL_ADC_ConfigChannel>
}
 800a66c:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 800a66e:	46c0      	nop			; (mov r8, r8)
 800a670:	20001c84 	.word	0x20001c84
 800a674:	40012400 	.word	0x40012400

0800a678 <USBPD_HW_IF_GlobalHwInit>:
{
 800a678:	b510      	push	{r4, lr}
  HW_IF_ADC_Init();
 800a67a:	f7ff ffc9 	bl	800a610 <HW_IF_ADC_Init>
  HAL_ADCEx_Calibration_Start(&usbpdm1_hadc);
 800a67e:	4c08      	ldr	r4, [pc, #32]	; (800a6a0 <USBPD_HW_IF_GlobalHwInit+0x28>)
 800a680:	0020      	movs	r0, r4
 800a682:	f7fc ff6b 	bl	800755c <HAL_ADCEx_Calibration_Start>
  HAL_ADC_Start_DMA(&usbpdm1_hadc, ADCxConvertedValues, ADCCONVERTEDVALUES_BUFFER_SIZE);
 800a686:	2203      	movs	r2, #3
 800a688:	4906      	ldr	r1, [pc, #24]	; (800a6a4 <USBPD_HW_IF_GlobalHwInit+0x2c>)
 800a68a:	0020      	movs	r0, r4
 800a68c:	f7fc fe4e 	bl	800732c <HAL_ADC_Start_DMA>
  HW_IF_CRC_Init();
 800a690:	f7ff ffaa 	bl	800a5e8 <HW_IF_CRC_Init>
  HW_IF_PWR_DigitalGPIO_Init();
 800a694:	f000 f87a 	bl	800a78c <HW_IF_PWR_DigitalGPIO_Init>
  USBPD_TIM_Init();
 800a698:	f001 f8f2 	bl	800b880 <USBPD_TIM_Init>
}
 800a69c:	bd10      	pop	{r4, pc}
 800a69e:	46c0      	nop			; (mov r8, r8)
 800a6a0:	20001c84 	.word	0x20001c84
 800a6a4:	20001cd0 	.word	0x20001cd0

0800a6a8 <HW_IF_UnwrapData_Init>:
  ud->exed_flag =       0;
 800a6a8:	22f0      	movs	r2, #240	; 0xf0
 800a6aa:	0052      	lsls	r2, r2, #1
 800a6ac:	4342      	muls	r2, r0
 800a6ae:	490a      	ldr	r1, [pc, #40]	; (800a6d8 <HW_IF_UnwrapData_Init+0x30>)
  ud->dataindex =       0;
 800a6b0:	480a      	ldr	r0, [pc, #40]	; (800a6dc <HW_IF_UnwrapData_Init+0x34>)
  ud->exed_flag =       0;
 800a6b2:	2300      	movs	r3, #0
  ud->dataindex =       0;
 800a6b4:	1880      	adds	r0, r0, r2
  ud->exed_flag =       0;
 800a6b6:	1851      	adds	r1, r2, r1
  ud->index =           2;      /* It discards first two bytes */
 800a6b8:	2202      	movs	r2, #2
  ud->exed_flag =       0;
 800a6ba:	808b      	strh	r3, [r1, #4]
  ud->index =           2;      /* It discards first two bytes */
 800a6bc:	6382      	str	r2, [r0, #56]	; 0x38
  preamble_offset = 0;
 800a6be:	4a08      	ldr	r2, [pc, #32]	; (800a6e0 <HW_IF_UnwrapData_Init+0x38>)
  ud->dataindex =       0;
 800a6c0:	6303      	str	r3, [r0, #48]	; 0x30
  ud->dataoffset =      0;
 800a6c2:	6343      	str	r3, [r0, #52]	; 0x34
  ud->offset =          0;
 800a6c4:	63c3      	str	r3, [r0, #60]	; 0x3c
  preamble_offset = 0;
 800a6c6:	7013      	strb	r3, [r2, #0]
  preamble_index = 0;
 800a6c8:	4a06      	ldr	r2, [pc, #24]	; (800a6e4 <HW_IF_UnwrapData_Init+0x3c>)
 800a6ca:	7013      	strb	r3, [r2, #0]
  preamble_counter++;
 800a6cc:	4a06      	ldr	r2, [pc, #24]	; (800a6e8 <HW_IF_UnwrapData_Init+0x40>)
 800a6ce:	6813      	ldr	r3, [r2, #0]
 800a6d0:	3301      	adds	r3, #1
 800a6d2:	6013      	str	r3, [r2, #0]
}
 800a6d4:	4770      	bx	lr
 800a6d6:	46c0      	nop			; (mov r8, r8)
 800a6d8:	20000080 	.word	0x20000080
 800a6dc:	20000058 	.word	0x20000058
 800a6e0:	20001c80 	.word	0x20001c80
 800a6e4:	20001d80 	.word	0x20001d80
 800a6e8:	200003d0 	.word	0x200003d0

0800a6ec <PHY_HW_IF_RX_Start>:
{
 800a6ec:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset != NULL)
 800a6ee:	25f0      	movs	r5, #240	; 0xf0
 800a6f0:	006d      	lsls	r5, r5, #1
 800a6f2:	002b      	movs	r3, r5
 800a6f4:	4343      	muls	r3, r0
 800a6f6:	4e24      	ldr	r6, [pc, #144]	; (800a788 <PHY_HW_IF_RX_Start+0x9c>)
{
 800a6f8:	b085      	sub	sp, #20
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset != NULL)
 800a6fa:	18f3      	adds	r3, r6, r3
 800a6fc:	33c5      	adds	r3, #197	; 0xc5
 800a6fe:	33ff      	adds	r3, #255	; 0xff
 800a700:	681b      	ldr	r3, [r3, #0]
{
 800a702:	0004      	movs	r4, r0
  if (Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset != NULL)
 800a704:	2b00      	cmp	r3, #0
 800a706:	d000      	beq.n	800a70a <PHY_HW_IF_RX_Start+0x1e>
    Ports[PortNum].cbs.USBPD_HW_IF_RX_Reset(PortNum);
 800a708:	4798      	blx	r3
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_RX;
 800a70a:	2304      	movs	r3, #4
 800a70c:	4365      	muls	r5, r4
 800a70e:	9501      	str	r5, [sp, #4]
 800a710:	1975      	adds	r5, r6, r5
 800a712:	766b      	strb	r3, [r5, #25]
  HW_IF_UnwrapData_Init(PortNum);
 800a714:	0020      	movs	r0, r4
 800a716:	f7ff ffc7 	bl	800a6a8 <HW_IF_UnwrapData_Init>
    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800a71a:	9f01      	ldr	r7, [sp, #4]
 800a71c:	3740      	adds	r7, #64	; 0x40
 800a71e:	19f7      	adds	r7, r6, r7
 800a720:	0038      	movs	r0, r7
 800a722:	f7fe f90d 	bl	8008940 <HAL_SPI_DMAStop>
  __IO uint32_t a = 0x0;
 800a726:	2300      	movs	r3, #0
 800a728:	9303      	str	r3, [sp, #12]
  while(local_hspi->Instance->SR & 0x01)
 800a72a:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800a72c:	2201      	movs	r2, #1
 800a72e:	689d      	ldr	r5, [r3, #8]
 800a730:	4015      	ands	r5, r2
 800a732:	d125      	bne.n	800a780 <PHY_HW_IF_RX_Start+0x94>
  memset(Ports[PortNum].pRxBuffPtr, 0x00, RX_BUFFER_SIZE);
 800a734:	23f0      	movs	r3, #240	; 0xf0
 800a736:	005b      	lsls	r3, r3, #1
 800a738:	435c      	muls	r4, r3
 800a73a:	1934      	adds	r4, r6, r4
 800a73c:	0029      	movs	r1, r5
 800a73e:	323b      	adds	r2, #59	; 0x3b
 800a740:	68e0      	ldr	r0, [r4, #12]
 800a742:	f002 fa34 	bl	800cbae <memset>
  HAL_SPI_Receive_DMA(&Ports[PortNum].hspi, (uint8_t*)Ports[PortNum].pRxBuffPtr, RX_BUFFER_SIZE);
 800a746:	68e1      	ldr	r1, [r4, #12]
 800a748:	223c      	movs	r2, #60	; 0x3c
 800a74a:	0038      	movs	r0, r7
 800a74c:	f7fe f846 	bl	80087dc <HAL_SPI_Receive_DMA>
  Ports[PortNum].modulo = 0;
 800a750:	0023      	movs	r3, r4
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a752:	2101      	movs	r1, #1
  Ports[PortNum].modulo = 0;
 800a754:	33dd      	adds	r3, #221	; 0xdd
 800a756:	33ff      	adds	r3, #255	; 0xff
 800a758:	701d      	strb	r5, [r3, #0]
  Ports[PortNum].ud_index_current[0]=0;
 800a75a:	3b03      	subs	r3, #3
 800a75c:	701d      	strb	r5, [r3, #0]
  Ports[PortNum].ud_index_current[1]=0;
 800a75e:	705d      	strb	r5, [r3, #1]
  Ports[PortNum].ud_index_current[2]=0;
 800a760:	709d      	strb	r5, [r3, #2]
  (Ports[PortNum].htimcountrx).Instance->CNT = 0;
 800a762:	34fc      	adds	r4, #252	; 0xfc
 800a764:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a766:	9801      	ldr	r0, [sp, #4]
  (Ports[PortNum].htimcountrx).Instance->CNT = 0;
 800a768:	6255      	str	r5, [r2, #36]	; 0x24
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a76a:	6953      	ldr	r3, [r2, #20]
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a76c:	3079      	adds	r0, #121	; 0x79
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a76e:	430b      	orrs	r3, r1
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a770:	30ff      	adds	r0, #255	; 0xff
  SET_BIT((Ports[PortNum].htimcountrx).Instance ->EGR, TIM_EGR_UG);
 800a772:	6153      	str	r3, [r2, #20]
  HAL_TIM_OC_Start_IT(&(Ports[PortNum].htimcountrx), RX_COUNTTIMCH(PortNum));
 800a774:	1830      	adds	r0, r6, r0
 800a776:	0029      	movs	r1, r5
 800a778:	f7fe fc1c 	bl	8008fb4 <HAL_TIM_OC_Start_IT>
}
 800a77c:	b005      	add	sp, #20
 800a77e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a = local_hspi->Instance->DR;
 800a780:	68da      	ldr	r2, [r3, #12]
 800a782:	9203      	str	r2, [sp, #12]
    UNUSED(a);
 800a784:	9a03      	ldr	r2, [sp, #12]
 800a786:	e7d1      	b.n	800a72c <PHY_HW_IF_RX_Start+0x40>
 800a788:	20000058 	.word	0x20000058

0800a78c <HW_IF_PWR_DigitalGPIO_Init>:
/**
  * @brief  Inititialization of the Power Pins.
  * @retval HAL Status
  */
HAL_StatusTypeDef HW_IF_PWR_DigitalGPIO_Init()
{
 800a78c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a78e:	2500      	movs	r5, #0
 800a790:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef  GPIO_InitStruct;
  uint8_t index = 0;
  for(index=0;index<USBPD_POWSELn;index++)
  {
    USBPD_BSP_GPIOPins_TypeDef gpio = USBPD_POWSELs[index];
 800a792:	ac02      	add	r4, sp, #8
 800a794:	0021      	movs	r1, r4
 800a796:	4b10      	ldr	r3, [pc, #64]	; (800a7d8 <HW_IF_PWR_DigitalGPIO_Init+0x4c>)
 800a798:	195a      	adds	r2, r3, r5
 800a79a:	cac1      	ldmia	r2!, {r0, r6, r7}
 800a79c:	c1c1      	stmia	r1!, {r0, r6, r7}
 800a79e:	58ee      	ldr	r6, [r5, r3]
 800a7a0:	195b      	adds	r3, r3, r5
 800a7a2:	889b      	ldrh	r3, [r3, #4]

    /* Configure the powsels pin */
    GPIO_InitStruct.Pin = gpio.GPIO_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a7a4:	2700      	movs	r7, #0
    USBPD_BSP_GPIOPins_TypeDef gpio = USBPD_POWSELs[index];
 800a7a6:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pin = gpio.GPIO_Pin;
 800a7a8:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a7aa:	2301      	movs	r3, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;

    HAL_GPIO_Init(gpio.GPIOx, &GPIO_InitStruct);
 800a7ac:	a905      	add	r1, sp, #20
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800a7ae:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(gpio.GPIOx, &GPIO_InitStruct);
 800a7b0:	0030      	movs	r0, r6
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800a7b2:	3302      	adds	r3, #2
 800a7b4:	9308      	str	r3, [sp, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a7b6:	9707      	str	r7, [sp, #28]
    HAL_GPIO_Init(gpio.GPIOx, &GPIO_InitStruct);
 800a7b8:	f7fd f8fe 	bl	80079b8 <HAL_GPIO_Init>

    /* Turn the pin off */
    USBPD_HW_IF_GPIO_Off(gpio);
 800a7bc:	9b01      	ldr	r3, [sp, #4]
 800a7be:	0030      	movs	r0, r6
 800a7c0:	80a3      	strh	r3, [r4, #4]
 800a7c2:	6861      	ldr	r1, [r4, #4]
 800a7c4:	68a2      	ldr	r2, [r4, #8]
 800a7c6:	350c      	adds	r5, #12
 800a7c8:	9602      	str	r6, [sp, #8]
 800a7ca:	f7ff fc87 	bl	800a0dc <USBPD_HW_IF_GPIO_Off>
  for(index=0;index<USBPD_POWSELn;index++)
 800a7ce:	2d30      	cmp	r5, #48	; 0x30
 800a7d0:	d1df      	bne.n	800a792 <HW_IF_PWR_DigitalGPIO_Init+0x6>
  }

  return HAL_OK;
}
 800a7d2:	0038      	movs	r0, r7
 800a7d4:	b00b      	add	sp, #44	; 0x2c
 800a7d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a7d8:	0800ce7c 	.word	0x0800ce7c

0800a7dc <HW_IF_PWR_SetVoltage>:
USBPD_StatusTypeDef HW_IF_PWR_SetVoltage(uint8_t PortNum, uint16_t voltage)
{
 USBPD_StatusTypeDef ret = USBPD_OK;
#if _PPS==USBPD_FALSE

 set_voltage=voltage;
 800a7dc:	4b2f      	ldr	r3, [pc, #188]	; (800a89c <HW_IF_PWR_SetVoltage+0xc0>)
{
 800a7de:	b510      	push	{r4, lr}
 set_voltage=voltage;
 800a7e0:	8019      	strh	r1, [r3, #0]
   * |  0   |  1   |  0   |  0   | 15V  |
   * |  1   |  0   |  0   |  0   | 20V  |
   * +------+------+------+------+------+
   */

 switch (voltage)
 800a7e2:	4b2f      	ldr	r3, [pc, #188]	; (800a8a0 <HW_IF_PWR_SetVoltage+0xc4>)
 800a7e4:	4299      	cmp	r1, r3
 800a7e6:	d032      	beq.n	800a84e <HW_IF_PWR_SetVoltage+0x72>
 800a7e8:	d804      	bhi.n	800a7f4 <HW_IF_PWR_SetVoltage+0x18>
 800a7ea:	4b2e      	ldr	r3, [pc, #184]	; (800a8a4 <HW_IF_PWR_SetVoltage+0xc8>)
 800a7ec:	4299      	cmp	r1, r3
 800a7ee:	d010      	beq.n	800a812 <HW_IF_PWR_SetVoltage+0x36>
 {
   case 5000:
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a7f0:	2200      	movs	r2, #0
 800a7f2:	e006      	b.n	800a802 <HW_IF_PWR_SetVoltage+0x26>
 switch (voltage)
 800a7f4:	4b2c      	ldr	r3, [pc, #176]	; (800a8a8 <HW_IF_PWR_SetVoltage+0xcc>)
 800a7f6:	4299      	cmp	r1, r3
 800a7f8:	d040      	beq.n	800a87c <HW_IF_PWR_SetVoltage+0xa0>
 800a7fa:	4b2c      	ldr	r3, [pc, #176]	; (800a8ac <HW_IF_PWR_SetVoltage+0xd0>)
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  1);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 0);
       break;
   case 20000:
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  1);
 800a7fc:	2201      	movs	r2, #1
 switch (voltage)
 800a7fe:	4299      	cmp	r1, r3
 800a800:	d1f6      	bne.n	800a7f0 <HW_IF_PWR_SetVoltage+0x14>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  1);
 800a802:	2180      	movs	r1, #128	; 0x80
 800a804:	2090      	movs	r0, #144	; 0x90
 800a806:	0049      	lsls	r1, r1, #1
 800a808:	05c0      	lsls	r0, r0, #23
 800a80a:	f7fd f997 	bl	8007b3c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
 800a80e:	2200      	movs	r2, #0
 800a810:	e03c      	b.n	800a88c <HW_IF_PWR_SetVoltage+0xb0>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a812:	2180      	movs	r1, #128	; 0x80
 800a814:	2090      	movs	r0, #144	; 0x90
 800a816:	2200      	movs	r2, #0
 800a818:	0049      	lsls	r1, r1, #1
 800a81a:	05c0      	lsls	r0, r0, #23
 800a81c:	f7fd f98e 	bl	8007b3c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
 800a820:	2180      	movs	r1, #128	; 0x80
 800a822:	2090      	movs	r0, #144	; 0x90
 800a824:	2200      	movs	r2, #0
 800a826:	0089      	lsls	r1, r1, #2
 800a828:	05c0      	lsls	r0, r0, #23
 800a82a:	f7fd f987 	bl	8007b3c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
 800a82e:	2180      	movs	r1, #128	; 0x80
 800a830:	2090      	movs	r0, #144	; 0x90
 800a832:	2200      	movs	r2, #0
 800a834:	00c9      	lsls	r1, r1, #3
 800a836:	05c0      	lsls	r0, r0, #23
 800a838:	f7fd f980 	bl	8007b3c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 1);
 800a83c:	2201      	movs	r2, #1
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 0);
 800a83e:	2180      	movs	r1, #128	; 0x80
 800a840:	2090      	movs	r0, #144	; 0x90
 800a842:	0109      	lsls	r1, r1, #4
 800a844:	05c0      	lsls	r0, r0, #23
 800a846:	f7fd f979 	bl	8007b3c <HAL_GPIO_WritePin>

  ret=(USBPD_StatusTypeDef)STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum),voltage);

#endif
  return USBPD_OK;//ret;
}
 800a84a:	2000      	movs	r0, #0
 800a84c:	bd10      	pop	{r4, pc}
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a84e:	2180      	movs	r1, #128	; 0x80
 800a850:	2090      	movs	r0, #144	; 0x90
 800a852:	2200      	movs	r2, #0
 800a854:	0049      	lsls	r1, r1, #1
 800a856:	05c0      	lsls	r0, r0, #23
 800a858:	f7fd f970 	bl	8007b3c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
 800a85c:	2180      	movs	r1, #128	; 0x80
 800a85e:	2090      	movs	r0, #144	; 0x90
 800a860:	2200      	movs	r2, #0
 800a862:	0089      	lsls	r1, r1, #2
 800a864:	05c0      	lsls	r0, r0, #23
 800a866:	f7fd f969 	bl	8007b3c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 1);
 800a86a:	2201      	movs	r2, #1
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
 800a86c:	2180      	movs	r1, #128	; 0x80
 800a86e:	2090      	movs	r0, #144	; 0x90
 800a870:	00c9      	lsls	r1, r1, #3
 800a872:	05c0      	lsls	r0, r0, #23
 800a874:	f7fd f962 	bl	8007b3c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11, 0);
 800a878:	2200      	movs	r2, #0
 800a87a:	e7e0      	b.n	800a83e <HW_IF_PWR_SetVoltage+0x62>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8,  0);
 800a87c:	2180      	movs	r1, #128	; 0x80
 800a87e:	2090      	movs	r0, #144	; 0x90
 800a880:	2200      	movs	r2, #0
 800a882:	0049      	lsls	r1, r1, #1
 800a884:	05c0      	lsls	r0, r0, #23
 800a886:	f7fd f959 	bl	8007b3c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  1);
 800a88a:	2201      	movs	r2, #1
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9,  0);
 800a88c:	2180      	movs	r1, #128	; 0x80
 800a88e:	2090      	movs	r0, #144	; 0x90
 800a890:	0089      	lsls	r1, r1, #2
 800a892:	05c0      	lsls	r0, r0, #23
 800a894:	f7fd f952 	bl	8007b3c <HAL_GPIO_WritePin>
	   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, 0);
 800a898:	2200      	movs	r2, #0
 800a89a:	e7e7      	b.n	800a86c <HW_IF_PWR_SetVoltage+0x90>
 800a89c:	200003d8 	.word	0x200003d8
 800a8a0:	00002ee0 	.word	0x00002ee0
 800a8a4:	00002328 	.word	0x00002328
 800a8a8:	00003a98 	.word	0x00003a98
 800a8ac:	00004e20 	.word	0x00004e20

0800a8b0 <HW_IF_PWR_GetVoltage>:
uint16_t HW_IF_PWR_GetVoltage(uint8_t PortNum)
{
#ifdef __VVAR
   return (uint16_t)MVOLT(ADCxConvertedValues[VBUS_INDEX(PortNum)]);
#else
   get_voltage = (uint16_t)(STUSB1602_VBUS_Select_Status_Get(STUSB1602_I2C_Add(PortNum)));
 800a8b0:	1e43      	subs	r3, r0, #1
 800a8b2:	4198      	sbcs	r0, r3
{
 800a8b4:	b510      	push	{r4, lr}
   get_voltage = (uint16_t)(STUSB1602_VBUS_Select_Status_Get(STUSB1602_I2C_Add(PortNum)));
 800a8b6:	3028      	adds	r0, #40	; 0x28
 800a8b8:	f7fc f9dc 	bl	8006c74 <STUSB1602_VBUS_Select_Status_Get>
 800a8bc:	4b01      	ldr	r3, [pc, #4]	; (800a8c4 <HW_IF_PWR_GetVoltage+0x14>)
 800a8be:	8058      	strh	r0, [r3, #2]
   return get_voltage;
#endif
}
 800a8c0:	bd10      	pop	{r4, pc}
 800a8c2:	46c0      	nop			; (mov r8, r8)
 800a8c4:	200003d8 	.word	0x200003d8

0800a8c8 <HW_IF_PWR_GetVoltage_from_reg>:
  * @param  PortNum port index
  * @retval The voltage value
  */
uint16_t HW_IF_PWR_GetVoltage_from_reg(uint8_t PortNum)
{
  return (uint16_t)(STUSB1602_VBUS_Select_Status_Get(STUSB1602_I2C_Add(PortNum)));
 800a8c8:	1e43      	subs	r3, r0, #1
 800a8ca:	4198      	sbcs	r0, r3
{
 800a8cc:	b510      	push	{r4, lr}
  return (uint16_t)(STUSB1602_VBUS_Select_Status_Get(STUSB1602_I2C_Add(PortNum)));
 800a8ce:	3028      	adds	r0, #40	; 0x28
 800a8d0:	f7fc f9d0 	bl	8006c74 <STUSB1602_VBUS_Select_Status_Get>
}
 800a8d4:	bd10      	pop	{r4, pc}
	...

0800a8d8 <HW_IF_PWR_Enable>:
  * @param  VconnState VCONN state
  * @param  role       Power role
  * @retval USBPD status
  */
HAL_StatusTypeDef HW_IF_PWR_Enable(uint8_t PortNum, USBPD_FunctionalState state, CCxPin_TypeDef Cc, uint32_t VconnState, USBPD_PortPowerRole_TypeDef role)
{
 800a8d8:	b570      	push	{r4, r5, r6, lr}
  HAL_StatusTypeDef ret = HAL_ERROR;
#if defined(CONF_NORMAL) || defined(CONF_DEMO_FPGA)
  uint32_t offset_port = (PortNum == 0) ? 0 : 2;
 800a8da:	0004      	movs	r4, r0
    ret = HAL_OK; /* To allow compatibility with other type-c controllers */
  }

#ifdef CONF_NORMAL
  /* both pin are set off */
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a8dc:	260c      	movs	r6, #12
  uint32_t offset_port = (PortNum == 0) ? 0 : 2;
 800a8de:	1e60      	subs	r0, r4, #1
 800a8e0:	4184      	sbcs	r4, r0
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a8e2:	0033      	movs	r3, r6
  uint32_t offset_port = (PortNum == 0) ? 0 : 2;
 800a8e4:	0064      	lsls	r4, r4, #1
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a8e6:	4363      	muls	r3, r4
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
 800a8e8:	3401      	adds	r4, #1
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a8ea:	4d08      	ldr	r5, [pc, #32]	; (800a90c <HW_IF_PWR_Enable+0x34>)
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
 800a8ec:	4366      	muls	r6, r4
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port]);
 800a8ee:	5958      	ldr	r0, [r3, r5]
 800a8f0:	18eb      	adds	r3, r5, r3
 800a8f2:	6859      	ldr	r1, [r3, #4]
 800a8f4:	689a      	ldr	r2, [r3, #8]
 800a8f6:	f7ff fbf1 	bl	800a0dc <USBPD_HW_IF_GPIO_Off>
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
 800a8fa:	5970      	ldr	r0, [r6, r5]
 800a8fc:	19ad      	adds	r5, r5, r6
 800a8fe:	6869      	ldr	r1, [r5, #4]
 800a900:	68aa      	ldr	r2, [r5, #8]
 800a902:	f7ff fbeb 	bl	800a0dc <USBPD_HW_IF_GPIO_Off>
  /* set SEL1 according to the selected voltage and the table STCH2 Voltage Output */
  USBPD_HW_IF_GPIO_Off(USBPD_POWSELs[offset_port+1]);
#endif

  return ret;
}
 800a906:	2000      	movs	r0, #0
 800a908:	bd70      	pop	{r4, r5, r6, pc}
 800a90a:	46c0      	nop			; (mov r8, r8)
 800a90c:	0800ce7c 	.word	0x0800ce7c

0800a910 <HW_IF_PWR_VBUSIsEnabled>:
//  {
//    ret = (HAL_GPIO_ReadPin(USBPDM1_GPIOs[PWREN_P1].GPIOx, USBPDM1_GPIOs[PWREN_P1].GPIO_Pin) == GPIO_PIN_SET) ? USBPD_ENABLE : USBPD_DISABLE ;
//  }
//#endif
  return ret;
}
 800a910:	2000      	movs	r0, #0
 800a912:	4770      	bx	lr

0800a914 <LL_SYSCFG_SetEXTISource>:
{
 800a914:	b510      	push	{r4, lr}
  MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], SYSCFG_EXTICR1_EXTI0 << (Line >> 16), Port << (Line >> 16));
 800a916:	240f      	movs	r4, #15
 800a918:	b2cb      	uxtb	r3, r1
 800a91a:	0c09      	lsrs	r1, r1, #16
 800a91c:	408c      	lsls	r4, r1
 800a91e:	4088      	lsls	r0, r1
 800a920:	4a03      	ldr	r2, [pc, #12]	; (800a930 <LL_SYSCFG_SetEXTISource+0x1c>)
 800a922:	009b      	lsls	r3, r3, #2
 800a924:	189b      	adds	r3, r3, r2
 800a926:	689a      	ldr	r2, [r3, #8]
 800a928:	43a2      	bics	r2, r4
 800a92a:	4310      	orrs	r0, r2
 800a92c:	6098      	str	r0, [r3, #8]
}
 800a92e:	bd10      	pop	{r4, pc}
 800a930:	40010000 	.word	0x40010000

0800a934 <HW_IF_COMM_WAIT>:
{
  USBPD_StatusTypeDef ret = USBPD_ERROR;
  int16_t timeout = Timeout;
  while (1)
  {
    if (Ports[PortNum].CommLock == 0)
 800a934:	23f0      	movs	r3, #240	; 0xf0
 800a936:	005b      	lsls	r3, r3, #1
 800a938:	001a      	movs	r2, r3
 800a93a:	4342      	muls	r2, r0
{
 800a93c:	b510      	push	{r4, lr}
    if (Ports[PortNum].CommLock == 0)
 800a93e:	4c0b      	ldr	r4, [pc, #44]	; (800a96c <HW_IF_COMM_WAIT+0x38>)
 800a940:	18a2      	adds	r2, r4, r2
 800a942:	32d2      	adds	r2, #210	; 0xd2
 800a944:	32ff      	adds	r2, #255	; 0xff
 800a946:	7812      	ldrb	r2, [r2, #0]
 800a948:	2a00      	cmp	r2, #0
 800a94a:	d107      	bne.n	800a95c <HW_IF_COMM_WAIT+0x28>
    {
      /* the resource is free */
      Ports[PortNum].CommLock = 1;
 800a94c:	2101      	movs	r1, #1
 800a94e:	4343      	muls	r3, r0
      ret = USBPD_OK;
 800a950:	0010      	movs	r0, r2
      Ports[PortNum].CommLock = 1;
 800a952:	18e3      	adds	r3, r4, r3
 800a954:	33d2      	adds	r3, #210	; 0xd2
 800a956:	33ff      	adds	r3, #255	; 0xff
 800a958:	7019      	strb	r1, [r3, #0]
    {
      timeout--;
    }
  }
  return ret;
}
 800a95a:	bd10      	pop	{r4, pc}
    if (timeout == 0)
 800a95c:	2900      	cmp	r1, #0
 800a95e:	d002      	beq.n	800a966 <HW_IF_COMM_WAIT+0x32>
 800a960:	3901      	subs	r1, #1
 800a962:	b209      	sxth	r1, r1
 800a964:	e7f0      	b.n	800a948 <HW_IF_COMM_WAIT+0x14>
      ret = USBPD_TIMEOUT;
 800a966:	2004      	movs	r0, #4
 800a968:	e7f7      	b.n	800a95a <HW_IF_COMM_WAIT+0x26>
 800a96a:	46c0      	nop			; (mov r8, r8)
 800a96c:	20000058 	.word	0x20000058

0800a970 <HW_IF_COMM_RELEASE>:
  * @param   PortNum The port index
  * @retval  USBPD status 
*/
static USBPD_StatusTypeDef HW_IF_COMM_RELEASE(uint8_t PortNum)
{
  if (Ports[PortNum].CommLock == 0)
 800a970:	23f0      	movs	r3, #240	; 0xf0
 800a972:	005b      	lsls	r3, r3, #1
 800a974:	4358      	muls	r0, r3
 800a976:	4b05      	ldr	r3, [pc, #20]	; (800a98c <HW_IF_COMM_RELEASE+0x1c>)
 800a978:	181b      	adds	r3, r3, r0
 800a97a:	33d2      	adds	r3, #210	; 0xd2
 800a97c:	33ff      	adds	r3, #255	; 0xff
 800a97e:	781a      	ldrb	r2, [r3, #0]
  {
    /* no change, the resource is already free */
    return USBPD_ERROR;
 800a980:	2002      	movs	r0, #2
  if (Ports[PortNum].CommLock == 0)
 800a982:	2a00      	cmp	r2, #0
 800a984:	d001      	beq.n	800a98a <HW_IF_COMM_RELEASE+0x1a>
  }

  /* release the resource */
  Ports[PortNum].CommLock = 0;
 800a986:	2000      	movs	r0, #0
 800a988:	7018      	strb	r0, [r3, #0]
  return USBPD_OK;
}
 800a98a:	4770      	bx	lr
 800a98c:	20000058 	.word	0x20000058

0800a990 <LL_APB1_GRP2_EnableClock.constprop.7>:
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP2_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 800a990:	2001      	movs	r0, #1
 800a992:	4a05      	ldr	r2, [pc, #20]	; (800a9a8 <LL_APB1_GRP2_EnableClock.constprop.7+0x18>)
__STATIC_INLINE void LL_APB1_GRP2_EnableClock(uint32_t Periphs)
 800a994:	b082      	sub	sp, #8
  SET_BIT(RCC->APB2ENR, Periphs);
 800a996:	6991      	ldr	r1, [r2, #24]
 800a998:	4301      	orrs	r1, r0
 800a99a:	6191      	str	r1, [r2, #24]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 800a99c:	6993      	ldr	r3, [r2, #24]
 800a99e:	4003      	ands	r3, r0
 800a9a0:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 800a9a2:	9b01      	ldr	r3, [sp, #4]
}
 800a9a4:	b002      	add	sp, #8
 800a9a6:	4770      	bx	lr
 800a9a8:	40021000 	.word	0x40021000

0800a9ac <USBPDM1_AssertRp>:
}
 800a9ac:	4770      	bx	lr

0800a9ae <USBPDM1_DeAssertRp>:
 800a9ae:	4770      	bx	lr

0800a9b0 <USBPDM1_AssertRd>:
 800a9b0:	4770      	bx	lr

0800a9b2 <USBPDM1_DeAssertRd>:
 800a9b2:	4770      	bx	lr

0800a9b4 <USBPD_HW_IF_HR_Start>:
{
 800a9b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800a9b6:	2164      	movs	r1, #100	; 0x64
{
 800a9b8:	0006      	movs	r6, r0
 800a9ba:	0017      	movs	r7, r2
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800a9bc:	f7ff ffba 	bl	800a934 <HW_IF_COMM_WAIT>
 800a9c0:	1e05      	subs	r5, r0, #0
  if (ret != USBPD_OK)
 800a9c2:	d144      	bne.n	800aa4e <USBPD_HW_IF_HR_Start+0x9a>
  if (Ports[PortNum].Device_cut == Cut_1)
 800a9c4:	22f0      	movs	r2, #240	; 0xf0
 800a9c6:	0052      	lsls	r2, r2, #1
 800a9c8:	4372      	muls	r2, r6
 800a9ca:	4b22      	ldr	r3, [pc, #136]	; (800aa54 <USBPD_HW_IF_HR_Start+0xa0>)
 800a9cc:	189b      	adds	r3, r3, r2
 800a9ce:	33d9      	adds	r3, #217	; 0xd9
 800a9d0:	33ff      	adds	r3, #255	; 0xff
 800a9d2:	781b      	ldrb	r3, [r3, #0]
 800a9d4:	2b03      	cmp	r3, #3
 800a9d6:	d106      	bne.n	800a9e6 <USBPD_HW_IF_HR_Start+0x32>
    STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Disable);
 800a9d8:	0030      	movs	r0, r6
 800a9da:	1e43      	subs	r3, r0, #1
 800a9dc:	4198      	sbcs	r0, r3
 800a9de:	2101      	movs	r1, #1
 800a9e0:	3028      	adds	r0, #40	; 0x28
 800a9e2:	f7fc fa63 	bl	8006eac <STUSB1602_VBUS_Range_State_Set>
  STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000);
 800a9e6:	0034      	movs	r4, r6
 800a9e8:	1e63      	subs	r3, r4, #1
 800a9ea:	419c      	sbcs	r4, r3
 800a9ec:	3428      	adds	r4, #40	; 0x28
 800a9ee:	491a      	ldr	r1, [pc, #104]	; (800aa58 <USBPD_HW_IF_HR_Start+0xa4>)
 800a9f0:	0020      	movs	r0, r4
 800a9f2:	f7fc f94d 	bl	8006c90 <STUSB1602_VBUS_Select_Status_Set>
  ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), Mode == ACKNOWLEDGE ? PD_HARD_RESET_RECEIVED_REQ : PD_HARD_RESET_SEND_REQ);
 800a9f6:	0039      	movs	r1, r7
 800a9f8:	1e4b      	subs	r3, r1, #1
 800a9fa:	4199      	sbcs	r1, r3
 800a9fc:	0020      	movs	r0, r4
 800a9fe:	310e      	adds	r1, #14
 800aa00:	f7fc fa9b 	bl	8006f3a <STUSB1602_Type_C_Command>
 800aa04:	0005      	movs	r5, r0
  if (Mode == ACKNOWLEDGE)
 800aa06:	2f00      	cmp	r7, #0
 800aa08:	d105      	bne.n	800aa16 <USBPD_HW_IF_HR_Start+0x62>
 800aa0a:	23c8      	movs	r3, #200	; 0xc8
 800aa0c:	46c0      	nop			; (mov r8, r8)
 800aa0e:	3b01      	subs	r3, #1
 800aa10:	b29b      	uxth	r3, r3
    for(uint16_t i=0;i<200;i++)
 800aa12:	2b00      	cmp	r3, #0
 800aa14:	d1fa      	bne.n	800aa0c <USBPD_HW_IF_HR_Start+0x58>
  if (ret == USBPD_OK)
 800aa16:	2800      	cmp	r0, #0
 800aa18:	d116      	bne.n	800aa48 <USBPD_HW_IF_HR_Start+0x94>
  STUSB1602_CC_DETECTION_STATUS_Value = STUSB1602_CC_Detection_Status_Get(STUSB1602_I2C_Add(PortNum));
 800aa1a:	0020      	movs	r0, r4
 800aa1c:	f7fb ffe6 	bl	80069ec <STUSB1602_CC_Detection_Status_Get>
  if (STUSB1602_CC_DETECTION_STATUS_Value.b.CC_VCONN_SUPPLY_STATE == VCONN_supplied_on_unused_CC_pin)
 800aa20:	2102      	movs	r1, #2
 800aa22:	b2c7      	uxtb	r7, r0
 800aa24:	420f      	tst	r7, r1
 800aa26:	d003      	beq.n	800aa30 <USBPD_HW_IF_HR_Start+0x7c>
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_TURN_OFF_VCONN_REQ);
 800aa28:	0020      	movs	r0, r4
 800aa2a:	f7fc fa86 	bl	8006f3a <STUSB1602_Type_C_Command>
 800aa2e:	0005      	movs	r5, r0
      (((Power_Role_TypeDef)STUSB1602_CC_DETECTION_STATUS_Value.b.CC_POWER_ROLE == Source) &&
 800aa30:	210c      	movs	r1, #12
 800aa32:	4039      	ands	r1, r7
  if (
 800aa34:	2908      	cmp	r1, #8
 800aa36:	d105      	bne.n	800aa44 <USBPD_HW_IF_HR_Start+0x90>
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_PORT_CHANGE_2_DFP_REQ);
 800aa38:	3905      	subs	r1, #5
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_PORT_CHANGE_2_UFP_REQ);
 800aa3a:	0020      	movs	r0, r4
 800aa3c:	f7fc fa7d 	bl	8006f3a <STUSB1602_Type_C_Command>
 800aa40:	0005      	movs	r5, r0
 800aa42:	e001      	b.n	800aa48 <USBPD_HW_IF_HR_Start+0x94>
  if (
 800aa44:	2904      	cmp	r1, #4
 800aa46:	d0f8      	beq.n	800aa3a <USBPD_HW_IF_HR_Start+0x86>
  HW_IF_COMM_RELEASE(PortNum);
 800aa48:	0030      	movs	r0, r6
 800aa4a:	f7ff ff91 	bl	800a970 <HW_IF_COMM_RELEASE>
}
 800aa4e:	0028      	movs	r0, r5
 800aa50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800aa52:	46c0      	nop			; (mov r8, r8)
 800aa54:	20000058 	.word	0x20000058
 800aa58:	00001388 	.word	0x00001388

0800aa5c <USBPD_HW_IF_HR_CheckVbusVSafe0V>:
{
 800aa5c:	b510      	push	{r4, lr}
  if (CurrentRole == USBPD_PORTPOWERROLE_SRC)
 800aa5e:	2901      	cmp	r1, #1
 800aa60:	d102      	bne.n	800aa68 <USBPD_HW_IF_HR_CheckVbusVSafe0V+0xc>
    return USBPD_OK;
 800aa62:	2300      	movs	r3, #0
}
 800aa64:	0018      	movs	r0, r3
 800aa66:	bd10      	pop	{r4, pc}
  return USBPD_ERROR;
 800aa68:	2302      	movs	r3, #2
  if (CurrentRole == USBPD_PORTPOWERROLE_SNK)
 800aa6a:	2900      	cmp	r1, #0
 800aa6c:	d1fa      	bne.n	800aa64 <USBPD_HW_IF_HR_CheckVbusVSafe0V+0x8>
    return STUSB1602_VBUS_Presence_Get(STUSB1602_I2C_Add(PortNum)) == VBUS_below_UVLO_threshold ? USBPD_OK : USBPD_BUSY;
 800aa6e:	1e43      	subs	r3, r0, #1
 800aa70:	4198      	sbcs	r0, r3
 800aa72:	3028      	adds	r0, #40	; 0x28
 800aa74:	f7fb ffe6 	bl	8006a44 <STUSB1602_VBUS_Presence_Get>
 800aa78:	2800      	cmp	r0, #0
 800aa7a:	d0f2      	beq.n	800aa62 <USBPD_HW_IF_HR_CheckVbusVSafe0V+0x6>
 800aa7c:	2303      	movs	r3, #3
 800aa7e:	e7f1      	b.n	800aa64 <USBPD_HW_IF_HR_CheckVbusVSafe0V+0x8>

0800aa80 <USBPD_HW_IF_HR_End>:
{
 800aa80:	b570      	push	{r4, r5, r6, lr}
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800aa82:	2164      	movs	r1, #100	; 0x64
{
 800aa84:	0006      	movs	r6, r0
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800aa86:	f7ff ff55 	bl	800a934 <HW_IF_COMM_WAIT>
 800aa8a:	1e05      	subs	r5, r0, #0
  if (ret != USBPD_OK)
 800aa8c:	d113      	bne.n	800aab6 <USBPD_HW_IF_HR_End+0x36>
  ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Command(STUSB1602_I2C_Add(PortNum), PD_HARD_RESET_COMPLETE_REQ);    
 800aa8e:	0034      	movs	r4, r6
 800aa90:	1e63      	subs	r3, r4, #1
 800aa92:	419c      	sbcs	r4, r3
 800aa94:	3428      	adds	r4, #40	; 0x28
 800aa96:	2101      	movs	r1, #1
 800aa98:	0020      	movs	r0, r4
 800aa9a:	f7fc fa4e 	bl	8006f3a <STUSB1602_Type_C_Command>
  ret = (USBPD_StatusTypeDef)STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000);
 800aa9e:	4907      	ldr	r1, [pc, #28]	; (800aabc <USBPD_HW_IF_HR_End+0x3c>)
 800aaa0:	0020      	movs	r0, r4
 800aaa2:	f7fc f8f5 	bl	8006c90 <STUSB1602_VBUS_Select_Status_Set>
  STUSB1602_CC_Detect_Alrt_Int_Mask_Set(STUSB1602_I2C_Add(PortNum), CC_Detect_Int_UNMASKED);
 800aaa6:	2100      	movs	r1, #0
  ret = (USBPD_StatusTypeDef)STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000);
 800aaa8:	0005      	movs	r5, r0
  STUSB1602_CC_Detect_Alrt_Int_Mask_Set(STUSB1602_I2C_Add(PortNum), CC_Detect_Int_UNMASKED);
 800aaaa:	0020      	movs	r0, r4
 800aaac:	f7fb ff7a 	bl	80069a4 <STUSB1602_CC_Detect_Alrt_Int_Mask_Set>
  HW_IF_COMM_RELEASE(PortNum);
 800aab0:	0030      	movs	r0, r6
 800aab2:	f7ff ff5d 	bl	800a970 <HW_IF_COMM_RELEASE>
}
 800aab6:	0028      	movs	r0, r5
 800aab8:	bd70      	pop	{r4, r5, r6, pc}
 800aaba:	46c0      	nop			; (mov r8, r8)
 800aabc:	00001388 	.word	0x00001388

0800aac0 <USBPD_HW_IF_ErrorRecovery>:
{
 800aac0:	b510      	push	{r4, lr}
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), SW_RST);
 800aac2:	1e44      	subs	r4, r0, #1
 800aac4:	41a0      	sbcs	r0, r4
 800aac6:	3028      	adds	r0, #40	; 0x28
 800aac8:	0004      	movs	r4, r0
 800aaca:	2101      	movs	r1, #1
 800aacc:	f7fc f92d 	bl	8006d2a <STUSB1602_SW_RESET_Set>
  HAL_Delay(27); // need to be 25ms min
 800aad0:	201b      	movs	r0, #27
 800aad2:	f7fc fb2b 	bl	800712c <HAL_Delay>
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), No_SW_RST);
 800aad6:	2100      	movs	r1, #0
 800aad8:	0020      	movs	r0, r4
 800aada:	f7fc f926 	bl	8006d2a <STUSB1602_SW_RESET_Set>
}
 800aade:	2000      	movs	r0, #0
 800aae0:	bd10      	pop	{r4, pc}
	...

0800aae4 <HW_IF_SPI_Init>:
  * @retval None
  */ 
void HW_IF_SPI_Init(uint8_t PortNum)
{
  /* Get the peripheral handler variable */
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800aae4:	21f0      	movs	r1, #240	; 0xf0
 800aae6:	0049      	lsls	r1, r1, #1
 800aae8:	4341      	muls	r1, r0
{
 800aaea:	0002      	movs	r2, r0
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800aaec:	0008      	movs	r0, r1
 800aaee:	4b11      	ldr	r3, [pc, #68]	; (800ab34 <HW_IF_SPI_Init+0x50>)
{
 800aaf0:	b510      	push	{r4, lr}
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800aaf2:	3040      	adds	r0, #64	; 0x40
  
  phspi->Instance =           SPI_Instance(PortNum);
 800aaf4:	4254      	negs	r4, r2
 800aaf6:	4162      	adcs	r2, r4
  SPI_HandleTypeDef*           phspi = &(Ports[PortNum].hspi);
 800aaf8:	18c0      	adds	r0, r0, r3
  phspi->Instance =           SPI_Instance(PortNum);
 800aafa:	185b      	adds	r3, r3, r1
  phspi->Init.Mode =           SPI_MODE_SLAVE;
  phspi->Init.Direction =  SPI_DIRECTION_2LINES;
  phspi->Init.DataSize =   SPI_DATASIZE_8BIT;
 800aafc:	21e0      	movs	r1, #224	; 0xe0
  phspi->Instance =           SPI_Instance(PortNum);
 800aafe:	4c0e      	ldr	r4, [pc, #56]	; (800ab38 <HW_IF_SPI_Init+0x54>)
 800ab00:	4252      	negs	r2, r2
 800ab02:	4022      	ands	r2, r4
  phspi->Init.DataSize =   SPI_DATASIZE_8BIT;
 800ab04:	00c9      	lsls	r1, r1, #3
  phspi->Instance =           SPI_Instance(PortNum);
 800ab06:	4c0d      	ldr	r4, [pc, #52]	; (800ab3c <HW_IF_SPI_Init+0x58>)
  phspi->Init.DataSize =   SPI_DATASIZE_8BIT;
 800ab08:	64d9      	str	r1, [r3, #76]	; 0x4c
  phspi->Init.CLKPolarity =     SPI_POLARITY_HIGH;
 800ab0a:	2102      	movs	r1, #2
  phspi->Instance =           SPI_Instance(PortNum);
 800ab0c:	1912      	adds	r2, r2, r4
 800ab0e:	641a      	str	r2, [r3, #64]	; 0x40
  phspi->Init.Mode =           SPI_MODE_SLAVE;
 800ab10:	2200      	movs	r2, #0
  phspi->Init.CLKPolarity =     SPI_POLARITY_HIGH;
 800ab12:	6519      	str	r1, [r3, #80]	; 0x50
  phspi->Init.CLKPhase =   SPI_PHASE_1EDGE;
  phspi->Init.NSS =     SPI_NSS_HARD_INPUT;
  phspi->Init.FirstBit =   SPI_FIRSTBIT_LSB;
 800ab14:	317e      	adds	r1, #126	; 0x7e
 800ab16:	6619      	str	r1, [r3, #96]	; 0x60
  phspi->Init.TIMode =     SPI_TIMODE_DISABLE;
  phspi->Init.CRCCalculation =  SPI_CRCCALCULATION_DISABLE;
  phspi->Init.CRCPolynomial =   7;
 800ab18:	3979      	subs	r1, #121	; 0x79
  phspi->Init.Mode =           SPI_MODE_SLAVE;
 800ab1a:	645a      	str	r2, [r3, #68]	; 0x44
  phspi->Init.Direction =  SPI_DIRECTION_2LINES;
 800ab1c:	649a      	str	r2, [r3, #72]	; 0x48
  phspi->Init.CLKPhase =   SPI_PHASE_1EDGE;
 800ab1e:	655a      	str	r2, [r3, #84]	; 0x54
  phspi->Init.NSS =     SPI_NSS_HARD_INPUT;
 800ab20:	659a      	str	r2, [r3, #88]	; 0x58
  phspi->Init.TIMode =     SPI_TIMODE_DISABLE;
 800ab22:	665a      	str	r2, [r3, #100]	; 0x64
  phspi->Init.CRCCalculation =  SPI_CRCCALCULATION_DISABLE;
 800ab24:	669a      	str	r2, [r3, #104]	; 0x68
  phspi->Init.CRCPolynomial =   7;
 800ab26:	66d9      	str	r1, [r3, #108]	; 0x6c
  phspi->Init.CRCLength =   SPI_CRC_LENGTH_DATASIZE;
 800ab28:	671a      	str	r2, [r3, #112]	; 0x70
  phspi->Init.NSSPMode =   SPI_NSS_PULSE_DISABLE;
 800ab2a:	675a      	str	r2, [r3, #116]	; 0x74
  
  HAL_SPI_Init(phspi);
 800ab2c:	f7fd fc88 	bl	8008440 <HAL_SPI_Init>
}
 800ab30:	bd10      	pop	{r4, pc}
 800ab32:	46c0      	nop			; (mov r8, r8)
 800ab34:	20000058 	.word	0x20000058
 800ab38:	ffff0800 	.word	0xffff0800
 800ab3c:	40013000 	.word	0x40013000

0800ab40 <HW_IF_SPI_Mode>:
  * @param  PortNum The port index
  * @param  mode Two allowed values: STUSB16xx_SPI_Mode_TX or STUSB16xx_SPI_Mode_RX
  * @retval None
  */ 
void HW_IF_SPI_Mode(uint8_t PortNum, STUSB1602_SPI_Mode_TypeDef mode)
{
 800ab40:	b570      	push	{r4, r5, r6, lr}
  /* Stop the SPI DMA before changing SPI mode */
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800ab42:	25f0      	movs	r5, #240	; 0xf0
 800ab44:	006d      	lsls	r5, r5, #1
 800ab46:	4345      	muls	r5, r0
 800ab48:	0028      	movs	r0, r5
 800ab4a:	4e1d      	ldr	r6, [pc, #116]	; (800abc0 <HW_IF_SPI_Mode+0x80>)
 800ab4c:	3040      	adds	r0, #64	; 0x40
 800ab4e:	1980      	adds	r0, r0, r6
{
 800ab50:	000c      	movs	r4, r1
  HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800ab52:	f7fd fef5 	bl	8008940 <HAL_SPI_DMAStop>
  
  /* Disable SPI peripheral */
  __HAL_SPI_DISABLE(&Ports[PortNum].hspi);
 800ab56:	2140      	movs	r1, #64	; 0x40
 800ab58:	1970      	adds	r0, r6, r5
 800ab5a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800ab5c:	681a      	ldr	r2, [r3, #0]
 800ab5e:	438a      	bics	r2, r1
 800ab60:	601a      	str	r2, [r3, #0]
  
  CR1Value = phspi->Instance->CR1;
  
  /* If cut 1.2 is used, SPI is configured to sample data
     on rising edge on TX phase as well as on falling edge on RX phase */
  if (Ports[PortNum].Device_cut== Cut_1)
 800ab62:	0002      	movs	r2, r0
 800ab64:	32d9      	adds	r2, #217	; 0xd9
 800ab66:	32ff      	adds	r2, #255	; 0xff
 800ab68:	7812      	ldrb	r2, [r2, #0]
  CR1Value = phspi->Instance->CR1;
 800ab6a:	6819      	ldr	r1, [r3, #0]
  if (Ports[PortNum].Device_cut== Cut_1)
 800ab6c:	2a03      	cmp	r2, #3
 800ab6e:	d110      	bne.n	800ab92 <HW_IF_SPI_Mode+0x52>
  {  
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^mode)&1;
 800ab70:	2501      	movs	r5, #1
 800ab72:	0849      	lsrs	r1, r1, #1
    phspi->Instance->CR1 &= ~1;
 800ab74:	681a      	ldr	r2, [r3, #0]
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^mode)&1;
 800ab76:	4029      	ands	r1, r5
 800ab78:	4061      	eors	r1, r4
    phspi->Instance->CR1 &= ~1;
 800ab7a:	43aa      	bics	r2, r5
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^mode)&1;
 800ab7c:	4029      	ands	r1, r5
 800ab7e:	6541      	str	r1, [r0, #84]	; 0x54
    phspi->Instance->CR1 &= ~1;
 800ab80:	601a      	str	r2, [r3, #0]
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^mode)&1;
 800ab82:	681a      	ldr	r2, [r3, #0]
    phspi->Instance->CR1 &= ~1;
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^1)&1;

    /* SPI NSS software or hardware according to the mode value */
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800ab84:	4311      	orrs	r1, r2
 800ab86:	6019      	str	r1, [r3, #0]
  }
  
  /* Enable SPI peripheral */
  __HAL_SPI_ENABLE(&Ports[PortNum].hspi);
 800ab88:	2240      	movs	r2, #64	; 0x40
 800ab8a:	6819      	ldr	r1, [r3, #0]
 800ab8c:	430a      	orrs	r2, r1
 800ab8e:	601a      	str	r2, [r3, #0]
}
 800ab90:	bd70      	pop	{r4, r5, r6, pc}
  if (Ports[PortNum].Device_cut == Cut_1_A)
 800ab92:	2a04      	cmp	r2, #4
 800ab94:	d1f8      	bne.n	800ab88 <HW_IF_SPI_Mode+0x48>
 800ab96:	2501      	movs	r5, #1
 800ab98:	002e      	movs	r6, r5
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^1)&1;
 800ab9a:	0849      	lsrs	r1, r1, #1
 800ab9c:	438e      	bics	r6, r1
    phspi->Instance->CR1 &= ~1;
 800ab9e:	6819      	ldr	r1, [r3, #0]
    phspi->Init.CLKPhase = (((CR1Value>>1)&1)^1)&1;
 800aba0:	6546      	str	r6, [r0, #84]	; 0x54
    phspi->Instance->CR1 &= ~1;
 800aba2:	43a9      	bics	r1, r5
 800aba4:	6019      	str	r1, [r3, #0]
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^1)&1;
 800aba6:	681a      	ldr	r2, [r3, #0]
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800aba8:	4906      	ldr	r1, [pc, #24]	; (800abc4 <HW_IF_SPI_Mode+0x84>)
    phspi->Instance->CR1 |= (((CR1Value>>1)&1)^1)&1;
 800abaa:	4332      	orrs	r2, r6
 800abac:	601a      	str	r2, [r3, #0]
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800abae:	681a      	ldr	r2, [r3, #0]
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800abb0:	402c      	ands	r4, r5
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800abb2:	400a      	ands	r2, r1
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800abb4:	4261      	negs	r1, r4
 800abb6:	4161      	adcs	r1, r4
    phspi->Instance->CR1 &= ~(1<<SPI_CR1_SSM_Pos);
 800abb8:	601a      	str	r2, [r3, #0]
    phspi->Instance->CR1 |= ((((~mode) & 1)<<SPI_CR1_SSM_Pos) & SPI_CR1_SSM);
 800abba:	681a      	ldr	r2, [r3, #0]
 800abbc:	0249      	lsls	r1, r1, #9
 800abbe:	e7e1      	b.n	800ab84 <HW_IF_SPI_Mode+0x44>
 800abc0:	20000058 	.word	0x20000058
 800abc4:	fffffdff 	.word	0xfffffdff

0800abc8 <HW_IF_DMA_Init>:
  * @brief  DMA init function
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_DMA_Init(uint8_t PortNum)
{
 800abc8:	b507      	push	{r0, r1, r2, lr}
 800abca:	2201      	movs	r2, #1
 800abcc:	4b09      	ldr	r3, [pc, #36]	; (800abf4 <HW_IF_DMA_Init+0x2c>)
  /* DMA controller clock enable */
  DMA_CLK_ENABLE(PortNum);
 800abce:	6959      	ldr	r1, [r3, #20]
 800abd0:	4311      	orrs	r1, r2
 800abd2:	6159      	str	r1, [r3, #20]
 800abd4:	695b      	ldr	r3, [r3, #20]
 800abd6:	401a      	ands	r2, r3
 800abd8:	2800      	cmp	r0, #0
 800abda:	d107      	bne.n	800abec <HW_IF_DMA_Init+0x24>
 800abdc:	9200      	str	r2, [sp, #0]
 800abde:	9b00      	ldr	r3, [sp, #0]

  /* NVIC configuration for DMA */
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800abe0:	300b      	adds	r0, #11
 800abe2:	2200      	movs	r2, #0
 800abe4:	0011      	movs	r1, r2
 800abe6:	f7fc fd0d 	bl	8007604 <HAL_NVIC_SetPriority>
}
 800abea:	bd07      	pop	{r0, r1, r2, pc}
  DMA_CLK_ENABLE(PortNum);
 800abec:	9201      	str	r2, [sp, #4]
 800abee:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800abf0:	200a      	movs	r0, #10
 800abf2:	e7f6      	b.n	800abe2 <HW_IF_DMA_Init+0x1a>
 800abf4:	40021000 	.word	0x40021000

0800abf8 <HW_IF_STUSB16xx_I2C_Init>:
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_STUSB16xx_I2C_Init(uint8_t PortNum)
{
  I2C_HandleTypeDef*           phi2c = &(Ports[PortNum].hi2c);
 800abf8:	23f0      	movs	r3, #240	; 0xf0
 800abfa:	005b      	lsls	r3, r3, #1
 800abfc:	4358      	muls	r0, r3
{
 800abfe:	b570      	push	{r4, r5, r6, lr}
  I2C_HandleTypeDef*           phi2c = &(Ports[PortNum].hi2c);
 800ac00:	0004      	movs	r4, r0
 800ac02:	4b0d      	ldr	r3, [pc, #52]	; (800ac38 <HW_IF_STUSB16xx_I2C_Init+0x40>)
 800ac04:	342d      	adds	r4, #45	; 0x2d
 800ac06:	34ff      	adds	r4, #255	; 0xff
 800ac08:	18e4      	adds	r4, r4, r3
  
  phi2c->Instance = I2C_INSTANCE(PortNum);
 800ac0a:	1818      	adds	r0, r3, r0
 800ac0c:	4b0b      	ldr	r3, [pc, #44]	; (800ac3c <HW_IF_STUSB16xx_I2C_Init+0x44>)
 800ac0e:	30fc      	adds	r0, #252	; 0xfc
 800ac10:	6303      	str	r3, [r0, #48]	; 0x30
  phi2c->Init.Timing =  I2C_TIMING(PortNum); 
 800ac12:	4b0b      	ldr	r3, [pc, #44]	; (800ac40 <HW_IF_STUSB16xx_I2C_Init+0x48>)
  phi2c->Init.OwnAddress1 = 0;
 800ac14:	2500      	movs	r5, #0
  phi2c->Init.Timing =  I2C_TIMING(PortNum); 
 800ac16:	6343      	str	r3, [r0, #52]	; 0x34
  phi2c->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800ac18:	2301      	movs	r3, #1
  phi2c->Init.OwnAddress1 = 0;
 800ac1a:	6385      	str	r5, [r0, #56]	; 0x38
  phi2c->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800ac1c:	63c3      	str	r3, [r0, #60]	; 0x3c
  phi2c->Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 800ac1e:	6405      	str	r5, [r0, #64]	; 0x40
  phi2c->Init.OwnAddress2 = 0;
 800ac20:	6445      	str	r5, [r0, #68]	; 0x44
  phi2c->Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 800ac22:	6485      	str	r5, [r0, #72]	; 0x48
  phi2c->Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 800ac24:	64c5      	str	r5, [r0, #76]	; 0x4c
  phi2c->Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 800ac26:	6505      	str	r5, [r0, #80]	; 0x50

  HAL_I2C_Init(phi2c);
 800ac28:	0020      	movs	r0, r4
 800ac2a:	f7fd f8e3 	bl	8007df4 <HAL_I2C_Init>
  
  HAL_I2CEx_ConfigAnalogFilter(phi2c, I2C_ANALOGFILTER_ENABLE);
 800ac2e:	0029      	movs	r1, r5
 800ac30:	0020      	movs	r0, r4
 800ac32:	f7fd faad 	bl	8008190 <HAL_I2CEx_ConfigAnalogFilter>
}
 800ac36:	bd70      	pop	{r4, r5, r6, pc}
 800ac38:	20000058 	.word	0x20000058
 800ac3c:	40005800 	.word	0x40005800
 800ac40:	20100917 	.word	0x20100917

0800ac44 <HW_IF_STUSB1602_IO_Init>:
  * @brief  Configuration of STUSB1602 GPIO pins
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_STUSB1602_IO_Init(uint8_t PortNum)
{
 800ac44:	b530      	push	{r4, r5, lr}
  GPIO_InitTypeDef GPIO_InitStruct;

  /* Configure GPIO pin : ALERT */
  GPIO_InitStruct.Pin = ALERT_GPIO_PIN(PortNum);
 800ac46:	2302      	movs	r3, #2
{
 800ac48:	b087      	sub	sp, #28
 800ac4a:	1e04      	subs	r4, r0, #0
  GPIO_InitStruct.Pin = ALERT_GPIO_PIN(PortNum);
 800ac4c:	d000      	beq.n	800ac50 <HW_IF_STUSB1602_IO_Init+0xc>
 800ac4e:	18db      	adds	r3, r3, r3
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(ALERT_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800ac50:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ac52:	2500      	movs	r5, #0
  GPIO_InitStruct.Pin = ALERT_GPIO_PIN(PortNum);
 800ac54:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800ac56:	4b2a      	ldr	r3, [pc, #168]	; (800ad00 <HW_IF_STUSB1602_IO_Init+0xbc>)
  HAL_GPIO_Init(ALERT_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800ac58:	a901      	add	r1, sp, #4
 800ac5a:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 800ac5c:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ac5e:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(ALERT_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800ac60:	f7fc feaa 	bl	80079b8 <HAL_GPIO_Init>
  
  /* Configure GPIO pin : A_B_SIDE */
  GPIO_InitStruct.Pin = A_B_Side_GPIO_PIN(PortNum);
 800ac64:	2301      	movs	r3, #1
 800ac66:	42ac      	cmp	r4, r5
 800ac68:	d000      	beq.n	800ac6c <HW_IF_STUSB1602_IO_Init+0x28>
 800ac6a:	3307      	adds	r3, #7
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(A_B_Side_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800ac6c:	2090      	movs	r0, #144	; 0x90
 800ac6e:	a901      	add	r1, sp, #4
 800ac70:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = A_B_Side_GPIO_PIN(PortNum);
 800ac72:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800ac74:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ac76:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(A_B_Side_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800ac78:	f7fc fe9e 	bl	80079b8 <HAL_GPIO_Init>

  /* Configure GPIO pin : TX_EN */
  GPIO_InitStruct.Pin = TX_EN_GPIO_PIN(PortNum);
 800ac7c:	2304      	movs	r3, #4
 800ac7e:	2c00      	cmp	r4, #0
 800ac80:	d000      	beq.n	800ac84 <HW_IF_STUSB1602_IO_Init+0x40>
 800ac82:	18db      	adds	r3, r3, r3
 800ac84:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800ac86:	2501      	movs	r5, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ac88:	2300      	movs	r3, #0
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(TX_EN_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800ac8a:	a901      	add	r1, sp, #4
 800ac8c:	481d      	ldr	r0, [pc, #116]	; (800ad04 <HW_IF_STUSB1602_IO_Init+0xc0>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ac8e:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800ac90:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800ac92:	9502      	str	r5, [sp, #8]
  HAL_GPIO_Init(TX_EN_GPIO_PORT(PortNum), &GPIO_InitStruct);  
 800ac94:	f7fc fe90 	bl	80079b8 <HAL_GPIO_Init>
  
  /* Configure GPIO pins : RESET */
  GPIO_InitStruct.Pin = RESET_GPIO_PIN(PortNum);
 800ac98:	2340      	movs	r3, #64	; 0x40
 800ac9a:	2c00      	cmp	r4, #0
 800ac9c:	d000      	beq.n	800aca0 <HW_IF_STUSB1602_IO_Init+0x5c>
 800ac9e:	18db      	adds	r3, r3, r3
 800aca0:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(RESET_GPIO_PORT(PortNum), &GPIO_InitStruct);

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(ALERT_GPIO_IRQHANDLER(PortNum), ALERT_GPIO_IRQPRIORITY(PortNum), 0);
 800aca2:	1e63      	subs	r3, r4, #1
 800aca4:	419c      	sbcs	r4, r3
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800aca6:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800aca8:	2500      	movs	r5, #0
  HAL_GPIO_Init(RESET_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800acaa:	a901      	add	r1, sp, #4
  HAL_NVIC_SetPriority(ALERT_GPIO_IRQHANDLER(PortNum), ALERT_GPIO_IRQPRIORITY(PortNum), 0);
 800acac:	3405      	adds	r4, #5
  HAL_GPIO_Init(RESET_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800acae:	4815      	ldr	r0, [pc, #84]	; (800ad04 <HW_IF_STUSB1602_IO_Init+0xc0>)
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800acb0:	9503      	str	r5, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800acb2:	9504      	str	r5, [sp, #16]
  HAL_GPIO_Init(RESET_GPIO_PORT(PortNum), &GPIO_InitStruct);
 800acb4:	f7fc fe80 	bl	80079b8 <HAL_GPIO_Init>
  HAL_NVIC_SetPriority(ALERT_GPIO_IRQHANDLER(PortNum), ALERT_GPIO_IRQPRIORITY(PortNum), 0);
 800acb8:	002a      	movs	r2, r5
 800acba:	2101      	movs	r1, #1
 800acbc:	0020      	movs	r0, r4
 800acbe:	f7fc fca1 	bl	8007604 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(ALERT_GPIO_IRQHANDLER(PortNum));
 800acc2:	0020      	movs	r0, r4
 800acc4:	f7fc fcc8 	bl	8007658 <HAL_NVIC_EnableIRQ>
 
  /* pin for ADC*/
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_4;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800acc8:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800acca:	2403      	movs	r4, #3
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_4;
 800accc:	2390      	movs	r3, #144	; 0x90
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800acce:	a901      	add	r1, sp, #4
 800acd0:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_4;
 800acd2:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800acd4:	9402      	str	r4, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800acd6:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800acd8:	f7fc fe6e 	bl	80079b8 <HAL_GPIO_Init>
  
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
 800acdc:	2311      	movs	r3, #17
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800acde:	a901      	add	r1, sp, #4
 800ace0:	4808      	ldr	r0, [pc, #32]	; (800ad04 <HW_IF_STUSB1602_IO_Init+0xc0>)
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
 800ace2:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800ace4:	9402      	str	r4, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ace6:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800ace8:	f7fc fe66 	bl	80079b8 <HAL_GPIO_Init>
  
  GPIO_InitStruct.Pin = GPIO_PIN_0;
 800acec:	2301      	movs	r3, #1
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800acee:	a901      	add	r1, sp, #4
 800acf0:	4805      	ldr	r0, [pc, #20]	; (800ad08 <HW_IF_STUSB1602_IO_Init+0xc4>)
  GPIO_InitStruct.Pin = GPIO_PIN_0;
 800acf2:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800acf4:	9402      	str	r4, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800acf6:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800acf8:	f7fc fe5e 	bl	80079b8 <HAL_GPIO_Init>
//    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
//    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
//    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
//    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
//  }
}
 800acfc:	b007      	add	sp, #28
 800acfe:	bd30      	pop	{r4, r5, pc}
 800ad00:	10210000 	.word	0x10210000
 800ad04:	48000800 	.word	0x48000800
 800ad08:	48000400 	.word	0x48000400

0800ad0c <HW_IF_RESET_CTRL>:
  * @brief  STUSB16xx software reset
  * @param  PortNum The port index
  * @retval None
*/ 
void HW_IF_RESET_CTRL(uint8_t PortNum)
{
 800ad0c:	b510      	push	{r4, lr}
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), SW_RST);
 800ad0e:	1e44      	subs	r4, r0, #1
 800ad10:	41a0      	sbcs	r0, r4
 800ad12:	2101      	movs	r1, #1
 800ad14:	3028      	adds	r0, #40	; 0x28
 800ad16:	0004      	movs	r4, r0
 800ad18:	f7fc f807 	bl	8006d2a <STUSB1602_SW_RESET_Set>
 800ad1c:	2164      	movs	r1, #100	; 0x64
 800ad1e:	46c0      	nop			; (mov r8, r8)
 800ad20:	3901      	subs	r1, #1
 800ad22:	b289      	uxth	r1, r1
  for(uint16_t i=0; i<100; i++)
 800ad24:	2900      	cmp	r1, #0
 800ad26:	d1fa      	bne.n	800ad1e <HW_IF_RESET_CTRL+0x12>
  {
    __NOP();
  }  
  STUSB1602_SW_RESET_Set(STUSB1602_I2C_Add(PortNum), No_SW_RST);
 800ad28:	0020      	movs	r0, r4
 800ad2a:	f7fb fffe 	bl	8006d2a <STUSB1602_SW_RESET_Set>
}
 800ad2e:	bd10      	pop	{r4, pc}

0800ad30 <HW_IF_RESET_Assert>:
  * @brief  Assert STUSB16xx hardware reset
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_RESET_Assert(uint8_t PortNum)
{
 800ad30:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(RESET_GPIO_PORT(PortNum), RESET_GPIO_PIN(PortNum), GPIO_PIN_SET);
 800ad32:	2140      	movs	r1, #64	; 0x40
 800ad34:	2800      	cmp	r0, #0
 800ad36:	d000      	beq.n	800ad3a <HW_IF_RESET_Assert+0xa>
 800ad38:	1849      	adds	r1, r1, r1
 800ad3a:	2201      	movs	r2, #1
 800ad3c:	4801      	ldr	r0, [pc, #4]	; (800ad44 <HW_IF_RESET_Assert+0x14>)
 800ad3e:	f7fc fefd 	bl	8007b3c <HAL_GPIO_WritePin>
}
 800ad42:	bd10      	pop	{r4, pc}
 800ad44:	48000800 	.word	0x48000800

0800ad48 <HW_IF_RESET_Deassert>:
  * @brief  Desert STUSB16xx hardware reset
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_RESET_Deassert(uint8_t PortNum)
{
 800ad48:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(RESET_GPIO_PORT(PortNum), RESET_GPIO_PIN(PortNum), GPIO_PIN_RESET);
 800ad4a:	2140      	movs	r1, #64	; 0x40
 800ad4c:	2800      	cmp	r0, #0
 800ad4e:	d000      	beq.n	800ad52 <HW_IF_RESET_Deassert+0xa>
 800ad50:	1849      	adds	r1, r1, r1
 800ad52:	2200      	movs	r2, #0
 800ad54:	4801      	ldr	r0, [pc, #4]	; (800ad5c <HW_IF_RESET_Deassert+0x14>)
 800ad56:	f7fc fef1 	bl	8007b3c <HAL_GPIO_WritePin>
}
 800ad5a:	bd10      	pop	{r4, pc}
 800ad5c:	48000800 	.word	0x48000800

0800ad60 <HW_IF_RX_Enable>:
  * @retval None
  */
void HW_IF_RX_Enable(uint8_t PortNum)
{
  /* Set the port state to waiting */
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_WAITING;
 800ad60:	23f0      	movs	r3, #240	; 0xf0
 800ad62:	005b      	lsls	r3, r3, #1
 800ad64:	4343      	muls	r3, r0
 800ad66:	4805      	ldr	r0, [pc, #20]	; (800ad7c <HW_IF_RX_Enable+0x1c>)
 800ad68:	18c0      	adds	r0, r0, r3
 800ad6a:	2305      	movs	r3, #5
 800ad6c:	7643      	strb	r3, [r0, #25]

  if (Ports[PortNum].cbs.USBPD_HW_IF_ReceiveMessage != NULL)
 800ad6e:	30b9      	adds	r0, #185	; 0xb9
 800ad70:	30ff      	adds	r0, #255	; 0xff
 800ad72:	6803      	ldr	r3, [r0, #0]
 800ad74:	2b00      	cmp	r3, #0
 800ad76:	d000      	beq.n	800ad7a <HW_IF_RX_Enable+0x1a>
 800ad78:	46c0      	nop			; (mov r8, r8)
  {
    __NOP();
  }
}
 800ad7a:	4770      	bx	lr
 800ad7c:	20000058 	.word	0x20000058

0800ad80 <HW_IF_RX_Disable>:
  * @retval None
  */
void HW_IF_RX_Disable(uint8_t PortNum)
{
  /* The port is ready to transmit */
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800ad80:	23f0      	movs	r3, #240	; 0xf0
 800ad82:	005b      	lsls	r3, r3, #1
 800ad84:	4343      	muls	r3, r0
 800ad86:	4805      	ldr	r0, [pc, #20]	; (800ad9c <HW_IF_RX_Disable+0x1c>)
 800ad88:	18c0      	adds	r0, r0, r3
 800ad8a:	2301      	movs	r3, #1
 800ad8c:	7643      	strb	r3, [r0, #25]
  
  if (Ports[PortNum].cbs.USBPD_HW_IF_ReceiveMessage != NULL)
 800ad8e:	30b9      	adds	r0, #185	; 0xb9
 800ad90:	30ff      	adds	r0, #255	; 0xff
 800ad92:	6803      	ldr	r3, [r0, #0]
 800ad94:	2b00      	cmp	r3, #0
 800ad96:	d000      	beq.n	800ad9a <HW_IF_RX_Disable+0x1a>
 800ad98:	46c0      	nop			; (mov r8, r8)
  {
    __NOP();
  }
}
 800ad9a:	4770      	bx	lr
 800ad9c:	20000058 	.word	0x20000058

0800ada0 <HW_IF_Port_SetInitialRole>:
  * @param  PortNum The port index
  * @param  role
  * @retval None
  */ 
void HW_IF_Port_SetInitialRole(uint8_t PortNum,USBPD_PortPowerRole_TypeDef role)
{
 800ada0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  CAD_HW_HandleTypeDef *_handle = &CAD_HW_Handles[PortNum];
  
  if (USBPD_TRUE == _handle->settings->CAD_RoleToggle)
 800ada2:	2318      	movs	r3, #24
 800ada4:	2601      	movs	r6, #1
 800ada6:	4343      	muls	r3, r0
 800ada8:	4a98      	ldr	r2, [pc, #608]	; (800b00c <HW_IF_Port_SetInitialRole+0x26c>)
{
 800adaa:	000f      	movs	r7, r1
  if (USBPD_TRUE == _handle->settings->CAD_RoleToggle)
 800adac:	589b      	ldr	r3, [r3, r2]
 800adae:	7a9d      	ldrb	r5, [r3, #10]
 800adb0:	4035      	ands	r5, r6
 800adb2:	d04a      	beq.n	800ae4a <HW_IF_Port_SetInitialRole+0xaa>
    /* Dual Role */
    /*0x18*/  
#if defined(CONF_DEMO)
    STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_1_5_A);
#else
    STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 800adb4:	1e44      	subs	r4, r0, #1
 800adb6:	41a0      	sbcs	r0, r4
 800adb8:	3028      	adds	r0, #40	; 0x28
 800adba:	0004      	movs	r4, r0
 800adbc:	2102      	movs	r1, #2
 800adbe:	f7fb fe6f 	bl	8006aa0 <STUSB1602_Current_Advertised_Set>
#endif
    STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800adc2:	0031      	movs	r1, r6
 800adc4:	0020      	movs	r0, r4
 800adc6:	f7fb fe9a 	bl	8006afe <STUSB1602_VCONN_Discharge_Status_Set>
#ifdef _APPLI_VCONN_SUPPORT
    STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Enable_on_CC_pin);    
#else
    STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800adca:	2100      	movs	r1, #0
 800adcc:	0020      	movs	r0, r4
 800adce:	f7fb fede 	bl	8006b8e <STUSB1602_VCONN_Supply_Status_Set>
#endif
    STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);    
 800add2:	2100      	movs	r1, #0
 800add4:	0020      	movs	r0, r4
 800add6:	f7fb feaa 	bl	8006b2e <STUSB1602_Data_Role_Swap_Status_Set>
    STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);    
 800adda:	2100      	movs	r1, #0
 800addc:	0020      	movs	r0, r4
 800adde:	f7fb febe 	bl	8006b5e <STUSB1602_Power_Role_Swap_Status_Set>

    /*0x1E*/
    STUSB1602_VCONN_Switch_Current_Limit_Set(STUSB1602_I2C_Add(PortNum), ILIM_350_ma);
 800ade2:	2100      	movs	r1, #0
 800ade4:	0020      	movs	r0, r4
 800ade6:	f7fb fee8 	bl	8006bba <STUSB1602_VCONN_Switch_Current_Limit_Set>

    /*0x1F*/
    STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), DRP_w_accessory_supp);  
 800adea:	2103      	movs	r1, #3
 800adec:	0020      	movs	r0, r4
 800adee:	f7fc f816 	bl	8006e1e <STUSB1602_Power_Mode_Set>

    /*0x20*/
    STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800adf2:	2100      	movs	r1, #0
 800adf4:	0020      	movs	r0, r4
 800adf6:	f7fb ff0e 	bl	8006c16 <STUSB1602_VCONN_Monitor_Status_Set>
    STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800adfa:	2100      	movs	r1, #0
 800adfc:	0020      	movs	r0, r4
 800adfe:	f7fb ff21 	bl	8006c44 <STUSB1602_VCONN_UVLO_Thresh_Status_Set>

    /*0x21*/
    STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800ae02:	4983      	ldr	r1, [pc, #524]	; (800b010 <HW_IF_Port_SetInitialRole+0x270>)
 800ae04:	0020      	movs	r0, r4
 800ae06:	f7fb ff43 	bl	8006c90 <STUSB1602_VBUS_Select_Status_Set>

    /*0x22*/
    STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20); 
 800ae0a:	2114      	movs	r1, #20
 800ae0c:	0020      	movs	r0, r4
 800ae0e:	f7fb ff59 	bl	8006cc4 <STUSB1602_VBUS_VShift_High_Set>
    STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800ae12:	2114      	movs	r1, #20
 800ae14:	0020      	movs	r0, r4
 800ae16:	4249      	negs	r1, r1
 800ae18:	f7fb ff6c 	bl	8006cf4 <STUSB1602_VBUS_VShift_Low_Set>

    /*0x25*/
    STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800ae1c:	2193      	movs	r1, #147	; 0x93
 800ae1e:	0020      	movs	r0, r4
 800ae20:	0089      	lsls	r1, r1, #2
 800ae22:	f7fb ffae 	bl	8006d82 <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
    STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800ae26:	21c8      	movs	r1, #200	; 0xc8
 800ae28:	0020      	movs	r0, r4
 800ae2a:	f7fb ffc5 	bl	8006db8 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>

    /*0x2E*/
    STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
 800ae2e:	2100      	movs	r1, #0
 800ae30:	0020      	movs	r0, r4
 800ae32:	f7fc f823 	bl	8006e7c <STUSB1602_VDD_OVLO_Threshold_Set>

#if defined(CONF_DEMO)
    STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Disable);
#else
 //   STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
    STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Disable);
 800ae36:	0031      	movs	r1, r6
 800ae38:	0020      	movs	r0, r4
 800ae3a:	f7fc f837 	bl	8006eac <STUSB1602_VBUS_Range_State_Set>
#endif

    STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V); /* default value is VBUS_vSafe0V_Thr_0_6V, VBUS_vSafe0V_Thr_1_8V */
 800ae3e:	2100      	movs	r1, #0

      /*0x2E*/
      STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);

      STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V); /* default value is VBUS_vSafe0V_Thr_0_6V, VBUS_vSafe0V_Thr_1_8V */
 800ae40:	0020      	movs	r0, r4
 800ae42:	f7fc f84b 	bl	8006edc <STUSB1602_VBUS_VSAFE0V_Threshold_Set>
      STUSB1602_VDD_UVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_UVLO_Disable);
 800ae46:	0031      	movs	r1, r6
 800ae48:	e0db      	b.n	800b002 <HW_IF_Port_SetInitialRole+0x262>
    switch (role)
 800ae4a:	2900      	cmp	r1, #0
 800ae4c:	d04d      	beq.n	800aeea <HW_IF_Port_SetInitialRole+0x14a>
 800ae4e:	2901      	cmp	r1, #1
 800ae50:	d100      	bne.n	800ae54 <HW_IF_Port_SetInitialRole+0xb4>
 800ae52:	e088      	b.n	800af66 <HW_IF_Port_SetInitialRole+0x1c6>
      STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A);
 800ae54:	1e44      	subs	r4, r0, #1
 800ae56:	41a0      	sbcs	r0, r4
 800ae58:	3028      	adds	r0, #40	; 0x28
 800ae5a:	0004      	movs	r4, r0
 800ae5c:	2102      	movs	r1, #2
 800ae5e:	f7fb fe1f 	bl	8006aa0 <STUSB1602_Current_Advertised_Set>
      STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800ae62:	0031      	movs	r1, r6
 800ae64:	0020      	movs	r0, r4
 800ae66:	f7fb fe4a 	bl	8006afe <STUSB1602_VCONN_Discharge_Status_Set>
      STUSB1602_SNK_Disconnect_Mode_Status_Set(STUSB1602_I2C_Add(PortNum), VBUS_or_SRC_removed);
 800ae6a:	0029      	movs	r1, r5
 800ae6c:	0020      	movs	r0, r4
 800ae6e:	f7fb fe2e 	bl	8006ace <STUSB1602_SNK_Disconnect_Mode_Status_Set>
      STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800ae72:	0029      	movs	r1, r5
 800ae74:	0020      	movs	r0, r4
 800ae76:	f7fb fe8a 	bl	8006b8e <STUSB1602_VCONN_Supply_Status_Set>
      STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);
 800ae7a:	0029      	movs	r1, r5
 800ae7c:	0020      	movs	r0, r4
 800ae7e:	f7fb fe56 	bl	8006b2e <STUSB1602_Data_Role_Swap_Status_Set>
      STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);
 800ae82:	0029      	movs	r1, r5
 800ae84:	0020      	movs	r0, r4
 800ae86:	f7fb fe6a 	bl	8006b5e <STUSB1602_Power_Role_Swap_Status_Set>
      STUSB1602_VCONN_Switch_Current_Limit_Set(STUSB1602_I2C_Add(PortNum), ILIM_350_ma);
 800ae8a:	0029      	movs	r1, r5
 800ae8c:	0020      	movs	r0, r4
 800ae8e:	f7fb fe94 	bl	8006bba <STUSB1602_VCONN_Switch_Current_Limit_Set>
      STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), DRP_w_accessory_supp);  
 800ae92:	2103      	movs	r1, #3
 800ae94:	0020      	movs	r0, r4
 800ae96:	f7fb ffc2 	bl	8006e1e <STUSB1602_Power_Mode_Set>
      STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800ae9a:	0029      	movs	r1, r5
 800ae9c:	0020      	movs	r0, r4
 800ae9e:	f7fb feba 	bl	8006c16 <STUSB1602_VCONN_Monitor_Status_Set>
      STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800aea2:	0029      	movs	r1, r5
 800aea4:	0020      	movs	r0, r4
 800aea6:	f7fb fecd 	bl	8006c44 <STUSB1602_VCONN_UVLO_Thresh_Status_Set>
      STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800aeaa:	4959      	ldr	r1, [pc, #356]	; (800b010 <HW_IF_Port_SetInitialRole+0x270>)
 800aeac:	0020      	movs	r0, r4
 800aeae:	f7fb feef 	bl	8006c90 <STUSB1602_VBUS_Select_Status_Set>
      STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20); 
 800aeb2:	2114      	movs	r1, #20
 800aeb4:	0020      	movs	r0, r4
 800aeb6:	f7fb ff05 	bl	8006cc4 <STUSB1602_VBUS_VShift_High_Set>
      STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800aeba:	2114      	movs	r1, #20
 800aebc:	0020      	movs	r0, r4
 800aebe:	4249      	negs	r1, r1
 800aec0:	f7fb ff18 	bl	8006cf4 <STUSB1602_VBUS_VShift_Low_Set>
      STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800aec4:	2193      	movs	r1, #147	; 0x93
 800aec6:	0020      	movs	r0, r4
 800aec8:	0089      	lsls	r1, r1, #2
 800aeca:	f7fb ff5a 	bl	8006d82 <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
      STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800aece:	21c8      	movs	r1, #200	; 0xc8
 800aed0:	0020      	movs	r0, r4
 800aed2:	f7fb ff71 	bl	8006db8 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>
      STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
 800aed6:	0029      	movs	r1, r5
 800aed8:	0020      	movs	r0, r4
 800aeda:	f7fb ffcf 	bl	8006e7c <STUSB1602_VDD_OVLO_Threshold_Set>
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
 800aede:	0029      	movs	r1, r5
 800aee0:	0020      	movs	r0, r4
 800aee2:	f7fb ffe3 	bl	8006eac <STUSB1602_VBUS_Range_State_Set>
      STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V); /* default value is VBUS_vSafe0V_Thr_0_6V, VBUS_vSafe0V_Thr_1_8V */
 800aee6:	0029      	movs	r1, r5
 800aee8:	e7aa      	b.n	800ae40 <HW_IF_Port_SetInitialRole+0xa0>
      STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);
 800aeea:	1e44      	subs	r4, r0, #1
 800aeec:	41a0      	sbcs	r0, r4
 800aeee:	3028      	adds	r0, #40	; 0x28
 800aef0:	0004      	movs	r4, r0
 800aef2:	f7fb fe1c 	bl	8006b2e <STUSB1602_Data_Role_Swap_Status_Set>
      STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);
 800aef6:	0039      	movs	r1, r7
 800aef8:	0020      	movs	r0, r4
 800aefa:	f7fb fe30 	bl	8006b5e <STUSB1602_Power_Role_Swap_Status_Set>
      STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800aefe:	0031      	movs	r1, r6
 800af00:	0020      	movs	r0, r4
 800af02:	f7fb fdfc 	bl	8006afe <STUSB1602_VCONN_Discharge_Status_Set>
      STUSB1602_SNK_Disconnect_Mode_Status_Set(STUSB1602_I2C_Add(PortNum), VBUS_or_SRC_removed);
 800af06:	0039      	movs	r1, r7
 800af08:	0020      	movs	r0, r4
 800af0a:	f7fb fde0 	bl	8006ace <STUSB1602_SNK_Disconnect_Mode_Status_Set>
      STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800af0e:	0039      	movs	r1, r7
 800af10:	0020      	movs	r0, r4
 800af12:	f7fb fe3c 	bl	8006b8e <STUSB1602_VCONN_Supply_Status_Set>
      STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), SNK_without_accessory_supp);  
 800af16:	2102      	movs	r1, #2
 800af18:	0020      	movs	r0, r4
 800af1a:	f7fb ff80 	bl	8006e1e <STUSB1602_Power_Mode_Set>
      STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800af1e:	0039      	movs	r1, r7
 800af20:	0020      	movs	r0, r4
 800af22:	f7fb fe78 	bl	8006c16 <STUSB1602_VCONN_Monitor_Status_Set>
      STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800af26:	0039      	movs	r1, r7
 800af28:	0020      	movs	r0, r4
 800af2a:	f7fb fe8b 	bl	8006c44 <STUSB1602_VCONN_UVLO_Thresh_Status_Set>
      STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800af2e:	4938      	ldr	r1, [pc, #224]	; (800b010 <HW_IF_Port_SetInitialRole+0x270>)
 800af30:	0020      	movs	r0, r4
 800af32:	f7fb fead 	bl	8006c90 <STUSB1602_VBUS_Select_Status_Set>
      STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20); 
 800af36:	2114      	movs	r1, #20
 800af38:	0020      	movs	r0, r4
 800af3a:	f7fb fec3 	bl	8006cc4 <STUSB1602_VBUS_VShift_High_Set>
      STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800af3e:	2114      	movs	r1, #20
 800af40:	0020      	movs	r0, r4
 800af42:	4249      	negs	r1, r1
 800af44:	f7fb fed6 	bl	8006cf4 <STUSB1602_VBUS_VShift_Low_Set>
      STUSB1602_Pwr_Acc_Detect_Set(STUSB1602_I2C_Add(PortNum), Pwr_Acc_Detect_Disable); 
 800af48:	0039      	movs	r1, r7
 800af4a:	0020      	movs	r0, r4
 800af4c:	f7fb ff03 	bl	8006d56 <STUSB1602_Pwr_Acc_Detect_Set>
      STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800af50:	2193      	movs	r1, #147	; 0x93
 800af52:	0020      	movs	r0, r4
 800af54:	0089      	lsls	r1, r1, #2
 800af56:	f7fb ff14 	bl	8006d82 <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
      STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800af5a:	21c8      	movs	r1, #200	; 0xc8
 800af5c:	0020      	movs	r0, r4
 800af5e:	f7fb ff2b 	bl	8006db8 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
 800af62:	0039      	movs	r1, r7
 800af64:	e768      	b.n	800ae38 <HW_IF_Port_SetInitialRole+0x98>
      STUSB1602_Current_Advertised_Set(STUSB1602_I2C_Add(PortNum), USB_C_Current_3_0_A); /* USB_C_Current_3_A */
 800af66:	1e44      	subs	r4, r0, #1
 800af68:	41a0      	sbcs	r0, r4
 800af6a:	3028      	adds	r0, #40	; 0x28
 800af6c:	0004      	movs	r4, r0
 800af6e:	2102      	movs	r1, #2
 800af70:	f7fb fd96 	bl	8006aa0 <STUSB1602_Current_Advertised_Set>
      STUSB1602_VCONN_Discharge_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Discharge_Enable_250ms_on_CC_pin);
 800af74:	0039      	movs	r1, r7
 800af76:	0020      	movs	r0, r4
 800af78:	f7fb fdc1 	bl	8006afe <STUSB1602_VCONN_Discharge_Status_Set>
      STUSB1602_VCONN_Supply_Status_Set(STUSB1602_I2C_Add(PortNum), VCONN_Supply_Capability_Disable_on_CC_pin);
 800af7c:	0029      	movs	r1, r5
 800af7e:	0020      	movs	r0, r4
 800af80:	f7fb fe05 	bl	8006b8e <STUSB1602_VCONN_Supply_Status_Set>
      STUSB1602_Data_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Data_Role_Swap_Disable);
 800af84:	0029      	movs	r1, r5
 800af86:	0020      	movs	r0, r4
 800af88:	f7fb fdd1 	bl	8006b2e <STUSB1602_Data_Role_Swap_Status_Set>
      STUSB1602_Power_Role_Swap_Status_Set(STUSB1602_I2C_Add(PortNum), Power_Role_Swap_Disable);
 800af8c:	0029      	movs	r1, r5
 800af8e:	0020      	movs	r0, r4
 800af90:	f7fb fde5 	bl	8006b5e <STUSB1602_Power_Role_Swap_Status_Set>
      STUSB1602_VCONN_Switch_Current_Limit_Set(STUSB1602_I2C_Add(PortNum), ILIM_350_ma);
 800af94:	0029      	movs	r1, r5
 800af96:	0020      	movs	r0, r4
 800af98:	f7fb fe0f 	bl	8006bba <STUSB1602_VCONN_Switch_Current_Limit_Set>
      STUSB1602_Power_Mode_Set(STUSB1602_I2C_Add(PortNum), SRC_with_accessory_supp);  
 800af9c:	0029      	movs	r1, r5
 800af9e:	0020      	movs	r0, r4
 800afa0:	f7fb ff3d 	bl	8006e1e <STUSB1602_Power_Mode_Set>
      STUSB1602_VCONN_Monitor_Status_Set(STUSB1602_I2C_Add(PortNum), Disable_UVLO_thr_detect_on_VCONN); 
 800afa4:	0029      	movs	r1, r5
 800afa6:	0020      	movs	r0, r4
 800afa8:	f7fb fe35 	bl	8006c16 <STUSB1602_VCONN_Monitor_Status_Set>
      STUSB1602_VCONN_UVLO_Thresh_Status_Set(STUSB1602_I2C_Add(PortNum), Hi_UVLO_thr_of_4_65_V);
 800afac:	0029      	movs	r1, r5
 800afae:	0020      	movs	r0, r4
 800afb0:	f7fb fe48 	bl	8006c44 <STUSB1602_VCONN_UVLO_Thresh_Status_Set>
      STUSB1602_VBUS_Select_Status_Set(STUSB1602_I2C_Add(PortNum), 5000); 
 800afb4:	4916      	ldr	r1, [pc, #88]	; (800b010 <HW_IF_Port_SetInitialRole+0x270>)
 800afb6:	0020      	movs	r0, r4
 800afb8:	f7fb fe6a 	bl	8006c90 <STUSB1602_VBUS_Select_Status_Set>
      STUSB1602_VBUS_VShift_High_Set(STUSB1602_I2C_Add(PortNum), 20);
 800afbc:	2114      	movs	r1, #20
 800afbe:	0020      	movs	r0, r4
 800afc0:	f7fb fe80 	bl	8006cc4 <STUSB1602_VBUS_VShift_High_Set>
      STUSB1602_VBUS_VShift_Low_Set(STUSB1602_I2C_Add(PortNum), -20); 
 800afc4:	2114      	movs	r1, #20
 800afc6:	0020      	movs	r0, r4
 800afc8:	4249      	negs	r1, r1
 800afca:	f7fb fe93 	bl	8006cf4 <STUSB1602_VBUS_VShift_Low_Set>
      STUSB1602_VBUS_Discharge_Time_to_0V_Set(STUSB1602_I2C_Add(PortNum), 84*7);
 800afce:	2193      	movs	r1, #147	; 0x93
 800afd0:	0020      	movs	r0, r4
 800afd2:	0089      	lsls	r1, r1, #2
 800afd4:	f7fb fed5 	bl	8006d82 <STUSB1602_VBUS_Discharge_Time_to_0V_Set>
      STUSB1602_VBUS_Discharge_Time_to_PDO_Set(STUSB1602_I2C_Add(PortNum), 200);
 800afd8:	21c8      	movs	r1, #200	; 0xc8
 800afda:	0020      	movs	r0, r4
 800afdc:	f7fb feec 	bl	8006db8 <STUSB1602_VBUS_Discharge_Time_to_PDO_Set>
      STUSB1602_VBUS_Discharge_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Discharge_Path_Enable); 
 800afe0:	0039      	movs	r1, r7
 800afe2:	0020      	movs	r0, r4
 800afe4:	f7fb ff04 	bl	8006df0 <STUSB1602_VBUS_Discharge_State_Set>
      STUSB1602_VDD_OVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_OVLO_Enable);
 800afe8:	0029      	movs	r1, r5
 800afea:	0020      	movs	r0, r4
 800afec:	f7fb ff46 	bl	8006e7c <STUSB1602_VDD_OVLO_Threshold_Set>
      STUSB1602_VBUS_Range_State_Set(STUSB1602_I2C_Add(PortNum), VBUS_Range_Enable);
 800aff0:	0029      	movs	r1, r5
 800aff2:	0020      	movs	r0, r4
 800aff4:	f7fb ff5a 	bl	8006eac <STUSB1602_VBUS_Range_State_Set>
      STUSB1602_VBUS_VSAFE0V_Threshold_Set(STUSB1602_I2C_Add(PortNum), VBUS_vSafe0V_Thr_0_6V);
 800aff8:	0029      	movs	r1, r5
 800affa:	0020      	movs	r0, r4
 800affc:	f7fb ff6e 	bl	8006edc <STUSB1602_VBUS_VSAFE0V_Threshold_Set>
      STUSB1602_VDD_UVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_UVLO_Disable);
 800b000:	0039      	movs	r1, r7
      STUSB1602_VDD_UVLO_Threshold_Set(STUSB1602_I2C_Add(PortNum), VDD_UVLO_Disable);
 800b002:	0020      	movs	r0, r4
 800b004:	f7fb ff83 	bl	8006f0e <STUSB1602_VDD_UVLO_Threshold_Set>
    break;
    }
  }
}
 800b008:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b00a:	46c0      	nop			; (mov r8, r8)
 800b00c:	20001c68 	.word	0x20001c68
 800b010:	00001388 	.word	0x00001388

0800b014 <HW_IF_check_bus_idle>:
  * @param  PortNum The port index
  * @retval USBPD_StatusTypeDef
  */
USBPD_StatusTypeDef HW_IF_check_bus_idle(uint8_t PortNum)
{
  return (((Ports[PortNum].CCx == CCNONE) || ((HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET))) ? USBPD_BUSY : USBPD_OK);
 800b014:	22f0      	movs	r2, #240	; 0xf0
 800b016:	0052      	lsls	r2, r2, #1
 800b018:	4342      	muls	r2, r0
 800b01a:	4b0c      	ldr	r3, [pc, #48]	; (800b04c <HW_IF_check_bus_idle+0x38>)
{
 800b01c:	b510      	push	{r4, lr}
  return (((Ports[PortNum].CCx == CCNONE) || ((HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET))) ? USBPD_BUSY : USBPD_OK);
 800b01e:	189b      	adds	r3, r3, r2
 800b020:	7d9b      	ldrb	r3, [r3, #22]
 800b022:	2b00      	cmp	r3, #0
 800b024:	d00a      	beq.n	800b03c <HW_IF_check_bus_idle+0x28>
 800b026:	2800      	cmp	r0, #0
 800b028:	d00b      	beq.n	800b042 <HW_IF_check_bus_idle+0x2e>
 800b02a:	2090      	movs	r0, #144	; 0x90
 800b02c:	2180      	movs	r1, #128	; 0x80
 800b02e:	05c0      	lsls	r0, r0, #23
 800b030:	0209      	lsls	r1, r1, #8
 800b032:	f7fc fd7d 	bl	8007b30 <HAL_GPIO_ReadPin>
 800b036:	2300      	movs	r3, #0
 800b038:	4298      	cmp	r0, r3
 800b03a:	d100      	bne.n	800b03e <HW_IF_check_bus_idle+0x2a>
 800b03c:	2303      	movs	r3, #3
}
 800b03e:	0018      	movs	r0, r3
 800b040:	bd10      	pop	{r4, pc}
  return (((Ports[PortNum].CCx == CCNONE) || ((HAL_GPIO_ReadPin(SPI_NSS_PORT(PortNum), SPI_NSS_PIN(PortNum)) == GPIO_PIN_RESET))) ? USBPD_BUSY : USBPD_OK);
 800b042:	2180      	movs	r1, #128	; 0x80
 800b044:	4802      	ldr	r0, [pc, #8]	; (800b050 <HW_IF_check_bus_idle+0x3c>)
 800b046:	0149      	lsls	r1, r1, #5
 800b048:	e7f3      	b.n	800b032 <HW_IF_check_bus_idle+0x1e>
 800b04a:	46c0      	nop			; (mov r8, r8)
 800b04c:	20000058 	.word	0x20000058
 800b050:	48000400 	.word	0x48000400

0800b054 <HW_IF_NSS_RisingFalling_Interrupt>:
  * @param  PortNum The port index
  * @param  status Two allowed values: ENABLE or DISABLE
  * @retval None
  */ 
void HW_IF_NSS_RisingFalling_Interrupt (uint8_t PortNum ,FunctionalState status)
{
 800b054:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800b056:	0004      	movs	r4, r0
 800b058:	000d      	movs	r5, r1
  LL_EXTI_InitTypeDef EXTI_InitStruct;

  if (status == ENABLE)
 800b05a:	2901      	cmp	r1, #1
 800b05c:	d12a      	bne.n	800b0b4 <HW_IF_NSS_RisingFalling_Interrupt+0x60>
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800b05e:	2380      	movs	r3, #128	; 0x80
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800b060:	20c1      	movs	r0, #193	; 0xc1
 800b062:	2180      	movs	r1, #128	; 0x80
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800b064:	4a20      	ldr	r2, [pc, #128]	; (800b0e8 <HW_IF_NSS_RisingFalling_Interrupt+0x94>)
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800b066:	0080      	lsls	r0, r0, #2
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800b068:	6013      	str	r3, [r2, #0]
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800b06a:	5813      	ldr	r3, [r2, r0]
 800b06c:	0609      	lsls	r1, r1, #24
 800b06e:	021b      	lsls	r3, r3, #8
 800b070:	0a1b      	lsrs	r3, r3, #8
 800b072:	430b      	orrs	r3, r1
 800b074:	5013      	str	r3, [r2, r0]
    /* NVIC configuration*/
    NVIC_EnableIRQ(SPI_NSS_LL_IRQHANDLER(PortNum));
    NVIC_SetPriority(SPI_NSS_LL_IRQHANDLER(PortNum),SPI_NSS_LL_IRQPRIORITY(PortNum));

    /* External Line initialization */
    LL_APB1_GRP2_EnableClock(SPI_NSS_LL_APB(PortNum));
 800b076:	f7ff fc8b 	bl	800a990 <LL_APB1_GRP2_EnableClock.constprop.7>
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800b07a:	2c00      	cmp	r4, #0
 800b07c:	d117      	bne.n	800b0ae <HW_IF_NSS_RisingFalling_Interrupt+0x5a>
 800b07e:	0028      	movs	r0, r5
 800b080:	2103      	movs	r1, #3

    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800b082:	4263      	negs	r3, r4
 800b084:	415c      	adcs	r4, r3
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800b086:	f7ff fc45 	bl	800a914 <LL_SYSCFG_SetEXTISource>
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800b08a:	4b18      	ldr	r3, [pc, #96]	; (800b0ec <HW_IF_NSS_RisingFalling_Interrupt+0x98>)
 800b08c:	4264      	negs	r4, r4
 800b08e:	401c      	ands	r4, r3
 800b090:	2380      	movs	r3, #128	; 0x80
 800b092:	021b      	lsls	r3, r3, #8
 800b094:	18e4      	adds	r4, r4, r3
    EXTI_InitStruct.LineCommand = ENABLE;
 800b096:	466a      	mov	r2, sp
 800b098:	2301      	movs	r3, #1
 800b09a:	7113      	strb	r3, [r2, #4]
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 800b09c:	2300      	movs	r3, #0
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800b09e:	9400      	str	r4, [sp, #0]
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 800b0a0:	7153      	strb	r3, [r2, #5]
    EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_RISING_FALLING;
 800b0a2:	3303      	adds	r3, #3
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));

    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
    EXTI_InitStruct.LineCommand = DISABLE;
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
    EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_NONE;
 800b0a4:	7193      	strb	r3, [r2, #6]
    LL_EXTI_Init(&EXTI_InitStruct);
 800b0a6:	4668      	mov	r0, sp
 800b0a8:	f7fe fa8c 	bl	80095c4 <LL_EXTI_Init>
  }  
}
 800b0ac:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800b0ae:	2000      	movs	r0, #0
 800b0b0:	490f      	ldr	r1, [pc, #60]	; (800b0f0 <HW_IF_NSS_RisingFalling_Interrupt+0x9c>)
 800b0b2:	e7e6      	b.n	800b082 <HW_IF_NSS_RisingFalling_Interrupt+0x2e>
  *         (*) value not defined in all devices.
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP2_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB2ENR, Periphs);
 800b0b4:	2001      	movs	r0, #1
 800b0b6:	4a0f      	ldr	r2, [pc, #60]	; (800b0f4 <HW_IF_NSS_RisingFalling_Interrupt+0xa0>)
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800b0b8:	2103      	movs	r1, #3
 800b0ba:	6993      	ldr	r3, [r2, #24]
 800b0bc:	4383      	bics	r3, r0
 800b0be:	6193      	str	r3, [r2, #24]
 800b0c0:	2c00      	cmp	r4, #0
 800b0c2:	d001      	beq.n	800b0c8 <HW_IF_NSS_RisingFalling_Interrupt+0x74>
 800b0c4:	2000      	movs	r0, #0
 800b0c6:	490a      	ldr	r1, [pc, #40]	; (800b0f0 <HW_IF_NSS_RisingFalling_Interrupt+0x9c>)
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800b0c8:	4263      	negs	r3, r4
 800b0ca:	415c      	adcs	r4, r3
    LL_SYSCFG_SetEXTISource(SPI_NSS_LL_PORT(PortNum), SPI_NSS_LL_SYS_EXTI(PortNum));
 800b0cc:	f7ff fc22 	bl	800a914 <LL_SYSCFG_SetEXTISource>
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800b0d0:	4b06      	ldr	r3, [pc, #24]	; (800b0ec <HW_IF_NSS_RisingFalling_Interrupt+0x98>)
 800b0d2:	4264      	negs	r4, r4
 800b0d4:	401c      	ands	r4, r3
 800b0d6:	2380      	movs	r3, #128	; 0x80
 800b0d8:	021b      	lsls	r3, r3, #8
 800b0da:	18e4      	adds	r4, r4, r3
    EXTI_InitStruct.LineCommand = DISABLE;
 800b0dc:	466a      	mov	r2, sp
 800b0de:	2300      	movs	r3, #0
    EXTI_InitStruct.Line_0_31 = SPI_NSS_LL_EXTI(PortNum);
 800b0e0:	9400      	str	r4, [sp, #0]
    EXTI_InitStruct.LineCommand = DISABLE;
 800b0e2:	7113      	strb	r3, [r2, #4]
    EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
 800b0e4:	7153      	strb	r3, [r2, #5]
 800b0e6:	e7dd      	b.n	800b0a4 <HW_IF_NSS_RisingFalling_Interrupt+0x50>
 800b0e8:	e000e100 	.word	0xe000e100
 800b0ec:	ffff9000 	.word	0xffff9000
 800b0f0:	000c0003 	.word	0x000c0003
 800b0f4:	40021000 	.word	0x40021000

0800b0f8 <HW_IF_COUNTER_TIM_Init>:
  * @brief  Initialization of counter
  * @param  PortNum The port index
  * @retval None
  */ 
void HW_IF_COUNTER_TIM_Init(uint8_t PortNum)
{
 800b0f8:	b5f0      	push	{r4, r5, r6, r7, lr}
  /* Get the peripheral handler variable */
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800b0fa:	25f0      	movs	r5, #240	; 0xf0
 800b0fc:	006d      	lsls	r5, r5, #1
 800b0fe:	4345      	muls	r5, r0
 800b100:	4b25      	ldr	r3, [pc, #148]	; (800b198 <HW_IF_COUNTER_TIM_Init+0xa0>)
  
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig;
  TIM_OC_InitTypeDef sConfigOC;
  
  htimcountrx->Instance =                       RX_COUNTTIM(PortNum);
 800b102:	4242      	negs	r2, r0
 800b104:	4150      	adcs	r0, r2
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800b106:	002e      	movs	r6, r5
  htimcountrx->Instance =                       RX_COUNTTIM(PortNum);
 800b108:	195d      	adds	r5, r3, r5
 800b10a:	002f      	movs	r7, r5
 800b10c:	4a23      	ldr	r2, [pc, #140]	; (800b19c <HW_IF_COUNTER_TIM_Init+0xa4>)
 800b10e:	4240      	negs	r0, r0
 800b110:	0280      	lsls	r0, r0, #10
 800b112:	1880      	adds	r0, r0, r2
 800b114:	37fc      	adds	r7, #252	; 0xfc
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800b116:	3679      	adds	r6, #121	; 0x79
{
 800b118:	b08f      	sub	sp, #60	; 0x3c
  htimcountrx->Instance =                       RX_COUNTTIM(PortNum);
 800b11a:	67f8      	str	r0, [r7, #124]	; 0x7c
  TIM_HandleTypeDef* htimcountrx = &(Ports[PortNum].htimcountrx);
 800b11c:	36ff      	adds	r6, #255	; 0xff
 800b11e:	18f6      	adds	r6, r6, r3
  htimcountrx->Init.Prescaler =                 ( HAL_RCC_GetHCLKFreq() / 1000000 ) - 1; // 1us Resolution
 800b120:	002c      	movs	r4, r5
 800b122:	f7fd f89d 	bl	8008260 <HAL_RCC_GetHCLKFreq>
 800b126:	491e      	ldr	r1, [pc, #120]	; (800b1a0 <HW_IF_COUNTER_TIM_Init+0xa8>)
 800b128:	f7fa fc4e 	bl	80059c8 <__udivsi3>
 800b12c:	347d      	adds	r4, #125	; 0x7d
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800b12e:	002b      	movs	r3, r5
  htimcountrx->Init.Prescaler =                 ( HAL_RCC_GetHCLKFreq() / 1000000 ) - 1; // 1us Resolution
 800b130:	34ff      	adds	r4, #255	; 0xff
 800b132:	3801      	subs	r0, #1
  htimcountrx->Init.Period =                    DMA_TIME_ELAPSED;
 800b134:	223c      	movs	r2, #60	; 0x3c
  htimcountrx->Init.Prescaler =                 ( HAL_RCC_GetHCLKFreq() / 1000000 ) - 1; // 1us Resolution
 800b136:	6020      	str	r0, [r4, #0]
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800b138:	2400      	movs	r4, #0
 800b13a:	3381      	adds	r3, #129	; 0x81
  htimcountrx->Init.ClockDivision =             TIM_CLOCKDIVISION_DIV1;
  htimcountrx->Init.RepetitionCounter =         0;
 800b13c:	358d      	adds	r5, #141	; 0x8d
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800b13e:	33ff      	adds	r3, #255	; 0xff
  htimcountrx->Init.RepetitionCounter =         0;
 800b140:	35ff      	adds	r5, #255	; 0xff
  htimcountrx->Init.Period =                    DMA_TIME_ELAPSED;
 800b142:	605a      	str	r2, [r3, #4]
  htimcountrx->Init.CounterMode =               TIM_COUNTERMODE_UP;
 800b144:	601c      	str	r4, [r3, #0]
  htimcountrx->Init.ClockDivision =             TIM_CLOCKDIVISION_DIV1;
 800b146:	609c      	str	r4, [r3, #8]
  htimcountrx->Init.RepetitionCounter =         0;
 800b148:	602c      	str	r4, [r5, #0]
  HAL_TIM_Base_Init(htimcountrx);
 800b14a:	0030      	movs	r0, r6
 800b14c:	f7fd fe82 	bl	8008e54 <HAL_TIM_Base_Init>
  
  HAL_TIM_OC_Init(htimcountrx);
 800b150:	0030      	movs	r0, r6
 800b152:	f7fd fe9a 	bl	8008e8a <HAL_TIM_OC_Init>
  sBreakDeadTimeConfig.OffStateRunMode =        TIM_OSSR_DISABLE;
  sBreakDeadTimeConfig.OffStateIDLEMode =       TIM_OSSI_DISABLE;
  sBreakDeadTimeConfig.LockLevel =              TIM_LOCKLEVEL_OFF;
  sBreakDeadTimeConfig.DeadTime =               0;
  sBreakDeadTimeConfig.BreakState =             TIM_BREAK_DISABLE;
  sBreakDeadTimeConfig.BreakPolarity =          TIM_BREAKPOLARITY_HIGH;
 800b156:	2380      	movs	r3, #128	; 0x80
  sBreakDeadTimeConfig.AutomaticOutput =        TIM_AUTOMATICOUTPUT_DISABLE;
  HAL_TIMEx_ConfigBreakDeadTime(htimcountrx, &sBreakDeadTimeConfig);
 800b158:	4669      	mov	r1, sp
  sBreakDeadTimeConfig.BreakPolarity =          TIM_BREAKPOLARITY_HIGH;
 800b15a:	019b      	lsls	r3, r3, #6
  HAL_TIMEx_ConfigBreakDeadTime(htimcountrx, &sBreakDeadTimeConfig);
 800b15c:	0030      	movs	r0, r6
  sBreakDeadTimeConfig.BreakPolarity =          TIM_BREAKPOLARITY_HIGH;
 800b15e:	9305      	str	r3, [sp, #20]
  sBreakDeadTimeConfig.OffStateRunMode =        TIM_OSSR_DISABLE;
 800b160:	9400      	str	r4, [sp, #0]
  sBreakDeadTimeConfig.OffStateIDLEMode =       TIM_OSSI_DISABLE;
 800b162:	9401      	str	r4, [sp, #4]
  sBreakDeadTimeConfig.LockLevel =              TIM_LOCKLEVEL_OFF;
 800b164:	9402      	str	r4, [sp, #8]
  sBreakDeadTimeConfig.DeadTime =               0;
 800b166:	9403      	str	r4, [sp, #12]
  sBreakDeadTimeConfig.BreakState =             TIM_BREAK_DISABLE;
 800b168:	9404      	str	r4, [sp, #16]
  sBreakDeadTimeConfig.AutomaticOutput =        TIM_AUTOMATICOUTPUT_DISABLE;
 800b16a:	9406      	str	r4, [sp, #24]
  HAL_TIMEx_ConfigBreakDeadTime(htimcountrx, &sBreakDeadTimeConfig);
 800b16c:	f7fd ffb6 	bl	80090dc <HAL_TIMEx_ConfigBreakDeadTime>
  
  sConfigOC.OCMode =                            TIM_OCMODE_TIMING;
  sConfigOC.Pulse =                             DMA_TIME_COUNT_COMPARE;
 800b170:	230a      	movs	r3, #10
  sConfigOC.OCPolarity =                        TIM_OCPOLARITY_HIGH;
  sConfigOC.OCNPolarity =                       TIM_OCNPOLARITY_HIGH;
  sConfigOC.OCFastMode =                        TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState =                       TIM_OCIDLESTATE_RESET;
  sConfigOC.OCNIdleState =                      TIM_OCNIDLESTATE_RESET;
  HAL_TIM_OC_ConfigChannel(htimcountrx, &sConfigOC, RX_COUNTTIMCH(PortNum));
 800b172:	0022      	movs	r2, r4
 800b174:	a907      	add	r1, sp, #28
 800b176:	0030      	movs	r0, r6
  sConfigOC.Pulse =                             DMA_TIME_COUNT_COMPARE;
 800b178:	9308      	str	r3, [sp, #32]
  sConfigOC.OCMode =                            TIM_OCMODE_TIMING;
 800b17a:	9407      	str	r4, [sp, #28]
  sConfigOC.OCPolarity =                        TIM_OCPOLARITY_HIGH;
 800b17c:	9409      	str	r4, [sp, #36]	; 0x24
  sConfigOC.OCNPolarity =                       TIM_OCNPOLARITY_HIGH;
 800b17e:	940a      	str	r4, [sp, #40]	; 0x28
  sConfigOC.OCFastMode =                        TIM_OCFAST_DISABLE;
 800b180:	940b      	str	r4, [sp, #44]	; 0x2c
  sConfigOC.OCIdleState =                       TIM_OCIDLESTATE_RESET;
 800b182:	940c      	str	r4, [sp, #48]	; 0x30
  sConfigOC.OCNIdleState =                      TIM_OCNIDLESTATE_RESET;
 800b184:	940d      	str	r4, [sp, #52]	; 0x34
  HAL_TIM_OC_ConfigChannel(htimcountrx, &sConfigOC, RX_COUNTTIMCH(PortNum));
 800b186:	f7fd fedb 	bl	8008f40 <HAL_TIM_OC_ConfigChannel>
  
  __HAL_TIM_CLEAR_IT(htimcountrx, TIM_IT_UPDATE);
 800b18a:	2202      	movs	r2, #2
 800b18c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 800b18e:	4252      	negs	r2, r2
 800b190:	611a      	str	r2, [r3, #16]
}
 800b192:	b00f      	add	sp, #60	; 0x3c
 800b194:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b196:	46c0      	nop			; (mov r8, r8)
 800b198:	20000058 	.word	0x20000058
 800b19c:	40014800 	.word	0x40014800
 800b1a0:	000f4240 	.word	0x000f4240

0800b1a4 <STUSB16xx_HW_IF_TX_DMA_Init>:
  * @brief  Initialization of DMA for transmission
  * @param  PortNum The port index
  * @retval None
  */ 
void STUSB16xx_HW_IF_TX_DMA_Init(uint8_t PortNum)
{
 800b1a4:	23f0      	movs	r3, #240	; 0xf0
 800b1a6:	005b      	lsls	r3, r3, #1
 800b1a8:	4343      	muls	r3, r0
 800b1aa:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800b1ac:	001e      	movs	r6, r3
 800b1ae:	9301      	str	r3, [sp, #4]
  
  /* Set the DMA handler of the peripheral handler */
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800b1b0:	9a01      	ldr	r2, [sp, #4]
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800b1b2:	4b18      	ldr	r3, [pc, #96]	; (800b214 <STUSB16xx_HW_IF_TX_DMA_Init+0x70>)
 800b1b4:	36a4      	adds	r6, #164	; 0xa4
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800b1b6:	189c      	adds	r4, r3, r2
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800b1b8:	18f6      	adds	r6, r6, r3
  
  /* Peripheral DMA init*/
  hdma_tx_spi->Instance =                   TX_DMACH(PortNum);
 800b1ba:	0003      	movs	r3, r0
 800b1bc:	1e5a      	subs	r2, r3, #1
 800b1be:	4193      	sbcs	r3, r2
 800b1c0:	2227      	movs	r2, #39	; 0x27
 800b1c2:	425b      	negs	r3, r3
 800b1c4:	4393      	bics	r3, r2
 800b1c6:	4a14      	ldr	r2, [pc, #80]	; (800b218 <STUSB16xx_HW_IF_TX_DMA_Init+0x74>)
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800b1c8:	0027      	movs	r7, r4
  hdma_tx_spi->Instance =                   TX_DMACH(PortNum);
 800b1ca:	189b      	adds	r3, r3, r2
 800b1cc:	0022      	movs	r2, r4
 800b1ce:	32a4      	adds	r2, #164	; 0xa4
 800b1d0:	6013      	str	r3, [r2, #0]
  hdma_tx_spi->Init.Direction =             DMA_MEMORY_TO_PERIPH;
 800b1d2:	0023      	movs	r3, r4
 800b1d4:	2210      	movs	r2, #16
 800b1d6:	33a8      	adds	r3, #168	; 0xa8
 800b1d8:	601a      	str	r2, [r3, #0]
  hdma_tx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800b1da:	0022      	movs	r2, r4
 800b1dc:	2300      	movs	r3, #0
  hdma_tx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800b1de:	2180      	movs	r1, #128	; 0x80
{
 800b1e0:	0005      	movs	r5, r0
  hdma_tx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800b1e2:	32ac      	adds	r2, #172	; 0xac
  Ports[PortNum].hspi.hdmatx = hdma_tx_spi;
 800b1e4:	3794      	adds	r7, #148	; 0x94
 800b1e6:	603e      	str	r6, [r7, #0]
  hdma_tx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800b1e8:	6051      	str	r1, [r2, #4]
  hdma_tx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800b1ea:	6013      	str	r3, [r2, #0]
  hdma_tx_spi->Init.PeriphDataAlignment =   DMA_PDATAALIGN_BYTE;
 800b1ec:	6093      	str	r3, [r2, #8]
  hdma_tx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800b1ee:	60d3      	str	r3, [r2, #12]
  hdma_tx_spi->Init.Mode =                  DMA_NORMAL;
 800b1f0:	6113      	str	r3, [r2, #16]
  hdma_tx_spi->Init.Priority =              DMACHIRQ_PRIO(PortNum);
 800b1f2:	6153      	str	r3, [r2, #20]
  HAL_DMA_Init(hdma_tx_spi);
 800b1f4:	0030      	movs	r0, r6
 800b1f6:	f7fc fb31 	bl	800785c <HAL_DMA_Init>
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
  
  /* Enable IRQ DMA */
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800b1fa:	4268      	negs	r0, r5
 800b1fc:	4168      	adcs	r0, r5
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800b1fe:	9b01      	ldr	r3, [sp, #4]
 800b200:	4a04      	ldr	r2, [pc, #16]	; (800b214 <STUSB16xx_HW_IF_TX_DMA_Init+0x70>)
 800b202:	3340      	adds	r3, #64	; 0x40
 800b204:	18d3      	adds	r3, r2, r3
 800b206:	34c8      	adds	r4, #200	; 0xc8
 800b208:	603e      	str	r6, [r7, #0]
 800b20a:	6023      	str	r3, [r4, #0]
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800b20c:	300a      	adds	r0, #10
 800b20e:	f7fc fa23 	bl	8007658 <HAL_NVIC_EnableIRQ>
}
 800b212:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800b214:	20000058 	.word	0x20000058
 800b218:	40020058 	.word	0x40020058

0800b21c <STUSB16xx_HW_IF_RX_DMA_Init>:
  * @brief  Initialization DMA for reception
  * @param  PortNum The port index
  * @retval None
  */ 
void STUSB16xx_HW_IF_RX_DMA_Init(uint8_t PortNum)
{
 800b21c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800b21e:	26f0      	movs	r6, #240	; 0xf0
 800b220:	0076      	lsls	r6, r6, #1
 800b222:	4346      	muls	r6, r0
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_rx_spi = &(Ports[PortNum].hdmarx);
 800b224:	0033      	movs	r3, r6
 800b226:	4a17      	ldr	r2, [pc, #92]	; (800b284 <STUSB16xx_HW_IF_RX_DMA_Init+0x68>)
 800b228:	33e8      	adds	r3, #232	; 0xe8
 800b22a:	189b      	adds	r3, r3, r2
 800b22c:	9301      	str	r3, [sp, #4]
 
  /* Peripheral DMA init*/
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800b22e:	0003      	movs	r3, r0
 800b230:	1e5a      	subs	r2, r3, #1
 800b232:	4193      	sbcs	r3, r2
 800b234:	2227      	movs	r2, #39	; 0x27
 800b236:	425b      	negs	r3, r3
 800b238:	4393      	bics	r3, r2
 800b23a:	4a13      	ldr	r2, [pc, #76]	; (800b288 <STUSB16xx_HW_IF_RX_DMA_Init+0x6c>)
  hdma_rx_spi->Init.Direction =             DMA_PERIPH_TO_MEMORY;
  hdma_rx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
  hdma_rx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800b23c:	2180      	movs	r1, #128	; 0x80
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800b23e:	189b      	adds	r3, r3, r2
 800b240:	4a10      	ldr	r2, [pc, #64]	; (800b284 <STUSB16xx_HW_IF_RX_DMA_Init+0x68>)
{
 800b242:	0005      	movs	r5, r0
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800b244:	1994      	adds	r4, r2, r6
 800b246:	0022      	movs	r2, r4
  hdma_rx_spi->Init.PeriphDataAlignment =   DMA_PDATAALIGN_BYTE;
  hdma_rx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800b248:	0027      	movs	r7, r4
  hdma_rx_spi->Instance =                   RX_DMACH(PortNum);
 800b24a:	32e8      	adds	r2, #232	; 0xe8
 800b24c:	6013      	str	r3, [r2, #0]
  hdma_rx_spi->Init.Direction =             DMA_PERIPH_TO_MEMORY;
 800b24e:	2300      	movs	r3, #0
  hdma_rx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800b250:	37fc      	adds	r7, #252	; 0xfc
  hdma_rx_spi->Init.Direction =             DMA_PERIPH_TO_MEMORY;
 800b252:	6053      	str	r3, [r2, #4]
  hdma_rx_spi->Init.PeriphInc =             DMA_PINC_DISABLE;
 800b254:	6093      	str	r3, [r2, #8]
  hdma_rx_spi->Init.PeriphDataAlignment =   DMA_PDATAALIGN_BYTE;
 800b256:	6113      	str	r3, [r2, #16]
  hdma_rx_spi->Init.MemDataAlignment =      DMA_MDATAALIGN_BYTE;
 800b258:	603b      	str	r3, [r7, #0]
  hdma_rx_spi->Init.Mode =                  DMA_NORMAL;
 800b25a:	607b      	str	r3, [r7, #4]
  hdma_rx_spi->Init.Priority =              DMA_PRIORITY_VERY_HIGH;
 800b25c:	23c0      	movs	r3, #192	; 0xc0
 800b25e:	019b      	lsls	r3, r3, #6
 800b260:	60bb      	str	r3, [r7, #8]
  hdma_rx_spi->Init.MemInc =                DMA_MINC_ENABLE;
 800b262:	60d1      	str	r1, [r2, #12]
  HAL_DMA_Init(hdma_rx_spi);
 800b264:	9801      	ldr	r0, [sp, #4]
 800b266:	f7fc faf9 	bl	800785c <HAL_DMA_Init>
  Ports[PortNum].hspi.hdmarx = hdma_rx_spi; 
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmarx,(*hdma_rx_spi));

  /* Enable IRQ DMA */
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800b26a:	4268      	negs	r0, r5
 800b26c:	4168      	adcs	r0, r5
  Ports[PortNum].hspi.hdmarx = hdma_rx_spi; 
 800b26e:	9b01      	ldr	r3, [sp, #4]
 800b270:	3498      	adds	r4, #152	; 0x98
 800b272:	6023      	str	r3, [r4, #0]
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmarx,(*hdma_rx_spi));
 800b274:	4b03      	ldr	r3, [pc, #12]	; (800b284 <STUSB16xx_HW_IF_RX_DMA_Init+0x68>)
 800b276:	3640      	adds	r6, #64	; 0x40
 800b278:	199e      	adds	r6, r3, r6
 800b27a:	613e      	str	r6, [r7, #16]
  HAL_NVIC_EnableIRQ(DMACHIRQ(PortNum));
 800b27c:	300a      	adds	r0, #10
 800b27e:	f7fc f9eb 	bl	8007658 <HAL_NVIC_EnableIRQ>
  
}
 800b282:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800b284:	20000058 	.word	0x20000058
 800b288:	40020044 	.word	0x40020044

0800b28c <STUSB16xx_HW_IF_Set_DMA_Normal_Mode>:
  * @brief  It switches SPI DMA in normal mode
  * @param  PortNum The port index
  * @retval None
  */
void STUSB16xx_HW_IF_Set_DMA_Normal_Mode(uint8_t PortNum)
{
 800b28c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b28e:	24f0      	movs	r4, #240	; 0xf0
 800b290:	0064      	lsls	r4, r4, #1
 800b292:	4344      	muls	r4, r0
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800b294:	4e09      	ldr	r6, [pc, #36]	; (800b2bc <STUSB16xx_HW_IF_Set_DMA_Normal_Mode+0x30>)
 800b296:	0027      	movs	r7, r4
  
  hdma_tx_spi->Init.Mode =                  DMA_NORMAL;
 800b298:	1935      	adds	r5, r6, r4
 800b29a:	002b      	movs	r3, r5
 800b29c:	2200      	movs	r2, #0
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800b29e:	37a4      	adds	r7, #164	; 0xa4
 800b2a0:	19bf      	adds	r7, r7, r6
  hdma_tx_spi->Init.Mode =                  DMA_NORMAL;
 800b2a2:	33bc      	adds	r3, #188	; 0xbc
 800b2a4:	601a      	str	r2, [r3, #0]
  HAL_DMA_Init(hdma_tx_spi);
 800b2a6:	0038      	movs	r0, r7
 800b2a8:	f7fc fad8 	bl	800785c <HAL_DMA_Init>
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800b2ac:	002b      	movs	r3, r5
 800b2ae:	3440      	adds	r4, #64	; 0x40
 800b2b0:	35c8      	adds	r5, #200	; 0xc8
 800b2b2:	19a4      	adds	r4, r4, r6
 800b2b4:	3394      	adds	r3, #148	; 0x94
 800b2b6:	601f      	str	r7, [r3, #0]
 800b2b8:	602c      	str	r4, [r5, #0]
}
 800b2ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b2bc:	20000058 	.word	0x20000058

0800b2c0 <STUSB16xx_HW_IF_Set_DMA_Circular_Mode>:
  * @brief  It switches SPI DMA in circular mode
  * @param  PortNum The port index
  * @retval None
  */
void STUSB16xx_HW_IF_Set_DMA_Circular_Mode(uint8_t PortNum)
{
 800b2c0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800b2c2:	24f0      	movs	r4, #240	; 0xf0
 800b2c4:	0064      	lsls	r4, r4, #1
 800b2c6:	4344      	muls	r4, r0
  /* Get the peripheral handler variable */
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800b2c8:	0023      	movs	r3, r4
 800b2ca:	4f0e      	ldr	r7, [pc, #56]	; (800b304 <STUSB16xx_HW_IF_Set_DMA_Circular_Mode+0x44>)
 800b2cc:	33a4      	adds	r3, #164	; 0xa4
  
  hdma_tx_spi->Init.Mode =                  DMA_CIRCULAR;
 800b2ce:	193e      	adds	r6, r7, r4
  DMA_HandleTypeDef* hdma_tx_spi = &(Ports[PortNum].hdmatx);
 800b2d0:	19db      	adds	r3, r3, r7
 800b2d2:	9301      	str	r3, [sp, #4]
  hdma_tx_spi->Init.Mode =                  DMA_CIRCULAR;
 800b2d4:	0033      	movs	r3, r6
 800b2d6:	2220      	movs	r2, #32
 800b2d8:	33bc      	adds	r3, #188	; 0xbc
{
 800b2da:	0005      	movs	r5, r0
  hdma_tx_spi->Init.Mode =                  DMA_CIRCULAR;
 800b2dc:	601a      	str	r2, [r3, #0]
  HAL_DMA_Init(hdma_tx_spi);
 800b2de:	9801      	ldr	r0, [sp, #4]
 800b2e0:	f7fc fabc 	bl	800785c <HAL_DMA_Init>
  
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800b2e4:	0033      	movs	r3, r6
 800b2e6:	9a01      	ldr	r2, [sp, #4]
 800b2e8:	3394      	adds	r3, #148	; 0x94
 800b2ea:	601a      	str	r2, [r3, #0]
  
  /* DMA interrupt init */
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800b2ec:	4268      	negs	r0, r5
 800b2ee:	4168      	adcs	r0, r5
 800b2f0:	2200      	movs	r2, #0
  __HAL_LINKDMA((&Ports[PortNum].hspi),hdmatx,(*hdma_tx_spi));
 800b2f2:	3440      	adds	r4, #64	; 0x40
 800b2f4:	36c8      	adds	r6, #200	; 0xc8
 800b2f6:	19e7      	adds	r7, r4, r7
 800b2f8:	6037      	str	r7, [r6, #0]
  HAL_NVIC_SetPriority(DMACHIRQ(PortNum), DMACHIRQ_PRIO(PortNum), 0);
 800b2fa:	300a      	adds	r0, #10
 800b2fc:	0011      	movs	r1, r2
 800b2fe:	f7fc f981 	bl	8007604 <HAL_NVIC_SetPriority>
}
 800b302:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 800b304:	20000058 	.word	0x20000058

0800b308 <STUSB16xx_HW_IF_Switch_Mode>:
  * @param  PortNum The port index
  * @param  mode Two allowed values:  STUSB16xx_SPI_Mode_TX or STUSB16xx_SPI_Mode_RX
  * @retval None
  */ 
void STUSB16xx_HW_IF_Switch_Mode(uint8_t PortNum, STUSB1602_SPI_Mode_TypeDef mode)
{
 800b308:	b570      	push	{r4, r5, r6, lr}
 800b30a:	000c      	movs	r4, r1

  /* Set the data sampling edge according to mode */
  HW_IF_SPI_Mode(PortNum, mode);  
  
  /* Enable/Disable RX NSS EXT Interrupt */
  HW_IF_NSS_RisingFalling_Interrupt (PortNum, mode == STUSB16xx_SPI_Mode_RX ? ENABLE : DISABLE);
 800b30c:	3c01      	subs	r4, #1
{
 800b30e:	0005      	movs	r5, r0
  HW_IF_SPI_Mode(PortNum, mode);  
 800b310:	f7ff fc16 	bl	800ab40 <HW_IF_SPI_Mode>
  HW_IF_NSS_RisingFalling_Interrupt (PortNum, mode == STUSB16xx_SPI_Mode_RX ? ENABLE : DISABLE);
 800b314:	4261      	negs	r1, r4
 800b316:	4161      	adcs	r1, r4
 800b318:	0028      	movs	r0, r5
 800b31a:	b2c9      	uxtb	r1, r1
 800b31c:	f7ff fe9a 	bl	800b054 <HW_IF_NSS_RisingFalling_Interrupt>
}
 800b320:	bd70      	pop	{r4, r5, r6, pc}
	...

0800b324 <STUSB16xx_HW_IF_TX_EN_Status>:
  * @param  PortNum The port index
  * @param  status Two allowed values: GPIO_PIN_SET or GPIO_PIN_RESET
  * @retval None
  */ 
void STUSB16xx_HW_IF_TX_EN_Status(uint8_t PortNum, GPIO_PinState status)
{
 800b324:	000a      	movs	r2, r1
 800b326:	b510      	push	{r4, lr}
  HAL_GPIO_WritePin(TX_EN_GPIO_PORT(PortNum), TX_EN_GPIO_PIN(PortNum), status);
 800b328:	2104      	movs	r1, #4
 800b32a:	2800      	cmp	r0, #0
 800b32c:	d000      	beq.n	800b330 <STUSB16xx_HW_IF_TX_EN_Status+0xc>
 800b32e:	1849      	adds	r1, r1, r1
 800b330:	4801      	ldr	r0, [pc, #4]	; (800b338 <STUSB16xx_HW_IF_TX_EN_Status+0x14>)
 800b332:	f7fc fc03 	bl	8007b3c <HAL_GPIO_WritePin>
}
 800b336:	bd10      	pop	{r4, pc}
 800b338:	48000800 	.word	0x48000800

0800b33c <HW_IF_STUSB16xx_Reset>:
{
 800b33c:	b570      	push	{r4, r5, r6, lr}
 800b33e:	0005      	movs	r5, r0
  HW_IF_RESET_Assert(PortNum);
 800b340:	2478      	movs	r4, #120	; 0x78
 800b342:	f7ff fcf5 	bl	800ad30 <HW_IF_RESET_Assert>
 800b346:	46c0      	nop			; (mov r8, r8)
 800b348:	3c01      	subs	r4, #1
 800b34a:	b2a4      	uxth	r4, r4
  for(uint16_t i=0;i<120;i++) 
 800b34c:	2c00      	cmp	r4, #0
 800b34e:	d1fa      	bne.n	800b346 <HW_IF_STUSB16xx_Reset+0xa>
  HW_IF_RESET_Deassert(PortNum);
 800b350:	0028      	movs	r0, r5
 800b352:	f7ff fcf9 	bl	800ad48 <HW_IF_RESET_Deassert>
  STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_RESET);
 800b356:	0028      	movs	r0, r5
 800b358:	0021      	movs	r1, r4
 800b35a:	f7ff ffe3 	bl	800b324 <STUSB16xx_HW_IF_TX_EN_Status>
}
 800b35e:	bd70      	pop	{r4, r5, r6, pc}

0800b360 <USBPD_HW_IF_PortHwInit>:
{
 800b360:	b084      	sub	sp, #16
 800b362:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b364:	b093      	sub	sp, #76	; 0x4c
 800b366:	ac19      	add	r4, sp, #100	; 0x64
 800b368:	60a3      	str	r3, [r4, #8]
 800b36a:	ab1f      	add	r3, sp, #124	; 0x7c
 800b36c:	781b      	ldrb	r3, [r3, #0]
 800b36e:	0005      	movs	r5, r0
 800b370:	9311      	str	r3, [sp, #68]	; 0x44
  nvm_read = 0;
 800b372:	2300      	movs	r3, #0
 800b374:	4f2e      	ldr	r7, [pc, #184]	; (800b430 <USBPD_HW_IF_PortHwInit+0xd0>)
{
 800b376:	9119      	str	r1, [sp, #100]	; 0x64
 800b378:	6062      	str	r2, [r4, #4]
  nvm_read = 0;
 800b37a:	703b      	strb	r3, [r7, #0]
  HW_IF_STUSB1602_IO_Init(PortNum);
 800b37c:	f7ff fc62 	bl	800ac44 <HW_IF_STUSB1602_IO_Init>
  HW_IF_STUSB16xx_Reset(PortNum);
 800b380:	0028      	movs	r0, r5
 800b382:	f7ff ffdb 	bl	800b33c <HW_IF_STUSB16xx_Reset>
  HW_IF_STUSB16xx_I2C_Init(PortNum);
 800b386:	0028      	movs	r0, r5
 800b388:	f7ff fc36 	bl	800abf8 <HW_IF_STUSB16xx_I2C_Init>
  STUSB1602_Driver_Init(PortNum, Ports[PortNum].hi2c);
 800b38c:	21f0      	movs	r1, #240	; 0xf0
 800b38e:	0049      	lsls	r1, r1, #1
 800b390:	4369      	muls	r1, r5
 800b392:	4b28      	ldr	r3, [pc, #160]	; (800b434 <USBPD_HW_IF_PortHwInit+0xd4>)
 800b394:	2240      	movs	r2, #64	; 0x40
 800b396:	1859      	adds	r1, r3, r1
 800b398:	000e      	movs	r6, r1
 800b39a:	3629      	adds	r6, #41	; 0x29
 800b39c:	36ff      	adds	r6, #255	; 0xff
 800b39e:	3139      	adds	r1, #57	; 0x39
 800b3a0:	31ff      	adds	r1, #255	; 0xff
 800b3a2:	4668      	mov	r0, sp
 800b3a4:	3604      	adds	r6, #4
 800b3a6:	f001 fbf9 	bl	800cb9c <memcpy>
 800b3aa:	ce0e      	ldmia	r6!, {r1, r2, r3}
  nvm_read = STUSB1602_NVM_OK_Get(STUSB1602_I2C_Add(PortNum));
 800b3ac:	002e      	movs	r6, r5
  STUSB1602_Driver_Init(PortNum, Ports[PortNum].hi2c);
 800b3ae:	0028      	movs	r0, r5
 800b3b0:	f7fb fab4 	bl	800691c <STUSB1602_Driver_Init>
  nvm_read = STUSB1602_NVM_OK_Get(STUSB1602_I2C_Add(PortNum));
 800b3b4:	1e73      	subs	r3, r6, #1
 800b3b6:	419e      	sbcs	r6, r3
 800b3b8:	3628      	adds	r6, #40	; 0x28
    nvm_read = STUSB1602_NVM_OK_Get(STUSB1602_I2C_Add(PortNum));
 800b3ba:	0030      	movs	r0, r6
 800b3bc:	f7fb fd46 	bl	8006e4c <STUSB1602_NVM_OK_Get>
 800b3c0:	7038      	strb	r0, [r7, #0]
  while (nvm_read != 2)
 800b3c2:	783b      	ldrb	r3, [r7, #0]
 800b3c4:	2b02      	cmp	r3, #2
 800b3c6:	d1f8      	bne.n	800b3ba <USBPD_HW_IF_PortHwInit+0x5a>
  Ports[PortNum].Device_cut = STUSB1602_DEVICE_CUT_Get(STUSB1602_I2C_Add(PortNum));
 800b3c8:	27f0      	movs	r7, #240	; 0xf0
 800b3ca:	007f      	lsls	r7, r7, #1
 800b3cc:	436f      	muls	r7, r5
 800b3ce:	0030      	movs	r0, r6
 800b3d0:	f7fb fd48 	bl	8006e64 <STUSB1602_DEVICE_CUT_Get>
 800b3d4:	4b17      	ldr	r3, [pc, #92]	; (800b434 <USBPD_HW_IF_PortHwInit+0xd4>)
 800b3d6:	19df      	adds	r7, r3, r7
 800b3d8:	003b      	movs	r3, r7
 800b3da:	33d9      	adds	r3, #217	; 0xd9
 800b3dc:	33ff      	adds	r3, #255	; 0xff
 800b3de:	7018      	strb	r0, [r3, #0]
  HW_IF_DMA_Init(PortNum);
 800b3e0:	0028      	movs	r0, r5
 800b3e2:	f7ff fbf1 	bl	800abc8 <HW_IF_DMA_Init>
  HW_IF_SPI_Init(PortNum);
 800b3e6:	0028      	movs	r0, r5
 800b3e8:	f7ff fb7c 	bl	800aae4 <HW_IF_SPI_Init>
  HW_IF_COUNTER_TIM_Init(PortNum);
 800b3ec:	0028      	movs	r0, r5
 800b3ee:	f7ff fe83 	bl	800b0f8 <HW_IF_COUNTER_TIM_Init>
  HW_IF_Port_SetInitialRole(PortNum,role);
 800b3f2:	9911      	ldr	r1, [sp, #68]	; 0x44
 800b3f4:	0028      	movs	r0, r5
 800b3f6:	f7ff fcd3 	bl	800ada0 <HW_IF_Port_SetInitialRole>
  STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_RX);
 800b3fa:	0028      	movs	r0, r5
 800b3fc:	2101      	movs	r1, #1
 800b3fe:	f7ff ff83 	bl	800b308 <STUSB16xx_HW_IF_Switch_Mode>
    STUSB1602_CC_Detect_Alrt_Int_Mask_Set(STUSB1602_I2C_Add(PortNum), CC_Detect_Int_UNMASKED);
 800b402:	2100      	movs	r1, #0
 800b404:	0030      	movs	r0, r6
 800b406:	f7fb facd 	bl	80069a4 <STUSB1602_CC_Detect_Alrt_Int_Mask_Set>
  Ports[PortNum].cbs = cbs;
 800b40a:	003a      	movs	r2, r7
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800b40c:	2301      	movs	r3, #1
  Ports[PortNum].cbs = cbs;
 800b40e:	32b9      	adds	r2, #185	; 0xb9
 800b410:	32ff      	adds	r2, #255	; 0xff
  Ports[PortNum].State = HAL_USBPD_PORT_STATE_READY;
 800b412:	767b      	strb	r3, [r7, #25]
  Ports[PortNum].cbs = cbs;
 800b414:	0013      	movs	r3, r2
 800b416:	cc07      	ldmia	r4!, {r0, r1, r2}
 800b418:	c307      	stmia	r3!, {r0, r1, r2}
 800b41a:	cc07      	ldmia	r4!, {r0, r1, r2}
 800b41c:	c307      	stmia	r3!, {r0, r1, r2}
}
 800b41e:	2000      	movs	r0, #0
  Ports[PortNum].role = role;
 800b420:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800b422:	3701      	adds	r7, #1
 800b424:	77fb      	strb	r3, [r7, #31]
}
 800b426:	b013      	add	sp, #76	; 0x4c
 800b428:	bcf0      	pop	{r4, r5, r6, r7}
 800b42a:	bc08      	pop	{r3}
 800b42c:	b004      	add	sp, #16
 800b42e:	4718      	bx	r3
 800b430:	200003dc 	.word	0x200003dc
 800b434:	20000058 	.word	0x20000058

0800b438 <STUSB16xx_HW_IF_Alert_Check>:
  * @param  PortNum The port index
  * @retval None
  */ 
void STUSB16xx_HW_IF_Alert_Check(uint8_t PortNum)
{
  Ports[PortNum].AlertEventCount++;
 800b438:	23f0      	movs	r3, #240	; 0xf0
 800b43a:	005b      	lsls	r3, r3, #1
 800b43c:	4343      	muls	r3, r0
 800b43e:	4804      	ldr	r0, [pc, #16]	; (800b450 <STUSB16xx_HW_IF_Alert_Check+0x18>)
 800b440:	18c0      	adds	r0, r0, r3
 800b442:	30d1      	adds	r0, #209	; 0xd1
 800b444:	30ff      	adds	r0, #255	; 0xff
 800b446:	7803      	ldrb	r3, [r0, #0]
 800b448:	3301      	adds	r3, #1
 800b44a:	7003      	strb	r3, [r0, #0]
}
 800b44c:	4770      	bx	lr
 800b44e:	46c0      	nop			; (mov r8, r8)
 800b450:	20000058 	.word	0x20000058

0800b454 <STUSB16xx_HW_IF_Alert_Manager>:
  * @brief  It manages registers related to STUSB1602 ALERT interrupts
  * @param  PortNum The port index
  * @retval USBPD_StatusTypeDef
  */ 
USBPD_StatusTypeDef STUSB16xx_HW_IF_Alert_Manager(uint8_t PortNum)
{
 800b454:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b456:	0004      	movs	r4, r0
 800b458:	26c8      	movs	r6, #200	; 0xc8
 800b45a:	b085      	sub	sp, #20
 800b45c:	46c0      	nop			; (mov r8, r8)
 800b45e:	3e01      	subs	r6, #1
  uint8_t AlertAttempts;
  uint8_t AlertAccomplished;
  uint32_t i;

  /* Delay of few us in order to be sure that registers are updated*/
  for(i=0; i<200; i++)
 800b460:	2e00      	cmp	r6, #0
 800b462:	d1fb      	bne.n	800b45c <STUSB16xx_HW_IF_Alert_Manager+0x8>
  AlertAttempts = 10;
  
  while(1)
  {
    /* Registers from 0x0B to 0x12 are read */
    STUSB1602_AlertMonitoring_Value = STUSB1602_Alert_Monitoring_Get(STUSB1602_I2C_Add(PortNum));
 800b464:	0025      	movs	r5, r4
 800b466:	1e6b      	subs	r3, r5, #1
 800b468:	419d      	sbcs	r5, r3
 800b46a:	3528      	adds	r5, #40	; 0x28
 800b46c:	0029      	movs	r1, r5
 800b46e:	a802      	add	r0, sp, #8
 800b470:	f7fb fa8a 	bl	8006988 <STUSB1602_Alert_Monitoring_Get>
    
    /* Check ALERT due to a change occurred on CC */
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.CC_DETECTION_STATUS_AL) && \
 800b474:	2240      	movs	r2, #64	; 0x40
 800b476:	ab02      	add	r3, sp, #8
 800b478:	781b      	ldrb	r3, [r3, #0]
 800b47a:	9301      	str	r3, [sp, #4]
 800b47c:	9901      	ldr	r1, [sp, #4]
  AlertAccomplished = 0;
 800b47e:	0033      	movs	r3, r6
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.CC_DETECTION_STATUS_AL) && \
 800b480:	4211      	tst	r1, r2
 800b482:	d03e      	beq.n	800b502 <STUSB16xx_HW_IF_Alert_Manager+0xae>
        (!STUSB1602_AlertMonitoring_Value.reg_0C.b.CC_DETECTION_STATUS_AL_MASK) && \
 800b484:	ab02      	add	r3, sp, #8
 800b486:	7859      	ldrb	r1, [r3, #1]
  AlertAccomplished = 0;
 800b488:	0033      	movs	r3, r6
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.CC_DETECTION_STATUS_AL) && \
 800b48a:	4211      	tst	r1, r2
 800b48c:	d139      	bne.n	800b502 <STUSB16xx_HW_IF_Alert_Manager+0xae>
        (!STUSB1602_AlertMonitoring_Value.reg_0C.b.CC_DETECTION_STATUS_AL_MASK) && \
 800b48e:	2701      	movs	r7, #1
 800b490:	ab02      	add	r3, sp, #8
 800b492:	789a      	ldrb	r2, [r3, #2]
  AlertAccomplished = 0;
 800b494:	0033      	movs	r3, r6
        (!STUSB1602_AlertMonitoring_Value.reg_0C.b.CC_DETECTION_STATUS_AL_MASK) && \
 800b496:	423a      	tst	r2, r7
 800b498:	d033      	beq.n	800b502 <STUSB16xx_HW_IF_Alert_Manager+0xae>
        (STUSB1602_AlertMonitoring_Value.reg_0D.b.ATTACH_STATE_TRANS))
    {
      if (STUSB1602_AlertMonitoring_Value.reg_0E.b.CC_ATTACH_STATE)     /* CC line is ATTACHED */
 800b49a:	ab02      	add	r3, sp, #8
 800b49c:	78d8      	ldrb	r0, [r3, #3]
 800b49e:	496a      	ldr	r1, [pc, #424]	; (800b648 <STUSB16xx_HW_IF_Alert_Manager+0x1f4>)
 800b4a0:	4238      	tst	r0, r7
 800b4a2:	d100      	bne.n	800b4a6 <STUSB16xx_HW_IF_Alert_Manager+0x52>
 800b4a4:	e093      	b.n	800b5ce <STUSB16xx_HW_IF_Alert_Manager+0x17a>
      {
        /* Check the CC attach mode */
        switch (STUSB1602_AlertMonitoring_Value.reg_0E.b.CC_ATTACH_MODE)
 800b4a6:	0940      	lsrs	r0, r0, #5
 800b4a8:	3801      	subs	r0, #1
 800b4aa:	2318      	movs	r3, #24
 800b4ac:	2804      	cmp	r0, #4
 800b4ae:	d900      	bls.n	800b4b2 <STUSB16xx_HW_IF_Alert_Manager+0x5e>
 800b4b0:	e085      	b.n	800b5be <STUSB16xx_HW_IF_Alert_Manager+0x16a>
 800b4b2:	f7fa fa7f 	bl	80059b4 <__gnu_thumb1_case_uqi>
 800b4b6:	6c03      	.short	0x6c03
 800b4b8:	747c      	.short	0x747c
 800b4ba:	0c          	.byte	0x0c
 800b4bb:	00          	.byte	0x00
        {
        case Sink_Attached:
          /* USBPD_CAD_STATE_ATTACHED */
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_SWITCH_TO_SRC;
 800b4bc:	4363      	muls	r3, r4
 800b4be:	18cb      	adds	r3, r1, r3
 800b4c0:	210f      	movs	r1, #15
 800b4c2:	7c1a      	ldrb	r2, [r3, #16]
 800b4c4:	438a      	bics	r2, r1
 800b4c6:	0011      	movs	r1, r2
 800b4c8:	2209      	movs	r2, #9
          /*  */
          break;

        default:
          /* USPPD_CAD_STATE_UNKNOWN */
          CAD_HW_Handles[PortNum].state = USPPD_CAD_STATE_UNKNOW;
 800b4ca:	430a      	orrs	r2, r1
 800b4cc:	741a      	strb	r2, [r3, #16]
          break;
        }

        /* CAD handle is updated */
        CAD_HW_Handles[PortNum].cc = CCXHANDLE(STUSB1602_AlertMonitoring_Value.reg_11.b.CC_ATTACHED);
 800b4ce:	2118      	movs	r1, #24
 800b4d0:	2630      	movs	r6, #48	; 0x30
 800b4d2:	4361      	muls	r1, r4
 800b4d4:	4a5c      	ldr	r2, [pc, #368]	; (800b648 <STUSB16xx_HW_IF_Alert_Manager+0x1f4>)
 800b4d6:	ab02      	add	r3, sp, #8
 800b4d8:	799b      	ldrb	r3, [r3, #6]
 800b4da:	1851      	adds	r1, r2, r1
 800b4dc:	7c0a      	ldrb	r2, [r1, #16]
 800b4de:	09db      	lsrs	r3, r3, #7
 800b4e0:	3301      	adds	r3, #1
 800b4e2:	0118      	lsls	r0, r3, #4
 800b4e4:	43b2      	bics	r2, r6
 800b4e6:	4302      	orrs	r2, r0
 800b4e8:	740a      	strb	r2, [r1, #16]
  Ports[PortNum].CCx = cc;
 800b4ea:	21f0      	movs	r1, #240	; 0xf0
 800b4ec:	0049      	lsls	r1, r1, #1
 800b4ee:	4361      	muls	r1, r4
 800b4f0:	4a56      	ldr	r2, [pc, #344]	; (800b64c <STUSB16xx_HW_IF_Alert_Manager+0x1f8>)
  Ports[PortNum].CCxChange = SET;
 800b4f2:	3e2f      	subs	r6, #47	; 0x2f
  Ports[PortNum].CCx = cc;
 800b4f4:	1852      	adds	r2, r2, r1
 800b4f6:	7593      	strb	r3, [r2, #22]
  Ports[PortNum].CCxChange = SET;
 800b4f8:	75d6      	strb	r6, [r2, #23]

        /* Port handle is updated */
        HW_IF_Port_Set_CC(PortNum, CAD_HW_Handles[PortNum].cc);

        /* RX mode is enabled */
        HW_IF_RX_Enable(PortNum);
 800b4fa:	0020      	movs	r0, r4
 800b4fc:	f7ff fc30 	bl	800ad60 <HW_IF_RX_Enable>
        /* TX mode is enabled */
        HW_IF_RX_Disable(PortNum);
      }

      /* Exit from the alert check procedure */
      AlertAccomplished = 1;
 800b500:	0033      	movs	r3, r6
    }

    /* Check if a MONITORING STATUS ALERT detected */
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.MONITORING_STATUS_AL) && \
 800b502:	2220      	movs	r2, #32
 800b504:	9901      	ldr	r1, [sp, #4]
 800b506:	4211      	tst	r1, r2
 800b508:	d00b      	beq.n	800b522 <STUSB16xx_HW_IF_Alert_Manager+0xce>
      (!STUSB1602_AlertMonitoring_Value.reg_0C.b.MONITORING_STATUS_AL_MASK)) 
 800b50a:	a902      	add	r1, sp, #8
 800b50c:	7849      	ldrb	r1, [r1, #1]
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.MONITORING_STATUS_AL) && \
 800b50e:	4211      	tst	r1, r2
 800b510:	d107      	bne.n	800b522 <STUSB16xx_HW_IF_Alert_Manager+0xce>
    {
      /* Check changes occurred in MONITORING STATUS register and restore the ALERT pin */
      STUSB1602_Monitoring_Status_Trans_Value = STUSB1602_Monitoring_Status_Trans_Reg_Get(STUSB1602_I2C_Add(PortNum));
 800b512:	0028      	movs	r0, r5
 800b514:	f7fb fa74 	bl	8006a00 <STUSB1602_Monitoring_Status_Trans_Reg_Get>

      /* Exit from the alert check procedure */
      AlertAccomplished = 1;

      /* If the alert due to a monitoring event is unmasked remove the if statement and put your code */
      if (STUSB1602_Monitoring_Status_Trans_Value.d8 >0)
 800b518:	b2c0      	uxtb	r0, r0
      AlertAccomplished = 1;
 800b51a:	2301      	movs	r3, #1
      if (STUSB1602_Monitoring_Status_Trans_Value.d8 >0)
 800b51c:	2800      	cmp	r0, #0
 800b51e:	d000      	beq.n	800b522 <STUSB16xx_HW_IF_Alert_Manager+0xce>
 800b520:	46c0      	nop			; (mov r8, r8)
        __NOP();
      }
    }

    /* Check if a HW FAULT STATUS ALERT detected */
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.HW_FAULT_STATUS_AL) && \
 800b522:	aa02      	add	r2, sp, #8
 800b524:	7811      	ldrb	r1, [r2, #0]
 800b526:	2210      	movs	r2, #16
 800b528:	4211      	tst	r1, r2
 800b52a:	d066      	beq.n	800b5fa <STUSB16xx_HW_IF_Alert_Manager+0x1a6>
      (!STUSB1602_AlertMonitoring_Value.reg_0C.b.HW_FAULT_STATUS_AL_MASK)) 
 800b52c:	a902      	add	r1, sp, #8
 800b52e:	7849      	ldrb	r1, [r1, #1]
    if ((STUSB1602_AlertMonitoring_Value.reg_0B.b.HW_FAULT_STATUS_AL) && \
 800b530:	4211      	tst	r1, r2
 800b532:	d162      	bne.n	800b5fa <STUSB16xx_HW_IF_Alert_Manager+0x1a6>
    {
      /* Check changes occurred in HW FAULT STATUS register and restore the ALERT pin */
      STUSB1602_HW_Fault_Status_Trans_Value = STUSB1602_Hard_Fault_Trans_Status_Get(STUSB1602_I2C_Add(PortNum));
 800b534:	0028      	movs	r0, r5
 800b536:	f7fb faa9 	bl	8006a8c <STUSB1602_Hard_Fault_Trans_Status_Get>

      /* Exit from the alert check procedure */
      AlertAccomplished = 1;

      /* If the alert due to a hardware fault event is unmasked remove then if statement and put your code*/
      if (STUSB1602_HW_Fault_Status_Trans_Value.d8 >0)
 800b53a:	b2c0      	uxtb	r0, r0
 800b53c:	2800      	cmp	r0, #0
 800b53e:	d000      	beq.n	800b542 <STUSB16xx_HW_IF_Alert_Manager+0xee>
 800b540:	46c0      	nop			; (mov r8, r8)
 800b542:	2604      	movs	r6, #4
 800b544:	2c00      	cmp	r4, #0
 800b546:	d100      	bne.n	800b54a <STUSB16xx_HW_IF_Alert_Manager+0xf6>
 800b548:	2602      	movs	r6, #2
 800b54a:	270a      	movs	r7, #10
 800b54c:	b2b6      	uxth	r6, r6
  /* reset alert signal */
  uint8_t count = 10;
  uint8_t cleared_alert_flag = 0;
  while (1)
  {
    cleared_alert_flag = (HAL_GPIO_ReadPin(ALERT_GPIO_PORT(PortNum), ALERT_GPIO_PIN(PortNum)) != GPIO_PIN_RESET);
 800b54e:	2090      	movs	r0, #144	; 0x90
 800b550:	0031      	movs	r1, r6
 800b552:	05c0      	lsls	r0, r0, #23
 800b554:	f7fc faec 	bl	8007b30 <HAL_GPIO_ReadPin>
 800b558:	1e04      	subs	r4, r0, #0
    /* check if the alert pin is reset */
    if (cleared_alert_flag || count == 0) 
 800b55a:	d158      	bne.n	800b60e <STUSB16xx_HW_IF_Alert_Manager+0x1ba>
 800b55c:	2f00      	cmp	r7, #0
 800b55e:	d056      	beq.n	800b60e <STUSB16xx_HW_IF_Alert_Manager+0x1ba>
    {
      break;
    }
    if (STUSB16xx_I2CxHandle.Lock != HAL_LOCKED)
 800b560:	4b3b      	ldr	r3, [pc, #236]	; (800b650 <STUSB16xx_HW_IF_Alert_Manager+0x1fc>)
 800b562:	3340      	adds	r3, #64	; 0x40
 800b564:	781b      	ldrb	r3, [r3, #0]
 800b566:	2b01      	cmp	r3, #1
 800b568:	d0f1      	beq.n	800b54e <STUSB16xx_HW_IF_Alert_Manager+0xfa>
    {
      /* Restore the CC_DETECTION_STATUS_TRANS register*/
      STUSB1602_Attach_State_Trans_Get(STUSB1602_I2C_Add(PortNum));
 800b56a:	0028      	movs	r0, r5
 800b56c:	f7fb fa32 	bl	80069d4 <STUSB1602_Attach_State_Trans_Get>

      /* Restore the MONITORING_STATUS_TRANS register */
      STUSB1602_Monitoring_Status_Trans_Reg_Get(STUSB1602_I2C_Add(PortNum));
 800b570:	0028      	movs	r0, r5
 800b572:	f7fb fa45 	bl	8006a00 <STUSB1602_Monitoring_Status_Trans_Reg_Get>

      /* Restore the HARD_FAULT_TRANS register */
      STUSB1602_Hard_Fault_Trans_Status_Get(STUSB1602_I2C_Add(PortNum));
 800b576:	0028      	movs	r0, r5
 800b578:	f7fb fa88 	bl	8006a8c <STUSB1602_Hard_Fault_Trans_Status_Get>

      /* Decrement the counter to implement a TO */
      count--;
 800b57c:	23fa      	movs	r3, #250	; 0xfa
 800b57e:	3f01      	subs	r7, #1
 800b580:	b2ff      	uxtb	r7, r7
 800b582:	009b      	lsls	r3, r3, #2
 800b584:	46c0      	nop			; (mov r8, r8)
 800b586:	3b01      	subs	r3, #1

      /* wait a bit time */
      for(i=0; i<1000; i++)
 800b588:	2b00      	cmp	r3, #0
 800b58a:	d1fb      	bne.n	800b584 <STUSB16xx_HW_IF_Alert_Manager+0x130>
 800b58c:	e7df      	b.n	800b54e <STUSB16xx_HW_IF_Alert_Manager+0xfa>
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_SWITCH_TO_SNK;
 800b58e:	4363      	muls	r3, r4
 800b590:	18cb      	adds	r3, r1, r3
 800b592:	210f      	movs	r1, #15
 800b594:	7c1a      	ldrb	r2, [r3, #16]
 800b596:	438a      	bics	r2, r1
 800b598:	0011      	movs	r1, r2
 800b59a:	220a      	movs	r2, #10
 800b59c:	e795      	b.n	800b4ca <STUSB16xx_HW_IF_Alert_Manager+0x76>
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_ACCESSORY;
 800b59e:	4363      	muls	r3, r4
 800b5a0:	18cb      	adds	r3, r1, r3
 800b5a2:	210f      	movs	r1, #15
 800b5a4:	7c1a      	ldrb	r2, [r3, #16]
 800b5a6:	438a      	bics	r2, r1
 800b5a8:	0011      	movs	r1, r2
 800b5aa:	2207      	movs	r2, #7
 800b5ac:	e78d      	b.n	800b4ca <STUSB16xx_HW_IF_Alert_Manager+0x76>
          CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_DEBUG;
 800b5ae:	4363      	muls	r3, r4
 800b5b0:	18cb      	adds	r3, r1, r3
 800b5b2:	210f      	movs	r1, #15
 800b5b4:	7c1a      	ldrb	r2, [r3, #16]
 800b5b6:	438a      	bics	r2, r1
 800b5b8:	0011      	movs	r1, r2
 800b5ba:	2208      	movs	r2, #8
 800b5bc:	e785      	b.n	800b4ca <STUSB16xx_HW_IF_Alert_Manager+0x76>
          CAD_HW_Handles[PortNum].state = USPPD_CAD_STATE_UNKNOW;
 800b5be:	4363      	muls	r3, r4
 800b5c0:	18cb      	adds	r3, r1, r3
 800b5c2:	210f      	movs	r1, #15
 800b5c4:	7c1a      	ldrb	r2, [r3, #16]
 800b5c6:	438a      	bics	r2, r1
 800b5c8:	0011      	movs	r1, r2
 800b5ca:	220c      	movs	r2, #12
 800b5cc:	e77d      	b.n	800b4ca <STUSB16xx_HW_IF_Alert_Manager+0x76>
        CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_DETACHED;
 800b5ce:	2318      	movs	r3, #24
 800b5d0:	4363      	muls	r3, r4
 800b5d2:	18cb      	adds	r3, r1, r3
 800b5d4:	210f      	movs	r1, #15
 800b5d6:	7c1a      	ldrb	r2, [r3, #16]
        HW_IF_RX_Disable(PortNum);
 800b5d8:	0020      	movs	r0, r4
        CAD_HW_Handles[PortNum].state = USBPD_CAD_STATE_DETACHED;
 800b5da:	438a      	bics	r2, r1
        CAD_HW_Handles[PortNum].cc = CCNONE;
 800b5dc:	433a      	orrs	r2, r7
 800b5de:	3121      	adds	r1, #33	; 0x21
 800b5e0:	438a      	bics	r2, r1
 800b5e2:	741a      	strb	r2, [r3, #16]
  Ports[PortNum].CCx = cc;
 800b5e4:	22f0      	movs	r2, #240	; 0xf0
 800b5e6:	0052      	lsls	r2, r2, #1
 800b5e8:	4362      	muls	r2, r4
 800b5ea:	4b18      	ldr	r3, [pc, #96]	; (800b64c <STUSB16xx_HW_IF_Alert_Manager+0x1f8>)
 800b5ec:	189b      	adds	r3, r3, r2
 800b5ee:	759e      	strb	r6, [r3, #22]
  Ports[PortNum].CCxChange = SET;
 800b5f0:	75df      	strb	r7, [r3, #23]
        HW_IF_RX_Disable(PortNum);
 800b5f2:	f7ff fbc5 	bl	800ad80 <HW_IF_RX_Disable>
      AlertAccomplished = 1;
 800b5f6:	003b      	movs	r3, r7
 800b5f8:	e783      	b.n	800b502 <STUSB16xx_HW_IF_Alert_Manager+0xae>
    if (AlertAttempts == 0 || AlertAccomplished)
 800b5fa:	2b00      	cmp	r3, #0
 800b5fc:	d1a1      	bne.n	800b542 <STUSB16xx_HW_IF_Alert_Manager+0xee>
 800b5fe:	330a      	adds	r3, #10
 800b600:	46c0      	nop			; (mov r8, r8)
 800b602:	3b01      	subs	r3, #1
    for(i=0; i<10; i++)
 800b604:	2b00      	cmp	r3, #0
 800b606:	d1fb      	bne.n	800b600 <STUSB16xx_HW_IF_Alert_Manager+0x1ac>
      for(i=0; i<400000; i++) __NOP();
    }

  }
  return USBPD_OK;
} 
 800b608:	2000      	movs	r0, #0
 800b60a:	b005      	add	sp, #20
 800b60c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cleared_alert_flag |= (HAL_GPIO_ReadPin(ALERT_GPIO_PORT(PortNum), ALERT_GPIO_PIN(PortNum)) != GPIO_PIN_RESET);
 800b60e:	2090      	movs	r0, #144	; 0x90
 800b610:	0031      	movs	r1, r6
 800b612:	05c0      	lsls	r0, r0, #23
 800b614:	f7fc fa8c 	bl	8007b30 <HAL_GPIO_ReadPin>
  if (!cleared_alert_flag) {
 800b618:	4320      	orrs	r0, r4
 800b61a:	b2c0      	uxtb	r0, r0
 800b61c:	2800      	cmp	r0, #0
 800b61e:	d1f3      	bne.n	800b608 <STUSB16xx_HW_IF_Alert_Manager+0x1b4>
    USBPD_BSP_LED_Off(GREEN_USER_LED);
 800b620:	f7fb fcae 	bl	8006f80 <USBPD_BSP_LED_Off>
    USBPD_BSP_LED_Off(LED_PORT0_CC);
 800b624:	2003      	movs	r0, #3
 800b626:	f7fb fcab 	bl	8006f80 <USBPD_BSP_LED_Off>
    USBPD_BSP_LED_Off(LED_PORT0_VBUS);
 800b62a:	2002      	movs	r0, #2
 800b62c:	f7fb fca8 	bl	8006f80 <USBPD_BSP_LED_Off>
    USBPD_BSP_LED_Off(LED_PORT0_ROLE);
 800b630:	2001      	movs	r0, #1
 800b632:	f7fb fca5 	bl	8006f80 <USBPD_BSP_LED_Off>
      USBPD_BSP_LED_Toggle(PortNum == 0 ? LED_PORT0_CC : LED_PORT0_CC);
 800b636:	2003      	movs	r0, #3
 800b638:	f7fb fccc 	bl	8006fd4 <USBPD_BSP_LED_Toggle>
 800b63c:	4b05      	ldr	r3, [pc, #20]	; (800b654 <STUSB16xx_HW_IF_Alert_Manager+0x200>)
 800b63e:	46c0      	nop			; (mov r8, r8)
 800b640:	3b01      	subs	r3, #1
      for(i=0; i<400000; i++) __NOP();
 800b642:	2b00      	cmp	r3, #0
 800b644:	d1fb      	bne.n	800b63e <STUSB16xx_HW_IF_Alert_Manager+0x1ea>
 800b646:	e7f6      	b.n	800b636 <STUSB16xx_HW_IF_Alert_Manager+0x1e2>
 800b648:	20001c68 	.word	0x20001c68
 800b64c:	20000058 	.word	0x20000058
 800b650:	20001a50 	.word	0x20001a50
 800b654:	00061a80 	.word	0x00061a80

0800b658 <CAD_StateMachine>:
{
 800b658:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if (hhw_handle->AlertEventCount > 0)
 800b65a:	27f0      	movs	r7, #240	; 0xf0
{
 800b65c:	000d      	movs	r5, r1
  *Event = USBPD_CAD_EVENT_NONE;
 800b65e:	2100      	movs	r1, #0
  if (hhw_handle->AlertEventCount > 0)
 800b660:	007f      	lsls	r7, r7, #1
 800b662:	4347      	muls	r7, r0
 800b664:	4e51      	ldr	r6, [pc, #324]	; (800b7ac <CAD_StateMachine+0x154>)
{
 800b666:	0004      	movs	r4, r0
  if (hhw_handle->AlertEventCount > 0)
 800b668:	19f7      	adds	r7, r6, r7
 800b66a:	37d1      	adds	r7, #209	; 0xd1
 800b66c:	37ff      	adds	r7, #255	; 0xff
 800b66e:	783b      	ldrb	r3, [r7, #0]
{
 800b670:	9201      	str	r2, [sp, #4]
  *Event = USBPD_CAD_EVENT_NONE;
 800b672:	7029      	strb	r1, [r5, #0]
  if (hhw_handle->AlertEventCount > 0)
 800b674:	428b      	cmp	r3, r1
 800b676:	d00c      	beq.n	800b692 <CAD_StateMachine+0x3a>
    ret = HW_IF_COMM_WAIT(PortNum, 0);
 800b678:	f7ff f95c 	bl	800a934 <HW_IF_COMM_WAIT>
    if (ret == USBPD_OK)
 800b67c:	2800      	cmp	r0, #0
 800b67e:	d108      	bne.n	800b692 <CAD_StateMachine+0x3a>
      if (STUSB16xx_HW_IF_Alert_Manager(PortNum) == USBPD_OK)
 800b680:	0020      	movs	r0, r4
 800b682:	f7ff fee7 	bl	800b454 <STUSB16xx_HW_IF_Alert_Manager>
 800b686:	2800      	cmp	r0, #0
 800b688:	d100      	bne.n	800b68c <CAD_StateMachine+0x34>
        hhw_handle->AlertEventCount = 0;
 800b68a:	7038      	strb	r0, [r7, #0]
      HW_IF_COMM_RELEASE(PortNum);
 800b68c:	0020      	movs	r0, r4
 800b68e:	f7ff f96f 	bl	800a970 <HW_IF_COMM_RELEASE>
  switch(_handle->state)
 800b692:	2218      	movs	r2, #24
 800b694:	0013      	movs	r3, r2
 800b696:	4363      	muls	r3, r4
 800b698:	4945      	ldr	r1, [pc, #276]	; (800b7b0 <CAD_StateMachine+0x158>)
 800b69a:	18cb      	adds	r3, r1, r3
 800b69c:	7c18      	ldrb	r0, [r3, #16]
 800b69e:	23f0      	movs	r3, #240	; 0xf0
 800b6a0:	0700      	lsls	r0, r0, #28
 800b6a2:	0f00      	lsrs	r0, r0, #28
 800b6a4:	005b      	lsls	r3, r3, #1
 800b6a6:	280a      	cmp	r0, #10
 800b6a8:	d900      	bls.n	800b6ac <CAD_StateMachine+0x54>
 800b6aa:	e06b      	b.n	800b784 <CAD_StateMachine+0x12c>
 800b6ac:	f7fa f982 	bl	80059b4 <__gnu_thumb1_case_uqi>
 800b6b0:	6a6a0619 	.word	0x6a6a0619
 800b6b4:	6a6a6a6a 	.word	0x6a6a6a6a
 800b6b8:	566a      	.short	0x566a
 800b6ba:	71          	.byte	0x71
 800b6bb:	00          	.byte	0x00
    if (Ports[PortNum].NbDetach == 0)
 800b6bc:	4363      	muls	r3, r4
 800b6be:	18f3      	adds	r3, r6, r3
 800b6c0:	33d3      	adds	r3, #211	; 0xd3
 800b6c2:	33ff      	adds	r3, #255	; 0xff
 800b6c4:	9300      	str	r3, [sp, #0]
 800b6c6:	781b      	ldrb	r3, [r3, #0]
 800b6c8:	2b00      	cmp	r3, #0
 800b6ca:	d10a      	bne.n	800b6e2 <CAD_StateMachine+0x8a>
      if ((STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum))) == VBUS_below_VSAFE0V_threshold)
 800b6cc:	0027      	movs	r7, r4
 800b6ce:	1e7b      	subs	r3, r7, #1
 800b6d0:	419f      	sbcs	r7, r3
 800b6d2:	3728      	adds	r7, #40	; 0x28
 800b6d4:	0038      	movs	r0, r7
 800b6d6:	f7fb f9a9 	bl	8006a2c <STUSB1602_VBUS_VSAFE0V_Get>
 800b6da:	2801      	cmp	r0, #1
 800b6dc:	d126      	bne.n	800b72c <CAD_StateMachine+0xd4>
        Ports[PortNum].NbDetach = 1;
 800b6de:	9b00      	ldr	r3, [sp, #0]
 800b6e0:	7018      	strb	r0, [r3, #0]
    *Event = USBPD_CAD_EVENT_DETACHED;
 800b6e2:	2301      	movs	r3, #1
 800b6e4:	702b      	strb	r3, [r5, #0]
  if ((hhw_handle->CCxChange == SET) && (_handle->state != USBPD_CAD_STATE_SWITCH_TO_SRC) && (_handle->state != USBPD_CAD_STATE_SWITCH_TO_SNK))
 800b6e6:	23f0      	movs	r3, #240	; 0xf0
 800b6e8:	005b      	lsls	r3, r3, #1
 800b6ea:	4363      	muls	r3, r4
 800b6ec:	18f6      	adds	r6, r6, r3
 800b6ee:	7df3      	ldrb	r3, [r6, #23]
 800b6f0:	2b01      	cmp	r3, #1
 800b6f2:	d10f      	bne.n	800b714 <CAD_StateMachine+0xbc>
 800b6f4:	3317      	adds	r3, #23
 800b6f6:	4363      	muls	r3, r4
 800b6f8:	4a2d      	ldr	r2, [pc, #180]	; (800b7b0 <CAD_StateMachine+0x158>)
 800b6fa:	18d3      	adds	r3, r2, r3
 800b6fc:	220f      	movs	r2, #15
 800b6fe:	7c1b      	ldrb	r3, [r3, #16]
 800b700:	401a      	ands	r2, r3
 800b702:	3a09      	subs	r2, #9
 800b704:	2a01      	cmp	r2, #1
 800b706:	d905      	bls.n	800b714 <CAD_StateMachine+0xbc>
    *CCXX  = _handle->cc;
 800b708:	069b      	lsls	r3, r3, #26
 800b70a:	9a01      	ldr	r2, [sp, #4]
 800b70c:	0f9b      	lsrs	r3, r3, #30
 800b70e:	7013      	strb	r3, [r2, #0]
    hhw_handle->CCxChange = RESET;
 800b710:	2300      	movs	r3, #0
 800b712:	75f3      	strb	r3, [r6, #23]
  if ((*Event != USBPD_CAD_EVENT_DETACHED) || (previous_event[PortNum] != USBPD_CAD_EVENT_DETACHED))
 800b714:	782a      	ldrb	r2, [r5, #0]
 800b716:	4b27      	ldr	r3, [pc, #156]	; (800b7b4 <CAD_StateMachine+0x15c>)
 800b718:	2a01      	cmp	r2, #1
 800b71a:	d103      	bne.n	800b724 <CAD_StateMachine+0xcc>
 800b71c:	1919      	adds	r1, r3, r4
 800b71e:	7849      	ldrb	r1, [r1, #1]
 800b720:	2901      	cmp	r1, #1
 800b722:	d03f      	beq.n	800b7a4 <CAD_StateMachine+0x14c>
    previous_event[PortNum] = *Event;
 800b724:	191c      	adds	r4, r3, r4
 800b726:	7062      	strb	r2, [r4, #1]
}
 800b728:	2002      	movs	r0, #2
 800b72a:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        if  (STUSB1602_TypeC_FSM_State_Get(STUSB1602_I2C_Add(PortNum)) == Unattached_SNK)
 800b72c:	0038      	movs	r0, r7
 800b72e:	f7fb f9a1 	bl	8006a74 <STUSB1602_TypeC_FSM_State_Get>
 800b732:	2800      	cmp	r0, #0
 800b734:	d1d5      	bne.n	800b6e2 <CAD_StateMachine+0x8a>
          if ((STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum))) != VBUS_below_VSAFE0V_threshold)
 800b736:	0038      	movs	r0, r7
 800b738:	f7fb f978 	bl	8006a2c <STUSB1602_VBUS_VSAFE0V_Get>
 800b73c:	2801      	cmp	r0, #1
 800b73e:	d0d0      	beq.n	800b6e2 <CAD_StateMachine+0x8a>
            if ((STUSB1602_TypeC_FSM_State_Get(STUSB1602_I2C_Add(PortNum)) == AttachWait_SRC) && 
 800b740:	0038      	movs	r0, r7
 800b742:	f7fb f997 	bl	8006a74 <STUSB1602_TypeC_FSM_State_Get>
 800b746:	2809      	cmp	r0, #9
 800b748:	d1cb      	bne.n	800b6e2 <CAD_StateMachine+0x8a>
                (STUSB1602_VBUS_VSAFE0V_Get(STUSB1602_I2C_Add(PortNum)) != VBUS_below_VSAFE0V_threshold))
 800b74a:	0038      	movs	r0, r7
 800b74c:	f7fb f96e 	bl	8006a2c <STUSB1602_VBUS_VSAFE0V_Get>
            if ((STUSB1602_TypeC_FSM_State_Get(STUSB1602_I2C_Add(PortNum)) == AttachWait_SRC) && 
 800b750:	2801      	cmp	r0, #1
 800b752:	d0c6      	beq.n	800b6e2 <CAD_StateMachine+0x8a>
              HW_IF_RESET_CTRL(PortNum);
 800b754:	0020      	movs	r0, r4
 800b756:	f7ff fad9 	bl	800ad0c <HW_IF_RESET_CTRL>
 800b75a:	e7c2      	b.n	800b6e2 <CAD_StateMachine+0x8a>
    _handle->params->PE_PowerRole = USBPD_PORTPOWERROLE_SRC;
 800b75c:	0013      	movs	r3, r2
 800b75e:	4363      	muls	r3, r4
 800b760:	4a13      	ldr	r2, [pc, #76]	; (800b7b0 <CAD_StateMachine+0x158>)
 800b762:	18d3      	adds	r3, r2, r3
 800b764:	2204      	movs	r2, #4
 800b766:	6859      	ldr	r1, [r3, #4]
 800b768:	7808      	ldrb	r0, [r1, #0]
 800b76a:	4302      	orrs	r2, r0
    _handle->params->PE_PowerRole = USBPD_PORTPOWERROLE_SNK;
 800b76c:	700a      	strb	r2, [r1, #0]
    _handle->state = USBPD_CAD_STATE_ATTACHED;
 800b76e:	210f      	movs	r1, #15
 800b770:	7c1a      	ldrb	r2, [r3, #16]
 800b772:	438a      	bics	r2, r1
 800b774:	0011      	movs	r1, r2
 800b776:	2203      	movs	r2, #3
 800b778:	430a      	orrs	r2, r1
 800b77a:	741a      	strb	r2, [r3, #16]
    *Event = USBPD_CAD_EVENT_ATTACHED;
 800b77c:	2302      	movs	r3, #2
 800b77e:	702b      	strb	r3, [r5, #0]
    Ports[PortNum].NbDetach =0;
 800b780:	33df      	adds	r3, #223	; 0xdf
 800b782:	33ff      	adds	r3, #255	; 0xff
    Ports[PortNum].NbDetach =0;
 800b784:	2200      	movs	r2, #0
 800b786:	4363      	muls	r3, r4
 800b788:	18f3      	adds	r3, r6, r3
 800b78a:	33d3      	adds	r3, #211	; 0xd3
 800b78c:	33ff      	adds	r3, #255	; 0xff
 800b78e:	701a      	strb	r2, [r3, #0]
    break;
 800b790:	e7a9      	b.n	800b6e6 <CAD_StateMachine+0x8e>
    _handle->params->PE_PowerRole = USBPD_PORTPOWERROLE_SNK;
 800b792:	0013      	movs	r3, r2
 800b794:	2004      	movs	r0, #4
 800b796:	4363      	muls	r3, r4
 800b798:	4a05      	ldr	r2, [pc, #20]	; (800b7b0 <CAD_StateMachine+0x158>)
 800b79a:	18d3      	adds	r3, r2, r3
 800b79c:	6859      	ldr	r1, [r3, #4]
 800b79e:	780a      	ldrb	r2, [r1, #0]
 800b7a0:	4382      	bics	r2, r0
 800b7a2:	e7e3      	b.n	800b76c <CAD_StateMachine+0x114>
    *Event = USBPD_CAD_EVENT_NONE;
 800b7a4:	2300      	movs	r3, #0
 800b7a6:	702b      	strb	r3, [r5, #0]
 800b7a8:	e7be      	b.n	800b728 <CAD_StateMachine+0xd0>
 800b7aa:	46c0      	nop			; (mov r8, r8)
 800b7ac:	20000058 	.word	0x20000058
 800b7b0:	20001c68 	.word	0x20001c68
 800b7b4:	200003dc 	.word	0x200003dc

0800b7b8 <STUSB16xx_HW_IF_Send_Packet>:
  * @param  pData The pointer to data buffer
  * @param  Size The amount of data to be sent
  * @retval USBPD status
  */
USBPD_StatusTypeDef STUSB16xx_HW_IF_Send_Packet(uint8_t PortNum, uint8_t *pData, uint16_t Size)
{
 800b7b8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800b7ba:	0005      	movs	r5, r0
 800b7bc:	9100      	str	r1, [sp, #0]
 800b7be:	9201      	str	r2, [sp, #4]
  USBPD_StatusTypeDef ret = USBPD_ERROR;
  
  /* Check if the bus is idle */
  ret = HW_IF_check_bus_idle(PortNum);
 800b7c0:	f7ff fc28 	bl	800b014 <HW_IF_check_bus_idle>
 800b7c4:	1e06      	subs	r6, r0, #0
  if (ret == USBPD_OK && 1 /* tx ready */)
 800b7c6:	d11d      	bne.n	800b804 <STUSB16xx_HW_IF_Send_Packet+0x4c>
  {
    /* Set the state to busy*/
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_TX;
 800b7c8:	24f0      	movs	r4, #240	; 0xf0
 800b7ca:	2203      	movs	r2, #3
 800b7cc:	0064      	lsls	r4, r4, #1
 800b7ce:	436c      	muls	r4, r5
 800b7d0:	4f0d      	ldr	r7, [pc, #52]	; (800b808 <STUSB16xx_HW_IF_Send_Packet+0x50>)

    /* Set the SPI in TX mode */
    STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 800b7d2:	0001      	movs	r1, r0
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_TX;
 800b7d4:	193b      	adds	r3, r7, r4

    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800b7d6:	3440      	adds	r4, #64	; 0x40
    Ports[PortNum].State = HAL_USBPD_PORT_STATE_BUSY_TX;
 800b7d8:	765a      	strb	r2, [r3, #25]
    STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 800b7da:	0028      	movs	r0, r5
    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800b7dc:	19e4      	adds	r4, r4, r7
    STUSB16xx_HW_IF_Switch_Mode(PortNum, STUSB16xx_SPI_Mode_TX);
 800b7de:	f7ff fd93 	bl	800b308 <STUSB16xx_HW_IF_Switch_Mode>
    HAL_SPI_DMAStop(&Ports[PortNum].hspi);
 800b7e2:	0020      	movs	r0, r4
 800b7e4:	f7fd f8ac 	bl	8008940 <HAL_SPI_DMAStop>
    __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 800b7e8:	4b08      	ldr	r3, [pc, #32]	; (800b80c <STUSB16xx_HW_IF_Send_Packet+0x54>)
 800b7ea:	4a09      	ldr	r2, [pc, #36]	; (800b810 <STUSB16xx_HW_IF_Send_Packet+0x58>)

    /* Send TX Buffer by SPI DMA */
    HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, pData, Size);
 800b7ec:	9900      	ldr	r1, [sp, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, 0x0FFFFFFF);
 800b7ee:	605a      	str	r2, [r3, #4]
    HAL_SPI_Transmit_DMA(&Ports[PortNum].hspi, pData, Size);
 800b7f0:	0020      	movs	r0, r4
 800b7f2:	9a01      	ldr	r2, [sp, #4]
 800b7f4:	f7fc fe92 	bl	800851c <HAL_SPI_Transmit_DMA>

    /* Set TX_EN GPIO */
    STUSB16xx_HW_IF_TX_EN_Status(PortNum, GPIO_PIN_SET);
 800b7f8:	2101      	movs	r1, #1
 800b7fa:	0028      	movs	r0, r5
 800b7fc:	f7ff fd92 	bl	800b324 <STUSB16xx_HW_IF_TX_EN_Status>
  else
  {
    __NOP();
  }
  return ret;
}
 800b800:	0030      	movs	r0, r6
 800b802:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800b804:	46c0      	nop			; (mov r8, r8)
 800b806:	e7fb      	b.n	800b800 <STUSB16xx_HW_IF_Send_Packet+0x48>
 800b808:	20000058 	.word	0x20000058
 800b80c:	40020000 	.word	0x40020000
 800b810:	0fffffff 	.word	0x0fffffff

0800b814 <STUSB16xx_HW_IF_DataRoleSwap>:
USBPD_StatusTypeDef STUSB16xx_HW_IF_DataRoleSwap(uint8_t PortNum)
{
  uint32_t STUSB16xx_ACK_timeout = 0xFFFF;
  USBPD_StatusTypeDef ret = USBPD_ERROR;

  if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_DFP)
 800b814:	21f0      	movs	r1, #240	; 0xf0
 800b816:	0049      	lsls	r1, r1, #1
 800b818:	4341      	muls	r1, r0
 800b81a:	4a0c      	ldr	r2, [pc, #48]	; (800b84c <STUSB16xx_HW_IF_DataRoleSwap+0x38>)
{
 800b81c:	b510      	push	{r4, lr}
  if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_DFP)
 800b81e:	1852      	adds	r2, r2, r1
 800b820:	3229      	adds	r2, #41	; 0x29
 800b822:	7812      	ldrb	r2, [r2, #0]
{
 800b824:	0003      	movs	r3, r0
  if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_DFP)
 800b826:	2a01      	cmp	r2, #1
 800b828:	d107      	bne.n	800b83a <STUSB16xx_HW_IF_DataRoleSwap+0x26>
  {
    /* i2c_dr_swap_port_change_2_ufp_req command */
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Control_Set(STUSB1602_I2C_Add(PortNum), PD_DR_SWAP_PORT_CHANGE_2_UFP_REQ);    
 800b82a:	1e58      	subs	r0, r3, #1
 800b82c:	4183      	sbcs	r3, r0
 800b82e:	3328      	adds	r3, #40	; 0x28
 800b830:	0018      	movs	r0, r3
 800b832:	210a      	movs	r1, #10
//    }
  }
  else if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_UFP)
  {
    /* i2c_dr_swap_port_change_2_dfp_req command */
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Control_Set(STUSB1602_I2C_Add(PortNum), PD_DR_SWAP_PORT_CHANGE_2_DFP_REQ);    
 800b834:	f7fb f9d8 	bl	8006be8 <STUSB1602_Type_C_Control_Set>

  if (STUSB16xx_ACK_timeout == 0)
    ret = USBPD_ERROR;

  return ret;
}
 800b838:	bd10      	pop	{r4, pc}
    ret = USBPD_ERROR;
 800b83a:	2002      	movs	r0, #2
  else if (Ports[PortNum].DataRole == USBPD_PORTDATAROLE_UFP)
 800b83c:	2a00      	cmp	r2, #0
 800b83e:	d1fb      	bne.n	800b838 <STUSB16xx_HW_IF_DataRoleSwap+0x24>
    ret = (USBPD_StatusTypeDef)STUSB1602_Type_C_Control_Set(STUSB1602_I2C_Add(PortNum), PD_DR_SWAP_PORT_CHANGE_2_DFP_REQ);    
 800b840:	1e58      	subs	r0, r3, #1
 800b842:	4183      	sbcs	r3, r0
 800b844:	3328      	adds	r3, #40	; 0x28
 800b846:	0018      	movs	r0, r3
 800b848:	2109      	movs	r1, #9
 800b84a:	e7f3      	b.n	800b834 <STUSB16xx_HW_IF_DataRoleSwap+0x20>
 800b84c:	20000058 	.word	0x20000058

0800b850 <USBPD_16xx_IsResistor_SinkTxOk>:
  * @brief  Get Sink Resistors State
  * @param  PortNum The port index
  * @retval USBPD_FALSE of USBPD_TRUE
  */
uint8_t USBPD_16xx_IsResistor_SinkTxOk(uint8_t PortNum)
{
 800b850:	b570      	push	{r4, r5, r6, lr}
  uint8_t TX_OK;

  USBPD_StatusTypeDef ret = USBPD_ERROR;
  /* try to acquire the communication resource to avoid the conflict */
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800b852:	2164      	movs	r1, #100	; 0x64
{
 800b854:	0005      	movs	r5, r0
  ret = HW_IF_COMM_WAIT(PortNum, COMM_TO_DEFAULT);
 800b856:	f7ff f86d 	bl	800a934 <HW_IF_COMM_WAIT>
  if (ret != USBPD_OK)
  {
    return USBPD_FALSE;
 800b85a:	2300      	movs	r3, #0
  if (ret != USBPD_OK)
 800b85c:	4298      	cmp	r0, r3
 800b85e:	d10d      	bne.n	800b87c <USBPD_16xx_IsResistor_SinkTxOk+0x2c>
  }
  TX_OK = STUSB1602_Sink_Power_State_Get(STUSB1602_I2C_Add(PortNum));
 800b860:	0028      	movs	r0, r5
 800b862:	1e43      	subs	r3, r0, #1
 800b864:	4198      	sbcs	r0, r3
 800b866:	3028      	adds	r0, #40	; 0x28
 800b868:	f7fb f8f8 	bl	8006a5c <STUSB1602_Sink_Power_State_Get>
 800b86c:	0004      	movs	r4, r0
  HW_IF_COMM_RELEASE(PortNum);
 800b86e:	0028      	movs	r0, r5

  if ( TX_OK == Pwr_3_0_SNK)
 800b870:	3c02      	subs	r4, #2
  HW_IF_COMM_RELEASE(PortNum);
 800b872:	f7ff f87d 	bl	800a970 <HW_IF_COMM_RELEASE>
  if ( TX_OK == Pwr_3_0_SNK)
 800b876:	4263      	negs	r3, r4
 800b878:	4163      	adcs	r3, r4
    return USBPD_FALSE;
 800b87a:	b2db      	uxtb	r3, r3
  }
  else
  {
    return USBPD_FALSE;
  }
}
 800b87c:	0018      	movs	r0, r3
 800b87e:	bd70      	pop	{r4, r5, r6, pc}

0800b880 <USBPD_TIM_Init>:
/**
  * @brief  Initialization of TIMERSERVER, used for CRC and RETRY operations
  * @retval None
  */
void USBPD_TIM_Init(void)
{
 800b880:	b537      	push	{r0, r1, r2, r4, r5, lr}
  TIMx_CLK_ENABLE;
 800b882:	2001      	movs	r0, #1
 800b884:	4a26      	ldr	r2, [pc, #152]	; (800b920 <USBPD_TIM_Init+0xa0>)
  *         @arg @ref LL_TIM_COUNTERMODE_CENTER_UP_DOWN
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetCounterMode(TIM_TypeDef *TIMx, uint32_t CounterMode)
{
  MODIFY_REG(TIMx->CR1, TIM_CR1_DIR | TIM_CR1_CMS, CounterMode);
 800b886:	2480      	movs	r4, #128	; 0x80
 800b888:	69d1      	ldr	r1, [r2, #28]
 800b88a:	05e4      	lsls	r4, r4, #23
 800b88c:	4301      	orrs	r1, r0
 800b88e:	61d1      	str	r1, [r2, #28]
 800b890:	69d3      	ldr	r3, [r2, #28]
 800b892:	2270      	movs	r2, #112	; 0x70
 800b894:	4003      	ands	r3, r0
 800b896:	9301      	str	r3, [sp, #4]
 800b898:	9b01      	ldr	r3, [sp, #4]
 800b89a:	6823      	ldr	r3, [r4, #0]

  /* Counter mode: select up-counting mode */
  LL_TIM_SetCounterMode(TIMx, LL_TIM_COUNTERMODE_UP);

  /* Set the pre-scaler value to have TIMx counter clock equal to 1 MHz */
  LL_TIM_SetPrescaler(TIMx, __LL_TIM_CALC_PSC(SystemCoreClock, 1000000));
 800b89c:	2000      	movs	r0, #0
 800b89e:	4393      	bics	r3, r2
 800b8a0:	6023      	str	r3, [r4, #0]
 800b8a2:	4b20      	ldr	r3, [pc, #128]	; (800b924 <USBPD_TIM_Init+0xa4>)
 800b8a4:	681d      	ldr	r5, [r3, #0]
 800b8a6:	4b20      	ldr	r3, [pc, #128]	; (800b928 <USBPD_TIM_Init+0xa8>)
 800b8a8:	429d      	cmp	r5, r3
 800b8aa:	d904      	bls.n	800b8b6 <USBPD_TIM_Init+0x36>
 800b8ac:	491f      	ldr	r1, [pc, #124]	; (800b92c <USBPD_TIM_Init+0xac>)
 800b8ae:	0028      	movs	r0, r5
 800b8b0:	f7fa f88a 	bl	80059c8 <__udivsi3>
 800b8b4:	3801      	subs	r0, #1
  * @param  Prescaler between Min_Data=0 and Max_Data=65535
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetPrescaler(TIM_TypeDef *TIMx, uint32_t Prescaler)
{
  WRITE_REG(TIMx->PSC, Prescaler);
 800b8b6:	62a0      	str	r0, [r4, #40]	; 0x28
  * @param  TIMx Timer instance
  * @retval  Prescaler value between Min_Data=0 and Max_Data=65535
  */
__STATIC_INLINE uint32_t LL_TIM_GetPrescaler(TIM_TypeDef *TIMx)
{
  return (uint32_t)(READ_REG(TIMx->PSC));
 800b8b8:	6aa1      	ldr	r1, [r4, #40]	; 0x28

  /* Set the auto-reload value to have a counter frequency of 250Hz */
  LL_TIM_SetAutoReload(TIMx, __LL_TIM_CALC_ARR(SystemCoreClock, LL_TIM_GetPrescaler(TIMx), 250));
 800b8ba:	0028      	movs	r0, r5
 800b8bc:	3101      	adds	r1, #1
 800b8be:	f7fa f883 	bl	80059c8 <__udivsi3>
 800b8c2:	2200      	movs	r2, #0
 800b8c4:	28f9      	cmp	r0, #249	; 0xf9
 800b8c6:	d907      	bls.n	800b8d8 <USBPD_TIM_Init+0x58>
 800b8c8:	21fa      	movs	r1, #250	; 0xfa
 800b8ca:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800b8cc:	0028      	movs	r0, r5
 800b8ce:	3301      	adds	r3, #1
 800b8d0:	4359      	muls	r1, r3
 800b8d2:	f7fa f879 	bl	80059c8 <__udivsi3>
 800b8d6:	1e42      	subs	r2, r0, #1
  * @param  AutoReload between Min_Data=0 and Max_Data=65535
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetAutoReload(TIM_TypeDef *TIMx, uint32_t AutoReload)
{
  WRITE_REG(TIMx->ARR, AutoReload);
 800b8d8:	2380      	movs	r3, #128	; 0x80
 800b8da:	05db      	lsls	r3, r3, #23
 800b8dc:	62da      	str	r2, [r3, #44]	; 0x2c
  */
__STATIC_INLINE void LL_TIM_OC_SetMode(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Mode)
{
  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
 800b8de:	4c14      	ldr	r4, [pc, #80]	; (800b930 <USBPD_TIM_Init+0xb0>)
 800b8e0:	699a      	ldr	r2, [r3, #24]
 800b8e2:	4914      	ldr	r1, [pc, #80]	; (800b934 <USBPD_TIM_Init+0xb4>)
 800b8e4:	4022      	ands	r2, r4
 800b8e6:	430a      	orrs	r2, r1
  register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
 800b8e8:	4813      	ldr	r0, [pc, #76]	; (800b938 <USBPD_TIM_Init+0xb8>)
  MODIFY_REG(*pReg, ((TIM_CCMR1_OC1M  | TIM_CCMR1_CC1S) << SHIFT_TAB_OCxx[iChannel]),  Mode << SHIFT_TAB_OCxx[iChannel]);
 800b8ea:	619a      	str	r2, [r3, #24]
 800b8ec:	6842      	ldr	r2, [r0, #4]
 800b8ee:	4014      	ands	r4, r2
 800b8f0:	4321      	orrs	r1, r4
 800b8f2:	6041      	str	r1, [r0, #4]
  * @retval None
  */
__STATIC_INLINE void LL_TIM_OC_SetPolarity(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t Polarity)
{
  register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
  MODIFY_REG(TIMx->CCER, (TIM_CCER_CC1P << SHIFT_TAB_CCxP[iChannel]),  Polarity << SHIFT_TAB_CCxP[iChannel]);
 800b8f4:	2102      	movs	r1, #2
 800b8f6:	6a1a      	ldr	r2, [r3, #32]
 800b8f8:	438a      	bics	r2, r1
 800b8fa:	621a      	str	r2, [r3, #32]
 800b8fc:	6a1a      	ldr	r2, [r3, #32]
 800b8fe:	311e      	adds	r1, #30
 800b900:	438a      	bics	r2, r1
 800b902:	621a      	str	r2, [r3, #32]
 800b904:	6a1a      	ldr	r2, [r3, #32]
 800b906:	490d      	ldr	r1, [pc, #52]	; (800b93c <USBPD_TIM_Init+0xbc>)
 800b908:	400a      	ands	r2, r1
 800b90a:	621a      	str	r2, [r3, #32]
 800b90c:	6a1a      	ldr	r2, [r3, #32]
 800b90e:	490c      	ldr	r1, [pc, #48]	; (800b940 <USBPD_TIM_Init+0xc0>)
 800b910:	400a      	ands	r2, r1
 800b912:	621a      	str	r2, [r3, #32]
  SET_BIT(TIMx->CR1, TIM_CR1_CEN);
 800b914:	2201      	movs	r2, #1
 800b916:	6819      	ldr	r1, [r3, #0]
 800b918:	430a      	orrs	r2, r1
 800b91a:	601a      	str	r2, [r3, #0]
  LL_TIM_OC_SetPolarity(TIMx, LL_TIM_CHANNEL_CH3, LL_TIM_OCPOLARITY_HIGH);
  LL_TIM_OC_SetPolarity(TIMx, LL_TIM_CHANNEL_CH4, LL_TIM_OCPOLARITY_HIGH);

  /* Enable counter */
  LL_TIM_EnableCounter(TIMx);
}
 800b91c:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
 800b91e:	46c0      	nop			; (mov r8, r8)
 800b920:	40021000 	.word	0x40021000
 800b924:	20000030 	.word	0x20000030
 800b928:	000f423f 	.word	0x000f423f
 800b92c:	000f4240 	.word	0x000f4240
 800b930:	ffff8c8c 	.word	0xffff8c8c
 800b934:	00003030 	.word	0x00003030
 800b938:	40000018 	.word	0x40000018
 800b93c:	fffffdff 	.word	0xfffffdff
 800b940:	ffffdfff 	.word	0xffffdfff

0800b944 <USBPD_TIM_Start>:
  * @param  id Timer Operation Identifier
  * @param  us_time time in micro-seconds
  * @retval None
  */
void USBPD_TIM_Start(TIM_identifier id, uint16_t us_time)
{
 800b944:	b510      	push	{r4, lr}
  switch (id)
 800b946:	2803      	cmp	r0, #3
 800b948:	d80f      	bhi.n	800b96a <USBPD_TIM_Start+0x26>
 800b94a:	2480      	movs	r4, #128	; 0x80
 800b94c:	05e4      	lsls	r4, r4, #23
 800b94e:	f7fa f831 	bl	80059b4 <__gnu_thumb1_case_uqi>
 800b952:	0d02      	.short	0x0d02
 800b954:	1f16      	.short	0x1f16
  {
    case TIM_PORT0_CRC:
      LL_TIM_OC_SetCompareCH1(TIMx, (us_time + TIMx->CNT) % 4000);
 800b956:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b958:	1808      	adds	r0, r1, r0
 800b95a:	21fa      	movs	r1, #250	; 0xfa
 800b95c:	0109      	lsls	r1, r1, #4
 800b95e:	f7fa f8b9 	bl	8005ad4 <__aeabi_uidivmod>
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_ClearFlag_CC1(TIM_TypeDef *TIMx)
{
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC1IF));
 800b962:	2303      	movs	r3, #3
  WRITE_REG(TIMx->CCR1, CompareValue);
 800b964:	6361      	str	r1, [r4, #52]	; 0x34
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_ClearFlag_CC4(TIM_TypeDef *TIMx)
{
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
 800b966:	425b      	negs	r3, r3
 800b968:	6123      	str	r3, [r4, #16]
      LL_TIM_ClearFlag_CC4(TIMx);
      break;
    default:
      break;
  }
}
 800b96a:	bd10      	pop	{r4, pc}
      LL_TIM_OC_SetCompareCH2(TIMx, (us_time + TIMx->CNT) % 4000);
 800b96c:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b96e:	1808      	adds	r0, r1, r0
 800b970:	21fa      	movs	r1, #250	; 0xfa
 800b972:	0109      	lsls	r1, r1, #4
 800b974:	f7fa f8ae 	bl	8005ad4 <__aeabi_uidivmod>
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC2IF));
 800b978:	2305      	movs	r3, #5
  WRITE_REG(TIMx->CCR2, CompareValue);
 800b97a:	63a1      	str	r1, [r4, #56]	; 0x38
 800b97c:	e7f3      	b.n	800b966 <USBPD_TIM_Start+0x22>
      LL_TIM_OC_SetCompareCH3(TIMx, (us_time + TIMx->CNT) % 4000);
 800b97e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b980:	1808      	adds	r0, r1, r0
 800b982:	21fa      	movs	r1, #250	; 0xfa
 800b984:	0109      	lsls	r1, r1, #4
 800b986:	f7fa f8a5 	bl	8005ad4 <__aeabi_uidivmod>
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC3IF));
 800b98a:	2309      	movs	r3, #9
  WRITE_REG(TIMx->CCR3, CompareValue);
 800b98c:	63e1      	str	r1, [r4, #60]	; 0x3c
 800b98e:	e7ea      	b.n	800b966 <USBPD_TIM_Start+0x22>
      LL_TIM_OC_SetCompareCH4(TIMx, (us_time + TIMx->CNT) % 4000);
 800b990:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b992:	1808      	adds	r0, r1, r0
 800b994:	21fa      	movs	r1, #250	; 0xfa
 800b996:	0109      	lsls	r1, r1, #4
 800b998:	f7fa f89c 	bl	8005ad4 <__aeabi_uidivmod>
  WRITE_REG(TIMx->SR, ~(TIM_SR_CC4IF));
 800b99c:	2311      	movs	r3, #17
  WRITE_REG(TIMx->CCR4, CompareValue);
 800b99e:	6421      	str	r1, [r4, #64]	; 0x40
 800b9a0:	e7e1      	b.n	800b966 <USBPD_TIM_Start+0x22>

0800b9a2 <USBPD_TIM_IsExpired>:
  * @brief  Retrieve the TIMERSERVER status for a specified id
  * @param  id Timer Operation Identifier
  * @retval State of bit (1 or 0).
  */
uint8_t USBPD_TIM_IsExpired(TIM_identifier id)
{
 800b9a2:	b500      	push	{lr}
    case TIM_PORT1_RETRY:
      return LL_TIM_IsActiveFlag_CC4(TIMx);
    default:
      break;
  }
  return 1;
 800b9a4:	2301      	movs	r3, #1
  switch (id)
 800b9a6:	2803      	cmp	r0, #3
 800b9a8:	d808      	bhi.n	800b9bc <USBPD_TIM_IsExpired+0x1a>
 800b9aa:	2280      	movs	r2, #128	; 0x80
 800b9ac:	05d2      	lsls	r2, r2, #23
  * @param  TIMx Timer instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_TIM_IsActiveFlag_CC4(TIM_TypeDef *TIMx)
{
  return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
 800b9ae:	6912      	ldr	r2, [r2, #16]
 800b9b0:	f7fa f800 	bl	80059b4 <__gnu_thumb1_case_uqi>
 800b9b4:	0a080602 	.word	0x0a080602
  return (READ_BIT(TIMx->SR, TIM_SR_CC1IF) == (TIM_SR_CC1IF));
 800b9b8:	0852      	lsrs	r2, r2, #1
      return LL_TIM_IsActiveFlag_CC4(TIMx);
 800b9ba:	4013      	ands	r3, r2
}
 800b9bc:	0018      	movs	r0, r3
 800b9be:	bd00      	pop	{pc}
  return (READ_BIT(TIMx->SR, TIM_SR_CC2IF) == (TIM_SR_CC2IF));
 800b9c0:	0892      	lsrs	r2, r2, #2
 800b9c2:	e7fa      	b.n	800b9ba <USBPD_TIM_IsExpired+0x18>
  return (READ_BIT(TIMx->SR, TIM_SR_CC3IF) == (TIM_SR_CC3IF));
 800b9c4:	08d2      	lsrs	r2, r2, #3
 800b9c6:	e7f8      	b.n	800b9ba <USBPD_TIM_IsExpired+0x18>
  return (READ_BIT(TIMx->SR, TIM_SR_CC4IF) == (TIM_SR_CC4IF));
 800b9c8:	0912      	lsrs	r2, r2, #4
 800b9ca:	e7f6      	b.n	800b9ba <USBPD_TIM_IsExpired+0x18>

0800b9cc <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 800b9cc:	b510      	push	{r4, lr}
  vTaskStartScheduler();
 800b9ce:	f000 fc67 	bl	800c2a0 <vTaskStartScheduler>
  
  return osOK;
}
 800b9d2:	2000      	movs	r0, #0
 800b9d4:	bd10      	pop	{r4, pc}

0800b9d6 <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 800b9d6:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b9d8:	6902      	ldr	r2, [r0, #16]
{
 800b9da:	000b      	movs	r3, r1
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b9dc:	6846      	ldr	r6, [r0, #4]
 800b9de:	6801      	ldr	r1, [r0, #0]
 800b9e0:	2508      	movs	r5, #8
 800b9e2:	5f45      	ldrsh	r5, [r0, r5]
 800b9e4:	b292      	uxth	r2, r2
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 800b9e6:	2400      	movs	r4, #0
  if (priority != osPriorityError) {
 800b9e8:	2d84      	cmp	r5, #132	; 0x84
 800b9ea:	d000      	beq.n	800b9ee <osThreadCreate+0x18>
    fpriority += (priority - osPriorityIdle);
 800b9ec:	1cec      	adds	r4, r5, #3
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b9ee:	a803      	add	r0, sp, #12
 800b9f0:	9001      	str	r0, [sp, #4]
 800b9f2:	9400      	str	r4, [sp, #0]
 800b9f4:	0030      	movs	r0, r6
 800b9f6:	f000 fb63 	bl	800c0c0 <xTaskCreate>
                   thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
                   &handle) != pdPASS)  {
    return NULL;
 800b9fa:	2300      	movs	r3, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800b9fc:	2801      	cmp	r0, #1
 800b9fe:	d100      	bne.n	800ba02 <osThreadCreate+0x2c>
  }     
#endif
  
  return handle;
 800ba00:	9b03      	ldr	r3, [sp, #12]
}
 800ba02:	0018      	movs	r0, r3
 800ba04:	b004      	add	sp, #16
 800ba06:	bd70      	pop	{r4, r5, r6, pc}

0800ba08 <osThreadTerminate>:
* @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osThreadTerminate shall be consistent in every CMSIS-RTOS.
*/
osStatus osThreadTerminate (osThreadId thread_id)
{
 800ba08:	b510      	push	{r4, lr}
#if (INCLUDE_vTaskDelete == 1)
  vTaskDelete(thread_id);
 800ba0a:	f000 fc07 	bl	800c21c <vTaskDelete>
  return osOK;
#else
  return osErrorOS;
#endif
}
 800ba0e:	2000      	movs	r0, #0
 800ba10:	bd10      	pop	{r4, pc}

0800ba12 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 800ba12:	b510      	push	{r4, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 800ba14:	2800      	cmp	r0, #0
 800ba16:	d100      	bne.n	800ba1a <osDelay+0x8>
 800ba18:	3001      	adds	r0, #1
 800ba1a:	f000 fd31 	bl	800c480 <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 800ba1e:	2000      	movs	r0, #0
 800ba20:	bd10      	pop	{r4, pc}

0800ba22 <osMessageCreate>:
* @param  thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval  message queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS.
*/
osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
{
 800ba22:	b510      	push	{r4, lr}
    return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
  }
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
#else  
  return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
 800ba24:	6841      	ldr	r1, [r0, #4]
 800ba26:	2200      	movs	r2, #0
 800ba28:	6800      	ldr	r0, [r0, #0]
 800ba2a:	f000 f94f 	bl	800bccc <xQueueGenericCreate>
#endif
}
 800ba2e:	bd10      	pop	{r4, pc}

0800ba30 <osMessagePut>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
*/
osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
 800ba30:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  portBASE_TYPE taskWoken = pdFALSE;
 800ba32:	2300      	movs	r3, #0
{
 800ba34:	9101      	str	r1, [sp, #4]
  portBASE_TYPE taskWoken = pdFALSE;
 800ba36:	9303      	str	r3, [sp, #12]
  TickType_t ticks;
  
  ticks = millisec / portTICK_PERIOD_MS;
  if (ticks == 0) {
 800ba38:	429a      	cmp	r2, r3
 800ba3a:	d100      	bne.n	800ba3e <osMessagePut+0xe>
    ticks = 1;
 800ba3c:	2201      	movs	r2, #1
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800ba3e:	f3ef 8305 	mrs	r3, IPSR
  }
  
  if (inHandlerMode()) {
 800ba42:	2b00      	cmp	r3, #0
 800ba44:	d012      	beq.n	800ba6c <osMessagePut+0x3c>
    if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
 800ba46:	2300      	movs	r3, #0
 800ba48:	aa03      	add	r2, sp, #12
 800ba4a:	a901      	add	r1, sp, #4
 800ba4c:	f000 f9e3 	bl	800be16 <xQueueGenericSendFromISR>
 800ba50:	2801      	cmp	r0, #1
 800ba52:	d002      	beq.n	800ba5a <osMessagePut+0x2a>
      return osErrorOS;
 800ba54:	20ff      	movs	r0, #255	; 0xff
      return osErrorOS;
    }
  }
  
  return osOK;
}
 800ba56:	b005      	add	sp, #20
 800ba58:	bd00      	pop	{pc}
    portEND_SWITCHING_ISR(taskWoken);
 800ba5a:	9b03      	ldr	r3, [sp, #12]
 800ba5c:	2b00      	cmp	r3, #0
 800ba5e:	d003      	beq.n	800ba68 <osMessagePut+0x38>
 800ba60:	2280      	movs	r2, #128	; 0x80
 800ba62:	4b05      	ldr	r3, [pc, #20]	; (800ba78 <osMessagePut+0x48>)
 800ba64:	0552      	lsls	r2, r2, #21
 800ba66:	601a      	str	r2, [r3, #0]
  return osOK;
 800ba68:	2000      	movs	r0, #0
 800ba6a:	e7f4      	b.n	800ba56 <osMessagePut+0x26>
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
 800ba6c:	a901      	add	r1, sp, #4
 800ba6e:	f000 f94a 	bl	800bd06 <xQueueGenericSend>
 800ba72:	2801      	cmp	r0, #1
 800ba74:	d0f8      	beq.n	800ba68 <osMessagePut+0x38>
 800ba76:	e7ed      	b.n	800ba54 <osMessagePut+0x24>
 800ba78:	e000ed04 	.word	0xe000ed04

0800ba7c <osMessageGet>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval event information that includes status code.
* @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
*/
osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
{
 800ba7c:	b5f0      	push	{r4, r5, r6, r7, lr}
  portBASE_TYPE taskWoken;
  TickType_t ticks;
  osEvent event;
  
  event.def.message_id = queue_id;
  event.value.v = 0;
 800ba7e:	2700      	movs	r7, #0
{
 800ba80:	b085      	sub	sp, #20
  event.def.message_id = queue_id;
 800ba82:	ac01      	add	r4, sp, #4
{
 800ba84:	0005      	movs	r5, r0
 800ba86:	0016      	movs	r6, r2
 800ba88:	0008      	movs	r0, r1
  event.def.message_id = queue_id;
 800ba8a:	60a1      	str	r1, [r4, #8]
  event.value.v = 0;
 800ba8c:	6067      	str	r7, [r4, #4]
  
  if (queue_id == NULL) {
 800ba8e:	42b9      	cmp	r1, r7
 800ba90:	d107      	bne.n	800baa2 <osMessageGet+0x26>
    event.status = osErrorParameter;
 800ba92:	2380      	movs	r3, #128	; 0x80
 800ba94:	9301      	str	r3, [sp, #4]
    else {
      event.status = (ticks == 0) ? osOK : osEventTimeout;
    }
  }
  
  return event;
 800ba96:	002b      	movs	r3, r5
 800ba98:	cc07      	ldmia	r4!, {r0, r1, r2}
 800ba9a:	c307      	stmia	r3!, {r0, r1, r2}
}
 800ba9c:	0028      	movs	r0, r5
 800ba9e:	b005      	add	sp, #20
 800baa0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  taskWoken = pdFALSE;
 800baa2:	9700      	str	r7, [sp, #0]
 800baa4:	f3ef 8305 	mrs	r3, IPSR
  if (inHandlerMode()) {
 800baa8:	2b00      	cmp	r3, #0
 800baaa:	d011      	beq.n	800bad0 <osMessageGet+0x54>
    if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
 800baac:	466a      	mov	r2, sp
 800baae:	a902      	add	r1, sp, #8
 800bab0:	f000 fa8a 	bl	800bfc8 <xQueueReceiveFromISR>
 800bab4:	2801      	cmp	r0, #1
 800bab6:	d109      	bne.n	800bacc <osMessageGet+0x50>
      event.status = osEventMessage;
 800bab8:	2310      	movs	r3, #16
 800baba:	6023      	str	r3, [r4, #0]
    portEND_SWITCHING_ISR(taskWoken);
 800babc:	9b00      	ldr	r3, [sp, #0]
 800babe:	2b00      	cmp	r3, #0
 800bac0:	d0e9      	beq.n	800ba96 <osMessageGet+0x1a>
 800bac2:	2280      	movs	r2, #128	; 0x80
 800bac4:	4b09      	ldr	r3, [pc, #36]	; (800baec <osMessageGet+0x70>)
 800bac6:	0552      	lsls	r2, r2, #21
 800bac8:	601a      	str	r2, [r3, #0]
 800baca:	e7e4      	b.n	800ba96 <osMessageGet+0x1a>
      event.status = osOK;
 800bacc:	6027      	str	r7, [r4, #0]
 800bace:	e7f5      	b.n	800babc <osMessageGet+0x40>
    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
 800bad0:	a902      	add	r1, sp, #8
 800bad2:	f000 f9e9 	bl	800bea8 <xQueueGenericReceive>
 800bad6:	2801      	cmp	r0, #1
 800bad8:	d102      	bne.n	800bae0 <osMessageGet+0x64>
      event.status = osEventMessage;
 800bada:	2310      	movs	r3, #16
 800badc:	6023      	str	r3, [r4, #0]
 800bade:	e7da      	b.n	800ba96 <osMessageGet+0x1a>
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 800bae0:	1e73      	subs	r3, r6, #1
 800bae2:	419e      	sbcs	r6, r3
 800bae4:	01b6      	lsls	r6, r6, #6
 800bae6:	9601      	str	r6, [sp, #4]
 800bae8:	e7d5      	b.n	800ba96 <osMessageGet+0x1a>
 800baea:	46c0      	nop			; (mov r8, r8)
 800baec:	e000ed04 	.word	0xe000ed04

0800baf0 <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 800baf0:	b510      	push	{r4, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
  {
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
 800baf2:	f000 ff0f 	bl	800c914 <xPortSysTickHandler>
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 800baf6:	bd10      	pop	{r4, pc}

0800baf8 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800baf8:	0003      	movs	r3, r0

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800bafa:	2201      	movs	r2, #1
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800bafc:	3308      	adds	r3, #8
 800bafe:	6043      	str	r3, [r0, #4]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800bb00:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800bb02:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800bb04:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800bb06:	4252      	negs	r2, r2
 800bb08:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800bb0a:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800bb0c:	4770      	bx	lr

0800bb0e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 800bb0e:	2300      	movs	r3, #0
 800bb10:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 800bb12:	4770      	bx	lr

0800bb14 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 800bb14:	6843      	ldr	r3, [r0, #4]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800bb16:	689a      	ldr	r2, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
 800bb18:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800bb1a:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800bb1c:	689a      	ldr	r2, [r3, #8]
 800bb1e:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800bb20:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800bb22:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800bb24:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800bb26:	3301      	adds	r3, #1
 800bb28:	6003      	str	r3, [r0, #0]
}
 800bb2a:	4770      	bx	lr

0800bb2c <vListInsert>:
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800bb2c:	0003      	movs	r3, r0
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800bb2e:	680a      	ldr	r2, [r1, #0]
{
 800bb30:	b530      	push	{r4, r5, lr}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800bb32:	3308      	adds	r3, #8
	if( xValueOfInsertion == portMAX_DELAY )
 800bb34:	1c54      	adds	r4, r2, #1
 800bb36:	d10b      	bne.n	800bb50 <vListInsert+0x24>
		pxIterator = pxList->xListEnd.pxPrevious;
 800bb38:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800bb3a:	685a      	ldr	r2, [r3, #4]
 800bb3c:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 800bb3e:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 800bb40:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 800bb42:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 800bb44:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800bb46:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800bb48:	3301      	adds	r3, #1
 800bb4a:	6003      	str	r3, [r0, #0]
}
 800bb4c:	bd30      	pop	{r4, r5, pc}
 800bb4e:	0023      	movs	r3, r4
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800bb50:	685c      	ldr	r4, [r3, #4]
 800bb52:	6825      	ldr	r5, [r4, #0]
 800bb54:	4295      	cmp	r5, r2
 800bb56:	d9fa      	bls.n	800bb4e <vListInsert+0x22>
 800bb58:	e7ef      	b.n	800bb3a <vListInsert+0xe>

0800bb5a <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800bb5a:	6841      	ldr	r1, [r0, #4]
 800bb5c:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 800bb5e:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800bb60:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800bb62:	6882      	ldr	r2, [r0, #8]
 800bb64:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800bb66:	6859      	ldr	r1, [r3, #4]
 800bb68:	4281      	cmp	r1, r0
 800bb6a:	d100      	bne.n	800bb6e <uxListRemove+0x14>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800bb6c:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 800bb6e:	2200      	movs	r2, #0
 800bb70:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 800bb72:	681a      	ldr	r2, [r3, #0]
 800bb74:	1e50      	subs	r0, r2, #1
 800bb76:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 800bb78:	4770      	bx	lr

0800bb7a <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 800bb7a:	b570      	push	{r4, r5, r6, lr}
 800bb7c:	0016      	movs	r6, r2

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800bb7e:	6c02      	ldr	r2, [r0, #64]	; 0x40
{
 800bb80:	0004      	movs	r4, r0
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800bb82:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800bb84:	2a00      	cmp	r2, #0
 800bb86:	d00d      	beq.n	800bba4 <prvCopyDataToQueue+0x2a>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 800bb88:	2e00      	cmp	r6, #0
 800bb8a:	d10f      	bne.n	800bbac <prvCopyDataToQueue+0x32>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 800bb8c:	6880      	ldr	r0, [r0, #8]
 800bb8e:	f001 f805 	bl	800cb9c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800bb92:	68a3      	ldr	r3, [r4, #8]
 800bb94:	6c22      	ldr	r2, [r4, #64]	; 0x40
 800bb96:	189b      	adds	r3, r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800bb98:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 800bb9a:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800bb9c:	4293      	cmp	r3, r2
 800bb9e:	d301      	bcc.n	800bba4 <prvCopyDataToQueue+0x2a>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800bba0:	6823      	ldr	r3, [r4, #0]
 800bba2:	60a3      	str	r3, [r4, #8]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 800bba4:	3501      	adds	r5, #1
 800bba6:	63a5      	str	r5, [r4, #56]	; 0x38

	return xReturn;
}
 800bba8:	2000      	movs	r0, #0
 800bbaa:	bd70      	pop	{r4, r5, r6, pc}
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bbac:	68c0      	ldr	r0, [r0, #12]
 800bbae:	f000 fff5 	bl	800cb9c <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800bbb2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800bbb4:	68e2      	ldr	r2, [r4, #12]
 800bbb6:	425b      	negs	r3, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800bbb8:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 800bbba:	18d2      	adds	r2, r2, r3
 800bbbc:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800bbbe:	428a      	cmp	r2, r1
 800bbc0:	d202      	bcs.n	800bbc8 <prvCopyDataToQueue+0x4e>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 800bbc2:	6862      	ldr	r2, [r4, #4]
 800bbc4:	18d3      	adds	r3, r2, r3
 800bbc6:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 800bbc8:	2e02      	cmp	r6, #2
 800bbca:	d1eb      	bne.n	800bba4 <prvCopyDataToQueue+0x2a>
				--uxMessagesWaiting;
 800bbcc:	002b      	movs	r3, r5
 800bbce:	1e5a      	subs	r2, r3, #1
 800bbd0:	4193      	sbcs	r3, r2
 800bbd2:	1aed      	subs	r5, r5, r3
 800bbd4:	e7e6      	b.n	800bba4 <prvCopyDataToQueue+0x2a>

0800bbd6 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 800bbd6:	0003      	movs	r3, r0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800bbd8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
 800bbda:	b510      	push	{r4, lr}
 800bbdc:	0008      	movs	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800bbde:	2a00      	cmp	r2, #0
 800bbe0:	d00a      	beq.n	800bbf8 <prvCopyDataFromQueue+0x22>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800bbe2:	68d9      	ldr	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800bbe4:	685c      	ldr	r4, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800bbe6:	1889      	adds	r1, r1, r2
 800bbe8:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800bbea:	42a1      	cmp	r1, r4
 800bbec:	d301      	bcc.n	800bbf2 <prvCopyDataFromQueue+0x1c>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 800bbee:	6819      	ldr	r1, [r3, #0]
 800bbf0:	60d9      	str	r1, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 800bbf2:	68d9      	ldr	r1, [r3, #12]
 800bbf4:	f000 ffd2 	bl	800cb9c <memcpy>
	}
}
 800bbf8:	bd10      	pop	{r4, pc}

0800bbfa <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 800bbfa:	b570      	push	{r4, r5, r6, lr}
 800bbfc:	0005      	movs	r5, r0
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;
 800bbfe:	002e      	movs	r6, r5
 800bc00:	3645      	adds	r6, #69	; 0x45
	taskENTER_CRITICAL();
 800bc02:	f000 fe3d 	bl	800c880 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 800bc06:	7834      	ldrb	r4, [r6, #0]
 800bc08:	b264      	sxtb	r4, r4

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800bc0a:	2c00      	cmp	r4, #0
 800bc0c:	dc10      	bgt.n	800bc30 <prvUnlockQueue+0x36>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 800bc0e:	23ff      	movs	r3, #255	; 0xff
 800bc10:	7033      	strb	r3, [r6, #0]
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;
 800bc12:	002e      	movs	r6, r5
 800bc14:	3644      	adds	r6, #68	; 0x44
	taskEXIT_CRITICAL();
 800bc16:	f000 fe3f 	bl	800c898 <vPortExitCritical>
	taskENTER_CRITICAL();
 800bc1a:	f000 fe31 	bl	800c880 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 800bc1e:	7834      	ldrb	r4, [r6, #0]
 800bc20:	b264      	sxtb	r4, r4

		while( cRxLock > queueLOCKED_UNMODIFIED )
 800bc22:	2c00      	cmp	r4, #0
 800bc24:	dc11      	bgt.n	800bc4a <prvUnlockQueue+0x50>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 800bc26:	23ff      	movs	r3, #255	; 0xff
 800bc28:	7033      	strb	r3, [r6, #0]
	}
	taskEXIT_CRITICAL();
 800bc2a:	f000 fe35 	bl	800c898 <vPortExitCritical>
}
 800bc2e:	bd70      	pop	{r4, r5, r6, pc}
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800bc30:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800bc32:	2b00      	cmp	r3, #0
 800bc34:	d0eb      	beq.n	800bc0e <prvUnlockQueue+0x14>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800bc36:	0028      	movs	r0, r5
 800bc38:	3024      	adds	r0, #36	; 0x24
 800bc3a:	f000 fcad 	bl	800c598 <xTaskRemoveFromEventList>
 800bc3e:	2800      	cmp	r0, #0
 800bc40:	d001      	beq.n	800bc46 <prvUnlockQueue+0x4c>
						vTaskMissedYield();
 800bc42:	f000 fd1d 	bl	800c680 <vTaskMissedYield>
 800bc46:	3c01      	subs	r4, #1
 800bc48:	e7de      	b.n	800bc08 <prvUnlockQueue+0xe>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800bc4a:	692b      	ldr	r3, [r5, #16]
 800bc4c:	2b00      	cmp	r3, #0
 800bc4e:	d0ea      	beq.n	800bc26 <prvUnlockQueue+0x2c>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800bc50:	0028      	movs	r0, r5
 800bc52:	3010      	adds	r0, #16
 800bc54:	f000 fca0 	bl	800c598 <xTaskRemoveFromEventList>
 800bc58:	2800      	cmp	r0, #0
 800bc5a:	d001      	beq.n	800bc60 <prvUnlockQueue+0x66>
					vTaskMissedYield();
 800bc5c:	f000 fd10 	bl	800c680 <vTaskMissedYield>
 800bc60:	3c01      	subs	r4, #1
 800bc62:	e7dd      	b.n	800bc20 <prvUnlockQueue+0x26>

0800bc64 <xQueueGenericReset>:
{
 800bc64:	b570      	push	{r4, r5, r6, lr}
 800bc66:	0004      	movs	r4, r0
 800bc68:	000d      	movs	r5, r1
	configASSERT( pxQueue );
 800bc6a:	2800      	cmp	r0, #0
 800bc6c:	d101      	bne.n	800bc72 <xQueueGenericReset+0xe>
 800bc6e:	b672      	cpsid	i
 800bc70:	e7fe      	b.n	800bc70 <xQueueGenericReset+0xc>
	taskENTER_CRITICAL();
 800bc72:	f000 fe05 	bl	800c880 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800bc76:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800bc78:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800bc7a:	6822      	ldr	r2, [r4, #0]
 800bc7c:	434b      	muls	r3, r1
 800bc7e:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 800bc80:	1a5b      	subs	r3, r3, r1
 800bc82:	18d3      	adds	r3, r2, r3
 800bc84:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 800bc86:	0023      	movs	r3, r4
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 800bc88:	6060      	str	r0, [r4, #4]
		pxQueue->pcWriteTo = pxQueue->pcHead;
 800bc8a:	60a2      	str	r2, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800bc8c:	2000      	movs	r0, #0
		pxQueue->cRxLock = queueUNLOCKED;
 800bc8e:	22ff      	movs	r2, #255	; 0xff
 800bc90:	3344      	adds	r3, #68	; 0x44
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800bc92:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
 800bc94:	701a      	strb	r2, [r3, #0]
		pxQueue->cTxLock = queueUNLOCKED;
 800bc96:	705a      	strb	r2, [r3, #1]
		if( xNewQueue == pdFALSE )
 800bc98:	4285      	cmp	r5, r0
 800bc9a:	d10e      	bne.n	800bcba <xQueueGenericReset+0x56>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800bc9c:	6923      	ldr	r3, [r4, #16]
 800bc9e:	4283      	cmp	r3, r0
 800bca0:	d007      	beq.n	800bcb2 <xQueueGenericReset+0x4e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800bca2:	0020      	movs	r0, r4
 800bca4:	3010      	adds	r0, #16
 800bca6:	f000 fc77 	bl	800c598 <xTaskRemoveFromEventList>
 800bcaa:	2800      	cmp	r0, #0
 800bcac:	d001      	beq.n	800bcb2 <xQueueGenericReset+0x4e>
					queueYIELD_IF_USING_PREEMPTION();
 800bcae:	f000 fddb 	bl	800c868 <vPortYield>
	taskEXIT_CRITICAL();
 800bcb2:	f000 fdf1 	bl	800c898 <vPortExitCritical>
}
 800bcb6:	2001      	movs	r0, #1
 800bcb8:	bd70      	pop	{r4, r5, r6, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800bcba:	0020      	movs	r0, r4
 800bcbc:	3010      	adds	r0, #16
 800bcbe:	f7ff ff1b 	bl	800baf8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 800bcc2:	0020      	movs	r0, r4
 800bcc4:	3024      	adds	r0, #36	; 0x24
 800bcc6:	f7ff ff17 	bl	800baf8 <vListInitialise>
 800bcca:	e7f2      	b.n	800bcb2 <xQueueGenericReset+0x4e>

0800bccc <xQueueGenericCreate>:
	{
 800bccc:	b570      	push	{r4, r5, r6, lr}
 800bcce:	0006      	movs	r6, r0
 800bcd0:	000d      	movs	r5, r1
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 800bcd2:	2800      	cmp	r0, #0
 800bcd4:	d101      	bne.n	800bcda <xQueueGenericCreate+0xe>
 800bcd6:	b672      	cpsid	i
 800bcd8:	e7fe      	b.n	800bcd8 <xQueueGenericCreate+0xc>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bcda:	0008      	movs	r0, r1
 800bcdc:	4370      	muls	r0, r6
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 800bcde:	3048      	adds	r0, #72	; 0x48
 800bce0:	f000 fcf6 	bl	800c6d0 <pvPortMalloc>
 800bce4:	1e04      	subs	r4, r0, #0
		if( pxNewQueue != NULL )
 800bce6:	d008      	beq.n	800bcfa <xQueueGenericCreate+0x2e>
	if( uxItemSize == ( UBaseType_t ) 0 )
 800bce8:	2d00      	cmp	r5, #0
 800bcea:	d108      	bne.n	800bcfe <xQueueGenericCreate+0x32>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800bcec:	6020      	str	r0, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 800bcee:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 800bcf0:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800bcf2:	2101      	movs	r1, #1
 800bcf4:	0020      	movs	r0, r4
 800bcf6:	f7ff ffb5 	bl	800bc64 <xQueueGenericReset>
	}
 800bcfa:	0020      	movs	r0, r4
 800bcfc:	bd70      	pop	{r4, r5, r6, pc}
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 800bcfe:	0003      	movs	r3, r0
 800bd00:	3348      	adds	r3, #72	; 0x48
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 800bd02:	6003      	str	r3, [r0, #0]
 800bd04:	e7f3      	b.n	800bcee <xQueueGenericCreate+0x22>

0800bd06 <xQueueGenericSend>:
{
 800bd06:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bd08:	b085      	sub	sp, #20
 800bd0a:	0004      	movs	r4, r0
 800bd0c:	000f      	movs	r7, r1
 800bd0e:	9201      	str	r2, [sp, #4]
 800bd10:	001e      	movs	r6, r3
	configASSERT( pxQueue );
 800bd12:	2800      	cmp	r0, #0
 800bd14:	d101      	bne.n	800bd1a <xQueueGenericSend+0x14>
 800bd16:	b672      	cpsid	i
 800bd18:	e7fe      	b.n	800bd18 <xQueueGenericSend+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800bd1a:	2900      	cmp	r1, #0
 800bd1c:	d104      	bne.n	800bd28 <xQueueGenericSend+0x22>
 800bd1e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800bd20:	2b00      	cmp	r3, #0
 800bd22:	d001      	beq.n	800bd28 <xQueueGenericSend+0x22>
 800bd24:	b672      	cpsid	i
 800bd26:	e7fe      	b.n	800bd26 <xQueueGenericSend+0x20>
 800bd28:	2300      	movs	r3, #0
 800bd2a:	9300      	str	r3, [sp, #0]
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800bd2c:	2e02      	cmp	r6, #2
 800bd2e:	d14f      	bne.n	800bdd0 <xQueueGenericSend+0xca>
 800bd30:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800bd32:	2b01      	cmp	r3, #1
 800bd34:	d04c      	beq.n	800bdd0 <xQueueGenericSend+0xca>
 800bd36:	b672      	cpsid	i
 800bd38:	e7fe      	b.n	800bd38 <xQueueGenericSend+0x32>
				if( xTicksToWait == ( TickType_t ) 0 )
 800bd3a:	9d01      	ldr	r5, [sp, #4]
 800bd3c:	2d00      	cmp	r5, #0
 800bd3e:	d103      	bne.n	800bd48 <xQueueGenericSend+0x42>
					taskEXIT_CRITICAL();
 800bd40:	f000 fdaa 	bl	800c898 <vPortExitCritical>
			return errQUEUE_FULL;
 800bd44:	2000      	movs	r0, #0
 800bd46:	e05e      	b.n	800be06 <xQueueGenericSend+0x100>
				else if( xEntryTimeSet == pdFALSE )
 800bd48:	9b00      	ldr	r3, [sp, #0]
 800bd4a:	2b00      	cmp	r3, #0
 800bd4c:	d102      	bne.n	800bd54 <xQueueGenericSend+0x4e>
					vTaskSetTimeOutState( &xTimeOut );
 800bd4e:	a802      	add	r0, sp, #8
 800bd50:	f000 fc56 	bl	800c600 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 800bd54:	f000 fda0 	bl	800c898 <vPortExitCritical>
		vTaskSuspendAll();
 800bd58:	f000 fac6 	bl	800c2e8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800bd5c:	f000 fd90 	bl	800c880 <vPortEnterCritical>
 800bd60:	0022      	movs	r2, r4
 800bd62:	3244      	adds	r2, #68	; 0x44
 800bd64:	7813      	ldrb	r3, [r2, #0]
 800bd66:	b25b      	sxtb	r3, r3
 800bd68:	3301      	adds	r3, #1
 800bd6a:	d101      	bne.n	800bd70 <xQueueGenericSend+0x6a>
 800bd6c:	2300      	movs	r3, #0
 800bd6e:	7013      	strb	r3, [r2, #0]
 800bd70:	0022      	movs	r2, r4
 800bd72:	3245      	adds	r2, #69	; 0x45
 800bd74:	7813      	ldrb	r3, [r2, #0]
 800bd76:	b25b      	sxtb	r3, r3
 800bd78:	3301      	adds	r3, #1
 800bd7a:	d101      	bne.n	800bd80 <xQueueGenericSend+0x7a>
 800bd7c:	2300      	movs	r3, #0
 800bd7e:	7013      	strb	r3, [r2, #0]
 800bd80:	f000 fd8a 	bl	800c898 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800bd84:	a901      	add	r1, sp, #4
 800bd86:	a802      	add	r0, sp, #8
 800bd88:	f000 fc4a 	bl	800c620 <xTaskCheckForTimeOut>
 800bd8c:	2800      	cmp	r0, #0
 800bd8e:	d13c      	bne.n	800be0a <xQueueGenericSend+0x104>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 800bd90:	f000 fd76 	bl	800c880 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800bd94:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bd96:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800bd98:	4293      	cmp	r3, r2
 800bd9a:	d110      	bne.n	800bdbe <xQueueGenericSend+0xb8>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800bd9c:	f000 fd7c 	bl	800c898 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800bda0:	0020      	movs	r0, r4
 800bda2:	9901      	ldr	r1, [sp, #4]
 800bda4:	3010      	adds	r0, #16
 800bda6:	f000 fbe5 	bl	800c574 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800bdaa:	0020      	movs	r0, r4
 800bdac:	f7ff ff25 	bl	800bbfa <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800bdb0:	f000 fb0e 	bl	800c3d0 <xTaskResumeAll>
 800bdb4:	2800      	cmp	r0, #0
 800bdb6:	d109      	bne.n	800bdcc <xQueueGenericSend+0xc6>
					portYIELD_WITHIN_API();
 800bdb8:	f000 fd56 	bl	800c868 <vPortYield>
 800bdbc:	e006      	b.n	800bdcc <xQueueGenericSend+0xc6>
	taskEXIT_CRITICAL();
 800bdbe:	f000 fd6b 	bl	800c898 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 800bdc2:	0020      	movs	r0, r4
 800bdc4:	f7ff ff19 	bl	800bbfa <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800bdc8:	f000 fb02 	bl	800c3d0 <xTaskResumeAll>
 800bdcc:	2301      	movs	r3, #1
 800bdce:	9300      	str	r3, [sp, #0]
		taskENTER_CRITICAL();
 800bdd0:	f000 fd56 	bl	800c880 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800bdd4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bdd6:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800bdd8:	4293      	cmp	r3, r2
 800bdda:	d301      	bcc.n	800bde0 <xQueueGenericSend+0xda>
 800bddc:	2e02      	cmp	r6, #2
 800bdde:	d1ac      	bne.n	800bd3a <xQueueGenericSend+0x34>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800bde0:	0032      	movs	r2, r6
 800bde2:	0039      	movs	r1, r7
 800bde4:	0020      	movs	r0, r4
 800bde6:	f7ff fec8 	bl	800bb7a <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800bdea:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800bdec:	2b00      	cmp	r3, #0
 800bdee:	d003      	beq.n	800bdf8 <xQueueGenericSend+0xf2>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800bdf0:	0020      	movs	r0, r4
 800bdf2:	3024      	adds	r0, #36	; 0x24
 800bdf4:	f000 fbd0 	bl	800c598 <xTaskRemoveFromEventList>
 800bdf8:	2800      	cmp	r0, #0
 800bdfa:	d001      	beq.n	800be00 <xQueueGenericSend+0xfa>
							queueYIELD_IF_USING_PREEMPTION();
 800bdfc:	f000 fd34 	bl	800c868 <vPortYield>
				taskEXIT_CRITICAL();
 800be00:	f000 fd4a 	bl	800c898 <vPortExitCritical>
				return pdPASS;
 800be04:	2001      	movs	r0, #1
}
 800be06:	b005      	add	sp, #20
 800be08:	bdf0      	pop	{r4, r5, r6, r7, pc}
			prvUnlockQueue( pxQueue );
 800be0a:	0020      	movs	r0, r4
 800be0c:	f7ff fef5 	bl	800bbfa <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800be10:	f000 fade 	bl	800c3d0 <xTaskResumeAll>
 800be14:	e796      	b.n	800bd44 <xQueueGenericSend+0x3e>

0800be16 <xQueueGenericSendFromISR>:
{
 800be16:	b5f0      	push	{r4, r5, r6, r7, lr}
 800be18:	b085      	sub	sp, #20
 800be1a:	0004      	movs	r4, r0
 800be1c:	9101      	str	r1, [sp, #4]
 800be1e:	0017      	movs	r7, r2
 800be20:	001e      	movs	r6, r3
	configASSERT( pxQueue );
 800be22:	2800      	cmp	r0, #0
 800be24:	d101      	bne.n	800be2a <xQueueGenericSendFromISR+0x14>
 800be26:	b672      	cpsid	i
 800be28:	e7fe      	b.n	800be28 <xQueueGenericSendFromISR+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800be2a:	9b01      	ldr	r3, [sp, #4]
 800be2c:	2b00      	cmp	r3, #0
 800be2e:	d104      	bne.n	800be3a <xQueueGenericSendFromISR+0x24>
 800be30:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800be32:	2b00      	cmp	r3, #0
 800be34:	d001      	beq.n	800be3a <xQueueGenericSendFromISR+0x24>
 800be36:	b672      	cpsid	i
 800be38:	e7fe      	b.n	800be38 <xQueueGenericSendFromISR+0x22>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800be3a:	2e02      	cmp	r6, #2
 800be3c:	d104      	bne.n	800be48 <xQueueGenericSendFromISR+0x32>
 800be3e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800be40:	2b01      	cmp	r3, #1
 800be42:	d001      	beq.n	800be48 <xQueueGenericSendFromISR+0x32>
 800be44:	b672      	cpsid	i
 800be46:	e7fe      	b.n	800be46 <xQueueGenericSendFromISR+0x30>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800be48:	f000 fd34 	bl	800c8b4 <ulSetInterruptMaskFromISR>
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800be4c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800be4e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800be50:	9003      	str	r0, [sp, #12]
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800be52:	4293      	cmp	r3, r2
 800be54:	d302      	bcc.n	800be5c <xQueueGenericSendFromISR+0x46>
			xReturn = errQUEUE_FULL;
 800be56:	2500      	movs	r5, #0
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800be58:	2e02      	cmp	r6, #2
 800be5a:	d11a      	bne.n	800be92 <xQueueGenericSendFromISR+0x7c>
			const int8_t cTxLock = pxQueue->cTxLock;
 800be5c:	0023      	movs	r3, r4
 800be5e:	3345      	adds	r3, #69	; 0x45
 800be60:	9302      	str	r3, [sp, #8]
 800be62:	781d      	ldrb	r5, [r3, #0]
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800be64:	0032      	movs	r2, r6
			const int8_t cTxLock = pxQueue->cTxLock;
 800be66:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800be68:	9901      	ldr	r1, [sp, #4]
 800be6a:	0020      	movs	r0, r4
 800be6c:	f7ff fe85 	bl	800bb7a <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 800be70:	1c6b      	adds	r3, r5, #1
 800be72:	d114      	bne.n	800be9e <xQueueGenericSendFromISR+0x88>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800be74:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800be76:	2b00      	cmp	r3, #0
 800be78:	d101      	bne.n	800be7e <xQueueGenericSendFromISR+0x68>
			xReturn = pdPASS;
 800be7a:	2501      	movs	r5, #1
 800be7c:	e009      	b.n	800be92 <xQueueGenericSendFromISR+0x7c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800be7e:	0020      	movs	r0, r4
 800be80:	3024      	adds	r0, #36	; 0x24
 800be82:	f000 fb89 	bl	800c598 <xTaskRemoveFromEventList>
 800be86:	2800      	cmp	r0, #0
 800be88:	d0f7      	beq.n	800be7a <xQueueGenericSendFromISR+0x64>
							if( pxHigherPriorityTaskWoken != NULL )
 800be8a:	2f00      	cmp	r7, #0
 800be8c:	d0f5      	beq.n	800be7a <xQueueGenericSendFromISR+0x64>
								*pxHigherPriorityTaskWoken = pdTRUE;
 800be8e:	2501      	movs	r5, #1
 800be90:	603d      	str	r5, [r7, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800be92:	9803      	ldr	r0, [sp, #12]
 800be94:	f000 fd13 	bl	800c8be <vClearInterruptMaskFromISR>
}
 800be98:	0028      	movs	r0, r5
 800be9a:	b005      	add	sp, #20
 800be9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800be9e:	3501      	adds	r5, #1
 800bea0:	9b02      	ldr	r3, [sp, #8]
 800bea2:	b26d      	sxtb	r5, r5
 800bea4:	701d      	strb	r5, [r3, #0]
 800bea6:	e7e8      	b.n	800be7a <xQueueGenericSendFromISR+0x64>

0800bea8 <xQueueGenericReceive>:
{
 800bea8:	b5f0      	push	{r4, r5, r6, r7, lr}
 800beaa:	b085      	sub	sp, #20
 800beac:	0004      	movs	r4, r0
 800beae:	000e      	movs	r6, r1
 800beb0:	9201      	str	r2, [sp, #4]
 800beb2:	9300      	str	r3, [sp, #0]
	configASSERT( pxQueue );
 800beb4:	2800      	cmp	r0, #0
 800beb6:	d101      	bne.n	800bebc <xQueueGenericReceive+0x14>
 800beb8:	b672      	cpsid	i
 800beba:	e7fe      	b.n	800beba <xQueueGenericReceive+0x12>
 800bebc:	2700      	movs	r7, #0
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800bebe:	42b9      	cmp	r1, r7
 800bec0:	d155      	bne.n	800bf6e <xQueueGenericReceive+0xc6>
 800bec2:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800bec4:	42bb      	cmp	r3, r7
 800bec6:	d001      	beq.n	800becc <xQueueGenericReceive+0x24>
 800bec8:	b672      	cpsid	i
 800beca:	e7fe      	b.n	800beca <xQueueGenericReceive+0x22>
 800becc:	000f      	movs	r7, r1
 800bece:	e04e      	b.n	800bf6e <xQueueGenericReceive+0xc6>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800bed0:	6a63      	ldr	r3, [r4, #36]	; 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 800bed2:	60e7      	str	r7, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800bed4:	2b00      	cmp	r3, #0
 800bed6:	d064      	beq.n	800bfa2 <xQueueGenericReceive+0xfa>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800bed8:	0020      	movs	r0, r4
 800beda:	3024      	adds	r0, #36	; 0x24
 800bedc:	e05b      	b.n	800bf96 <xQueueGenericReceive+0xee>
				if( xTicksToWait == ( TickType_t ) 0 )
 800bede:	9b01      	ldr	r3, [sp, #4]
 800bee0:	2b00      	cmp	r3, #0
 800bee2:	d103      	bne.n	800beec <xQueueGenericReceive+0x44>
					taskEXIT_CRITICAL();
 800bee4:	f000 fcd8 	bl	800c898 <vPortExitCritical>
					return errQUEUE_EMPTY;
 800bee8:	2000      	movs	r0, #0
 800beea:	e05d      	b.n	800bfa8 <xQueueGenericReceive+0x100>
				else if( xEntryTimeSet == pdFALSE )
 800beec:	2f00      	cmp	r7, #0
 800beee:	d102      	bne.n	800bef6 <xQueueGenericReceive+0x4e>
					vTaskSetTimeOutState( &xTimeOut );
 800bef0:	a802      	add	r0, sp, #8
 800bef2:	f000 fb85 	bl	800c600 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 800bef6:	f000 fccf 	bl	800c898 <vPortExitCritical>
		vTaskSuspendAll();
 800befa:	f000 f9f5 	bl	800c2e8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800befe:	f000 fcbf 	bl	800c880 <vPortEnterCritical>
 800bf02:	0022      	movs	r2, r4
 800bf04:	3244      	adds	r2, #68	; 0x44
 800bf06:	7813      	ldrb	r3, [r2, #0]
 800bf08:	b25b      	sxtb	r3, r3
 800bf0a:	3301      	adds	r3, #1
 800bf0c:	d101      	bne.n	800bf12 <xQueueGenericReceive+0x6a>
 800bf0e:	2300      	movs	r3, #0
 800bf10:	7013      	strb	r3, [r2, #0]
 800bf12:	0022      	movs	r2, r4
 800bf14:	3245      	adds	r2, #69	; 0x45
 800bf16:	7813      	ldrb	r3, [r2, #0]
 800bf18:	b25b      	sxtb	r3, r3
 800bf1a:	3301      	adds	r3, #1
 800bf1c:	d101      	bne.n	800bf22 <xQueueGenericReceive+0x7a>
 800bf1e:	2300      	movs	r3, #0
 800bf20:	7013      	strb	r3, [r2, #0]
 800bf22:	f000 fcb9 	bl	800c898 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800bf26:	a901      	add	r1, sp, #4
 800bf28:	a802      	add	r0, sp, #8
 800bf2a:	f000 fb79 	bl	800c620 <xTaskCheckForTimeOut>
 800bf2e:	2800      	cmp	r0, #0
 800bf30:	d13c      	bne.n	800bfac <xQueueGenericReceive+0x104>
	taskENTER_CRITICAL();
 800bf32:	f000 fca5 	bl	800c880 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800bf36:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bf38:	2b00      	cmp	r3, #0
 800bf3a:	d110      	bne.n	800bf5e <xQueueGenericReceive+0xb6>
	taskEXIT_CRITICAL();
 800bf3c:	f000 fcac 	bl	800c898 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800bf40:	0020      	movs	r0, r4
 800bf42:	9901      	ldr	r1, [sp, #4]
 800bf44:	3024      	adds	r0, #36	; 0x24
 800bf46:	f000 fb15 	bl	800c574 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800bf4a:	0020      	movs	r0, r4
 800bf4c:	f7ff fe55 	bl	800bbfa <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800bf50:	f000 fa3e 	bl	800c3d0 <xTaskResumeAll>
 800bf54:	2800      	cmp	r0, #0
 800bf56:	d109      	bne.n	800bf6c <xQueueGenericReceive+0xc4>
					portYIELD_WITHIN_API();
 800bf58:	f000 fc86 	bl	800c868 <vPortYield>
 800bf5c:	e006      	b.n	800bf6c <xQueueGenericReceive+0xc4>
	taskEXIT_CRITICAL();
 800bf5e:	f000 fc9b 	bl	800c898 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 800bf62:	0020      	movs	r0, r4
 800bf64:	f7ff fe49 	bl	800bbfa <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800bf68:	f000 fa32 	bl	800c3d0 <xTaskResumeAll>
 800bf6c:	2701      	movs	r7, #1
		taskENTER_CRITICAL();
 800bf6e:	f000 fc87 	bl	800c880 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800bf72:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800bf74:	2d00      	cmp	r5, #0
 800bf76:	d0b2      	beq.n	800bede <xQueueGenericReceive+0x36>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800bf78:	0031      	movs	r1, r6
 800bf7a:	0020      	movs	r0, r4
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 800bf7c:	68e7      	ldr	r7, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800bf7e:	f7ff fe2a 	bl	800bbd6 <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
 800bf82:	9b00      	ldr	r3, [sp, #0]
 800bf84:	2b00      	cmp	r3, #0
 800bf86:	d1a3      	bne.n	800bed0 <xQueueGenericReceive+0x28>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800bf88:	6923      	ldr	r3, [r4, #16]
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 800bf8a:	3d01      	subs	r5, #1
 800bf8c:	63a5      	str	r5, [r4, #56]	; 0x38
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800bf8e:	2b00      	cmp	r3, #0
 800bf90:	d007      	beq.n	800bfa2 <xQueueGenericReceive+0xfa>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800bf92:	0020      	movs	r0, r4
 800bf94:	3010      	adds	r0, #16
 800bf96:	f000 faff 	bl	800c598 <xTaskRemoveFromEventList>
 800bf9a:	2800      	cmp	r0, #0
 800bf9c:	d001      	beq.n	800bfa2 <xQueueGenericReceive+0xfa>
							queueYIELD_IF_USING_PREEMPTION();
 800bf9e:	f000 fc63 	bl	800c868 <vPortYield>
				taskEXIT_CRITICAL();
 800bfa2:	f000 fc79 	bl	800c898 <vPortExitCritical>
				return pdPASS;
 800bfa6:	2001      	movs	r0, #1
}
 800bfa8:	b005      	add	sp, #20
 800bfaa:	bdf0      	pop	{r4, r5, r6, r7, pc}
			prvUnlockQueue( pxQueue );
 800bfac:	0020      	movs	r0, r4
 800bfae:	f7ff fe24 	bl	800bbfa <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800bfb2:	f000 fa0d 	bl	800c3d0 <xTaskResumeAll>
	taskENTER_CRITICAL();
 800bfb6:	f000 fc63 	bl	800c880 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800bfba:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800bfbc:	2b00      	cmp	r3, #0
 800bfbe:	d100      	bne.n	800bfc2 <xQueueGenericReceive+0x11a>
 800bfc0:	e790      	b.n	800bee4 <xQueueGenericReceive+0x3c>
	taskEXIT_CRITICAL();
 800bfc2:	f000 fc69 	bl	800c898 <vPortExitCritical>
 800bfc6:	e7d1      	b.n	800bf6c <xQueueGenericReceive+0xc4>

0800bfc8 <xQueueReceiveFromISR>:
{
 800bfc8:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bfca:	b085      	sub	sp, #20
 800bfcc:	0004      	movs	r4, r0
 800bfce:	9102      	str	r1, [sp, #8]
 800bfd0:	0016      	movs	r6, r2
	configASSERT( pxQueue );
 800bfd2:	2800      	cmp	r0, #0
 800bfd4:	d101      	bne.n	800bfda <xQueueReceiveFromISR+0x12>
 800bfd6:	b672      	cpsid	i
 800bfd8:	e7fe      	b.n	800bfd8 <xQueueReceiveFromISR+0x10>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800bfda:	9b02      	ldr	r3, [sp, #8]
 800bfdc:	2b00      	cmp	r3, #0
 800bfde:	d104      	bne.n	800bfea <xQueueReceiveFromISR+0x22>
 800bfe0:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800bfe2:	2b00      	cmp	r3, #0
 800bfe4:	d001      	beq.n	800bfea <xQueueReceiveFromISR+0x22>
 800bfe6:	b672      	cpsid	i
 800bfe8:	e7fe      	b.n	800bfe8 <xQueueReceiveFromISR+0x20>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800bfea:	f000 fc63 	bl	800c8b4 <ulSetInterruptMaskFromISR>
			xReturn = pdFAIL;
 800bfee:	2500      	movs	r5, #0
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800bff0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800bff2:	9003      	str	r0, [sp, #12]
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800bff4:	9301      	str	r3, [sp, #4]
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800bff6:	42ab      	cmp	r3, r5
 800bff8:	d01b      	beq.n	800c032 <xQueueReceiveFromISR+0x6a>
			const int8_t cRxLock = pxQueue->cRxLock;
 800bffa:	0027      	movs	r7, r4
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800bffc:	9902      	ldr	r1, [sp, #8]
			const int8_t cRxLock = pxQueue->cRxLock;
 800bffe:	3744      	adds	r7, #68	; 0x44
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800c000:	0020      	movs	r0, r4
			const int8_t cRxLock = pxQueue->cRxLock;
 800c002:	783d      	ldrb	r5, [r7, #0]
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800c004:	f7ff fde7 	bl	800bbd6 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 800c008:	9b01      	ldr	r3, [sp, #4]
			const int8_t cRxLock = pxQueue->cRxLock;
 800c00a:	b26d      	sxtb	r5, r5
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 800c00c:	3b01      	subs	r3, #1
 800c00e:	63a3      	str	r3, [r4, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 800c010:	1c6b      	adds	r3, r5, #1
 800c012:	d114      	bne.n	800c03e <xQueueReceiveFromISR+0x76>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800c014:	6923      	ldr	r3, [r4, #16]
 800c016:	2b00      	cmp	r3, #0
 800c018:	d101      	bne.n	800c01e <xQueueReceiveFromISR+0x56>
			xReturn = pdPASS;
 800c01a:	2501      	movs	r5, #1
 800c01c:	e009      	b.n	800c032 <xQueueReceiveFromISR+0x6a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800c01e:	0020      	movs	r0, r4
 800c020:	3010      	adds	r0, #16
 800c022:	f000 fab9 	bl	800c598 <xTaskRemoveFromEventList>
 800c026:	2800      	cmp	r0, #0
 800c028:	d0f7      	beq.n	800c01a <xQueueReceiveFromISR+0x52>
						if( pxHigherPriorityTaskWoken != NULL )
 800c02a:	2e00      	cmp	r6, #0
 800c02c:	d0f5      	beq.n	800c01a <xQueueReceiveFromISR+0x52>
							*pxHigherPriorityTaskWoken = pdTRUE;
 800c02e:	2501      	movs	r5, #1
 800c030:	6035      	str	r5, [r6, #0]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800c032:	9803      	ldr	r0, [sp, #12]
 800c034:	f000 fc43 	bl	800c8be <vClearInterruptMaskFromISR>
}
 800c038:	0028      	movs	r0, r5
 800c03a:	b005      	add	sp, #20
 800c03c:	bdf0      	pop	{r4, r5, r6, r7, pc}
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 800c03e:	3501      	adds	r5, #1
 800c040:	b26d      	sxtb	r5, r5
 800c042:	703d      	strb	r5, [r7, #0]
 800c044:	e7e9      	b.n	800c01a <xQueueReceiveFromISR+0x52>
	...

0800c048 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800c048:	4b06      	ldr	r3, [pc, #24]	; (800c064 <prvResetNextTaskUnblockTime+0x1c>)
 800c04a:	681a      	ldr	r2, [r3, #0]
 800c04c:	6812      	ldr	r2, [r2, #0]
 800c04e:	2a00      	cmp	r2, #0
 800c050:	d102      	bne.n	800c058 <prvResetNextTaskUnblockTime+0x10>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 800c052:	3a01      	subs	r2, #1
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800c054:	605a      	str	r2, [r3, #4]
	}
}
 800c056:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800c058:	681a      	ldr	r2, [r3, #0]
 800c05a:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800c05c:	68d2      	ldr	r2, [r2, #12]
 800c05e:	6852      	ldr	r2, [r2, #4]
 800c060:	e7f8      	b.n	800c054 <prvResetNextTaskUnblockTime+0xc>
 800c062:	46c0      	nop			; (mov r8, r8)
 800c064:	200003e4 	.word	0x200003e4

0800c068 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 800c068:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c06a:	0005      	movs	r5, r0
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 800c06c:	4c13      	ldr	r4, [pc, #76]	; (800c0bc <prvAddCurrentTaskToDelayedList+0x54>)
{
 800c06e:	000f      	movs	r7, r1
const TickType_t xConstTickCount = xTickCount;
 800c070:	68a6      	ldr	r6, [r4, #8]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800c072:	68e0      	ldr	r0, [r4, #12]
 800c074:	3004      	adds	r0, #4
 800c076:	f7ff fd70 	bl	800bb5a <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800c07a:	1c6b      	adds	r3, r5, #1
 800c07c:	d108      	bne.n	800c090 <prvAddCurrentTaskToDelayedList+0x28>
 800c07e:	2f00      	cmp	r7, #0
 800c080:	d006      	beq.n	800c090 <prvAddCurrentTaskToDelayedList+0x28>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800c082:	0020      	movs	r0, r4
 800c084:	68e1      	ldr	r1, [r4, #12]
 800c086:	3010      	adds	r0, #16
 800c088:	3104      	adds	r1, #4
 800c08a:	f7ff fd43 	bl	800bb14 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 800c08e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800c090:	68e3      	ldr	r3, [r4, #12]
			xTimeToWake = xConstTickCount + xTicksToWait;
 800c092:	1975      	adds	r5, r6, r5
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800c094:	605d      	str	r5, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 800c096:	42ae      	cmp	r6, r5
 800c098:	d905      	bls.n	800c0a6 <prvAddCurrentTaskToDelayedList+0x3e>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800c09a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800c09c:	68e1      	ldr	r1, [r4, #12]
 800c09e:	3104      	adds	r1, #4
 800c0a0:	f7ff fd44 	bl	800bb2c <vListInsert>
 800c0a4:	e7f3      	b.n	800c08e <prvAddCurrentTaskToDelayedList+0x26>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800c0a6:	6820      	ldr	r0, [r4, #0]
 800c0a8:	68e1      	ldr	r1, [r4, #12]
 800c0aa:	3104      	adds	r1, #4
 800c0ac:	f7ff fd3e 	bl	800bb2c <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 800c0b0:	6863      	ldr	r3, [r4, #4]
 800c0b2:	42ab      	cmp	r3, r5
 800c0b4:	d9eb      	bls.n	800c08e <prvAddCurrentTaskToDelayedList+0x26>
					xNextTaskUnblockTime = xTimeToWake;
 800c0b6:	6065      	str	r5, [r4, #4]
}
 800c0b8:	e7e9      	b.n	800c08e <prvAddCurrentTaskToDelayedList+0x26>
 800c0ba:	46c0      	nop			; (mov r8, r8)
 800c0bc:	200003e4 	.word	0x200003e4

0800c0c0 <xTaskCreate>:
	{
 800c0c0:	b5f0      	push	{r4, r5, r6, r7, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c0c2:	0095      	lsls	r5, r2, #2
	{
 800c0c4:	b085      	sub	sp, #20
 800c0c6:	9002      	str	r0, [sp, #8]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c0c8:	0028      	movs	r0, r5
	{
 800c0ca:	000f      	movs	r7, r1
 800c0cc:	9303      	str	r3, [sp, #12]
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c0ce:	f000 faff 	bl	800c6d0 <pvPortMalloc>
 800c0d2:	1e06      	subs	r6, r0, #0
			if( pxStack != NULL )
 800c0d4:	d100      	bne.n	800c0d8 <xTaskCreate+0x18>
 800c0d6:	e08b      	b.n	800c1f0 <xTaskCreate+0x130>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 800c0d8:	204c      	movs	r0, #76	; 0x4c
 800c0da:	f000 faf9 	bl	800c6d0 <pvPortMalloc>
 800c0de:	1e04      	subs	r4, r0, #0
				if( pxNewTCB != NULL )
 800c0e0:	d100      	bne.n	800c0e4 <xTaskCreate+0x24>
 800c0e2:	e082      	b.n	800c1ea <xTaskCreate+0x12a>
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800c0e4:	2307      	movs	r3, #7
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800c0e6:	3d04      	subs	r5, #4
					pxNewTCB->pxStack = pxStack;
 800c0e8:	6306      	str	r6, [r0, #48]	; 0x30
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 800c0ea:	1976      	adds	r6, r6, r5
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800c0ec:	439e      	bics	r6, r3
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800c0ee:	2300      	movs	r3, #0
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800c0f0:	9601      	str	r6, [sp, #4]
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800c0f2:	001a      	movs	r2, r3
 800c0f4:	5cf9      	ldrb	r1, [r7, r3]
 800c0f6:	3234      	adds	r2, #52	; 0x34
 800c0f8:	54a1      	strb	r1, [r4, r2]
		if( pcName[ x ] == 0x00 )
 800c0fa:	5cfa      	ldrb	r2, [r7, r3]
 800c0fc:	2a00      	cmp	r2, #0
 800c0fe:	d002      	beq.n	800c106 <xTaskCreate+0x46>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800c100:	3301      	adds	r3, #1
 800c102:	2b10      	cmp	r3, #16
 800c104:	d1f5      	bne.n	800c0f2 <xTaskCreate+0x32>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800c106:	0023      	movs	r3, r4
 800c108:	2200      	movs	r2, #0
 800c10a:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 800c10c:	3343      	adds	r3, #67	; 0x43
 800c10e:	701a      	strb	r2, [r3, #0]
 800c110:	2d06      	cmp	r5, #6
 800c112:	d900      	bls.n	800c116 <xTaskCreate+0x56>
 800c114:	2506      	movs	r5, #6
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800c116:	1d26      	adds	r6, r4, #4
	pxNewTCB->uxPriority = uxPriority;
 800c118:	62e5      	str	r5, [r4, #44]	; 0x2c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800c11a:	0030      	movs	r0, r6
 800c11c:	f7ff fcf7 	bl	800bb0e <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 800c120:	0020      	movs	r0, r4
 800c122:	3018      	adds	r0, #24
 800c124:	f7ff fcf3 	bl	800bb0e <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c128:	2307      	movs	r3, #7
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800c12a:	0022      	movs	r2, r4
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c12c:	1b5d      	subs	r5, r3, r5
		pxNewTCB->ulNotifiedValue = 0;
 800c12e:	2300      	movs	r3, #0
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800c130:	3248      	adds	r2, #72	; 0x48
		pxNewTCB->ulNotifiedValue = 0;
 800c132:	6463      	str	r3, [r4, #68]	; 0x44
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 800c134:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c136:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800c138:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800c13a:	9902      	ldr	r1, [sp, #8]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800c13c:	7013      	strb	r3, [r2, #0]
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800c13e:	9801      	ldr	r0, [sp, #4]
 800c140:	9a03      	ldr	r2, [sp, #12]
 800c142:	f000 fb7f 	bl	800c844 <pxPortInitialiseStack>
	if( ( void * ) pxCreatedTask != NULL )
 800c146:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800c148:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 800c14a:	2b00      	cmp	r3, #0
 800c14c:	d000      	beq.n	800c150 <xTaskCreate+0x90>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 800c14e:	601c      	str	r4, [r3, #0]
	taskENTER_CRITICAL();
 800c150:	f000 fb96 	bl	800c880 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 800c154:	4d2d      	ldr	r5, [pc, #180]	; (800c20c <xTaskCreate+0x14c>)
 800c156:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800c158:	3301      	adds	r3, #1
 800c15a:	62ab      	str	r3, [r5, #40]	; 0x28
		if( pxCurrentTCB == NULL )
 800c15c:	68ef      	ldr	r7, [r5, #12]
 800c15e:	2f00      	cmp	r7, #0
 800c160:	d149      	bne.n	800c1f6 <xTaskCreate+0x136>
			pxCurrentTCB = pxNewTCB;
 800c162:	60ec      	str	r4, [r5, #12]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800c164:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800c166:	2b01      	cmp	r3, #1
 800c168:	d11f      	bne.n	800c1aa <xTaskCreate+0xea>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800c16a:	2014      	movs	r0, #20
 800c16c:	4378      	muls	r0, r7
 800c16e:	4b28      	ldr	r3, [pc, #160]	; (800c210 <xTaskCreate+0x150>)
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800c170:	3701      	adds	r7, #1
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800c172:	1818      	adds	r0, r3, r0
 800c174:	f7ff fcc0 	bl	800baf8 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800c178:	2f07      	cmp	r7, #7
 800c17a:	d1f6      	bne.n	800c16a <xTaskCreate+0xaa>
	vListInitialise( &xDelayedTaskList1 );
 800c17c:	002f      	movs	r7, r5
 800c17e:	372c      	adds	r7, #44	; 0x2c
 800c180:	0038      	movs	r0, r7
 800c182:	f7ff fcb9 	bl	800baf8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800c186:	4823      	ldr	r0, [pc, #140]	; (800c214 <xTaskCreate+0x154>)
 800c188:	f7ff fcb6 	bl	800baf8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 800c18c:	0028      	movs	r0, r5
 800c18e:	3054      	adds	r0, #84	; 0x54
 800c190:	f7ff fcb2 	bl	800baf8 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 800c194:	0028      	movs	r0, r5
 800c196:	3068      	adds	r0, #104	; 0x68
 800c198:	f7ff fcae 	bl	800baf8 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 800c19c:	0028      	movs	r0, r5
 800c19e:	3010      	adds	r0, #16
 800c1a0:	f7ff fcaa 	bl	800baf8 <vListInitialise>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800c1a4:	4b1b      	ldr	r3, [pc, #108]	; (800c214 <xTaskCreate+0x154>)
	pxDelayedTaskList = &xDelayedTaskList1;
 800c1a6:	602f      	str	r7, [r5, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800c1a8:	626b      	str	r3, [r5, #36]	; 0x24
		uxTaskNumber++;
 800c1aa:	4b1b      	ldr	r3, [pc, #108]	; (800c218 <xTaskCreate+0x158>)
 800c1ac:	681a      	ldr	r2, [r3, #0]
		prvAddTaskToReadyList( pxNewTCB );
 800c1ae:	6859      	ldr	r1, [r3, #4]
		uxTaskNumber++;
 800c1b0:	3201      	adds	r2, #1
 800c1b2:	601a      	str	r2, [r3, #0]
		prvAddTaskToReadyList( pxNewTCB );
 800c1b4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800c1b6:	428a      	cmp	r2, r1
 800c1b8:	d900      	bls.n	800c1bc <xTaskCreate+0xfc>
 800c1ba:	605a      	str	r2, [r3, #4]
 800c1bc:	2014      	movs	r0, #20
 800c1be:	4350      	muls	r0, r2
 800c1c0:	4b13      	ldr	r3, [pc, #76]	; (800c210 <xTaskCreate+0x150>)
 800c1c2:	0031      	movs	r1, r6
 800c1c4:	1818      	adds	r0, r3, r0
 800c1c6:	f7ff fca5 	bl	800bb14 <vListInsertEnd>
	taskEXIT_CRITICAL();
 800c1ca:	f000 fb65 	bl	800c898 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 800c1ce:	6feb      	ldr	r3, [r5, #124]	; 0x7c
			xReturn = pdPASS;
 800c1d0:	2601      	movs	r6, #1
	if( xSchedulerRunning != pdFALSE )
 800c1d2:	2b00      	cmp	r3, #0
 800c1d4:	d006      	beq.n	800c1e4 <xTaskCreate+0x124>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800c1d6:	68eb      	ldr	r3, [r5, #12]
 800c1d8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c1da:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800c1dc:	429a      	cmp	r2, r3
 800c1de:	d201      	bcs.n	800c1e4 <xTaskCreate+0x124>
			taskYIELD_IF_USING_PREEMPTION();
 800c1e0:	f000 fb42 	bl	800c868 <vPortYield>
	}
 800c1e4:	0030      	movs	r0, r6
 800c1e6:	b005      	add	sp, #20
 800c1e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
					vPortFree( pxStack );
 800c1ea:	0030      	movs	r0, r6
 800c1ec:	f000 fae2 	bl	800c7b4 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800c1f0:	2601      	movs	r6, #1
 800c1f2:	4276      	negs	r6, r6
 800c1f4:	e7f6      	b.n	800c1e4 <xTaskCreate+0x124>
			if( xSchedulerRunning == pdFALSE )
 800c1f6:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 800c1f8:	2b00      	cmp	r3, #0
 800c1fa:	d1d6      	bne.n	800c1aa <xTaskCreate+0xea>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 800c1fc:	68eb      	ldr	r3, [r5, #12]
 800c1fe:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800c200:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c202:	4293      	cmp	r3, r2
 800c204:	d8d1      	bhi.n	800c1aa <xTaskCreate+0xea>
					pxCurrentTCB = pxNewTCB;
 800c206:	60ec      	str	r4, [r5, #12]
 800c208:	e7cf      	b.n	800c1aa <xTaskCreate+0xea>
 800c20a:	46c0      	nop			; (mov r8, r8)
 800c20c:	200003e4 	.word	0x200003e4
 800c210:	20000484 	.word	0x20000484
 800c214:	20000424 	.word	0x20000424
 800c218:	20000464 	.word	0x20000464

0800c21c <vTaskDelete>:
	{
 800c21c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c21e:	0004      	movs	r4, r0
		taskENTER_CRITICAL();
 800c220:	f000 fb2e 	bl	800c880 <vPortEnterCritical>
 800c224:	4d1c      	ldr	r5, [pc, #112]	; (800c298 <vTaskDelete+0x7c>)
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 800c226:	2c00      	cmp	r4, #0
 800c228:	d100      	bne.n	800c22c <vTaskDelete+0x10>
 800c22a:	68ec      	ldr	r4, [r5, #12]
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800c22c:	1d27      	adds	r7, r4, #4
 800c22e:	0038      	movs	r0, r7
 800c230:	f7ff fc93 	bl	800bb5a <uxListRemove>
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800c234:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800c236:	2b00      	cmp	r3, #0
 800c238:	d003      	beq.n	800c242 <vTaskDelete+0x26>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800c23a:	0020      	movs	r0, r4
 800c23c:	3018      	adds	r0, #24
 800c23e:	f7ff fc8c 	bl	800bb5a <uxListRemove>
			uxTaskNumber++;
 800c242:	4e16      	ldr	r6, [pc, #88]	; (800c29c <vTaskDelete+0x80>)
 800c244:	6833      	ldr	r3, [r6, #0]
 800c246:	3301      	adds	r3, #1
 800c248:	6033      	str	r3, [r6, #0]
			if( pxTCB == pxCurrentTCB )
 800c24a:	68eb      	ldr	r3, [r5, #12]
 800c24c:	42a3      	cmp	r3, r4
 800c24e:	d114      	bne.n	800c27a <vTaskDelete+0x5e>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 800c250:	0028      	movs	r0, r5
 800c252:	0039      	movs	r1, r7
 800c254:	3068      	adds	r0, #104	; 0x68
 800c256:	f7ff fc5d 	bl	800bb14 <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
 800c25a:	68b3      	ldr	r3, [r6, #8]
 800c25c:	3301      	adds	r3, #1
 800c25e:	60b3      	str	r3, [r6, #8]
		taskEXIT_CRITICAL();
 800c260:	f000 fb1a 	bl	800c898 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 800c264:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 800c266:	2b00      	cmp	r3, #0
 800c268:	d015      	beq.n	800c296 <vTaskDelete+0x7a>
			if( pxTCB == pxCurrentTCB )
 800c26a:	68eb      	ldr	r3, [r5, #12]
 800c26c:	42a3      	cmp	r3, r4
 800c26e:	d112      	bne.n	800c296 <vTaskDelete+0x7a>
				configASSERT( uxSchedulerSuspended == 0 );
 800c270:	68f3      	ldr	r3, [r6, #12]
 800c272:	2b00      	cmp	r3, #0
 800c274:	d00d      	beq.n	800c292 <vTaskDelete+0x76>
 800c276:	b672      	cpsid	i
 800c278:	e7fe      	b.n	800c278 <vTaskDelete+0x5c>
				--uxCurrentNumberOfTasks;
 800c27a:	6aab      	ldr	r3, [r5, #40]	; 0x28
			vPortFree( pxTCB->pxStack );
 800c27c:	6b20      	ldr	r0, [r4, #48]	; 0x30
				--uxCurrentNumberOfTasks;
 800c27e:	3b01      	subs	r3, #1
 800c280:	62ab      	str	r3, [r5, #40]	; 0x28
			vPortFree( pxTCB->pxStack );
 800c282:	f000 fa97 	bl	800c7b4 <vPortFree>
			vPortFree( pxTCB );
 800c286:	0020      	movs	r0, r4
 800c288:	f000 fa94 	bl	800c7b4 <vPortFree>
				prvResetNextTaskUnblockTime();
 800c28c:	f7ff fedc 	bl	800c048 <prvResetNextTaskUnblockTime>
 800c290:	e7e6      	b.n	800c260 <vTaskDelete+0x44>
				portYIELD_WITHIN_API();
 800c292:	f000 fae9 	bl	800c868 <vPortYield>
	}
 800c296:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c298:	200003e4 	.word	0x200003e4
 800c29c:	20000464 	.word	0x20000464

0800c2a0 <vTaskStartScheduler>:
{
 800c2a0:	b513      	push	{r0, r1, r4, lr}
		xReturn = xTaskCreate(	prvIdleTask,
 800c2a2:	2400      	movs	r4, #0
 800c2a4:	4b0c      	ldr	r3, [pc, #48]	; (800c2d8 <vTaskStartScheduler+0x38>)
 800c2a6:	9400      	str	r4, [sp, #0]
 800c2a8:	3310      	adds	r3, #16
 800c2aa:	9301      	str	r3, [sp, #4]
 800c2ac:	2228      	movs	r2, #40	; 0x28
 800c2ae:	0023      	movs	r3, r4
 800c2b0:	490a      	ldr	r1, [pc, #40]	; (800c2dc <vTaskStartScheduler+0x3c>)
 800c2b2:	480b      	ldr	r0, [pc, #44]	; (800c2e0 <vTaskStartScheduler+0x40>)
 800c2b4:	f7ff ff04 	bl	800c0c0 <xTaskCreate>
	if( xReturn == pdPASS )
 800c2b8:	2801      	cmp	r0, #1
 800c2ba:	d109      	bne.n	800c2d0 <vTaskStartScheduler+0x30>
		portDISABLE_INTERRUPTS();
 800c2bc:	b672      	cpsid	i
		xNextTaskUnblockTime = portMAX_DELAY;
 800c2be:	2201      	movs	r2, #1
 800c2c0:	4b08      	ldr	r3, [pc, #32]	; (800c2e4 <vTaskStartScheduler+0x44>)
 800c2c2:	4252      	negs	r2, r2
 800c2c4:	605a      	str	r2, [r3, #4]
		xSchedulerRunning = pdTRUE;
 800c2c6:	67d8      	str	r0, [r3, #124]	; 0x7c
		xTickCount = ( TickType_t ) 0U;
 800c2c8:	609c      	str	r4, [r3, #8]
		if( xPortStartScheduler() != pdFALSE )
 800c2ca:	f000 fb49 	bl	800c960 <xPortStartScheduler>
}
 800c2ce:	bd13      	pop	{r0, r1, r4, pc}
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 800c2d0:	1c43      	adds	r3, r0, #1
 800c2d2:	d1fc      	bne.n	800c2ce <vTaskStartScheduler+0x2e>
 800c2d4:	b672      	cpsid	i
 800c2d6:	e7fe      	b.n	800c2d6 <vTaskStartScheduler+0x36>
 800c2d8:	20000464 	.word	0x20000464
 800c2dc:	0800ced6 	.word	0x0800ced6
 800c2e0:	0800c4b5 	.word	0x0800c4b5
 800c2e4:	200003e4 	.word	0x200003e4

0800c2e8 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 800c2e8:	4a02      	ldr	r2, [pc, #8]	; (800c2f4 <vTaskSuspendAll+0xc>)
 800c2ea:	68d3      	ldr	r3, [r2, #12]
 800c2ec:	3301      	adds	r3, #1
 800c2ee:	60d3      	str	r3, [r2, #12]
}
 800c2f0:	4770      	bx	lr
 800c2f2:	46c0      	nop			; (mov r8, r8)
 800c2f4:	20000464 	.word	0x20000464

0800c2f8 <uxTaskGetNumberOfTasks>:
	return uxCurrentNumberOfTasks;
 800c2f8:	4b01      	ldr	r3, [pc, #4]	; (800c300 <uxTaskGetNumberOfTasks+0x8>)
 800c2fa:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
 800c2fc:	4770      	bx	lr
 800c2fe:	46c0      	nop			; (mov r8, r8)
 800c300:	200003e4 	.word	0x200003e4

0800c304 <xTaskIncrementTick>:
{
 800c304:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800c306:	4d2f      	ldr	r5, [pc, #188]	; (800c3c4 <xTaskIncrementTick+0xc0>)
 800c308:	68eb      	ldr	r3, [r5, #12]
 800c30a:	2b00      	cmp	r3, #0
 800c30c:	d155      	bne.n	800c3ba <xTaskIncrementTick+0xb6>
		const TickType_t xConstTickCount = xTickCount + 1;
 800c30e:	4c2e      	ldr	r4, [pc, #184]	; (800c3c8 <xTaskIncrementTick+0xc4>)
 800c310:	68a3      	ldr	r3, [r4, #8]
 800c312:	3301      	adds	r3, #1
 800c314:	9300      	str	r3, [sp, #0]
		xTickCount = xConstTickCount;
 800c316:	60a3      	str	r3, [r4, #8]
		if( xConstTickCount == ( TickType_t ) 0U )
 800c318:	2b00      	cmp	r3, #0
 800c31a:	d10e      	bne.n	800c33a <xTaskIncrementTick+0x36>
			taskSWITCH_DELAYED_LISTS();
 800c31c:	6823      	ldr	r3, [r4, #0]
 800c31e:	681b      	ldr	r3, [r3, #0]
 800c320:	2b00      	cmp	r3, #0
 800c322:	d001      	beq.n	800c328 <xTaskIncrementTick+0x24>
 800c324:	b672      	cpsid	i
 800c326:	e7fe      	b.n	800c326 <xTaskIncrementTick+0x22>
 800c328:	6823      	ldr	r3, [r4, #0]
 800c32a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800c32c:	6022      	str	r2, [r4, #0]
 800c32e:	6263      	str	r3, [r4, #36]	; 0x24
 800c330:	696b      	ldr	r3, [r5, #20]
 800c332:	3301      	adds	r3, #1
 800c334:	616b      	str	r3, [r5, #20]
 800c336:	f7ff fe87 	bl	800c048 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 800c33a:	6863      	ldr	r3, [r4, #4]
 800c33c:	9a00      	ldr	r2, [sp, #0]
BaseType_t xSwitchRequired = pdFALSE;
 800c33e:	2600      	movs	r6, #0
		if( xConstTickCount >= xNextTaskUnblockTime )
 800c340:	4293      	cmp	r3, r2
 800c342:	d933      	bls.n	800c3ac <xTaskIncrementTick+0xa8>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800c344:	68e3      	ldr	r3, [r4, #12]
 800c346:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c348:	2314      	movs	r3, #20
 800c34a:	4353      	muls	r3, r2
 800c34c:	4a1f      	ldr	r2, [pc, #124]	; (800c3cc <xTaskIncrementTick+0xc8>)
 800c34e:	58d3      	ldr	r3, [r2, r3]
 800c350:	2b01      	cmp	r3, #1
 800c352:	d900      	bls.n	800c356 <xTaskIncrementTick+0x52>
				xSwitchRequired = pdTRUE;
 800c354:	2601      	movs	r6, #1
		if( xYieldPending != pdFALSE )
 800c356:	69eb      	ldr	r3, [r5, #28]
 800c358:	2b00      	cmp	r3, #0
 800c35a:	d000      	beq.n	800c35e <xTaskIncrementTick+0x5a>
			xSwitchRequired = pdTRUE;
 800c35c:	2601      	movs	r6, #1
}
 800c35e:	0030      	movs	r0, r6
 800c360:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800c362:	6823      	ldr	r3, [r4, #0]
					if( xConstTickCount < xItemValue )
 800c364:	9a00      	ldr	r2, [sp, #0]
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 800c366:	68db      	ldr	r3, [r3, #12]
 800c368:	68df      	ldr	r7, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800c36a:	687b      	ldr	r3, [r7, #4]
					if( xConstTickCount < xItemValue )
 800c36c:	429a      	cmp	r2, r3
 800c36e:	d322      	bcc.n	800c3b6 <xTaskIncrementTick+0xb2>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800c370:	1d3b      	adds	r3, r7, #4
 800c372:	0018      	movs	r0, r3
 800c374:	9301      	str	r3, [sp, #4]
 800c376:	f7ff fbf0 	bl	800bb5a <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800c37a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c37c:	2b00      	cmp	r3, #0
 800c37e:	d003      	beq.n	800c388 <xTaskIncrementTick+0x84>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800c380:	0038      	movs	r0, r7
 800c382:	3018      	adds	r0, #24
 800c384:	f7ff fbe9 	bl	800bb5a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800c388:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c38a:	686b      	ldr	r3, [r5, #4]
 800c38c:	4298      	cmp	r0, r3
 800c38e:	d900      	bls.n	800c392 <xTaskIncrementTick+0x8e>
 800c390:	6068      	str	r0, [r5, #4]
 800c392:	2314      	movs	r3, #20
 800c394:	4358      	muls	r0, r3
 800c396:	4b0d      	ldr	r3, [pc, #52]	; (800c3cc <xTaskIncrementTick+0xc8>)
 800c398:	1d39      	adds	r1, r7, #4
 800c39a:	1818      	adds	r0, r3, r0
 800c39c:	f7ff fbba 	bl	800bb14 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800c3a0:	68e3      	ldr	r3, [r4, #12]
 800c3a2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c3a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c3a6:	429a      	cmp	r2, r3
 800c3a8:	d300      	bcc.n	800c3ac <xTaskIncrementTick+0xa8>
							xSwitchRequired = pdTRUE;
 800c3aa:	2601      	movs	r6, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800c3ac:	6823      	ldr	r3, [r4, #0]
 800c3ae:	681b      	ldr	r3, [r3, #0]
 800c3b0:	2b00      	cmp	r3, #0
 800c3b2:	d1d6      	bne.n	800c362 <xTaskIncrementTick+0x5e>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c3b4:	3b01      	subs	r3, #1
						xNextTaskUnblockTime = xItemValue;
 800c3b6:	6063      	str	r3, [r4, #4]
						break;
 800c3b8:	e7c4      	b.n	800c344 <xTaskIncrementTick+0x40>
		++uxPendedTicks;
 800c3ba:	69ab      	ldr	r3, [r5, #24]
BaseType_t xSwitchRequired = pdFALSE;
 800c3bc:	2600      	movs	r6, #0
		++uxPendedTicks;
 800c3be:	3301      	adds	r3, #1
 800c3c0:	61ab      	str	r3, [r5, #24]
 800c3c2:	e7c8      	b.n	800c356 <xTaskIncrementTick+0x52>
 800c3c4:	20000464 	.word	0x20000464
 800c3c8:	200003e4 	.word	0x200003e4
 800c3cc:	20000484 	.word	0x20000484

0800c3d0 <xTaskResumeAll>:
{
 800c3d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( uxSchedulerSuspended );
 800c3d2:	4c28      	ldr	r4, [pc, #160]	; (800c474 <xTaskResumeAll+0xa4>)
 800c3d4:	68e3      	ldr	r3, [r4, #12]
 800c3d6:	2b00      	cmp	r3, #0
 800c3d8:	d101      	bne.n	800c3de <xTaskResumeAll+0xe>
 800c3da:	b672      	cpsid	i
 800c3dc:	e7fe      	b.n	800c3dc <xTaskResumeAll+0xc>
	taskENTER_CRITICAL();
 800c3de:	f000 fa4f 	bl	800c880 <vPortEnterCritical>
		--uxSchedulerSuspended;
 800c3e2:	68e3      	ldr	r3, [r4, #12]
 800c3e4:	3b01      	subs	r3, #1
 800c3e6:	60e3      	str	r3, [r4, #12]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800c3e8:	68e5      	ldr	r5, [r4, #12]
 800c3ea:	2d00      	cmp	r5, #0
 800c3ec:	d004      	beq.n	800c3f8 <xTaskResumeAll+0x28>
BaseType_t xAlreadyYielded = pdFALSE;
 800c3ee:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 800c3f0:	f000 fa52 	bl	800c898 <vPortExitCritical>
}
 800c3f4:	0020      	movs	r0, r4
 800c3f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800c3f8:	4e1f      	ldr	r6, [pc, #124]	; (800c478 <xTaskResumeAll+0xa8>)
 800c3fa:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800c3fc:	2b00      	cmp	r3, #0
 800c3fe:	d0f6      	beq.n	800c3ee <xTaskResumeAll+0x1e>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800c400:	6d73      	ldr	r3, [r6, #84]	; 0x54
 800c402:	2b00      	cmp	r3, #0
 800c404:	d117      	bne.n	800c436 <xTaskResumeAll+0x66>
				if( pxTCB != NULL )
 800c406:	2d00      	cmp	r5, #0
 800c408:	d001      	beq.n	800c40e <xTaskResumeAll+0x3e>
					prvResetNextTaskUnblockTime();
 800c40a:	f7ff fe1d 	bl	800c048 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 800c40e:	69a5      	ldr	r5, [r4, #24]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 800c410:	2d00      	cmp	r5, #0
 800c412:	d009      	beq.n	800c428 <xTaskResumeAll+0x58>
								xYieldPending = pdTRUE;
 800c414:	2601      	movs	r6, #1
							if( xTaskIncrementTick() != pdFALSE )
 800c416:	f7ff ff75 	bl	800c304 <xTaskIncrementTick>
 800c41a:	2800      	cmp	r0, #0
 800c41c:	d000      	beq.n	800c420 <xTaskResumeAll+0x50>
								xYieldPending = pdTRUE;
 800c41e:	61e6      	str	r6, [r4, #28]
							--uxPendedCounts;
 800c420:	3d01      	subs	r5, #1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 800c422:	2d00      	cmp	r5, #0
 800c424:	d1f7      	bne.n	800c416 <xTaskResumeAll+0x46>
						uxPendedTicks = 0;
 800c426:	61a5      	str	r5, [r4, #24]
				if( xYieldPending != pdFALSE )
 800c428:	69e3      	ldr	r3, [r4, #28]
 800c42a:	2b00      	cmp	r3, #0
 800c42c:	d0df      	beq.n	800c3ee <xTaskResumeAll+0x1e>
					taskYIELD_IF_USING_PREEMPTION();
 800c42e:	f000 fa1b 	bl	800c868 <vPortYield>
						xAlreadyYielded = pdTRUE;
 800c432:	2401      	movs	r4, #1
 800c434:	e7dc      	b.n	800c3f0 <xTaskResumeAll+0x20>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 800c436:	6e33      	ldr	r3, [r6, #96]	; 0x60
 800c438:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800c43a:	0028      	movs	r0, r5
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800c43c:	1d2f      	adds	r7, r5, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800c43e:	3018      	adds	r0, #24
 800c440:	f7ff fb8b 	bl	800bb5a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800c444:	0038      	movs	r0, r7
 800c446:	f7ff fb88 	bl	800bb5a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800c44a:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 800c44c:	6863      	ldr	r3, [r4, #4]
 800c44e:	4298      	cmp	r0, r3
 800c450:	d900      	bls.n	800c454 <xTaskResumeAll+0x84>
 800c452:	6060      	str	r0, [r4, #4]
 800c454:	2314      	movs	r3, #20
 800c456:	4358      	muls	r0, r3
 800c458:	4b08      	ldr	r3, [pc, #32]	; (800c47c <xTaskResumeAll+0xac>)
 800c45a:	0039      	movs	r1, r7
 800c45c:	18c0      	adds	r0, r0, r3
 800c45e:	f7ff fb59 	bl	800bb14 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800c462:	68f3      	ldr	r3, [r6, #12]
 800c464:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800c466:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c468:	429a      	cmp	r2, r3
 800c46a:	d3c9      	bcc.n	800c400 <xTaskResumeAll+0x30>
						xYieldPending = pdTRUE;
 800c46c:	2301      	movs	r3, #1
 800c46e:	61e3      	str	r3, [r4, #28]
 800c470:	e7c6      	b.n	800c400 <xTaskResumeAll+0x30>
 800c472:	46c0      	nop			; (mov r8, r8)
 800c474:	20000464 	.word	0x20000464
 800c478:	200003e4 	.word	0x200003e4
 800c47c:	20000484 	.word	0x20000484

0800c480 <vTaskDelay>:
	{
 800c480:	b570      	push	{r4, r5, r6, lr}
 800c482:	1e04      	subs	r4, r0, #0
		if( xTicksToDelay > ( TickType_t ) 0U )
 800c484:	d102      	bne.n	800c48c <vTaskDelay+0xc>
			portYIELD_WITHIN_API();
 800c486:	f000 f9ef 	bl	800c868 <vPortYield>
	}
 800c48a:	bd70      	pop	{r4, r5, r6, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 800c48c:	4b08      	ldr	r3, [pc, #32]	; (800c4b0 <vTaskDelay+0x30>)
 800c48e:	68dd      	ldr	r5, [r3, #12]
 800c490:	2d00      	cmp	r5, #0
 800c492:	d001      	beq.n	800c498 <vTaskDelay+0x18>
 800c494:	b672      	cpsid	i
 800c496:	e7fe      	b.n	800c496 <vTaskDelay+0x16>
			vTaskSuspendAll();
 800c498:	f7ff ff26 	bl	800c2e8 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 800c49c:	0029      	movs	r1, r5
 800c49e:	0020      	movs	r0, r4
 800c4a0:	f7ff fde2 	bl	800c068 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 800c4a4:	f7ff ff94 	bl	800c3d0 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 800c4a8:	2800      	cmp	r0, #0
 800c4aa:	d0ec      	beq.n	800c486 <vTaskDelay+0x6>
 800c4ac:	e7ed      	b.n	800c48a <vTaskDelay+0xa>
 800c4ae:	46c0      	nop			; (mov r8, r8)
 800c4b0:	20000464 	.word	0x20000464

0800c4b4 <prvIdleTask>:
{
 800c4b4:	b570      	push	{r4, r5, r6, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800c4b6:	4d14      	ldr	r5, [pc, #80]	; (800c508 <prvIdleTask+0x54>)
 800c4b8:	68ab      	ldr	r3, [r5, #8]
 800c4ba:	2b00      	cmp	r3, #0
 800c4bc:	d106      	bne.n	800c4cc <prvIdleTask+0x18>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800c4be:	4b13      	ldr	r3, [pc, #76]	; (800c50c <prvIdleTask+0x58>)
 800c4c0:	681b      	ldr	r3, [r3, #0]
 800c4c2:	2b01      	cmp	r3, #1
 800c4c4:	d9f7      	bls.n	800c4b6 <prvIdleTask+0x2>
				taskYIELD();
 800c4c6:	f000 f9cf 	bl	800c868 <vPortYield>
 800c4ca:	e7f4      	b.n	800c4b6 <prvIdleTask+0x2>
			vTaskSuspendAll();
 800c4cc:	f7ff ff0c 	bl	800c2e8 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 800c4d0:	4c0f      	ldr	r4, [pc, #60]	; (800c510 <prvIdleTask+0x5c>)
 800c4d2:	6ea6      	ldr	r6, [r4, #104]	; 0x68
			( void ) xTaskResumeAll();
 800c4d4:	f7ff ff7c 	bl	800c3d0 <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 800c4d8:	2e00      	cmp	r6, #0
 800c4da:	d0ec      	beq.n	800c4b6 <prvIdleTask+0x2>
				taskENTER_CRITICAL();
 800c4dc:	f000 f9d0 	bl	800c880 <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 800c4e0:	6f63      	ldr	r3, [r4, #116]	; 0x74
 800c4e2:	68de      	ldr	r6, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800c4e4:	1d30      	adds	r0, r6, #4
 800c4e6:	f7ff fb38 	bl	800bb5a <uxListRemove>
					--uxCurrentNumberOfTasks;
 800c4ea:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800c4ec:	3b01      	subs	r3, #1
 800c4ee:	62a3      	str	r3, [r4, #40]	; 0x28
					--uxDeletedTasksWaitingCleanUp;
 800c4f0:	68ab      	ldr	r3, [r5, #8]
 800c4f2:	3b01      	subs	r3, #1
 800c4f4:	60ab      	str	r3, [r5, #8]
				taskEXIT_CRITICAL();
 800c4f6:	f000 f9cf 	bl	800c898 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 800c4fa:	6b30      	ldr	r0, [r6, #48]	; 0x30
 800c4fc:	f000 f95a 	bl	800c7b4 <vPortFree>
			vPortFree( pxTCB );
 800c500:	0030      	movs	r0, r6
 800c502:	f000 f957 	bl	800c7b4 <vPortFree>
 800c506:	e7d6      	b.n	800c4b6 <prvIdleTask+0x2>
 800c508:	20000464 	.word	0x20000464
 800c50c:	20000484 	.word	0x20000484
 800c510:	200003e4 	.word	0x200003e4

0800c514 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800c514:	4914      	ldr	r1, [pc, #80]	; (800c568 <vTaskSwitchContext+0x54>)
{
 800c516:	b570      	push	{r4, r5, r6, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800c518:	68cb      	ldr	r3, [r1, #12]
 800c51a:	2b00      	cmp	r3, #0
 800c51c:	d002      	beq.n	800c524 <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
 800c51e:	2301      	movs	r3, #1
 800c520:	61cb      	str	r3, [r1, #28]
}
 800c522:	bd70      	pop	{r4, r5, r6, pc}
 800c524:	2514      	movs	r5, #20
		xYieldPending = pdFALSE;
 800c526:	61cb      	str	r3, [r1, #28]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800c528:	684b      	ldr	r3, [r1, #4]
 800c52a:	4810      	ldr	r0, [pc, #64]	; (800c56c <vTaskSwitchContext+0x58>)
 800c52c:	002a      	movs	r2, r5
 800c52e:	435a      	muls	r2, r3
 800c530:	1814      	adds	r4, r2, r0
 800c532:	6826      	ldr	r6, [r4, #0]
 800c534:	2e00      	cmp	r6, #0
 800c536:	d011      	beq.n	800c55c <vTaskSwitchContext+0x48>
 800c538:	6865      	ldr	r5, [r4, #4]
 800c53a:	3208      	adds	r2, #8
 800c53c:	686d      	ldr	r5, [r5, #4]
 800c53e:	1812      	adds	r2, r2, r0
 800c540:	6065      	str	r5, [r4, #4]
 800c542:	4295      	cmp	r5, r2
 800c544:	d101      	bne.n	800c54a <vTaskSwitchContext+0x36>
 800c546:	686a      	ldr	r2, [r5, #4]
 800c548:	6062      	str	r2, [r4, #4]
 800c54a:	2214      	movs	r2, #20
 800c54c:	435a      	muls	r2, r3
 800c54e:	1880      	adds	r0, r0, r2
 800c550:	6842      	ldr	r2, [r0, #4]
 800c552:	68d0      	ldr	r0, [r2, #12]
 800c554:	4a06      	ldr	r2, [pc, #24]	; (800c570 <vTaskSwitchContext+0x5c>)
 800c556:	60d0      	str	r0, [r2, #12]
 800c558:	604b      	str	r3, [r1, #4]
}
 800c55a:	e7e2      	b.n	800c522 <vTaskSwitchContext+0xe>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 800c55c:	2b00      	cmp	r3, #0
 800c55e:	d101      	bne.n	800c564 <vTaskSwitchContext+0x50>
 800c560:	b672      	cpsid	i
 800c562:	e7fe      	b.n	800c562 <vTaskSwitchContext+0x4e>
 800c564:	3b01      	subs	r3, #1
 800c566:	e7e1      	b.n	800c52c <vTaskSwitchContext+0x18>
 800c568:	20000464 	.word	0x20000464
 800c56c:	20000484 	.word	0x20000484
 800c570:	200003e4 	.word	0x200003e4

0800c574 <vTaskPlaceOnEventList>:
{
 800c574:	b510      	push	{r4, lr}
 800c576:	000c      	movs	r4, r1
	configASSERT( pxEventList );
 800c578:	2800      	cmp	r0, #0
 800c57a:	d101      	bne.n	800c580 <vTaskPlaceOnEventList+0xc>
 800c57c:	b672      	cpsid	i
 800c57e:	e7fe      	b.n	800c57e <vTaskPlaceOnEventList+0xa>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800c580:	4b04      	ldr	r3, [pc, #16]	; (800c594 <vTaskPlaceOnEventList+0x20>)
 800c582:	68d9      	ldr	r1, [r3, #12]
 800c584:	3118      	adds	r1, #24
 800c586:	f7ff fad1 	bl	800bb2c <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800c58a:	2101      	movs	r1, #1
 800c58c:	0020      	movs	r0, r4
 800c58e:	f7ff fd6b 	bl	800c068 <prvAddCurrentTaskToDelayedList>
}
 800c592:	bd10      	pop	{r4, pc}
 800c594:	200003e4 	.word	0x200003e4

0800c598 <xTaskRemoveFromEventList>:
{
 800c598:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800c59a:	68c3      	ldr	r3, [r0, #12]
 800c59c:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 800c59e:	2c00      	cmp	r4, #0
 800c5a0:	d101      	bne.n	800c5a6 <xTaskRemoveFromEventList+0xe>
 800c5a2:	b672      	cpsid	i
 800c5a4:	e7fe      	b.n	800c5a4 <xTaskRemoveFromEventList+0xc>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800c5a6:	0027      	movs	r7, r4
 800c5a8:	3718      	adds	r7, #24
 800c5aa:	0038      	movs	r0, r7
 800c5ac:	f7ff fad5 	bl	800bb5a <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800c5b0:	4d10      	ldr	r5, [pc, #64]	; (800c5f4 <xTaskRemoveFromEventList+0x5c>)
 800c5b2:	4e11      	ldr	r6, [pc, #68]	; (800c5f8 <xTaskRemoveFromEventList+0x60>)
 800c5b4:	68eb      	ldr	r3, [r5, #12]
 800c5b6:	2b00      	cmp	r3, #0
 800c5b8:	d118      	bne.n	800c5ec <xTaskRemoveFromEventList+0x54>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800c5ba:	1d27      	adds	r7, r4, #4
 800c5bc:	0038      	movs	r0, r7
 800c5be:	f7ff facc 	bl	800bb5a <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800c5c2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800c5c4:	686a      	ldr	r2, [r5, #4]
 800c5c6:	4293      	cmp	r3, r2
 800c5c8:	d900      	bls.n	800c5cc <xTaskRemoveFromEventList+0x34>
 800c5ca:	606b      	str	r3, [r5, #4]
 800c5cc:	2014      	movs	r0, #20
 800c5ce:	4358      	muls	r0, r3
 800c5d0:	4b0a      	ldr	r3, [pc, #40]	; (800c5fc <xTaskRemoveFromEventList+0x64>)
 800c5d2:	18c0      	adds	r0, r0, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800c5d4:	0039      	movs	r1, r7
 800c5d6:	f7ff fa9d 	bl	800bb14 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800c5da:	68f3      	ldr	r3, [r6, #12]
 800c5dc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800c5de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
		xReturn = pdFALSE;
 800c5e0:	2000      	movs	r0, #0
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800c5e2:	429a      	cmp	r2, r3
 800c5e4:	d901      	bls.n	800c5ea <xTaskRemoveFromEventList+0x52>
		xYieldPending = pdTRUE;
 800c5e6:	3001      	adds	r0, #1
 800c5e8:	61e8      	str	r0, [r5, #28]
}
 800c5ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800c5ec:	0030      	movs	r0, r6
 800c5ee:	3054      	adds	r0, #84	; 0x54
 800c5f0:	e7f0      	b.n	800c5d4 <xTaskRemoveFromEventList+0x3c>
 800c5f2:	46c0      	nop			; (mov r8, r8)
 800c5f4:	20000464 	.word	0x20000464
 800c5f8:	200003e4 	.word	0x200003e4
 800c5fc:	20000484 	.word	0x20000484

0800c600 <vTaskSetTimeOutState>:
	configASSERT( pxTimeOut );
 800c600:	2800      	cmp	r0, #0
 800c602:	d101      	bne.n	800c608 <vTaskSetTimeOutState+0x8>
 800c604:	b672      	cpsid	i
 800c606:	e7fe      	b.n	800c606 <vTaskSetTimeOutState+0x6>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800c608:	4b03      	ldr	r3, [pc, #12]	; (800c618 <vTaskSetTimeOutState+0x18>)
 800c60a:	695b      	ldr	r3, [r3, #20]
 800c60c:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800c60e:	4b03      	ldr	r3, [pc, #12]	; (800c61c <vTaskSetTimeOutState+0x1c>)
 800c610:	689b      	ldr	r3, [r3, #8]
 800c612:	6043      	str	r3, [r0, #4]
}
 800c614:	4770      	bx	lr
 800c616:	46c0      	nop			; (mov r8, r8)
 800c618:	20000464 	.word	0x20000464
 800c61c:	200003e4 	.word	0x200003e4

0800c620 <xTaskCheckForTimeOut>:
{
 800c620:	b570      	push	{r4, r5, r6, lr}
 800c622:	0004      	movs	r4, r0
 800c624:	000d      	movs	r5, r1
	configASSERT( pxTimeOut );
 800c626:	2800      	cmp	r0, #0
 800c628:	d101      	bne.n	800c62e <xTaskCheckForTimeOut+0xe>
 800c62a:	b672      	cpsid	i
 800c62c:	e7fe      	b.n	800c62c <xTaskCheckForTimeOut+0xc>
	configASSERT( pxTicksToWait );
 800c62e:	2900      	cmp	r1, #0
 800c630:	d101      	bne.n	800c636 <xTaskCheckForTimeOut+0x16>
 800c632:	b672      	cpsid	i
 800c634:	e7fe      	b.n	800c634 <xTaskCheckForTimeOut+0x14>
	taskENTER_CRITICAL();
 800c636:	f000 f923 	bl	800c880 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 800c63a:	4b0f      	ldr	r3, [pc, #60]	; (800c678 <xTaskCheckForTimeOut+0x58>)
				xReturn = pdFALSE;
 800c63c:	2600      	movs	r6, #0
		const TickType_t xConstTickCount = xTickCount;
 800c63e:	6899      	ldr	r1, [r3, #8]
			if( *pxTicksToWait == portMAX_DELAY )
 800c640:	682b      	ldr	r3, [r5, #0]
 800c642:	1c5a      	adds	r2, r3, #1
 800c644:	d013      	beq.n	800c66e <xTaskCheckForTimeOut+0x4e>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800c646:	4a0d      	ldr	r2, [pc, #52]	; (800c67c <xTaskCheckForTimeOut+0x5c>)
 800c648:	6826      	ldr	r6, [r4, #0]
 800c64a:	6950      	ldr	r0, [r2, #20]
 800c64c:	6862      	ldr	r2, [r4, #4]
 800c64e:	4286      	cmp	r6, r0
 800c650:	d002      	beq.n	800c658 <xTaskCheckForTimeOut+0x38>
			xReturn = pdTRUE;
 800c652:	2601      	movs	r6, #1
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800c654:	4291      	cmp	r1, r2
 800c656:	d20a      	bcs.n	800c66e <xTaskCheckForTimeOut+0x4e>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800c658:	1a88      	subs	r0, r1, r2
			xReturn = pdTRUE;
 800c65a:	2601      	movs	r6, #1
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800c65c:	4283      	cmp	r3, r0
 800c65e:	d906      	bls.n	800c66e <xTaskCheckForTimeOut+0x4e>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 800c660:	1a5b      	subs	r3, r3, r1
 800c662:	189b      	adds	r3, r3, r2
 800c664:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 800c666:	0020      	movs	r0, r4
 800c668:	f7ff ffca 	bl	800c600 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 800c66c:	2600      	movs	r6, #0
	taskEXIT_CRITICAL();
 800c66e:	f000 f913 	bl	800c898 <vPortExitCritical>
}
 800c672:	0030      	movs	r0, r6
 800c674:	bd70      	pop	{r4, r5, r6, pc}
 800c676:	46c0      	nop			; (mov r8, r8)
 800c678:	200003e4 	.word	0x200003e4
 800c67c:	20000464 	.word	0x20000464

0800c680 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 800c680:	2201      	movs	r2, #1
 800c682:	4b01      	ldr	r3, [pc, #4]	; (800c688 <vTaskMissedYield+0x8>)
 800c684:	61da      	str	r2, [r3, #28]
}
 800c686:	4770      	bx	lr
 800c688:	20000464 	.word	0x20000464

0800c68c <prvInsertBlockIntoFreeList>:
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800c68c:	4b0f      	ldr	r3, [pc, #60]	; (800c6cc <prvInsertBlockIntoFreeList+0x40>)
{
 800c68e:	b530      	push	{r4, r5, lr}
 800c690:	001d      	movs	r5, r3
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800c692:	681a      	ldr	r2, [r3, #0]
 800c694:	4282      	cmp	r2, r0
 800c696:	d317      	bcc.n	800c6c8 <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800c698:	685c      	ldr	r4, [r3, #4]
 800c69a:	1919      	adds	r1, r3, r4
 800c69c:	4288      	cmp	r0, r1
 800c69e:	d103      	bne.n	800c6a8 <prvInsertBlockIntoFreeList+0x1c>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800c6a0:	6841      	ldr	r1, [r0, #4]
 800c6a2:	0018      	movs	r0, r3
 800c6a4:	1909      	adds	r1, r1, r4
 800c6a6:	6059      	str	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800c6a8:	6841      	ldr	r1, [r0, #4]
 800c6aa:	1844      	adds	r4, r0, r1
 800c6ac:	42a2      	cmp	r2, r4
 800c6ae:	d106      	bne.n	800c6be <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800c6b0:	68ac      	ldr	r4, [r5, #8]
 800c6b2:	42a2      	cmp	r2, r4
 800c6b4:	d003      	beq.n	800c6be <prvInsertBlockIntoFreeList+0x32>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800c6b6:	6854      	ldr	r4, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800c6b8:	6812      	ldr	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800c6ba:	1861      	adds	r1, r4, r1
 800c6bc:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 800c6be:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 800c6c0:	4298      	cmp	r0, r3
 800c6c2:	d000      	beq.n	800c6c6 <prvInsertBlockIntoFreeList+0x3a>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800c6c4:	6018      	str	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800c6c6:	bd30      	pop	{r4, r5, pc}
 800c6c8:	0013      	movs	r3, r2
 800c6ca:	e7e2      	b.n	800c692 <prvInsertBlockIntoFreeList+0x6>
 800c6cc:	20000510 	.word	0x20000510

0800c6d0 <pvPortMalloc>:
{
 800c6d0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800c6d2:	0005      	movs	r5, r0
	vTaskSuspendAll();
 800c6d4:	f7ff fe08 	bl	800c2e8 <vTaskSuspendAll>
		if( pxEnd == NULL )
 800c6d8:	4c33      	ldr	r4, [pc, #204]	; (800c7a8 <pvPortMalloc+0xd8>)
 800c6da:	68a3      	ldr	r3, [r4, #8]
 800c6dc:	2b00      	cmp	r3, #0
 800c6de:	d11a      	bne.n	800c716 <pvPortMalloc+0x46>
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800c6e0:	2107      	movs	r1, #7
	uxAddress = ( size_t ) ucHeap;
 800c6e2:	4a32      	ldr	r2, [pc, #200]	; (800c7ac <pvPortMalloc+0xdc>)
 800c6e4:	4b32      	ldr	r3, [pc, #200]	; (800c7b0 <pvPortMalloc+0xe0>)
 800c6e6:	18d3      	adds	r3, r2, r3
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800c6e8:	420a      	tst	r2, r1
 800c6ea:	d03c      	beq.n	800c766 <pvPortMalloc+0x96>
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800c6ec:	1852      	adds	r2, r2, r1
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800c6ee:	438a      	bics	r2, r1
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 800c6f0:	1a9b      	subs	r3, r3, r2
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800c6f2:	2007      	movs	r0, #7
	xStart.xBlockSize = ( size_t ) 0;
 800c6f4:	2100      	movs	r1, #0
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 800c6f6:	18d3      	adds	r3, r2, r3
	uxAddress -= xHeapStructSize;
 800c6f8:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800c6fa:	4383      	bics	r3, r0
	xStart.xBlockSize = ( size_t ) 0;
 800c6fc:	6061      	str	r1, [r4, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800c6fe:	6022      	str	r2, [r4, #0]
	pxEnd->xBlockSize = 0;
 800c700:	6059      	str	r1, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 800c702:	6019      	str	r1, [r3, #0]
	pxEnd = ( void * ) uxAddress;
 800c704:	60a3      	str	r3, [r4, #8]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800c706:	1a99      	subs	r1, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 800c708:	6013      	str	r3, [r2, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800c70a:	2380      	movs	r3, #128	; 0x80
 800c70c:	061b      	lsls	r3, r3, #24
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800c70e:	6051      	str	r1, [r2, #4]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800c710:	60e1      	str	r1, [r4, #12]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800c712:	6121      	str	r1, [r4, #16]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800c714:	6163      	str	r3, [r4, #20]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800c716:	6967      	ldr	r7, [r4, #20]
 800c718:	423d      	tst	r5, r7
 800c71a:	d140      	bne.n	800c79e <pvPortMalloc+0xce>
			if( xWantedSize > 0 )
 800c71c:	2d00      	cmp	r5, #0
 800c71e:	d03e      	beq.n	800c79e <pvPortMalloc+0xce>
				xWantedSize += xHeapStructSize;
 800c720:	002b      	movs	r3, r5
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800c722:	2207      	movs	r2, #7
				xWantedSize += xHeapStructSize;
 800c724:	3308      	adds	r3, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800c726:	4213      	tst	r3, r2
 800c728:	d001      	beq.n	800c72e <pvPortMalloc+0x5e>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800c72a:	4393      	bics	r3, r2
 800c72c:	3308      	adds	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 800c72e:	2b00      	cmp	r3, #0
 800c730:	d035      	beq.n	800c79e <pvPortMalloc+0xce>
 800c732:	6926      	ldr	r6, [r4, #16]
 800c734:	429e      	cmp	r6, r3
 800c736:	d332      	bcc.n	800c79e <pvPortMalloc+0xce>
				pxPreviousBlock = &xStart;
 800c738:	0021      	movs	r1, r4
				pxBlock = xStart.pxNextFreeBlock;
 800c73a:	6825      	ldr	r5, [r4, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800c73c:	686a      	ldr	r2, [r5, #4]
 800c73e:	429a      	cmp	r2, r3
 800c740:	d202      	bcs.n	800c748 <pvPortMalloc+0x78>
 800c742:	6828      	ldr	r0, [r5, #0]
 800c744:	2800      	cmp	r0, #0
 800c746:	d110      	bne.n	800c76a <pvPortMalloc+0x9a>
				if( pxBlock != pxEnd )
 800c748:	68a0      	ldr	r0, [r4, #8]
 800c74a:	42a8      	cmp	r0, r5
 800c74c:	d027      	beq.n	800c79e <pvPortMalloc+0xce>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c74e:	6808      	ldr	r0, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800c750:	1ad2      	subs	r2, r2, r3
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c752:	9001      	str	r0, [sp, #4]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 800c754:	6828      	ldr	r0, [r5, #0]
 800c756:	6008      	str	r0, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800c758:	2a10      	cmp	r2, #16
 800c75a:	d90d      	bls.n	800c778 <pvPortMalloc+0xa8>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800c75c:	18e8      	adds	r0, r5, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 800c75e:	0741      	lsls	r1, r0, #29
 800c760:	d006      	beq.n	800c770 <pvPortMalloc+0xa0>
 800c762:	b672      	cpsid	i
 800c764:	e7fe      	b.n	800c764 <pvPortMalloc+0x94>
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 800c766:	4b12      	ldr	r3, [pc, #72]	; (800c7b0 <pvPortMalloc+0xe0>)
 800c768:	e7c3      	b.n	800c6f2 <pvPortMalloc+0x22>
 800c76a:	0029      	movs	r1, r5
 800c76c:	0005      	movs	r5, r0
 800c76e:	e7e5      	b.n	800c73c <pvPortMalloc+0x6c>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 800c770:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 800c772:	606b      	str	r3, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 800c774:	f7ff ff8a 	bl	800c68c <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800c778:	686b      	ldr	r3, [r5, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800c77a:	68e2      	ldr	r2, [r4, #12]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800c77c:	1af6      	subs	r6, r6, r3
 800c77e:	6126      	str	r6, [r4, #16]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800c780:	4296      	cmp	r6, r2
 800c782:	d200      	bcs.n	800c786 <pvPortMalloc+0xb6>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 800c784:	60e6      	str	r6, [r4, #12]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800c786:	431f      	orrs	r7, r3
					pxBlock->pxNextFreeBlock = NULL;
 800c788:	2300      	movs	r3, #0
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c78a:	9c01      	ldr	r4, [sp, #4]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800c78c:	606f      	str	r7, [r5, #4]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800c78e:	3408      	adds	r4, #8
					pxBlock->pxNextFreeBlock = NULL;
 800c790:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 800c792:	f7ff fe1d 	bl	800c3d0 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 800c796:	0763      	lsls	r3, r4, #29
 800c798:	d003      	beq.n	800c7a2 <pvPortMalloc+0xd2>
 800c79a:	b672      	cpsid	i
 800c79c:	e7fe      	b.n	800c79c <pvPortMalloc+0xcc>
void *pvReturn = NULL;
 800c79e:	2400      	movs	r4, #0
 800c7a0:	e7f7      	b.n	800c792 <pvPortMalloc+0xc2>
}
 800c7a2:	0020      	movs	r0, r4
 800c7a4:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 800c7a6:	46c0      	nop			; (mov r8, r8)
 800c7a8:	20000510 	.word	0x20000510
 800c7ac:	20000528 	.word	0x20000528
 800c7b0:	00001450 	.word	0x00001450

0800c7b4 <vPortFree>:
{
 800c7b4:	b570      	push	{r4, r5, r6, lr}
	if( pv != NULL )
 800c7b6:	2800      	cmp	r0, #0
 800c7b8:	d01a      	beq.n	800c7f0 <vPortFree+0x3c>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800c7ba:	4d0e      	ldr	r5, [pc, #56]	; (800c7f4 <vPortFree+0x40>)
 800c7bc:	3808      	subs	r0, #8
 800c7be:	6843      	ldr	r3, [r0, #4]
 800c7c0:	696a      	ldr	r2, [r5, #20]
 800c7c2:	0004      	movs	r4, r0
 800c7c4:	421a      	tst	r2, r3
 800c7c6:	d101      	bne.n	800c7cc <vPortFree+0x18>
 800c7c8:	b672      	cpsid	i
 800c7ca:	e7fe      	b.n	800c7ca <vPortFree+0x16>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800c7cc:	6801      	ldr	r1, [r0, #0]
 800c7ce:	2900      	cmp	r1, #0
 800c7d0:	d001      	beq.n	800c7d6 <vPortFree+0x22>
 800c7d2:	b672      	cpsid	i
 800c7d4:	e7fe      	b.n	800c7d4 <vPortFree+0x20>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800c7d6:	4393      	bics	r3, r2
 800c7d8:	6043      	str	r3, [r0, #4]
				vTaskSuspendAll();
 800c7da:	f7ff fd85 	bl	800c2e8 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 800c7de:	692a      	ldr	r2, [r5, #16]
 800c7e0:	6863      	ldr	r3, [r4, #4]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800c7e2:	0020      	movs	r0, r4
					xFreeBytesRemaining += pxLink->xBlockSize;
 800c7e4:	189b      	adds	r3, r3, r2
 800c7e6:	612b      	str	r3, [r5, #16]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800c7e8:	f7ff ff50 	bl	800c68c <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 800c7ec:	f7ff fdf0 	bl	800c3d0 <xTaskResumeAll>
}
 800c7f0:	bd70      	pop	{r4, r5, r6, pc}
 800c7f2:	46c0      	nop			; (mov r8, r8)
 800c7f4:	20000510 	.word	0x20000510

0800c7f8 <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800c7f8:	4b03      	ldr	r3, [pc, #12]	; (800c808 <prvTaskExitError+0x10>)
 800c7fa:	681b      	ldr	r3, [r3, #0]
 800c7fc:	3301      	adds	r3, #1
 800c7fe:	d001      	beq.n	800c804 <prvTaskExitError+0xc>
 800c800:	b672      	cpsid	i
 800c802:	e7fe      	b.n	800c802 <prvTaskExitError+0xa>
	portDISABLE_INTERRUPTS();
 800c804:	b672      	cpsid	i
 800c806:	e7fe      	b.n	800c806 <prvTaskExitError+0xe>
 800c808:	20000238 	.word	0x20000238
 800c80c:	00000000 	.word	0x00000000

0800c810 <vPortStartFirstTask>:
void vPortStartFirstTask( void )
{
	/* The MSP stack is not reset as, unlike on M3/4 parts, there is no vector
	table offset register that can be used to locate the initial stack value.
	Not all M0 parts have the application vector table at address 0. */
	__asm volatile(
 800c810:	4a0b      	ldr	r2, [pc, #44]	; (800c840 <pxCurrentTCBConst2>)
 800c812:	6813      	ldr	r3, [r2, #0]
 800c814:	6818      	ldr	r0, [r3, #0]
 800c816:	3020      	adds	r0, #32
 800c818:	f380 8809 	msr	PSP, r0
 800c81c:	2002      	movs	r0, #2
 800c81e:	f380 8814 	msr	CONTROL, r0
 800c822:	f3bf 8f6f 	isb	sy
 800c826:	bc3f      	pop	{r0, r1, r2, r3, r4, r5}
 800c828:	46ae      	mov	lr, r5
 800c82a:	bc08      	pop	{r3}
 800c82c:	bc04      	pop	{r2}
 800c82e:	b662      	cpsie	i
 800c830:	4718      	bx	r3
 800c832:	46c0      	nop			; (mov r8, r8)
 800c834:	46c0      	nop			; (mov r8, r8)
 800c836:	46c0      	nop			; (mov r8, r8)
 800c838:	46c0      	nop			; (mov r8, r8)
 800c83a:	46c0      	nop			; (mov r8, r8)
 800c83c:	46c0      	nop			; (mov r8, r8)
 800c83e:	46c0      	nop			; (mov r8, r8)

0800c840 <pxCurrentTCBConst2>:
 800c840:	200003f0 	.word	0x200003f0

0800c844 <pxPortInitialiseStack>:
{
 800c844:	b510      	push	{r4, lr}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800c846:	2480      	movs	r4, #128	; 0x80
 800c848:	1f03      	subs	r3, r0, #4
 800c84a:	0464      	lsls	r4, r4, #17
 800c84c:	601c      	str	r4, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
 800c84e:	3b04      	subs	r3, #4
 800c850:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 800c852:	4903      	ldr	r1, [pc, #12]	; (800c860 <pxPortInitialiseStack+0x1c>)
 800c854:	3b04      	subs	r3, #4
 800c856:	6019      	str	r1, [r3, #0]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800c858:	3b14      	subs	r3, #20
	pxTopOfStack -= 8; /* R11..R4. */
 800c85a:	3840      	subs	r0, #64	; 0x40
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800c85c:	601a      	str	r2, [r3, #0]
}
 800c85e:	bd10      	pop	{r4, pc}
 800c860:	0800c7f9 	.word	0x0800c7f9

0800c864 <SVC_Handler>:
}
 800c864:	4770      	bx	lr
	...

0800c868 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
 800c868:	2280      	movs	r2, #128	; 0x80
 800c86a:	4b04      	ldr	r3, [pc, #16]	; (800c87c <vPortYield+0x14>)
 800c86c:	0552      	lsls	r2, r2, #21
 800c86e:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 800c870:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800c874:	f3bf 8f6f 	isb	sy
}
 800c878:	4770      	bx	lr
 800c87a:	46c0      	nop			; (mov r8, r8)
 800c87c:	e000ed04 	.word	0xe000ed04

0800c880 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    portDISABLE_INTERRUPTS();
 800c880:	b672      	cpsid	i
    uxCriticalNesting++;
 800c882:	4a04      	ldr	r2, [pc, #16]	; (800c894 <vPortEnterCritical+0x14>)
 800c884:	6813      	ldr	r3, [r2, #0]
 800c886:	3301      	adds	r3, #1
 800c888:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
 800c88a:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800c88e:	f3bf 8f6f 	isb	sy
}
 800c892:	4770      	bx	lr
 800c894:	20000238 	.word	0x20000238

0800c898 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
 800c898:	4a05      	ldr	r2, [pc, #20]	; (800c8b0 <vPortExitCritical+0x18>)
 800c89a:	6813      	ldr	r3, [r2, #0]
 800c89c:	2b00      	cmp	r3, #0
 800c89e:	d101      	bne.n	800c8a4 <vPortExitCritical+0xc>
 800c8a0:	b672      	cpsid	i
 800c8a2:	e7fe      	b.n	800c8a2 <vPortExitCritical+0xa>
    uxCriticalNesting--;
 800c8a4:	3b01      	subs	r3, #1
 800c8a6:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
 800c8a8:	2b00      	cmp	r3, #0
 800c8aa:	d100      	bne.n	800c8ae <vPortExitCritical+0x16>
    {
        portENABLE_INTERRUPTS();
 800c8ac:	b662      	cpsie	i
    }
}
 800c8ae:	4770      	bx	lr
 800c8b0:	20000238 	.word	0x20000238

0800c8b4 <ulSetInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

uint32_t ulSetInterruptMaskFromISR( void )
{
	__asm volatile(
 800c8b4:	f3ef 8010 	mrs	r0, PRIMASK
 800c8b8:	b672      	cpsid	i
 800c8ba:	4770      	bx	lr
					" bx lr				  "
				  );

	/* To avoid compiler warnings.  This line will never be reached. */
	return 0;
}
 800c8bc:	2000      	movs	r0, #0

0800c8be <vClearInterruptMaskFromISR>:
/*-----------------------------------------------------------*/

void vClearInterruptMaskFromISR( uint32_t ulMask )
{
	__asm volatile(
 800c8be:	f380 8810 	msr	PRIMASK, r0
 800c8c2:	4770      	bx	lr
	...

0800c8d0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 800c8d0:	f3ef 8009 	mrs	r0, PSP
 800c8d4:	4b0e      	ldr	r3, [pc, #56]	; (800c910 <pxCurrentTCBConst>)
 800c8d6:	681a      	ldr	r2, [r3, #0]
 800c8d8:	3820      	subs	r0, #32
 800c8da:	6010      	str	r0, [r2, #0]
 800c8dc:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800c8de:	4644      	mov	r4, r8
 800c8e0:	464d      	mov	r5, r9
 800c8e2:	4656      	mov	r6, sl
 800c8e4:	465f      	mov	r7, fp
 800c8e6:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
 800c8e8:	b508      	push	{r3, lr}
 800c8ea:	b672      	cpsid	i
 800c8ec:	f7ff fe12 	bl	800c514 <vTaskSwitchContext>
 800c8f0:	b662      	cpsie	i
 800c8f2:	bc0c      	pop	{r2, r3}
 800c8f4:	6811      	ldr	r1, [r2, #0]
 800c8f6:	6808      	ldr	r0, [r1, #0]
 800c8f8:	3010      	adds	r0, #16
 800c8fa:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800c8fc:	46a0      	mov	r8, r4
 800c8fe:	46a9      	mov	r9, r5
 800c900:	46b2      	mov	sl, r6
 800c902:	46bb      	mov	fp, r7
 800c904:	f380 8809 	msr	PSP, r0
 800c908:	3820      	subs	r0, #32
 800c90a:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
 800c90c:	4718      	bx	r3
 800c90e:	46c0      	nop			; (mov r8, r8)

0800c910 <pxCurrentTCBConst>:
 800c910:	200003f0 	.word	0x200003f0

0800c914 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 800c914:	b510      	push	{r4, lr}
uint32_t ulPreviousMask;

	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 800c916:	f7ff ffcd 	bl	800c8b4 <ulSetInterruptMaskFromISR>
 800c91a:	0004      	movs	r4, r0
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 800c91c:	f7ff fcf2 	bl	800c304 <xTaskIncrementTick>
 800c920:	2800      	cmp	r0, #0
 800c922:	d003      	beq.n	800c92c <xPortSysTickHandler+0x18>
		{
			/* Pend a context switch. */
			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 800c924:	2280      	movs	r2, #128	; 0x80
 800c926:	4b03      	ldr	r3, [pc, #12]	; (800c934 <xPortSysTickHandler+0x20>)
 800c928:	0552      	lsls	r2, r2, #21
 800c92a:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 800c92c:	0020      	movs	r0, r4
 800c92e:	f7ff ffc6 	bl	800c8be <vClearInterruptMaskFromISR>
}
 800c932:	bd10      	pop	{r4, pc}
 800c934:	e000ed04 	.word	0xe000ed04

0800c938 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */
	/* Configure SysTick to interrupt at the requested rate. */

	portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800c938:	21fa      	movs	r1, #250	; 0xfa
 800c93a:	4b06      	ldr	r3, [pc, #24]	; (800c954 <vPortSetupTimerInterrupt+0x1c>)
{
 800c93c:	b510      	push	{r4, lr}
	portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800c93e:	6818      	ldr	r0, [r3, #0]
 800c940:	0089      	lsls	r1, r1, #2
 800c942:	f7f9 f841 	bl	80059c8 <__udivsi3>
	portNVIC_SYSTICK_CTRL = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 800c946:	2207      	movs	r2, #7
	portNVIC_SYSTICK_LOAD = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800c948:	4b03      	ldr	r3, [pc, #12]	; (800c958 <vPortSetupTimerInterrupt+0x20>)
 800c94a:	3801      	subs	r0, #1
 800c94c:	6018      	str	r0, [r3, #0]
	portNVIC_SYSTICK_CTRL = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 800c94e:	4b03      	ldr	r3, [pc, #12]	; (800c95c <vPortSetupTimerInterrupt+0x24>)
 800c950:	601a      	str	r2, [r3, #0]
}
 800c952:	bd10      	pop	{r4, pc}
 800c954:	20000030 	.word	0x20000030
 800c958:	e000e014 	.word	0xe000e014
 800c95c:	e000e010 	.word	0xe000e010

0800c960 <xPortStartScheduler>:
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 800c960:	22ff      	movs	r2, #255	; 0xff
 800c962:	4b0a      	ldr	r3, [pc, #40]	; (800c98c <xPortStartScheduler+0x2c>)
 800c964:	0412      	lsls	r2, r2, #16
 800c966:	6819      	ldr	r1, [r3, #0]
{
 800c968:	b510      	push	{r4, lr}
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 800c96a:	430a      	orrs	r2, r1
 800c96c:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 800c96e:	22ff      	movs	r2, #255	; 0xff
 800c970:	6819      	ldr	r1, [r3, #0]
 800c972:	0612      	lsls	r2, r2, #24
 800c974:	430a      	orrs	r2, r1
 800c976:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 800c978:	f7ff ffde 	bl	800c938 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 800c97c:	2200      	movs	r2, #0
 800c97e:	4b04      	ldr	r3, [pc, #16]	; (800c990 <xPortStartScheduler+0x30>)
 800c980:	601a      	str	r2, [r3, #0]
	vPortStartFirstTask();
 800c982:	f7ff ff45 	bl	800c810 <vPortStartFirstTask>
	prvTaskExitError();
 800c986:	f7ff ff37 	bl	800c7f8 <prvTaskExitError>
 800c98a:	46c0      	nop			; (mov r8, r8)
 800c98c:	e000ed20 	.word	0xe000ed20
 800c990:	20000238 	.word	0x20000238

0800c994 <Led_Init>:
/**
  * @brief This function performs an init of the LED manager.
  * @retval None
  */
void Led_Init()
{
 800c994:	2300      	movs	r3, #0
 800c996:	4a08      	ldr	r2, [pc, #32]	; (800c9b8 <Led_Init+0x24>)
 800c998:	b530      	push	{r4, r5, lr}
 800c99a:	0010      	movs	r0, r2
static inline void prvLedStatusInit(LED_BSP_TypeDef Index)
{
  configASSERT(LED_INDEX_IsValid(Index));

  Status[Index].Index = Index;
  Status[Index].Mode = LED_MODE_OFF;
 800c99c:	0019      	movs	r1, r3
  Status[Index].Period = LED_PERIOD_DEFAULT;
 800c99e:	2564      	movs	r5, #100	; 0x64
    LedOrder[i] = i;
 800c9a0:	4c06      	ldr	r4, [pc, #24]	; (800c9bc <Led_Init+0x28>)
    prvLedStatusInit((LED_BSP_TypeDef)i);
 800c9a2:	7013      	strb	r3, [r2, #0]
    LedOrder[i] = i;
 800c9a4:	54e3      	strb	r3, [r4, r3]
 800c9a6:	3301      	adds	r3, #1
  Status[Index].Mode = LED_MODE_OFF;
 800c9a8:	7051      	strb	r1, [r2, #1]
  Status[Index].Period = LED_PERIOD_DEFAULT;
 800c9aa:	8095      	strh	r5, [r2, #4]
  Status[Index].Count = 0;
 800c9ac:	80d1      	strh	r1, [r2, #6]
 800c9ae:	3208      	adds	r2, #8
  for(i=0; i<LED_INDEX_LEN; i++)
 800c9b0:	2b04      	cmp	r3, #4
 800c9b2:	d1f6      	bne.n	800c9a2 <Led_Init+0xe>
  GlobalCount = 0;
 800c9b4:	8401      	strh	r1, [r0, #32]
}
 800c9b6:	bd30      	pop	{r4, r5, pc}
 800c9b8:	20001978 	.word	0x20001978
 800c9bc:	20001dbc 	.word	0x20001dbc

0800c9c0 <Led_Set>:
{
 800c9c0:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (!LED_INDEX_IsValid(Index) || 
 800c9c2:	b2c3      	uxtb	r3, r0
{
 800c9c4:	b089      	sub	sp, #36	; 0x24
 800c9c6:	0006      	movs	r6, r0
 800c9c8:	000d      	movs	r5, r1
  if (!LED_INDEX_IsValid(Index) || 
 800c9ca:	2b03      	cmp	r3, #3
 800c9cc:	d821      	bhi.n	800ca12 <Led_Set+0x52>
 800c9ce:	2909      	cmp	r1, #9
 800c9d0:	d81f      	bhi.n	800ca12 <Led_Set+0x52>
      !LED_MODE_IsValid(Mode) || 
 800c9d2:	2902      	cmp	r1, #2
 800c9d4:	d105      	bne.n	800c9e2 <Led_Set+0x22>
      !LED_PERIOD_IsValid(Mode, Period) )
 800c9d6:	0013      	movs	r3, r2
 800c9d8:	491e      	ldr	r1, [pc, #120]	; (800ca54 <Led_Set+0x94>)
 800c9da:	3b0a      	subs	r3, #10
 800c9dc:	b29b      	uxth	r3, r3
 800c9de:	428b      	cmp	r3, r1
 800c9e0:	d817      	bhi.n	800ca12 <Led_Set+0x52>
  pStatus->Count = 0;
 800c9e2:	2100      	movs	r1, #0
  pStatus->Mode = Mode;
 800c9e4:	4c1c      	ldr	r4, [pc, #112]	; (800ca58 <Led_Set+0x98>)
 800c9e6:	00f3      	lsls	r3, r6, #3
 800c9e8:	9301      	str	r3, [sp, #4]
  switch(Mode)
 800c9ea:	1e68      	subs	r0, r5, #1
  pStatus->Mode = Mode;
 800c9ec:	18e3      	adds	r3, r4, r3
 800c9ee:	705d      	strb	r5, [r3, #1]
  pStatus->Period = Period;
 800c9f0:	809a      	strh	r2, [r3, #4]
  pStatus->Count = 0;
 800c9f2:	80d9      	strh	r1, [r3, #6]
  switch(Mode)
 800c9f4:	2808      	cmp	r0, #8
 800c9f6:	d829      	bhi.n	800ca4c <Led_Set+0x8c>
 800c9f8:	f7f8 ffdc 	bl	80059b4 <__gnu_thumb1_case_uqi>
 800c9fc:	10100d05 	.word	0x10100d05
 800ca00:	10101010 	.word	0x10101010
 800ca04:	10          	.byte	0x10
 800ca05:	00          	.byte	0x00
 * @brief  Turn on a LED.
 * @param  cIndex: State Index
 */
void prvLedOn(LED_BSP_TypeDef Index)
{
  USBPD_BSP_LED_On(Index);
 800ca06:	0030      	movs	r0, r6
 800ca08:	f7fa faac 	bl	8006f64 <USBPD_BSP_LED_On>
  pStatus->ModePrevious = Mode;
 800ca0c:	9b01      	ldr	r3, [sp, #4]
 800ca0e:	18e4      	adds	r4, r4, r3
 800ca10:	70a5      	strb	r5, [r4, #2]
}
 800ca12:	b009      	add	sp, #36	; 0x24
 800ca14:	bdf0      	pop	{r4, r5, r6, r7, pc}
    pStatus->Count = pStatus->Period;
 800ca16:	00f3      	lsls	r3, r6, #3
 800ca18:	18e3      	adds	r3, r4, r3
 800ca1a:	80da      	strh	r2, [r3, #6]
    if (xLedThreadId == NULL)
 800ca1c:	4b0f      	ldr	r3, [pc, #60]	; (800ca5c <Led_Set+0x9c>)
 800ca1e:	681b      	ldr	r3, [r3, #0]
 800ca20:	469c      	mov	ip, r3
 800ca22:	2b00      	cmp	r3, #0
 800ca24:	d10d      	bne.n	800ca42 <Led_Set+0x82>
      osThreadDef(LEDThread, prvLedThread, LED_THREAD_PRIORITY, 0, configMINIMAL_STACK_SIZE);
 800ca26:	ab03      	add	r3, sp, #12
 800ca28:	9300      	str	r3, [sp, #0]
 800ca2a:	9a00      	ldr	r2, [sp, #0]
 800ca2c:	4b0c      	ldr	r3, [pc, #48]	; (800ca60 <Led_Set+0xa0>)
 800ca2e:	cb83      	ldmia	r3!, {r0, r1, r7}
 800ca30:	c283      	stmia	r2!, {r0, r1, r7}
 800ca32:	cb03      	ldmia	r3!, {r0, r1}
 800ca34:	c203      	stmia	r2!, {r0, r1}
      xLedThreadId = osThreadCreate(osThread(LEDThread), NULL);
 800ca36:	4661      	mov	r1, ip
 800ca38:	9800      	ldr	r0, [sp, #0]
 800ca3a:	f7fe ffcc 	bl	800b9d6 <osThreadCreate>
 800ca3e:	4b07      	ldr	r3, [pc, #28]	; (800ca5c <Led_Set+0x9c>)
 800ca40:	6018      	str	r0, [r3, #0]
    if (pStatus->ModePrevious != Mode)
 800ca42:	00f3      	lsls	r3, r6, #3
 800ca44:	18e3      	adds	r3, r4, r3
 800ca46:	789b      	ldrb	r3, [r3, #2]
 800ca48:	42ab      	cmp	r3, r5
 800ca4a:	d0df      	beq.n	800ca0c <Led_Set+0x4c>
 * @brief  Turn off a LED.
 * @param  cIndex: State Index
 */
void prvLedOff(LED_BSP_TypeDef Index)
{
  USBPD_BSP_LED_Off(Index);
 800ca4c:	0030      	movs	r0, r6
 800ca4e:	f7fa fa97 	bl	8006f80 <USBPD_BSP_LED_Off>
 800ca52:	e7db      	b.n	800ca0c <Led_Set+0x4c>
 800ca54:	00002706 	.word	0x00002706
 800ca58:	20001978 	.word	0x20001978
 800ca5c:	20001dc0 	.word	0x20001dc0
 800ca60:	0800ceac 	.word	0x0800ceac

0800ca64 <prvLedThread>:
{
 800ca64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    half_period = GlobalPeriod>>1;
 800ca66:	2401      	movs	r4, #1
  osDelay(100);
 800ca68:	2064      	movs	r0, #100	; 0x64
 800ca6a:	f7fe ffd2 	bl	800ba12 <osDelay>
    half_period = GlobalPeriod>>1;
 800ca6e:	4f2c      	ldr	r7, [pc, #176]	; (800cb20 <prvLedThread+0xbc>)
 800ca70:	883d      	ldrh	r5, [r7, #0]
 800ca72:	086d      	lsrs	r5, r5, #1
      if (LED_MODE_IsBlinking(pStatus->Mode))
 800ca74:	4e2b      	ldr	r6, [pc, #172]	; (800cb24 <prvLedThread+0xc0>)
 800ca76:	00e3      	lsls	r3, r4, #3
 800ca78:	3b07      	subs	r3, #7
 800ca7a:	5cf0      	ldrb	r0, [r6, r3]
 800ca7c:	1ec3      	subs	r3, r0, #3
 800ca7e:	2b06      	cmp	r3, #6
 800ca80:	d810      	bhi.n	800caa4 <prvLedThread+0x40>
        switch(pStatus->Mode)
 800ca82:	3804      	subs	r0, #4
 800ca84:	8c33      	ldrh	r3, [r6, #32]
 800ca86:	2805      	cmp	r0, #5
 800ca88:	d804      	bhi.n	800ca94 <prvLedThread+0x30>
 800ca8a:	f7f8 ff93 	bl	80059b4 <__gnu_thumb1_case_uqi>
 800ca8e:	1633      	.short	0x1633
 800ca90:	3e383328 	.word	0x3e383328
          prvLed((LED_BSP_TypeDef)i, (GlobalMap >> GlobalCount) & 0x01);
 800ca94:	6879      	ldr	r1, [r7, #4]
 * @brief  Turn on off a LED.
 * @param  cIndex: State Index
 */
void prvLed(LED_BSP_TypeDef Index, uint8_t Value)
{
  USBPD_BSP_LED_Set(Index, Value);
 800ca96:	1e60      	subs	r0, r4, #1
          prvLed((LED_BSP_TypeDef)i, (GlobalMap >> GlobalCount) & 0x01);
 800ca98:	40d9      	lsrs	r1, r3
  USBPD_BSP_LED_Set(Index, Value);
 800ca9a:	2301      	movs	r3, #1
 800ca9c:	b240      	sxtb	r0, r0
 800ca9e:	4019      	ands	r1, r3
 800caa0:	f7fa fa50 	bl	8006f44 <USBPD_BSP_LED_Set>
 800caa4:	3401      	adds	r4, #1
    for(i=0; i<LED_INDEX_LEN; i++)
 800caa6:	2c05      	cmp	r4, #5
 800caa8:	d1e4      	bne.n	800ca74 <prvLedThread+0x10>
    GlobalCount++;
 800caaa:	8c30      	ldrh	r0, [r6, #32]
    GlobalCount %= GlobalPeriod;
 800caac:	8839      	ldrh	r1, [r7, #0]
    GlobalCount++;
 800caae:	3001      	adds	r0, #1
    GlobalCount %= GlobalPeriod;
 800cab0:	b280      	uxth	r0, r0
 800cab2:	f7f9 f80f 	bl	8005ad4 <__aeabi_uidivmod>
 800cab6:	8431      	strh	r1, [r6, #32]
 800cab8:	e7d5      	b.n	800ca66 <prvLedThread+0x2>
          if (GlobalCount == 0 || GlobalCount == 3) 
 800caba:	2b00      	cmp	r3, #0
 800cabc:	d001      	beq.n	800cac2 <prvLedThread+0x5e>
 800cabe:	2b03      	cmp	r3, #3
 800cac0:	d104      	bne.n	800cacc <prvLedThread+0x68>
  USBPD_BSP_LED_On(Index);
 800cac2:	1e60      	subs	r0, r4, #1
 800cac4:	b240      	sxtb	r0, r0
 800cac6:	f7fa fa4d 	bl	8006f64 <USBPD_BSP_LED_On>
 800caca:	e7eb      	b.n	800caa4 <prvLedThread+0x40>
          else if (GlobalCount == 1 || GlobalCount == 4) 
 800cacc:	2b01      	cmp	r3, #1
 800cace:	d001      	beq.n	800cad4 <prvLedThread+0x70>
 800cad0:	2b04      	cmp	r3, #4
 800cad2:	d1e7      	bne.n	800caa4 <prvLedThread+0x40>
  USBPD_BSP_LED_Off(Index);
 800cad4:	1e60      	subs	r0, r4, #1
 800cad6:	b240      	sxtb	r0, r0
 800cad8:	f7fa fa52 	bl	8006f80 <USBPD_BSP_LED_Off>
 800cadc:	e7e2      	b.n	800caa4 <prvLedThread+0x40>
          if (GlobalCount == 0 || GlobalCount == 4 || GlobalCount == 8) 
 800cade:	001a      	movs	r2, r3
 800cae0:	2104      	movs	r1, #4
 800cae2:	438a      	bics	r2, r1
 800cae4:	d0ed      	beq.n	800cac2 <prvLedThread+0x5e>
 800cae6:	2b08      	cmp	r3, #8
 800cae8:	d0eb      	beq.n	800cac2 <prvLedThread+0x5e>
          else if (GlobalCount == 2 || GlobalCount == 6 || GlobalCount == 10) 
 800caea:	2a02      	cmp	r2, #2
 800caec:	d0f2      	beq.n	800cad4 <prvLedThread+0x70>
 800caee:	2b0a      	cmp	r3, #10
 800caf0:	d1d8      	bne.n	800caa4 <prvLedThread+0x40>
 800caf2:	e7ef      	b.n	800cad4 <prvLedThread+0x70>
          if (GlobalCount == 0) 
 800caf4:	2b00      	cmp	r3, #0
 800caf6:	d0e4      	beq.n	800cac2 <prvLedThread+0x5e>
          else if (GlobalCount == 2) 
 800caf8:	2b02      	cmp	r3, #2
 800cafa:	d1d3      	bne.n	800caa4 <prvLedThread+0x40>
 800cafc:	e7ea      	b.n	800cad4 <prvLedThread+0x70>
          else if (GlobalCount == (half_period+2)) 
 800cafe:	1caa      	adds	r2, r5, #2
          if (GlobalCount == half_period) 
 800cb00:	429d      	cmp	r5, r3
 800cb02:	d0de      	beq.n	800cac2 <prvLedThread+0x5e>
          else if (GlobalCount == (half_period+1) || GlobalCount == (half_period+4))
 800cb04:	4293      	cmp	r3, r2
 800cb06:	d1cd      	bne.n	800caa4 <prvLedThread+0x40>
 800cb08:	e7e4      	b.n	800cad4 <prvLedThread+0x70>
          if (GlobalCount == half_period || GlobalCount == (half_period+3)) 
 800cb0a:	429d      	cmp	r5, r3
 800cb0c:	d0d9      	beq.n	800cac2 <prvLedThread+0x5e>
 800cb0e:	1cea      	adds	r2, r5, #3
 800cb10:	4293      	cmp	r3, r2
 800cb12:	d0d6      	beq.n	800cac2 <prvLedThread+0x5e>
          else if (GlobalCount == (half_period+1) || GlobalCount == (half_period+4))
 800cb14:	1c6a      	adds	r2, r5, #1
 800cb16:	4293      	cmp	r3, r2
 800cb18:	d0dc      	beq.n	800cad4 <prvLedThread+0x70>
 800cb1a:	1d2a      	adds	r2, r5, #4
 800cb1c:	e7f2      	b.n	800cb04 <prvLedThread+0xa0>
 800cb1e:	46c0      	nop			; (mov r8, r8)
 800cb20:	2000023c 	.word	0x2000023c
 800cb24:	20001978 	.word	0x20001978

0800cb28 <__aeabi_memclr>:
 800cb28:	b510      	push	{r4, lr}
 800cb2a:	2200      	movs	r2, #0
 800cb2c:	f000 f801 	bl	800cb32 <__aeabi_memset>
 800cb30:	bd10      	pop	{r4, pc}

0800cb32 <__aeabi_memset>:
 800cb32:	0013      	movs	r3, r2
 800cb34:	b510      	push	{r4, lr}
 800cb36:	000a      	movs	r2, r1
 800cb38:	0019      	movs	r1, r3
 800cb3a:	f000 f838 	bl	800cbae <memset>
 800cb3e:	bd10      	pop	{r4, pc}

0800cb40 <__libc_init_array>:
 800cb40:	b570      	push	{r4, r5, r6, lr}
 800cb42:	2600      	movs	r6, #0
 800cb44:	4d0c      	ldr	r5, [pc, #48]	; (800cb78 <__libc_init_array+0x38>)
 800cb46:	4c0d      	ldr	r4, [pc, #52]	; (800cb7c <__libc_init_array+0x3c>)
 800cb48:	1b64      	subs	r4, r4, r5
 800cb4a:	10a4      	asrs	r4, r4, #2
 800cb4c:	42a6      	cmp	r6, r4
 800cb4e:	d109      	bne.n	800cb64 <__libc_init_array+0x24>
 800cb50:	2600      	movs	r6, #0
 800cb52:	f000 f8b7 	bl	800ccc4 <_init>
 800cb56:	4d0a      	ldr	r5, [pc, #40]	; (800cb80 <__libc_init_array+0x40>)
 800cb58:	4c0a      	ldr	r4, [pc, #40]	; (800cb84 <__libc_init_array+0x44>)
 800cb5a:	1b64      	subs	r4, r4, r5
 800cb5c:	10a4      	asrs	r4, r4, #2
 800cb5e:	42a6      	cmp	r6, r4
 800cb60:	d105      	bne.n	800cb6e <__libc_init_array+0x2e>
 800cb62:	bd70      	pop	{r4, r5, r6, pc}
 800cb64:	00b3      	lsls	r3, r6, #2
 800cb66:	58eb      	ldr	r3, [r5, r3]
 800cb68:	4798      	blx	r3
 800cb6a:	3601      	adds	r6, #1
 800cb6c:	e7ee      	b.n	800cb4c <__libc_init_array+0xc>
 800cb6e:	00b3      	lsls	r3, r6, #2
 800cb70:	58eb      	ldr	r3, [r5, r3]
 800cb72:	4798      	blx	r3
 800cb74:	3601      	adds	r6, #1
 800cb76:	e7f2      	b.n	800cb5e <__libc_init_array+0x1e>
 800cb78:	0800cee8 	.word	0x0800cee8
 800cb7c:	0800cee8 	.word	0x0800cee8
 800cb80:	0800cee8 	.word	0x0800cee8
 800cb84:	0800ceec 	.word	0x0800ceec

0800cb88 <malloc>:
 800cb88:	b510      	push	{r4, lr}
 800cb8a:	4b03      	ldr	r3, [pc, #12]	; (800cb98 <malloc+0x10>)
 800cb8c:	0001      	movs	r1, r0
 800cb8e:	6818      	ldr	r0, [r3, #0]
 800cb90:	f000 f816 	bl	800cbc0 <_malloc_r>
 800cb94:	bd10      	pop	{r4, pc}
 800cb96:	46c0      	nop			; (mov r8, r8)
 800cb98:	20000244 	.word	0x20000244

0800cb9c <memcpy>:
 800cb9c:	2300      	movs	r3, #0
 800cb9e:	b510      	push	{r4, lr}
 800cba0:	429a      	cmp	r2, r3
 800cba2:	d100      	bne.n	800cba6 <memcpy+0xa>
 800cba4:	bd10      	pop	{r4, pc}
 800cba6:	5ccc      	ldrb	r4, [r1, r3]
 800cba8:	54c4      	strb	r4, [r0, r3]
 800cbaa:	3301      	adds	r3, #1
 800cbac:	e7f8      	b.n	800cba0 <memcpy+0x4>

0800cbae <memset>:
 800cbae:	0003      	movs	r3, r0
 800cbb0:	1812      	adds	r2, r2, r0
 800cbb2:	4293      	cmp	r3, r2
 800cbb4:	d100      	bne.n	800cbb8 <memset+0xa>
 800cbb6:	4770      	bx	lr
 800cbb8:	7019      	strb	r1, [r3, #0]
 800cbba:	3301      	adds	r3, #1
 800cbbc:	e7f9      	b.n	800cbb2 <memset+0x4>
	...

0800cbc0 <_malloc_r>:
 800cbc0:	2303      	movs	r3, #3
 800cbc2:	b570      	push	{r4, r5, r6, lr}
 800cbc4:	1ccd      	adds	r5, r1, #3
 800cbc6:	439d      	bics	r5, r3
 800cbc8:	3508      	adds	r5, #8
 800cbca:	0006      	movs	r6, r0
 800cbcc:	2d0c      	cmp	r5, #12
 800cbce:	d21e      	bcs.n	800cc0e <_malloc_r+0x4e>
 800cbd0:	250c      	movs	r5, #12
 800cbd2:	42a9      	cmp	r1, r5
 800cbd4:	d81d      	bhi.n	800cc12 <_malloc_r+0x52>
 800cbd6:	0030      	movs	r0, r6
 800cbd8:	f000 f862 	bl	800cca0 <__malloc_lock>
 800cbdc:	4a25      	ldr	r2, [pc, #148]	; (800cc74 <_malloc_r+0xb4>)
 800cbde:	6814      	ldr	r4, [r2, #0]
 800cbe0:	0021      	movs	r1, r4
 800cbe2:	2900      	cmp	r1, #0
 800cbe4:	d119      	bne.n	800cc1a <_malloc_r+0x5a>
 800cbe6:	4c24      	ldr	r4, [pc, #144]	; (800cc78 <_malloc_r+0xb8>)
 800cbe8:	6823      	ldr	r3, [r4, #0]
 800cbea:	2b00      	cmp	r3, #0
 800cbec:	d103      	bne.n	800cbf6 <_malloc_r+0x36>
 800cbee:	0030      	movs	r0, r6
 800cbf0:	f000 f844 	bl	800cc7c <_sbrk_r>
 800cbf4:	6020      	str	r0, [r4, #0]
 800cbf6:	0029      	movs	r1, r5
 800cbf8:	0030      	movs	r0, r6
 800cbfa:	f000 f83f 	bl	800cc7c <_sbrk_r>
 800cbfe:	1c43      	adds	r3, r0, #1
 800cc00:	d12b      	bne.n	800cc5a <_malloc_r+0x9a>
 800cc02:	230c      	movs	r3, #12
 800cc04:	0030      	movs	r0, r6
 800cc06:	6033      	str	r3, [r6, #0]
 800cc08:	f000 f84b 	bl	800cca2 <__malloc_unlock>
 800cc0c:	e003      	b.n	800cc16 <_malloc_r+0x56>
 800cc0e:	2d00      	cmp	r5, #0
 800cc10:	dadf      	bge.n	800cbd2 <_malloc_r+0x12>
 800cc12:	230c      	movs	r3, #12
 800cc14:	6033      	str	r3, [r6, #0]
 800cc16:	2000      	movs	r0, #0
 800cc18:	bd70      	pop	{r4, r5, r6, pc}
 800cc1a:	680b      	ldr	r3, [r1, #0]
 800cc1c:	1b5b      	subs	r3, r3, r5
 800cc1e:	d419      	bmi.n	800cc54 <_malloc_r+0x94>
 800cc20:	2b0b      	cmp	r3, #11
 800cc22:	d903      	bls.n	800cc2c <_malloc_r+0x6c>
 800cc24:	600b      	str	r3, [r1, #0]
 800cc26:	18cc      	adds	r4, r1, r3
 800cc28:	6025      	str	r5, [r4, #0]
 800cc2a:	e003      	b.n	800cc34 <_malloc_r+0x74>
 800cc2c:	684b      	ldr	r3, [r1, #4]
 800cc2e:	428c      	cmp	r4, r1
 800cc30:	d10d      	bne.n	800cc4e <_malloc_r+0x8e>
 800cc32:	6013      	str	r3, [r2, #0]
 800cc34:	0030      	movs	r0, r6
 800cc36:	f000 f834 	bl	800cca2 <__malloc_unlock>
 800cc3a:	0020      	movs	r0, r4
 800cc3c:	2207      	movs	r2, #7
 800cc3e:	300b      	adds	r0, #11
 800cc40:	1d23      	adds	r3, r4, #4
 800cc42:	4390      	bics	r0, r2
 800cc44:	1ac3      	subs	r3, r0, r3
 800cc46:	d0e7      	beq.n	800cc18 <_malloc_r+0x58>
 800cc48:	425a      	negs	r2, r3
 800cc4a:	50e2      	str	r2, [r4, r3]
 800cc4c:	e7e4      	b.n	800cc18 <_malloc_r+0x58>
 800cc4e:	6063      	str	r3, [r4, #4]
 800cc50:	000c      	movs	r4, r1
 800cc52:	e7ef      	b.n	800cc34 <_malloc_r+0x74>
 800cc54:	000c      	movs	r4, r1
 800cc56:	6849      	ldr	r1, [r1, #4]
 800cc58:	e7c3      	b.n	800cbe2 <_malloc_r+0x22>
 800cc5a:	2303      	movs	r3, #3
 800cc5c:	1cc4      	adds	r4, r0, #3
 800cc5e:	439c      	bics	r4, r3
 800cc60:	42a0      	cmp	r0, r4
 800cc62:	d0e1      	beq.n	800cc28 <_malloc_r+0x68>
 800cc64:	1a21      	subs	r1, r4, r0
 800cc66:	0030      	movs	r0, r6
 800cc68:	f000 f808 	bl	800cc7c <_sbrk_r>
 800cc6c:	1c43      	adds	r3, r0, #1
 800cc6e:	d1db      	bne.n	800cc28 <_malloc_r+0x68>
 800cc70:	e7c7      	b.n	800cc02 <_malloc_r+0x42>
 800cc72:	46c0      	nop			; (mov r8, r8)
 800cc74:	200019c8 	.word	0x200019c8
 800cc78:	200019cc 	.word	0x200019cc

0800cc7c <_sbrk_r>:
 800cc7c:	2300      	movs	r3, #0
 800cc7e:	b570      	push	{r4, r5, r6, lr}
 800cc80:	4c06      	ldr	r4, [pc, #24]	; (800cc9c <_sbrk_r+0x20>)
 800cc82:	0005      	movs	r5, r0
 800cc84:	0008      	movs	r0, r1
 800cc86:	6023      	str	r3, [r4, #0]
 800cc88:	f000 f80c 	bl	800cca4 <_sbrk>
 800cc8c:	1c43      	adds	r3, r0, #1
 800cc8e:	d103      	bne.n	800cc98 <_sbrk_r+0x1c>
 800cc90:	6823      	ldr	r3, [r4, #0]
 800cc92:	2b00      	cmp	r3, #0
 800cc94:	d000      	beq.n	800cc98 <_sbrk_r+0x1c>
 800cc96:	602b      	str	r3, [r5, #0]
 800cc98:	bd70      	pop	{r4, r5, r6, pc}
 800cc9a:	46c0      	nop			; (mov r8, r8)
 800cc9c:	20001dc4 	.word	0x20001dc4

0800cca0 <__malloc_lock>:
 800cca0:	4770      	bx	lr

0800cca2 <__malloc_unlock>:
 800cca2:	4770      	bx	lr

0800cca4 <_sbrk>:
 800cca4:	4b05      	ldr	r3, [pc, #20]	; (800ccbc <_sbrk+0x18>)
 800cca6:	0002      	movs	r2, r0
 800cca8:	6819      	ldr	r1, [r3, #0]
 800ccaa:	2900      	cmp	r1, #0
 800ccac:	d101      	bne.n	800ccb2 <_sbrk+0xe>
 800ccae:	4904      	ldr	r1, [pc, #16]	; (800ccc0 <_sbrk+0x1c>)
 800ccb0:	6019      	str	r1, [r3, #0]
 800ccb2:	6818      	ldr	r0, [r3, #0]
 800ccb4:	1882      	adds	r2, r0, r2
 800ccb6:	601a      	str	r2, [r3, #0]
 800ccb8:	4770      	bx	lr
 800ccba:	46c0      	nop			; (mov r8, r8)
 800ccbc:	200019d0 	.word	0x200019d0
 800ccc0:	20001dc8 	.word	0x20001dc8

0800ccc4 <_init>:
 800ccc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ccc6:	46c0      	nop			; (mov r8, r8)
 800ccc8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800ccca:	bc08      	pop	{r3}
 800cccc:	469e      	mov	lr, r3
 800ccce:	4770      	bx	lr

0800ccd0 <_fini>:
 800ccd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ccd2:	46c0      	nop			; (mov r8, r8)
 800ccd4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800ccd6:	bc08      	pop	{r3}
 800ccd8:	469e      	mov	lr, r3
 800ccda:	4770      	bx	lr
